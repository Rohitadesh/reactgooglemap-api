/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Flenovo%2FDesktop%2Fgit%2Freactgooglemap-api%2Fsrc%2Fpages%2Findex.js&page=%2F!":
/*!********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Flenovo%2FDesktop%2Fgit%2Freactgooglemap-api%2Fsrc%2Fpages%2Findex.js&page=%2F! ***!
  \********************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./src/pages/index.js */ \"./src/pages/index.js\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD0lMkZob21lJTJGbGVub3ZvJTJGRGVza3RvcCUyRmdpdCUyRnJlYWN0Z29vZ2xlbWFwLWFwaSUyRnNyYyUyRnBhZ2VzJTJGaW5kZXguanMmcGFnZT0lMkYhIiwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsa0RBQXNCO0FBQzdDO0FBQ0E7QUFDQSxPQUFPLElBQVU7QUFDakIsTUFBTSxVQUFVO0FBQ2hCO0FBQ0EsT0FBTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz80MWY5Il0sInNvdXJjZXNDb250ZW50IjpbIlxuICAgICh3aW5kb3cuX19ORVhUX1AgPSB3aW5kb3cuX19ORVhUX1AgfHwgW10pLnB1c2goW1xuICAgICAgXCIvXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwiLi9zcmMvcGFnZXMvaW5kZXguanNcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL1wiXSlcbiAgICAgIH0pO1xuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Flenovo%2FDesktop%2Fgit%2Freactgooglemap-api%2Fsrc%2Fpages%2Findex.js&page=%2F!\n"));

/***/ }),

/***/ "./src/pages/componets/Home.js":
/*!*************************************!*\
  !*** ./src/pages/componets/Home.js ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ag_charts_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ag-charts-react */ \"./node_modules/ag-charts-react/dist/package/index.esm.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n\nvar _s = $RefreshSig$();\n\n\nconst HomeDashboard = ()=>{\n    _s();\n    const [chartOptions, setChartOptions] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({\n        data: [\n            {\n                month: \"Jan\",\n                avgTemp: 2.3,\n                iceCreamSales: 162000\n            },\n            {\n                month: \"Mar\",\n                avgTemp: 6.3,\n                iceCreamSales: 302000\n            },\n            {\n                month: \"May\",\n                avgTemp: 16.2,\n                iceCreamSales: 800000\n            },\n            {\n                month: \"Jul\",\n                avgTemp: 22.8,\n                iceCreamSales: 1254000\n            },\n            {\n                month: \"Sep\",\n                avgTemp: 14.5,\n                iceCreamSales: 950000\n            },\n            {\n                month: \"Nov\",\n                avgTemp: 8.9,\n                iceCreamSales: 200000\n            }\n        ],\n        series: [\n            {\n                type: \"bar\",\n                xKey: \"month\",\n                yKey: \"iceCreamSales\"\n            }\n        ]\n    });\n    const [pieChart, setPichart] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)({\n        data: [\n            {\n                asset: \"Stocks\",\n                amount: 60000\n            },\n            {\n                asset: \"Bonds\",\n                amount: 40000\n            },\n            {\n                asset: \"Cash\",\n                amount: 7000\n            },\n            {\n                asset: \"Real Estate\",\n                amount: 5000\n            },\n            {\n                asset: \"Commodities\",\n                amount: 3000\n            }\n        ],\n        series: [\n            {\n                type: \"pie\",\n                angleKey: \"amount\",\n                legendItemKey: \"amount\"\n            }\n        ]\n    });\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \" w-[90%] grid grid-rows-15 flex flex-col gap-12 \",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"row-span-5 rounded-md flex flex-row justify-center items-center\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"w-[70%] flex flex-col justify-center items-center    border rounded-md h-full\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ag_charts_react__WEBPACK_IMPORTED_MODULE_1__.AgCharts, {\n                                className: \"w-[90%]\",\n                                options: chartOptions\n                            }, void 0, false, {\n                                fileName: \"/home/lenovo/Desktop/git/reactgooglemap-api/src/pages/componets/Home.js\",\n                                lineNumber: 40,\n                                columnNumber: 25\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"/home/lenovo/Desktop/git/reactgooglemap-api/src/pages/componets/Home.js\",\n                            lineNumber: 39,\n                            columnNumber: 21\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"w-[30%] h-full border\"\n                        }, void 0, false, {\n                            fileName: \"/home/lenovo/Desktop/git/reactgooglemap-api/src/pages/componets/Home.js\",\n                            lineNumber: 42,\n                            columnNumber: 21\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/lenovo/Desktop/git/reactgooglemap-api/src/pages/componets/Home.js\",\n                    lineNumber: 38,\n                    columnNumber: 17\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"row-span-5 rounded-md flex flex-row justify-center items-center\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"w-[70%] flex flex-col justify-center items-center    border rounded-md h-full\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ag_charts_react__WEBPACK_IMPORTED_MODULE_1__.AgCharts, {\n                                className: \"w-[90%]\",\n                                options: chartOptions\n                            }, void 0, false, {\n                                fileName: \"/home/lenovo/Desktop/git/reactgooglemap-api/src/pages/componets/Home.js\",\n                                lineNumber: 46,\n                                columnNumber: 25\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"/home/lenovo/Desktop/git/reactgooglemap-api/src/pages/componets/Home.js\",\n                            lineNumber: 45,\n                            columnNumber: 21\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"w-[30%] h-full border\"\n                        }, void 0, false, {\n                            fileName: \"/home/lenovo/Desktop/git/reactgooglemap-api/src/pages/componets/Home.js\",\n                            lineNumber: 48,\n                            columnNumber: 21\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/lenovo/Desktop/git/reactgooglemap-api/src/pages/componets/Home.js\",\n                    lineNumber: 44,\n                    columnNumber: 17\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"row-span-5 rounded-md flex flex-row justify-center items-center\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"w-[70%] flex flex-col justify-center items-center    border rounded-md h-full\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(ag_charts_react__WEBPACK_IMPORTED_MODULE_1__.AgCharts, {\n                                className: \"w-[90%]\",\n                                options: chartOptions\n                            }, void 0, false, {\n                                fileName: \"/home/lenovo/Desktop/git/reactgooglemap-api/src/pages/componets/Home.js\",\n                                lineNumber: 52,\n                                columnNumber: 25\n                            }, undefined)\n                        }, void 0, false, {\n                            fileName: \"/home/lenovo/Desktop/git/reactgooglemap-api/src/pages/componets/Home.js\",\n                            lineNumber: 51,\n                            columnNumber: 21\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"w-[30%] h-full border\"\n                        }, void 0, false, {\n                            fileName: \"/home/lenovo/Desktop/git/reactgooglemap-api/src/pages/componets/Home.js\",\n                            lineNumber: 54,\n                            columnNumber: 21\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/lenovo/Desktop/git/reactgooglemap-api/src/pages/componets/Home.js\",\n                    lineNumber: 50,\n                    columnNumber: 17\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"/home/lenovo/Desktop/git/reactgooglemap-api/src/pages/componets/Home.js\",\n            lineNumber: 37,\n            columnNumber: 13\n        }, undefined)\n    }, void 0, false);\n};\n_s(HomeDashboard, \"AHTfkzCCL9SQP/AOr9UO/cqP+NE=\");\n_c = HomeDashboard;\n/* harmony default export */ __webpack_exports__[\"default\"] = (HomeDashboard);\nvar _c;\n$RefreshReg$(_c, \"HomeDashboard\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvY29tcG9uZXRzL0hvbWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBMkM7QUFDVjtBQUNqQyxNQUFNRSxnQkFBZ0I7O0lBRWxCLE1BQU0sQ0FBQ0MsY0FBY0MsZ0JBQWdCLEdBQUdILCtDQUFRQSxDQUFDO1FBRTdDSSxNQUFNO1lBQ0Y7Z0JBQUVDLE9BQU87Z0JBQU9DLFNBQVM7Z0JBQUtDLGVBQWU7WUFBTztZQUNwRDtnQkFBRUYsT0FBTztnQkFBT0MsU0FBUztnQkFBS0MsZUFBZTtZQUFPO1lBQ3BEO2dCQUFFRixPQUFPO2dCQUFPQyxTQUFTO2dCQUFNQyxlQUFlO1lBQU87WUFDckQ7Z0JBQUVGLE9BQU87Z0JBQU9DLFNBQVM7Z0JBQU1DLGVBQWU7WUFBUTtZQUN0RDtnQkFBRUYsT0FBTztnQkFBT0MsU0FBUztnQkFBTUMsZUFBZTtZQUFPO1lBQ3JEO2dCQUFFRixPQUFPO2dCQUFPQyxTQUFTO2dCQUFLQyxlQUFlO1lBQU87U0FDdkQ7UUFFREMsUUFBUTtZQUFDO2dCQUFFQyxNQUFNO2dCQUFPQyxNQUFNO2dCQUFTQyxNQUFNO1lBQWdCO1NBQUU7SUFDbkU7SUFFQSxNQUFLLENBQUNDLFVBQVNDLFdBQVcsR0FBQ2IsK0NBQVFBLENBQUM7UUFFaENJLE1BQU87WUFDSDtnQkFBRVUsT0FBTztnQkFBVUMsUUFBUTtZQUFNO1lBQ2pDO2dCQUFFRCxPQUFPO2dCQUFTQyxRQUFRO1lBQU07WUFDaEM7Z0JBQUVELE9BQU87Z0JBQVFDLFFBQVE7WUFBSztZQUM5QjtnQkFBRUQsT0FBTztnQkFBZUMsUUFBUTtZQUFLO1lBQ3JDO2dCQUFFRCxPQUFPO2dCQUFlQyxRQUFRO1lBQUs7U0FDdEM7UUFHSFAsUUFBUTtZQUFDO2dCQUFFQyxNQUFNO2dCQUFPTyxVQUFVO2dCQUFVQyxlQUFlO1lBQVM7U0FBRTtJQUMxRTtJQUlBLHFCQUNJO2tCQUNJLDRFQUFDQztZQUFJQyxXQUFVOzs4QkFDWCw4REFBQ0Q7b0JBQUlDLFdBQVU7O3NDQUNYLDhEQUFDRDs0QkFBSUMsV0FBVTtzQ0FDWCw0RUFBQ3BCLHFEQUFRQTtnQ0FBRW9CLFdBQVU7Z0NBQVVDLFNBQVNsQjs7Ozs7Ozs7Ozs7c0NBRTVDLDhEQUFDZ0I7NEJBQUlDLFdBQVU7Ozs7Ozs7Ozs7Ozs4QkFFbkIsOERBQUNEO29CQUFJQyxXQUFVOztzQ0FDWCw4REFBQ0Q7NEJBQUlDLFdBQVU7c0NBQ1gsNEVBQUNwQixxREFBUUE7Z0NBQUVvQixXQUFVO2dDQUFVQyxTQUFTbEI7Ozs7Ozs7Ozs7O3NDQUU1Qyw4REFBQ2dCOzRCQUFJQyxXQUFVOzs7Ozs7Ozs7Ozs7OEJBRW5CLDhEQUFDRDtvQkFBSUMsV0FBVTs7c0NBQ1gsOERBQUNEOzRCQUFJQyxXQUFVO3NDQUNYLDRFQUFDcEIscURBQVFBO2dDQUFFb0IsV0FBVTtnQ0FBVUMsU0FBU2xCOzs7Ozs7Ozs7OztzQ0FFNUMsOERBQUNnQjs0QkFBSUMsV0FBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU1uQztHQXpETWxCO0tBQUFBO0FBMkROLCtEQUFlQSxhQUFhQSxFQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9wYWdlcy9jb21wb25ldHMvSG9tZS5qcz81ZWJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFnQ2hhcnRzIH0gZnJvbSAnYWctY2hhcnRzLXJlYWN0JztcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuY29uc3QgSG9tZURhc2hib2FyZCA9ICgpID0+e1xuXG4gICAgY29uc3QgW2NoYXJ0T3B0aW9ucywgc2V0Q2hhcnRPcHRpb25zXSA9IHVzZVN0YXRlKHtcbiAgICAgIFxuICAgICAgICBkYXRhOiBbXG4gICAgICAgICAgICB7IG1vbnRoOiAnSmFuJywgYXZnVGVtcDogMi4zLCBpY2VDcmVhbVNhbGVzOiAxNjIwMDAgfSxcbiAgICAgICAgICAgIHsgbW9udGg6ICdNYXInLCBhdmdUZW1wOiA2LjMsIGljZUNyZWFtU2FsZXM6IDMwMjAwMCB9LFxuICAgICAgICAgICAgeyBtb250aDogJ01heScsIGF2Z1RlbXA6IDE2LjIsIGljZUNyZWFtU2FsZXM6IDgwMDAwMCB9LFxuICAgICAgICAgICAgeyBtb250aDogJ0p1bCcsIGF2Z1RlbXA6IDIyLjgsIGljZUNyZWFtU2FsZXM6IDEyNTQwMDAgfSxcbiAgICAgICAgICAgIHsgbW9udGg6ICdTZXAnLCBhdmdUZW1wOiAxNC41LCBpY2VDcmVhbVNhbGVzOiA5NTAwMDAgfSxcbiAgICAgICAgICAgIHsgbW9udGg6ICdOb3YnLCBhdmdUZW1wOiA4LjksIGljZUNyZWFtU2FsZXM6IDIwMDAwMCB9LFxuICAgICAgICBdLFxuICAgICAgXG4gICAgICAgIHNlcmllczogW3sgdHlwZTogJ2JhcicsIHhLZXk6ICdtb250aCcsIHlLZXk6ICdpY2VDcmVhbVNhbGVzJyB9XSxcbiAgICB9KTtcblxuICAgIGNvbnN0W3BpZUNoYXJ0LHNldFBpY2hhcnRdPXVzZVN0YXRlKHtcbiAgICAgICAgIFxuICAgICAgICBkYXRhOiAgW1xuICAgICAgICAgICAgeyBhc3NldDogXCJTdG9ja3NcIiwgYW1vdW50OiA2MDAwMCB9LFxuICAgICAgICAgICAgeyBhc3NldDogXCJCb25kc1wiLCBhbW91bnQ6IDQwMDAwIH0sXG4gICAgICAgICAgICB7IGFzc2V0OiBcIkNhc2hcIiwgYW1vdW50OiA3MDAwIH0sXG4gICAgICAgICAgICB7IGFzc2V0OiBcIlJlYWwgRXN0YXRlXCIsIGFtb3VudDogNTAwMCB9LFxuICAgICAgICAgICAgeyBhc3NldDogXCJDb21tb2RpdGllc1wiLCBhbW91bnQ6IDMwMDAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICBcbiAgICAgIFxuICAgICAgICBzZXJpZXM6IFt7IHR5cGU6ICdwaWUnLCBhbmdsZUtleTogJ2Ftb3VudCcsIGxlZ2VuZEl0ZW1LZXk6ICdhbW91bnQnIH1dLFxuICAgIH0pO1xuXG4gICAgXG5cbiAgICByZXR1cm4oXG4gICAgICAgIDw+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIiB3LVs5MCVdIGdyaWQgZ3JpZC1yb3dzLTE1IGZsZXggZmxleC1jb2wgZ2FwLTEyIFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93LXNwYW4tNSByb3VuZGVkLW1kIGZsZXggZmxleC1yb3cganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1bNzAlXSBmbGV4IGZsZXgtY29sIGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciAgICBib3JkZXIgcm91bmRlZC1tZCBoLWZ1bGxcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxBZ0NoYXJ0cyAgY2xhc3NOYW1lPSd3LVs5MCVdJyBvcHRpb25zPXtjaGFydE9wdGlvbnN9IC8+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctWzMwJV0gaC1mdWxsIGJvcmRlclwiPjwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93LXNwYW4tNSByb3VuZGVkLW1kIGZsZXggZmxleC1yb3cganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1bNzAlXSBmbGV4IGZsZXgtY29sIGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciAgICBib3JkZXIgcm91bmRlZC1tZCBoLWZ1bGxcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxBZ0NoYXJ0cyAgY2xhc3NOYW1lPSd3LVs5MCVdJyBvcHRpb25zPXtjaGFydE9wdGlvbnN9IC8+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctWzMwJV0gaC1mdWxsIGJvcmRlclwiPjwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93LXNwYW4tNSByb3VuZGVkLW1kIGZsZXggZmxleC1yb3cganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1bNzAlXSBmbGV4IGZsZXgtY29sIGp1c3RpZnktY2VudGVyIGl0ZW1zLWNlbnRlciAgICBib3JkZXIgcm91bmRlZC1tZCBoLWZ1bGxcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxBZ0NoYXJ0cyAgY2xhc3NOYW1lPSd3LVs5MCVdJyBvcHRpb25zPXtjaGFydE9wdGlvbnN9IC8+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctWzMwJV0gaC1mdWxsIGJvcmRlclwiPjwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICBcbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8Lz5cbiAgICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IEhvbWVEYXNoYm9hcmQiXSwibmFtZXMiOlsiQWdDaGFydHMiLCJ1c2VTdGF0ZSIsIkhvbWVEYXNoYm9hcmQiLCJjaGFydE9wdGlvbnMiLCJzZXRDaGFydE9wdGlvbnMiLCJkYXRhIiwibW9udGgiLCJhdmdUZW1wIiwiaWNlQ3JlYW1TYWxlcyIsInNlcmllcyIsInR5cGUiLCJ4S2V5IiwieUtleSIsInBpZUNoYXJ0Iiwic2V0UGljaGFydCIsImFzc2V0IiwiYW1vdW50IiwiYW5nbGVLZXkiLCJsZWdlbmRJdGVtS2V5IiwiZGl2IiwiY2xhc3NOYW1lIiwib3B0aW9ucyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pages/componets/Home.js\n"));

/***/ }),

/***/ "./src/pages/index.js":
/*!****************************!*\
  !*** ./src/pages/index.js ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _componets_Home__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./componets/Home */ \"./src/pages/componets/Home.js\");\n// import Image from \"next/image\";\n\n\n\nfunction Home() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_componets_Home__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {}, void 0, false, {\n        fileName: \"/home/lenovo/Desktop/git/reactgooglemap-api/src/pages/index.js\",\n        lineNumber: 10,\n        columnNumber: 4\n    }, this);\n}\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLGtDQUFrQzs7QUFLNUJBO0FBSHVDO0FBSzlCLFNBQVNFO0lBQ3RCLHFCQUNDLDhEQUFDRCx1REFBYUE7Ozs7O0FBRWpCO0tBSndCQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvcGFnZXMvaW5kZXguanM/NDA4MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBpbXBvcnQgSW1hZ2UgZnJvbSBcIm5leHQvaW1hZ2VcIjtcbmltcG9ydCB7IEludGVyIH0gZnJvbSBcIm5leHQvZm9udC9nb29nbGVcIjtcbmltcG9ydCBIb21lRGFzaGJvYXJkIGZyb20gXCIuL2NvbXBvbmV0cy9Ib21lXCI7XG4vLyBpbXBvcnQgbmF0dXJlIGZyb20gJy4uLy4uL3B1YmxpYy9uYXR1cmUubXA0J1xuXG5jb25zdCBpbnRlciA9IEludGVyKHsgc3Vic2V0czogW1wibGF0aW5cIl0gfSk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhvbWUoKSB7XG4gIHJldHVybiAoXG4gICA8SG9tZURhc2hib2FyZCAvPlxuICApO1xufVxuIl0sIm5hbWVzIjpbImludGVyIiwiSG9tZURhc2hib2FyZCIsIkhvbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/pages/index.js\n"));

/***/ }),

/***/ "./node_modules/ag-charts-community/dist/package/main.esm.mjs":
/*!********************************************************************!*\
  !*** ./node_modules/ag-charts-community/dist/package/main.esm.mjs ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AG_CHARTS_LOCALE_EN_US: function() { return /* binding */ AG_CHARTS_LOCALE_EN_US; },\n/* harmony export */   AgCharts: function() { return /* binding */ AgCharts; },\n/* harmony export */   AgErrorBarSupportedSeriesTypes: function() { return /* binding */ AgErrorBarSupportedSeriesTypes; },\n/* harmony export */   AgTooltipPositionType: function() { return /* binding */ AgTooltipPositionType; },\n/* harmony export */   ICONS_LEGACY: function() { return /* binding */ ICONS_LEGACY; },\n/* harmony export */   Marker: function() { return /* binding */ Marker; },\n/* harmony export */   VERSION: function() { return /* binding */ VERSION; },\n/* harmony export */   _ModuleSupport: function() { return /* binding */ module_support_exports; },\n/* harmony export */   _Scale: function() { return /* binding */ sparklines_scale_exports; },\n/* harmony export */   _Scene: function() { return /* binding */ integrated_charts_scene_exports; },\n/* harmony export */   _Theme: function() { return /* binding */ integrated_charts_theme_exports; },\n/* harmony export */   _Util: function() { return /* binding */ sparklines_util_exports; },\n/* harmony export */   time: function() { return /* binding */ time_exports; }\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result)\n    __defProp(target, key, result);\n  return result;\n};\n\n// packages/ag-charts-locale/src/en-US.ts\nvar AG_CHARTS_LOCALE_EN_US = {\n  // Screen reader announcement when the focused item becomes visible\n  ariaAnnounceVisible: \"visible\",\n  // Screen reader announcement when the focused item becomes hidden\n  ariaAnnounceHidden: \"hidden\",\n  // Screen reader announcement when focusing an item in the chart\n  ariaAnnounceHoverDatum: \"${datum}\",\n  // Screen reader announcement when focusing a chart\n  ariaAnnounceChart: \"chart, ${seriesCount}[number] series\",\n  // Screen reader announcement when focusing an item in a treemap or sunburst chart\n  ariaAnnounceHierarchyDatum: \"level ${level}[number], ${count}[number] children, ${description}\",\n  // Screen reader announcement when focusing a link in a Sankey or chord chart\n  ariaAnnounceFlowProportionLink: \"link ${index} of ${count}, from ${from} to ${to}, ${sizeName} ${size}\",\n  // Screen reader announcement when focusing a node in a Sankey or chord chart\n  ariaAnnounceFlowProportionNode: \"node ${index} of ${count}, ${description}\",\n  // Screen reader text for annotation-options toolbar\n  ariaLabelAnnotationOptionsToolbar: \"Annotation Options\",\n  // Screen reader text for the color picker dialog\n  ariaLabelColorPicker: \"Color picker\",\n  // Screen reader text for the financial charts toolbar\n  ariaLabelFinancialCharts: \"Financial Charts\",\n  // Screen reader text for the legend toolbar\n  ariaLabelLegend: \"Legend\",\n  // Screen reader text for the legend pagination button\n  ariaLabelLegendPagination: \"Legend Pagination\",\n  // Screen reader text for the previous legend page button\n  ariaLabelLegendPagePrevious: \"Previous Legend Page\",\n  // Screen reader text for the next legend page button\n  ariaLabelLegendPageNext: \"Next Legend Page\",\n  // Screen reader text for the an item in the legend\n  ariaLabelLegendItem: \"${label}, Legend item ${index}[number] of ${count}[number], \",\n  // Screen reader text for the an unknown item in the legend\n  ariaLabelLegendItemUnknown: \"Unknown legend item\",\n  // Screen reader text for the navigator element\n  ariaLabelNavigator: \"Navigator\",\n  // Screen reader text for an accessibility control that changes the position of the navigator's range\n  ariaLabelNavigatorRange: \"Range\",\n  // Screen reader text for an accessibility control that changes the start of the navigator's range\n  ariaLabelNavigatorMinimum: \"Minimum\",\n  // Screen reader text for an accessibility control that changes the end of the navigator's range\n  ariaLabelNavigatorMaximum: \"Maximum\",\n  // Screen reader text for ranges toolbar\n  ariaLabelRangesToolbar: \"Ranges\",\n  // Screen reader text for zoom toolbar\n  ariaLabelZoomToolbar: \"Zoom\",\n  // Screen reader text for the value of the navigator's range\n  ariaValuePanRange: \"${min}[percent] to ${max}[percent]\",\n  // Default text for the 'loading data' overlay\n  overlayLoadingData: \"Loading data...\",\n  // Default text for the 'no data' overlay\n  overlayNoData: \"No data to display\",\n  // Default text for the 'no visible series' overlay\n  overlayNoVisibleSeries: \"No visible series\",\n  // Text for the series type toolbar's chart type button\n  toolbarSeriesTypeDropdown: \"Chart Type\",\n  // Text for the series type toolbar's OHLC chart type button\n  toolbarSeriesTypeOHLC: \"OHLC\",\n  // Text for the series type toolbar's HLC chart type button\n  toolbarSeriesTypeHLC: \"HLC\",\n  // Text for the series type toolbar's high low chart type button\n  toolbarSeriesTypeHighLow: \"High Low\",\n  // Text for the series type toolbar's candles chart type button\n  toolbarSeriesTypeCandles: \"Candles\",\n  // Text for the series type toolbar's hollow candles chart type button\n  toolbarSeriesTypeHollowCandles: \"Hollow Candles\",\n  // Text for the series type toolbar's line chart type button\n  toolbarSeriesTypeLine: \"Line\",\n  // Text for the series type toolbar's line with markers chart type button\n  toolbarSeriesTypeLineWithMarkers: \"Line with Markers\",\n  // Text for the series type toolbar's line with step line chart type button\n  toolbarSeriesTypeStepLine: \"Step Line\",\n  // Text for the annotation toolbar's trend line button\n  toolbarAnnotationsTrendLine: \"Trend Line\",\n  // Text for the annotation toolbar's horizontal line button\n  toolbarAnnotationsHorizontalLine: \"Horizontal Line\",\n  // Text for the annotation toolbar's vertical line button\n  toolbarAnnotationsVerticalLine: \"Vertical Line\",\n  // Text for the annotation toolbar's parallel channel button\n  toolbarAnnotationsParallelChannel: \"Parallel Channel\",\n  // Text for the annotation toolbar's disjoint channel button\n  toolbarAnnotationsDisjointChannel: \"Disjoint Channel\",\n  // Text for the annotation toolbar's clear all button\n  toolbarAnnotationsClearAll: \"Clear All\",\n  /**\n   * Text for the annotation toolbar's color picker annotation button\n   * @deprecated v10.1.0 use `toolbarAnnotationsLineColor` instead.\n   */\n  toolbarAnnotationsColor: \"Color\",\n  // Text for the annotation toolbar's fill color picker annotation button\n  toolbarAnnotationsFillColor: \"Fill Color\",\n  // Text for the annotation toolbar's line color picker annotation button\n  toolbarAnnotationsLineColor: \"Line Color\",\n  // Text for the annotation toolbar's text color picker annotation button\n  toolbarAnnotationsTextColor: \"Text Color\",\n  // Text for the annotation toolbar's text size picker annotation button\n  toolbarAnnotationsTextSize: \"Text Size\",\n  // Text for the annotation toolbar's lock annotation button\n  toolbarAnnotationsLock: \"Lock\",\n  // Text for the annotation toolbar's unlock annotation button\n  toolbarAnnotationsUnlock: \"Unlock\",\n  // Text for the annotation toolbar's delete annotation button\n  toolbarAnnotationsDelete: \"Delete\",\n  // Text for the annotation toolbar's line annotations menu button\n  toolbarAnnotationsLineAnnotations: \"Trend Lines\",\n  // Text for the annotation toolbar's text annotations menu button\n  toolbarAnnotationsTextAnnotations: \"Text Annotations\",\n  // Text for the annotation toolbar's callout button\n  toolbarAnnotationsCallout: \"Callout\",\n  // Text for the annotation toolbar's comment button\n  toolbarAnnotationsComment: \"Comment\",\n  // Text for the annotation toolbar's note button\n  toolbarAnnotationsNote: \"Note\",\n  // Text for the annotation toolbar's text button\n  toolbarAnnotationsText: \"Text\",\n  // Text for the range toolbar's 1 month button\n  toolbarRange1Month: \"1M\",\n  // Aria label for the range toolbar's 1 month button\n  toolbarRange1MonthAria: \"1 month\",\n  // Text for the range toolbar's 3 month button\n  toolbarRange3Months: \"3M\",\n  // Aria label for the range toolbar's 3 month button\n  toolbarRange3MonthsAria: \"3 months\",\n  // Text for the range toolbar's 6 month button\n  toolbarRange6Months: \"6M\",\n  // Aria label for the range toolbar's 6 month button\n  toolbarRange6MonthsAria: \"6 months\",\n  // Text for the range toolbar's year to date button\n  toolbarRangeYearToDate: \"YTD\",\n  // Aria label for the range toolbar's year to date month button\n  toolbarRangeYearToDateAria: \"Year to date\",\n  // Text for the range toolbar's 1 year button\n  toolbarRange1Year: \"1Y\",\n  // Aria label for the range toolbar's 1 year button\n  toolbarRange1YearAria: \"1 year\",\n  // Text for the range toolbar's full range button\n  toolbarRangeAll: \"All\",\n  // Aria label for the range toolbar's full range button\n  toolbarRangeAllAria: \"All\",\n  // Text for the zoom toolbar's zoom out button\n  toolbarZoomZoomOut: \"Zoom out\",\n  // Text for the zoom toolbar's zoom in button\n  toolbarZoomZoomIn: \"Zoom in\",\n  // Text for the zoom toolbar's pan left button\n  toolbarZoomPanLeft: \"Pan left\",\n  // Text for the zoom toolbar's pan right button\n  toolbarZoomPanRight: \"Pan right\",\n  // Text for the zoom toolbar's pan to the start button\n  toolbarZoomPanStart: \"Pan to the start\",\n  // Text for the zoom toolbar's pan to the end button\n  toolbarZoomPanEnd: \"Pan to the end\",\n  // Text for the zoom toolbar's pan reset button\n  toolbarZoomReset: \"Reset the zoom\",\n  // Text for the context menu's download button\n  contextMenuDownload: \"Download\",\n  // Text for the context menu's toggle series visibility button\n  contextMenuToggleSeriesVisibility: \"Toggle Visibility\",\n  // Text for the context menu's toggle other series visibility button\n  contextMenuToggleOtherSeries: \"Toggle Other Series\",\n  // Text for the context menu's zoom to point button\n  contextMenuZoomToCursor: \"Zoom to here\",\n  // Text for the context menu's pan to point button\n  contextMenuPanToCursor: \"Pan to here\"\n};\n\n// packages/ag-charts-types/src/chart/errorBarOptions.ts\nvar AgErrorBarSupportedSeriesTypes = [\"bar\", \"line\", \"scatter\"];\n\n// packages/ag-charts-types/src/chart/navigatorOptions.ts\nvar __MINI_CHART_SERIES_OPTIONS = {};\nvar __VERIFY_MINI_CHART_SERIES_OPTIONS = void 0;\n__VERIFY_MINI_CHART_SERIES_OPTIONS = __MINI_CHART_SERIES_OPTIONS;\n\n// packages/ag-charts-types/src/chart/toolbarOptions.ts\nvar ICONS_LEGACY = [\n  \"delete-legacy\",\n  \"disjoint-channel\",\n  \"disjoint-channel-legacy\",\n  \"horizontal-line-legacy\",\n  \"line-color-legacy\",\n  \"lock\",\n  \"lock-legacy\",\n  \"pan-end-legacy\",\n  \"pan-left-legacy\",\n  \"pan-right-legacy\",\n  \"pan-start-legacy\",\n  \"parallel-channel\",\n  \"parallel-channel-legacy\",\n  \"reset-legacy\",\n  \"trend-line\",\n  \"trend-line-legacy\",\n  \"unlock\",\n  \"unlock-legacy\",\n  \"vertical-line\",\n  \"vertical-line-legacy\",\n  \"zoom-in-legacy\",\n  \"zoom-in-alt\",\n  \"zoom-in-alt-legacy\",\n  \"zoom-out-legacy\",\n  \"zoom-out-alt\",\n  \"zoom-out-alt-legacy\"\n];\n\n// packages/ag-charts-types/src/chart/tooltipOptions.ts\nvar AgTooltipPositionType = /* @__PURE__ */ ((AgTooltipPositionType2) => {\n  AgTooltipPositionType2[\"POINTER\"] = \"pointer\";\n  AgTooltipPositionType2[\"NODE\"] = \"node\";\n  AgTooltipPositionType2[\"TOP\"] = \"top\";\n  AgTooltipPositionType2[\"RIGHT\"] = \"right\";\n  AgTooltipPositionType2[\"BOTTOM\"] = \"bottom\";\n  AgTooltipPositionType2[\"LEFT\"] = \"left\";\n  AgTooltipPositionType2[\"TOP_LEFT\"] = \"top-left\";\n  AgTooltipPositionType2[\"TOP_RIGHT\"] = \"top-right\";\n  AgTooltipPositionType2[\"BOTTOM_RIGHT\"] = \"bottom-right\";\n  AgTooltipPositionType2[\"BOTTOM_LEFT\"] = \"bottom-left\";\n  return AgTooltipPositionType2;\n})(AgTooltipPositionType || {});\n\n// packages/ag-charts-types/src/chart/themeOptions.ts\nvar __THEME_OVERRIDES = {};\nvar __VERIFY_THEME_OVERRIDES = void 0;\n__VERIFY_THEME_OVERRIDES = __THEME_OVERRIDES;\n\n// packages/ag-charts-community/src/util/time/index.ts\nvar time_exports = {};\n__export(time_exports, {\n  TimeInterval: () => TimeInterval,\n  day: () => day,\n  friday: () => friday,\n  hour: () => hour,\n  millisecond: () => millisecond,\n  minute: () => minute,\n  monday: () => monday,\n  month: () => month,\n  saturday: () => saturday,\n  second: () => second,\n  sunday: () => sunday,\n  thursday: () => thursday,\n  tuesday: () => tuesday,\n  utcDay: () => utcDay,\n  utcHour: () => utcHour,\n  utcMinute: () => utcMinute,\n  utcMonth: () => utcMonth,\n  utcYear: () => utcYear,\n  wednesday: () => wednesday,\n  year: () => year\n});\n\n// packages/ag-charts-community/src/util/function.ts\nvar doOnceState = /* @__PURE__ */ new Map();\nfunction doOnce(func, key) {\n  if (doOnceState.has(key))\n    return;\n  doOnceState.set(key, true);\n  func();\n}\ndoOnce.clear = () => doOnceState.clear();\nfunction identity(x) {\n  return x;\n}\nfunction* iterate(...iterators) {\n  for (const iterator of iterators) {\n    yield* iterator;\n  }\n}\nfunction throttle(callback2, waitMs = 0, options) {\n  const { leading = true, trailing = true } = options ?? {};\n  let timerId;\n  let lastArgs;\n  let shouldWait = false;\n  function timeoutHandler() {\n    if (trailing && lastArgs) {\n      timerId = setTimeout(timeoutHandler, waitMs);\n      callback2(...lastArgs);\n    } else {\n      shouldWait = false;\n    }\n    lastArgs = null;\n  }\n  function throttleCallback(...args) {\n    if (shouldWait) {\n      lastArgs = args;\n    } else {\n      shouldWait = true;\n      timerId = setTimeout(timeoutHandler, waitMs);\n      if (leading) {\n        callback2(...args);\n      } else {\n        lastArgs = args;\n      }\n    }\n  }\n  return Object.assign(throttleCallback, {\n    cancel() {\n      clearTimeout(timerId);\n      shouldWait = false;\n      lastArgs = null;\n    }\n  });\n}\nfunction joinFunctions(...fns) {\n  return () => {\n    for (const fn of fns) {\n      fn();\n    }\n  };\n}\n\n// packages/ag-charts-community/src/util/logger.ts\nvar Logger = {\n  log(...logContent) {\n    console.log(...logContent);\n  },\n  warn(message, ...logContent) {\n    console.warn(`AG Charts - ${message}`, ...logContent);\n  },\n  error(message, ...logContent) {\n    if (typeof message === \"object\") {\n      console.error(`AG Charts error`, message, ...logContent);\n    } else {\n      console.error(`AG Charts - ${message}`, ...logContent);\n    }\n  },\n  table(...logContent) {\n    console.table(...logContent);\n  },\n  warnOnce(message, ...logContent) {\n    doOnce(() => Logger.warn(message, ...logContent), `Logger.warn: ${message}`);\n  },\n  errorOnce(message, ...logContent) {\n    doOnce(() => Logger.error(message, ...logContent), `Logger.error: ${message}`);\n  }\n};\n\n// packages/ag-charts-community/src/util/time/interval.ts\nvar TimeInterval = class {\n  constructor(_encode, _decode, _rangeCallback) {\n    this._encode = _encode;\n    this._decode = _decode;\n    this._rangeCallback = _rangeCallback;\n  }\n  /**\n   * Returns a new date representing the latest interval boundary date before or equal to date.\n   * For example, `day.floor(date)` typically returns 12:00 AM local time on the given date.\n   * @param date\n   */\n  floor(date) {\n    const d = new Date(date);\n    const e = this._encode(d);\n    return this._decode(e);\n  }\n  /**\n   * Returns a new date representing the earliest interval boundary date after or equal to date.\n   * @param date\n   */\n  ceil(date) {\n    const d = new Date(Number(date) - 1);\n    const e = this._encode(d);\n    return this._decode(e + 1);\n  }\n  /**\n   * Returns an array of dates representing every interval boundary after or equal to start (inclusive) and before stop (exclusive).\n   * @param start Range start.\n   * @param stop Range end.\n   * @param extend If specified, the requested range will be extended to the closest \"nice\" values.\n   */\n  range(start, stop, extend) {\n    const rangeCallback = this._rangeCallback?.(start, stop);\n    const e0 = this._encode(extend ? this.floor(start) : this.ceil(start));\n    const e1 = this._encode(extend ? this.ceil(stop) : this.floor(stop));\n    if (e1 < e0) {\n      return [];\n    }\n    const range3 = [];\n    for (let e = e0; e <= e1; e++) {\n      const d = this._decode(e);\n      range3.push(d);\n    }\n    rangeCallback?.();\n    return range3;\n  }\n};\nvar CountableTimeInterval = class extends TimeInterval {\n  getOffset(snapTo, step) {\n    const s = typeof snapTo === \"number\" || snapTo instanceof Date ? this._encode(new Date(snapTo)) : 0;\n    return Math.floor(s) % step;\n  }\n  /**\n   * Returns a filtered view of this interval representing every step'th date.\n   * It can be a number of minutes, hours, days etc.\n   * Must be a positive integer.\n   * @param step\n   */\n  every(step, options) {\n    let offset4 = 0;\n    let rangeCallback;\n    const unsafeStep = step;\n    step = Math.max(1, Math.round(step));\n    if (unsafeStep !== step) {\n      Logger.warnOnce(`interval step of [${unsafeStep}] rounded to [${step}].`);\n    }\n    const { snapTo = \"start\" } = options ?? {};\n    if (typeof snapTo === \"string\") {\n      const initialOffset = offset4;\n      rangeCallback = (start, stop) => {\n        const s = snapTo === \"start\" ? start : stop;\n        offset4 = this.getOffset(s, step);\n        return () => offset4 = initialOffset;\n      };\n    } else if (typeof snapTo === \"number\") {\n      offset4 = this.getOffset(new Date(snapTo), step);\n    } else if (snapTo instanceof Date) {\n      offset4 = this.getOffset(snapTo, step);\n    }\n    const encode13 = (date) => {\n      const e = this._encode(date);\n      return Math.floor((e - offset4) / step);\n    };\n    const decode13 = (encoded) => {\n      return this._decode(encoded * step + offset4);\n    };\n    return new TimeInterval(encode13, decode13, rangeCallback);\n  }\n};\n\n// packages/ag-charts-community/src/util/time/millisecond.ts\nfunction encode(date) {\n  return date.getTime();\n}\nfunction decode(encoded) {\n  return new Date(encoded);\n}\nvar millisecond = new CountableTimeInterval(encode, decode);\nvar millisecond_default = millisecond;\n\n// packages/ag-charts-community/src/util/time/duration.ts\nvar epochYear = (/* @__PURE__ */ new Date(0)).getFullYear();\nvar durationSecond = 1e3;\nvar durationMinute = durationSecond * 60;\nvar durationHour = durationMinute * 60;\nvar durationDay = durationHour * 24;\nvar durationWeek = durationDay * 7;\nvar durationMonth = durationDay * 30;\nvar durationYear = durationDay * 365;\n\n// packages/ag-charts-community/src/util/time/second.ts\nvar offset = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;\nfunction encode2(date) {\n  return Math.floor((date.getTime() - offset) / durationSecond);\n}\nfunction decode2(encoded) {\n  return new Date(offset + encoded * durationSecond);\n}\nvar second = new CountableTimeInterval(encode2, decode2);\nvar second_default = second;\n\n// packages/ag-charts-community/src/util/time/minute.ts\nvar offset2 = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;\nfunction encode3(date) {\n  return Math.floor((date.getTime() - offset2) / durationMinute);\n}\nfunction decode3(encoded) {\n  return new Date(offset2 + encoded * durationMinute);\n}\nvar minute = new CountableTimeInterval(encode3, decode3);\nvar minute_default = minute;\n\n// packages/ag-charts-community/src/util/time/hour.ts\nvar offset3 = (/* @__PURE__ */ new Date()).getTimezoneOffset() * durationMinute;\nfunction encode4(date) {\n  return Math.floor((date.getTime() - offset3) / durationHour);\n}\nfunction decode4(encoded) {\n  return new Date(offset3 + encoded * durationHour);\n}\nvar hour = new CountableTimeInterval(encode4, decode4);\nvar hour_default = hour;\n\n// packages/ag-charts-community/src/util/time/day.ts\nfunction encode5(date) {\n  const tzOffsetMs = date.getTimezoneOffset() * durationMinute;\n  return Math.floor((date.getTime() - tzOffsetMs) / durationDay);\n}\nfunction decode5(encoded) {\n  const d = new Date(1970, 0, 1);\n  d.setDate(d.getDate() + encoded);\n  return d;\n}\nvar day = new CountableTimeInterval(encode5, decode5);\nvar day_default = day;\n\n// packages/ag-charts-community/src/util/time/week.ts\nfunction weekday(weekStart) {\n  const thursday2 = 4;\n  const dayShift = (7 + weekStart - thursday2) % 7;\n  function encode13(date) {\n    const tzOffsetMs = date.getTimezoneOffset() * durationMinute;\n    return Math.floor((date.getTime() - tzOffsetMs) / durationWeek - dayShift / 7);\n  }\n  function decode13(encoded) {\n    const d = new Date(1970, 0, 1);\n    d.setDate(d.getDate() + encoded * 7 + dayShift);\n    return d;\n  }\n  return new CountableTimeInterval(encode13, decode13);\n}\nvar sunday = weekday(0);\nvar monday = weekday(1);\nvar tuesday = weekday(2);\nvar wednesday = weekday(3);\nvar thursday = weekday(4);\nvar friday = weekday(5);\nvar saturday = weekday(6);\nvar week_default = sunday;\n\n// packages/ag-charts-community/src/util/time/month.ts\nfunction encode6(date) {\n  return date.getFullYear() * 12 + date.getMonth();\n}\nfunction decode6(encoded) {\n  const year2 = Math.floor(encoded / 12);\n  const month2 = encoded - year2 * 12;\n  return new Date(year2, month2, 1);\n}\nvar month = new CountableTimeInterval(encode6, decode6);\nvar month_default = month;\n\n// packages/ag-charts-community/src/util/time/year.ts\nfunction encode7(date) {\n  return date.getFullYear();\n}\nfunction decode7(encoded) {\n  const d = /* @__PURE__ */ new Date();\n  d.setFullYear(encoded);\n  d.setMonth(0, 1);\n  d.setHours(0, 0, 0, 0);\n  return d;\n}\nvar year = new CountableTimeInterval(encode7, decode7);\nvar year_default = year;\n\n// packages/ag-charts-community/src/util/time/utcMinute.ts\nfunction encode8(date) {\n  return Math.floor(date.getTime() / durationMinute);\n}\nfunction decode8(encoded) {\n  return new Date(encoded * durationMinute);\n}\nvar utcMinute = new CountableTimeInterval(encode8, decode8);\n\n// packages/ag-charts-community/src/util/time/utcHour.ts\nfunction encode9(date) {\n  return Math.floor(date.getTime() / durationHour);\n}\nfunction decode9(encoded) {\n  return new Date(encoded * durationHour);\n}\nvar utcHour = new CountableTimeInterval(encode9, decode9);\n\n// packages/ag-charts-community/src/util/time/utcDay.ts\nfunction encode10(date) {\n  return Math.floor(date.getTime() / durationDay);\n}\nfunction decode10(encoded) {\n  const d = /* @__PURE__ */ new Date(0);\n  d.setUTCDate(d.getUTCDate() + encoded);\n  d.setUTCHours(0, 0, 0, 0);\n  return d;\n}\nvar utcDay = new CountableTimeInterval(encode10, decode10);\n\n// packages/ag-charts-community/src/util/time/utcMonth.ts\nfunction encode11(date) {\n  return date.getUTCFullYear() * 12 + date.getUTCMonth();\n}\nfunction decode11(encoded) {\n  const year2 = Math.floor(encoded / 12);\n  const month2 = encoded - year2 * 12;\n  return new Date(Date.UTC(year2, month2, 1));\n}\nvar utcMonth = new CountableTimeInterval(encode11, decode11);\n\n// packages/ag-charts-community/src/util/time/utcYear.ts\nfunction encode12(date) {\n  return date.getUTCFullYear();\n}\nfunction decode12(encoded) {\n  const d = /* @__PURE__ */ new Date();\n  d.setUTCFullYear(encoded);\n  d.setUTCMonth(0, 1);\n  d.setUTCHours(0, 0, 0, 0);\n  return d;\n}\nvar utcYear = new CountableTimeInterval(encode12, decode12);\n\n// packages/ag-charts-community/src/motion/fromToMotion.ts\nvar fromToMotion_exports = {};\n__export(fromToMotion_exports, {\n  NODE_UPDATE_STATE_TO_PHASE_MAPPING: () => NODE_UPDATE_STATE_TO_PHASE_MAPPING,\n  fromToMotion: () => fromToMotion,\n  staticFromToMotion: () => staticFromToMotion\n});\n\n// packages/ag-charts-community/src/util/id.ts\nvar ID_MAP = /* @__PURE__ */ new Map();\nfunction resetIds() {\n  ID_MAP.clear();\n}\nfunction createId(instance) {\n  const constructor = instance.constructor;\n  const className = Object.hasOwn(constructor, \"className\") ? constructor.className : constructor.name;\n  if (!className) {\n    throw new Error(`The ${constructor} is missing the 'className' property.`);\n  }\n  const nextId = (ID_MAP.get(className) ?? 0) + 1;\n  ID_MAP.set(className, nextId);\n  return `${className}-${nextId}`;\n}\nfunction uuid() {\n  const url = URL.createObjectURL(new Blob());\n  return url.split(\"/\").at(-1);\n}\n\n// packages/ag-charts-community/src/util/iterator.ts\nfunction toIterable(value) {\n  if (typeof value !== \"object\" || value == null || !(Symbol.iterator in value)) {\n    return argsIterable(value);\n  }\n  return value;\n}\nfunction* arraysIterable(...arrays) {\n  for (const array2 of arrays) {\n    for (const e of array2) {\n      yield e;\n    }\n  }\n}\nfunction* argsIterable(...args) {\n  for (const arg of args) {\n    yield arg;\n  }\n}\n\n// packages/ag-charts-community/src/util/interpolating.ts\nvar interpolate = \"$interpolate\";\nvar isInterpolating = (x) => x[interpolate] != null;\n\n// packages/ag-charts-community/src/util/nearest.ts\nfunction nearestSquared(x, y, objects, maxDistanceSquared = Infinity) {\n  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };\n  for (const obj of objects) {\n    const thisDistance = obj.distanceSquared(x, y);\n    if (thisDistance === 0) {\n      return { nearest: obj, distanceSquared: 0 };\n    } else if (thisDistance < result.distanceSquared) {\n      result.nearest = obj;\n      result.distanceSquared = thisDistance;\n    }\n  }\n  return result;\n}\nfunction nearestSquaredInContainer(x, y, container, maxDistanceSquared = Infinity) {\n  const { x: tx, y: ty } = container.transformPoint(x, y);\n  const result = { nearest: void 0, distanceSquared: maxDistanceSquared };\n  for (const child of container.children) {\n    const { nearest, distanceSquared: distanceSquared3 } = child.nearestSquared(tx, ty, result.distanceSquared);\n    if (distanceSquared3 === 0) {\n      return { nearest, distanceSquared: distanceSquared3 };\n    } else if (distanceSquared3 < result.distanceSquared) {\n      result.nearest = nearest;\n      result.distanceSquared = distanceSquared3;\n    }\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/util/number.ts\nfunction clamp(min, value, max) {\n  return Math.min(max, Math.max(min, value));\n}\nfunction clampArray(value, array2) {\n  const [min, max] = findMinMax(array2);\n  return clamp(min, value, max);\n}\nfunction findMinMax(array2) {\n  if (array2.length === 0)\n    return [];\n  const result = [Infinity, -Infinity];\n  for (const val of array2) {\n    if (val < result[0])\n      result[0] = val;\n    if (val > result[1])\n      result[1] = val;\n  }\n  return result;\n}\nfunction findRangeExtent(array2) {\n  const [min, max] = findMinMax(array2);\n  return max - min;\n}\nfunction isEqual(a, b, epsilon2 = 1e-10) {\n  return Math.abs(a - b) < epsilon2;\n}\nfunction isNegative(value) {\n  return Math.sign(value) === -1 || Object.is(value, -0);\n}\nfunction round(value, decimals = 2) {\n  const base = 10 ** decimals;\n  return Math.round(value * base) / base;\n}\nfunction toFixed(value, fractionOrSignificantDigits = 2) {\n  const power = Math.floor(Math.log(Math.abs(value)) / Math.LN10);\n  if (power >= 0 || !isFinite(power)) {\n    return value.toFixed(fractionOrSignificantDigits);\n  }\n  return value.toFixed(Math.abs(power) - 1 + fractionOrSignificantDigits);\n}\nfunction mod(n, m) {\n  return Math.floor(n % m + (n < 0 ? m : 0));\n}\nfunction countFractionDigits(value) {\n  if (Math.floor(value) === value)\n    return 0;\n  return String(value).split(\".\")[1]?.length ?? 0;\n}\nfunction formatNormalizedPercentage(ratio2, locale) {\n  locale = locale ?? navigator.language;\n  return new Intl.NumberFormat(locale, { style: \"percent\" }).format(ratio2);\n}\nfunction formatPercentage(percent, locale) {\n  return formatNormalizedPercentage(percent / 100, locale);\n}\n\n// packages/ag-charts-community/src/scene/bbox.ts\nvar _BBox = class _BBox {\n  constructor(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n  static fromDOMRect({ x, y, width, height }) {\n    return new _BBox(x, y, width, height);\n  }\n  toDOMRect() {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height,\n      top: this.y,\n      left: this.x,\n      right: this.x + this.width,\n      bottom: this.y + this.height,\n      toJSON() {\n        return {};\n      }\n    };\n  }\n  clone() {\n    const { x, y, width, height } = this;\n    return new _BBox(x, y, width, height);\n  }\n  equals(other) {\n    return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;\n  }\n  containsPoint(x, y) {\n    return x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;\n  }\n  intersection(other) {\n    if (!this.collidesBBox(other))\n      return;\n    const newX1 = clamp(other.x, this.x, other.x + other.width);\n    const newY1 = clamp(other.y, this.y, other.y + other.height);\n    const newX2 = clamp(other.x, this.x + this.width, other.x + other.width);\n    const newY2 = clamp(other.y, this.y + this.height, other.y + other.height);\n    return new _BBox(newX1, newY1, newX2 - newX1, newY2 - newY1);\n  }\n  collidesBBox(other) {\n    return this.x < other.x + other.width && this.x + this.width > other.x && this.y < other.y + other.height && this.y + this.height > other.y;\n  }\n  computeCenter() {\n    return { x: this.x + this.width / 2, y: this.y + this.height / 2 };\n  }\n  isFinite() {\n    return Number.isFinite(this.x) && Number.isFinite(this.y) && Number.isFinite(this.width) && Number.isFinite(this.height);\n  }\n  distanceSquared(x, y) {\n    if (this.containsPoint(x, y)) {\n      return 0;\n    }\n    const dx = x - clamp(this.x, x, this.x + this.width);\n    const dy = y - clamp(this.y, y, this.y + this.height);\n    return dx * dx + dy * dy;\n  }\n  static nearestBox(x, y, boxes) {\n    return nearestSquared(x, y, boxes);\n  }\n  clip(clipRect) {\n    if (clipRect === void 0)\n      return this;\n    const x1 = Math.max(this.x, clipRect.x);\n    const y1 = Math.max(this.y, clipRect.y);\n    const x2 = Math.min(this.x + this.width, clipRect.x + clipRect.width);\n    const y2 = Math.min(this.y + this.height, clipRect.y + clipRect.height);\n    this.x = x1;\n    this.y = y1;\n    this.width = Math.max(0, x2 - x1);\n    this.height = Math.max(0, y2 - y1);\n    return this;\n  }\n  shrink(amount, position) {\n    const apply2 = (pos, amt) => {\n      switch (pos) {\n        case \"top\":\n          this.y += amt;\n        case \"bottom\":\n          this.height -= amt;\n          break;\n        case \"left\":\n          this.x += amt;\n        case \"right\":\n          this.width -= amt;\n          break;\n        case \"vertical\":\n          this.y += amt;\n          this.height -= amt * 2;\n          break;\n        case \"horizontal\":\n          this.x += amt;\n          this.width -= amt * 2;\n          break;\n        case void 0:\n          this.x += amt;\n          this.width -= amt * 2;\n          this.y += amt;\n          this.height -= amt * 2;\n          break;\n        default:\n      }\n    };\n    if (typeof amount === \"number\") {\n      apply2(position, amount);\n    } else if (typeof amount === \"object\") {\n      Object.entries(amount).forEach(([pos, amt]) => apply2(pos, amt));\n    }\n    return this;\n  }\n  grow(amount, position) {\n    if (typeof amount === \"number\") {\n      this.shrink(-amount, position);\n    } else {\n      const paddingCopy = { ...amount };\n      for (const key in paddingCopy) {\n        paddingCopy[key] *= -1;\n      }\n      this.shrink(paddingCopy);\n    }\n    return this;\n  }\n  translate(x, y) {\n    this.x += x;\n    this.y += y;\n    return this;\n  }\n  combine(other) {\n    const { x, y, width, height } = this;\n    this.x = Math.min(x, other.x);\n    this.y = Math.min(y, other.y);\n    this.width = Math.max(x + width, other.x + other.width) - this.x;\n    this.height = Math.max(y + height, other.y + other.height) - this.y;\n  }\n  static merge(boxes) {\n    let left = Infinity;\n    let top = Infinity;\n    let right = -Infinity;\n    let bottom = -Infinity;\n    for (const box of boxes) {\n      if (box.x < left) {\n        left = box.x;\n      }\n      if (box.y < top) {\n        top = box.y;\n      }\n      if (box.x + box.width > right) {\n        right = box.x + box.width;\n      }\n      if (box.y + box.height > bottom) {\n        bottom = box.y + box.height;\n      }\n    }\n    return new _BBox(left, top, right - left, bottom - top);\n  }\n  [interpolate](other, d) {\n    return new _BBox(\n      this.x * (1 - d) + other.x * d,\n      this.y * (1 - d) + other.y * d,\n      this.width * (1 - d) + other.width * d,\n      this.height * (1 - d) + other.height * d\n    );\n  }\n};\n_BBox.zero = Object.freeze(new _BBox(0, 0, 0, 0));\n_BBox.NaN = Object.freeze(new _BBox(NaN, NaN, NaN, NaN));\nvar BBox = _BBox;\n\n// packages/ag-charts-community/src/scene/changeDetectable.ts\nvar RedrawType = /* @__PURE__ */ ((RedrawType2) => {\n  RedrawType2[RedrawType2[\"NONE\"] = 0] = \"NONE\";\n  RedrawType2[RedrawType2[\"TRIVIAL\"] = 1] = \"TRIVIAL\";\n  RedrawType2[RedrawType2[\"MINOR\"] = 2] = \"MINOR\";\n  RedrawType2[RedrawType2[\"MAJOR\"] = 3] = \"MAJOR\";\n  return RedrawType2;\n})(RedrawType || {});\nfunction SceneChangeDetection(opts) {\n  return function(target, key) {\n    const privateKey = `__${key}`;\n    if (target[key]) {\n      return;\n    }\n    prepareGetSet(target, key, privateKey, opts);\n  };\n}\nfunction prepareGetSet(target, key, privateKey, opts) {\n  const {\n    redraw = 1 /* TRIVIAL */,\n    type = \"normal\",\n    changeCb,\n    convertor,\n    checkDirtyOnAssignment = false\n  } = opts ?? {};\n  const requiredOpts = { redraw, type, changeCb, checkDirtyOnAssignment, convertor };\n  let setter;\n  switch (type) {\n    case \"normal\":\n      setter = buildNormalSetter(privateKey, requiredOpts);\n      break;\n    case \"transform\":\n      setter = buildTransformSetter(privateKey, requiredOpts);\n      break;\n    case \"path\":\n      setter = buildPathSetter(privateKey, requiredOpts);\n      break;\n    case \"font\":\n      setter = buildFontSetter(privateKey, requiredOpts);\n      break;\n  }\n  setter = buildCheckDirtyChain(\n    buildChangeCallbackChain(buildConvertorChain(setter, requiredOpts), requiredOpts),\n    requiredOpts\n  );\n  const getter = function() {\n    return this[privateKey];\n  };\n  Object.defineProperty(target, key, {\n    set: setter,\n    get: getter,\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction buildConvertorChain(setterFn, opts) {\n  const { convertor } = opts;\n  if (convertor) {\n    return function(value) {\n      setterFn.call(this, convertor(value));\n    };\n  }\n  return setterFn;\n}\nvar NO_CHANGE = Symbol(\"no-change\");\nfunction buildChangeCallbackChain(setterFn, opts) {\n  const { changeCb } = opts;\n  if (changeCb) {\n    return function(value) {\n      const change = setterFn.call(this, value);\n      if (change !== NO_CHANGE) {\n        changeCb.call(this, this);\n      }\n      return change;\n    };\n  }\n  return setterFn;\n}\nfunction buildCheckDirtyChain(setterFn, opts) {\n  const { checkDirtyOnAssignment } = opts;\n  if (checkDirtyOnAssignment) {\n    return function(value) {\n      const change = setterFn.call(this, value);\n      if (change !== NO_CHANGE && value != null && value._dirty > 0 /* NONE */) {\n        this.markDirty(value, value._dirty);\n      }\n      return change;\n    };\n  }\n  return setterFn;\n}\nfunction buildNormalSetter(privateKey, opts) {\n  const { redraw = 1 /* TRIVIAL */, changeCb } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      this.markDirty(this, redraw);\n      changeCb?.(this);\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\nfunction buildTransformSetter(privateKey, opts) {\n  const { redraw = 1 /* TRIVIAL */ } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      this.markDirtyTransform(redraw);\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\nfunction buildPathSetter(privateKey, opts) {\n  const { redraw = 1 /* TRIVIAL */ } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      if (!this._dirtyPath) {\n        this._dirtyPath = true;\n        this.markDirty(this, redraw);\n      }\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\nfunction buildFontSetter(privateKey, opts) {\n  const { redraw = 1 /* TRIVIAL */ } = opts;\n  return function(value) {\n    const oldValue = this[privateKey];\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      if (!this._dirtyFont) {\n        this._dirtyFont = true;\n        this.markDirty(this, redraw);\n      }\n      return value;\n    }\n    return NO_CHANGE;\n  };\n}\nvar ChangeDetectable = class {\n  constructor() {\n    this._dirty = 3 /* MAJOR */;\n  }\n  markDirty(_source, type = 1 /* TRIVIAL */) {\n    if (this._dirty < type) {\n      this._dirty = type;\n    }\n  }\n  markClean(_opts) {\n    this._dirty = 0 /* NONE */;\n  }\n  isDirty() {\n    return this._dirty > 0 /* NONE */;\n  }\n};\n\n// packages/ag-charts-community/src/scene/matrix.ts\nvar _Matrix = class _Matrix {\n  get e() {\n    return [...this.elements];\n  }\n  constructor(elements3 = [1, 0, 0, 1, 0, 0]) {\n    this.elements = elements3;\n  }\n  setElements(elements3) {\n    const e = this.elements;\n    e[0] = elements3[0];\n    e[1] = elements3[1];\n    e[2] = elements3[2];\n    e[3] = elements3[3];\n    e[4] = elements3[4];\n    e[5] = elements3[5];\n    return this;\n  }\n  get identity() {\n    const e = this.elements;\n    return e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 1 && e[4] === 0 && e[5] === 0;\n  }\n  /**\n   * Performs the AxB matrix multiplication and saves the result\n   * to `C`, if given, or to `A` otherwise.\n   */\n  AxB(A, B, C) {\n    const a = A[0] * B[0] + A[2] * B[1], b = A[1] * B[0] + A[3] * B[1], c = A[0] * B[2] + A[2] * B[3], d = A[1] * B[2] + A[3] * B[3], e = A[0] * B[4] + A[2] * B[5] + A[4], f = A[1] * B[4] + A[3] * B[5] + A[5];\n    C = C ?? A;\n    C[0] = a;\n    C[1] = b;\n    C[2] = c;\n    C[3] = d;\n    C[4] = e;\n    C[5] = f;\n  }\n  /**\n   * The `other` matrix gets post-multiplied to the current matrix.\n   * Returns the current matrix.\n   * @param other\n   */\n  multiplySelf(other) {\n    this.AxB(this.elements, other.elements);\n    return this;\n  }\n  /**\n   * The `other` matrix gets post-multiplied to the current matrix.\n   * Returns a new matrix.\n   * @param other\n   */\n  multiply(other) {\n    const elements3 = new Array(6);\n    this.AxB(this.elements, other.elements, elements3);\n    return new _Matrix(elements3);\n  }\n  preMultiplySelf(other) {\n    this.AxB(other.elements, this.elements, this.elements);\n    return this;\n  }\n  /**\n   * Returns the inverse of this matrix as a new matrix.\n   */\n  inverse() {\n    const el = this.elements;\n    let a = el[0], b = el[1], c = el[2], d = el[3];\n    const e = el[4], f = el[5];\n    const rD = 1 / (a * d - b * c);\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    return new _Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n  }\n  /**\n   * Save the inverse of this matrix to the given matrix.\n   */\n  inverseTo(other) {\n    const el = this.elements;\n    let a = el[0], b = el[1], c = el[2], d = el[3];\n    const e = el[4], f = el[5];\n    const rD = 1 / (a * d - b * c);\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    other.setElements([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n    return this;\n  }\n  invertSelf() {\n    const el = this.elements;\n    let a = el[0], b = el[1], c = el[2], d = el[3];\n    const e = el[4], f = el[5];\n    const rD = 1 / (a * d - b * c);\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    el[0] = d;\n    el[1] = -b;\n    el[2] = -c;\n    el[3] = a;\n    el[4] = c * f - d * e;\n    el[5] = b * e - a * f;\n    return this;\n  }\n  transformPoint(x, y) {\n    const e = this.elements;\n    return {\n      x: x * e[0] + y * e[2] + e[4],\n      y: x * e[1] + y * e[3] + e[5]\n    };\n  }\n  transformBBox(bbox, target) {\n    const el = this.elements;\n    const xx = el[0];\n    const xy = el[1];\n    const yx = el[2];\n    const yy = el[3];\n    const h_w = bbox.width * 0.5;\n    const h_h = bbox.height * 0.5;\n    const cx = bbox.x + h_w;\n    const cy = bbox.y + h_h;\n    const w = Math.abs(h_w * xx) + Math.abs(h_h * yx);\n    const h = Math.abs(h_w * xy) + Math.abs(h_h * yy);\n    target ?? (target = new BBox(0, 0, 0, 0));\n    target.x = cx * xx + cy * yx + el[4] - w;\n    target.y = cx * xy + cy * yy + el[5] - h;\n    target.width = w + w;\n    target.height = h + h;\n    return target;\n  }\n  toContext(ctx) {\n    if (this.identity) {\n      return;\n    }\n    const e = this.elements;\n    ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);\n  }\n  static flyweight(sourceMatrix) {\n    return _Matrix.instance.setElements(sourceMatrix.elements);\n  }\n  static updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, opts) {\n    const sx = scalingX;\n    const sy = scalingY;\n    let scx;\n    let scy;\n    if (sx === 1 && sy === 1) {\n      scx = 0;\n      scy = 0;\n    } else {\n      scx = opts?.scalingCenterX ?? 0;\n      scy = opts?.scalingCenterY ?? 0;\n    }\n    const r = rotation;\n    const cos = Math.cos(r);\n    const sin = Math.sin(r);\n    let rcx;\n    let rcy;\n    if (r === 0) {\n      rcx = 0;\n      rcy = 0;\n    } else {\n      rcx = opts?.rotationCenterX ?? 0;\n      rcy = opts?.rotationCenterY ?? 0;\n    }\n    const tx = translationX;\n    const ty = translationY;\n    const tx4 = scx * (1 - sx) - rcx;\n    const ty4 = scy * (1 - sy) - rcy;\n    matrix.setElements([\n      cos * sx,\n      sin * sx,\n      -sin * sy,\n      cos * sy,\n      cos * tx4 - sin * ty4 + rcx + tx,\n      sin * tx4 + cos * ty4 + rcy + ty\n    ]);\n    return matrix;\n  }\n  static fromContext(ctx) {\n    const domMatrix = ctx.getTransform();\n    return new _Matrix([domMatrix.a, domMatrix.b, domMatrix.c, domMatrix.d, domMatrix.e, domMatrix.f]);\n  }\n};\n_Matrix.instance = new _Matrix();\nvar Matrix = _Matrix;\n\n// packages/ag-charts-community/src/scene/node.ts\nvar PointerEvents = /* @__PURE__ */ ((PointerEvents2) => {\n  PointerEvents2[PointerEvents2[\"All\"] = 0] = \"All\";\n  PointerEvents2[PointerEvents2[\"None\"] = 1] = \"None\";\n  return PointerEvents2;\n})(PointerEvents || {});\nvar _Node = class _Node extends ChangeDetectable {\n  constructor({ isVirtual, tag, zIndex, name } = {}) {\n    super();\n    /** Unique number to allow creation order to be easily determined. */\n    this.serialNumber = _Node._nextSerialNumber++;\n    /**\n     * Unique node ID in the form `ClassName-NaturalNumber`.\n     */\n    this.id = createId(this);\n    /**\n     * To simplify the type system (especially in Selections) we don't have the `Parent` node\n     * (one that has children). Instead, we mimic HTML DOM, where any node can have children.\n     * But we still need to distinguish regular leaf nodes from container leafs somehow.\n     */\n    this.isContainerNode = false;\n    this._virtualChildren = [];\n    this._children = [];\n    // Used to check for duplicate nodes.\n    this.childSet = {};\n    // These matrices may need to have package level visibility\n    // for performance optimization purposes.\n    this.matrix = new Matrix();\n    this.dirtyTransform = false;\n    this.scalingX = 1;\n    this.scalingY = 1;\n    this.scalingCenterX = null;\n    this.scalingCenterY = null;\n    this.rotationCenterX = null;\n    this.rotationCenterY = null;\n    this.rotation = 0;\n    this.translationX = 0;\n    this.translationY = 0;\n    this._childNodeCounts = {\n      groups: 0,\n      nonGroups: 0\n    };\n    this.visible = true;\n    this.dirtyZIndex = false;\n    this.zIndex = 0;\n    /** Discriminators for render order within a zIndex. */\n    this.zIndexSubOrder = void 0;\n    this.pointerEvents = 0 /* All */;\n    this.name = name;\n    this.isVirtual = isVirtual ?? false;\n    this.tag = tag ?? NaN;\n    this.zIndex = zIndex ?? 0;\n  }\n  /**\n   * Some arbitrary data bound to the node.\n   */\n  get datum() {\n    return this._datum ?? this._parent?.datum;\n  }\n  get previousDatum() {\n    return this._previousDatum;\n  }\n  set datum(datum) {\n    if (this._datum !== datum) {\n      this._previousDatum = this._datum;\n    }\n    this._datum = datum;\n  }\n  _setLayerManager(value) {\n    this._layerManager = value;\n    this._debug = value?.debug;\n    for (const child of this._children) {\n      child._setLayerManager(value);\n    }\n    for (const child of this._virtualChildren) {\n      child._setLayerManager(value);\n    }\n  }\n  get layerManager() {\n    return this._layerManager;\n  }\n  *ancestors() {\n    let node = this;\n    while (node = node.parent) {\n      yield node;\n    }\n  }\n  *traverseUp() {\n    yield this;\n    yield* this.ancestors();\n  }\n  get parent() {\n    return this._parent;\n  }\n  get children() {\n    return this._virtualChildren.length ? this._children.concat(this._virtualChildren.flatMap((next) => next.children)) : this._children;\n  }\n  get virtualChildren() {\n    return this._virtualChildren;\n  }\n  hasVirtualChildren() {\n    return this._virtualChildren.length > 0;\n  }\n  // new Set<Node>()\n  setProperties(styles, pickKeys) {\n    if (pickKeys) {\n      for (const key of pickKeys) {\n        this[key] = styles[key];\n      }\n    } else {\n      Object.assign(this, styles);\n    }\n    return this;\n  }\n  /**\n   * Appends one or more new node instances to this parent.\n   * If one needs to:\n   * - move a child to the end of the list of children\n   * - move a child from one parent to another (including parents in other scenes)\n   * one should use the {@link insertBefore} method instead.\n   * @param nodes A node or nodes to append.\n   */\n  append(nodes) {\n    nodes = toIterable(nodes);\n    for (const node of nodes) {\n      if (node.parent) {\n        throw new Error(`${node} already belongs to another parent: ${node.parent}.`);\n      }\n      if (node.layerManager) {\n        throw new Error(`${node} already belongs to a scene: ${node.layerManager}.`);\n      }\n      if (this.childSet[node.id]) {\n        throw new Error(`Duplicate ${node.constructor.name} node: ${node}`);\n      }\n      if (node.isVirtual) {\n        this._virtualChildren.push(node);\n      } else {\n        this._children.push(node);\n      }\n      this.childSet[node.id] = true;\n      node._parent = this;\n      node._setLayerManager(this.layerManager);\n    }\n    this.dirtyZIndex = true;\n    this.markDirty(this, 3 /* MAJOR */);\n  }\n  appendChild(node) {\n    this.append(node);\n    return node;\n  }\n  removeChild(node) {\n    const error = () => {\n      throw new Error(`The node to be removed is not a child of this node.`);\n    };\n    if (node.parent !== this) {\n      error();\n    }\n    if (node.isVirtual) {\n      const i = this._virtualChildren.indexOf(node);\n      if (i < 0)\n        error();\n      this._virtualChildren.splice(i, 1);\n    } else {\n      const i = this._children.indexOf(node);\n      if (i < 0)\n        error();\n      this._children.splice(i, 1);\n    }\n    delete this.childSet[node.id];\n    node._parent = void 0;\n    node._setLayerManager();\n    this.dirtyZIndex = true;\n    this.markDirty(node, 3 /* MAJOR */);\n    return node;\n  }\n  clear() {\n    for (const child of arraysIterable(this._virtualChildren, this._children)) {\n      child._parent = void 0;\n      child._setLayerManager();\n    }\n    this._virtualChildren.length = 0;\n    this._children.length = 0;\n    this.childSet = {};\n  }\n  calculateCumulativeMatrix() {\n    this.computeTransformMatrix();\n    const matrix = Matrix.flyweight(this.matrix);\n    for (const parent of this.ancestors()) {\n      parent.computeTransformMatrix();\n      matrix.preMultiplySelf(parent.matrix);\n    }\n    return matrix;\n  }\n  transformPoint(x, y) {\n    const matrix = this.calculateCumulativeMatrix();\n    return matrix.invertSelf().transformPoint(x, y);\n  }\n  inverseTransformPoint(x, y) {\n    const matrix = this.calculateCumulativeMatrix();\n    return matrix.transformPoint(x, y);\n  }\n  transformBBox(bbox) {\n    const matrix = this.calculateCumulativeMatrix();\n    return matrix.invertSelf().transformBBox(bbox);\n  }\n  inverseTransformBBox(bbox) {\n    const matrix = this.calculateCumulativeMatrix();\n    return matrix.transformBBox(bbox);\n  }\n  markDirtyTransform() {\n    this.dirtyTransform = true;\n    this.markDirty(this, 3 /* MAJOR */);\n  }\n  destroy() {\n    this.parent?.removeChild(this);\n  }\n  containsPoint(_x, _y) {\n    return false;\n  }\n  /**\n   * Hit testing method.\n   * Recursively checks if the given point is inside this node or any of its children.\n   * Returns the first matching node or `undefined`.\n   * Nodes that render later (show on top) are hit tested first.\n   */\n  pickNode(x, y) {\n    if (!this.visible || this.pointerEvents === 1 /* None */ || !this.containsPoint(x, y)) {\n      return;\n    }\n    const { children } = this;\n    if (children.length > 1e3) {\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const containsPoint = child.computeTransformedBBox()?.containsPoint(x, y);\n        const hit = containsPoint ? child.pickNode(x, y) : void 0;\n        if (hit) {\n          return hit;\n        }\n      }\n    } else if (children.length) {\n      for (let i = children.length - 1; i >= 0; i--) {\n        const hit = children[i].pickNode(x, y);\n        if (hit) {\n          return hit;\n        }\n      }\n    } else if (!this.isContainerNode) {\n      return this;\n    }\n  }\n  getBBox(forceRecalculation = false) {\n    if (this.cachedBBox == null || forceRecalculation) {\n      this.cachedBBox = Object.freeze(this.computeBBox());\n    }\n    return this.cachedBBox;\n  }\n  computeBBox() {\n    return;\n  }\n  computeTransformedBBox() {\n    const bbox = this.getBBox()?.clone();\n    if (!bbox) {\n      return;\n    }\n    this.computeTransformMatrix();\n    const matrix = Matrix.flyweight(this.matrix);\n    for (const parent of this.ancestors()) {\n      parent.computeTransformMatrix();\n      matrix.preMultiplySelf(parent.matrix);\n    }\n    matrix.transformBBox(bbox, bbox);\n    return bbox;\n  }\n  computeTransformMatrix() {\n    if (!this.dirtyTransform) {\n      return;\n    }\n    const {\n      matrix,\n      scalingX,\n      scalingY,\n      rotation,\n      translationX,\n      translationY,\n      scalingCenterX,\n      scalingCenterY,\n      rotationCenterX,\n      rotationCenterY\n    } = this;\n    Matrix.updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, {\n      scalingCenterX,\n      scalingCenterY,\n      rotationCenterX,\n      rotationCenterY\n    });\n    this.dirtyTransform = false;\n  }\n  transformRenderContext(renderCtx, layerCtx) {\n    this.computeTransformMatrix();\n    this.matrix.toContext(layerCtx ?? renderCtx.ctx);\n    return this.matrix;\n  }\n  /** Perform any pre-rendering initialization. */\n  preRender() {\n    this._childNodeCounts.groups = 0;\n    this._childNodeCounts.nonGroups = 1;\n    for (const child of this.children) {\n      const childCounts = child.preRender();\n      this._childNodeCounts.groups += childCounts.groups;\n      this._childNodeCounts.nonGroups += childCounts.nonGroups;\n    }\n    return this._childNodeCounts;\n  }\n  render(renderCtx) {\n    const { stats } = renderCtx;\n    this._dirty = 0 /* NONE */;\n    this.cachedBBox = this.computeBBox();\n    if (stats) {\n      stats.nodesRendered++;\n    }\n  }\n  markDirty(_source, type = 1 /* TRIVIAL */, parentType = type) {\n    this.cachedBBox = void 0;\n    if (this._dirty > type || this._dirty === type && type === parentType) {\n      return;\n    }\n    this._dirty = type;\n    if (this.parent) {\n      this.parent.markDirty(this, parentType);\n    } else if (this.layerManager) {\n      this.layerManager.markDirty();\n    }\n  }\n  get dirty() {\n    return this._dirty;\n  }\n  markClean(opts) {\n    const { force = false, recursive = true } = opts ?? {};\n    if (this._dirty === 0 /* NONE */ && !force) {\n      return;\n    }\n    this._dirty = 0 /* NONE */;\n    if (recursive !== false) {\n      for (const child of this._virtualChildren) {\n        child.markClean({ force });\n      }\n    }\n    if (recursive === true) {\n      for (const child of this._children) {\n        child.markClean({ force });\n      }\n    }\n  }\n  onVisibleChange() {\n  }\n  get nodeCount() {\n    let count = 1;\n    let dirtyCount = this._dirty >= 0 /* NONE */ || this.dirtyTransform ? 1 : 0;\n    let visibleCount = this.visible ? 1 : 0;\n    const countChild = (child) => {\n      const { count: childCount, visibleCount: childVisibleCount, dirtyCount: childDirtyCount } = child.nodeCount;\n      count += childCount;\n      visibleCount += childVisibleCount;\n      dirtyCount += childDirtyCount;\n    };\n    for (const child of this._children) {\n      countChild(child);\n    }\n    for (const child of this._virtualChildren) {\n      countChild(child);\n    }\n    return { count, visibleCount, dirtyCount };\n  }\n  onZIndexChange() {\n    if (this.parent) {\n      this.parent.dirtyZIndex = true;\n    }\n  }\n};\n_Node._nextSerialNumber = 0;\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"scalingX\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"scalingY\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"scalingCenterX\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"scalingCenterY\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"rotationCenterX\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"rotationCenterY\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"rotation\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"translationX\", 2);\n__decorateClass([\n  SceneChangeDetection({ type: \"transform\" })\n], _Node.prototype, \"translationY\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 3 /* MAJOR */,\n    changeCb: (target) => target.onVisibleChange()\n  })\n], _Node.prototype, \"visible\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 1 /* TRIVIAL */,\n    changeCb: (target) => target.onZIndexChange()\n  })\n], _Node.prototype, \"zIndex\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 1 /* TRIVIAL */,\n    changeCb: (target) => target.onZIndexChange()\n  })\n], _Node.prototype, \"zIndexSubOrder\", 2);\nvar Node = _Node;\n\n// packages/ag-charts-community/src/util/color.ts\nvar lerp = (x, y, t) => x * (1 - t) + y * t;\nvar srgbToLinear = (value) => {\n  const sign = value < 0 ? -1 : 1;\n  const abs = Math.abs(value);\n  if (abs <= 0.04045)\n    return value / 12.92;\n  return sign * ((abs + 0.055) / 1.055) ** 2.4;\n};\nvar srgbFromLinear = (value) => {\n  const sign = value < 0 ? -1 : 1;\n  const abs = Math.abs(value);\n  if (abs > 31308e-7) {\n    return sign * (1.055 * abs ** (1 / 2.4) - 0.055);\n  }\n  return 12.92 * value;\n};\nvar _Color = class _Color {\n  /**\n   * Every color component should be in the [0, 1] range.\n   * Some easing functions (such as elastic easing) can overshoot the target value by some amount.\n   * So, when animating colors, if the source or target color components are already near\n   * or at the edge of the allowed [0, 1] range, it is possible for the intermediate color\n   * component value to end up outside of that range mid-animation. For this reason the constructor\n   * performs range checking/constraining.\n   * @param r Red component.\n   * @param g Green component.\n   * @param b Blue component.\n   * @param a Alpha (opacity) component.\n   */\n  constructor(r, g, b, a = 1) {\n    this.r = clamp(0, r || 0, 1);\n    this.g = clamp(0, g || 0, 1);\n    this.b = clamp(0, b || 0, 1);\n    this.a = clamp(0, a || 0, 1);\n  }\n  /**\n   * A color string can be in one of the following formats to be valid:\n   * - #rgb\n   * - #rrggbb\n   * - rgb(r, g, b)\n   * - rgba(r, g, b, a)\n   * - CSS color name such as 'white', 'orange', 'cyan', etc.\n   */\n  static validColorString(str) {\n    if (str.indexOf(\"#\") >= 0) {\n      return !!_Color.parseHex(str);\n    }\n    if (str.indexOf(\"rgb\") >= 0) {\n      return !!_Color.stringToRgba(str);\n    }\n    return !!_Color.nameToHex[str.toLowerCase()];\n  }\n  /**\n   * The given string can be in one of the following formats:\n   * - #rgb\n   * - #rrggbb\n   * - rgb(r, g, b)\n   * - rgba(r, g, b, a)\n   * - CSS color name such as 'white', 'orange', 'cyan', etc.\n   * @param str\n   */\n  static fromString(str) {\n    if (str.indexOf(\"#\") >= 0) {\n      return _Color.fromHexString(str);\n    }\n    const hex = _Color.nameToHex[str.toLowerCase()];\n    if (hex) {\n      return _Color.fromHexString(hex);\n    }\n    if (str.indexOf(\"rgb\") >= 0) {\n      return _Color.fromRgbaString(str);\n    }\n    throw new Error(`Invalid color string: '${str}'`);\n  }\n  // See https://drafts.csswg.org/css-color/#hex-notation\n  static parseHex(input) {\n    input = input.replace(/ /g, \"\").slice(1);\n    let parts;\n    switch (input.length) {\n      case 6:\n      case 8:\n        parts = [];\n        for (let i = 0; i < input.length; i += 2) {\n          parts.push(parseInt(`${input[i]}${input[i + 1]}`, 16));\n        }\n        break;\n      case 3:\n      case 4:\n        parts = input.split(\"\").map((p) => parseInt(p, 16)).map((p) => p + p * 16);\n        break;\n    }\n    if (parts?.length >= 3 && parts.every((p) => p >= 0)) {\n      if (parts.length === 3) {\n        parts.push(255);\n      }\n      return parts;\n    }\n  }\n  static fromHexString(str) {\n    const values = _Color.parseHex(str);\n    if (values) {\n      const [r, g, b, a] = values;\n      return new _Color(r / 255, g / 255, b / 255, a / 255);\n    }\n    throw new Error(`Malformed hexadecimal color string: '${str}'`);\n  }\n  static stringToRgba(str) {\n    let po = -1;\n    let pc = -1;\n    for (let i = 0; i < str.length; i++) {\n      const c = str[i];\n      if (po === -1 && c === \"(\") {\n        po = i;\n      } else if (c === \")\") {\n        pc = i;\n        break;\n      }\n    }\n    if (po === -1 || pc === -1)\n      return;\n    const contents = str.substring(po + 1, pc);\n    const parts = contents.split(\",\");\n    const rgba = [];\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i];\n      let value = parseFloat(part);\n      if (!Number.isFinite(value)) {\n        return;\n      }\n      if (part.indexOf(\"%\") >= 0) {\n        value = clamp(0, value, 100);\n        value /= 100;\n      } else if (i === 3) {\n        value = clamp(0, value, 1);\n      } else {\n        value = clamp(0, value, 255);\n        value /= 255;\n      }\n      rgba.push(value);\n    }\n    return rgba;\n  }\n  static fromRgbaString(str) {\n    const rgba = _Color.stringToRgba(str);\n    if (rgba) {\n      if (rgba.length === 3) {\n        return new _Color(rgba[0], rgba[1], rgba[2]);\n      } else if (rgba.length === 4) {\n        return new _Color(rgba[0], rgba[1], rgba[2], rgba[3]);\n      }\n    }\n    throw new Error(`Malformed rgb/rgba color string: '${str}'`);\n  }\n  static fromArray(arr) {\n    if (arr.length === 4) {\n      return new _Color(arr[0], arr[1], arr[2], arr[3]);\n    }\n    if (arr.length === 3) {\n      return new _Color(arr[0], arr[1], arr[2]);\n    }\n    throw new Error(\"The given array should contain 3 or 4 color components (numbers).\");\n  }\n  static fromHSB(h, s, b, alpha = 1) {\n    const rgb = _Color.HSBtoRGB(h, s, b);\n    return new _Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static fromHSL(h, s, l, alpha = 1) {\n    const rgb = _Color.HSLtoRGB(h, s, l);\n    return new _Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static fromOKLCH(l, c, h, alpha = 1) {\n    const rgb = _Color.OKLCHtoRGB(l, c, h);\n    return new _Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static padHex(str) {\n    return str.length === 1 ? \"0\" + str : str;\n  }\n  toHexString() {\n    let hex = \"#\" + _Color.padHex(Math.round(this.r * 255).toString(16)) + _Color.padHex(Math.round(this.g * 255).toString(16)) + _Color.padHex(Math.round(this.b * 255).toString(16));\n    if (this.a < 1) {\n      hex += _Color.padHex(Math.round(this.a * 255).toString(16));\n    }\n    return hex;\n  }\n  toRgbaString(fractionDigits = 3) {\n    const components = [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255)];\n    const k = Math.pow(10, fractionDigits);\n    if (this.a !== 1) {\n      components.push(Math.round(this.a * k) / k);\n      return `rgba(${components.join(\", \")})`;\n    }\n    return `rgb(${components.join(\", \")})`;\n  }\n  toString() {\n    if (this.a === 1) {\n      return this.toHexString();\n    }\n    return this.toRgbaString();\n  }\n  toHSB() {\n    return _Color.RGBtoHSB(this.r, this.g, this.b);\n  }\n  static RGBtoOKLCH(r, g, b) {\n    const LSRGB0 = srgbToLinear(r);\n    const LSRGB1 = srgbToLinear(g);\n    const LSRGB2 = srgbToLinear(b);\n    const LMS0 = Math.cbrt(0.4122214708 * LSRGB0 + 0.5363325363 * LSRGB1 + 0.0514459929 * LSRGB2);\n    const LMS1 = Math.cbrt(0.2119034982 * LSRGB0 + 0.6806995451 * LSRGB1 + 0.1073969566 * LSRGB2);\n    const LMS2 = Math.cbrt(0.0883024619 * LSRGB0 + 0.2817188376 * LSRGB1 + 0.6299787005 * LSRGB2);\n    const OKLAB0 = 0.2104542553 * LMS0 + 0.793617785 * LMS1 - 0.0040720468 * LMS2;\n    const OKLAB1 = 1.9779984951 * LMS0 - 2.428592205 * LMS1 + 0.4505937099 * LMS2;\n    const OKLAB2 = 0.0259040371 * LMS0 + 0.7827717662 * LMS1 - 0.808675766 * LMS2;\n    const hue = Math.atan2(OKLAB2, OKLAB1) * 180 / Math.PI;\n    const OKLCH0 = OKLAB0;\n    const OKLCH1 = Math.hypot(OKLAB1, OKLAB2);\n    const OKLCH2 = hue >= 0 ? hue : hue + 360;\n    return [OKLCH0, OKLCH1, OKLCH2];\n  }\n  static OKLCHtoRGB(l, c, h) {\n    const OKLAB0 = l;\n    const OKLAB1 = c * Math.cos(h * Math.PI / 180);\n    const OKLAB2 = c * Math.sin(h * Math.PI / 180);\n    const LMS0 = (OKLAB0 + 0.3963377774 * OKLAB1 + 0.2158037573 * OKLAB2) ** 3;\n    const LMS1 = (OKLAB0 - 0.1055613458 * OKLAB1 - 0.0638541728 * OKLAB2) ** 3;\n    const LMS2 = (OKLAB0 - 0.0894841775 * OKLAB1 - 1.291485548 * OKLAB2) ** 3;\n    const LSRGB0 = 4.0767416621 * LMS0 - 3.3077115913 * LMS1 + 0.2309699292 * LMS2;\n    const LSRGB1 = -1.2684380046 * LMS0 + 2.6097574011 * LMS1 - 0.3413193965 * LMS2;\n    const LSRGB2 = -0.0041960863 * LMS0 - 0.7034186147 * LMS1 + 1.707614701 * LMS2;\n    const SRGB0 = srgbFromLinear(LSRGB0);\n    const SRGB1 = srgbFromLinear(LSRGB1);\n    const SRGB2 = srgbFromLinear(LSRGB2);\n    return [SRGB0, SRGB1, SRGB2];\n  }\n  static RGBtoHSL(r, g, b) {\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n    const l = (max + min) / 2;\n    let h;\n    let s;\n    if (max === min) {\n      h = 0;\n      s = 0;\n    } else {\n      const delta3 = max - min;\n      s = l > 0.5 ? delta3 / (2 - max - min) : delta3 / (max + min);\n      if (max === r) {\n        h = (g - b) / delta3 + (g < b ? 6 : 0);\n      } else if (max === g) {\n        h = (b - r) / delta3 + 2;\n      } else {\n        h = (r - g) / delta3 + 4;\n      }\n      h *= 360 / 6;\n    }\n    return [h, s, l];\n  }\n  static HSLtoRGB(h, s, l) {\n    h = (h % 360 + 360) % 360;\n    if (s === 0) {\n      return [l, l, l];\n    }\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    function hueToRgb(t) {\n      if (t < 0)\n        t += 1;\n      if (t > 1)\n        t -= 1;\n      if (t < 1 / 6)\n        return p + (q - p) * 6 * t;\n      if (t < 1 / 2)\n        return q;\n      if (t < 2 / 3)\n        return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    }\n    const r = hueToRgb(h / 360 + 1 / 3);\n    const g = hueToRgb(h / 360);\n    const b = hueToRgb(h / 360 - 1 / 3);\n    return [r, g, b];\n  }\n  /**\n   * Converts the given RGB triple to an array of HSB (HSV) components.\n   */\n  static RGBtoHSB(r, g, b) {\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n    const S = max === 0 ? 0 : (max - min) / max;\n    let H = 0;\n    if (min !== max) {\n      const delta3 = max - min;\n      const rc = (max - r) / delta3;\n      const gc = (max - g) / delta3;\n      const bc = (max - b) / delta3;\n      if (r === max) {\n        H = bc - gc;\n      } else if (g === max) {\n        H = 2 + rc - bc;\n      } else {\n        H = 4 + gc - rc;\n      }\n      H /= 6;\n      if (H < 0) {\n        H = H + 1;\n      }\n    }\n    return [H * 360, S, max];\n  }\n  /**\n   * Converts the given HSB (HSV) triple to an array of RGB components.\n   */\n  static HSBtoRGB(H, S, B) {\n    H = (H % 360 + 360) % 360 / 360;\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    if (S === 0) {\n      r = g = b = B;\n    } else {\n      const h = (H - Math.floor(H)) * 6;\n      const f = h - Math.floor(h);\n      const p = B * (1 - S);\n      const q = B * (1 - S * f);\n      const t = B * (1 - S * (1 - f));\n      switch (h >> 0) {\n        case 0:\n          r = B;\n          g = t;\n          b = p;\n          break;\n        case 1:\n          r = q;\n          g = B;\n          b = p;\n          break;\n        case 2:\n          r = p;\n          g = B;\n          b = t;\n          break;\n        case 3:\n          r = p;\n          g = q;\n          b = B;\n          break;\n        case 4:\n          r = t;\n          g = p;\n          b = B;\n          break;\n        case 5:\n          r = B;\n          g = p;\n          b = q;\n          break;\n      }\n    }\n    return [r, g, b];\n  }\n  static mix(c0, c1, t) {\n    return new _Color(lerp(c0.r, c1.r, t), lerp(c0.g, c1.g, t), lerp(c0.b, c1.b, t), lerp(c0.a, c1.a, t));\n  }\n};\n/**\n * CSS Color Module Level 4:\n * https://drafts.csswg.org/css-color/#named-colors\n */\n_Color.nameToHex = {\n  // @ts-expect-error\n  __proto__: null,\n  aliceblue: \"#F0F8FF\",\n  antiquewhite: \"#FAEBD7\",\n  aqua: \"#00FFFF\",\n  aquamarine: \"#7FFFD4\",\n  azure: \"#F0FFFF\",\n  beige: \"#F5F5DC\",\n  bisque: \"#FFE4C4\",\n  black: \"#000000\",\n  blanchedalmond: \"#FFEBCD\",\n  blue: \"#0000FF\",\n  blueviolet: \"#8A2BE2\",\n  brown: \"#A52A2A\",\n  burlywood: \"#DEB887\",\n  cadetblue: \"#5F9EA0\",\n  chartreuse: \"#7FFF00\",\n  chocolate: \"#D2691E\",\n  coral: \"#FF7F50\",\n  cornflowerblue: \"#6495ED\",\n  cornsilk: \"#FFF8DC\",\n  crimson: \"#DC143C\",\n  cyan: \"#00FFFF\",\n  darkblue: \"#00008B\",\n  darkcyan: \"#008B8B\",\n  darkgoldenrod: \"#B8860B\",\n  darkgray: \"#A9A9A9\",\n  darkgreen: \"#006400\",\n  darkgrey: \"#A9A9A9\",\n  darkkhaki: \"#BDB76B\",\n  darkmagenta: \"#8B008B\",\n  darkolivegreen: \"#556B2F\",\n  darkorange: \"#FF8C00\",\n  darkorchid: \"#9932CC\",\n  darkred: \"#8B0000\",\n  darksalmon: \"#E9967A\",\n  darkseagreen: \"#8FBC8F\",\n  darkslateblue: \"#483D8B\",\n  darkslategray: \"#2F4F4F\",\n  darkslategrey: \"#2F4F4F\",\n  darkturquoise: \"#00CED1\",\n  darkviolet: \"#9400D3\",\n  deeppink: \"#FF1493\",\n  deepskyblue: \"#00BFFF\",\n  dimgray: \"#696969\",\n  dimgrey: \"#696969\",\n  dodgerblue: \"#1E90FF\",\n  firebrick: \"#B22222\",\n  floralwhite: \"#FFFAF0\",\n  forestgreen: \"#228B22\",\n  fuchsia: \"#FF00FF\",\n  gainsboro: \"#DCDCDC\",\n  ghostwhite: \"#F8F8FF\",\n  gold: \"#FFD700\",\n  goldenrod: \"#DAA520\",\n  gray: \"#808080\",\n  green: \"#008000\",\n  greenyellow: \"#ADFF2F\",\n  grey: \"#808080\",\n  honeydew: \"#F0FFF0\",\n  hotpink: \"#FF69B4\",\n  indianred: \"#CD5C5C\",\n  indigo: \"#4B0082\",\n  ivory: \"#FFFFF0\",\n  khaki: \"#F0E68C\",\n  lavender: \"#E6E6FA\",\n  lavenderblush: \"#FFF0F5\",\n  lawngreen: \"#7CFC00\",\n  lemonchiffon: \"#FFFACD\",\n  lightblue: \"#ADD8E6\",\n  lightcoral: \"#F08080\",\n  lightcyan: \"#E0FFFF\",\n  lightgoldenrodyellow: \"#FAFAD2\",\n  lightgray: \"#D3D3D3\",\n  lightgreen: \"#90EE90\",\n  lightgrey: \"#D3D3D3\",\n  lightpink: \"#FFB6C1\",\n  lightsalmon: \"#FFA07A\",\n  lightseagreen: \"#20B2AA\",\n  lightskyblue: \"#87CEFA\",\n  lightslategray: \"#778899\",\n  lightslategrey: \"#778899\",\n  lightsteelblue: \"#B0C4DE\",\n  lightyellow: \"#FFFFE0\",\n  lime: \"#00FF00\",\n  limegreen: \"#32CD32\",\n  linen: \"#FAF0E6\",\n  magenta: \"#FF00FF\",\n  maroon: \"#800000\",\n  mediumaquamarine: \"#66CDAA\",\n  mediumblue: \"#0000CD\",\n  mediumorchid: \"#BA55D3\",\n  mediumpurple: \"#9370DB\",\n  mediumseagreen: \"#3CB371\",\n  mediumslateblue: \"#7B68EE\",\n  mediumspringgreen: \"#00FA9A\",\n  mediumturquoise: \"#48D1CC\",\n  mediumvioletred: \"#C71585\",\n  midnightblue: \"#191970\",\n  mintcream: \"#F5FFFA\",\n  mistyrose: \"#FFE4E1\",\n  moccasin: \"#FFE4B5\",\n  navajowhite: \"#FFDEAD\",\n  navy: \"#000080\",\n  oldlace: \"#FDF5E6\",\n  olive: \"#808000\",\n  olivedrab: \"#6B8E23\",\n  orange: \"#FFA500\",\n  orangered: \"#FF4500\",\n  orchid: \"#DA70D6\",\n  palegoldenrod: \"#EEE8AA\",\n  palegreen: \"#98FB98\",\n  paleturquoise: \"#AFEEEE\",\n  palevioletred: \"#DB7093\",\n  papayawhip: \"#FFEFD5\",\n  peachpuff: \"#FFDAB9\",\n  peru: \"#CD853F\",\n  pink: \"#FFC0CB\",\n  plum: \"#DDA0DD\",\n  powderblue: \"#B0E0E6\",\n  purple: \"#800080\",\n  rebeccapurple: \"#663399\",\n  red: \"#FF0000\",\n  rosybrown: \"#BC8F8F\",\n  royalblue: \"#4169E1\",\n  saddlebrown: \"#8B4513\",\n  salmon: \"#FA8072\",\n  sandybrown: \"#F4A460\",\n  seagreen: \"#2E8B57\",\n  seashell: \"#FFF5EE\",\n  sienna: \"#A0522D\",\n  silver: \"#C0C0C0\",\n  skyblue: \"#87CEEB\",\n  slateblue: \"#6A5ACD\",\n  slategray: \"#708090\",\n  slategrey: \"#708090\",\n  snow: \"#FFFAFA\",\n  springgreen: \"#00FF7F\",\n  steelblue: \"#4682B4\",\n  tan: \"#D2B48C\",\n  teal: \"#008080\",\n  thistle: \"#D8BFD8\",\n  tomato: \"#FF6347\",\n  transparent: \"#00000000\",\n  turquoise: \"#40E0D0\",\n  violet: \"#EE82EE\",\n  wheat: \"#F5DEB3\",\n  white: \"#FFFFFF\",\n  whitesmoke: \"#F5F5F5\",\n  yellow: \"#FFFF00\",\n  yellowgreen: \"#9ACD32\"\n};\nvar Color = _Color;\n\n// packages/ag-charts-community/src/util/interpolate.ts\nfunction interpolateNumber(a, b) {\n  return (d) => Number(a) * (1 - d) + Number(b) * d;\n}\nfunction interpolateColor(a, b) {\n  if (typeof a === \"string\") {\n    try {\n      a = Color.fromString(a);\n    } catch (e) {\n      a = Color.fromArray([0, 0, 0]);\n    }\n  }\n  if (typeof b === \"string\") {\n    try {\n      b = Color.fromString(b);\n    } catch (e) {\n      b = Color.fromArray([0, 0, 0]);\n    }\n  }\n  return (d) => Color.mix(a, b, d).toRgbaString();\n}\n\n// packages/ag-charts-community/src/util/decorator.ts\nvar BREAK_TRANSFORM_CHAIN = Symbol(\"BREAK\");\nvar CONFIG_KEY = \"__decorator_config\";\nfunction initialiseConfig(target, propertyKeyOrSymbol) {\n  if (Object.getOwnPropertyDescriptor(target, CONFIG_KEY) == null) {\n    Object.defineProperty(target, CONFIG_KEY, { value: {} });\n  }\n  const config = target[CONFIG_KEY];\n  const propertyKey = propertyKeyOrSymbol.toString();\n  if (typeof config[propertyKey] !== \"undefined\") {\n    return config[propertyKey];\n  }\n  const valuesMap = /* @__PURE__ */ new WeakMap();\n  config[propertyKey] = { setters: [], getters: [], observers: [], valuesMap };\n  const descriptor = Object.getOwnPropertyDescriptor(target, propertyKeyOrSymbol);\n  const prevSet = descriptor?.set;\n  const prevGet = descriptor?.get;\n  const getter = function() {\n    let value = prevGet ? prevGet.call(this) : valuesMap.get(this);\n    for (const transformFn of config[propertyKey].getters) {\n      value = transformFn(this, propertyKeyOrSymbol, value);\n      if (value === BREAK_TRANSFORM_CHAIN) {\n        return;\n      }\n    }\n    return value;\n  };\n  const setter = function(value) {\n    const { setters, observers } = config[propertyKey];\n    let oldValue;\n    if (setters.some((f) => f.length > 2)) {\n      oldValue = prevGet ? prevGet.call(this) : valuesMap.get(this);\n    }\n    for (const transformFn of setters) {\n      value = transformFn(this, propertyKeyOrSymbol, value, oldValue);\n      if (value === BREAK_TRANSFORM_CHAIN) {\n        return;\n      }\n    }\n    if (prevSet) {\n      prevSet.call(this, value);\n    } else {\n      valuesMap.set(this, value);\n    }\n    for (const observerFn of observers) {\n      observerFn(this, value, oldValue);\n    }\n  };\n  Object.defineProperty(target, propertyKeyOrSymbol, {\n    set: setter,\n    get: getter,\n    enumerable: true,\n    configurable: false\n  });\n  return config[propertyKey];\n}\nfunction addTransformToInstanceProperty(setTransform, getTransform, configMetadata) {\n  return (target, propertyKeyOrSymbol) => {\n    const config = initialiseConfig(target, propertyKeyOrSymbol);\n    config.setters.push(setTransform);\n    if (getTransform) {\n      config.getters.unshift(getTransform);\n    }\n    if (configMetadata) {\n      Object.assign(config, configMetadata);\n    }\n  };\n}\nfunction addObserverToInstanceProperty(setObserver) {\n  return (target, propertyKeyOrSymbol) => {\n    initialiseConfig(target, propertyKeyOrSymbol).observers.push(setObserver);\n  };\n}\nfunction isDecoratedObject(target) {\n  return typeof target !== \"undefined\" && CONFIG_KEY in target;\n}\nfunction listDecoratedProperties(target) {\n  const targets = /* @__PURE__ */ new Set();\n  while (isDecoratedObject(target)) {\n    targets.add(target?.[CONFIG_KEY]);\n    target = Object.getPrototypeOf(target);\n  }\n  return Array.from(targets).flatMap((configMap) => Object.keys(configMap));\n}\nfunction extractDecoratedProperties(target) {\n  return listDecoratedProperties(target).reduce((result, key) => {\n    result[key] = target[key] ?? null;\n    return result;\n  }, {});\n}\nfunction extractDecoratedPropertyMetadata(target, propertyKeyOrSymbol) {\n  const propertyKey = propertyKeyOrSymbol.toString();\n  while (isDecoratedObject(target)) {\n    const config = target[CONFIG_KEY];\n    if (Object.hasOwn(config, propertyKey)) {\n      return config[propertyKey];\n    }\n    target = Object.getPrototypeOf(target);\n  }\n}\n\n// packages/ag-charts-community/src/util/type-guards.ts\nfunction isDefined(val) {\n  return val != null;\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\nfunction isBoolean(value) {\n  return typeof value === \"boolean\";\n}\nfunction isDate(value) {\n  return value instanceof Date;\n}\nfunction isValidDate(value) {\n  return isDate(value) && !isNaN(Number(value));\n}\nfunction isRegExp(value) {\n  return value instanceof RegExp;\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null && !isArray(value);\n}\nfunction isObjectLike(value) {\n  return isArray(value) || isPlainObject(value);\n}\nfunction isPlainObject(value) {\n  return typeof value === \"object\" && value !== null && value.constructor === Object;\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nfunction isNumber(value) {\n  return typeof value === \"number\";\n}\nfunction isFiniteNumber(value) {\n  return Number.isFinite(value);\n}\nfunction isHtmlElement(value) {\n  return typeof window !== \"undefined\" && value instanceof HTMLElement;\n}\nfunction isEnumKey(enumObject, enumKey) {\n  return isString(enumKey) && Object.keys(enumObject).includes(enumKey);\n}\nfunction isEnumValue(enumObject, enumValue) {\n  return Object.values(enumObject).includes(enumValue);\n}\nfunction isSymbol(value) {\n  return typeof value === \"symbol\";\n}\n\n// packages/ag-charts-community/src/util/object.ts\nfunction deepMerge(...sources) {\n  return mergeDefaults(...sources.reverse());\n}\nfunction mergeDefaults(...sources) {\n  const target = {};\n  for (const source of sources) {\n    if (!isObject(source))\n      continue;\n    const keys = isDecoratedObject(source) ? listDecoratedProperties(source) : Object.keys(source);\n    for (const key of keys) {\n      if (isPlainObject(target[key]) && isPlainObject(source[key])) {\n        target[key] = mergeDefaults(target[key], source[key]);\n      } else {\n        target[key] ?? (target[key] = source[key]);\n      }\n    }\n  }\n  return target;\n}\nfunction mergeArrayDefaults(dataArray, ...itemDefaults) {\n  if (itemDefaults && isArray(dataArray)) {\n    return dataArray.map((item) => mergeDefaults(item, ...itemDefaults));\n  }\n  return dataArray;\n}\nfunction mapValues(object2, mapper) {\n  return Object.entries(object2).reduce(\n    (result, [key, value]) => {\n      result[key] = mapper(value, key, object2);\n      return result;\n    },\n    {}\n  );\n}\nfunction without(object2, keys) {\n  const clone = { ...object2 };\n  for (const key of keys) {\n    delete clone[key];\n  }\n  return clone;\n}\nfunction getPath(object2, path) {\n  const pathArray = isArray(path) ? path : path.split(\".\");\n  return pathArray.reduce((value, pathKey) => value[pathKey], object2);\n}\nvar SKIP_JS_BUILTINS = /* @__PURE__ */ new Set([\"__proto__\", \"constructor\", \"prototype\"]);\nfunction setPath(object2, path, newValue) {\n  const pathArray = isArray(path) ? path.slice() : path.split(\".\");\n  const lastKey = pathArray.pop();\n  if (pathArray.some((p) => SKIP_JS_BUILTINS.has(p)))\n    return;\n  const lastObject = pathArray.reduce((value, pathKey) => value[pathKey], object2);\n  lastObject[lastKey] = newValue;\n  return lastObject[lastKey];\n}\nfunction partialAssign(keysToCopy, target, source) {\n  if (source === void 0) {\n    return target;\n  }\n  for (const key of keysToCopy) {\n    const value = source[key];\n    if (value !== void 0) {\n      target[key] = value;\n    }\n  }\n  return target;\n}\n\n// packages/ag-charts-community/src/util/properties.ts\nvar BaseProperties = class {\n  set(properties) {\n    const { className = this.constructor.name } = this.constructor;\n    if (typeof properties !== \"object\") {\n      Logger.warn(`unable to set ${className} - expecting a properties object`);\n      return this;\n    }\n    const keys = new Set(Object.keys(properties));\n    for (const propertyKey of listDecoratedProperties(this)) {\n      if (keys.has(propertyKey)) {\n        const value = properties[propertyKey];\n        const self = this;\n        if (isProperties(self[propertyKey])) {\n          self[propertyKey] = self[propertyKey] instanceof PropertiesArray ? self[propertyKey].reset(value) : self[propertyKey].set(value);\n        } else {\n          self[propertyKey] = value;\n        }\n        keys.delete(propertyKey);\n      }\n    }\n    for (const unknownKey of keys) {\n      Logger.warn(`unable to set [${unknownKey}] in ${className} - property is unknown`);\n    }\n    return this;\n  }\n  isValid(warningPrefix) {\n    return listDecoratedProperties(this).every((propertyKey) => {\n      const { optional } = extractDecoratedPropertyMetadata(this, propertyKey);\n      const valid = optional === true || typeof this[propertyKey] !== \"undefined\";\n      if (!valid) {\n        Logger.warnOnce(`${warningPrefix ?? \"\"}[${propertyKey}] is required.`);\n      }\n      return valid;\n    });\n  }\n  toJson() {\n    return listDecoratedProperties(this).reduce((object2, propertyKey) => {\n      const propertyValue = this[propertyKey];\n      object2[propertyKey] = isProperties(propertyValue) ? propertyValue.toJson() : propertyValue;\n      return object2;\n    }, {});\n  }\n};\nvar PropertiesArray = class _PropertiesArray extends Array {\n  constructor(itemFactory, ...properties) {\n    super(properties.length);\n    const isConstructor = (value2) => Boolean(value2?.prototype?.constructor?.name);\n    const value = isConstructor(itemFactory) ? (params) => new itemFactory().set(params) : itemFactory;\n    Object.defineProperty(this, \"itemFactory\", { value, enumerable: false, configurable: false });\n    this.set(properties);\n  }\n  set(properties) {\n    if (isArray(properties)) {\n      this.length = properties.length;\n      for (let i = 0; i < properties.length; i++) {\n        this[i] = this.itemFactory(properties[i]);\n      }\n    }\n    return this;\n  }\n  reset(properties) {\n    return new _PropertiesArray(this.itemFactory, ...properties);\n  }\n  toJson() {\n    return this.map((value) => value?.toJson?.() ?? value);\n  }\n};\nfunction isProperties(value) {\n  return value instanceof BaseProperties || value instanceof PropertiesArray;\n}\n\n// packages/ag-charts-community/src/util/json.ts\nvar CLASS_INSTANCE_TYPE = \"class-instance\";\nfunction jsonDiff(source, target, skip) {\n  if (isArray(target)) {\n    if (!isArray(source) || source.length !== target.length || target.some((v, i) => jsonDiff(source[i], v) != null)) {\n      return target;\n    }\n  } else if (isPlainObject(target)) {\n    if (!isPlainObject(source)) {\n      return target;\n    }\n    const result = {};\n    const allKeys = /* @__PURE__ */ new Set([\n      ...Object.keys(source),\n      ...Object.keys(target)\n    ]);\n    for (const key of allKeys) {\n      if (source[key] === target[key] || skip?.includes(key)) {\n        continue;\n      }\n      if (typeof source[key] === typeof target[key]) {\n        const diff2 = jsonDiff(source[key], target[key]);\n        if (diff2 !== null) {\n          result[key] = diff2;\n        }\n      } else {\n        result[key] = target[key];\n      }\n    }\n    return Object.keys(result).length ? result : null;\n  } else if (source !== target) {\n    return target;\n  }\n  return null;\n}\nfunction deepClone(source, options) {\n  if (isArray(source)) {\n    return source.map((item) => deepClone(item, options));\n  }\n  if (isPlainObject(source)) {\n    return mapValues(\n      source,\n      (value, key) => options?.shallow?.includes(key) ? shallowClone(value) : deepClone(value, options)\n    );\n  }\n  return shallowClone(source);\n}\nfunction shallowClone(source) {\n  if (isArray(source)) {\n    return [...source];\n  }\n  if (isPlainObject(source)) {\n    return { ...source };\n  }\n  if (isDate(source)) {\n    return new Date(source);\n  }\n  if (isRegExp(source)) {\n    return new RegExp(source.source, source.flags);\n  }\n  return source;\n}\nfunction jsonWalk(json, visit, opts, ...jsons) {\n  if (isArray(json)) {\n    visit(json, ...jsons);\n    json.forEach((node, index) => {\n      jsonWalk(node, visit, opts, ...keyMapper(jsons, index));\n    });\n  } else if (isPlainObject(json)) {\n    visit(json, ...jsons);\n    for (const key of Object.keys(json)) {\n      if (opts?.skip?.includes(key)) {\n        continue;\n      }\n      const value = json[key];\n      if (isArray(value) || isPlainObject(value)) {\n        jsonWalk(value, visit, opts, ...keyMapper(jsons, key));\n      }\n    }\n  }\n}\nfunction jsonApply(target, source, params = {}) {\n  const { path, matcherPath = path?.replace(/(\\[[0-9+]+])/i, \"[]\"), skip = [] } = params;\n  if (target == null) {\n    throw new Error(`AG Charts - target is uninitialised: ${path ?? \"<root>\"}`);\n  }\n  if (source == null) {\n    return target;\n  }\n  if (isProperties(target)) {\n    return target.set(source);\n  }\n  const targetAny = target;\n  const targetType = classify(target);\n  for (const property in source) {\n    if (SKIP_JS_BUILTINS.has(property))\n      continue;\n    const propertyMatcherPath = `${matcherPath ? matcherPath + \".\" : \"\"}${property}`;\n    if (skip.includes(propertyMatcherPath))\n      continue;\n    const newValue = source[property];\n    const propertyPath = `${path ? path + \".\" : \"\"}${property}`;\n    const targetClass = targetAny.constructor;\n    const currentValue = targetAny[property];\n    try {\n      const currentValueType = classify(currentValue);\n      const newValueType = classify(newValue);\n      if (targetType === CLASS_INSTANCE_TYPE && !(property in target)) {\n        Logger.warn(`unable to set [${propertyPath}] in ${targetClass?.name} - property is unknown`);\n        continue;\n      }\n      if (currentValueType != null && newValueType != null && newValueType !== currentValueType && (currentValueType !== CLASS_INSTANCE_TYPE || newValueType !== \"object\")) {\n        Logger.warn(\n          `unable to set [${propertyPath}] in ${targetClass?.name} - can't apply type of [${newValueType}], allowed types are: [${currentValueType}]`\n        );\n        continue;\n      }\n      if (isProperties(currentValue)) {\n        targetAny[property].set(newValue);\n      } else if (newValueType === \"object\") {\n        if (currentValue == null) {\n          targetAny[property] = {};\n        }\n        jsonApply(currentValue ?? targetAny[property], newValue, {\n          ...params,\n          path: propertyPath,\n          matcherPath: propertyMatcherPath\n        });\n      } else {\n        targetAny[property] = newValue;\n      }\n    } catch (error) {\n      Logger.warn(`unable to set [${propertyPath}] in [${targetClass?.name}]; nested error is: ${error.message}`);\n    }\n  }\n  return target;\n}\nfunction keyMapper(data, key) {\n  return data.map((dataObject) => dataObject?.[key]);\n}\nfunction classify(value) {\n  if (value == null) {\n    return null;\n  }\n  if (isHtmlElement(value) || isDate(value)) {\n    return \"primitive\";\n  }\n  if (isArray(value)) {\n    return \"array\";\n  }\n  if (isObject(value)) {\n    return isPlainObject(value) ? \"object\" : CLASS_INSTANCE_TYPE;\n  }\n  if (isFunction(value)) {\n    return \"function\";\n  }\n  return \"primitive\";\n}\n\n// packages/ag-charts-community/src/motion/easing.ts\nvar easing_exports = {};\n__export(easing_exports, {\n  easeIn: () => easeIn,\n  easeInOut: () => easeInOut,\n  easeInOutQuad: () => easeInOutQuad,\n  easeInQuad: () => easeInQuad,\n  easeOut: () => easeOut,\n  easeOutQuad: () => easeOutQuad,\n  inverseEaseOut: () => inverseEaseOut,\n  linear: () => linear\n});\nvar linear = (n) => n;\nvar easeIn = (n) => 1 - Math.cos(n * Math.PI / 2);\nvar easeOut = (n) => Math.sin(n * Math.PI / 2);\nvar easeInOut = (n) => -(Math.cos(n * Math.PI) - 1) / 2;\nvar easeInQuad = (n) => n * n;\nvar easeOutQuad = (n) => 1 - (1 - n) ** 2;\nvar easeInOutQuad = (n) => n < 0.5 ? 2 * n * n : 1 - (-2 * n + 2) ** 2 / 2;\nvar inverseEaseOut = (x) => 2 * Math.asin(x) / Math.PI;\n\n// packages/ag-charts-community/src/motion/animation.ts\nvar QUICK_TRANSITION = 0.2;\nvar PHASE_ORDER = [\"initial\", \"remove\", \"update\", \"add\", \"trailing\", \"end\", \"none\"];\nvar PHASE_METADATA = {\n  initial: {\n    animationDuration: 1,\n    animationDelay: 0\n  },\n  add: {\n    animationDuration: 0.25,\n    animationDelay: 0.75\n  },\n  remove: {\n    animationDuration: 0.25,\n    animationDelay: 0\n  },\n  update: {\n    animationDuration: 0.5,\n    animationDelay: 0.25\n  },\n  trailing: {\n    animationDuration: QUICK_TRANSITION,\n    animationDelay: 1,\n    skipIfNoEarlierAnimations: true\n  },\n  end: {\n    animationDelay: 1 + QUICK_TRANSITION,\n    animationDuration: 0,\n    skipIfNoEarlierAnimations: true\n  },\n  none: {\n    animationDuration: 0,\n    animationDelay: 0\n  }\n};\nvar RepeatType = /* @__PURE__ */ ((RepeatType2) => {\n  RepeatType2[\"Loop\"] = \"loop\";\n  RepeatType2[\"Reverse\"] = \"reverse\";\n  return RepeatType2;\n})(RepeatType || {});\nfunction isNodeArray(array2) {\n  return array2.every((n) => n instanceof Node);\n}\nfunction deconstructSelectionsOrNodes(selectionsOrNodes) {\n  return isNodeArray(selectionsOrNodes) ? { nodes: selectionsOrNodes, selections: [] } : { nodes: [], selections: selectionsOrNodes };\n}\nvar Animation = class {\n  constructor(opts) {\n    this.isComplete = false;\n    this.elapsed = 0;\n    this.iteration = 0;\n    this.isPlaying = false;\n    this.isReverse = false;\n    this.id = opts.id;\n    this.groupId = opts.groupId;\n    this.autoplay = opts.autoplay ?? true;\n    this.ease = opts.ease ?? linear;\n    this.phase = opts.phase;\n    const durationProportion = opts.duration ?? PHASE_METADATA[this.phase].animationDuration;\n    this.duration = durationProportion * opts.defaultDuration;\n    this.delay = (opts.delay ?? 0) * opts.defaultDuration;\n    this.onComplete = opts.onComplete;\n    this.onPlay = opts.onPlay;\n    this.onStop = opts.onStop;\n    this.onUpdate = opts.onUpdate;\n    this.interpolate = this.createInterpolator(opts.from, opts.to);\n    this.from = opts.from;\n    if (opts.skip === true) {\n      this.onUpdate?.(opts.to, false, this);\n      this.onStop?.(this);\n      this.onComplete?.(this);\n      this.isComplete = true;\n    }\n    if (opts.collapsable !== false) {\n      this.duration = this.checkCollapse(opts, this.duration);\n    }\n  }\n  checkCollapse(opts, calculatedDuration) {\n    if (opts.from === opts.to)\n      return 0;\n    const diff2 = typeof opts.from === \"object\" ? jsonDiff(opts.from, opts.to) : null;\n    if (diff2) {\n      return calculatedDuration;\n    }\n    return 0;\n  }\n  play(initialUpdate = false) {\n    if (this.isPlaying || this.isComplete)\n      return;\n    this.isPlaying = true;\n    this.onPlay?.(this);\n    if (!this.autoplay)\n      return;\n    this.autoplay = false;\n    if (!initialUpdate)\n      return;\n    this.onUpdate?.(this.from, true, this);\n  }\n  pause() {\n    this.isPlaying = false;\n  }\n  stop() {\n    this.isPlaying = false;\n    if (!this.isComplete) {\n      this.isComplete = true;\n      this.onStop?.(this);\n    }\n  }\n  update(time2) {\n    if (this.isComplete)\n      return time2;\n    if (!this.isPlaying && this.autoplay) {\n      this.play(true);\n    }\n    const previousElapsed = this.elapsed;\n    this.elapsed += time2;\n    if (this.delay > this.elapsed)\n      return 0;\n    const value = this.interpolate(this.isReverse ? 1 - this.delta : this.delta);\n    this.onUpdate?.(value, false, this);\n    const totalDuration = this.delay + this.duration;\n    if (this.elapsed >= totalDuration) {\n      this.stop();\n      this.isComplete = true;\n      this.onComplete?.(this);\n      return time2 - (totalDuration - previousElapsed);\n    }\n    return 0;\n  }\n  get delta() {\n    return this.ease(clamp(0, (this.elapsed - this.delay) / this.duration, 1));\n  }\n  createInterpolator(from2, to) {\n    if (typeof to !== \"object\" || isInterpolating(to)) {\n      return this.interpolateValue(from2, to);\n    }\n    const interpolatorEntries = [];\n    for (const key in to) {\n      const interpolator = this.interpolateValue(from2[key], to[key]);\n      if (interpolator != null) {\n        interpolatorEntries.push([key, interpolator]);\n      }\n    }\n    return (d) => {\n      const result = {};\n      for (const [key, interpolator] of interpolatorEntries) {\n        result[key] = interpolator(d);\n      }\n      return result;\n    };\n  }\n  interpolateValue(a, b) {\n    if (a === void 0 || b === void 0) {\n      return;\n    } else if (isInterpolating(a)) {\n      return (d) => a[interpolate](b, d);\n    }\n    try {\n      switch (typeof a) {\n        case \"number\":\n          return interpolateNumber(a, b);\n        case \"string\":\n          return interpolateColor(a, b);\n        case \"boolean\":\n          if (a === b)\n            return () => a;\n          break;\n      }\n    } catch (e) {\n    }\n    throw new Error(`Unable to interpolate values: ${a}, ${b}`);\n  }\n};\n\n// packages/ag-charts-community/src/motion/fromToMotion.ts\nvar NODE_UPDATE_STATE_TO_PHASE_MAPPING = {\n  added: \"add\",\n  updated: \"update\",\n  removed: \"remove\",\n  unknown: \"initial\",\n  \"no-op\": \"none\"\n};\nfunction fromToMotion(groupId, subId, animationManager, selectionsOrNodes, fns, getDatumId, diff2) {\n  const { fromFn, toFn, intermediateFn } = fns;\n  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);\n  const processNodes = (liveNodes, subNodes) => {\n    let prevFromProps;\n    let liveNodeIndex = 0;\n    let nodeIndex = 0;\n    for (const node of subNodes) {\n      const isLive = liveNodes[liveNodeIndex] === node;\n      const ctx = {\n        last: nodeIndex >= subNodes.length - 1,\n        lastLive: liveNodeIndex >= liveNodes.length - 1,\n        prev: subNodes[nodeIndex - 1],\n        prevFromProps,\n        prevLive: liveNodes[liveNodeIndex - 1],\n        next: subNodes[nodeIndex + 1],\n        nextLive: liveNodes[liveNodeIndex + (isLive ? 1 : 0)]\n      };\n      const animationId = `${groupId}_${subId}_${node.id}`;\n      animationManager.stopByAnimationId(animationId);\n      let status = \"unknown\";\n      if (!isLive) {\n        status = \"removed\";\n      } else if (getDatumId && diff2) {\n        status = calculateStatus(node, node.datum, getDatumId, diff2);\n      }\n      const { phase, start, finish, delay, duration, ...from2 } = fromFn(node, node.datum, status, ctx);\n      const {\n        phase: toPhase,\n        start: toStart,\n        finish: toFinish,\n        delay: toDelay,\n        duration: toDuration,\n        ...to\n      } = toFn(node, node.datum, status, ctx);\n      const collapsable = finish == null && toFinish == null;\n      animationManager.animate({\n        id: animationId,\n        groupId,\n        phase: phase ?? toPhase ?? \"update\",\n        duration: duration ?? toDuration,\n        delay: delay ?? toDelay,\n        from: from2,\n        to,\n        ease: easeOut,\n        collapsable,\n        onPlay: () => {\n          node.setProperties({ ...start, ...toStart });\n        },\n        onUpdate(props) {\n          node.setProperties(props);\n          if (intermediateFn) {\n            node.setProperties(intermediateFn(node, node.datum, status, ctx));\n          }\n        },\n        onStop: () => {\n          node.setProperties({\n            ...start,\n            ...toStart,\n            ...from2,\n            ...to,\n            ...finish,\n            ...toFinish\n          });\n        }\n      });\n      if (isLive) {\n        liveNodeIndex++;\n      }\n      nodeIndex++;\n      prevFromProps = from2;\n    }\n  };\n  let selectionIndex = 0;\n  for (const selection of selections) {\n    const selectionNodes = selection.nodes();\n    const liveNodes = selectionNodes.filter((n) => !selection.isGarbage(n));\n    processNodes(liveNodes, selectionNodes);\n    animationManager.animate({\n      id: `${groupId}_${subId}_selection_${selectionIndex}`,\n      groupId,\n      phase: \"end\",\n      from: 0,\n      to: 1,\n      ease: easeOut,\n      onStop() {\n        selection.cleanup();\n      }\n    });\n    selectionIndex++;\n  }\n  processNodes(nodes, nodes);\n}\nfunction staticFromToMotion(groupId, subId, animationManager, selectionsOrNodes, from2, to, extraOpts) {\n  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);\n  const { start, finish, phase } = extraOpts;\n  const collapsable = finish == null;\n  animationManager.animate({\n    id: `${groupId}_${subId}`,\n    groupId,\n    phase: phase ?? \"update\",\n    from: from2,\n    to,\n    ease: easeOut,\n    collapsable,\n    onPlay: () => {\n      if (!start)\n        return;\n      for (const node of nodes) {\n        node.setProperties(start);\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties(start);\n        }\n      }\n    },\n    onUpdate(props) {\n      for (const node of nodes) {\n        node.setProperties(props);\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties(props);\n        }\n      }\n    },\n    onStop: () => {\n      for (const node of nodes) {\n        node.setProperties({ ...to, ...finish });\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties({ ...to, ...finish });\n        }\n        selection.cleanup();\n      }\n    }\n  });\n}\nfunction calculateStatus(node, datum, getDatumId, diff2) {\n  const id = getDatumId(node, datum);\n  if (diff2.added.has(id)) {\n    return \"added\";\n  }\n  if (diff2.removed.has(id)) {\n    return \"removed\";\n  }\n  return \"updated\";\n}\n\n// packages/ag-charts-community/src/util/timeFormat.ts\nvar CONSTANTS = {\n  periods: [\"AM\", \"PM\"],\n  days: [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"],\n  shortDays: [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"],\n  months: [\n    \"January\",\n    \"February\",\n    \"March\",\n    \"April\",\n    \"May\",\n    \"June\",\n    \"July\",\n    \"August\",\n    \"September\",\n    \"October\",\n    \"November\",\n    \"December\"\n  ],\n  shortMonths: [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]\n};\nfunction dayOfYear(date, startOfYear = new Date(date.getFullYear(), 0, 1)) {\n  const startOffset = date.getTimezoneOffset() - startOfYear.getTimezoneOffset();\n  const timeDiff = date.getTime() - startOfYear.getTime() + startOffset * 6e4;\n  const timeOneDay = 36e5 * 24;\n  return Math.floor(timeDiff / timeOneDay);\n}\nfunction weekOfYear(date, startDay) {\n  const startOfYear = new Date(date.getFullYear(), 0, 1);\n  const startOfYearDay = startOfYear.getDay();\n  const firstWeekStartOffset = (startDay - startOfYearDay + 7) % 7;\n  const startOffset = new Date(date.getFullYear(), 0, firstWeekStartOffset + 1);\n  if (startOffset <= date) {\n    return Math.floor(dayOfYear(date, startOffset) / 7) + 1;\n  }\n  return 0;\n}\nvar SUNDAY = 0;\nvar MONDAY = 1;\nvar THURSDAY = 4;\nfunction isoWeekOfYear(date, year2 = date.getFullYear()) {\n  const firstOfYear = new Date(year2, 0, 1);\n  const firstOfYearDay = firstOfYear.getDay();\n  const firstThursdayOffset = (THURSDAY - firstOfYearDay + 7) % 7;\n  const startOffset = new Date(year2, 0, firstThursdayOffset - (THURSDAY - MONDAY) + 1);\n  if (startOffset <= date) {\n    return Math.floor(dayOfYear(date, startOffset) / 7) + 1;\n  }\n  return isoWeekOfYear(date, year2 - 1);\n}\nfunction timezone(date) {\n  const offset4 = date.getTimezoneOffset();\n  const unsignedOffset = Math.abs(offset4);\n  const sign = offset4 > 0 ? \"-\" : \"+\";\n  return `${sign}${pad(Math.floor(unsignedOffset / 60), 2, \"0\")}${pad(Math.floor(unsignedOffset % 60), 2, \"0\")}`;\n}\nvar FORMATTERS = {\n  a: (d) => CONSTANTS.shortDays[d.getDay()],\n  A: (d) => CONSTANTS.days[d.getDay()],\n  b: (d) => CONSTANTS.shortMonths[d.getMonth()],\n  B: (d) => CONSTANTS.months[d.getMonth()],\n  c: \"%x, %X\",\n  d: (d, p) => pad(d.getDate(), 2, p ?? \"0\"),\n  e: \"%_d\",\n  f: (d, p) => pad(d.getMilliseconds() * 1e3, 6, p ?? \"0\"),\n  H: (d, p) => pad(d.getHours(), 2, p ?? \"0\"),\n  I: (d, p) => {\n    const hours = d.getHours() % 12;\n    return hours === 0 ? \"12\" : pad(hours, 2, p ?? \"0\");\n  },\n  j: (d, p) => pad(dayOfYear(d) + 1, 3, p ?? \"0\"),\n  m: (d, p) => pad(d.getMonth() + 1, 2, p ?? \"0\"),\n  M: (d, p) => pad(d.getMinutes(), 2, p ?? \"0\"),\n  L: (d, p) => pad(d.getMilliseconds(), 3, p ?? \"0\"),\n  p: (d) => d.getHours() < 12 ? \"AM\" : \"PM\",\n  Q: (d) => String(d.getTime()),\n  s: (d) => String(Math.floor(d.getTime() / 1e3)),\n  S: (d, p) => pad(d.getSeconds(), 2, p ?? \"0\"),\n  u: (d) => {\n    let day2 = d.getDay();\n    if (day2 < 1)\n      day2 += 7;\n    return String(day2 % 7);\n  },\n  U: (d, p) => pad(weekOfYear(d, SUNDAY), 2, p ?? \"0\"),\n  V: (d, p) => pad(isoWeekOfYear(d), 2, p ?? \"0\"),\n  w: (d, p) => pad(d.getDay(), 2, p ?? \"0\"),\n  W: (d, p) => pad(weekOfYear(d, MONDAY), 2, p ?? \"0\"),\n  x: \"%-m/%-d/%Y\",\n  X: \"%-I:%M:%S %p\",\n  y: (d, p) => pad(d.getFullYear() % 100, 2, p ?? \"0\"),\n  Y: (d, p) => pad(d.getFullYear(), 4, p ?? \"0\"),\n  Z: (d) => timezone(d),\n  \"%\": () => \"%\"\n};\nvar PADS = {\n  _: \" \",\n  \"0\": \"0\",\n  \"-\": \"\"\n};\nfunction pad(value, size, padChar) {\n  const output = String(Math.floor(value));\n  if (output.length >= size) {\n    return output;\n  }\n  return `${padChar.repeat(size - output.length)}${output}`;\n}\nfunction buildFormatter(formatString) {\n  const formatParts = [];\n  while (formatString.length > 0) {\n    let nextEscapeIdx = formatString.indexOf(\"%\");\n    if (nextEscapeIdx !== 0) {\n      const literalPart = nextEscapeIdx > 0 ? formatString.substring(0, nextEscapeIdx) : formatString;\n      formatParts.push(literalPart);\n    }\n    if (nextEscapeIdx < 0)\n      break;\n    const maybePadSpecifier = formatString[nextEscapeIdx + 1];\n    const maybePad = PADS[maybePadSpecifier];\n    if (maybePad != null) {\n      nextEscapeIdx++;\n    }\n    const maybeFormatterSpecifier = formatString[nextEscapeIdx + 1];\n    const maybeFormatter = FORMATTERS[maybeFormatterSpecifier];\n    if (typeof maybeFormatter === \"function\") {\n      formatParts.push([maybeFormatter, maybePad]);\n    } else if (typeof maybeFormatter === \"string\") {\n      const formatter = buildFormatter(maybeFormatter);\n      formatParts.push([formatter, maybePad]);\n    } else {\n      formatParts.push(`${maybePad ?? \"\"}${maybeFormatterSpecifier}`);\n    }\n    formatString = formatString.substring(nextEscapeIdx + 2);\n  }\n  return (dateTime) => {\n    const dateTimeAsDate = typeof dateTime === \"number\" ? new Date(dateTime) : dateTime;\n    return formatParts.map((c) => typeof c === \"string\" ? c : c[0](dateTimeAsDate, c[1])).join(\"\");\n  };\n}\n\n// packages/ag-charts-community/src/util/timeFormatDefaults.ts\nfunction dateToNumber(x) {\n  return x instanceof Date ? x.getTime() : x;\n}\nfunction defaultTimeTickFormat(ticks, domain, formatOffset) {\n  const formatString = calculateDefaultTimeTickFormat(ticks, domain, formatOffset);\n  const formatter = buildFormatter(formatString);\n  return (date) => formatter(date);\n}\nfunction calculateDefaultTimeTickFormat(ticks = [], domain = ticks, formatOffset = 0) {\n  let minInterval = Infinity;\n  for (let i = 1; i < ticks.length; i++) {\n    minInterval = Math.min(minInterval, Math.abs(ticks[i] - ticks[i - 1]));\n  }\n  const startYear = new Date(domain[0]).getFullYear();\n  const stopYear = new Date(domain.at(-1)).getFullYear();\n  const yearChange = stopYear - startYear > 0;\n  const timeFormat = isFinite(minInterval) ? getIntervalLowestGranularityFormat(minInterval, ticks) : getLowestGranularityFormat(ticks[0]);\n  return formatStringBuilder(Math.max(timeFormat - formatOffset, 0), yearChange, ticks);\n}\nfunction getIntervalLowestGranularityFormat(value, ticks) {\n  if (value < durationSecond) {\n    return 0 /* MILLISECOND */;\n  } else if (value < durationMinute) {\n    return 1 /* SECOND */;\n  } else if (value < durationHour) {\n    return 2 /* MINUTE */;\n  } else if (value < durationDay) {\n    return 3 /* HOUR */;\n  } else if (value < durationWeek) {\n    return 4 /* WEEK_DAY */;\n  } else if (value < durationDay * 28 || value < durationDay * 31 && hasDuplicateMonth(ticks)) {\n    return 5 /* SHORT_MONTH */;\n  } else if (value < durationYear) {\n    return 6 /* MONTH */;\n  }\n  return 7 /* YEAR */;\n}\nfunction getLowestGranularityFormat(value) {\n  if (second_default.floor(value) < value) {\n    return 0 /* MILLISECOND */;\n  } else if (minute_default.floor(value) < value) {\n    return 1 /* SECOND */;\n  } else if (hour_default.floor(value) < value) {\n    return 2 /* MINUTE */;\n  } else if (day_default.floor(value) < value) {\n    return 3 /* HOUR */;\n  } else if (month_default.floor(value) < value) {\n    if (week_default.floor(value) < value) {\n      return 4 /* WEEK_DAY */;\n    }\n    return 5 /* SHORT_MONTH */;\n  } else if (year_default.floor(value) < value) {\n    return 6 /* MONTH */;\n  }\n  return 7 /* YEAR */;\n}\nfunction hasDuplicateMonth(ticks) {\n  let prevMonth = new Date(ticks[0]).getMonth();\n  for (let i = 1; i < ticks.length; i++) {\n    const tickMonth = new Date(ticks[i]).getMonth();\n    if (prevMonth === tickMonth) {\n      return true;\n    }\n    prevMonth = tickMonth;\n  }\n  return false;\n}\nfunction formatStringBuilder(defaultTimeFormat, yearChange, ticks) {\n  const firstTick = dateToNumber(ticks[0]);\n  const lastTick = dateToNumber(ticks.at(-1));\n  const extent2 = Math.abs(lastTick - firstTick);\n  const activeYear = yearChange || defaultTimeFormat === 7 /* YEAR */;\n  const activeDate = extent2 === 0;\n  const parts = [\n    [\"hour\", 6 * durationHour, 14 * durationDay, 3 /* HOUR */, \"%I %p\"],\n    [\"hour\", durationMinute, 6 * durationHour, 3 /* HOUR */, \"%I:%M\"],\n    [\"second\", 1e3, 6 * durationHour, 1 /* SECOND */, \":%S\"],\n    [\"ms\", 0, 6 * durationHour, 0 /* MILLISECOND */, \".%L\"],\n    [\"am/pm\", durationMinute, 6 * durationHour, 3 /* HOUR */, \"%p\"],\n    \" \",\n    [\"day\", durationDay, durationWeek, 4 /* WEEK_DAY */, \"%a\"],\n    [\"month\", activeDate ? 0 : durationWeek, 52 * durationWeek, 5 /* SHORT_MONTH */, \"%b %d\"],\n    [\"month\", 5 * durationWeek, 10 * durationYear, 6 /* MONTH */, \"%B\"],\n    \" \",\n    [\"year\", activeYear ? 0 : durationYear, Infinity, 7 /* YEAR */, \"%Y\"]\n  ];\n  const formatParts = parts.filter((v) => {\n    if (typeof v === \"string\")\n      return true;\n    const [_, min, max, format] = v;\n    return format >= defaultTimeFormat && min <= extent2 && extent2 < max;\n  }).reduce(\n    (r, next) => {\n      if (typeof next === \"string\") {\n        r.result.push(next);\n      } else if (!r.used.has(next[0])) {\n        r.result.push(next);\n        r.used.add(next[0]);\n      }\n      return r;\n    },\n    { result: [], used: /* @__PURE__ */ new Set() }\n  ).result;\n  const firstFormat = formatParts.findIndex((v) => typeof v !== \"string\");\n  const lastFormat = formatParts.length - [...formatParts].reverse().findIndex((v) => typeof v !== \"string\");\n  return formatParts.slice(firstFormat, lastFormat).map((v) => typeof v === \"string\" ? v : v[4]).join(\"\").replaceAll(/\\s+/g, \" \").trim();\n}\n\n// packages/ag-charts-community/src/scale/invalidating.ts\nvar Invalidating = (target, propertyKey) => {\n  const mappedProperty = Symbol(String(propertyKey));\n  target[mappedProperty] = void 0;\n  Object.defineProperty(target, propertyKey, {\n    get() {\n      return this[mappedProperty];\n    },\n    set(newValue) {\n      const oldValue = this[mappedProperty];\n      if (oldValue !== newValue) {\n        this[mappedProperty] = newValue;\n        this.invalid = true;\n      }\n    },\n    enumerable: true,\n    configurable: false\n  });\n};\n\n// packages/ag-charts-community/src/scale/bandScale.ts\nvar _BandScale = class _BandScale {\n  constructor() {\n    this.type = \"band\";\n    this.invalid = true;\n    this.range = [0, 1];\n    this.round = false;\n    this.interval = void 0;\n    /**\n     * Maps datum to its index in the {@link domain} array.\n     * Used to check for duplicate data (not allowed).\n     */\n    this.index = /* @__PURE__ */ new Map();\n    /**\n     * The output range values for datum at each index.\n     */\n    this.ordinalRange = [];\n    /**\n     * Contains unique data only.\n     */\n    this._domain = [];\n    this._bandwidth = 1;\n    this._step = 1;\n    this._inset = 1;\n    this._rawBandwidth = 1;\n    /**\n     * The ratio of the range that is reserved for space between bands.\n     */\n    this._paddingInner = 0;\n    /**\n     * The ratio of the range that is reserved for space before the first\n     * and after the last band.\n     */\n    this._paddingOuter = 0;\n  }\n  static is(value) {\n    return value instanceof _BandScale;\n  }\n  refresh() {\n    if (!this.invalid)\n      return;\n    this.invalid = false;\n    this.update();\n    if (this.invalid) {\n      Logger.warnOnce(\"Expected update to not invalidate scale\");\n    }\n  }\n  set domain(values) {\n    this.index = /* @__PURE__ */ new Map();\n    this.invalid = true;\n    this._domain = [];\n    for (const value of values) {\n      const key = dateToNumber(value);\n      if (this.getIndex(key) === void 0) {\n        this.index.set(key, this._domain.push(value) - 1);\n      }\n    }\n  }\n  get domain() {\n    return this._domain;\n  }\n  getDomain() {\n    return this._domain;\n  }\n  ticks() {\n    this.refresh();\n    return this._domain;\n  }\n  convert(d) {\n    this.refresh();\n    const i = this.getIndex(d);\n    if (i == null) {\n      return NaN;\n    }\n    return this.ordinalRange[i] ?? NaN;\n  }\n  invert(position) {\n    this.refresh();\n    const index = this.ordinalRange.findIndex((p) => p === position);\n    return this.domain[index];\n  }\n  invertNearest(position) {\n    this.refresh();\n    let nearest = -1;\n    let minDistance = Infinity;\n    const index = this.ordinalRange.findIndex((p, i) => {\n      if (p === position)\n        return true;\n      const distance3 = Math.abs(position - p);\n      if (distance3 < minDistance) {\n        minDistance = distance3;\n        nearest = i;\n      }\n      return false;\n    });\n    return this.domain[index] ?? this.domain[nearest];\n  }\n  get bandwidth() {\n    this.refresh();\n    return this._bandwidth;\n  }\n  get step() {\n    this.refresh();\n    return this._step;\n  }\n  get inset() {\n    this.refresh();\n    return this._inset;\n  }\n  get rawBandwidth() {\n    this.refresh();\n    return this._rawBandwidth;\n  }\n  set padding(value) {\n    value = clamp(0, value, 1);\n    this._paddingInner = value;\n    this._paddingOuter = value;\n  }\n  get padding() {\n    return this._paddingInner;\n  }\n  set paddingInner(value) {\n    this._paddingInner = clamp(0, value, 1);\n  }\n  get paddingInner() {\n    return this._paddingInner;\n  }\n  set paddingOuter(value) {\n    this._paddingOuter = clamp(0, value, 1);\n  }\n  get paddingOuter() {\n    return this._paddingOuter;\n  }\n  update() {\n    const count = this._domain.length;\n    if (count === 0)\n      return;\n    const [r0, r1] = this.range;\n    let { _paddingInner: paddingInner } = this;\n    const { _paddingOuter: paddingOuter, round: round3 } = this;\n    const rangeDistance = r1 - r0;\n    let rawStep, step, inset;\n    if (count === 1) {\n      paddingInner = 0;\n      rawStep = rangeDistance * (1 - paddingOuter * 2);\n      step = round3 ? Math.round(rawStep) : rawStep;\n      inset = rangeDistance * paddingOuter;\n    } else {\n      rawStep = rangeDistance / Math.max(1, count - paddingInner + paddingOuter * 2);\n      step = round3 ? Math.floor(rawStep) : rawStep;\n      inset = r0 + (rangeDistance - step * (count - paddingInner)) / 2;\n    }\n    let bandwidth = step * (1 - paddingInner);\n    if (round3) {\n      inset = Math.round(inset);\n      bandwidth = Math.round(bandwidth);\n    }\n    this._step = step;\n    this._inset = inset;\n    this._bandwidth = bandwidth;\n    this._rawBandwidth = rawStep * (1 - paddingInner);\n    this.ordinalRange = this._domain.map((_, i) => inset + step * i);\n  }\n  getIndex(value) {\n    return this.index.get(value instanceof Date ? value.getTime() : value);\n  }\n};\n__decorateClass([\n  Invalidating\n], _BandScale.prototype, \"range\", 2);\n__decorateClass([\n  Invalidating\n], _BandScale.prototype, \"round\", 2);\n__decorateClass([\n  Invalidating\n], _BandScale.prototype, \"interval\", 2);\nvar BandScale = _BandScale;\n\n// packages/ag-charts-community/src/util/validation.ts\nfunction Validate(predicate, options = {}) {\n  const { optional = false, property: overrideProperty } = options;\n  return addTransformToInstanceProperty(\n    (target, property, value) => {\n      const context = { ...options, target, property };\n      if (optional && typeof value === \"undefined\" || predicate(value, context)) {\n        if (isProperties(target[property]) && !isProperties(value)) {\n          target[property].set(value);\n          return target[property];\n        }\n        return value;\n      }\n      const cleanKey = overrideProperty ?? String(property).replace(/^_*/, \"\");\n      const targetName = target.constructor.className ?? target.constructor.name.replace(/Properties$/, \"\");\n      let valueString = stringify(value);\n      const maxLength = 50;\n      if (valueString != null && valueString.length > maxLength) {\n        const excessCharacters = valueString.length - maxLength;\n        valueString = valueString.slice(0, maxLength) + `... (+${excessCharacters} characters)`;\n      }\n      Logger.warn(\n        `Property [${cleanKey}] of [${targetName}] cannot be set to [${valueString}]${predicate.message ? `; expecting ${getPredicateMessage(predicate, context)}` : \"\"}, ignoring.`\n      );\n      return BREAK_TRANSFORM_CHAIN;\n    },\n    void 0,\n    { optional }\n  );\n}\nvar AND = (...predicates) => {\n  const messages = [];\n  return predicateWithMessage(\n    (value, ctx) => {\n      messages.length = 0;\n      return predicates.every((predicate) => {\n        const isValid2 = predicate(value, ctx);\n        if (!isValid2) {\n          messages.push(getPredicateMessage(predicate, ctx));\n        }\n        return isValid2;\n      });\n    },\n    () => messages.filter(Boolean).join(\" AND \")\n  );\n};\nvar OR = (...predicates) => predicateWithMessage(\n  (value, ctx) => predicates.some((predicate) => predicate(value, ctx)),\n  (ctx) => predicates.map(getPredicateMessageMapper(ctx)).filter(Boolean).join(\" OR \")\n);\nvar OBJECT = attachObjectRestrictions(\n  predicateWithMessage(\n    (value, ctx) => isProperties(value) || isObject(value) && isProperties(ctx.target[ctx.property]),\n    \"a properties object\"\n  )\n);\nvar PLAIN_OBJECT = attachObjectRestrictions(predicateWithMessage((value) => isObject(value), \"an object\"));\nvar BOOLEAN = predicateWithMessage(isBoolean, \"a boolean\");\nvar FUNCTION = predicateWithMessage(isFunction, \"a function\");\nvar STRING = predicateWithMessage(isString, \"a string\");\nvar NUMBER = attachNumberRestrictions(predicateWithMessage(isFiniteNumber, \"a number\"));\nvar NAN = predicateWithMessage((value) => isNumber(value) && isNaN(value), \"NaN\");\nvar POSITIVE_NUMBER = NUMBER.restrict({ min: 0 });\nvar RATIO = NUMBER.restrict({ min: 0, max: 1 });\nvar DEGREE = NUMBER.restrict({ min: -360, max: 360 });\nvar NUMBER_OR_NAN = OR(NUMBER, NAN);\nvar ARRAY = attachArrayRestrictions(predicateWithMessage(isArray, \"an array\"));\nvar ARRAY_OF = (predicate, message) => predicateWithMessage(\n  (value, ctx) => isArray(value) && value.every((item) => predicate(item, ctx)),\n  (ctx) => {\n    const arrayMessage = getPredicateMessage(ARRAY, ctx) ?? \"\";\n    return message ? `${arrayMessage} of ${message}` : arrayMessage;\n  }\n);\nvar isComparable = (value) => isFiniteNumber(value) || isValidDate(value);\nvar LESS_THAN = (otherField) => predicateWithMessage(\n  (v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v < ctx.target[otherField],\n  `to be less than ${otherField}`\n);\nvar GREATER_THAN = (otherField) => predicateWithMessage(\n  (v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v > ctx.target[otherField],\n  `to be greater than ${otherField}`\n);\nvar DATE = predicateWithMessage(isValidDate, \"Date object\");\nvar DATE_OR_DATETIME_MS = OR(DATE, POSITIVE_NUMBER);\nvar colorMessage = `A color string can be in one of the following formats to be valid: #rgb, #rrggbb, rgb(r, g, b), rgba(r, g, b, a) or a CSS color name such as 'white', 'orange', 'cyan', etc`;\nvar COLOR_STRING = predicateWithMessage(\n  (v) => isString(v) && Color.validColorString(v),\n  `color String. ${colorMessage}`\n);\nvar COLOR_STRING_ARRAY = predicateWithMessage(ARRAY_OF(COLOR_STRING), `color strings. ${colorMessage}`);\nvar BOOLEAN_ARRAY = ARRAY_OF(BOOLEAN, \"boolean values\");\nvar NUMBER_ARRAY = ARRAY_OF(NUMBER, \"numbers\");\nvar STRING_ARRAY = ARRAY_OF(STRING, \"strings\");\nvar DATE_ARRAY = predicateWithMessage(ARRAY_OF(DATE), \"Date objects\");\nvar OBJECT_ARRAY = predicateWithMessage(ARRAY_OF(OBJECT), \"objects\");\nvar LINE_CAP = UNION([\"butt\", \"round\", \"square\"], \"a line cap\");\nvar LINE_JOIN = UNION([\"round\", \"bevel\", \"miter\"], \"a line join\");\nvar LINE_DASH = predicateWithMessage(\n  ARRAY_OF(POSITIVE_NUMBER),\n  \"numbers specifying the length in pixels of alternating dashes and gaps, for example, [6, 3] means dashes with a length of 6 pixels with gaps between of 3 pixels.\"\n);\nvar POSITION = UNION([\"top\", \"right\", \"bottom\", \"left\"], \"a position\");\nvar FONT_STYLE = UNION([\"normal\", \"italic\", \"oblique\"], \"a font style\");\nvar FONT_WEIGHT = OR(\n  UNION([\"normal\", \"bold\", \"bolder\", \"lighter\"], \"a font weight\"),\n  NUMBER.restrict({ min: 1, max: 1e3 })\n);\nvar TEXT_WRAP = UNION([\"never\", \"always\", \"hyphenate\", \"on-space\"], \"a text wrap strategy\");\nvar TEXT_ALIGN = UNION([\"left\", \"center\", \"right\"], \"a text align\");\nvar VERTICAL_ALIGN = UNION([\"top\", \"middle\", \"bottom\"], \"a vertical align\");\nvar OVERFLOW_STRATEGY = UNION([\"ellipsis\", \"hide\"], \"an overflow strategy\");\nvar DIRECTION = UNION([\"horizontal\", \"vertical\"], \"a direction\");\nvar PLACEMENT = UNION([\"inside\", \"outside\"], \"a placement\");\nvar INTERACTION_RANGE = OR(UNION([\"exact\", \"nearest\"], \"interaction range\"), NUMBER);\nvar LABEL_PLACEMENT = UNION([\"top\", \"bottom\", \"left\", \"right\"]);\nfunction UNION(options, message = \"a\") {\n  return predicateWithMessage(\n    (v) => options.includes(v),\n    `${message} keyword such as ${joinUnionOptions(options)}`\n  );\n}\nvar MIN_SPACING = OR(AND(NUMBER.restrict({ min: 1 }), LESS_THAN(\"maxSpacing\")), NAN);\nvar MAX_SPACING = OR(AND(NUMBER.restrict({ min: 1 }), GREATER_THAN(\"minSpacing\")), NAN);\nfunction predicateWithMessage(predicate, message) {\n  predicate.message = message;\n  return predicate;\n}\nfunction joinUnionOptions(options) {\n  const values = options.map((option) => `'${option}'`);\n  if (values.length === 1) {\n    return values[0];\n  }\n  const lastValue = values.pop();\n  return `${values.join(\", \")} or ${lastValue}`;\n}\nfunction getPredicateMessage(predicate, ctx) {\n  return isFunction(predicate.message) ? predicate.message(ctx) : predicate.message;\n}\nfunction getPredicateMessageMapper(ctx) {\n  return (predicate) => getPredicateMessage(predicate, ctx);\n}\nfunction attachArrayRestrictions(predicate) {\n  return Object.assign(predicate, {\n    restrict({ length: length2, minLength } = {}) {\n      let message = \"an array\";\n      if (isNumber(minLength) && minLength > 0) {\n        message = \"a non-empty array\";\n      } else if (isNumber(length2)) {\n        message = `an array of length ${length2}`;\n      }\n      return predicateWithMessage(\n        (value) => isArray(value) && (isNumber(length2) ? value.length === length2 : true) && (isNumber(minLength) ? value.length >= minLength : true),\n        message\n      );\n    }\n  });\n}\nfunction attachNumberRestrictions(predicate) {\n  return Object.assign(predicate, {\n    restrict({ min, max } = {}) {\n      const message = [\"a number\"];\n      const hasMin = isNumber(min);\n      const hasMax = isNumber(max);\n      if (hasMin && hasMax) {\n        message.push(`between ${min} and ${max} inclusive`);\n      } else if (hasMin) {\n        message.push(`greater than or equal to ${min}`);\n      } else if (hasMax) {\n        message.push(`less than or equal to ${max}`);\n      }\n      return predicateWithMessage(\n        (value) => isFiniteNumber(value) && (hasMin ? value >= min : true) && (hasMax ? value <= max : true),\n        message.join(\" \")\n      );\n    }\n  });\n}\nfunction attachObjectRestrictions(predicate) {\n  return Object.assign(predicate, {\n    restrict(objectType) {\n      return predicateWithMessage(\n        (value) => value instanceof objectType,\n        (ctx) => getPredicateMessage(predicate, ctx) ?? `an instance of ${objectType.name}`\n      );\n    }\n  });\n}\nfunction stringify(value) {\n  if (typeof value === \"number\") {\n    if (isNaN(value))\n      return \"NaN\";\n    if (value === Infinity)\n      return \"Infinity\";\n    if (value === -Infinity)\n      return \"-Infinity\";\n  }\n  return JSON.stringify(value);\n}\n\n// packages/ag-charts-community/src/chart/chartAxisDirection.ts\nvar ChartAxisDirection = /* @__PURE__ */ ((ChartAxisDirection2) => {\n  ChartAxisDirection2[\"X\"] = \"x\";\n  ChartAxisDirection2[\"Y\"] = \"y\";\n  return ChartAxisDirection2;\n})(ChartAxisDirection || {});\n\n// packages/ag-charts-community/src/module/moduleMap.ts\nvar ModuleMap = class {\n  constructor() {\n    this.moduleMap = /* @__PURE__ */ new Map();\n  }\n  *modules() {\n    const sequencedModules = [\"toolbar\", \"navigator\"];\n    for (const m of this.moduleMap.values()) {\n      if (sequencedModules.includes(m.module.optionsKey)) {\n        continue;\n      }\n      yield m.moduleInstance;\n    }\n    for (const key of sequencedModules) {\n      const module = this.moduleMap.get(key);\n      if (module) {\n        yield module.moduleInstance;\n      }\n    }\n  }\n  addModule(module, moduleFactory) {\n    if (this.moduleMap.has(module.optionsKey)) {\n      throw new Error(`AG Charts - module already initialised: ${module.optionsKey}`);\n    }\n    this.moduleMap.set(module.optionsKey, { module, moduleInstance: moduleFactory(module) });\n  }\n  removeModule(module) {\n    const moduleKey = isString(module) ? module : module.optionsKey;\n    this.moduleMap.get(moduleKey)?.moduleInstance.destroy();\n    this.moduleMap.delete(moduleKey);\n  }\n  getModule(module) {\n    return this.moduleMap.get(isString(module) ? module : module.optionsKey)?.moduleInstance;\n  }\n  isEnabled(module) {\n    return this.moduleMap.has(isString(module) ? module : module.optionsKey);\n  }\n  mapModules(callback2) {\n    return Array.from(this.moduleMap.values(), (m, i) => callback2(m.moduleInstance, i));\n  }\n  destroy() {\n    for (const moduleKey of this.moduleMap.keys()) {\n      this.moduleMap.get(moduleKey)?.moduleInstance.destroy();\n    }\n    this.moduleMap.clear();\n  }\n};\n\n// packages/ag-charts-community/src/motion/resetMotion.ts\nvar resetMotion_exports = {};\n__export(resetMotion_exports, {\n  resetMotion: () => resetMotion\n});\nfunction resetMotion(selectionsOrNodes, propsFn) {\n  const { nodes, selections } = deconstructSelectionsOrNodes(selectionsOrNodes);\n  for (const selection of selections) {\n    for (const node of selection.nodes()) {\n      const from2 = propsFn(node, node.datum);\n      node.setProperties(from2);\n    }\n    selection.cleanup();\n  }\n  for (const node of nodes) {\n    const from2 = propsFn(node, node.datum);\n    node.setProperties(from2);\n  }\n}\n\n// packages/ag-charts-community/src/scale/continuousScale.ts\nvar _ContinuousScale = class _ContinuousScale {\n  constructor(domain, range3) {\n    this.invalid = true;\n    this.nice = false;\n    this.interval = void 0;\n    this.tickCount = _ContinuousScale.defaultTickCount;\n    this.minTickCount = 0;\n    this.maxTickCount = Infinity;\n    // TODO(olegat) should be of type D[]\n    this.niceDomain = [];\n    this.defaultClampMode = \"raw\";\n    this.domain = domain;\n    this.range = range3;\n  }\n  static is(value) {\n    return value instanceof _ContinuousScale;\n  }\n  transform(x) {\n    return x;\n  }\n  transformInvert(x) {\n    return x;\n  }\n  calcBandwidth(smallestInterval = 1) {\n    const domain = this.getDomain();\n    const rangeDistance = this.getPixelRange();\n    const intervals = Math.abs(domain[1] - domain[0]) / smallestInterval + 1;\n    const maxBands = Math.floor(rangeDistance);\n    const bands = Math.min(intervals, maxBands);\n    return rangeDistance / Math.max(1, bands);\n  }\n  getDomain() {\n    if (this.nice) {\n      this.refresh();\n      if (this.niceDomain.length) {\n        return this.niceDomain;\n      }\n    }\n    return this.domain;\n  }\n  convert(x, opts) {\n    const clampMode = opts?.clampMode ?? this.defaultClampMode;\n    if (!this.domain || this.domain.length < 2) {\n      return NaN;\n    }\n    this.refresh();\n    const domain = this.getDomain().map((d) => this.transform(d));\n    const [d0, d1] = domain;\n    const { range: range3 } = this;\n    const [r0, r1] = range3;\n    x = this.transform(x);\n    if (clampMode === \"clamped\") {\n      const [start, stop] = findMinMax(domain.map(Number));\n      if (Number(x) < start) {\n        return r0;\n      } else if (Number(x) > stop) {\n        return r1;\n      }\n    }\n    if (d0 === d1) {\n      return (r0 + r1) / 2;\n    } else if (x === d0) {\n      return r0;\n    } else if (x === d1) {\n      return r1;\n    }\n    return r0 + (Number(x) - Number(d0)) / (Number(d1) - Number(d0)) * (r1 - r0);\n  }\n  invert(x) {\n    this.refresh();\n    const domain = this.getDomain().map((d2) => this.transform(d2));\n    const [d0, d1] = domain;\n    const { range: range3 } = this;\n    const [r0, r1] = range3;\n    const isReversed = r0 > r1;\n    const rMin = isReversed ? r1 : r0;\n    const rMax = isReversed ? r0 : r1;\n    let d;\n    if (x < rMin) {\n      return isReversed ? d1 : d0;\n    } else if (x > rMax) {\n      return isReversed ? d0 : d1;\n    } else if (r0 === r1) {\n      d = this.toDomain((Number(d0) + Number(d1)) / 2);\n    } else {\n      d = this.toDomain(Number(d0) + (x - r0) / (r1 - r0) * (Number(d1) - Number(d0)));\n    }\n    return this.transformInvert(d);\n  }\n  refresh() {\n    if (!this.invalid)\n      return;\n    this.invalid = false;\n    this.update();\n    if (this.invalid) {\n      Logger.warnOnce(\"Expected update to not invalidate scale\");\n    }\n  }\n  getPixelRange() {\n    const [a, b] = this.range;\n    return Math.abs(b - a);\n  }\n};\n_ContinuousScale.defaultTickCount = 5;\n_ContinuousScale.defaultMaxTickCount = 6;\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"domain\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"range\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"nice\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"interval\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"tickCount\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"minTickCount\", 2);\n__decorateClass([\n  Invalidating\n], _ContinuousScale.prototype, \"maxTickCount\", 2);\nvar ContinuousScale = _ContinuousScale;\n\n// packages/ag-charts-community/src/util/numberFormat.ts\nfunction parseFormat(format) {\n  let prefix;\n  let suffix;\n  const surrounded = surroundedRegEx.exec(format);\n  if (surrounded) {\n    [, prefix, format, suffix] = surrounded;\n  }\n  const match = formatRegEx.exec(format);\n  if (!match) {\n    throw new Error(`The number formatter is invalid: ${format}`);\n  }\n  const [, fill, align, sign, symbol, zero, width, comma, precision, trim, type] = match;\n  return {\n    fill,\n    align,\n    sign,\n    symbol,\n    zero,\n    width: parseInt(width),\n    comma,\n    precision: parseInt(precision),\n    trim: Boolean(trim),\n    type,\n    prefix,\n    suffix\n  };\n}\nfunction numberFormat(format) {\n  const options = typeof format === \"string\" ? parseFormat(format) : format;\n  const { fill, align, sign = \"-\", symbol, zero, width, comma, type, prefix = \"\", suffix = \"\", precision } = options;\n  let { trim } = options;\n  const precisionIsNaN = precision == null || isNaN(precision);\n  let formatBody;\n  if (!type) {\n    formatBody = decimalTypes[\"g\"];\n    trim = true;\n  } else if (type in decimalTypes && type in integerTypes) {\n    formatBody = precisionIsNaN ? integerTypes[type] : decimalTypes[type];\n  } else if (type in decimalTypes) {\n    formatBody = decimalTypes[type];\n  } else if (type in integerTypes) {\n    formatBody = integerTypes[type];\n  } else {\n    throw new Error(`The number formatter type is invalid: ${type}`);\n  }\n  let formatterPrecision;\n  if (precision == null || precisionIsNaN) {\n    formatterPrecision = type ? 6 : 12;\n  } else {\n    formatterPrecision = precision;\n  }\n  return (n) => {\n    let result = formatBody(n, formatterPrecision);\n    if (trim) {\n      result = removeTrailingZeros(result);\n    }\n    if (comma) {\n      result = insertSeparator(result, comma);\n    }\n    result = addSign(n, result, sign);\n    if (symbol && symbol !== \"#\") {\n      result = `${symbol}${result}`;\n    }\n    if (symbol === \"#\" && type === \"x\") {\n      result = `0x${result}`;\n    }\n    if (type === \"s\") {\n      result = `${result}${getSIPrefix(n)}`;\n    }\n    if (type === \"%\" || type === \"p\") {\n      result = `${result}%`;\n    }\n    if (width != null && !isNaN(width)) {\n      result = addPadding(result, width, fill ?? zero, align);\n    }\n    result = `${prefix}${result}${suffix}`;\n    return result;\n  };\n}\nvar formatRegEx = /^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(?:\\.(\\d+))?(~)?([%a-z])?$/i;\nvar surroundedRegEx = /^((?:[^#]|#[^{])*)#{([^}]+)}(.*)$/;\nvar integerTypes = {\n  b: (n) => absFloor(n).toString(2),\n  c: (n) => String.fromCharCode(n),\n  d: (n) => Math.round(Math.abs(n)).toFixed(0),\n  o: (n) => absFloor(n).toString(8),\n  x: (n) => absFloor(n).toString(16),\n  X: (n) => integerTypes.x(n).toUpperCase(),\n  n: (n) => integerTypes.d(n),\n  \"%\": (n) => `${absFloor(n * 100).toFixed(0)}`\n};\nvar decimalTypes = {\n  e: (n, f) => Math.abs(n).toExponential(f),\n  E: (n, f) => decimalTypes.e(n, f).toUpperCase(),\n  f: (n, f) => Math.abs(n).toFixed(f),\n  F: (n, f) => decimalTypes.f(n, f).toUpperCase(),\n  g: (n, f) => {\n    if (n === 0) {\n      return \"0\";\n    }\n    const a = Math.abs(n);\n    const p = Math.floor(Math.log10(a));\n    if (p >= -4 && p < f) {\n      return a.toFixed(f - 1 - p);\n    }\n    return a.toExponential(f - 1);\n  },\n  G: (n, f) => decimalTypes.g(n, f).toUpperCase(),\n  n: (n, f) => decimalTypes.g(n, f),\n  p: (n, f) => decimalTypes.r(n * 100, f),\n  r: (n, f) => {\n    if (n === 0) {\n      return \"0\";\n    }\n    const a = Math.abs(n);\n    const p = Math.floor(Math.log10(a));\n    const q = p - (f - 1);\n    if (q <= 0) {\n      return a.toFixed(-q);\n    }\n    const x = 10 ** q;\n    return (Math.round(a / x) * x).toFixed();\n  },\n  s: (n, f) => {\n    const p = getSIPrefixPower(n);\n    return decimalTypes.r(n / 10 ** p, f);\n  },\n  \"%\": (n, f) => decimalTypes.f(n * 100, f)\n};\nvar minSIPrefix = -24;\nvar maxSIPrefix = 24;\nvar siPrefixes = {\n  [minSIPrefix]: \"y\",\n  [-21]: \"z\",\n  [-18]: \"a\",\n  [-15]: \"f\",\n  [-12]: \"p\",\n  [-9]: \"n\",\n  [-6]: \"\\xB5\",\n  [-3]: \"m\",\n  [0]: \"\",\n  [3]: \"k\",\n  [6]: \"M\",\n  [9]: \"G\",\n  [12]: \"T\",\n  [15]: \"P\",\n  [18]: \"E\",\n  [21]: \"Z\",\n  [maxSIPrefix]: \"Y\"\n};\nvar minusSign = \"\\u2212\";\nfunction absFloor(n) {\n  return Math.floor(Math.abs(n));\n}\nfunction removeTrailingZeros(numString) {\n  return numString.replace(/\\.0+$/, \"\").replace(/(\\.[1-9])0+$/, \"$1\");\n}\nfunction insertSeparator(numString, separator) {\n  let dotIndex = numString.indexOf(\".\");\n  if (dotIndex < 0) {\n    dotIndex = numString.length;\n  }\n  const integerChars = numString.substring(0, dotIndex).split(\"\");\n  const fractionalPart = numString.substring(dotIndex);\n  for (let i = integerChars.length - 3; i > 0; i -= 3) {\n    integerChars.splice(i, 0, separator);\n  }\n  return `${integerChars.join(\"\")}${fractionalPart}`;\n}\nfunction getSIPrefix(n) {\n  return siPrefixes[getSIPrefixPower(n)];\n}\nfunction getSIPrefixPower(n) {\n  return clamp(minSIPrefix, n ? Math.floor(Math.log10(Math.abs(n)) / 3) * 3 : 0, maxSIPrefix);\n}\nfunction addSign(num, numString, signType = \"\") {\n  if (signType === \"(\") {\n    return num >= 0 ? numString : `(${numString})`;\n  }\n  const plusSign = signType === \"+\" ? \"+\" : \"\";\n  return `${num >= 0 ? plusSign : minusSign}${numString}`;\n}\nfunction addPadding(numString, width, fill = \" \", align = \">\") {\n  let result = numString;\n  if (align === \">\" || !align) {\n    result = result.padStart(width, fill);\n  } else if (align === \"<\") {\n    result = result.padEnd(width, fill);\n  } else if (align === \"^\") {\n    const padWidth = Math.max(0, width - result.length);\n    const padLeft = Math.ceil(padWidth / 2);\n    const padRight = Math.floor(padWidth / 2);\n    result = result.padStart(padLeft + result.length, fill);\n    result = result.padEnd(padRight + result.length, fill);\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/util/array.ts\nfunction times(n, callback2) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(callback2(i));\n  }\n  return results;\n}\nfunction extent(values) {\n  if (values.length === 0) {\n    return;\n  }\n  let min = Infinity;\n  let max = -Infinity;\n  for (let n of values) {\n    if (n instanceof Date) {\n      n = n.getTime();\n    }\n    if (typeof n !== \"number\") {\n      continue;\n    }\n    if (n < min) {\n      min = n;\n    }\n    if (n > max) {\n      max = n;\n    }\n  }\n  const result = [min, max];\n  if (result.every(isFinite)) {\n    return result;\n  }\n}\nfunction normalisedExtent(d, min, max) {\n  return normalisedExtentWithMetadata(d, min, max).extent;\n}\nfunction normalisedExtentWithMetadata(d, min, max) {\n  let clipped = false;\n  if (d.length > 2) {\n    d = extent(d) ?? [NaN, NaN];\n  }\n  if (!isNaN(min)) {\n    clipped || (clipped = min > d[0]);\n    d = [min, d[1]];\n  }\n  if (!isNaN(max)) {\n    clipped || (clipped = max < d[1]);\n    d = [d[0], max];\n  }\n  if (d[0] > d[1]) {\n    d = [];\n  }\n  return { extent: d, clipped };\n}\nfunction arraysEqual(a, b) {\n  if (a == null || b == null || a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (Array.isArray(a[i]) && Array.isArray(b[i])) {\n      if (!arraysEqual(a[i], b[i])) {\n        return false;\n      }\n    } else if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toArray(value) {\n  if (typeof value === \"undefined\") {\n    return [];\n  }\n  return Array.isArray(value) ? value : [value];\n}\nfunction unique(array2) {\n  return Array.from(new Set(array2));\n}\nfunction groupBy(array2, iteratee) {\n  return array2.reduce((result, item) => {\n    const groupKey = iteratee(item);\n    result[groupKey] ?? (result[groupKey] = []);\n    result[groupKey].push(item);\n    return result;\n  }, {});\n}\nfunction circularSliceArray(data, size, offset4 = 0) {\n  if (data.length === 0) {\n    return [];\n  }\n  const result = [];\n  for (let i = 0; i < size; i++) {\n    result.push(data.at((i + offset4) % data.length));\n  }\n  return result;\n}\nfunction bifurcate(isLeft, array2) {\n  return array2.reduce(\n    ([left, right], value) => isLeft(value) ? [[...left, value], right] : [left, [...right, value]],\n    [[], []]\n  );\n}\nfunction* mapIterable(src, predicate) {\n  for (const e of src) {\n    yield predicate(e);\n  }\n}\nfunction constStringsIncludes(array2, value) {\n  const casting = array2;\n  return casting.includes(value);\n}\nfunction isInStringUnion(unionValues, value) {\n  return constStringsIncludes(unionValues, value);\n}\nfunction allInStringUnion(unionValues, values) {\n  return !values.some((v) => !isInStringUnion(unionValues, v));\n}\n\n// packages/ag-charts-community/src/util/ticks.ts\nvar tInterval = (timeInterval, baseDuration, step) => ({\n  duration: baseDuration * step,\n  timeInterval,\n  step\n});\nvar TickIntervals = [\n  tInterval(second_default, durationSecond, 1),\n  tInterval(second_default, durationSecond, 5),\n  tInterval(second_default, durationSecond, 15),\n  tInterval(second_default, durationSecond, 30),\n  tInterval(minute_default, durationMinute, 1),\n  tInterval(minute_default, durationMinute, 5),\n  tInterval(minute_default, durationMinute, 15),\n  tInterval(minute_default, durationMinute, 30),\n  tInterval(hour_default, durationHour, 1),\n  tInterval(hour_default, durationHour, 3),\n  tInterval(hour_default, durationHour, 6),\n  tInterval(hour_default, durationHour, 12),\n  tInterval(day_default, durationDay, 1),\n  tInterval(day_default, durationDay, 2),\n  tInterval(week_default, durationWeek, 1),\n  tInterval(week_default, durationWeek, 2),\n  tInterval(week_default, durationWeek, 3),\n  tInterval(month_default, durationMonth, 1),\n  tInterval(month_default, durationMonth, 2),\n  tInterval(month_default, durationMonth, 3),\n  tInterval(month_default, durationMonth, 4),\n  tInterval(month_default, durationMonth, 6),\n  tInterval(year_default, durationYear, 1)\n];\nvar TickMultipliers = [1, 2, 5, 10];\nfunction createTicks(start, stop, count, minCount, maxCount) {\n  if (count < 2) {\n    return range(start, stop, stop - start);\n  }\n  const step = tickStep(start, stop, count, minCount, maxCount);\n  if (isNaN(step)) {\n    return [];\n  }\n  start = Math.ceil(start / step) * step;\n  stop = Math.floor(stop / step) * step;\n  return range(start, stop, step);\n}\nfunction getTickInterval(start, stop, count, minCount, maxCount, targetInterval) {\n  const target = targetInterval ?? Math.abs(stop - start) / Math.max(count, 1);\n  let i = 0;\n  for (const tickInterval of TickIntervals) {\n    if (target <= tickInterval.duration)\n      break;\n    i++;\n  }\n  if (i === 0) {\n    const step2 = Math.max(tickStep(start, stop, count, minCount, maxCount), 1);\n    return millisecond_default.every(step2);\n  } else if (i === TickIntervals.length) {\n    const step2 = targetInterval == null ? tickStep(start / durationYear, stop / durationYear, count, minCount, maxCount) : 1;\n    return year_default.every(step2);\n  }\n  const i0 = TickIntervals[i - 1];\n  const i1 = TickIntervals[i];\n  const { timeInterval, step } = target - i0.duration < i1.duration - target ? i0 : i1;\n  return timeInterval.every(step);\n}\nfunction tickStep(start, end, count, minCount = 0, maxCount = Infinity) {\n  if (start === end) {\n    return 1;\n  }\n  if (count < 1) {\n    return NaN;\n  }\n  const extent2 = Math.abs(end - start);\n  const step = 10 ** Math.floor(Math.log10(extent2 / count));\n  let m = NaN, minDiff = Infinity, isInBounds = false;\n  for (const multiplier of TickMultipliers) {\n    const c = Math.ceil(extent2 / (multiplier * step));\n    const validBounds = c >= minCount && c <= maxCount;\n    if (isInBounds && !validBounds)\n      continue;\n    const diffCount = Math.abs(c - count);\n    if (minDiff > diffCount || isInBounds !== validBounds) {\n      isInBounds || (isInBounds = validBounds);\n      minDiff = diffCount;\n      m = multiplier;\n    }\n  }\n  return m * step;\n}\nfunction decimalPlaces(decimal) {\n  for (let i = decimal.length - 1; i >= 0; i -= 1) {\n    if (decimal[i] !== \"0\") {\n      return i + 1;\n    }\n  }\n  return 0;\n}\nfunction tickFormat(ticks, format) {\n  const options = parseFormat(format ?? \",f\");\n  if (options.precision == null || isNaN(options.precision)) {\n    if (!options.type || \"eEFgGnprs\".includes(options.type)) {\n      options.precision = Math.max(\n        ...ticks.map((x) => {\n          if (!Number.isFinite(x))\n            return 0;\n          const [integer, decimal] = x.toExponential((options.type ? 6 : 12) - 1).split(/\\.|e/g);\n          return (integer !== \"1\" && integer !== \"-1\" ? 1 : 0) + decimalPlaces(decimal) + 1;\n        })\n      );\n    } else if (\"f%\".includes(options.type)) {\n      options.precision = Math.max(\n        ...ticks.map((x) => {\n          if (!Number.isFinite(x) || x === 0)\n            return 0;\n          const l = Math.floor(Math.log10(Math.abs(x)));\n          const digits = options.type ? 6 : 12;\n          const [_integer, decimal] = x.toExponential(digits - 1).split(/\\.|e/g);\n          const decimalLength = decimalPlaces(decimal);\n          return Math.max(0, decimalLength - l);\n        })\n      );\n    }\n  }\n  const formatter = numberFormat(options);\n  return (n) => formatter(Number(n));\n}\nfunction range(start, end, step) {\n  const n = Math.ceil(Math.abs(end - start) / step);\n  const f = 10 ** countFractionDigits(step);\n  const d0 = Math.min(start, end);\n  return times(n + 1, (i) => Math.round((d0 + step * i) * f) / f);\n}\nfunction isDenseInterval(count, availableRange) {\n  if (count >= availableRange) {\n    Logger.warnOnce(\n      `the configured interval results in more than 1 item per pixel, ignoring. Supply a larger interval or omit this configuration`\n    );\n    return true;\n  }\n  return false;\n}\nfunction niceTicksDomain(start, end) {\n  const extent2 = Math.abs(end - start);\n  const step = 10 ** Math.floor(Math.log10(extent2));\n  let minError = Infinity, ticks = [start, end];\n  for (const multiplier of TickMultipliers) {\n    const m = multiplier * step;\n    const d0 = Math.floor(start / m) * m;\n    const d1 = Math.ceil(end / m) * m;\n    const error = 1 - extent2 / Math.abs(d1 - d0);\n    if (minError > error) {\n      minError = error;\n      ticks = [d0, d1];\n    }\n  }\n  return ticks;\n}\nfunction estimateTickCount(rangeExtent, minSpacing, maxSpacing, defaultTickCount, defaultMinSpacing) {\n  defaultMinSpacing = Math.max(defaultMinSpacing, rangeExtent / (defaultTickCount + 1));\n  if (isNaN(minSpacing)) {\n    minSpacing = defaultMinSpacing;\n  }\n  if (isNaN(maxSpacing)) {\n    maxSpacing = rangeExtent;\n  }\n  if (minSpacing > maxSpacing) {\n    if (minSpacing === defaultMinSpacing) {\n      minSpacing = maxSpacing;\n    } else {\n      maxSpacing = minSpacing;\n    }\n  }\n  const maxTickCount = clamp(1, Math.floor(rangeExtent / minSpacing), Math.min(Math.floor(rangeExtent), 100));\n  const minTickCount = Math.min(maxTickCount, Math.ceil(rangeExtent / maxSpacing));\n  const tickCount = clamp(minTickCount, defaultTickCount, maxTickCount);\n  return { minTickCount, maxTickCount, tickCount };\n}\n\n// packages/ag-charts-community/src/scale/logScale.ts\nvar _LogScale = class _LogScale extends ContinuousScale {\n  constructor() {\n    super([1, 10], [0, 1]);\n    this.type = \"log\";\n    this.base = 10;\n    this.baseLog = identity;\n    this.basePow = identity;\n    this.log = (x) => {\n      const start = Math.min(...this.domain);\n      return start >= 0 ? this.baseLog(x) : -this.baseLog(-x);\n    };\n    this.pow = (x) => {\n      const start = Math.min(...this.domain);\n      return start >= 0 ? this.basePow(x) : -this.basePow(-x);\n    };\n    this.defaultClampMode = \"clamped\";\n  }\n  toDomain(d) {\n    return d;\n  }\n  transform(x) {\n    const start = Math.min(...this.domain);\n    return start >= 0 ? Math.log(x) : -Math.log(-x);\n  }\n  transformInvert(x) {\n    const start = Math.min(...this.domain);\n    return start >= 0 ? Math.exp(x) : -Math.exp(-x);\n  }\n  refresh() {\n    if (this.base <= 0) {\n      this.base = 0;\n      Logger.warnOnce(\"expecting a finite Number greater than to 0\");\n    }\n    super.refresh();\n  }\n  update() {\n    if (!this.domain || this.domain.length < 2) {\n      return;\n    }\n    this.baseLog = _LogScale.getBaseLogMethod(this.base);\n    this.basePow = _LogScale.getBasePowerMethod(this.base);\n    if (this.nice) {\n      this.updateNiceDomain();\n    }\n  }\n  updateNiceDomain() {\n    const [d0, d1] = this.domain;\n    const roundStart = d0 > d1 ? Math.ceil : Math.floor;\n    const roundStop = d0 > d1 ? Math.floor : Math.ceil;\n    const n0 = this.pow(roundStart(this.log(d0)));\n    const n1 = this.pow(roundStop(this.log(d1)));\n    this.niceDomain = [n0, n1];\n  }\n  ticks() {\n    const count = this.tickCount ?? 10;\n    if (!this.domain || this.domain.length < 2 || count < 1) {\n      return [];\n    }\n    this.refresh();\n    const base = this.base;\n    const [d0, d1] = this.getDomain();\n    const start = Math.min(d0, d1);\n    const stop = Math.max(d0, d1);\n    let p0 = this.log(start);\n    let p1 = this.log(stop);\n    if (this.interval) {\n      const inBounds = (tick) => tick >= start && tick <= stop;\n      const step = Math.min(Math.abs(this.interval), Math.abs(p1 - p0));\n      const ticks2 = range(p0, p1, step).map(this.pow).filter(inBounds);\n      if (!isDenseInterval(ticks2.length, this.getPixelRange())) {\n        return ticks2;\n      }\n    }\n    const isBaseInteger = base % 1 === 0;\n    const isDiffLarge = p1 - p0 >= count;\n    if (!isBaseInteger || isDiffLarge) {\n      return createTicks(p0, p1, Math.min(p1 - p0, count)).map(this.pow);\n    }\n    const ticks = [];\n    const isPositive = start > 0;\n    p0 = Math.floor(p0) - 1;\n    p1 = Math.round(p1) + 1;\n    const availableSpacing = findRangeExtent(this.range) / count;\n    let lastTickPosition = Infinity;\n    for (let p = p0; p <= p1; p++) {\n      const nextMagnitudeTickPosition = this.convert(this.pow(p + 1));\n      for (let k = 1; k < base; k++) {\n        const q = isPositive ? k : base - k + 1;\n        const t = this.pow(p) * q;\n        const tickPosition = this.convert(t);\n        const prevSpacing = Math.abs(lastTickPosition - tickPosition);\n        const nextSpacing = Math.abs(tickPosition - nextMagnitudeTickPosition);\n        const fits = prevSpacing >= availableSpacing && nextSpacing >= availableSpacing;\n        if (t >= start && t <= stop && (k === 1 || fits || ticks.length === 0)) {\n          ticks.push(t);\n          lastTickPosition = tickPosition;\n        }\n      }\n    }\n    return ticks;\n  }\n  tickFormat({\n    count,\n    ticks,\n    specifier\n  }) {\n    if (count !== Infinity && ticks == null) {\n      this.ticks();\n    }\n    specifier ?? (specifier = this.base === 10 ? \".0e\" : \",\");\n    return isString(specifier) ? numberFormat(specifier) : specifier;\n  }\n  static getBaseLogMethod(base) {\n    switch (base) {\n      case 10:\n        return Math.log10;\n      case Math.E:\n        return Math.log;\n      case 2:\n        return Math.log2;\n      default:\n        const logBase = Math.log(base);\n        return (x) => Math.log(x) / logBase;\n    }\n  }\n  static getBasePowerMethod(base) {\n    switch (base) {\n      case 10:\n        return (x) => x >= 0 ? 10 ** x : 1 / 10 ** -x;\n      case Math.E:\n        return Math.exp;\n      default:\n        return (x) => base ** x;\n    }\n  }\n};\n__decorateClass([\n  Invalidating\n], _LogScale.prototype, \"base\", 2);\nvar LogScale = _LogScale;\n\n// packages/ag-charts-community/src/scale/timeScale.ts\nvar TimeScale = class _TimeScale extends ContinuousScale {\n  constructor() {\n    super([], [0, 1]);\n    this.type = \"time\";\n  }\n  toDomain(d) {\n    return new Date(d);\n  }\n  convert(x, opts) {\n    return super.convert(new Date(x), opts);\n  }\n  invert(y) {\n    return new Date(super.invert(y));\n  }\n  /**\n   * Returns uniformly-spaced dates that represent the scale's domain.\n   */\n  ticks() {\n    if (!this.domain || this.domain.length < 2) {\n      return [];\n    }\n    this.refresh();\n    const { interval, nice, tickCount, minTickCount, maxTickCount } = this;\n    const [start, stop] = findMinMax(this.getDomain().map(dateToNumber));\n    if (interval != null) {\n      return _TimeScale.getTicksForInterval({ start, stop, interval, availableRange: this.getPixelRange() }) ?? _TimeScale.getDefaultTicks({ start, stop, tickCount, minTickCount, maxTickCount });\n    } else if (nice && tickCount === 2) {\n      return this.niceDomain;\n    } else if (nice && tickCount === 1) {\n      return this.niceDomain.slice(0, 1);\n    }\n    return _TimeScale.getDefaultTicks({ start, stop, tickCount, minTickCount, maxTickCount });\n  }\n  static getDefaultTicks({\n    start,\n    stop,\n    tickCount,\n    minTickCount,\n    maxTickCount\n  }) {\n    const t = getTickInterval(start, stop, tickCount, minTickCount, maxTickCount);\n    return t ? t.range(new Date(start), new Date(stop)) : [];\n  }\n  static getTicksForInterval({\n    start,\n    stop,\n    interval,\n    availableRange\n  }) {\n    if (!interval) {\n      return [];\n    }\n    if (interval instanceof TimeInterval) {\n      const ticks2 = interval.range(new Date(start), new Date(stop));\n      if (isDenseInterval(ticks2.length, availableRange)) {\n        return;\n      }\n      return ticks2;\n    }\n    const absInterval = Math.abs(interval);\n    if (isDenseInterval((stop - start) / absInterval, availableRange))\n      return;\n    const reversedInterval = [...TickIntervals].reverse();\n    const timeInterval = reversedInterval.find((tickInterval) => absInterval % tickInterval.duration === 0);\n    if (timeInterval) {\n      const i = timeInterval.timeInterval.every(absInterval / (timeInterval.duration / timeInterval.step));\n      return i.range(new Date(start), new Date(stop));\n    }\n    let date = new Date(start);\n    const stopDate = new Date(stop);\n    const ticks = [];\n    while (date <= stopDate) {\n      ticks.push(date);\n      date = new Date(date);\n      date.setMilliseconds(date.getMilliseconds() + absInterval);\n    }\n    return ticks;\n  }\n  /**\n   * Returns a time format function suitable for displaying tick values.\n   * @param specifier If the specifier string is provided, this method is equivalent to\n   * the {@link TimeLocaleObject.format} method.\n   * If no specifier is provided, this method returns the default time format function.\n   */\n  tickFormat({\n    ticks,\n    domain,\n    specifier,\n    formatOffset\n  }) {\n    return specifier == null ? defaultTimeTickFormat(ticks, domain, formatOffset) : buildFormatter(specifier);\n  }\n  update() {\n    if (!this.domain || this.domain.length < 2) {\n      return;\n    }\n    if (this.nice) {\n      this.updateNiceDomain();\n    }\n  }\n  /**\n   * Extends the domain so that it starts and ends on nice round values.\n   * This method typically modifies the scales domain, and may only extend the bounds to the nearest round value.\n   */\n  updateNiceDomain() {\n    const maxAttempts = 4;\n    let [d0, d1] = this.domain;\n    for (let i = 0; i < maxAttempts; i++) {\n      this.updateNiceDomainIteration(d0, d1);\n      const [n0, n1] = this.niceDomain;\n      if (dateToNumber(d0) === dateToNumber(n0) && dateToNumber(d1) === dateToNumber(n1)) {\n        break;\n      }\n      d0 = n0;\n      d1 = n1;\n    }\n  }\n  updateNiceDomainIteration(d0, d1) {\n    const start = Math.min(dateToNumber(d0), dateToNumber(d1));\n    const stop = Math.max(dateToNumber(d0), dateToNumber(d1));\n    const isReversed = d0 > d1;\n    const { interval } = this;\n    let i;\n    if (interval instanceof TimeInterval) {\n      i = interval;\n    } else {\n      const tickCount = typeof interval === \"number\" ? (stop - start) / Math.max(interval, 1) : this.tickCount;\n      i = getTickInterval(start, stop, tickCount, this.minTickCount, this.maxTickCount);\n    }\n    if (i) {\n      const intervalRange = i.range(new Date(start), new Date(stop), true);\n      const domain = isReversed ? [...intervalRange].reverse() : intervalRange;\n      const n0 = domain[0];\n      const n1 = domain.at(-1);\n      this.niceDomain = [n0, n1];\n    }\n  }\n};\n\n// packages/ag-charts-community/src/scale/ordinalTimeScale.ts\nfunction compareNumbers(a, b) {\n  return a - b;\n}\nvar _OrdinalTimeScale = class _OrdinalTimeScale extends BandScale {\n  constructor() {\n    super(...arguments);\n    this.type = \"ordinal-time\";\n    this.tickCount = ContinuousScale.defaultTickCount;\n    this.minTickCount = 0;\n    this.maxTickCount = Infinity;\n    this.interval = void 0;\n    this._domain = [];\n    this.timestamps = [];\n    this.sortedTimestamps = [];\n    this.visibleRange = [0, 1];\n  }\n  static is(value) {\n    return value instanceof _OrdinalTimeScale;\n  }\n  setVisibleRange(visibleRange) {\n    this.visibleRange = visibleRange;\n  }\n  set domain(values) {\n    this.invalid = true;\n    if (values.length === 0) {\n      this._domain = [];\n      return;\n    }\n    this._domain = values;\n    this.timestamps = unique(values.map(dateToNumber));\n    this.sortedTimestamps = this.timestamps.slice().sort(compareNumbers);\n  }\n  get domain() {\n    return this._domain;\n  }\n  ticks() {\n    this.refresh();\n    const [t0, t1] = [this.timestamps[0], this.timestamps.at(-1)];\n    const start = Math.min(t0, t1);\n    const stop = Math.max(t0, t1);\n    const isReversed = t0 > t1;\n    let ticks;\n    if (this.interval == null) {\n      ticks = this.getDefaultTicks(this.maxTickCount, isReversed);\n    } else {\n      const [r0, r1] = this.range;\n      const availableRange = Math.abs(r1 - r0);\n      ticks = TimeScale.getTicksForInterval({ start, stop, interval: this.interval, availableRange }) ?? [];\n    }\n    const tickPositions = /* @__PURE__ */ new Set();\n    return ticks.filter((tick) => {\n      const position = this.convert(tick);\n      if (isNaN(position) || tickPositions.has(position)) {\n        return false;\n      }\n      tickPositions.add(position);\n      return true;\n    });\n  }\n  getDefaultTicks(maxTickCount, isReversed) {\n    const ticks = [];\n    const count = this.timestamps.length;\n    const tickEvery = Math.ceil(count * (this.visibleRange[1] - this.visibleRange[0]) / maxTickCount);\n    const tickOffset = Math.floor(tickEvery / 2);\n    for (const [index, value] of this.timestamps.entries()) {\n      if (tickEvery > 0 && (index + tickOffset) % tickEvery)\n        continue;\n      if (isReversed) {\n        ticks.push(new Date(this.timestamps[count - index - 1]));\n      } else {\n        ticks.push(new Date(value));\n      }\n    }\n    return ticks;\n  }\n  convert(d) {\n    this.refresh();\n    const n = Number(d);\n    if (n < this.sortedTimestamps[0]) {\n      return NaN;\n    }\n    let i = this.findInterval(n);\n    if (this.timestamps[0] !== this.sortedTimestamps[0]) {\n      i = this.timestamps.length - i - 1;\n    }\n    return this.ordinalRange[i] ?? NaN;\n  }\n  findInterval(target) {\n    const { sortedTimestamps } = this;\n    let low = 0;\n    let high = sortedTimestamps.length - 1;\n    while (low <= high) {\n      const mid = Math.floor((low + high) / 2);\n      if (sortedTimestamps[mid] === target) {\n        return mid;\n      } else if (sortedTimestamps[mid] < target) {\n        low = mid + 1;\n      } else {\n        high = mid - 1;\n      }\n    }\n    return low;\n  }\n  /**\n   * Returns a time format function suitable for displaying tick values.\n   * @param specifier If the specifier string is provided, this method is equivalent to\n   * the {@link TimeLocaleObject.format} method.\n   * If no specifier is provided, this method returns the default time format function.\n   */\n  tickFormat({\n    ticks,\n    domain,\n    specifier\n  }) {\n    return specifier == null ? defaultTimeTickFormat(ticks, domain) : buildFormatter(specifier);\n  }\n  invert(position) {\n    this.refresh();\n    const index = this.ordinalRange.findIndex((p) => position <= p);\n    return this.domain[index];\n  }\n  invertNearest(y) {\n    return new Date(super.invertNearest(y));\n  }\n};\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"tickCount\", 2);\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"minTickCount\", 2);\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"maxTickCount\", 2);\n__decorateClass([\n  Invalidating\n], _OrdinalTimeScale.prototype, \"interval\", 2);\nvar OrdinalTimeScale = _OrdinalTimeScale;\n\n// packages/ag-charts-community/src/util/compare.ts\nfunction ascendingStringNumberUndefined(a, b) {\n  if (typeof a === \"number\" && typeof b === \"number\") {\n    return a - b;\n  } else if (typeof a === \"string\" && typeof b === \"string\") {\n    return a.localeCompare(b);\n  } else if (a == null && b == null) {\n    return 0;\n  } else if (a == null) {\n    return -1;\n  } else if (b == null) {\n    return 1;\n  }\n  return String(a).localeCompare(String(b));\n}\nfunction toLiteral(v) {\n  return typeof v === \"function\" ? v() : v;\n}\nfunction compoundAscending(a, b, comparator) {\n  for (const idx in a) {\n    const diff2 = comparator(toLiteral(a[idx]), toLiteral(b[idx]));\n    if (diff2 !== 0) {\n      return diff2;\n    }\n  }\n  return 0;\n}\n\n// packages/ag-charts-community/src/scene/group.ts\nvar _Group = class _Group extends Node {\n  constructor(opts) {\n    super({ isVirtual: opts?.isVirtual, name: opts?.name });\n    this.opts = opts;\n    this.opacity = 1;\n    this.lastBBox = void 0;\n    const { zIndex, zIndexSubOrder } = opts ?? {};\n    this.isContainerNode = true;\n    if (zIndex !== void 0) {\n      this.zIndex = zIndex;\n    }\n    if (zIndexSubOrder !== void 0) {\n      this.zIndexSubOrder = zIndexSubOrder;\n    }\n  }\n  static is(value) {\n    return value instanceof _Group;\n  }\n  onZIndexChange() {\n    super.onZIndexChange();\n    if (this.layer) {\n      this._layerManager?.moveLayer(this.layer, this.zIndex, this.zIndexSubOrder);\n    }\n  }\n  isLayer() {\n    return this.layer != null;\n  }\n  _setLayerManager(layersManager) {\n    if (this._layerManager && this.layer) {\n      this._layerManager.removeLayer(this.layer);\n      this.layer = void 0;\n    }\n    if (this.layer) {\n      throw new Error(\"AG Charts - unable to deregister scene rendering layer!\");\n    }\n    super._setLayerManager(layersManager);\n  }\n  initialiseLayer() {\n    if (this.layer)\n      return;\n    if (!this._layerManager || this.opts?.layer !== true)\n      return;\n    this.layer = this._layerManager.addLayer({\n      name: this.name,\n      zIndex: this.zIndex,\n      zIndexSubOrder: this.zIndexSubOrder,\n      getComputedOpacity: () => this.getComputedOpacity(),\n      getVisibility: () => this.getVisibility()\n    });\n  }\n  getComputedOpacity() {\n    let opacity = 1;\n    for (const node of this.traverseUp()) {\n      if (node instanceof _Group) {\n        opacity *= node.opacity;\n      }\n    }\n    return opacity;\n  }\n  getVisibility() {\n    for (const node of this.traverseUp()) {\n      if (!node.visible) {\n        return false;\n      }\n    }\n    return true;\n  }\n  onVisibleChange() {\n    if (this.layer) {\n      this.layer.enabled = this.visible;\n    }\n  }\n  markDirty(source, type = 1 /* TRIVIAL */) {\n    if (this.isVirtual) {\n      super.markDirty(source, type);\n      return;\n    }\n    let parentType = type;\n    if (type < 2 /* MINOR */ || this.layer != null) {\n      parentType = 1 /* TRIVIAL */;\n    }\n    super.markDirty(source, type, parentType);\n  }\n  // We consider a group to be boundless, thus any point belongs to it.\n  containsPoint(_x, _y) {\n    return true;\n  }\n  computeBBox() {\n    this.computeTransformMatrix();\n    return _Group.computeBBox(this.children);\n  }\n  computeTransformedBBox() {\n    return this.getBBox();\n  }\n  computeTransformedRegionBBox() {\n    if (this.clipRect) {\n      this.computeTransformMatrix();\n      return this.matrix.transformBBox(this.clipRect);\n    }\n    return this.computeTransformedBBox();\n  }\n  preRender() {\n    const counts = super.preRender();\n    counts.groups += 1;\n    counts.nonGroups -= 1;\n    if (this.opts?.layer !== true || this.layer != null)\n      return counts;\n    if (counts.nonGroups > 0) {\n      this.initialiseLayer();\n    }\n    if (this.opts?.nonEmptyChildDerivedZIndex && counts.nonGroups > 0) {\n      this.deriveZIndexFromChildren();\n    }\n    return counts;\n  }\n  deriveZIndexFromChildren() {\n    const children = this.children.filter((c) => c._childNodeCounts.nonGroups > 0);\n    this.sortChildren(children);\n    const lastChild = children.at(-1);\n    this.zIndex = lastChild?.zIndex ?? -Infinity;\n    this.zIndexSubOrder = lastChild?.zIndexSubOrder;\n  }\n  render(renderCtx) {\n    const { opts: { name = void 0 } = {}, _debug: debug3 } = this;\n    const { dirty, dirtyZIndex, layer, children, clipRect, dirtyTransform } = this;\n    let { ctx, forceRender, clipBBox } = renderCtx;\n    const { resized, stats } = renderCtx;\n    const canvasCtxTransform = ctx.getTransform();\n    const isDirty = dirty >= 2 /* MINOR */ || dirtyZIndex || resized;\n    let isChildDirty = isDirty;\n    let isChildLayerDirty = false;\n    for (const child of children) {\n      isChildDirty || (isChildDirty = child.layerManager == null && child.dirty >= 1 /* TRIVIAL */);\n      isChildLayerDirty || (isChildLayerDirty = child.layerManager != null && child.dirty >= 1 /* TRIVIAL */);\n      if (isChildDirty) {\n        break;\n      }\n    }\n    if (name) {\n      debug3?.({ name, group: this, isDirty, isChildDirty, dirtyTransform, renderCtx, forceRender });\n    }\n    if (dirtyTransform) {\n      forceRender = \"dirtyTransform\";\n    } else if (layer) {\n      const currentBBox = this.getBBox();\n      if (this.lastBBox === void 0 || !this.lastBBox.equals(currentBBox)) {\n        forceRender = \"dirtyTransform\";\n        this.lastBBox = currentBBox;\n      }\n    }\n    if (!isDirty && !isChildDirty && !isChildLayerDirty && !forceRender) {\n      if (name && stats) {\n        debug3?.({ name, result: \"skipping\", renderCtx, counts: this.nodeCount, group: this });\n      }\n      if (layer && stats) {\n        stats.layersSkipped++;\n        stats.nodesSkipped += this.nodeCount.count;\n      }\n      this.markClean({ recursive: false });\n      return;\n    }\n    const groupVisible = this.visible;\n    if (layer) {\n      ctx = layer.context;\n      ctx.save();\n      ctx.setTransform(layer.pixelRatio, 0, 0, layer.pixelRatio, 0, 0);\n      if (forceRender !== \"dirtyTransform\") {\n        forceRender = isChildDirty || dirtyZIndex;\n      }\n      if (forceRender)\n        layer.clear();\n      if (clipBBox) {\n        const { width, height, x, y } = clipBBox;\n        debug3?.(() => ({\n          name,\n          clipBBox,\n          ctxTransform: ctx.getTransform(),\n          renderCtx,\n          group: this\n        }));\n        ctx.beginPath();\n        ctx.rect(x, y, width, height);\n        ctx.clip();\n      }\n      ctx.setTransform(canvasCtxTransform);\n    } else {\n      ctx.globalAlpha *= this.opacity;\n    }\n    const matrix = this.transformRenderContext(renderCtx, ctx);\n    if (clipRect) {\n      const { x, y, width, height } = clipRect;\n      ctx.save();\n      debug3?.(() => ({ name, clipRect, ctxTransform: ctx.getTransform(), renderCtx, group: this }));\n      ctx.beginPath();\n      ctx.rect(x, y, width, height);\n      ctx.clip();\n      clipBBox = matrix.transformBBox(clipRect);\n    }\n    const hasVirtualChildren = this.hasVirtualChildren();\n    if (dirtyZIndex) {\n      this.sortChildren(children);\n      if (forceRender !== \"dirtyTransform\")\n        forceRender = true;\n    } else if (hasVirtualChildren) {\n      this.sortChildren(children);\n    }\n    const renderContextChanged = forceRender !== renderCtx.forceRender || clipBBox !== renderCtx.clipBBox || ctx !== renderCtx.ctx;\n    const childRenderContext = renderContextChanged ? { ...renderCtx, ctx, forceRender, clipBBox } : renderCtx;\n    let skipped = 0;\n    for (const child of children) {\n      if (!child.visible || !groupVisible) {\n        child.markClean();\n        if (stats)\n          skipped += child.nodeCount.count;\n        continue;\n      }\n      if (!forceRender && child.dirty === 0 /* NONE */) {\n        if (stats)\n          skipped += child.nodeCount.count;\n        continue;\n      }\n      ctx.save();\n      child.render(childRenderContext);\n      ctx.restore();\n    }\n    if (stats)\n      stats.nodesSkipped += skipped;\n    super.render(renderCtx);\n    if (clipRect) {\n      ctx.restore();\n    }\n    if (hasVirtualChildren) {\n      for (const child of this.virtualChildren) {\n        child.markClean({ recursive: \"virtual\" });\n      }\n    }\n    if (layer) {\n      if (stats)\n        stats.layersRendered++;\n      ctx.restore();\n      if (forceRender)\n        layer.snapshot();\n      layer.context.verifyDepthZero?.();\n    }\n    if (name && stats) {\n      debug3?.({ name, result: \"rendered\", skipped, renderCtx, counts: this.nodeCount, group: this });\n    }\n  }\n  sortChildren(children) {\n    this.dirtyZIndex = false;\n    children.sort(\n      (a, b) => compoundAscending(\n        [a.zIndex, ...a.zIndexSubOrder ?? [void 0, void 0], a.serialNumber],\n        [b.zIndex, ...b.zIndexSubOrder ?? [void 0, void 0], b.serialNumber],\n        ascendingStringNumberUndefined\n      )\n    );\n  }\n  static computeBBox(nodes, opts) {\n    let left = Infinity;\n    let right = -Infinity;\n    let top = Infinity;\n    let bottom = -Infinity;\n    const skipInvisible = opts?.skipInvisible ?? true;\n    for (const n of nodes) {\n      if (skipInvisible && !n.visible)\n        continue;\n      const bbox = n.computeTransformedBBox();\n      if (!bbox)\n        continue;\n      const { x, y, width, height } = bbox;\n      if (x < left) {\n        left = x;\n      }\n      if (y < top) {\n        top = y;\n      }\n      if (x + width > right) {\n        right = x + width;\n      }\n      if (y + height > bottom) {\n        bottom = y + height;\n      }\n    }\n    return new BBox(left, top, right - left, bottom - top);\n  }\n  /**\n   * Transforms bbox given in the canvas coordinate space to bbox in this group's coordinate space and\n   * sets this group's clipRect to the transformed bbox.\n   * @param bbox clipRect bbox in the canvas coordinate space.\n   */\n  setClipRectInGroupCoordinateSpace(bbox) {\n    this.clipRect = bbox ? this.transformBBox(bbox) : void 0;\n  }\n};\n_Group.className = \"Group\";\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 3 /* MAJOR */,\n    convertor: (v) => clamp(0, v, 1)\n  })\n], _Group.prototype, \"opacity\", 2);\nvar Group = _Group;\n\n// packages/ag-charts-community/src/util/dom.ts\nvar verifiedGlobals = {};\nif (typeof window !== \"undefined\") {\n  verifiedGlobals.window = window;\n} else if (typeof global !== \"undefined\") {\n  verifiedGlobals.window = global.window;\n}\nif (typeof document !== \"undefined\") {\n  verifiedGlobals.document = document;\n} else if (typeof global !== \"undefined\") {\n  verifiedGlobals.document = global.document;\n}\nfunction getDocument(propertyName) {\n  return propertyName ? verifiedGlobals.document?.[propertyName] : verifiedGlobals.document;\n}\nfunction getWindow(propertyName) {\n  return propertyName ? verifiedGlobals.window?.[propertyName] : verifiedGlobals.window;\n}\nfunction createElement(tagName, className, style) {\n  const element2 = getDocument().createElement(tagName);\n  if (typeof className === \"object\") {\n    style = className;\n    className = void 0;\n  }\n  if (className) {\n    element2.classList.add(className);\n  }\n  if (style) {\n    Object.assign(element2.style, style);\n  }\n  return element2;\n}\nfunction createElementNS(namespaceURI, qualifiedName) {\n  return getDocument().createElementNS(namespaceURI, qualifiedName);\n}\nfunction downloadUrl(dataUrl, fileName) {\n  const { body } = getDocument();\n  const element2 = createElement(\"a\", { display: \"none\" });\n  element2.href = dataUrl;\n  element2.download = fileName;\n  body.appendChild(element2);\n  element2.click();\n  setTimeout(() => body.removeChild(element2));\n}\nfunction setDocument(document2) {\n  verifiedGlobals.document = document2;\n}\nfunction setWindow(window2) {\n  verifiedGlobals.window = window2;\n}\nfunction setElementBBox(element2, bbox) {\n  if (element2) {\n    element2.style.width = `${bbox.width}px`;\n    element2.style.height = `${bbox.height}px`;\n    element2.style.left = `${bbox.x}px`;\n    element2.style.top = `${bbox.y}px`;\n  }\n}\n\n// packages/ag-charts-community/src/util/debug.ts\nvar LONG_TIME_PERIOD_THRESHOLD = 2e3;\nvar timeOfLastLog = Date.now();\nvar logTimeGap = () => {\n  const timeSinceLastLog = Date.now() - timeOfLastLog;\n  if (timeSinceLastLog > LONG_TIME_PERIOD_THRESHOLD) {\n    const prettyDuration = (Math.floor(timeSinceLastLog / 100) / 10).toFixed(1);\n    Logger.log(`**** ${prettyDuration}s since last log message ****`);\n  }\n  timeOfLastLog = Date.now();\n};\nvar Debug = {\n  create(...debugSelectors) {\n    const resultFn = (...logContent) => {\n      if (Debug.check(...debugSelectors)) {\n        if (typeof logContent[0] === \"function\") {\n          logContent = toArray(logContent[0]());\n        }\n        logTimeGap();\n        Logger.log(...logContent);\n      }\n    };\n    return Object.assign(resultFn, { check: () => Debug.check(...debugSelectors) });\n  },\n  check(...debugSelectors) {\n    if (debugSelectors.length === 0) {\n      debugSelectors.push(true);\n    }\n    const chartDebug = toArray(getWindow(\"agChartsDebug\"));\n    return chartDebug.some((selector) => debugSelectors.includes(selector));\n  }\n};\n\n// packages/ag-charts-community/src/scene/selection.ts\nvar Selection = class _Selection {\n  constructor(parentNode, classOrFactory, autoCleanup = true) {\n    this.parentNode = parentNode;\n    this.autoCleanup = autoCleanup;\n    this.garbageBin = /* @__PURE__ */ new Set();\n    this._nodesMap = /* @__PURE__ */ new Map();\n    this._nodes = [];\n    this.data = [];\n    this.debug = Debug.create(true, \"scene\", \"scene:selections\");\n    this.nodeFactory = Object.prototype.isPrototypeOf.call(Node, classOrFactory) ? () => new classOrFactory() : classOrFactory;\n  }\n  static select(parent, classOrFactory, garbageCollection = true) {\n    return new _Selection(parent, classOrFactory, garbageCollection);\n  }\n  static selectAll(parent, predicate) {\n    const results = [];\n    const traverse = (node) => {\n      if (predicate(node)) {\n        results.push(node);\n      }\n      node.children.forEach(traverse);\n    };\n    traverse(parent);\n    return results;\n  }\n  static selectByClass(node, Class, ...ExtraClasses) {\n    return _Selection.selectAll(node, (n) => {\n      return n instanceof Class || ExtraClasses.some((C) => n instanceof C);\n    });\n  }\n  static selectByTag(node, tag) {\n    return _Selection.selectAll(node, (n) => n.tag === tag);\n  }\n  createNode(datum, initializer, idx) {\n    const node = this.nodeFactory(datum);\n    node.datum = datum;\n    initializer?.(node);\n    if (idx == null) {\n      this._nodes.push(node);\n    } else {\n      this._nodes.splice(idx, 0, node);\n    }\n    this.parentNode.appendChild(node);\n    return node;\n  }\n  /**\n   * Update the data in a selection. If an `getDatumId()` function is provided, maintain a list of ids related to\n   * the nodes. Otherwise, take the more efficient route of simply creating and destroying nodes at the end\n   * of the array.\n   */\n  update(data, initializer, getDatumId) {\n    if (this.garbageBin.size > 0) {\n      this.debug(`Selection - update() called with pending garbage: ${data}`);\n    }\n    if (getDatumId) {\n      const dataMap = new Map(\n        data.map((datum, idx) => [getDatumId(datum), [datum, idx]])\n      );\n      for (const [node, datumId] of this._nodesMap.entries()) {\n        if (dataMap.has(datumId)) {\n          const [newDatum] = dataMap.get(datumId);\n          node.datum = newDatum;\n          this.garbageBin.delete(node);\n          dataMap.delete(datumId);\n        } else {\n          this.garbageBin.add(node);\n        }\n      }\n      for (const [datumId, [datum, idx]] of dataMap.entries()) {\n        this._nodesMap.set(this.createNode(datum, initializer, idx), datumId);\n      }\n    } else {\n      const maxLength = Math.max(data.length, this.data.length);\n      for (let i = 0; i < maxLength; i++) {\n        if (i >= data.length) {\n          this.garbageBin.add(this._nodes[i]);\n        } else if (i >= this._nodes.length) {\n          this.createNode(data[i], initializer);\n        } else {\n          this._nodes[i].datum = data[i];\n          this.garbageBin.delete(this._nodes[i]);\n        }\n      }\n    }\n    this.data = data.slice();\n    if (this.autoCleanup) {\n      this.cleanup();\n    }\n    return this;\n  }\n  cleanup() {\n    if (this.garbageBin.size === 0) {\n      return this;\n    }\n    this._nodes = this._nodes.filter((node) => {\n      if (this.garbageBin.has(node)) {\n        this._nodesMap.delete(node);\n        this.garbageBin.delete(node);\n        node.destroy();\n        return false;\n      }\n      return true;\n    });\n    return this;\n  }\n  clear() {\n    this.update([]);\n    return this;\n  }\n  isGarbage(node) {\n    return this.garbageBin.has(node);\n  }\n  hasGarbage() {\n    return this.garbageBin.size > 0;\n  }\n  each(iterate2) {\n    for (const entry of this._nodes.entries()) {\n      iterate2(entry[1], entry[1].datum, entry[0]);\n    }\n    return this;\n  }\n  *[Symbol.iterator]() {\n    for (let index = 0; index < this._nodes.length; index++) {\n      const node = this._nodes[index];\n      const datum = this._nodes[index].datum;\n      yield { node, datum, index };\n    }\n  }\n  select(predicate) {\n    return _Selection.selectAll(this.parentNode, predicate);\n  }\n  selectByClass(Class) {\n    return _Selection.selectByClass(this.parentNode, Class);\n  }\n  selectByTag(tag) {\n    return _Selection.selectByTag(this.parentNode, tag);\n  }\n  nodes() {\n    return this._nodes;\n  }\n  at(index) {\n    return this._nodes.at(index);\n  }\n};\n\n// packages/ag-charts-community/src/util/angle.ts\nvar twoPi = Math.PI * 2;\nfunction normalizeAngle360(radians) {\n  radians %= twoPi;\n  radians += twoPi;\n  radians %= twoPi;\n  return radians;\n}\nfunction normalizeAngle360Inclusive(radians) {\n  radians %= twoPi;\n  radians += twoPi;\n  if (radians !== twoPi) {\n    radians %= twoPi;\n  }\n  return radians;\n}\nfunction normalizeAngle180(radians) {\n  radians %= twoPi;\n  if (radians < -Math.PI) {\n    radians += twoPi;\n  } else if (radians >= Math.PI) {\n    radians -= twoPi;\n  }\n  return radians;\n}\nfunction isBetweenAngles(targetAngle, startAngle, endAngle) {\n  const t = normalizeAngle360(targetAngle);\n  const a0 = normalizeAngle360(startAngle);\n  const a1 = normalizeAngle360(endAngle);\n  if (a0 < a1) {\n    return a0 <= t && t <= a1;\n  } else if (a0 > a1) {\n    return a0 <= t || t <= a1;\n  } else {\n    return true;\n  }\n}\nfunction toRadians(degrees) {\n  return degrees / 180 * Math.PI;\n}\nfunction toDegrees(radians) {\n  return radians / Math.PI * 180;\n}\nfunction angleDiff(angle0, angle1, counterClockwise) {\n  if (counterClockwise) {\n    [angle0, angle1] = [angle1, angle0];\n  }\n  const a0 = normalizeAngle360(angle0);\n  const a1 = normalizeAngle360(angle1) + twoPi;\n  return (a1 - a0) % twoPi;\n}\nfunction angleBetween(angle0, angle1) {\n  angle0 = normalizeAngle360(angle0);\n  angle1 = normalizeAngle360(angle1);\n  return angle1 - angle0 + (angle0 > angle1 ? 2 * Math.PI : 0);\n}\nfunction displacePointFromVector(centerX, centerY, radius, angle2) {\n  const x = centerX + radius * Math.cos(angle2);\n  const y = centerY + radius * Math.sin(angle2);\n  return { x, y };\n}\n\n// packages/ag-charts-community/src/util/distance.ts\nfunction pointsDistanceSquared(x1, y1, x2, y2) {\n  const dx = x1 - x2;\n  const dy = y1 - y2;\n  return dx * dx + dy * dy;\n}\nfunction lineDistanceSquared(x, y, x1, y1, x2, y2, best) {\n  if (x1 === x2 && y1 === y2) {\n    return Math.min(best, pointsDistanceSquared(x, y, x1, y1));\n  }\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const t = Math.max(0, Math.min(1, ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy)));\n  const ix = x1 + t * dx;\n  const iy = y1 + t * dy;\n  return Math.min(best, pointsDistanceSquared(x, y, ix, iy));\n}\nfunction arcDistanceSquared(x, y, cx, cy, radius, startAngle, endAngle, counterClockwise, best) {\n  if (counterClockwise) {\n    [endAngle, startAngle] = [startAngle, endAngle];\n  }\n  const angle2 = Math.atan2(y - cy, x - cx);\n  if (!isBetweenAngles(angle2, startAngle, endAngle)) {\n    const startX = cx + Math.cos(startAngle) * radius;\n    const startY = cy + Math.sin(startAngle) * radius;\n    const endX = cx + Math.cos(startAngle) * radius;\n    const endY = cy + Math.sin(startAngle) * radius;\n    return Math.min(best, pointsDistanceSquared(x, y, startX, startY), pointsDistanceSquared(x, y, endX, endY));\n  }\n  const distToArc = radius - Math.sqrt(pointsDistanceSquared(x, y, cx, cy));\n  return Math.min(best, distToArc * distToArc);\n}\n\n// packages/ag-charts-community/src/scene/gradient/gradient.ts\nvar Gradient = class {\n  constructor(stops = []) {\n    this.stops = stops;\n  }\n};\n\n// packages/ag-charts-community/src/scene/gradient/linearGradient.ts\nvar LinearGradient = class extends Gradient {\n  constructor(stops, angle2 = 0) {\n    super(stops);\n    this.angle = angle2;\n  }\n  createGradient(ctx, bbox) {\n    const angleOffset = 90;\n    const { stops, angle: angle2 } = this;\n    const radians = normalizeAngle360(toRadians(angle2 + angleOffset));\n    const cos = Math.cos(radians);\n    const sin = Math.sin(radians);\n    const w = bbox.width;\n    const h = bbox.height;\n    const cx = bbox.x + w * 0.5;\n    const cy = bbox.y + h * 0.5;\n    if (w > 0 && h > 0) {\n      const diagonal = Math.sqrt(h * h + w * w) / 2;\n      const diagonalAngle = Math.atan2(h, w);\n      let quarteredAngle;\n      if (radians < Math.PI / 2) {\n        quarteredAngle = radians;\n      } else if (radians < Math.PI) {\n        quarteredAngle = Math.PI - radians;\n      } else if (radians < 1.5 * Math.PI) {\n        quarteredAngle = radians - Math.PI;\n      } else {\n        quarteredAngle = 2 * Math.PI - radians;\n      }\n      const l = diagonal * Math.abs(Math.cos(quarteredAngle - diagonalAngle));\n      const gradient = ctx.createLinearGradient(cx + cos * l, cy + sin * l, cx - cos * l, cy - sin * l);\n      for (const stop of stops) {\n        gradient.addColorStop(stop.offset, stop.color);\n      }\n      return gradient;\n    }\n    return \"black\";\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/shape.ts\nvar LINEAR_GRADIENT_REGEXP = /^linear-gradient\\((-?[\\d.]+)deg,(.*?)\\)$/i;\nvar _Shape = class _Shape extends Node {\n  constructor() {\n    super(...arguments);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.fill = _Shape.defaultStyles.fill;\n    this.stroke = _Shape.defaultStyles.stroke;\n    this.strokeWidth = _Shape.defaultStyles.strokeWidth;\n    this.lineDash = _Shape.defaultStyles.lineDash;\n    this.lineDashOffset = _Shape.defaultStyles.lineDashOffset;\n    this.lineCap = _Shape.defaultStyles.lineCap;\n    this.lineJoin = _Shape.defaultStyles.lineJoin;\n    this.miterLimit = void 0;\n    this.opacity = _Shape.defaultStyles.opacity;\n    this.fillShadow = _Shape.defaultStyles.fillShadow;\n  }\n  /**\n   * Restores the default styles introduced by this subclass.\n   */\n  restoreOwnStyles() {\n    const { defaultStyles } = this.constructor;\n    Object.assign(this, defaultStyles);\n  }\n  onFillChange() {\n    const { fill } = this;\n    let linearGradientMatch;\n    if (fill?.startsWith(\"linear-gradient\") && (linearGradientMatch = LINEAR_GRADIENT_REGEXP.exec(fill))) {\n      const angle2 = parseFloat(linearGradientMatch[1]);\n      const colors = [];\n      const colorsPart = linearGradientMatch[2];\n      const colorRegex = /(#[0-9a-f]+)|(rgba?\\(.+?\\))|([a-z]+)/gi;\n      let c;\n      while (c = colorRegex.exec(colorsPart)) {\n        colors.push(c[0]);\n      }\n      this.gradient = new LinearGradient(\n        colors.map((color, index) => ({ color, offset: index / (colors.length - 1) })),\n        angle2\n      );\n    } else {\n      this.gradient = void 0;\n    }\n  }\n  /**\n   * Returns a device-pixel aligned coordinate (or length if length is supplied).\n   *\n   * NOTE: Not suitable for strokes, since the stroke needs to be offset to the middle\n   * of a device pixel.\n   */\n  align(start, length2) {\n    const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;\n    const alignedStart = Math.round(start * pixelRatio) / pixelRatio;\n    if (length2 == null) {\n      return alignedStart;\n    } else if (length2 === 0) {\n      return 0;\n    } else if (length2 < 1) {\n      return Math.ceil(length2 * pixelRatio) / pixelRatio;\n    }\n    return Math.round((length2 + start) * pixelRatio) / pixelRatio - alignedStart;\n  }\n  fillStroke(ctx, path) {\n    this.renderFill(ctx, path);\n    this.renderStroke(ctx, path);\n  }\n  renderFill(ctx, path) {\n    if (this.fill) {\n      const { globalAlpha } = ctx;\n      this.applyFill(ctx);\n      this.applyFillAlpha(ctx);\n      this.applyShadow(ctx);\n      this.executeFill(ctx, path);\n      ctx.globalAlpha = globalAlpha;\n    }\n    ctx.shadowColor = \"rgba(0, 0, 0, 0)\";\n  }\n  executeFill(ctx, path) {\n    path ? ctx.fill(path) : ctx.fill();\n  }\n  applyFill(ctx) {\n    ctx.fillStyle = this.gradient?.createGradient(ctx, this.getBBox()) ?? this.fill;\n  }\n  applyFillAlpha(ctx) {\n    ctx.globalAlpha *= this.opacity * this.fillOpacity;\n  }\n  applyShadow(ctx) {\n    const pixelRatio = this.layerManager?.canvas.pixelRatio ?? 1;\n    const fillShadow = this.fillShadow;\n    if (fillShadow?.enabled) {\n      ctx.shadowColor = fillShadow.color;\n      ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n      ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n      ctx.shadowBlur = fillShadow.blur * pixelRatio;\n    }\n  }\n  renderStroke(ctx, path) {\n    if (this.stroke && this.strokeWidth) {\n      const { globalAlpha } = ctx;\n      ctx.strokeStyle = this.stroke;\n      ctx.globalAlpha *= this.opacity * this.strokeOpacity;\n      ctx.lineWidth = this.strokeWidth;\n      if (this.lineDash) {\n        ctx.setLineDash(this.lineDash);\n      }\n      if (this.lineDashOffset) {\n        ctx.lineDashOffset = this.lineDashOffset;\n      }\n      if (this.lineCap) {\n        ctx.lineCap = this.lineCap;\n      }\n      if (this.lineJoin) {\n        ctx.lineJoin = this.lineJoin;\n      }\n      if (this.miterLimit != null) {\n        ctx.miterLimit = this.miterLimit;\n      }\n      this.executeStroke(ctx, path);\n      ctx.globalAlpha = globalAlpha;\n    }\n  }\n  executeStroke(ctx, path) {\n    path ? ctx.stroke(path) : ctx.stroke();\n  }\n  containsPoint(x, y) {\n    return this.isPointInPath(x, y);\n  }\n};\n/**\n * Defaults for style properties. Note that properties that affect the position\n * and shape of the node are not considered style properties, for example:\n * `x`, `y`, `width`, `height`, `radius`, `rotation`, etc.\n * Can be used to reset to the original styling after some custom styling\n * has been applied (using the `restoreOwnStyles` method).\n * These static defaults are meant to be inherited by subclasses.\n */\n_Shape.defaultStyles = {\n  fill: \"black\",\n  stroke: void 0,\n  strokeWidth: 0,\n  lineDash: void 0,\n  lineDashOffset: 0,\n  lineCap: void 0,\n  lineJoin: void 0,\n  opacity: 1,\n  fillShadow: void 0\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */, changeCb: (s) => s.onFillChange() })\n], _Shape.prototype, \"fill\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"stroke\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineDash\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineCap\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"lineJoin\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], _Shape.prototype, \"miterLimit\", 2);\n__decorateClass([\n  SceneChangeDetection({\n    redraw: 2 /* MINOR */,\n    convertor: (v) => clamp(0, v, 1)\n  })\n], _Shape.prototype, \"opacity\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */, checkDirtyOnAssignment: true })\n], _Shape.prototype, \"fillShadow\", 2);\nvar Shape = _Shape;\n\n// packages/ag-charts-community/src/scene/shape/line.ts\nvar Line = class extends Shape {\n  constructor(opts = {}) {\n    super(opts);\n    this.x1 = 0;\n    this.y1 = 0;\n    this.x2 = 0;\n    this.y2 = 0;\n    this.restoreOwnStyles();\n  }\n  set x(value) {\n    this.x1 = value;\n    this.x2 = value;\n  }\n  set y(value) {\n    this.y1 = value;\n    this.y2 = value;\n  }\n  computeBBox() {\n    return new BBox(\n      Math.min(this.x1, this.x2),\n      Math.min(this.y1, this.y2),\n      Math.abs(this.x2 - this.x1),\n      Math.abs(this.y2 - this.y1)\n    );\n  }\n  isPointInPath(px, py) {\n    if (this.x1 === this.x2 || this.y1 === this.y2) {\n      const { x, y } = this.transformPoint(px, py);\n      return this.getBBox().clone().grow(this.strokeWidth / 2).containsPoint(x, y);\n    }\n    return false;\n  }\n  distanceSquared(px, py) {\n    const { x1, y1, x2, y2 } = this;\n    return lineDistanceSquared(px, py, x1, y1, x2, y2, Infinity);\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats, devicePixelRatio } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    this.transformRenderContext(renderCtx);\n    let { x1, y1, x2, y2 } = this;\n    if (x1 === x2) {\n      const { strokeWidth } = this;\n      const x = Math.round(x1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);\n      x1 = x;\n      x2 = x;\n    } else if (y1 === y2) {\n      const { strokeWidth } = this;\n      const y = Math.round(y1 * devicePixelRatio) / devicePixelRatio + Math.trunc(strokeWidth * devicePixelRatio) % 2 / (devicePixelRatio * 2);\n      y1 = y;\n      y2 = y;\n    }\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    this.fillStroke(ctx);\n    this.fillShadow?.markClean();\n    super.render(renderCtx);\n  }\n};\nLine.className = \"Line\";\nLine.defaultStyles = Object.assign({}, Shape.defaultStyles, {\n  fill: void 0,\n  strokeWidth: 1\n});\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"x1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"y1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"x2\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Line.prototype, \"y2\", 2);\n\n// packages/ag-charts-community/src/util/canvas.util.ts\nfunction createCanvasContext(width = 0, height = 0) {\n  return new OffscreenCanvas(width, height).getContext(\"2d\");\n}\n\n// packages/ag-charts-community/src/util/lruCache.ts\nvar LRUCache = class {\n  constructor(maxCacheSize = 5) {\n    this.maxCacheSize = maxCacheSize;\n    this.store = /* @__PURE__ */ new Map();\n  }\n  get(key) {\n    if (!this.store.has(key))\n      return void 0;\n    const hit = this.store.get(key);\n    this.store.delete(key);\n    this.store.set(key, hit);\n    return hit;\n  }\n  has(key) {\n    return this.store.has(key);\n  }\n  set(key, value) {\n    this.store.set(key, value);\n    if (this.store.size > this.maxCacheSize) {\n      const iterator = this.store.keys();\n      let evictCount = this.store.size - this.maxCacheSize;\n      while (evictCount > 0) {\n        const evictKeyIterator = iterator.next();\n        if (!evictKeyIterator.done) {\n          this.store.delete(evictKeyIterator.value);\n        }\n        evictCount--;\n      }\n    }\n    return value;\n  }\n  clear() {\n    this.store.clear();\n  }\n};\n\n// packages/ag-charts-community/src/util/textMeasurer.ts\nvar CachedTextMeasurerPool = class {\n  // Measures the dimensions of the provided text, handling multiline if needed.\n  static measureText(text, options) {\n    const textMeasurer = this.getMeasurer(options);\n    return textMeasurer.measureText(text);\n  }\n  static measureLines(text, options) {\n    const textMeasurer = this.getMeasurer(options);\n    return textMeasurer.measureLines(text);\n  }\n  // Gets a TextMeasurer instance, configuring text alignment and baseline if provided.\n  static getMeasurer(options) {\n    const font = typeof options.font === \"string\" ? options.font : TextUtils.toFontString(options.font);\n    const key = `${font}-${options.textAlign ?? \"start\"}-${options.textBaseline ?? \"alphabetic\"}`;\n    return this.instanceMap.get(key) ?? this.createFontMeasurer(font, options, key);\n  }\n  // Creates or retrieves a TextMeasurer instance for a specific font.\n  static createFontMeasurer(font, options, key) {\n    const ctx = createCanvasContext();\n    ctx.font = font;\n    ctx.textAlign = options.textAlign ?? \"start\";\n    ctx.textBaseline = options.textBaseline ?? \"alphabetic\";\n    const measurer = new CachedTextMeasurer(ctx, options);\n    this.instanceMap.set(key, measurer);\n    return measurer;\n  }\n};\nCachedTextMeasurerPool.instanceMap = new LRUCache(10);\nvar CachedTextMeasurer = class {\n  constructor(ctx, options) {\n    this.ctx = ctx;\n    // cached text measurements\n    this.measureMap = new LRUCache(100);\n    if (options.textAlign) {\n      ctx.textAlign = options.textAlign;\n    }\n    if (options.textBaseline) {\n      ctx.textBaseline = options.textBaseline;\n    }\n    ctx.font = typeof options.font === \"string\" ? options.font : TextUtils.toFontString(options.font);\n    this.textMeasurer = new SimpleTextMeasurer(\n      (t) => this.cachedCtxMeasureText(t),\n      options.textBaseline ?? \"alphabetic\"\n    );\n  }\n  textWidth(text, estimate) {\n    return this.textMeasurer.textWidth(text, estimate);\n  }\n  measureText(text) {\n    return this.textMeasurer.measureText(text);\n  }\n  measureLines(text) {\n    return this.textMeasurer.measureLines(text);\n  }\n  cachedCtxMeasureText(text) {\n    if (!this.measureMap.has(text)) {\n      const rawResult = this.ctx.measureText(text);\n      this.measureMap.set(text, {\n        actualBoundingBoxAscent: rawResult.actualBoundingBoxAscent,\n        emHeightAscent: rawResult.emHeightAscent,\n        emHeightDescent: rawResult.emHeightDescent,\n        actualBoundingBoxDescent: rawResult.actualBoundingBoxDescent,\n        actualBoundingBoxLeft: rawResult.actualBoundingBoxLeft,\n        actualBoundingBoxRight: rawResult.actualBoundingBoxRight,\n        alphabeticBaseline: rawResult.alphabeticBaseline,\n        fontBoundingBoxAscent: rawResult.fontBoundingBoxAscent,\n        fontBoundingBoxDescent: rawResult.fontBoundingBoxDescent,\n        hangingBaseline: rawResult.hangingBaseline,\n        ideographicBaseline: rawResult.ideographicBaseline,\n        width: rawResult.width\n      });\n    }\n    return this.measureMap.get(text);\n  }\n};\nvar TextUtils = class {\n  static toFontString({ fontSize = 10, fontStyle, fontWeight, fontFamily, lineHeight }) {\n    let fontString = \"\";\n    if (fontStyle) {\n      fontString += `${fontStyle} `;\n    }\n    if (fontWeight) {\n      fontString += `${fontWeight} `;\n    }\n    fontString += `${fontSize}px`;\n    if (lineHeight) {\n      fontString += `/${lineHeight}px`;\n    }\n    fontString += ` ${fontFamily}`;\n    return fontString.trim();\n  }\n  static getLineHeight(fontSize) {\n    return Math.ceil(fontSize * this.defaultLineHeight);\n  }\n  // Determines vertical offset modifier based on text baseline.\n  static getVerticalModifier(textBaseline) {\n    switch (textBaseline) {\n      case \"hanging\":\n      case \"top\":\n        return 0;\n      case \"middle\":\n        return 0.5;\n      case \"alphabetic\":\n      case \"bottom\":\n      case \"ideographic\":\n      default:\n        return 1;\n    }\n  }\n};\nTextUtils.EllipsisChar = \"\\u2026\";\n// Representation for text clipping.\nTextUtils.defaultLineHeight = 1.15;\n// Normally between 1.1 and 1.2\nTextUtils.lineSplitter = /\\r?\\n/g;\nvar SimpleTextMeasurer = class {\n  constructor(measureTextFn, textBaseline = \"alphabetic\") {\n    this.measureTextFn = measureTextFn;\n    this.textBaseline = textBaseline;\n    // local chars width cache per TextMeasurer\n    this.charMap = /* @__PURE__ */ new Map();\n  }\n  // Measures metrics for a single line of text.\n  getMetrics(text) {\n    const m = this.measureTextFn(text);\n    m.fontBoundingBoxAscent ?? (m.fontBoundingBoxAscent = m.emHeightAscent);\n    m.fontBoundingBoxDescent ?? (m.fontBoundingBoxDescent = m.emHeightDescent);\n    return {\n      width: m.width,\n      height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,\n      lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,\n      offsetTop: m.actualBoundingBoxAscent,\n      offsetLeft: m.actualBoundingBoxLeft\n    };\n  }\n  // Calculates aggregated metrics for multiline text.\n  getMultilineMetrics(lines) {\n    let width = 0;\n    let height = 0;\n    let offsetTop = 0;\n    let offsetLeft = 0;\n    let baselineDistance = 0;\n    const verticalModifier = TextUtils.getVerticalModifier(this.textBaseline);\n    const lineMetrics = [];\n    let index = 0;\n    const length2 = lines.length;\n    for (const line of lines) {\n      const m = this.measureTextFn(line);\n      m.fontBoundingBoxAscent ?? (m.fontBoundingBoxAscent = m.emHeightAscent);\n      m.fontBoundingBoxDescent ?? (m.fontBoundingBoxDescent = m.emHeightDescent);\n      if (width < m.width) {\n        width = m.width;\n      }\n      if (offsetLeft < m.actualBoundingBoxLeft) {\n        offsetLeft = m.actualBoundingBoxLeft;\n      }\n      if (index === 0) {\n        height += m.actualBoundingBoxAscent;\n        offsetTop += m.actualBoundingBoxAscent;\n      } else {\n        baselineDistance += m.fontBoundingBoxAscent;\n      }\n      if (index === length2 - 1) {\n        height += m.actualBoundingBoxDescent;\n      } else {\n        baselineDistance += m.fontBoundingBoxDescent;\n      }\n      lineMetrics.push({\n        text: line,\n        width: m.width,\n        height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent,\n        lineHeight: m.fontBoundingBoxAscent + m.fontBoundingBoxDescent,\n        offsetTop: m.actualBoundingBoxAscent,\n        offsetLeft: m.actualBoundingBoxLeft\n      });\n      index++;\n    }\n    height += baselineDistance;\n    offsetTop += baselineDistance * verticalModifier;\n    return { width, height, offsetTop, offsetLeft, lineMetrics };\n  }\n  textWidth(text, estimate) {\n    if (estimate) {\n      let estimatedWidth = 0;\n      for (let i = 0; i < text.length; i++) {\n        estimatedWidth += this.textWidth(text.charAt(i));\n      }\n      return estimatedWidth;\n    }\n    if (text.length > 1) {\n      return this.measureTextFn(text).width;\n    }\n    return this.charMap.get(text) ?? this.charWidth(text);\n  }\n  measureText(text) {\n    return this.getMetrics(text);\n  }\n  // Measures the dimensions of the provided text, handling multiline if needed.\n  measureLines(text) {\n    const lines = typeof text === \"string\" ? text.split(TextUtils.lineSplitter) : text;\n    return this.getMultilineMetrics(lines);\n  }\n  charWidth(char) {\n    const { width } = this.measureTextFn(char);\n    this.charMap.set(char, width);\n    return width;\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/text.ts\nfunction SceneFontChangeDetection(opts) {\n  const { redraw = 3 /* MAJOR */, changeCb } = opts ?? {};\n  return SceneChangeDetection({ redraw, type: \"font\", changeCb });\n}\nvar _Text = class _Text extends Shape {\n  constructor() {\n    super(...arguments);\n    this.x = 0;\n    this.y = 0;\n    this.lines = [];\n    this.text = void 0;\n    this.fontSize = 10;\n    this.fontFamily = \"sans-serif\";\n    this.textAlign = _Text.defaultStyles.textAlign;\n    this.textBaseline = _Text.defaultStyles.textBaseline;\n  }\n  onTextChange() {\n    this.lines = this.text?.split(\"\\n\").map((s) => s.trim()) ?? [];\n  }\n  static computeBBox(lines, x, y, opts) {\n    const { offsetTop, offsetLeft, width, height } = CachedTextMeasurerPool.measureLines(lines, opts);\n    return new BBox(x - offsetLeft, y - offsetTop, width, height);\n  }\n  computeBBox() {\n    const { x, y, lines, textBaseline, textAlign } = this;\n    return _Text.computeBBox(lines, x, y, { font: this, textBaseline, textAlign });\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    const bbox = this.getBBox();\n    return bbox ? bbox.containsPoint(point.x, point.y) : false;\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    if (!this.lines.length || !this.layerManager) {\n      if (stats)\n        stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    this.transformRenderContext(renderCtx);\n    const { fill, stroke, strokeWidth } = this;\n    const { pixelRatio } = this.layerManager.canvas;\n    ctx.font = TextUtils.toFontString(this);\n    ctx.textAlign = this.textAlign;\n    ctx.textBaseline = this.textBaseline;\n    if (fill) {\n      ctx.fillStyle = fill;\n      ctx.globalAlpha *= this.opacity * this.fillOpacity;\n      const { fillShadow } = this;\n      if (fillShadow?.enabled) {\n        ctx.shadowColor = fillShadow.color;\n        ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n        ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n        ctx.shadowBlur = fillShadow.blur * pixelRatio;\n      }\n      this.renderLines((line, x, y) => ctx.fillText(line, x, y));\n    }\n    if (stroke && strokeWidth) {\n      ctx.strokeStyle = stroke;\n      ctx.lineWidth = strokeWidth;\n      ctx.globalAlpha *= this.opacity * this.strokeOpacity;\n      const { lineDash, lineDashOffset, lineCap, lineJoin } = this;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      this.renderLines((line, x, y) => ctx.strokeText(line, x, y));\n    }\n    super.render(renderCtx);\n  }\n  renderLines(renderCallback) {\n    const { lines, x, y } = this;\n    const lineHeight = this.lineHeight ?? TextUtils.getLineHeight(this.fontSize);\n    let offsetY = (lineHeight - lineHeight * lines.length) * TextUtils.getVerticalModifier(this.textBaseline);\n    for (const line of lines) {\n      renderCallback(line, x, y + offsetY);\n      offsetY += lineHeight;\n    }\n  }\n  setFont(props) {\n    this.fontFamily = props.fontFamily;\n    this.fontSize = props.fontSize;\n    this.fontStyle = props.fontStyle;\n    this.fontWeight = props.fontWeight;\n  }\n  setAlign(props) {\n    this.textAlign = props.textAlign;\n    this.textBaseline = props.textBaseline;\n  }\n};\n_Text.className = \"Text\";\n// The default line spacing for document editors is usually 1.15\n_Text.defaultLineHeightRatio = 1.15;\n_Text.defaultStyles = Object.assign({}, Shape.defaultStyles, {\n  textAlign: \"start\",\n  fontStyle: void 0,\n  fontWeight: void 0,\n  fontSize: 10,\n  fontFamily: \"sans-serif\",\n  textBaseline: \"alphabetic\"\n});\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"x\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"y\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, changeCb: (o) => o.onTextChange() })\n], _Text.prototype, \"text\", 2);\n__decorateClass([\n  SceneFontChangeDetection()\n], _Text.prototype, \"fontStyle\", 2);\n__decorateClass([\n  SceneFontChangeDetection()\n], _Text.prototype, \"fontWeight\", 2);\n__decorateClass([\n  SceneFontChangeDetection()\n], _Text.prototype, \"fontSize\", 2);\n__decorateClass([\n  SceneFontChangeDetection()\n], _Text.prototype, \"fontFamily\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"textAlign\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"textBaseline\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], _Text.prototype, \"lineHeight\", 2);\nvar Text = _Text;\n\n// packages/ag-charts-community/src/scene/util/labelPlacement.ts\nfunction circleRectOverlap(c, unitCenter, x, y, w, h) {\n  if (c.size === 0) {\n    return false;\n  }\n  let cx = c.x;\n  let cy = c.y;\n  if (unitCenter != null) {\n    cx -= (unitCenter.x - 0.5) * c.size;\n    cy -= (unitCenter.y - 0.5) * c.size;\n  }\n  let edgeX = cx;\n  if (cx < x) {\n    edgeX = x;\n  } else if (cx > x + w) {\n    edgeX = x + w;\n  }\n  let edgeY = cy;\n  if (cy < y) {\n    edgeY = y;\n  } else if (cy > y + h) {\n    edgeY = y + h;\n  }\n  const dx = cx - edgeX;\n  const dy = cy - edgeY;\n  const d = Math.sqrt(dx * dx + dy * dy);\n  return d <= c.size * 0.5;\n}\nfunction rectRectOverlap(r1, x2, y2, w2, h2) {\n  const xOverlap = r1.x + r1.width > x2 && r1.x < x2 + w2;\n  const yOverlap = r1.y + r1.height > y2 && r1.y < y2 + h2;\n  return xOverlap && yOverlap;\n}\nfunction rectContainsRect(r1, r2x, r2y, r2w, r2h) {\n  return r2x + r2w < r1.x + r1.width && r2x > r1.x && r2y > r1.y && r2y + r2h < r1.y + r1.height;\n}\nfunction isPointLabelDatum(x) {\n  return x != null && typeof x.point === \"object\" && typeof x.label === \"object\";\n}\nvar labelPlacements = {\n  top: { x: 0, y: -1 },\n  bottom: { x: 0, y: 1 },\n  left: { x: -1, y: 0 },\n  right: { x: 1, y: 0 }\n};\nfunction placeLabels(data, bounds, padding = 5) {\n  const result = [];\n  data = data.map((d) => d.slice().sort((a, b) => b.point.size - a.point.size));\n  for (let j = 0; j < data.length; j++) {\n    const labels = result[j] = [];\n    const datum = data[j];\n    if (!(datum?.length && datum[0].label)) {\n      continue;\n    }\n    for (let index = 0, ln = datum.length; index < ln; index++) {\n      const d = datum[index];\n      const { point, label, marker } = d;\n      const { text, width, height } = label;\n      const r = point.size * 0.5;\n      let dx = 0;\n      let dy = 0;\n      if (r > 0 && d.placement != null) {\n        const placement = labelPlacements[d.placement];\n        dx = (width * 0.5 + r + padding) * placement.x;\n        dy = (height * 0.5 + r + padding) * placement.y;\n      }\n      const x = point.x - width * 0.5 + dx - ((marker?.center.x ?? 0.5) - 0.5) * point.size;\n      const y = point.y - height * 0.5 + dy - ((marker?.center.y ?? 0.5) - 0.5) * point.size;\n      const withinBounds = !bounds || rectContainsRect(bounds, x, y, width, height);\n      if (!withinBounds) {\n        continue;\n      }\n      const overlapPoints = data.some(\n        (dataDatums) => dataDatums.some(\n          (dataDatum) => circleRectOverlap(dataDatum.point, dataDatum.marker?.center, x, y, width, height)\n        )\n      );\n      if (overlapPoints) {\n        continue;\n      }\n      const overlapLabels = result.some((l2) => l2.some((l3) => rectRectOverlap(l3, x, y, width, height)));\n      if (overlapLabels) {\n        continue;\n      }\n      labels.push({ index, text, x, y, width, height, datum: d });\n    }\n  }\n  return result;\n}\nfunction axisLabelsOverlap(data, padding) {\n  const result = [];\n  for (let index = 0; index < data.length; index++) {\n    const datum = data[index];\n    const {\n      point: { x, y },\n      label: { text }\n    } = datum;\n    let { width, height } = datum.label;\n    width += padding ?? 0;\n    height += padding ?? 0;\n    if (result.some((l) => rectRectOverlap(l, x, y, width, height))) {\n      return true;\n    }\n    result.push({ index, text, x, y, width, height, datum });\n  }\n  return false;\n}\n\n// packages/ag-charts-community/src/util/equal.ts\nfunction areArrayNumbersEqual(arrA, arrB) {\n  return arrA.length === arrB.length && arrA.every((item, i) => Number(item) === Number(arrB[i]));\n}\n\n// packages/ag-charts-community/src/util/proxy.ts\nfunction ProxyProperty(proxyPath, configMetadata) {\n  const pathArray = isArray(proxyPath) ? proxyPath : proxyPath.split(\".\");\n  if (pathArray.length === 1) {\n    const [property] = pathArray;\n    return addTransformToInstanceProperty(\n      (target, _, value) => target[property] = value,\n      (target) => target[property],\n      configMetadata\n    );\n  }\n  return addTransformToInstanceProperty(\n    (target, _, value) => setPath(target, pathArray, value),\n    (target) => getPath(target, pathArray),\n    configMetadata\n  );\n}\nfunction ProxyOnWrite(proxyProperty) {\n  return addTransformToInstanceProperty((target, _, value) => target[proxyProperty] = value);\n}\nfunction ProxyPropertyOnWrite(childName, childProperty) {\n  return addTransformToInstanceProperty((target, key, value) => target[childName][childProperty ?? key] = value);\n}\nfunction ActionOnSet(opts) {\n  const { newValue: newValueFn, oldValue: oldValueFn, changeValue: changeValueFn } = opts;\n  return addTransformToInstanceProperty((target, _, newValue, oldValue) => {\n    if (newValue !== oldValue) {\n      if (oldValue !== void 0) {\n        oldValueFn?.call(target, oldValue);\n      }\n      if (newValue !== void 0) {\n        newValueFn?.call(target, newValue);\n      }\n      changeValueFn?.call(target, newValue, oldValue);\n    }\n    return newValue;\n  });\n}\nfunction ObserveChanges(observerFn) {\n  return addObserverToInstanceProperty(observerFn);\n}\n\n// packages/ag-charts-community/src/util/stateMachine.ts\nvar debugColor = \"color: green\";\nvar debugQuietColor = \"color: grey\";\nvar _StateMachine = class _StateMachine {\n  constructor(defaultState, states, enterEach) {\n    this.defaultState = defaultState;\n    this.states = states;\n    this.enterEach = enterEach;\n    this.debug = Debug.create(true, \"animation\");\n    this.state = defaultState;\n    this.debug(`%c${this.constructor.name} | init -> ${defaultState}`, debugColor);\n  }\n  transition(event, data) {\n    const shouldTransitionSelf = this.transitionChild(event, data);\n    if (!shouldTransitionSelf || this.state === _StateMachine.child || this.state === _StateMachine.parent) {\n      return;\n    }\n    const currentState = this.state;\n    const currentStateConfig = this.states[this.state];\n    let destination = currentStateConfig[event];\n    const debugPrefix = `%c${this.constructor.name} | ${this.state} -> ${event} ->`;\n    if (Array.isArray(destination)) {\n      destination = destination.find((transition) => {\n        if (!transition.guard)\n          return true;\n        const valid = transition.guard(data);\n        if (!valid) {\n          this.debug(`${debugPrefix} ${transition.target} (guarded)`, debugQuietColor);\n        }\n        return valid;\n      });\n    } else if (typeof destination === \"object\" && !(destination instanceof _StateMachine) && destination.guard && !destination.guard(data)) {\n      this.debug(`${debugPrefix} ${destination.target} (guarded)`, debugQuietColor);\n      return;\n    }\n    if (!destination) {\n      this.debug(`${debugPrefix} ${this.state}`, debugQuietColor);\n      return;\n    }\n    const destinationState = this.getDestinationState(destination);\n    const exitFn = destinationState === this.state ? void 0 : currentStateConfig.onExit;\n    this.debug(`${debugPrefix} ${destinationState}`, debugColor);\n    this.state = destinationState;\n    if (typeof destination === \"function\") {\n      destination(data);\n    } else if (typeof destination === \"object\" && !(destination instanceof _StateMachine)) {\n      destination.action?.(data);\n    }\n    exitFn?.();\n    this.enterEach?.(currentState, destinationState);\n    if (destinationState !== currentState && destinationState !== _StateMachine.child && destinationState !== _StateMachine.parent) {\n      this.states[destinationState].onEnter?.(currentState, data);\n    }\n  }\n  is(value) {\n    if (this.state === _StateMachine.child && this.childState) {\n      return this.childState.is(value);\n    }\n    return this.state === value;\n  }\n  resetHierarchy() {\n    this.debug(\n      `%c${this.constructor.name} | ${this.state} -> [resetHierarchy] -> ${this.defaultState}`,\n      \"color: green\"\n    );\n    this.state = this.defaultState;\n  }\n  transitionChild(event, data) {\n    if (this.state !== _StateMachine.child || !this.childState)\n      return true;\n    this.childState.transition(event, data);\n    if (!this.childState.is(_StateMachine.parent))\n      return true;\n    this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${this.defaultState}`, debugColor);\n    this.state = this.defaultState;\n    this.states[this.state].onEnter?.();\n    this.childState.resetHierarchy();\n    return false;\n  }\n  getDestinationState(destination) {\n    let state = this.state;\n    if (typeof destination === \"string\") {\n      state = destination;\n    } else if (destination instanceof _StateMachine) {\n      this.childState = destination;\n      state = _StateMachine.child;\n    } else if (typeof destination === \"object\") {\n      if (destination.target instanceof _StateMachine) {\n        this.childState = destination.target;\n        state = _StateMachine.child;\n      } else {\n        state = destination.target;\n      }\n    }\n    return state;\n  }\n};\n_StateMachine.child = \"__child\";\n_StateMachine.parent = \"__parent\";\nvar StateMachine = _StateMachine;\n\n// packages/ag-charts-community/src/util/textWrapper.ts\nvar TextWrapper = class {\n  static wrapText(text, options) {\n    return this.wrapLines(text, options).join(\"\\n\");\n  }\n  static wrapLines(text, options) {\n    const clippedResult = this.textWrap(text, options);\n    if (options.overflow === \"hide\" && clippedResult.some((l) => l.endsWith(TextUtils.EllipsisChar))) {\n      return [];\n    }\n    return clippedResult;\n  }\n  static appendEllipsis(text) {\n    return text.replace(/[.,]{1,5}$/, \"\") + TextUtils.EllipsisChar;\n  }\n  static truncateLine(text, measurer, maxWidth, ellipsisForce) {\n    const ellipsisWidth = measurer.textWidth(TextUtils.EllipsisChar);\n    let estimatedWidth = 0;\n    let i = 0;\n    for (; i < text.length; i++) {\n      const charWidth = measurer.textWidth(text.charAt(i));\n      if (estimatedWidth + charWidth > maxWidth)\n        break;\n      estimatedWidth += charWidth;\n    }\n    if (text.length === i && (!ellipsisForce || estimatedWidth + ellipsisWidth <= maxWidth)) {\n      return ellipsisForce ? text + TextUtils.EllipsisChar : text;\n    }\n    text = text.slice(0, i).trimEnd();\n    while (text.length && measurer.textWidth(text) + ellipsisWidth > maxWidth) {\n      text = text.slice(0, -1).trimEnd();\n    }\n    return text + TextUtils.EllipsisChar;\n  }\n  static textWrap(text, options) {\n    const lines = text.split(TextUtils.lineSplitter);\n    const measurer = CachedTextMeasurerPool.getMeasurer(options);\n    if (options.textWrap === \"never\") {\n      return lines.map((line) => this.truncateLine(line.trimEnd(), measurer, options.maxWidth));\n    }\n    const result = [];\n    const wrapHyphenate = options.textWrap === \"hyphenate\";\n    const wrapOnSpace = options.textWrap == null || options.textWrap === \"on-space\";\n    for (let line of lines) {\n      line = line.trimEnd();\n      if (line === \"\") {\n        result.push(line);\n        continue;\n      }\n      for (let i = 0, estimatedWidth = 0, lastSpaceIndex = 0; i < line.length; i++) {\n        const char = line.charAt(i);\n        estimatedWidth += measurer.textWidth(char);\n        if (char === \" \") {\n          lastSpaceIndex = i;\n        }\n        if (estimatedWidth > options.maxWidth) {\n          if (i === 0)\n            break;\n          const actualWidth = measurer.textWidth(line.slice(0, i + 1));\n          if (actualWidth <= options.maxWidth) {\n            estimatedWidth = actualWidth;\n            continue;\n          }\n          if (lastSpaceIndex) {\n            const nextWord = this.getWordAt(line, lastSpaceIndex + 1);\n            const textWidth = measurer.textWidth(nextWord);\n            if (textWidth <= options.maxWidth) {\n              result.push(line.slice(0, lastSpaceIndex).trimEnd());\n              line = line.slice(lastSpaceIndex).trimStart();\n              i = -1;\n              estimatedWidth = 0;\n              lastSpaceIndex = 0;\n              continue;\n            } else if (wrapOnSpace && textWidth > options.maxWidth) {\n              result.push(\n                line.slice(0, lastSpaceIndex).trimEnd(),\n                this.truncateLine(\n                  line.slice(lastSpaceIndex).trimStart(),\n                  measurer,\n                  options.maxWidth,\n                  true\n                )\n              );\n            }\n          } else if (wrapOnSpace) {\n            result.push(this.truncateLine(line, measurer, options.maxWidth, true));\n          }\n          if (wrapOnSpace) {\n            line = \"\";\n            break;\n          }\n          const postfix = wrapHyphenate ? \"-\" : \"\";\n          let newLine = line.slice(0, i).trim();\n          while (newLine.length && measurer.textWidth(newLine + postfix) > options.maxWidth) {\n            newLine = newLine.slice(0, -1).trimEnd();\n          }\n          result.push(newLine + postfix);\n          if (!newLine.length) {\n            line = \"\";\n            break;\n          }\n          line = line.slice(newLine.length).trimStart();\n          i = -1;\n          estimatedWidth = 0;\n          lastSpaceIndex = 0;\n        }\n      }\n      if (line) {\n        result.push(line);\n      }\n    }\n    this.avoidOrphans(result, measurer, options);\n    return this.clipLines(result, measurer, options);\n  }\n  static getWordAt(text, position) {\n    const nextSpaceIndex = text.indexOf(\" \", position);\n    return nextSpaceIndex === -1 ? text.slice(position) : text.slice(position, nextSpaceIndex);\n  }\n  static clipLines(lines, measurer, options) {\n    if (!options.maxHeight) {\n      return lines;\n    }\n    const { height, lineMetrics } = measurer.measureLines(lines);\n    if (height <= options.maxHeight) {\n      return lines;\n    }\n    for (let i = 0, cumulativeHeight = 0; i < lineMetrics.length; i++) {\n      const { lineHeight } = lineMetrics[i];\n      cumulativeHeight += lineHeight;\n      if (cumulativeHeight > options.maxHeight) {\n        if (options.overflow === \"hide\") {\n          return [];\n        }\n        const clippedResults = lines.slice(0, i || 1);\n        const lastLine = clippedResults.pop();\n        return clippedResults.concat(this.truncateLine(lastLine, measurer, options.maxWidth, true));\n      }\n    }\n    return lines;\n  }\n  static avoidOrphans(lines, measurer, options) {\n    if (options.avoidOrphans === false || lines.length < 2)\n      return;\n    const { length: length2 } = lines;\n    const lastLine = lines[length2 - 1];\n    const beforeLast = lines[length2 - 2];\n    if (beforeLast.length < lastLine.length)\n      return;\n    const lastSpaceIndex = beforeLast.lastIndexOf(\" \");\n    if (lastSpaceIndex === -1 || lastSpaceIndex === beforeLast.indexOf(\" \") || lastLine.includes(\" \"))\n      return;\n    const lastWord = beforeLast.slice(lastSpaceIndex + 1);\n    if (measurer.textWidth(lastLine + lastWord) <= options.maxWidth) {\n      lines[length2 - 2] = beforeLast.slice(0, lastSpaceIndex);\n      lines[length2 - 1] = lastWord + \" \" + lastLine;\n    }\n  }\n};\n\n// packages/ag-charts-community/src/util/attributeUtil.ts\nfunction setAttribute(e, qualifiedName, value) {\n  if (value === void 0 || value === \"\") {\n    e?.removeAttribute(qualifiedName);\n  } else {\n    e?.setAttribute(qualifiedName, value.toString());\n  }\n}\nfunction setVisibility(element2, hiddenToken, hidden) {\n  element2.ariaHidden = `${hidden}`;\n  element2.classList.toggle(hiddenToken, hidden);\n}\n\n// packages/ag-charts-community/src/util/placement.ts\nfunction calculatePlacement(naturalWidth, naturalHeight, container, bounds) {\n  let { top, right, bottom, left, width, height } = bounds;\n  if (left != null) {\n    if (width != null) {\n      right = container.width - left + width;\n    } else if (right != null) {\n      width = container.width - left - right;\n    }\n  } else if (right != null && width != null) {\n    left = container.width - right - width;\n  }\n  if (top != null) {\n    if (height != null) {\n      bottom = container.height - top - height;\n    } else if (bottom != null) {\n      height = container.height - bottom - top;\n    }\n  } else if (bottom != null && height != null) {\n    top = container.height - bottom - height;\n  }\n  if (width == null) {\n    if (height == null) {\n      width = naturalWidth;\n      height = naturalHeight;\n    } else {\n      width = Math.ceil(naturalWidth * height / naturalHeight);\n    }\n  } else if (height == null) {\n    height = Math.ceil(naturalHeight * width / naturalWidth);\n  }\n  if (left == null) {\n    if (right == null) {\n      left = Math.floor((container.width - width) / 2);\n    } else {\n      left = container.width - right - width;\n    }\n  }\n  if (top == null) {\n    if (bottom == null) {\n      top = Math.floor((container.height - height) / 2);\n    } else {\n      top = container.height - height - bottom;\n    }\n  }\n  return { x: left, y: top, width, height };\n}\n\n// packages/ag-charts-community/src/chart/tooltip/tooltip.ts\nvar DEFAULT_TOOLTIP_CLASS = \"ag-chart-tooltip\";\nvar DEFAULT_TOOLTIP_DARK_CLASS = \"ag-chart-dark-tooltip\";\nvar EMPTY_TOOLTIP_CONTENT = { html: \"\", ariaLabel: \"\" };\nfunction toAccessibleText(inputHtml) {\n  const lineConverter = (_match, offset4, str) => {\n    if (offset4 === 0 || str[offset4 - 1] !== \".\") {\n      return \". \";\n    }\n    return \" \";\n  };\n  return inputHtml.replace(/<br\\s*\\/?>/g, lineConverter).replace(/<\\/p\\s+>/g, lineConverter).replace(/<\\/li\\s*>/g, lineConverter).replace(/<[^<>]+>/g, \"\").replace(/\\n+/g, \" \").replace(/\\s+/g, \" \");\n}\nfunction toTooltipHtml(input, defaults) {\n  if (typeof input === \"string\") {\n    return { html: input, ariaLabel: input };\n  }\n  const {\n    content = defaults?.content ?? \"\",\n    title = defaults?.title,\n    color = defaults?.color ?? \"white\",\n    backgroundColor = defaults?.backgroundColor ?? \"#888\"\n  } = input;\n  const titleHtml = title ? `<div class=\"${DEFAULT_TOOLTIP_CLASS}-title\"\n        style=\"color: ${color}; background-color: ${backgroundColor}\">${title}</div>` : \"\";\n  const titleAria = title ? `${title}: ` : \"\";\n  const contentHtml = content ? `<div class=\"${DEFAULT_TOOLTIP_CLASS}-content\">${content}</div>` : \"\";\n  return {\n    html: `${titleHtml}${contentHtml}`,\n    ariaLabel: toAccessibleText(`${titleAria}${content}`)\n  };\n}\nvar TooltipPosition = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    /** The type of positioning for the tooltip. By default, the tooltip follows the pointer. */\n    this.type = \"pointer\";\n    /** The horizontal offset in pixels for the position of the tooltip. */\n    this.xOffset = 0;\n    /** The vertical offset in pixels for the position of the tooltip. */\n    this.yOffset = 0;\n  }\n};\n__decorateClass([\n  Validate(\n    UNION(\n      [\n        \"pointer\",\n        \"node\",\n        \"top\",\n        \"right\",\n        \"bottom\",\n        \"left\",\n        \"top-left\",\n        \"top-right\",\n        \"bottom-right\",\n        \"bottom-left\"\n      ],\n      \"a position type\"\n    )\n  )\n], TooltipPosition.prototype, \"type\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], TooltipPosition.prototype, \"xOffset\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], TooltipPosition.prototype, \"yOffset\", 2);\nvar Tooltip = class extends BaseProperties {\n  constructor() {\n    super();\n    this.enabled = true;\n    this.delay = 0;\n    this.range = void 0;\n    this.wrapping = \"hyphenate\";\n    this.position = new TooltipPosition();\n    this.darkTheme = false;\n    this.bounds = \"extended\";\n    this.enableInteraction = false;\n    this.lastVisibilityChange = Date.now();\n    this.wrapTypes = [\"always\", \"hyphenate\", \"on-space\", \"never\"];\n    this.showTimeout = 0;\n    this._showArrow = true;\n  }\n  get interactive() {\n    return this.enableInteraction;\n  }\n  setup(domManager) {\n    this.element = domManager.addChild(\"canvas-overlay\", DEFAULT_TOOLTIP_CLASS);\n    this.element.classList.add(DEFAULT_TOOLTIP_CLASS);\n    setAttribute(this.element, \"aria-hidden\", true);\n  }\n  destroy(domManager) {\n    domManager.removeChild(\"canvas-overlay\", DEFAULT_TOOLTIP_CLASS);\n  }\n  isVisible() {\n    return !this.element?.classList.contains(DEFAULT_TOOLTIP_CLASS + \"-hidden\");\n  }\n  /**\n   * Shows tooltip at the given event's coordinates.\n   * If the `html` parameter is missing, moves the existing tooltip to the new position.\n   */\n  show(boundingRect, canvasRect, meta, content, instantly = false) {\n    const { element: element2 } = this;\n    if (content != null && element2 != null) {\n      element2.innerHTML = content.html;\n    } else if (!element2?.innerHTML) {\n      this.toggle(false);\n      return;\n    }\n    const positionType = meta.position?.type ?? this.position.type;\n    const xOffset = meta.position?.xOffset ?? 0;\n    const yOffset = meta.position?.yOffset ?? 0;\n    const tooltipBounds = this.getTooltipBounds({ positionType, meta, yOffset, xOffset, canvasRect });\n    const relativeRect = {\n      x: boundingRect.x - canvasRect.x,\n      y: boundingRect.y - canvasRect.y,\n      width: boundingRect.width,\n      height: boundingRect.height\n    };\n    const position = calculatePlacement(element2.clientWidth, element2.clientHeight, relativeRect, tooltipBounds);\n    const minX = relativeRect.x;\n    const minY = relativeRect.y;\n    const maxX = relativeRect.width - element2.clientWidth - 1 + minX;\n    const maxY = relativeRect.height - element2.clientHeight + minY;\n    const left = clamp(minX, position.x, maxX);\n    const top = clamp(minY, position.y, maxY);\n    const constrained = left !== position.x || top !== position.y;\n    const defaultShowArrow = (positionType === \"node\" || positionType === \"pointer\") && !constrained && !xOffset && !yOffset;\n    const showArrow = meta.showArrow ?? this.showArrow ?? defaultShowArrow;\n    this.updateShowArrow(showArrow);\n    element2.style.transform = `translate(${Math.round(left)}px, ${Math.round(top)}px)`;\n    element2.style.pointerEvents = meta.enableInteraction ? \"auto\" : \"none\";\n    element2.setAttribute(\"data-pointer-capture\", \"retain\");\n    this.enableInteraction = meta.enableInteraction ?? false;\n    if (this.delay > 0 && !instantly) {\n      this.toggle(false);\n      this.showTimeout = setTimeout(() => {\n        this.toggle(true);\n      }, this.delay);\n    } else {\n      this.toggle(true);\n    }\n  }\n  toggle(visible) {\n    if (!this.element)\n      return;\n    const { classList } = this.element;\n    const toggleClass = (name, include) => classList.toggle(`${DEFAULT_TOOLTIP_CLASS}-${name}`, include);\n    const wasVisible = this.isVisible();\n    let timeSinceLastVisibilityChangeMs = Infinity;\n    if (!visible) {\n      clearTimeout(this.showTimeout);\n    }\n    if (wasVisible !== visible) {\n      const now = Date.now();\n      timeSinceLastVisibilityChangeMs = now - this.lastVisibilityChange;\n      this.lastVisibilityChange = now;\n    }\n    const animatedMoveThresholdMs = 100;\n    const thrashingThresholdMs = 5;\n    const noAnimation = !wasVisible && visible && timeSinceLastVisibilityChangeMs > animatedMoveThresholdMs;\n    if (timeSinceLastVisibilityChangeMs > thrashingThresholdMs) {\n      toggleClass(\"no-animation\", noAnimation);\n    }\n    toggleClass(\"no-interaction\", !this.enableInteraction);\n    toggleClass(\"hidden\", !visible);\n    toggleClass(\"arrow\", this._showArrow);\n    classList.toggle(DEFAULT_TOOLTIP_DARK_CLASS, this.darkTheme);\n    for (const wrapType of this.wrapTypes) {\n      classList.toggle(`${DEFAULT_TOOLTIP_CLASS}-wrap-${wrapType}`, wrapType === this.wrapping);\n    }\n  }\n  updateShowArrow(show) {\n    this._showArrow = show;\n  }\n  getTooltipBounds(opts) {\n    if (!this.element)\n      return {};\n    const { positionType, meta, yOffset, xOffset, canvasRect } = opts;\n    const { clientWidth: tooltipWidth, clientHeight: tooltipHeight } = this.element;\n    const bounds = { width: tooltipWidth, height: tooltipHeight };\n    switch (positionType) {\n      case \"node\":\n      case \"pointer\": {\n        bounds.top = meta.offsetY + yOffset - tooltipHeight - 8;\n        bounds.left = meta.offsetX + xOffset - tooltipWidth / 2;\n        return bounds;\n      }\n      case \"top\": {\n        bounds.top = yOffset;\n        bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;\n        return bounds;\n      }\n      case \"right\": {\n        bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;\n        bounds.left = canvasRect.width - tooltipWidth / 2 + xOffset;\n        return bounds;\n      }\n      case \"left\": {\n        bounds.top = canvasRect.height / 2 - tooltipHeight / 2 + yOffset;\n        bounds.left = xOffset;\n        return bounds;\n      }\n      case \"bottom\": {\n        bounds.top = canvasRect.height - tooltipHeight + yOffset;\n        bounds.left = canvasRect.width / 2 - tooltipWidth / 2 + xOffset;\n        return bounds;\n      }\n      case \"top-left\": {\n        bounds.top = yOffset;\n        bounds.left = xOffset;\n        return bounds;\n      }\n      case \"top-right\": {\n        bounds.top = yOffset;\n        bounds.left = canvasRect.width - tooltipWidth + xOffset;\n        return bounds;\n      }\n      case \"bottom-right\": {\n        bounds.top = canvasRect.height - tooltipHeight + yOffset;\n        bounds.left = canvasRect.width - tooltipWidth + xOffset;\n        return bounds;\n      }\n      case \"bottom-left\": {\n        bounds.top = canvasRect.height - tooltipHeight + yOffset;\n        bounds.left = xOffset;\n        return bounds;\n      }\n    }\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], Tooltip.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], Tooltip.prototype, \"showArrow\", 2);\n__decorateClass([\n  ObserveChanges((target, newValue, oldValue) => {\n    if (newValue) {\n      target.element?.classList.add(newValue);\n    }\n    if (oldValue) {\n      target.element?.classList.remove(oldValue);\n    }\n  }),\n  Validate(STRING, { optional: true })\n], Tooltip.prototype, \"class\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Tooltip.prototype, \"delay\", 2);\n__decorateClass([\n  Validate(INTERACTION_RANGE, { optional: true })\n], Tooltip.prototype, \"range\", 2);\n__decorateClass([\n  Validate(TEXT_WRAP)\n], Tooltip.prototype, \"wrapping\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Tooltip.prototype, \"position\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], Tooltip.prototype, \"darkTheme\", 2);\n__decorateClass([\n  Validate(UNION([\"extended\", \"canvas\"]))\n], Tooltip.prototype, \"bounds\", 2);\n\n// packages/ag-charts-community/src/chart/caption.ts\nvar Caption = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.id = createId(this);\n    this.node = new Text({ zIndex: 1 }).setProperties({\n      textAlign: \"center\",\n      pointerEvents: 1 /* None */\n    });\n    this.enabled = false;\n    this.textAlign = \"center\";\n    this.fontSize = 10;\n    this.fontFamily = \"sans-serif\";\n    this.wrapping = \"always\";\n    this.truncated = false;\n    this.layoutStyle = \"block\";\n  }\n  registerInteraction(moduleCtx) {\n    const { regionManager, proxyInteractionService, layoutService } = moduleCtx;\n    const region = regionManager.getRegion(\"root\");\n    const destroyFns = [\n      layoutService.addListener(\"layout-complete\", () => this.updateA11yText(proxyInteractionService)),\n      region.addListener(\"hover\", (event) => this.handleMouseMove(moduleCtx, event)),\n      region.addListener(\"leave\", (event) => this.handleMouseLeave(moduleCtx, event))\n    ];\n    return joinFunctions(...destroyFns);\n  }\n  computeTextWrap(containerWidth, containerHeight) {\n    const { text, wrapping } = this;\n    const maxWidth = Math.min(this.maxWidth ?? Infinity, containerWidth);\n    const maxHeight = this.maxHeight ?? containerHeight;\n    if (!isFinite(maxWidth) && !isFinite(maxHeight)) {\n      this.node.text = text;\n      return;\n    }\n    const wrappedText = TextWrapper.wrapText(text ?? \"\", { maxWidth, maxHeight, font: this, textWrap: wrapping });\n    this.node.text = wrappedText;\n    this.truncated = wrappedText.includes(TextUtils.EllipsisChar);\n  }\n  updateA11yText(proxyService) {\n    if (this.enabled && this.text) {\n      const bbox = this.node.computeTransformedBBox();\n      if (bbox) {\n        const { id } = this;\n        this.proxyText ?? (this.proxyText = proxyService.createProxyElement({ type: \"text\", id, parent: \"canvas-proxy\" }));\n        this.proxyText.textContent = this.text;\n        this.proxyText.updateBounds(bbox);\n      }\n    } else {\n      this.proxyText?.remove();\n      this.proxyText = void 0;\n    }\n  }\n  handleMouseMove(moduleCtx, event) {\n    if (event !== void 0 && this.enabled && this.node.visible && this.truncated) {\n      const { offsetX, offsetY } = event;\n      moduleCtx.tooltipManager.updateTooltip(\n        this.id,\n        { offsetX, offsetY, lastPointerEvent: event, showArrow: false },\n        toTooltipHtml({ content: this.text })\n      );\n    }\n  }\n  handleMouseLeave(moduleCtx, _event) {\n    moduleCtx.tooltipManager.removeTooltip(this.id);\n  }\n};\nCaption.SMALL_PADDING = 10;\nCaption.LARGE_PADDING = 20;\n__decorateClass([\n  Validate(BOOLEAN)\n], Caption.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"text\", 2);\n__decorateClass([\n  Validate(TEXT_ALIGN, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"textAlign\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true }),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING),\n  ProxyPropertyOnWrite(\"node\")\n], Caption.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"node\", \"fill\")\n], Caption.prototype, \"color\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"spacing\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"lineHeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"maxWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Caption.prototype, \"maxHeight\", 2);\n__decorateClass([\n  Validate(TEXT_WRAP)\n], Caption.prototype, \"wrapping\", 2);\n__decorateClass([\n  Validate(STRING)\n], Caption.prototype, \"layoutStyle\", 2);\n\n// packages/ag-charts-community/src/scene/shape/range.ts\nvar Range = class extends Shape {\n  constructor(opts = {}) {\n    super(opts);\n    this.x1 = 0;\n    this.y1 = 0;\n    this.x2 = 0;\n    this.y2 = 0;\n    this.startLine = false;\n    this.endLine = false;\n    this.isRange = false;\n    this.restoreOwnStyles();\n  }\n  computeBBox() {\n    return new BBox(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);\n  }\n  isPointInPath(_x, _y) {\n    return false;\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    this.transformRenderContext(renderCtx);\n    let { x1, y1, x2, y2 } = this;\n    x1 = this.align(x1);\n    y1 = this.align(y1);\n    x2 = this.align(x2);\n    y2 = this.align(y2);\n    const { fill, opacity, isRange } = this;\n    const fillActive = !!(isRange && fill);\n    if (fillActive) {\n      const { fillOpacity } = this;\n      ctx.fillStyle = fill;\n      ctx.globalAlpha = opacity * fillOpacity;\n      ctx.beginPath();\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y1);\n      ctx.lineTo(x2, y2);\n      ctx.lineTo(x1, y2);\n      ctx.closePath();\n      ctx.fill();\n    }\n    const { stroke, strokeWidth, startLine, endLine } = this;\n    const strokeActive = !!((startLine || endLine) && stroke && strokeWidth);\n    if (strokeActive) {\n      const { strokeOpacity, lineDash, lineDashOffset, lineCap, lineJoin } = this;\n      ctx.strokeStyle = stroke;\n      ctx.globalAlpha = opacity * strokeOpacity;\n      ctx.lineWidth = strokeWidth;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      ctx.beginPath();\n      if (startLine) {\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y1);\n      }\n      if (endLine) {\n        ctx.moveTo(x2, y2);\n        ctx.lineTo(x1, y2);\n      }\n      ctx.stroke();\n    }\n    this.fillShadow?.markClean();\n    super.render(renderCtx);\n  }\n};\nRange.className = \"Range\";\nRange.defaultStyles = {\n  ...Shape.defaultStyles,\n  strokeWidth: 1\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"x1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"y1\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"x2\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"y2\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"startLine\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"endLine\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 2 /* MINOR */ })\n], Range.prototype, \"isRange\", 2);\n\n// packages/ag-charts-community/src/chart/label.ts\nvar Label = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n  }\n  getFont() {\n    return TextUtils.toFontString(this);\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], Label.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], Label.prototype, \"color\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], Label.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], Label.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Label.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], Label.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], Label.prototype, \"formatter\", 2);\nfunction calculateLabelRotation(opts) {\n  const { parallelFlipRotation = 0, regularFlipRotation = 0 } = opts;\n  const configuredRotation = opts.rotation ? normalizeAngle360(toRadians(opts.rotation)) : 0;\n  const parallelFlipFlag = !configuredRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n  const regularFlipFlag = !configuredRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n  let defaultRotation = 0;\n  if (opts.parallel) {\n    defaultRotation = parallelFlipFlag * Math.PI / 2;\n  } else if (regularFlipFlag === -1) {\n    defaultRotation = Math.PI;\n  }\n  return { configuredRotation, defaultRotation, parallelFlipFlag, regularFlipFlag };\n}\nfunction getLabelSpacing(minSpacing, rotated) {\n  if (!isNaN(minSpacing)) {\n    return minSpacing;\n  }\n  return rotated ? 0 : 10;\n}\nfunction getTextBaseline(parallel, labelRotation, sideFlag, parallelFlipFlag) {\n  if (parallel && !labelRotation) {\n    return sideFlag * parallelFlipFlag === -1 ? \"hanging\" : \"bottom\";\n  }\n  return \"middle\";\n}\nfunction getTextAlign(parallel, labelRotation, labelAutoRotation, sideFlag, regularFlipFlag) {\n  const labelRotated = labelRotation > 0 && labelRotation <= Math.PI;\n  const labelAutoRotated = labelAutoRotation > 0 && labelAutoRotation <= Math.PI;\n  const alignFlag = labelRotated || labelAutoRotated ? -1 : 1;\n  if (parallel) {\n    if (labelRotation || labelAutoRotation) {\n      if (sideFlag * alignFlag === -1) {\n        return \"end\";\n      }\n    } else {\n      return \"center\";\n    }\n  } else if (sideFlag * regularFlipFlag === -1) {\n    return \"end\";\n  }\n  return \"start\";\n}\nfunction calculateLabelBBox(text, bbox, labelMatrix) {\n  const { x: labelX, y: labelY, width, height } = bbox;\n  const translatedBBox = new BBox(labelX, labelY, 0, 0);\n  labelMatrix.transformBBox(translatedBBox, bbox);\n  const { x, y } = bbox;\n  return {\n    point: { x, y },\n    label: { text, width, height }\n  };\n}\n\n// packages/ag-charts-community/src/chart/layers.ts\nvar Layers = /* @__PURE__ */ ((Layers2) => {\n  Layers2[Layers2[\"SERIES_BACKGROUND_ZINDEX\"] = 0] = \"SERIES_BACKGROUND_ZINDEX\";\n  Layers2[Layers2[\"AXIS_GRID_ZINDEX\"] = 1] = \"AXIS_GRID_ZINDEX\";\n  Layers2[Layers2[\"AXIS_ZINDEX\"] = 2] = \"AXIS_ZINDEX\";\n  Layers2[Layers2[\"SERIES_CROSSLINE_RANGE_ZINDEX\"] = 3] = \"SERIES_CROSSLINE_RANGE_ZINDEX\";\n  Layers2[Layers2[\"SERIES_LAYER_ZINDEX\"] = 4] = \"SERIES_LAYER_ZINDEX\";\n  Layers2[Layers2[\"SERIES_HIGHLIGHT_ZINDEX\"] = 5] = \"SERIES_HIGHLIGHT_ZINDEX\";\n  Layers2[Layers2[\"AXIS_FOREGROUND_ZINDEX\"] = 6] = \"AXIS_FOREGROUND_ZINDEX\";\n  Layers2[Layers2[\"SERIES_CROSSHAIR_ZINDEX\"] = 7] = \"SERIES_CROSSHAIR_ZINDEX\";\n  Layers2[Layers2[\"SERIES_LABEL_ZINDEX\"] = 8] = \"SERIES_LABEL_ZINDEX\";\n  Layers2[Layers2[\"SERIES_CROSSLINE_LINE_ZINDEX\"] = 9] = \"SERIES_CROSSLINE_LINE_ZINDEX\";\n  Layers2[Layers2[\"SERIES_ANNOTATION_ZINDEX\"] = 10] = \"SERIES_ANNOTATION_ZINDEX\";\n  Layers2[Layers2[\"CHART_ANNOTATION_ZINDEX\"] = 11] = \"CHART_ANNOTATION_ZINDEX\";\n  Layers2[Layers2[\"CHART_ANNOTATION_FOCUSED_ZINDEX\"] = 12] = \"CHART_ANNOTATION_FOCUSED_ZINDEX\";\n  Layers2[Layers2[\"LEGEND_ZINDEX\"] = 13] = \"LEGEND_ZINDEX\";\n  Layers2[Layers2[\"NAVIGATOR_ZINDEX\"] = 14] = \"NAVIGATOR_ZINDEX\";\n  Layers2[Layers2[\"FOREGROUND_ZINDEX\"] = 15] = \"FOREGROUND_ZINDEX\";\n  return Layers2;\n})(Layers || {});\n\n// packages/ag-charts-community/src/util/value.ts\nfunction isStringObject(value) {\n  return value != null && Object.hasOwn(value, \"toString\") && isString(value.toString());\n}\nfunction isNumberObject(value) {\n  return value != null && Object.hasOwn(value, \"valueOf\") && isFiniteNumber(value.valueOf());\n}\nfunction isContinuous(value) {\n  return isFiniteNumber(value) || isValidDate(value) || isNumberObject(value);\n}\nfunction checkDatum(value, isContinuousScale) {\n  return value != null && (!isContinuousScale || isContinuous(value));\n}\nfunction transformIntegratedCategoryValue(value) {\n  if (isStringObject(value) && Object.hasOwn(value, \"id\")) {\n    return value.id;\n  }\n  return value;\n}\n\n// packages/ag-charts-community/src/chart/crossline/crossLine.ts\nvar MATCHING_CROSSLINE_TYPE = (property) => {\n  return property === \"value\" ? predicateWithMessage(\n    (_, ctx) => ctx.target[\"type\"] === \"line\",\n    (ctx) => ctx.target[\"type\"] === \"range\" ? `crossLine type 'range' to have a 'range' property instead of 'value'` : `crossLine property 'type' to be 'line'`\n  ) : predicateWithMessage(\n    (_, ctx) => ctx.target[\"type\"] === \"range\",\n    (ctx) => ctx.target.type === \"line\" ? `crossLine type 'line' to have a 'value' property instead of 'range'` : `crossLine property 'type' to be 'range'`\n  );\n};\nvar validateCrossLineValues = (type, value, range3, scale2) => {\n  const lineCrossLine = type === \"line\" && value !== void 0;\n  const rangeCrossLine = type === \"range\" && range3 !== void 0;\n  if (!lineCrossLine && !rangeCrossLine) {\n    return true;\n  }\n  const [start, end] = range3 ?? [value, void 0];\n  const isContinuous2 = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n  const validStart = checkDatum(start, isContinuous2) && !isNaN(scale2.convert(start));\n  const validEnd = checkDatum(end, isContinuous2) && !isNaN(scale2.convert(end));\n  if (lineCrossLine && validStart || rangeCrossLine && validStart && validEnd) {\n    return true;\n  }\n  const message = [`Expecting crossLine`];\n  if (rangeCrossLine) {\n    if (!validStart) {\n      message.push(`range start ${stringify(start)}`);\n    }\n    if (!validEnd) {\n      message.push(`${validStart ? \"\" : \"and \"}range end ${stringify(end)}`);\n    }\n  } else {\n    message.push(`value ${stringify(start)}`);\n  }\n  message.push(`to match the axis scale domain.`);\n  Logger.warnOnce(message.join(\" \"));\n  return false;\n};\n\n// packages/ag-charts-community/src/chart/crossline/crossLineLabelPosition.ts\nvar horizontalCrosslineTranslationDirections = {\n  top: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  bottom: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  left: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  right: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  topLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\n  topRight: { xTranslationDirection: -1, yTranslationDirection: -1 },\n  bottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  bottomRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  inside: { xTranslationDirection: 0, yTranslationDirection: 0 },\n  insideLeft: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  insideRight: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  insideTop: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  insideBottom: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  insideTopLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\n  insideTopRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  insideBottomRight: { xTranslationDirection: -1, yTranslationDirection: -1 }\n};\nvar verticalCrossLineTranslationDirections = {\n  top: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  bottom: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  left: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  right: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  topLeft: { xTranslationDirection: -1, yTranslationDirection: -1 },\n  topRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  bottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\n  bottomRight: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  inside: { xTranslationDirection: 0, yTranslationDirection: 0 },\n  insideLeft: { xTranslationDirection: 0, yTranslationDirection: 1 },\n  insideRight: { xTranslationDirection: 0, yTranslationDirection: -1 },\n  insideTop: { xTranslationDirection: -1, yTranslationDirection: 0 },\n  insideBottom: { xTranslationDirection: 1, yTranslationDirection: 0 },\n  insideTopLeft: { xTranslationDirection: -1, yTranslationDirection: 1 },\n  insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\n  insideTopRight: { xTranslationDirection: -1, yTranslationDirection: -1 },\n  insideBottomRight: { xTranslationDirection: 1, yTranslationDirection: -1 }\n};\nfunction calculateLabelTranslation({\n  yDirection,\n  padding = 0,\n  position = \"top\",\n  bbox\n}) {\n  const crossLineTranslationDirections = yDirection ? horizontalCrosslineTranslationDirections : verticalCrossLineTranslationDirections;\n  const { xTranslationDirection, yTranslationDirection } = crossLineTranslationDirections[position];\n  const w = yDirection ? bbox.width : bbox.height;\n  const h = yDirection ? bbox.height : bbox.width;\n  const xTranslation = xTranslationDirection * (padding + w / 2);\n  const yTranslation = yTranslationDirection * (padding + h / 2);\n  return {\n    xTranslation,\n    yTranslation\n  };\n}\nfunction calculateLabelChartPadding({\n  yDirection,\n  bbox,\n  padding = 0,\n  position = \"top\"\n}) {\n  const chartPadding = {};\n  if (position.startsWith(\"inside\"))\n    return chartPadding;\n  if (position === \"top\" && !yDirection) {\n    chartPadding.top = padding + bbox.height;\n  } else if (position === \"bottom\" && !yDirection) {\n    chartPadding.bottom = padding + bbox.height;\n  } else if (position === \"left\" && yDirection) {\n    chartPadding.left = padding + bbox.width;\n  } else if (position === \"right\" && yDirection) {\n    chartPadding.right = padding + bbox.width;\n  }\n  return chartPadding;\n}\nvar POSITION_TOP_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xEnd / 2, y: yStart };\n  } else {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  }\n};\nvar POSITION_LEFT_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  } else {\n    return { x: xEnd / 2, y: yStart };\n  }\n};\nvar POSITION_RIGHT_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  } else {\n    return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : yEnd };\n  }\n};\nvar POSITION_BOTTOM_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : yEnd };\n  } else {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n  }\n};\nvar POSITION_INSIDE_COORDINATES = ({ xEnd, yStart, yEnd }) => {\n  return { x: xEnd / 2, y: isNaN(yEnd) ? yStart : (yStart + yEnd) / 2 };\n};\nvar POSITION_TOP_LEFT_COORDINATES = ({ yDirection, xStart, xEnd, yStart }) => {\n  if (yDirection) {\n    return { x: xStart / 2, y: yStart };\n  } else {\n    return { x: xEnd, y: yStart };\n  }\n};\nvar POSITION_BOTTOM_LEFT_COORDINATES = ({ yDirection, xStart, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : yEnd };\n  } else {\n    return { x: xStart, y: yStart };\n  }\n};\nvar POSITION_TOP_RIGHT_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xEnd, y: yStart };\n  } else {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : yEnd };\n  }\n};\nvar POSITION_BOTTOM_RIGHT_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {\n  if (yDirection) {\n    return { x: xEnd, y: isNaN(yEnd) ? yStart : yEnd };\n  } else {\n    return { x: xStart, y: isNaN(yEnd) ? yStart : yEnd };\n  }\n};\nvar labelDirectionHandling = {\n  top: { c: POSITION_TOP_COORDINATES },\n  bottom: { c: POSITION_BOTTOM_COORDINATES },\n  left: { c: POSITION_LEFT_COORDINATES },\n  right: { c: POSITION_RIGHT_COORDINATES },\n  topLeft: { c: POSITION_TOP_LEFT_COORDINATES },\n  topRight: { c: POSITION_TOP_RIGHT_COORDINATES },\n  bottomLeft: { c: POSITION_BOTTOM_LEFT_COORDINATES },\n  bottomRight: { c: POSITION_BOTTOM_RIGHT_COORDINATES },\n  inside: { c: POSITION_INSIDE_COORDINATES },\n  insideLeft: { c: POSITION_LEFT_COORDINATES },\n  insideRight: { c: POSITION_RIGHT_COORDINATES },\n  insideTop: { c: POSITION_TOP_COORDINATES },\n  insideBottom: { c: POSITION_BOTTOM_COORDINATES },\n  insideTopLeft: { c: POSITION_TOP_LEFT_COORDINATES },\n  insideBottomLeft: { c: POSITION_BOTTOM_LEFT_COORDINATES },\n  insideTopRight: { c: POSITION_TOP_RIGHT_COORDINATES },\n  insideBottomRight: { c: POSITION_BOTTOM_RIGHT_COORDINATES }\n};\n\n// packages/ag-charts-community/src/chart/crossline/cartesianCrossLine.ts\nvar CROSSLINE_LABEL_POSITION = UNION(\n  [\n    \"top\",\n    \"left\",\n    \"right\",\n    \"bottom\",\n    \"topLeft\",\n    \"topRight\",\n    \"bottomLeft\",\n    \"bottomRight\",\n    \"inside\",\n    \"insideLeft\",\n    \"insideRight\",\n    \"insideTop\",\n    \"insideBottom\",\n    \"insideTopLeft\",\n    \"insideBottomLeft\",\n    \"insideTopRight\",\n    \"insideBottomRight\"\n  ],\n  \"crossLine label position\"\n);\nvar CartesianCrossLineLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.fontSize = 14;\n    this.fontFamily = \"Verdana, sans-serif\";\n    this.padding = 5;\n    this.color = \"rgba(87, 87, 87, 1)\";\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianCrossLineLabel.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], CartesianCrossLineLabel.prototype, \"text\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], CartesianCrossLineLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], CartesianCrossLineLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], CartesianCrossLineLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], CartesianCrossLineLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], CartesianCrossLineLabel.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], CartesianCrossLineLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(CROSSLINE_LABEL_POSITION, { optional: true })\n], CartesianCrossLineLabel.prototype, \"position\", 2);\n__decorateClass([\n  Validate(DEGREE, { optional: true })\n], CartesianCrossLineLabel.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianCrossLineLabel.prototype, \"parallel\", 2);\nvar _CartesianCrossLine = class _CartesianCrossLine extends BaseProperties {\n  constructor() {\n    super();\n    this.id = createId(this);\n    this.label = new CartesianCrossLineLabel();\n    this.scale = void 0;\n    this.clippedRange = [-Infinity, Infinity];\n    this.gridLength = 0;\n    this.sideFlag = -1;\n    this.parallelFlipRotation = 0;\n    this.regularFlipRotation = 0;\n    this.direction = \"x\" /* X */;\n    this.group = new Group({ name: `${this.id}`, layer: true, zIndex: _CartesianCrossLine.LINE_LAYER_ZINDEX });\n    this.labelGroup = new Group({ name: `${this.id}`, layer: true, zIndex: _CartesianCrossLine.LABEL_LAYER_ZINDEX });\n    this.crossLineRange = new Range();\n    this.crossLineLabel = new Text();\n    this.labelPoint = void 0;\n    this.data = [];\n    this.startLine = false;\n    this.endLine = false;\n    this.isRange = false;\n    this.group.append(this.crossLineRange);\n    this.labelGroup.append(this.crossLineLabel);\n    this.crossLineRange.pointerEvents = 1 /* None */;\n  }\n  update(visible) {\n    const { enabled, data, type, value, range: range3, scale: scale2 } = this;\n    if (!type || !scale2 || !enabled || !visible || !validateCrossLineValues(type, value, range3, scale2) || data.length === 0) {\n      this.group.visible = false;\n      this.labelGroup.visible = false;\n      return;\n    }\n    this.group.visible = visible;\n    this.labelGroup.visible = visible;\n    this.group.zIndex = this.getZIndex(this.isRange);\n    this.updateNodes();\n  }\n  calculateLayout(visible, reversedAxis) {\n    if (!visible)\n      return;\n    const {\n      scale: scale2,\n      gridLength,\n      sideFlag,\n      direction,\n      label: { position = \"top\" },\n      clippedRange,\n      strokeWidth = 0\n    } = this;\n    this.data = [];\n    if (!scale2)\n      return;\n    const bandwidth = scale2.bandwidth ?? 0;\n    const step = scale2.step ?? 0;\n    const padding = (reversedAxis ? -1 : 1) * (scale2 instanceof BandScale ? (step - bandwidth) / 2 : 0);\n    const [xStart, xEnd] = [0, sideFlag * gridLength];\n    let [yStart, yEnd] = this.getRange();\n    const ordinalTimeScalePadding = yEnd === void 0 && OrdinalTimeScale.is(scale2) ? bandwidth / 2 + padding : 0;\n    let [clampedYStart, clampedYEnd] = [\n      Number(scale2.convert(yStart, { clampMode: \"clamped\" })) - padding + ordinalTimeScalePadding,\n      scale2.convert(yEnd, { clampMode: \"clamped\" }) + bandwidth + padding\n    ];\n    clampedYStart = clampArray(clampedYStart, clippedRange);\n    clampedYEnd = clampArray(clampedYEnd, clippedRange);\n    [yStart, yEnd] = [Number(scale2.convert(yStart)) + ordinalTimeScalePadding, scale2.convert(yEnd) + bandwidth];\n    const validRange = (yStart === clampedYStart || yEnd === clampedYEnd || clampedYStart !== clampedYEnd) && Math.abs(clampedYEnd - clampedYStart) > 0;\n    if (validRange && clampedYStart > clampedYEnd) {\n      [clampedYStart, clampedYEnd] = [clampedYEnd, clampedYStart];\n      [yStart, yEnd] = [yEnd, yStart];\n    }\n    if (yStart - padding >= clampedYStart)\n      yStart -= padding;\n    if (yEnd + padding <= clampedYEnd)\n      yEnd += padding;\n    this.isRange = validRange;\n    this.startLine = strokeWidth > 0 && yStart >= clampedYStart && yStart <= clampedYStart + padding;\n    this.endLine = strokeWidth > 0 && yEnd >= clampedYEnd - bandwidth - padding && yEnd <= clampedYEnd;\n    if (!validRange && !this.startLine && !this.endLine)\n      return;\n    this.data = [clampedYStart, clampedYEnd];\n    if (this.label.enabled) {\n      const yDirection = direction === \"y\" /* Y */;\n      const { c = POSITION_TOP_COORDINATES } = labelDirectionHandling[position] ?? {};\n      const { x: labelX, y: labelY } = c({\n        yDirection,\n        xStart,\n        xEnd,\n        yStart: clampedYStart,\n        yEnd: clampedYEnd\n      });\n      this.labelPoint = {\n        x: labelX,\n        y: labelY\n      };\n    }\n  }\n  updateNodes() {\n    this.updateRangeNode();\n    if (this.label.enabled) {\n      this.updateLabel();\n      this.positionLabel();\n    }\n  }\n  updateRangeNode() {\n    const {\n      crossLineRange,\n      sideFlag,\n      gridLength,\n      data,\n      startLine,\n      endLine,\n      isRange,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      lineDash\n    } = this;\n    crossLineRange.x1 = 0;\n    crossLineRange.x2 = sideFlag * gridLength;\n    crossLineRange.y1 = data[0];\n    crossLineRange.y2 = data[1];\n    crossLineRange.startLine = startLine;\n    crossLineRange.endLine = endLine;\n    crossLineRange.isRange = isRange;\n    crossLineRange.fill = fill;\n    crossLineRange.fillOpacity = fillOpacity ?? 1;\n    crossLineRange.stroke = stroke;\n    crossLineRange.strokeWidth = strokeWidth ?? 1;\n    crossLineRange.strokeOpacity = this.strokeOpacity ?? 1;\n    crossLineRange.lineDash = lineDash;\n  }\n  updateLabel() {\n    const { crossLineLabel, label } = this;\n    if (!label.text)\n      return;\n    crossLineLabel.fontStyle = label.fontStyle;\n    crossLineLabel.fontWeight = label.fontWeight;\n    crossLineLabel.fontSize = label.fontSize;\n    crossLineLabel.fontFamily = label.fontFamily;\n    crossLineLabel.fill = label.color;\n    crossLineLabel.text = label.text;\n  }\n  positionLabel() {\n    const {\n      crossLineLabel,\n      labelPoint: { x = void 0, y = void 0 } = {},\n      label: { parallel, rotation, position = \"top\", padding = 0 },\n      direction,\n      parallelFlipRotation,\n      regularFlipRotation\n    } = this;\n    if (x === void 0 || y === void 0)\n      return;\n    const { defaultRotation, configuredRotation } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    crossLineLabel.rotation = defaultRotation + configuredRotation;\n    crossLineLabel.textBaseline = \"middle\";\n    crossLineLabel.textAlign = \"center\";\n    const bbox = crossLineLabel.computeTransformedBBox();\n    if (!bbox)\n      return;\n    const yDirection = direction === \"y\" /* Y */;\n    const { xTranslation, yTranslation } = calculateLabelTranslation({\n      yDirection,\n      padding,\n      position,\n      bbox\n    });\n    crossLineLabel.translationX = x + xTranslation;\n    crossLineLabel.translationY = y + yTranslation;\n  }\n  getZIndex(isRange = false) {\n    return isRange ? _CartesianCrossLine.RANGE_LAYER_ZINDEX : _CartesianCrossLine.LINE_LAYER_ZINDEX;\n  }\n  getRange() {\n    const { value, range: range3, scale: scale2 } = this;\n    const isContinuous2 = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const start = range3?.[0] ?? value;\n    let end = range3?.[1];\n    if (!isContinuous2 && end === void 0) {\n      end = start;\n    }\n    if (isContinuous2 && start === end) {\n      end = void 0;\n    }\n    return [start, end];\n  }\n  computeLabelBBox() {\n    const { label } = this;\n    if (!label.enabled)\n      return;\n    const tempText = new Text();\n    tempText.fontFamily = label.fontFamily;\n    tempText.fontSize = label.fontSize;\n    tempText.fontStyle = label.fontStyle;\n    tempText.fontWeight = label.fontWeight;\n    tempText.text = label.text;\n    const {\n      labelPoint: { x = void 0, y = void 0 } = {},\n      label: { parallel, rotation, position = \"top\", padding = 0 },\n      direction,\n      parallelFlipRotation,\n      regularFlipRotation\n    } = this;\n    if (x === void 0 || y === void 0)\n      return;\n    const { configuredRotation } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    tempText.rotation = configuredRotation;\n    tempText.textBaseline = \"middle\";\n    tempText.textAlign = \"center\";\n    const bbox = tempText.computeTransformedBBox();\n    if (!bbox)\n      return;\n    const yDirection = direction === \"y\" /* Y */;\n    const { xTranslation, yTranslation } = calculateLabelTranslation({\n      yDirection,\n      padding,\n      position,\n      bbox\n    });\n    tempText.translationX = x + xTranslation;\n    tempText.translationY = y + yTranslation;\n    return tempText.computeTransformedBBox();\n  }\n  calculatePadding(padding) {\n    const {\n      isRange,\n      startLine,\n      endLine,\n      direction,\n      label: { padding: labelPadding = 0, position = \"top\" }\n    } = this;\n    if (!isRange && !startLine && !endLine)\n      return;\n    const crossLineLabelBBox = this.computeLabelBBox();\n    if (crossLineLabelBBox?.x == null || crossLineLabelBBox?.y == null)\n      return;\n    const chartPadding = calculateLabelChartPadding({\n      yDirection: direction === \"y\" /* Y */,\n      padding: labelPadding,\n      position,\n      bbox: crossLineLabelBBox\n    });\n    padding.left = Math.max(padding.left ?? 0, chartPadding.left ?? 0);\n    padding.right = Math.max(padding.right ?? 0, chartPadding.right ?? 0);\n    padding.top = Math.max(padding.top ?? 0, chartPadding.top ?? 0);\n    padding.bottom = Math.max(padding.bottom ?? 0, chartPadding.bottom ?? 0);\n  }\n};\n_CartesianCrossLine.LINE_LAYER_ZINDEX = 9 /* SERIES_CROSSLINE_LINE_ZINDEX */;\n_CartesianCrossLine.RANGE_LAYER_ZINDEX = 3 /* SERIES_CROSSLINE_RANGE_ZINDEX */;\n_CartesianCrossLine.LABEL_LAYER_ZINDEX = 8 /* SERIES_LABEL_ZINDEX */;\n_CartesianCrossLine.className = \"CrossLine\";\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], _CartesianCrossLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(UNION([\"range\", \"line\"], \"a crossLine type\"), { optional: true })\n], _CartesianCrossLine.prototype, \"type\", 2);\n__decorateClass([\n  Validate(AND(MATCHING_CROSSLINE_TYPE(\"range\"), ARRAY.restrict({ length: 2 })), {\n    optional: true\n  })\n], _CartesianCrossLine.prototype, \"range\", 2);\n__decorateClass([\n  Validate(MATCHING_CROSSLINE_TYPE(\"value\"), { optional: true })\n], _CartesianCrossLine.prototype, \"value\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], _CartesianCrossLine.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], _CartesianCrossLine.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], _CartesianCrossLine.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], _CartesianCrossLine.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], _CartesianCrossLine.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH, { optional: true })\n], _CartesianCrossLine.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _CartesianCrossLine.prototype, \"label\", 2);\nvar CartesianCrossLine = _CartesianCrossLine;\n\n// packages/ag-charts-community/src/chart/interaction/regions.ts\nvar REGIONS = /* @__PURE__ */ ((REGIONS2) => {\n  REGIONS2[\"TITLE\"] = \"title\";\n  REGIONS2[\"SUBTITLE\"] = \"subtitle\";\n  REGIONS2[\"FOOTNOTE\"] = \"footnote\";\n  REGIONS2[\"LEGEND\"] = \"legend\";\n  REGIONS2[\"NAVIGATOR\"] = \"navigator\";\n  REGIONS2[\"PAGINATION\"] = \"pagination\";\n  REGIONS2[\"ROOT\"] = \"root\";\n  REGIONS2[\"SERIES\"] = \"series\";\n  REGIONS2[\"HORIZONTAL_AXES\"] = \"horizontal-axes\";\n  REGIONS2[\"VERTICAL_AXES\"] = \"vertical-axes\";\n  REGIONS2[\"TOOLBAR\"] = \"toolbar\";\n  return REGIONS2;\n})(REGIONS || {});\n\n// packages/ag-charts-community/src/chart/axis/axisGridLine.ts\nvar GRID_STYLE_KEYS = [\"stroke\", \"lineDash\"];\nvar GRID_STYLE = ARRAY_OF(\n  (value) => isObject(value) && Object.keys(value).every((key) => GRID_STYLE_KEYS.includes(key)),\n  \"objects with gridline style properties such as 'stroke' or 'lineDash'\"\n);\nvar AxisGridLine = class {\n  constructor() {\n    this.enabled = true;\n    this.width = 1;\n    this.style = [\n      {\n        stroke: void 0,\n        lineDash: []\n      }\n    ];\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisGridLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisGridLine.prototype, \"width\", 2);\n__decorateClass([\n  Validate(GRID_STYLE)\n], AxisGridLine.prototype, \"style\", 2);\n\n// packages/ag-charts-community/src/util/default.ts\nfunction Default(defaultValue, replaces = [void 0]) {\n  return addTransformToInstanceProperty((_, __, v) => {\n    if (replaces.includes(v)) {\n      return isFunction(defaultValue) ? defaultValue(v) : defaultValue;\n    }\n    return v;\n  });\n}\n\n// packages/ag-charts-community/src/chart/axis/axisInterval.ts\nvar TICK_INTERVAL = predicateWithMessage(\n  (value) => isFiniteNumber(value) && value > 0 || value instanceof TimeInterval,\n  `a non-zero positive Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'`\n);\nvar AxisInterval = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.minSpacing = NaN;\n    this.maxSpacing = NaN;\n  }\n};\n__decorateClass([\n  Validate(TICK_INTERVAL, { optional: true })\n], AxisInterval.prototype, \"step\", 2);\n__decorateClass([\n  Validate(ARRAY, { optional: true })\n], AxisInterval.prototype, \"values\", 2);\n__decorateClass([\n  Validate(MIN_SPACING),\n  Default(NaN)\n], AxisInterval.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(MAX_SPACING),\n  Default(NaN)\n], AxisInterval.prototype, \"maxSpacing\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisLabel.ts\nvar AxisLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n    this.padding = 5;\n    this.minSpacing = NaN;\n    this.color = \"#575757\";\n    this.avoidCollisions = true;\n    this.mirrored = false;\n    this.parallel = false;\n  }\n  /**\n   * The side of the axis line to position the labels on.\n   * -1 = left (default)\n   * 1 = right\n   */\n  getSideFlag() {\n    return this.mirrored ? 1 : -1;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], AxisLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], AxisLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(NUMBER.restrict({ min: 1 }))\n], AxisLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], AxisLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisLabel.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(NUMBER_OR_NAN),\n  Default(NaN)\n], AxisLabel.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(DEGREE, { optional: true })\n], AxisLabel.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"avoidCollisions\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"mirrored\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLabel.prototype, \"parallel\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], AxisLabel.prototype, \"formatter\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AxisLabel.prototype, \"format\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisLine.ts\nvar AxisLine = class {\n  constructor() {\n    this.enabled = true;\n    this.width = 1;\n    this.stroke = void 0;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisLine.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisLine.prototype, \"width\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisLine.prototype, \"stroke\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisTick.ts\nvar AxisTick = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.width = 1;\n    this.size = 6;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisTick.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisTick.prototype, \"width\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisTick.prototype, \"size\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisTick.prototype, \"stroke\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisTitle.ts\nvar AxisTitle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = false;\n    this.spacing = Caption.SMALL_PADDING;\n    this.fontSize = 10;\n    this.fontFamily = \"sans-serif\";\n    this.wrapping = \"always\";\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], AxisTitle.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AxisTitle.prototype, \"text\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], AxisTitle.prototype, \"spacing\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], AxisTitle.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], AxisTitle.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AxisTitle.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], AxisTitle.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], AxisTitle.prototype, \"color\", 2);\n__decorateClass([\n  Validate(TEXT_WRAP)\n], AxisTitle.prototype, \"wrapping\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], AxisTitle.prototype, \"formatter\", 2);\n\n// packages/ag-charts-community/src/chart/axis/axisUtil.ts\nfunction prepareAxisAnimationContext(axis) {\n  const [requestedRangeMin, requestedRangeMax] = findMinMax(axis.range);\n  const min = Math.floor(requestedRangeMin);\n  const max = Math.ceil(requestedRangeMax);\n  return { min, max, visible: min !== max };\n}\nvar fullCircle = Math.PI * 2;\nvar halfCircle = fullCircle / 2;\nfunction normaliseEndRotation(start, end) {\n  const directDistance = Math.abs(end - start);\n  if (directDistance < halfCircle)\n    return end;\n  if (start > end)\n    return end + fullCircle;\n  return end - fullCircle;\n}\nfunction prepareAxisAnimationFunctions(ctx) {\n  const outOfBounds = (y, range3) => {\n    const [min = ctx.min, max = ctx.max] = findMinMax(range3 ?? []);\n    return y < min || y > max;\n  };\n  const tick = {\n    fromFn(node, datum, status) {\n      let y = node.y1 + node.translationY;\n      let opacity = node.opacity;\n      if (status === \"added\" || outOfBounds(node.datum.translationY, node.datum.range)) {\n        y = datum.translationY;\n        opacity = 0;\n      }\n      return { y: 0, translationY: y, opacity, phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] };\n    },\n    toFn(_node, datum, status) {\n      const y = datum.translationY;\n      let opacity = 1;\n      if (status === \"removed\") {\n        opacity = 0;\n      }\n      return {\n        y: 0,\n        translationY: y,\n        opacity,\n        finish: {\n          // Set explicit y after animation so it's pixel aligned\n          y,\n          translationY: 0\n        }\n      };\n    },\n    intermediateFn(node, _datum, _status) {\n      return { visible: !outOfBounds(node.y) };\n    }\n  };\n  const label = {\n    fromFn(node, newDatum, status) {\n      const datum = node.previousDatum ?? newDatum;\n      const x = datum.x;\n      const y = datum.y;\n      const rotationCenterX = datum.rotationCenterX;\n      let translationY = Math.round(node.translationY);\n      let rotation = datum.rotation;\n      let opacity = node.opacity;\n      if (status === \"removed\" || outOfBounds(datum.y, datum.range)) {\n        rotation = newDatum.rotation;\n      } else if (status === \"added\" || outOfBounds(node.datum.y, node.datum.range)) {\n        translationY = Math.round(datum.translationY);\n        opacity = 0;\n        rotation = newDatum.rotation;\n      }\n      return {\n        x,\n        y,\n        rotationCenterX,\n        translationY,\n        rotation,\n        opacity,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]\n      };\n    },\n    toFn(node, datum, status) {\n      const x = datum.x;\n      const y = datum.y;\n      const rotationCenterX = datum.rotationCenterX;\n      const translationY = Math.round(datum.translationY);\n      let rotation = 0;\n      let opacity = 1;\n      if (status === \"added\") {\n        opacity = 1;\n        rotation = datum.rotation;\n      } else if (status === \"removed\") {\n        opacity = 0;\n        rotation = datum.rotation;\n      } else {\n        rotation = normaliseEndRotation(node.previousDatum?.rotation ?? datum.rotation, datum.rotation);\n      }\n      return { x, y, rotationCenterX, translationY, rotation, opacity, finish: { rotation: datum.rotation } };\n    }\n  };\n  const line = {\n    fromFn(node, datum) {\n      return {\n        ...node.previousDatum ?? datum,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"updated\"]\n      };\n    },\n    toFn(_node, datum) {\n      return { ...datum };\n    }\n  };\n  const group = {\n    fromFn(node, _datum) {\n      const { rotation, translationX, translationY } = node;\n      return {\n        rotation,\n        translationX,\n        translationY,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"updated\"]\n      };\n    },\n    toFn(_node, datum) {\n      const { rotation, translationX, translationY } = datum;\n      return {\n        rotation,\n        translationX,\n        translationY\n      };\n    }\n  };\n  return { tick, line, label, group };\n}\nfunction resetAxisGroupFn() {\n  return (_node, datum) => {\n    return {\n      rotation: datum.rotation,\n      rotationCenterX: datum.rotationCenterX,\n      rotationCenterY: datum.rotationCenterY,\n      translationX: datum.translationX,\n      translationY: datum.translationY\n    };\n  };\n}\nfunction resetAxisSelectionFn(ctx) {\n  const { visible: rangeVisible, min, max } = ctx;\n  return (_node, datum) => {\n    const y = datum.translationY;\n    const visible = rangeVisible && y >= min && y <= max;\n    return {\n      y,\n      translationY: 0,\n      opacity: 1,\n      visible\n    };\n  };\n}\nfunction resetAxisLabelSelectionFn() {\n  return (_node, datum) => {\n    return {\n      x: datum.x,\n      y: datum.y,\n      translationY: datum.translationY,\n      rotation: datum.rotation,\n      rotationCenterX: datum.rotationCenterX\n    };\n  };\n}\nfunction resetAxisLineSelectionFn() {\n  return (_node, datum) => {\n    return { ...datum };\n  };\n}\n\n// packages/ag-charts-community/src/chart/axis/axis.ts\nvar _Axis = class _Axis {\n  constructor(moduleCtx, scale2) {\n    this.moduleCtx = moduleCtx;\n    this.scale = scale2;\n    this.id = createId(this);\n    this.nice = true;\n    this.reverse = false;\n    this.keys = [];\n    this.interval = new AxisInterval();\n    this.dataDomain = { domain: [], clipped: false };\n    this.layoutConstraints = {\n      stacked: true,\n      align: \"start\",\n      width: 100,\n      unit: \"percent\"\n    };\n    this.boundSeries = [];\n    this.includeInvisibleDomains = false;\n    this.interactionEnabled = true;\n    this.axisGroup = new Group({ name: `${this.id}-axis`, zIndex: 2 /* AXIS_ZINDEX */ });\n    this.lineNode = this.axisGroup.appendChild(new Line({ name: `${this.id}-Axis-line` }));\n    this.tickLineGroup = this.axisGroup.appendChild(\n      new Group({ name: `${this.id}-Axis-tick-lines`, zIndex: 2 /* AXIS_ZINDEX */ })\n    );\n    this.tickLabelGroup = this.axisGroup.appendChild(\n      new Group({ name: `${this.id}-Axis-tick-labels`, zIndex: 2 /* AXIS_ZINDEX */ })\n    );\n    this.crossLineGroup = new Group({ name: `${this.id}-CrossLines` });\n    this.labelGroup = new Group({ name: `${this.id}-Labels`, zIndex: 10 /* SERIES_ANNOTATION_ZINDEX */ });\n    this.gridGroup = new Group({ name: `${this.id}-Axis-grid` });\n    this.gridLineGroup = this.gridGroup.appendChild(\n      new Group({\n        name: `${this.id}-gridLines`,\n        zIndex: 1 /* AXIS_GRID_ZINDEX */\n      })\n    );\n    this.tickLineGroupSelection = Selection.select(this.tickLineGroup, Line, false);\n    this.tickLabelGroupSelection = Selection.select(this.tickLabelGroup, Text, false);\n    this.gridLineGroupSelection = Selection.select(this.gridLineGroup, Line, false);\n    this._crossLines = [];\n    this.line = new AxisLine();\n    this.tick = new AxisTick();\n    this.gridLine = new AxisGridLine();\n    this.label = this.createLabel();\n    this.defaultTickMinSpacing = _Axis.defaultTickMinSpacing;\n    this.translation = { x: 0, y: 0 };\n    this.rotation = 0;\n    // axis rotation angle in degrees\n    this.layout = {\n      label: {\n        fractionDigits: 0,\n        padding: this.label.padding,\n        format: this.label.format\n      }\n    };\n    this.destroyFns = [];\n    this.range = [0, 1];\n    this.visibleRange = [0, 1];\n    this.title = new AxisTitle();\n    this._titleCaption = new Caption();\n    this.gridLength = 0;\n    /**\n     * The distance between the grid ticks and the axis ticks.\n     */\n    this.gridPadding = 0;\n    /**\n     * Is used to avoid collisions between axis labels and series.\n     */\n    this.seriesAreaPadding = 0;\n    this.tickGenerationResult = void 0;\n    this.maxThickness = Infinity;\n    this.moduleMap = new ModuleMap();\n    this.range = this.scale.range.slice();\n    this.crossLines.forEach((crossLine) => this.initCrossLine(crossLine));\n    this.destroyFns.push(this._titleCaption.registerInteraction(this.moduleCtx));\n    this._titleCaption.node.rotation = -Math.PI / 2;\n    this.axisGroup.appendChild(this._titleCaption.node);\n    this.animationManager = moduleCtx.animationManager;\n    this.animationState = new StateMachine(\"empty\", {\n      empty: {\n        update: {\n          target: \"ready\",\n          action: () => this.resetSelectionNodes()\n        },\n        reset: \"empty\"\n      },\n      ready: {\n        update: (data) => this.animateReadyUpdate(data),\n        resize: () => this.resetSelectionNodes(),\n        reset: \"empty\"\n      }\n    });\n    this._crossLines = [];\n    let previousSize = void 0;\n    this.destroyFns.push(\n      moduleCtx.layoutService.addListener(\"layout-complete\", (e) => {\n        if (previousSize != null && jsonDiff(e.chart, previousSize) != null) {\n          this.animationState.transition(\"resize\");\n        }\n        previousSize = { ...e.chart };\n      })\n    );\n  }\n  get type() {\n    return this.constructor.type ?? \"\";\n  }\n  set crossLines(value) {\n    const { CrossLineConstructor } = this.constructor;\n    this._crossLines.forEach((crossLine) => this.detachCrossLine(crossLine));\n    this._crossLines = value.map((crossLine) => {\n      const instance = new CrossLineConstructor();\n      instance.set(crossLine);\n      return instance;\n    });\n    this._crossLines.forEach((crossLine) => {\n      this.attachCrossLine(crossLine);\n      this.initCrossLine(crossLine);\n    });\n  }\n  get crossLines() {\n    return this._crossLines;\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    }\n  }\n  attachCrossLine(crossLine) {\n    this.crossLineGroup.appendChild(crossLine.group);\n    this.crossLineGroup.appendChild(crossLine.labelGroup);\n  }\n  detachCrossLine(crossLine) {\n    this.crossLineGroup.removeChild(crossLine.group);\n    this.crossLineGroup.removeChild(crossLine.labelGroup);\n  }\n  destroy() {\n    this.moduleMap.destroy();\n    this.destroyFns.forEach((f) => f());\n  }\n  updateRange() {\n    const { range: rr, visibleRange: vr, scale: scale2 } = this;\n    const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    const shift = span * vr[0];\n    const start = rr[0] - shift;\n    scale2.setVisibleRange?.(vr);\n    scale2.range = [start, start + span];\n    this.crossLines.forEach((crossLine) => {\n      crossLine.clippedRange = [rr[0], rr[1]];\n    });\n  }\n  setCrossLinesVisible(visible) {\n    this.crossLineGroup.visible = visible;\n  }\n  attachAxis(axisNode, gridNode) {\n    gridNode.appendChild(this.gridGroup);\n    axisNode.appendChild(this.axisGroup);\n    axisNode.appendChild(this.crossLineGroup);\n    axisNode.appendChild(this.labelGroup);\n  }\n  attachLabel(axisLabelNode) {\n    this.labelGroup.append(axisLabelNode);\n  }\n  detachAxis(axisNode, gridNode) {\n    gridNode.removeChild(this.gridGroup);\n    axisNode.removeChild(this.axisGroup);\n    axisNode.removeChild(this.crossLineGroup);\n    axisNode.removeChild(this.labelGroup);\n  }\n  getAxisGroup() {\n    return this.axisGroup;\n  }\n  /**\n   * Checks if a point or an object is in range.\n   * @param x A point (or object's starting point).\n   * @param tolerance Expands the range on both ends by this amount.\n   */\n  inRange(x, tolerance = 0) {\n    const [min, max] = findMinMax(this.range);\n    return x >= min - tolerance && x <= max + tolerance;\n  }\n  onFormatChange(ticks, fractionDigits, _domain, format) {\n    const { scale: scale2 } = this;\n    const logScale = scale2 instanceof LogScale;\n    const defaultFormatter = (formatOffset) => logScale ? String : (x) => typeof x === \"number\" ? x.toFixed(fractionDigits + formatOffset) : String(x);\n    if (format && scale2 && scale2.tickFormat) {\n      try {\n        const formatter = scale2.tickFormat({ ticks, specifier: format });\n        this.labelFormatter = formatter;\n        this.datumFormatter = formatter;\n      } catch (e) {\n        this.labelFormatter = defaultFormatter(0);\n        this.datumFormatter = defaultFormatter(1);\n        Logger.warnOnce(`the axis label format string ${format} is invalid. No formatting will be applied`);\n      }\n    } else {\n      this.labelFormatter = defaultFormatter(0);\n      this.datumFormatter = defaultFormatter(1);\n    }\n  }\n  setTickInterval(interval) {\n    this.scale.interval = this.interval?.step ?? interval;\n  }\n  onGridLengthChange(value, prevValue) {\n    if (prevValue && !value || !prevValue && value) {\n      this.onGridVisibilityChange();\n    }\n    this.crossLines.forEach((crossLine) => this.initCrossLine(crossLine));\n  }\n  onGridVisibilityChange() {\n    this.gridLineGroupSelection.clear();\n  }\n  createLabel() {\n    return new AxisLabel();\n  }\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   */\n  update(_primaryTickCount = 0, animated = true) {\n    if (!this.tickGenerationResult) {\n      return;\n    }\n    const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();\n    const sideFlag = this.label.getSideFlag();\n    this.updatePosition();\n    const lineData = this.getAxisLineCoordinates();\n    const { tickData, combinedRotation, textBaseline, textAlign, primaryTickCount } = this.tickGenerationResult;\n    const previousTicks = this.tickLabelGroupSelection.nodes().map((node) => node.datum.tickId);\n    this.updateSelections(lineData, tickData.ticks, {\n      combinedRotation,\n      textAlign,\n      textBaseline,\n      range: this.scale.range\n    });\n    if (!animated || this.animationManager.isSkipped()) {\n      this.resetSelectionNodes();\n    } else {\n      const diff2 = this.calculateUpdateDiff(previousTicks, tickData);\n      this.animationState.transition(\"update\", diff2);\n    }\n    this.updateAxisLine();\n    this.updateLabels();\n    this.updateVisibility();\n    this.updateGridLines(sideFlag);\n    this.updateTickLines();\n    this.updateTitle({ anyTickVisible: tickData.ticks.length > 0 });\n    this.updateCrossLines({ rotation, parallelFlipRotation, regularFlipRotation });\n    this.updateLayoutState(tickData.fractionDigits);\n    return primaryTickCount;\n  }\n  getAxisLineCoordinates() {\n    const [min, max] = findMinMax(this.range);\n    return { x: 0, y1: min, y2: max };\n  }\n  getTickLineCoordinates(datum) {\n    const sideFlag = this.label.getSideFlag();\n    const x = sideFlag * this.getTickSize();\n    const x1 = Math.min(0, x);\n    const x2 = x1 + Math.abs(x);\n    const y = datum.translationY;\n    return { x1, x2, y };\n  }\n  getTickLabelProps(datum, params) {\n    const { label } = this;\n    const { combinedRotation, textBaseline, textAlign, range: range3 } = params;\n    const text = datum.tickLabel;\n    const sideFlag = label.getSideFlag();\n    const labelX = sideFlag * (this.getTickSize() + label.padding + this.seriesAreaPadding);\n    const visible = text !== \"\" && text != null;\n    return {\n      tickId: datum.tickId,\n      translationY: datum.translationY,\n      fill: label.color,\n      fontFamily: label.fontFamily,\n      fontSize: label.fontSize,\n      fontStyle: label.fontStyle,\n      fontWeight: label.fontWeight,\n      rotation: combinedRotation,\n      rotationCenterX: labelX,\n      text,\n      textAlign,\n      textBaseline,\n      visible,\n      x: labelX,\n      y: 0,\n      range: range3\n    };\n  }\n  getTickSize() {\n    return this.tick.enabled ? this.tick.size : 6;\n  }\n  setTitleProps(caption, params) {\n    const { title } = this;\n    if (!title.enabled) {\n      caption.enabled = false;\n      caption.node.visible = false;\n      return;\n    }\n    caption.color = title.color;\n    caption.fontFamily = title.fontFamily;\n    caption.fontSize = title.fontSize;\n    caption.fontStyle = title.fontStyle;\n    caption.fontWeight = title.fontWeight;\n    caption.enabled = title.enabled;\n    caption.wrapping = title.wrapping;\n    const titleNode = caption.node;\n    const padding = (title.spacing ?? 0) + params.spacing;\n    const sideFlag = this.label.getSideFlag();\n    const parallelFlipRotation = normalizeAngle360(this.rotation);\n    const titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;\n    const rotation = titleRotationFlag * sideFlag * Math.PI / 2;\n    const textBaseline = titleRotationFlag === 1 ? \"bottom\" : \"top\";\n    const { range: range3 } = this;\n    const x = Math.floor(titleRotationFlag * sideFlag * (range3[0] + range3[1]) / 2);\n    const y = sideFlag === -1 ? Math.floor(titleRotationFlag * -padding) : Math.floor(-padding);\n    const { callbackCache } = this.moduleCtx;\n    const { formatter = (p) => p.defaultValue } = title;\n    const text = callbackCache.call(formatter, this.getTitleFormatterParams());\n    titleNode.setProperties({\n      rotation,\n      text,\n      textBaseline,\n      visible: true,\n      x,\n      y\n    });\n  }\n  calculateLayout(primaryTickCount) {\n    const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();\n    const sideFlag = this.label.getSideFlag();\n    const labelX = sideFlag * (this.getTickSize() + this.label.padding + this.seriesAreaPadding);\n    this.updateScale();\n    this.tickGenerationResult = this.generateTicks({\n      primaryTickCount,\n      parallelFlipRotation,\n      regularFlipRotation,\n      labelX,\n      sideFlag\n    });\n    const { tickData, combinedRotation, textBaseline, textAlign, ...ticksResult } = this.tickGenerationResult;\n    this.updateLayoutState(tickData.fractionDigits);\n    const boxes = [];\n    const { x, y1, y2 } = this.getAxisLineCoordinates();\n    const lineBox = new BBox(\n      x + Math.min(sideFlag * this.seriesAreaPadding, 0),\n      y1,\n      this.seriesAreaPadding,\n      y2 - y1\n    );\n    boxes.push(lineBox);\n    if (this.tick.enabled) {\n      tickData.ticks.forEach((datum) => {\n        const { x1, x2, y } = this.getTickLineCoordinates(datum);\n        const tickLineBox = new BBox(x1, y, x2 - x1, 0);\n        boxes.push(tickLineBox);\n      });\n    }\n    if (this.label.enabled) {\n      const tempText = new Text();\n      tickData.ticks.forEach((datum) => {\n        const labelProps = this.getTickLabelProps(datum, {\n          combinedRotation,\n          textAlign,\n          textBaseline,\n          range: this.scale.range\n        });\n        if (!labelProps.visible) {\n          return;\n        }\n        tempText.setProperties({\n          ...labelProps,\n          translationY: Math.round(datum.translationY)\n        });\n        const box = tempText.computeTransformedBBox();\n        if (box) {\n          boxes.push(box);\n        }\n      });\n    }\n    if (this.title?.enabled) {\n      const caption = new Caption();\n      const spacing = BBox.merge(boxes).width;\n      this.setTitleProps(caption, { spacing });\n      const titleNode = caption.node;\n      const titleBox = titleNode.computeTransformedBBox();\n      if (titleBox) {\n        boxes.push(titleBox);\n      }\n    }\n    const bbox = BBox.merge(boxes);\n    const transformedBBox = this.getTransformBox(bbox);\n    const anySeriesActive = this.isAnySeriesActive();\n    this.crossLines.forEach((crossLine) => {\n      var _a;\n      crossLine.sideFlag = -sideFlag;\n      crossLine.direction = rotation === -Math.PI / 2 ? \"x\" /* X */ : \"y\" /* Y */;\n      if (crossLine instanceof CartesianCrossLine) {\n        (_a = crossLine.label).parallel ?? (_a.parallel = this.label.parallel);\n      }\n      crossLine.parallelFlipRotation = parallelFlipRotation;\n      crossLine.regularFlipRotation = regularFlipRotation;\n      crossLine.calculateLayout?.(anySeriesActive, this.reverse);\n    });\n    return {\n      primaryTickCount: ticksResult.primaryTickCount,\n      bbox: transformedBBox\n    };\n  }\n  updateLayoutState(fractionDigits) {\n    this.layout.label = {\n      fractionDigits,\n      padding: this.label.padding,\n      format: this.label.format\n    };\n  }\n  getTransformBox(bbox) {\n    const matrix = new Matrix();\n    const {\n      rotation: axisRotation,\n      translationX,\n      translationY,\n      rotationCenterX,\n      rotationCenterY\n    } = this.getAxisTransform();\n    Matrix.updateTransformMatrix(matrix, 1, 1, axisRotation, translationX, translationY, {\n      scalingCenterX: 0,\n      scalingCenterY: 0,\n      rotationCenterX,\n      rotationCenterY\n    });\n    return matrix.transformBBox(bbox);\n  }\n  setDomain(domain) {\n    this.dataDomain = this.normaliseDataDomain(domain);\n    if (this.reverse) {\n      this.dataDomain.domain.reverse();\n    }\n    this.scale.domain = this.dataDomain.domain;\n  }\n  updateScale() {\n    this.updateRange();\n    this.calculateDomain();\n    this.setTickInterval(this.interval.step);\n    const { scale: scale2, nice } = this;\n    if (!ContinuousScale.is(scale2)) {\n      return;\n    }\n    scale2.nice = nice;\n    scale2.update();\n  }\n  calculateRotations() {\n    const rotation = toRadians(this.rotation);\n    const parallelFlipRotation = normalizeAngle360(rotation);\n    const regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n    return { rotation, parallelFlipRotation, regularFlipRotation };\n  }\n  generateTicks({\n    primaryTickCount,\n    parallelFlipRotation,\n    regularFlipRotation,\n    labelX,\n    sideFlag\n  }) {\n    const {\n      scale: scale2,\n      interval: { minSpacing, maxSpacing },\n      label: { parallel, rotation, fontFamily, fontSize, fontStyle, fontWeight }\n    } = this;\n    const secondaryAxis = primaryTickCount !== void 0;\n    const { defaultRotation, configuredRotation, parallelFlipFlag, regularFlipFlag } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    const initialRotation = configuredRotation + defaultRotation;\n    const labelMatrix = new Matrix();\n    const { maxTickCount } = this.estimateTickCount({ minSpacing, maxSpacing });\n    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;\n    let textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);\n    const textBaseline = getTextBaseline(parallel, configuredRotation, sideFlag, parallelFlipFlag);\n    const font = TextUtils.toFontString({ fontFamily, fontSize, fontStyle, fontWeight });\n    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font });\n    const textProps = {\n      fontFamily,\n      fontSize,\n      fontStyle,\n      fontWeight,\n      textBaseline,\n      textAlign\n    };\n    let tickData = {\n      rawTicks: [],\n      fractionDigits: 0,\n      ticks: [],\n      labelCount: 0\n    };\n    let index = 0;\n    let autoRotation = 0;\n    let labelOverlap = true;\n    let terminate = false;\n    while (labelOverlap && index <= maxIterations) {\n      if (terminate) {\n        break;\n      }\n      autoRotation = 0;\n      textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);\n      const tickStrategies = this.getTickStrategies({ secondaryAxis, index });\n      for (const strategy of tickStrategies) {\n        ({ tickData, index, autoRotation, terminate } = strategy({\n          index,\n          tickData,\n          textProps,\n          labelOverlap,\n          terminate,\n          primaryTickCount\n        }));\n        const rotated = configuredRotation !== 0 || autoRotation !== 0;\n        const labelRotation = initialRotation + autoRotation;\n        textAlign = getTextAlign(parallel, configuredRotation, autoRotation, sideFlag, regularFlipFlag);\n        labelOverlap = this.label.avoidCollisions ? this.checkLabelOverlap(labelRotation, rotated, labelMatrix, tickData.ticks, labelX, textMeasurer) : false;\n      }\n    }\n    const combinedRotation = defaultRotation + configuredRotation + autoRotation;\n    if (!secondaryAxis && tickData.rawTicks.length > 0) {\n      primaryTickCount = tickData.rawTicks.length;\n    }\n    return { tickData, primaryTickCount, combinedRotation, textBaseline, textAlign };\n  }\n  getTickStrategies({\n    index: iteration,\n    secondaryAxis\n  }) {\n    const { scale: scale2, label } = this;\n    const { minSpacing } = this.interval;\n    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const avoidLabelCollisions = label.enabled && label.avoidCollisions;\n    const filterTicks = !continuous && iteration !== 0 && avoidLabelCollisions;\n    const autoRotate = label.autoRotate === true && label.rotation === void 0;\n    const strategies = [];\n    let tickGenerationType;\n    if (this.interval.values) {\n      tickGenerationType = 3 /* VALUES */;\n    } else if (secondaryAxis) {\n      tickGenerationType = 1 /* CREATE_SECONDARY */;\n    } else if (filterTicks) {\n      tickGenerationType = 2 /* FILTER */;\n    } else {\n      tickGenerationType = 0 /* CREATE */;\n    }\n    const tickGenerationStrategy = ({ index, tickData, primaryTickCount, terminate }) => this.createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount);\n    strategies.push(tickGenerationStrategy);\n    if (!continuous && !isNaN(minSpacing)) {\n      const tickFilterStrategy = ({ index, tickData, primaryTickCount, terminate }) => this.createTickData(2 /* FILTER */, index, tickData, terminate, primaryTickCount);\n      strategies.push(tickFilterStrategy);\n    }\n    if (!avoidLabelCollisions) {\n      return strategies;\n    }\n    if (autoRotate) {\n      const autoRotateStrategy = ({ index, tickData, labelOverlap, terminate }) => ({\n        index,\n        tickData,\n        autoRotation: this.getAutoRotation(labelOverlap),\n        terminate\n      });\n      strategies.push(autoRotateStrategy);\n    }\n    return strategies;\n  }\n  createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount) {\n    const { scale: scale2 } = this;\n    const { step, values, minSpacing, maxSpacing } = this.interval;\n    const { maxTickCount, minTickCount, defaultTickCount } = this.estimateTickCount({ minSpacing, maxSpacing });\n    const continuous = ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2);\n    const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;\n    let tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;\n    const regenerateTicks = step === void 0 && values === void 0 && tickCount > minTickCount && (continuous || tickGenerationType === 2 /* FILTER */);\n    let unchanged = true;\n    while (unchanged && index <= maxIterations) {\n      const prevTicks = tickData.rawTicks;\n      tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;\n      const { rawTicks, fractionDigits, ticks, labelCount } = this.getTicks({\n        tickGenerationType,\n        previousTicks: prevTicks,\n        tickCount,\n        minTickCount,\n        maxTickCount,\n        primaryTickCount\n      });\n      tickData.rawTicks = rawTicks;\n      tickData.fractionDigits = fractionDigits;\n      tickData.ticks = ticks;\n      tickData.labelCount = labelCount;\n      unchanged = regenerateTicks ? areArrayNumbersEqual(rawTicks, prevTicks) : false;\n      index++;\n    }\n    const shouldTerminate = step !== void 0 || values !== void 0;\n    terminate || (terminate = shouldTerminate);\n    return { tickData, index, autoRotation: 0, terminate };\n  }\n  checkLabelOverlap(rotation, rotated, labelMatrix, tickData, labelX, textMeasurer) {\n    Matrix.updateTransformMatrix(labelMatrix, 1, 1, rotation, 0, 0);\n    const labelData = this.createLabelData(tickData, labelX, labelMatrix, textMeasurer);\n    const labelSpacing = getLabelSpacing(this.label.minSpacing, rotated);\n    return axisLabelsOverlap(labelData, labelSpacing);\n  }\n  createLabelData(tickData, labelX, labelMatrix, textMeasurer) {\n    const labelData = [];\n    for (const { tickLabel, translationY } of tickData) {\n      if (!tickLabel)\n        continue;\n      const { width, height } = textMeasurer.measureLines(tickLabel);\n      const bbox = new BBox(labelX, translationY, width, height);\n      const labelDatum = calculateLabelBBox(tickLabel, bbox, labelMatrix);\n      labelData.push(labelDatum);\n    }\n    return labelData;\n  }\n  getAutoRotation(labelOverlap) {\n    return labelOverlap ? normalizeAngle360(toRadians(this.label.autoRotateAngle ?? 0)) : 0;\n  }\n  getTicks({\n    tickGenerationType,\n    previousTicks,\n    tickCount,\n    minTickCount,\n    maxTickCount,\n    primaryTickCount\n  }) {\n    const { range: range3, scale: scale2, visibleRange } = this;\n    let rawTicks;\n    switch (tickGenerationType) {\n      case 3 /* VALUES */:\n        rawTicks = this.interval.values;\n        if (ContinuousScale.is(scale2)) {\n          const [d0, d1] = findMinMax(scale2.getDomain().map(Number));\n          rawTicks = rawTicks.filter((value) => value >= d0 && value <= d1).sort((a, b) => a - b);\n        }\n        break;\n      case 1 /* CREATE_SECONDARY */:\n        if (ContinuousScale.is(scale2)) {\n          rawTicks = this.updateSecondaryAxisTicks(primaryTickCount);\n        } else {\n          rawTicks = this.createTicks(tickCount, minTickCount, maxTickCount);\n        }\n        break;\n      case 2 /* FILTER */:\n        rawTicks = this.filterTicks(previousTicks, tickCount);\n        break;\n      default:\n        rawTicks = this.createTicks(tickCount, minTickCount, maxTickCount);\n        break;\n    }\n    const fractionDigits = rawTicks.reduce((max, tick) => Math.max(max, countFractionDigits(tick)), 0);\n    const halfBandwidth = (scale2.bandwidth ?? 0) / 2;\n    const ticks = [];\n    let labelCount = 0;\n    const tickIdCounts = /* @__PURE__ */ new Map();\n    const start = Math.max(0, Math.floor(visibleRange[0] * rawTicks.length));\n    const end = Math.min(rawTicks.length, Math.ceil(visibleRange[1] * rawTicks.length));\n    const filteredTicks = rawTicks.slice(start, end);\n    this.onFormatChange(filteredTicks, fractionDigits, rawTicks, this.label.format);\n    for (let i = 0; i < filteredTicks.length; i++) {\n      const tick = filteredTicks[i];\n      const translationY = scale2.convert(tick) + halfBandwidth;\n      if (range3.length > 0 && !this.inRange(translationY, 1e-3))\n        continue;\n      const tickLabel = this.formatTick(tick, fractionDigits, start + i);\n      let tickId = tickLabel;\n      if (tickIdCounts.has(tickId)) {\n        const count = tickIdCounts.get(tickId);\n        tickIdCounts.set(tickId, count + 1);\n        tickId = `${tickId}_${count}`;\n      } else {\n        tickIdCounts.set(tickId, 1);\n      }\n      ticks.push({ tick, tickId, tickLabel, translationY: Math.floor(translationY) });\n      if (tickLabel === \"\" || tickLabel == null) {\n        continue;\n      }\n      labelCount++;\n    }\n    return { rawTicks, fractionDigits, ticks, labelCount };\n  }\n  filterTicks(ticks, tickCount) {\n    const { minSpacing, maxSpacing } = this.interval;\n    const tickSpacing = !isNaN(minSpacing) || !isNaN(maxSpacing);\n    const keepEvery = tickSpacing ? Math.ceil(ticks.length / tickCount) : 2;\n    return ticks.filter((_, i) => i % keepEvery === 0);\n  }\n  createTicks(tickCount, minTickCount, maxTickCount) {\n    const { scale: scale2 } = this;\n    if (tickCount && (ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2))) {\n      if (typeof tickCount === \"number\") {\n        scale2.tickCount = tickCount;\n        scale2.minTickCount = minTickCount ?? 0;\n        scale2.maxTickCount = maxTickCount ?? Infinity;\n      } else if (scale2 instanceof TimeScale) {\n        this.setTickInterval(tickCount);\n      }\n    }\n    return scale2.ticks?.() ?? [];\n  }\n  estimateTickCount({ minSpacing, maxSpacing }) {\n    if (!this.label.avoidCollisions) {\n      return {\n        minTickCount: ContinuousScale.defaultMaxTickCount,\n        maxTickCount: ContinuousScale.defaultMaxTickCount,\n        defaultTickCount: ContinuousScale.defaultMaxTickCount\n      };\n    }\n    const rangeWithBleed = this.calculateRangeWithBleed();\n    const defaultMinSpacing = Math.max(\n      this.defaultTickMinSpacing,\n      rangeWithBleed / ContinuousScale.defaultMaxTickCount\n    );\n    let clampMaxTickCount = !isNaN(maxSpacing);\n    if (isNaN(minSpacing)) {\n      minSpacing = defaultMinSpacing;\n    }\n    if (isNaN(maxSpacing)) {\n      maxSpacing = rangeWithBleed;\n    }\n    if (minSpacing > maxSpacing) {\n      if (minSpacing === defaultMinSpacing) {\n        minSpacing = maxSpacing;\n      } else {\n        maxSpacing = minSpacing;\n      }\n    }\n    const minRectDistance = 2;\n    clampMaxTickCount && (clampMaxTickCount = minRectDistance < defaultMinSpacing);\n    const maxTickCount = clamp(\n      1,\n      Math.floor(rangeWithBleed / minSpacing),\n      clampMaxTickCount ? Math.min(Math.floor(rangeWithBleed / minRectDistance), 100) : 100\n    );\n    const minTickCount = Math.min(maxTickCount, Math.ceil(rangeWithBleed / maxSpacing));\n    const defaultTickCount = clamp(minTickCount, ContinuousScale.defaultTickCount, maxTickCount);\n    return { minTickCount, maxTickCount, defaultTickCount };\n  }\n  updateVisibility() {\n    if (this.moduleCtx.animationManager.isSkipped()) {\n      this.resetSelectionNodes();\n    }\n    this.tickLineGroup.visible = this.tick.enabled;\n    this.gridLineGroup.visible = this.gridLine.enabled;\n    this.tickLabelGroup.visible = this.label.enabled;\n  }\n  updateCrossLines({\n    rotation,\n    parallelFlipRotation,\n    regularFlipRotation\n  }) {\n    const sideFlag = this.label.getSideFlag();\n    const anySeriesActive = this.isAnySeriesActive();\n    this.crossLines.forEach((crossLine) => {\n      crossLine.sideFlag = -sideFlag;\n      crossLine.direction = rotation === -Math.PI / 2 ? \"x\" /* X */ : \"y\" /* Y */;\n      if (crossLine instanceof CartesianCrossLine) {\n        crossLine.label.parallel = crossLine.label.parallel ?? this.label.parallel;\n      }\n      crossLine.parallelFlipRotation = parallelFlipRotation;\n      crossLine.regularFlipRotation = regularFlipRotation;\n      crossLine.update(anySeriesActive);\n    });\n  }\n  updateTickLines() {\n    const { tick, label } = this;\n    const sideFlag = label.getSideFlag();\n    this.tickLineGroupSelection.each((line) => {\n      line.strokeWidth = tick.width;\n      line.stroke = tick.stroke;\n      line.x1 = sideFlag * this.getTickSize();\n      line.x2 = 0;\n    });\n  }\n  calculateAvailableRange() {\n    return findRangeExtent(this.range);\n  }\n  /**\n   * Calculates the available range with an additional \"bleed\" beyond the canvas that encompasses the full axis when\n   * the visible range is only a portion of the axis.\n   */\n  calculateRangeWithBleed() {\n    const visibleScale = 1 / findRangeExtent(this.visibleRange);\n    return round(this.calculateAvailableRange() * visibleScale, 2);\n  }\n  calculateDomain() {\n    const visibleSeries = this.boundSeries.filter((s) => this.includeInvisibleDomains || s.isEnabled());\n    const domains = visibleSeries.flatMap((series) => series.getDomain(this.direction));\n    this.setDomain(domains);\n  }\n  getAxisTransform() {\n    return {\n      rotation: toRadians(this.rotation),\n      rotationCenterX: 0,\n      rotationCenterY: 0,\n      translationX: Math.floor(this.translation.x),\n      translationY: Math.floor(this.translation.y)\n    };\n  }\n  updatePosition() {\n    const { crossLineGroup, axisGroup, gridGroup, translation, gridLineGroupSelection, gridPadding, gridLength } = this;\n    const { rotation } = this.calculateRotations();\n    const sideFlag = this.label.getSideFlag();\n    const translationX = Math.floor(translation.x);\n    const translationY = Math.floor(translation.y);\n    crossLineGroup.setProperties({ rotation, translationX, translationY });\n    gridGroup.setProperties({ rotation, translationX, translationY });\n    axisGroup.datum = this.getAxisTransform();\n    gridLineGroupSelection.each((line) => {\n      line.x1 = gridPadding;\n      line.x2 = -sideFlag * gridLength + gridPadding;\n    });\n  }\n  updateSecondaryAxisTicks(_primaryTickCount) {\n    throw new Error(\"AG Charts - unexpected call to updateSecondaryAxisTicks() - check axes configuration.\");\n  }\n  updateSelections(lineData, data, params) {\n    this.lineNode.datum = lineData;\n    this.gridLineGroupSelection.update(\n      this.gridLength ? data : [],\n      (group) => group.append(new Line()),\n      (datum) => datum.tickId\n    );\n    this.tickLineGroupSelection.update(\n      data,\n      (group) => group.appendChild(new Line()),\n      (datum) => datum.tickId\n    );\n    this.tickLabelGroupSelection.update(\n      data.map((d) => this.getTickLabelProps(d, params)),\n      (group) => group.appendChild(new Text()),\n      (datum) => datum.tickId\n    );\n  }\n  updateAxisLine() {\n    const { line } = this;\n    const strokeWidth = line.enabled ? line.width : 0;\n    this.lineNode.setProperties({\n      stroke: line.stroke,\n      strokeWidth\n    });\n  }\n  updateGridLines(sideFlag) {\n    const {\n      gridLine: { style, width },\n      gridPadding,\n      gridLength\n    } = this;\n    if (gridLength === 0 || style.length === 0) {\n      return;\n    }\n    this.gridLineGroupSelection.each((line, _, index) => {\n      const { stroke, lineDash } = style[index % style.length];\n      line.setProperties({\n        x1: gridPadding,\n        x2: -sideFlag * gridLength + gridPadding,\n        fill: void 0,\n        stroke,\n        strokeWidth: width,\n        lineDash\n      });\n    });\n  }\n  updateLabels() {\n    const { label } = this;\n    if (!label.enabled) {\n      return;\n    }\n    this.tickLabelGroupSelection.each((node, datum) => {\n      node.setProperties(datum, [\n        \"fill\",\n        \"fontFamily\",\n        \"fontSize\",\n        \"fontStyle\",\n        \"fontWeight\",\n        \"text\",\n        \"textAlign\",\n        \"textBaseline\"\n      ]);\n    });\n  }\n  updateTitle(params) {\n    const { rotation, title, _titleCaption, lineNode, tickLineGroup, tickLabelGroup } = this;\n    let spacing = 0;\n    if (title.enabled && params.anyTickVisible) {\n      const tickBBox = Group.computeBBox([tickLineGroup, tickLabelGroup, lineNode]);\n      const tickWidth = rotation === 0 ? tickBBox.width : tickBBox.height;\n      spacing += tickWidth + (this.tickLabelGroup.visible ? 0 : this.seriesAreaPadding);\n    }\n    this.setTitleProps(_titleCaption, { spacing });\n  }\n  // For formatting (nice rounded) tick values.\n  formatTick(datum, fractionDigits, index) {\n    return String(this.getFormatter(index, true)(datum, fractionDigits));\n  }\n  // For formatting arbitrary values between the ticks.\n  formatDatum(datum) {\n    return String(this.getFormatter()(datum));\n  }\n  getFormatter(index = 0, isTickLabel) {\n    const {\n      label,\n      labelFormatter,\n      datumFormatter,\n      moduleCtx: { callbackCache }\n    } = this;\n    if (label.formatter) {\n      return (datum, fractionDigits) => callbackCache.call(label.formatter, { value: datum, index, fractionDigits }) ?? datum;\n    } else if (!isTickLabel && datumFormatter) {\n      return (datum) => callbackCache.call(datumFormatter, datum) ?? String(datum);\n    } else if (labelFormatter) {\n      return (datum) => callbackCache.call(labelFormatter, datum) ?? String(datum);\n    }\n    return (datum) => String(datum);\n  }\n  getBBox() {\n    return this.axisGroup.getBBox();\n  }\n  getRegionBBoxProvider() {\n    const { axisGroup } = this;\n    return {\n      id: this.id,\n      computeTransformedBBox() {\n        return axisGroup.computeTransformedBBox();\n      },\n      computeTransformedRegionBBox() {\n        return axisGroup.computeTransformedRegionBBox();\n      },\n      get visible() {\n        return axisGroup.visible;\n      }\n    };\n  }\n  initCrossLine(crossLine) {\n    crossLine.scale = this.scale;\n    crossLine.gridLength = this.gridLength;\n  }\n  isAnySeriesActive() {\n    return this.boundSeries.some((s) => this.includeInvisibleDomains || s.isEnabled());\n  }\n  clipTickLines(x, y, width, height) {\n    this.tickLineGroup.setClipRectInGroupCoordinateSpace(new BBox(x, y, width, height));\n  }\n  clipGrid(x, y, width, height) {\n    this.gridGroup.setClipRectInGroupCoordinateSpace(new BBox(x, y, width, height));\n  }\n  calculatePadding(min, max) {\n    const padding = Math.abs(this.reverse ? max : min) * 0.01;\n    return [padding, padding];\n  }\n  getTitleFormatterParams() {\n    const boundSeries = this.boundSeries.reduce((acc, next) => {\n      const keys = next.getKeys(this.direction);\n      const names = next.getNames(this.direction);\n      for (let idx = 0; idx < keys.length; idx++) {\n        acc.push({ key: keys[idx], name: names[idx] });\n      }\n      return acc;\n    }, []);\n    return {\n      direction: this.direction,\n      boundSeries,\n      defaultValue: this.title?.text\n    };\n  }\n  normaliseDataDomain(d) {\n    return { domain: [...d], clipped: false };\n  }\n  getLayoutState() {\n    return {\n      id: this.id,\n      rect: this.getBBox(),\n      gridPadding: this.gridPadding,\n      seriesAreaPadding: this.seriesAreaPadding,\n      tickSize: this.getTickSize(),\n      direction: this.direction,\n      domain: this.dataDomain.domain,\n      scale: this.scale,\n      ...this.layout\n    };\n  }\n  getModuleMap() {\n    return this.moduleMap;\n  }\n  createModuleContext() {\n    this.axisContext ?? (this.axisContext = this.createAxisContext());\n    return { ...this.moduleCtx, parent: this.axisContext };\n  }\n  createAxisContext() {\n    const { scale: scale2 } = this;\n    return {\n      axisId: this.id,\n      direction: this.direction,\n      continuous: ContinuousScale.is(scale2) || OrdinalTimeScale.is(scale2),\n      keys: () => this.boundSeries.flatMap((s) => s.getKeys(this.direction)),\n      seriesKeyProperties: () => this.boundSeries.reduce((keys, series) => {\n        const seriesKeys = series.getKeyProperties(this.direction);\n        seriesKeys.forEach((key) => {\n          if (keys.indexOf(key) < 0) {\n            keys.push(key);\n          }\n        });\n        return keys;\n      }, []),\n      scaleValueFormatter: (specifier) => this.getScaleValueFormatter(specifier),\n      scaleBandwidth: () => scale2.bandwidth ?? 0,\n      scaleDomain: () => scale2.getDomain?.(),\n      scaleConvert: (val) => scale2.convert(val),\n      scaleInvert: OrdinalTimeScale.is(scale2) ? (val) => scale2.invertNearest?.(val) : (val) => scale2.invert?.(val),\n      scaleInvertNearest: (val) => scale2.invertNearest?.(val),\n      attachLabel: (node) => this.attachLabel(node),\n      inRange: (x, tolerance) => this.inRange(x, tolerance)\n    };\n  }\n  getScaleValueFormatter(format) {\n    const { scale: scale2 } = this;\n    if (format && scale2 && scale2.tickFormat) {\n      try {\n        return scale2.tickFormat({ specifier: format });\n      } catch (e) {\n        Logger.warnOnce(`the format string ${format} is invalid, ignoring.`);\n      }\n    }\n    return this.getFormatter();\n  }\n  animateReadyUpdate(diff2) {\n    const { animationManager } = this.moduleCtx;\n    const selectionCtx = prepareAxisAnimationContext(this);\n    const fns = prepareAxisAnimationFunctions(selectionCtx);\n    fromToMotion(this.id, \"axis-group\", animationManager, [this.axisGroup], fns.group);\n    fromToMotion(this.id, \"line\", animationManager, [this.lineNode], fns.line);\n    fromToMotion(\n      this.id,\n      \"line-paths\",\n      animationManager,\n      [this.gridLineGroupSelection, this.tickLineGroupSelection],\n      fns.tick,\n      (_, d) => d.tickId,\n      diff2\n    );\n    fromToMotion(\n      this.id,\n      \"tick-labels\",\n      animationManager,\n      [this.tickLabelGroupSelection],\n      fns.label,\n      (_, d) => d.tickId,\n      diff2\n    );\n  }\n  resetSelectionNodes() {\n    const { gridLineGroupSelection, tickLineGroupSelection, tickLabelGroupSelection, lineNode } = this;\n    const selectionCtx = prepareAxisAnimationContext(this);\n    resetMotion([this.axisGroup], resetAxisGroupFn());\n    resetMotion([gridLineGroupSelection, tickLineGroupSelection], resetAxisSelectionFn(selectionCtx));\n    resetMotion([tickLabelGroupSelection], resetAxisLabelSelectionFn());\n    resetMotion([lineNode], resetAxisLineSelectionFn());\n  }\n  calculateUpdateDiff(previous, tickData) {\n    const added = /* @__PURE__ */ new Set();\n    const removed = /* @__PURE__ */ new Set();\n    const tickMap = {};\n    const tickCount = Math.max(previous.length, tickData.ticks.length);\n    for (let i = 0; i < tickCount; i++) {\n      const tickDatum = tickData.ticks[i];\n      const prev = previous[i];\n      const tick = tickDatum?.tickId;\n      tickMap[tick ?? prev] = tickDatum;\n      if (prev === tick) {\n        continue;\n      }\n      if (removed.has(tick)) {\n        removed.delete(tick);\n      } else if (tick) {\n        added.add(tick);\n      }\n      if (added.has(prev)) {\n        added.delete(prev);\n      } else if (prev) {\n        removed.add(prev);\n      }\n    }\n    return { changed: added.size > 0 || removed.size > 0, added, removed };\n  }\n  isReversed() {\n    return this.reverse;\n  }\n};\n_Axis.defaultTickMinSpacing = 50;\n_Axis.CrossLineConstructor = CartesianCrossLine;\n__decorateClass([\n  Validate(BOOLEAN)\n], _Axis.prototype, \"nice\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], _Axis.prototype, \"reverse\", 2);\n__decorateClass([\n  Validate(STRING_ARRAY)\n], _Axis.prototype, \"keys\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Axis.prototype, \"interval\", 2);\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], _Axis.prototype, \"title\", 2);\n__decorateClass([\n  ObserveChanges((target, value, oldValue) => target.onGridLengthChange(value, oldValue))\n], _Axis.prototype, \"gridLength\", 2);\nvar Axis = _Axis;\n\n// packages/ag-charts-community/src/chart/axis/cartesianAxisLabel.ts\nvar CartesianAxisLabel = class extends AxisLabel {\n  constructor() {\n    super(...arguments);\n    this.autoRotateAngle = 335;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianAxisLabel.prototype, \"autoRotate\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], CartesianAxisLabel.prototype, \"autoRotateAngle\", 2);\n\n// packages/ag-charts-community/src/chart/axis/cartesianAxis.ts\nvar _CartesianAxis = class _CartesianAxis extends Axis {\n  constructor() {\n    super(...arguments);\n    this.thickness = 0;\n  }\n  static is(value) {\n    return value instanceof _CartesianAxis;\n  }\n  get direction() {\n    return [\"top\", \"bottom\"].includes(this.position) ? \"x\" /* X */ : \"y\" /* Y */;\n  }\n  updateDirection() {\n    switch (this.position) {\n      case \"top\":\n        this.rotation = -90;\n        this.label.mirrored = true;\n        this.label.parallel = true;\n        break;\n      case \"right\":\n        this.rotation = 0;\n        this.label.mirrored = true;\n        this.label.parallel = false;\n        break;\n      case \"bottom\":\n        this.rotation = -90;\n        this.label.mirrored = false;\n        this.label.parallel = true;\n        break;\n      case \"left\":\n        this.rotation = 0;\n        this.label.mirrored = false;\n        this.label.parallel = false;\n        break;\n    }\n    if (this.axisContext) {\n      this.axisContext.position = this.position;\n      this.axisContext.direction = this.direction;\n    }\n  }\n  update(primaryTickCount, animated) {\n    this.updateDirection();\n    return super.update(primaryTickCount, animated);\n  }\n  calculateLayout(primaryTickCount) {\n    this.updateDirection();\n    return super.calculateLayout(primaryTickCount);\n  }\n  createAxisContext() {\n    return {\n      ...super.createAxisContext(),\n      position: this.position\n    };\n  }\n  createLabel() {\n    return new CartesianAxisLabel();\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], _CartesianAxis.prototype, \"thickness\", 2);\n__decorateClass([\n  Validate(POSITION)\n], _CartesianAxis.prototype, \"position\", 2);\nvar CartesianAxis = _CartesianAxis;\n\n// packages/ag-charts-community/src/chart/axis/categoryAxis.ts\nvar CategoryAxis = class extends CartesianAxis {\n  constructor(moduleCtx, scale2 = new BandScale()) {\n    super(moduleCtx, scale2);\n    this._paddingOverrideEnabled = false;\n    this.groupPaddingInner = 0.1;\n    this.includeInvisibleDomains = true;\n  }\n  set paddingInner(value) {\n    this._paddingOverrideEnabled = true;\n    this.scale.paddingInner = value;\n  }\n  get paddingInner() {\n    this._paddingOverrideEnabled = true;\n    return this.scale.paddingInner;\n  }\n  set paddingOuter(value) {\n    this.scale.paddingOuter = value;\n  }\n  get paddingOuter() {\n    return this.scale.paddingOuter;\n  }\n  normaliseDataDomain(d) {\n    const domain = [];\n    const uniqueValues = /* @__PURE__ */ new Set();\n    for (const v of d) {\n      const key = v instanceof Date ? v.getTime() : v;\n      if (!uniqueValues.has(key)) {\n        uniqueValues.add(key);\n        domain.push(v);\n      }\n    }\n    return { domain, clipped: false };\n  }\n  calculateDomain() {\n    if (!this._paddingOverrideEnabled) {\n      let paddingInner = Infinity;\n      let paddingOuter = -Infinity;\n      for (const s of this.boundSeries) {\n        const padding = s.getBandScalePadding?.();\n        if (padding == null)\n          continue;\n        paddingInner = Math.min(paddingInner, padding.inner);\n        paddingOuter = Math.max(paddingOuter, padding.outer);\n      }\n      this.scale.paddingInner = Number.isFinite(paddingInner) ? paddingInner : 0;\n      this.scale.paddingOuter = Number.isFinite(paddingOuter) ? paddingOuter : 0;\n    }\n    return super.calculateDomain();\n  }\n};\nCategoryAxis.className = \"CategoryAxis\";\nCategoryAxis.type = \"category\";\n__decorateClass([\n  Validate(RATIO)\n], CategoryAxis.prototype, \"groupPaddingInner\", 2);\n\n// packages/ag-charts-community/src/chart/axis/tree.ts\nvar TreeNode = class {\n  // current number in sibling group (index)\n  constructor(label = \"\", parent, number2 = 0) {\n    this.x = 0;\n    this.y = 0;\n    this.subtreeLeft = NaN;\n    this.subtreeRight = NaN;\n    this.screenX = 0;\n    this.screenY = 0;\n    this.children = [];\n    this.leafCount = 0;\n    this.prelim = 0;\n    this.mod = 0;\n    this.ancestor = this;\n    this.change = 0;\n    this.shift = 0;\n    this.label = label;\n    this.parent = parent;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.number = number2;\n  }\n  getLeftSibling() {\n    return this.number > 0 && this.parent ? this.parent.children[this.number - 1] : void 0;\n  }\n  getLeftmostSibling() {\n    return this.number > 0 && this.parent ? this.parent.children[0] : void 0;\n  }\n  // traverse the left contour of a subtree, return the successor of v on this contour\n  nextLeft() {\n    return this.children ? this.children[0] : this.thread;\n  }\n  // traverse the right contour of a subtree, return the successor of v on this contour\n  nextRight() {\n    return this.children ? this.children[this.children.length - 1] : this.thread;\n  }\n  getSiblings() {\n    return this.parent ? this.parent.children.filter((_, i) => i !== this.number) : [];\n  }\n};\nfunction ticksToTree(ticks, pad2 = true) {\n  const root = new TreeNode();\n  let depth = 0;\n  if (pad2) {\n    ticks.forEach((tick) => depth = Math.max(depth, tick.labels.length));\n  }\n  ticks.forEach((tick) => {\n    if (pad2) {\n      while (tick.labels.length < depth) {\n        tick.labels.unshift(\"\");\n      }\n    }\n    insertTick(root, tick);\n  });\n  return root;\n}\nfunction insertTick(root, tick) {\n  const pathParts = tick.labels.slice().reverse();\n  const lastPartIndex = pathParts.length - 1;\n  pathParts.forEach((pathPart, partIndex) => {\n    const children = root.children;\n    const existingNode = children.find((child) => child.label === pathPart);\n    const isNotLeaf = partIndex !== lastPartIndex;\n    if (existingNode && isNotLeaf) {\n      root = existingNode;\n    } else {\n      const node = new TreeNode(pathPart, root);\n      node.number = children.length;\n      children.push(node);\n      if (isNotLeaf) {\n        root = node;\n      }\n    }\n  });\n}\nfunction moveSubtree(wm, wp, shift) {\n  const subtrees = wp.number - wm.number;\n  const ratio2 = shift / subtrees;\n  wp.change -= ratio2;\n  wp.shift += shift;\n  wm.change += ratio2;\n  wp.prelim += shift;\n  wp.mod += shift;\n}\nfunction ancestor(vim, v, defaultAncestor) {\n  return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;\n}\nfunction executeShifts(v) {\n  const children = v.children;\n  if (children) {\n    let shift = 0;\n    let change = 0;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const w = children[i];\n      w.prelim += shift;\n      w.mod += shift;\n      change += w.change;\n      shift += w.shift + change;\n    }\n  }\n}\nfunction apportion(v, defaultAncestor, distance3) {\n  const w = v.getLeftSibling();\n  if (w) {\n    let vop = v;\n    let vip = v;\n    let vim = w;\n    let vom = vip.getLeftmostSibling();\n    let sip = vip.mod;\n    let sop = vop.mod;\n    let sim = vim.mod;\n    let som = vom.mod;\n    while (vim.nextRight() && vip.nextLeft()) {\n      vim = vim.nextRight();\n      vip = vip.nextLeft();\n      vom = vom.nextLeft();\n      vop = vop.nextRight();\n      vop.ancestor = v;\n      const shift = vim.prelim + sim - (vip.prelim + sip) + distance3;\n      if (shift > 0) {\n        moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);\n        sip += shift;\n        sop += shift;\n      }\n      sim += vim.mod;\n      sip += vip.mod;\n      som += vom.mod;\n      sop += vop.mod;\n    }\n    if (vim.nextRight() && !vop.nextRight()) {\n      vop.thread = vim.nextRight();\n      vop.mod += sim - sop;\n    } else {\n      if (vip.nextLeft() && !vom.nextLeft()) {\n        vom.thread = vip.nextLeft();\n        vom.mod += sip - som;\n      }\n      defaultAncestor = v;\n    }\n  }\n  return defaultAncestor;\n}\nfunction firstWalk(node, distance3) {\n  const children = node.children;\n  if (children.length) {\n    let defaultAncestor = children[0];\n    children.forEach((child) => {\n      firstWalk(child, distance3);\n      defaultAncestor = apportion(child, defaultAncestor, distance3);\n    });\n    executeShifts(node);\n    const midpoint = (children[0].prelim + children.at(-1).prelim) / 2;\n    const leftSibling = node.getLeftSibling();\n    if (leftSibling) {\n      node.prelim = leftSibling.prelim + distance3;\n      node.mod = node.prelim - midpoint;\n    } else {\n      node.prelim = midpoint;\n    }\n  } else {\n    const leftSibling = node.getLeftSibling();\n    node.prelim = leftSibling ? leftSibling.prelim + distance3 : 0;\n  }\n}\nvar Dimensions = class {\n  constructor() {\n    this.top = Infinity;\n    this.right = -Infinity;\n    this.bottom = -Infinity;\n    this.left = Infinity;\n  }\n  update(node, xy) {\n    const { x, y } = xy(node);\n    if (x > this.right) {\n      this.right = x;\n    }\n    if (x < this.left) {\n      this.left = x;\n    }\n    if (y > this.bottom) {\n      this.bottom = y;\n    }\n    if (y < this.top) {\n      this.top = y;\n    }\n  }\n};\nfunction secondWalk(v, m, layout) {\n  v.x = v.prelim + m;\n  v.y = v.depth;\n  layout.update(v);\n  v.children.forEach((w) => secondWalk(w, m + v.mod, layout));\n}\nfunction thirdWalk(v) {\n  const children = v.children;\n  let leafCount = 0;\n  children.forEach((w) => {\n    thirdWalk(w);\n    if (w.children.length) {\n      leafCount += w.leafCount;\n    } else {\n      leafCount++;\n    }\n  });\n  v.leafCount = leafCount;\n  if (children.length) {\n    v.subtreeLeft = children[0].subtreeLeft;\n    v.subtreeRight = children[v.children.length - 1].subtreeRight;\n    v.x = (v.subtreeLeft + v.subtreeRight) / 2;\n  } else {\n    v.subtreeLeft = v.x;\n    v.subtreeRight = v.x;\n  }\n}\nfunction treeLayout(root) {\n  const layout = new TreeLayout();\n  firstWalk(root, 1);\n  secondWalk(root, -root.prelim, layout);\n  thirdWalk(root);\n  return layout;\n}\nvar TreeLayout = class {\n  constructor() {\n    this.dimensions = new Dimensions();\n    this.leafCount = 0;\n    this.nodes = [];\n    // One might want to process leaf nodes separately from the rest of the tree.\n    // For example, position labels corresponding to leafs vertically, rather than horizontally.\n    this.leafNodes = [];\n    this.nonLeafNodes = [];\n    this.depth = 0;\n  }\n  update(node) {\n    this.dimensions.update(node, (n) => ({ x: n.x, y: n.y }));\n    if (node.children.length) {\n      this.nonLeafNodes.push(node);\n    } else {\n      this.leafCount++;\n      this.leafNodes.push(node);\n    }\n    if (node.depth > this.depth) {\n      this.depth = node.depth;\n    }\n    this.nodes.push(node);\n  }\n  resize(width, height, shiftX = 0, shiftY = 0, flipX = false) {\n    const xSteps = this.leafCount - 1;\n    const ySteps = this.depth;\n    const dimensions = this.dimensions;\n    let scalingX = 1;\n    let scalingY = 1;\n    if (width > 0 && xSteps) {\n      const existingSpacingX = (dimensions.right - dimensions.left) / xSteps;\n      const desiredSpacingX = width / xSteps;\n      scalingX = desiredSpacingX / existingSpacingX;\n      if (flipX) {\n        scalingX = -scalingX;\n      }\n    }\n    if (height > 0 && ySteps) {\n      const existingSpacingY = (dimensions.bottom - dimensions.top) / ySteps;\n      const desiredSpacingY = height / ySteps;\n      scalingY = desiredSpacingY / existingSpacingY;\n    }\n    const screenDimensions = new Dimensions();\n    this.nodes.forEach((node) => {\n      node.screenX = node.x * scalingX;\n      node.screenY = node.y * scalingY;\n      screenDimensions.update(node, (n) => ({ x: n.screenX, y: n.screenY }));\n    });\n    const offsetX = -screenDimensions.left;\n    const offsetY = -screenDimensions.top;\n    this.nodes.forEach((node) => {\n      node.screenX += offsetX + shiftX;\n      node.screenY += offsetY + shiftY;\n    });\n  }\n};\n\n// packages/ag-charts-community/src/chart/axis/groupedCategoryAxis.ts\nvar GroupedCategoryAxisLabel = class extends AxisLabel {\n  constructor() {\n    super(...arguments);\n    this.grid = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], GroupedCategoryAxisLabel.prototype, \"grid\", 2);\nvar GroupedCategoryAxis = class extends CartesianAxis {\n  constructor(moduleCtx) {\n    const scale2 = new BandScale();\n    scale2.paddingOuter = 0.1;\n    scale2.paddingInner = scale2.paddingOuter * 2;\n    super(moduleCtx, scale2);\n    // Label scale (labels are positioned between ticks, tick count = label count + 1).\n    // We don't call is `labelScale` for consistency with other axes.\n    this.tickScale = new BandScale();\n    this.line = new AxisLine();\n    this.label = new GroupedCategoryAxisLabel();\n    this.labelColor = \"rgba(87, 87, 87, 1)\";\n    this.includeInvisibleDomains = true;\n    const { tickLineGroup, tickLabelGroup, gridLineGroup, tickScale } = this;\n    tickScale.paddingInner = 1;\n    tickScale.paddingOuter = 0;\n    this.gridLineSelection = Selection.select(gridLineGroup, Line);\n    this.axisLineSelection = Selection.select(tickLineGroup, Line);\n    this.separatorSelection = Selection.select(tickLineGroup, Line);\n    this.labelSelection = Selection.select(tickLabelGroup, Text);\n    this.lineNode.visible = false;\n  }\n  updateRange() {\n    const { range: rr, visibleRange: vr, scale: scale2 } = this;\n    const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    const shift = span * vr[0];\n    const start = rr[0] - shift;\n    this.tickScale.range = scale2.range = [start, start + span];\n    this.resizeTickTree();\n  }\n  resizeTickTree() {\n    const s = this.scale;\n    const range3 = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;\n    const layout = this.tickTreeLayout;\n    const lineHeight = this.lineHeight;\n    if (layout) {\n      layout.resize(\n        Math.abs(range3[1] - range3[0]),\n        layout.depth * lineHeight,\n        (Math.min(range3[0], range3[1]) || 0) + (s.bandwidth ?? 0) / 2,\n        -layout.depth * lineHeight,\n        range3[1] - range3[0] < 0\n      );\n    }\n  }\n  get lineHeight() {\n    return this.label.fontSize * 1.5;\n  }\n  /**\n   * The length of the grid. The grid is only visible in case of a non-zero value.\n   */\n  onGridVisibilityChange() {\n    this.gridLineSelection.clear();\n    this.labelSelection.clear();\n  }\n  calculateDomain() {\n    const { direction } = this;\n    let isNumericX = null;\n    const flatDomains = this.boundSeries.filter((s) => s.visible).flatMap((series) => {\n      if (direction === \"y\" /* Y */ || isNumericX) {\n        return series.getDomain(direction);\n      }\n      if (isNumericX === null) {\n        const domain2 = series.getDomain(direction);\n        isNumericX = isNumber(domain2[0]);\n        return domain2;\n      }\n      return [];\n    });\n    this.setDomain(extent(flatDomains) ?? unique(flatDomains));\n    const { domain } = this.dataDomain;\n    this.tickTreeLayout = treeLayout(ticksToTree(domain));\n    this.tickScale.domain = domain.concat(\"\");\n    this.resizeTickTree();\n  }\n  /**\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\n   * Supposed to be called _manually_ after changing _any_ of the axis properties.\n   * This allows to bulk set axis properties before updating the nodes.\n   * The node changes made by this method are rendered on the next animation frame.\n   * We could schedule this method call automatically on the next animation frame\n   * when any of the axis properties change (the way we do when properties of scene graph's\n   * nodes change), but this will mean that we first wait for the next animation\n   * frame to make changes to the nodes of the axis, then wait for another animation\n   * frame to render those changes. It's nice to have everything update automatically,\n   * but this extra level of async indirection will not just introduce an unwanted delay,\n   * it will also make it harder to reason about the program.\n   */\n  update() {\n    if (!this.computedLayout) {\n      return;\n    }\n    this.updatePosition();\n    this.updateTitleCaption();\n    this.updateCategoryLabels();\n    this.updateSeparators();\n    this.updateAxisLines();\n    this.updateCategoryGridLines();\n    this.resetSelectionNodes();\n  }\n  updateTitleCaption() {\n    const { _titleCaption } = this;\n    _titleCaption.node.visible = false;\n  }\n  updateCategoryLabels() {\n    if (!this.computedLayout)\n      return;\n    const { tickLabelLayout } = this.computedLayout;\n    const labelSelection = this.labelSelection.update(tickLabelLayout);\n    labelSelection.each((node, datum) => {\n      node.setProperties(datum);\n    });\n  }\n  updateSeparators() {\n    if (!this.computedLayout)\n      return;\n    const { separatorLayout } = this.computedLayout;\n    const { range: range3 } = this;\n    const epsilon2 = 1e-7;\n    const separatorSelection = this.separatorSelection.update(separatorLayout);\n    separatorSelection.each((line, datum) => {\n      line.x1 = datum.x1;\n      line.x2 = datum.x2;\n      line.y1 = datum.y;\n      line.y2 = datum.y;\n      line.visible = this.tick.enabled && datum.y >= range3[0] - epsilon2 && datum.y <= range3[1] + epsilon2;\n      line.stroke = this.tick.stroke;\n      line.fill = void 0;\n      line.strokeWidth = 1;\n    });\n  }\n  updateAxisLines() {\n    if (!this.computedLayout)\n      return;\n    const { axisLineLayout } = this.computedLayout;\n    const axisLineSelection = this.axisLineSelection.update(axisLineLayout);\n    axisLineSelection.each((line, datum) => {\n      line.setProperties({\n        ...datum,\n        stroke: this.line.stroke,\n        strokeWidth: this.line.width\n      });\n      line.x1 = datum.x;\n      line.x2 = datum.x;\n      line.y1 = datum.y1;\n      line.y2 = datum.y2;\n      line.strokeWidth = this.line.width;\n      line.stroke = this.line.stroke;\n    });\n  }\n  updateCategoryGridLines() {\n    const { gridLength, gridLine, label, range: range3, tickScale } = this;\n    const ticks = tickScale.ticks();\n    const sideFlag = label.getSideFlag();\n    const gridSelection = this.gridLineSelection.update(gridLength ? ticks : []);\n    if (gridLength) {\n      const { width, style } = gridLine;\n      const styleCount = style.length;\n      gridSelection.each((line, datum, index) => {\n        const y = Math.round(tickScale.convert(datum));\n        line.x1 = 0;\n        line.x2 = -sideFlag * gridLength;\n        line.y1 = y;\n        line.y2 = y;\n        line.visible = gridLine.enabled && y >= range3[0] && y <= range3[1];\n        const { stroke, lineDash } = style[index % styleCount];\n        line.stroke = stroke;\n        line.strokeWidth = width;\n        line.lineDash = lineDash;\n        line.fill = void 0;\n      });\n    }\n  }\n  computeLayout() {\n    this.updateDirection();\n    this.calculateDomain();\n    this.updateRange();\n    const {\n      scale: scale2,\n      label,\n      label: { parallel },\n      moduleCtx: { callbackCache },\n      range: range3,\n      title,\n      title: { formatter = (p) => p.defaultValue } = {}\n    } = this;\n    const rangeStart = scale2.range[0];\n    const rangeEnd = scale2.range[1];\n    const rangeLength = Math.abs(rangeEnd - rangeStart);\n    const bandwidth = rangeLength / scale2.domain.length || 0;\n    const keepEvery = Math.ceil(label.fontSize / bandwidth);\n    const rotation = toRadians(this.rotation);\n    const isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;\n    const sideFlag = label.getSideFlag();\n    const lineHeight = this.lineHeight;\n    const tickTreeLayout = this.tickTreeLayout;\n    const labels = scale2.ticks();\n    const treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];\n    const isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;\n    const { defaultRotation, configuredRotation, parallelFlipFlag } = calculateLabelRotation({\n      rotation: label.rotation,\n      parallel,\n      regularFlipRotation: normalizeAngle360(rotation - Math.PI / 2),\n      parallelFlipRotation: normalizeAngle360(rotation)\n    });\n    const tickLabelLayout = [];\n    const copyLabelProps = (node) => {\n      return {\n        fill: node.fill,\n        fontFamily: node.fontFamily,\n        fontSize: node.fontSize,\n        fontStyle: node.fontStyle,\n        fontWeight: node.fontWeight,\n        rotation: node.rotation,\n        rotationCenterX: node.rotationCenterX,\n        rotationCenterY: node.rotationCenterY,\n        text: node.text,\n        textAlign: node.textAlign,\n        textBaseline: node.textBaseline,\n        translationX: node.translationX,\n        translationY: node.translationY,\n        visible: node.visible,\n        x: node.x,\n        y: node.y\n      };\n    };\n    const labelBBoxes = /* @__PURE__ */ new Map();\n    let maxLeafLabelWidth = 0;\n    const tempText = new Text();\n    const setLabelProps = (datum, index) => {\n      tempText.setProperties({\n        fill: label.color,\n        fontFamily: label.fontFamily,\n        fontSize: label.fontSize,\n        fontStyle: label.fontStyle,\n        fontWeight: label.fontWeight,\n        textAlign: \"center\",\n        textBaseline: parallelFlipFlag === -1 ? \"bottom\" : \"hanging\",\n        translationX: datum.screenY - label.fontSize * 0.25,\n        translationY: datum.screenX\n      });\n      if (index === 0) {\n        const isCaptionEnabled = title?.enabled && labels.length > 0;\n        if (!isCaptionEnabled) {\n          return false;\n        }\n        const text = callbackCache.call(formatter, this.getTitleFormatterParams());\n        tempText.setProperties({\n          fill: title.color,\n          fontFamily: title.fontFamily,\n          fontSize: title.fontSize,\n          fontStyle: title.fontStyle,\n          fontWeight: title.fontWeight,\n          text,\n          textBaseline: \"hanging\",\n          translationX: datum.screenY - label.fontSize * 0.25,\n          translationY: datum.screenX\n        });\n      } else if (index % keepEvery === 0) {\n        const isInRange = datum.screenX >= range3[0] && datum.screenX <= range3[1];\n        if (!isInRange) {\n          return false;\n        }\n        if (label.formatter) {\n          tempText.text = callbackCache.call(label.formatter, {\n            value: String(datum.label),\n            index\n          }) ?? String(datum.label);\n        } else {\n          tempText.text = String(datum.label);\n        }\n      } else {\n        return false;\n      }\n      return true;\n    };\n    treeLabels.forEach((datum, index) => {\n      const isVisible = setLabelProps(datum, index);\n      if (!isVisible)\n        return;\n      const bbox2 = tempText.computeTransformedBBox();\n      if (!bbox2)\n        return;\n      labelBBoxes.set(index, bbox2);\n      const isLeaf = !datum.children.length;\n      if (isLeaf && bbox2.width > maxLeafLabelWidth) {\n        maxLeafLabelWidth = bbox2.width;\n      }\n    });\n    const labelX = sideFlag * label.padding;\n    const labelGrid = this.label.grid;\n    const separatorData = [];\n    treeLabels.forEach((datum, index) => {\n      let visible = setLabelProps(datum, index);\n      const id = index;\n      tempText.x = labelX;\n      tempText.rotationCenterX = labelX;\n      const isLeaf = !datum.children.length;\n      if (isLeaf) {\n        tempText.rotation = configuredRotation;\n        tempText.textAlign = \"end\";\n        tempText.textBaseline = \"middle\";\n      } else {\n        tempText.translationX -= maxLeafLabelWidth - lineHeight + this.label.padding;\n        const availableRange = datum.leafCount * bandwidth;\n        const bbox2 = labelBBoxes.get(id);\n        if (bbox2 && bbox2.width > availableRange) {\n          visible = false;\n          labelBBoxes.delete(id);\n        } else if (isHorizontal) {\n          tempText.rotation = defaultRotation;\n        } else {\n          tempText.rotation = -Math.PI / 2;\n        }\n      }\n      if (datum.parent && isLabelTree) {\n        const y = isLeaf ? datum.screenX - bandwidth / 2 : datum.screenX - datum.leafCount * bandwidth / 2;\n        if (isLeaf) {\n          if (datum.number !== datum.children.length - 1 || labelGrid) {\n            separatorData.push({\n              y,\n              x1: 0,\n              x2: -maxLeafLabelWidth - this.label.padding * 2\n            });\n          }\n        } else {\n          const x = -maxLeafLabelWidth - this.label.padding * 2 + datum.screenY;\n          separatorData.push({\n            y,\n            x1: x + lineHeight,\n            x2: x\n          });\n        }\n      }\n      let props;\n      if (visible) {\n        const bbox2 = tempText.computeTransformedBBox();\n        if (bbox2) {\n          labelBBoxes.set(index, bbox2);\n        }\n        props = { ...copyLabelProps(tempText), visible };\n      } else {\n        labelBBoxes.delete(index);\n        props = { visible };\n      }\n      tickLabelLayout.push(props);\n    });\n    let minX = 0;\n    separatorData.forEach((d) => minX = Math.min(minX, d.x2));\n    separatorData.push({\n      y: Math.max(rangeStart, rangeEnd),\n      x1: 0,\n      x2: minX\n    });\n    const separatorLayout = [];\n    const separatorBoxes = [];\n    const epsilon2 = 1e-7;\n    separatorData.forEach((datum) => {\n      if (datum.y >= range3[0] - epsilon2 && datum.y <= range3[1] + epsilon2) {\n        const { x1, x2, y } = datum;\n        const separatorBox = new BBox(Math.min(x1, x2), y, Math.abs(x1 - x2), 0);\n        separatorBoxes.push(separatorBox);\n        separatorLayout.push({ x1, x2, y });\n      }\n    });\n    const axisLineLayout = [];\n    const axisLineBoxes = [];\n    const lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;\n    for (let i = 0; i < lineCount; i++) {\n      const visible = labels.length > 0 && (i === 0 || labelGrid && isLabelTree);\n      const x = i > 0 ? -maxLeafLabelWidth - this.label.padding * 2 - (i - 1) * lineHeight : 0;\n      const lineBox = new BBox(x, Math.min(...range3), 0, Math.abs(range3[1] - range3[0]));\n      axisLineBoxes.push(lineBox);\n      axisLineLayout.push({ x, y1: range3[0], y2: range3[1], visible });\n    }\n    const bbox = BBox.merge([...labelBBoxes.values(), ...separatorBoxes, ...axisLineBoxes]);\n    const transformedBBox = this.getTransformBox(bbox);\n    return {\n      bbox: transformedBBox,\n      tickLabelLayout,\n      separatorLayout,\n      axisLineLayout\n    };\n  }\n  calculateLayout() {\n    const { axisLineLayout, separatorLayout, tickLabelLayout, bbox } = this.computeLayout();\n    this.computedLayout = { axisLineLayout, separatorLayout, tickLabelLayout };\n    return { bbox, primaryTickCount: void 0 };\n  }\n};\nGroupedCategoryAxis.className = \"GroupedCategoryAxis\";\nGroupedCategoryAxis.type = \"grouped-category\";\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], GroupedCategoryAxis.prototype, \"labelColor\", 2);\n\n// packages/ag-charts-community/src/module/module.ts\nvar BaseModuleInstance = class {\n  constructor() {\n    this.destroyFns = [];\n  }\n  destroy() {\n    for (const destroyFn of this.destroyFns) {\n      destroyFn();\n    }\n  }\n};\nvar ModuleRegistry = class {\n  constructor() {\n    this.modules = [];\n    this.dependencies = /* @__PURE__ */ new Map();\n    this.dependents = /* @__PURE__ */ new Map();\n  }\n  register(...modules) {\n    for (const module of modules) {\n      this.registerDependencies(module);\n      const otherModule = this.modules.find(\n        (other) => module.type === other.type && module.optionsKey === other.optionsKey && module.identifier === other.identifier\n      );\n      if (otherModule) {\n        if (module.packageType === \"enterprise\" && otherModule.packageType === \"community\") {\n          const index = this.modules.indexOf(otherModule);\n          this.modules.splice(index, 1, module);\n        }\n      } else {\n        this.modules.push(module);\n      }\n    }\n  }\n  hasEnterpriseModules() {\n    return this.modules.some((m) => m.packageType === \"enterprise\");\n  }\n  *byType(...types) {\n    const { dependents } = this;\n    const yielded = /* @__PURE__ */ new Set();\n    let count = 0;\n    const maxCount = 3;\n    const modulesByType = this.modules.filter((module) => types.includes(module.type));\n    do {\n      for (const module of modulesByType) {\n        if (yielded.has(module.optionsKey) || dependents.has(module.optionsKey)) {\n          continue;\n        }\n        yield module;\n        yielded.add(module.optionsKey);\n        for (const [key, dependencies] of dependents.entries()) {\n          dependencies.delete(module.optionsKey);\n          if (dependencies.size === 0) {\n            dependents.delete(key);\n          }\n        }\n      }\n      count++;\n    } while (yielded.size < modulesByType.length && count < maxCount);\n    if (dependents.size > 0) {\n      throw new Error(`Could not resolve module dependencies: [${[...dependents.keys()]}]`);\n    }\n  }\n  registerDependencies(module) {\n    if (module.dependencies == null || module.dependencies.length === 0)\n      return;\n    for (const key of module.dependencies) {\n      const dependencies = this.dependencies.get(key) ?? /* @__PURE__ */ new Set();\n      dependencies.add(module.optionsKey);\n      this.dependencies.set(key, dependencies);\n    }\n    this.dependents.set(module.optionsKey, new Set(module.dependencies));\n  }\n};\nvar moduleRegistry = new ModuleRegistry();\n\n// packages/ag-charts-community/src/util/async.ts\nfunction sleep(sleepTimeoutMs) {\n  return new Promise((resolve) => {\n    setTimeout(() => resolve(void 0), sleepTimeoutMs);\n  });\n}\n\n// packages/ag-charts-community/src/util/mutex.ts\nvar Mutex = class {\n  constructor() {\n    this.available = true;\n    this.acquireQueue = [];\n  }\n  acquire(cb) {\n    return new Promise((resolve) => {\n      this.acquireQueue.push([cb, resolve]);\n      if (this.available) {\n        this.dispatchNext().catch((e) => Logger.errorOnce(e));\n      }\n    });\n  }\n  async acquireImmediately(cb) {\n    if (!this.available) {\n      return false;\n    }\n    await this.acquire(cb);\n    return true;\n  }\n  async waitForClearAcquireQueue() {\n    return this.acquire(async () => void 0);\n  }\n  async dispatchNext() {\n    this.available = false;\n    let [next, done] = this.acquireQueue.shift() ?? [];\n    while (next) {\n      try {\n        await next();\n        done?.();\n      } catch (error) {\n        Logger.error(\"mutex callback error\", error);\n        done?.();\n      }\n      [next, done] = this.acquireQueue.shift() ?? [];\n    }\n    this.available = true;\n  }\n};\n\n// packages/ag-charts-community/src/util/observable.ts\nvar Observable = class {\n  constructor() {\n    this.eventListeners = /* @__PURE__ */ new Map();\n  }\n  addEventListener(eventType, listener) {\n    if (typeof listener !== \"function\") {\n      throw new Error(\"AG Charts - listener must be a Function\");\n    }\n    const eventTypeListeners = this.eventListeners.get(eventType);\n    if (eventTypeListeners) {\n      eventTypeListeners.add(listener);\n    } else {\n      this.eventListeners.set(eventType, /* @__PURE__ */ new Set([listener]));\n    }\n  }\n  removeEventListener(type, listener) {\n    this.eventListeners.get(type)?.delete(listener);\n    if (this.eventListeners.size === 0) {\n      this.eventListeners.delete(type);\n    }\n  }\n  hasEventListener(type) {\n    return this.eventListeners.has(type);\n  }\n  clearEventListeners() {\n    this.eventListeners.clear();\n  }\n  fireEvent(event) {\n    this.eventListeners.get(event.type)?.forEach((listener) => listener(event));\n  }\n};\n\n// packages/ag-charts-community/src/util/padding.ts\nvar Padding = class extends BaseProperties {\n  constructor(top = 0, right = top, bottom = top, left = right) {\n    super();\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n    this.left = left;\n  }\n  clear() {\n    this.top = this.right = this.bottom = this.left = 0;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"top\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"right\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"bottom\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Padding.prototype, \"left\", 2);\n\n// packages/ag-charts-community/src/util/render.ts\nfunction debouncedAnimationFrame(cb) {\n  return buildScheduler((innerCb, _delayMs) => requestAnimationFrame(innerCb), cb);\n}\nfunction debouncedCallback(cb) {\n  return buildScheduler((innerCb, delayMs = 0) => setTimeout(innerCb, delayMs), cb);\n}\nfunction buildScheduler(scheduleFn, cb) {\n  let scheduleCount = 0;\n  let promiseRunning = false;\n  let awaitingPromise;\n  let awaitingDone;\n  const busy = () => {\n    return promiseRunning;\n  };\n  const done = () => {\n    promiseRunning = false;\n    awaitingDone?.();\n    awaitingDone = void 0;\n    awaitingPromise = void 0;\n    if (scheduleCount > 0) {\n      scheduleFn(scheduleCb);\n    }\n  };\n  const scheduleCb = () => {\n    const count = scheduleCount;\n    scheduleCount = 0;\n    promiseRunning = true;\n    const maybePromise = cb({ count });\n    if (!maybePromise) {\n      done();\n      return;\n    }\n    maybePromise.then(done, done);\n  };\n  return {\n    schedule(delayMs) {\n      if (scheduleCount === 0 && !busy()) {\n        scheduleFn(scheduleCb, delayMs);\n      }\n      scheduleCount++;\n    },\n    async await() {\n      if (!busy()) {\n        return;\n      }\n      if (awaitingPromise == null) {\n        awaitingPromise = new Promise((resolve) => {\n          awaitingDone = resolve;\n        });\n      }\n      while (busy()) {\n        await awaitingPromise;\n      }\n    }\n  };\n}\n\n// packages/ag-charts-community/src/version.ts\nvar VERSION = \"10.1.0\";\n\n// packages/ag-charts-community/src/api/state/memento.ts\nvar MementoCaretaker = class {\n  constructor(version) {\n    this.version = version.split(\"-\")[0];\n  }\n  save(...originators) {\n    const packet = { version: this.version };\n    for (const originator of Object.values(originators)) {\n      packet[originator.mementoOriginatorKey] = this.encode(originator, originator.createMemento());\n    }\n    return packet;\n  }\n  restore(blob, ...originators) {\n    if (typeof blob !== \"object\") {\n      Logger.warnOnce(`Could not restore data of type [${typeof blob}], expecting an object, ignoring.`);\n      return;\n    }\n    if (blob == null) {\n      Logger.warnOnce(`Could not restore data of type [null], expecting an object, ignoring.`);\n      return;\n    }\n    if (!(\"version\" in blob) || typeof blob.version !== \"string\") {\n      Logger.warnOnce(`Could not restore data, missing [version] string in object, ignoring.`);\n      return;\n    }\n    for (const originator of originators) {\n      if (!(originator.mementoOriginatorKey in blob)) {\n        continue;\n      }\n      const memento = this.decode(originator, blob[originator.mementoOriginatorKey]);\n      if (!originator.guardMemento(memento)) {\n        Logger.warnOnce(\n          `Could not restore [${originator.mementoOriginatorKey}] data, value was invalid, ignoring.`,\n          memento\n        );\n        return;\n      }\n      originator.restoreMemento(this.version, blob.version, memento);\n    }\n  }\n  /**\n   * Encode a memento as a serializable object, encoding any non-serializble types.\n   */\n  encode(originator, memento) {\n    try {\n      return JSON.parse(JSON.stringify(memento, this.encodeTypes));\n    } catch (error) {\n      throw new Error(`Failed to encode [${originator.mementoOriginatorKey}] value [${error}].`, {\n        cause: error\n      });\n    }\n  }\n  /**\n   * Decode an encoded memento, decoding any non-serializable types.\n   */\n  decode(originator, encoded) {\n    try {\n      return JSON.parse(JSON.stringify(encoded), this.decodeTypes);\n    } catch (error) {\n      throw new Error(`Failed to decode [${originator.mementoOriginatorKey}] value [${error}].`, {\n        cause: error\n      });\n    }\n  }\n  encodeTypes(key, value) {\n    if (isDate(this[key])) {\n      return { __type: \"date\", value: String(this[key]) };\n    }\n    return value;\n  }\n  decodeTypes(key, value) {\n    if (isObject(this[key]) && \"__type\" in this[key] && this[key].__type === \"date\") {\n      return new Date(this[key].value);\n    }\n    return value;\n  }\n};\n\n// packages/ag-charts-community/src/api/state/stateManager.ts\nvar StateManager = class {\n  constructor() {\n    this.caretaker = new MementoCaretaker(VERSION);\n    this.state = /* @__PURE__ */ new Map();\n  }\n  setState(originator, value) {\n    if (jsonDiff(this.state.get(originator.mementoOriginatorKey), value) == null) {\n      return;\n    }\n    this.state.set(originator.mementoOriginatorKey, value);\n    this.restoreState(originator);\n  }\n  restoreState(originator) {\n    const { caretaker, state } = this;\n    if (!state.has(originator.mementoOriginatorKey))\n      return;\n    const value = state.get(originator.mementoOriginatorKey);\n    caretaker.restore({ version: caretaker.version, [originator.mementoOriginatorKey]: value }, originator);\n  }\n};\n\n// packages/ag-charts-community/src/util/userAgent.ts\nfunction hasConstrainedCanvasMemory() {\n  if (typeof navigator === \"undefined\") {\n    return false;\n  }\n  const iPhoneOSMatch = navigator.userAgent.match(/\\(iPhone; CPU iPhone OS (\\d+_\\d+_\\d+) like Mac OS X\\)/);\n  if (iPhoneOSMatch == null) {\n    return false;\n  }\n  const [major, minor] = iPhoneOSMatch[1].split(\"_\").map(Number);\n  return major < 16 || major === 16 && minor < 6;\n}\n\n// packages/ag-charts-community/src/scene/canvas/hdpiCanvas.ts\nvar _HdpiCanvas = class _HdpiCanvas {\n  constructor(options) {\n    this.enabled = true;\n    this.width = 600;\n    this.height = 300;\n    const { width, height, pixelRatio, canvasConstructor, willReadFrequently = false } = options;\n    this.pixelRatio = hasConstrainedCanvasMemory() ? 1 : pixelRatio ?? getWindow(\"devicePixelRatio\");\n    this.element = canvasConstructor?.() ?? createElement(\"canvas\");\n    this.element.style.display = \"block\";\n    this.element.style.width = (width ?? this.width) + \"px\";\n    this.element.style.height = (height ?? this.height) + \"px\";\n    this.element.width = Math.round((width ?? this.width) * this.pixelRatio);\n    this.element.height = Math.round((height ?? this.height) * this.pixelRatio);\n    this.context = this.element.getContext(\"2d\", { willReadFrequently });\n    this.onEnabledChange();\n    this.resize(width ?? 0, height ?? 0);\n    _HdpiCanvas.debugContext(this.context);\n  }\n  static is(value) {\n    return value instanceof _HdpiCanvas;\n  }\n  drawImage(context, dx = 0, dy = 0) {\n    return context.drawImage(this.context.canvas, dx, dy);\n  }\n  toDataURL(type) {\n    return this.element.toDataURL(type);\n  }\n  resize(width, height) {\n    if (!(width > 0 && height > 0))\n      return;\n    const { element: element2, context, pixelRatio } = this;\n    element2.width = Math.round(width * pixelRatio);\n    element2.height = Math.round(height * pixelRatio);\n    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    element2.style.width = width + \"px\";\n    element2.style.height = height + \"px\";\n    this.width = width;\n    this.height = height;\n  }\n  snapshot() {\n  }\n  clear() {\n    this.context.save();\n    this.context.setTransform(this.pixelRatio, 0, 0, this.pixelRatio, 0, 0);\n    this.context.clearRect(0, 0, this.width, this.height);\n    this.context.restore();\n  }\n  destroy() {\n    this.element.remove();\n    this.element.width = 0;\n    this.element.height = 0;\n    this.context.clearRect(0, 0, 0, 0);\n    Object.freeze(this);\n  }\n  onEnabledChange() {\n    if (this.element) {\n      this.element.style.display = this.enabled ? \"\" : \"none\";\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  static debugContext(ctx) {\n    if (Debug.check(\"canvas\")) {\n      const save = ctx.save.bind(ctx);\n      const restore = ctx.restore.bind(ctx);\n      let depth = 0;\n      Object.assign(ctx, {\n        save() {\n          save();\n          depth++;\n        },\n        restore() {\n          if (depth === 0) {\n            throw new Error(\"AG Charts - Unable to restore() past depth 0\");\n          }\n          restore();\n          depth--;\n        },\n        verifyDepthZero() {\n          if (depth !== 0) {\n            throw new Error(`AG Charts - Save/restore depth is non-zero: ${depth}`);\n          }\n        }\n      });\n    }\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => target.onEnabledChange())\n], _HdpiCanvas.prototype, \"enabled\", 2);\nvar HdpiCanvas = _HdpiCanvas;\n\n// packages/ag-charts-community/src/scene/layersManager.ts\nvar LayersManager = class _LayersManager {\n  constructor(canvas, markDirty) {\n    this.canvas = canvas;\n    this.markDirty = markDirty;\n    this.debug = Debug.create(true, \"scene\");\n    this.layersMap = /* @__PURE__ */ new Map();\n    this.nextZIndex = 0;\n    this.nextLayerId = 0;\n  }\n  static sortLayers(a, b) {\n    return compoundAscending(\n      [a.zIndex, ...a.zIndexSubOrder ?? [void 0, void 0], a.id],\n      [b.zIndex, ...b.zIndexSubOrder ?? [void 0, void 0], b.id],\n      ascendingStringNumberUndefined\n    );\n  }\n  get size() {\n    return this.layersMap.size;\n  }\n  forEach(callback2) {\n    Array.from(this.layersMap.values()).sort(_LayersManager.sortLayers).forEach(callback2);\n  }\n  resize(width, height) {\n    this.canvas.resize(width, height);\n    this.layersMap.forEach(({ canvas }) => canvas.resize(width, height));\n  }\n  addLayer(opts) {\n    const { width, height, pixelRatio } = this.canvas;\n    const { zIndex = this.nextZIndex++, name, zIndexSubOrder, getComputedOpacity, getVisibility } = opts;\n    const canvas = new HdpiCanvas({ width, height, pixelRatio });\n    const newLayer = {\n      id: this.nextLayerId++,\n      name,\n      canvas,\n      zIndex,\n      zIndexSubOrder,\n      getComputedOpacity,\n      getVisibility\n    };\n    if (zIndex >= this.nextZIndex) {\n      this.nextZIndex = zIndex + 1;\n    }\n    this.layersMap.set(canvas, newLayer);\n    this.debug(\"Scene.addLayer() - layers\", this.layersMap);\n    return newLayer.canvas;\n  }\n  removeLayer(canvas) {\n    if (this.layersMap.has(canvas)) {\n      this.layersMap.delete(canvas);\n      canvas.destroy();\n      this.markDirty();\n      this.debug(\"Scene.removeLayer() -  layers\", this.layersMap);\n    }\n  }\n  moveLayer(canvas, newZIndex, newZIndexSubOrder) {\n    const layer = this.layersMap.get(canvas);\n    if (layer) {\n      layer.zIndex = newZIndex;\n      layer.zIndexSubOrder = newZIndexSubOrder;\n      this.markDirty();\n      this.debug(\"Scene.moveLayer() -  layers\", this.layersMap);\n    }\n  }\n  clear() {\n    this.layersMap.clear();\n  }\n};\n\n// packages/ag-charts-community/src/scene/sceneDebug.ts\nfunction debugStats(layersManager, debugSplitTimes, ctx, renderCtxStats, extraDebugStats = {}, seriesRect = BBox.zero) {\n  if (!Debug.check(\"scene:stats\" /* SCENE_STATS */, \"scene:stats:verbose\" /* SCENE_STATS_VERBOSE */))\n    return;\n  const { layersRendered = 0, layersSkipped = 0, nodesRendered = 0, nodesSkipped = 0 } = renderCtxStats ?? {};\n  const end = performance.now();\n  const { start, ...durations } = debugSplitTimes;\n  const splits = Object.entries(durations).map(([n, t]) => {\n    return time(n, t);\n  }).filter((v) => v != null).join(\" + \");\n  const extras = Object.entries(extraDebugStats).map(([k, v]) => `${k}: ${v}`).join(\" ; \");\n  const detailedStats = Debug.check(\"scene:stats:verbose\" /* SCENE_STATS_VERBOSE */);\n  const stats = [\n    `${time(\"\\u23F1\\uFE0F\", start, end)} (${splits})`,\n    `${extras}`,\n    `Layers: ${detailedStats ? pct(layersRendered, layersSkipped) : layersManager.size}`,\n    detailedStats ? `Nodes: ${pct(nodesRendered, nodesSkipped)}` : null\n  ].filter(isString);\n  const measurer = new SimpleTextMeasurer((t) => ctx.measureText(t));\n  const statsSize = new Map(stats.map((t) => [t, measurer.measureLines(t)]));\n  const width = Math.max(...Array.from(statsSize.values(), (s) => s.width));\n  const height = accumulate(statsSize.values(), (s) => s.height);\n  ctx.save();\n  ctx.fillStyle = \"white\";\n  ctx.fillRect(0, 0, width, height);\n  ctx.fillStyle = \"black\";\n  let y = 0;\n  for (const [stat, size] of statsSize.entries()) {\n    y += size.height;\n    ctx.fillText(stat, 2 + seriesRect.x, y);\n  }\n  ctx.restore();\n}\nfunction debugSceneNodeHighlight(ctx, debugNodes) {\n  ctx.save();\n  for (const [name, node] of Object.entries(debugNodes)) {\n    const bbox = node.computeTransformedBBox();\n    if (!bbox) {\n      Logger.log(`Scene.render() - no bbox for debugged node [${name}].`);\n      continue;\n    }\n    ctx.globalAlpha = 0.8;\n    ctx.strokeStyle = \"red\";\n    ctx.lineWidth = 1;\n    ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);\n    ctx.fillStyle = \"red\";\n    ctx.strokeStyle = \"white\";\n    ctx.font = \"16px sans-serif\";\n    ctx.textBaseline = \"top\";\n    ctx.textAlign = \"left\";\n    ctx.lineWidth = 2;\n    ctx.strokeText(name, bbox.x, bbox.y, bbox.width);\n    ctx.fillText(name, bbox.x, bbox.y, bbox.width);\n  }\n  ctx.restore();\n}\nfunction buildTree(node) {\n  if (!Debug.check(true, \"scene\" /* SCENE */))\n    return {};\n  return {\n    node,\n    name: node.name ?? node.id,\n    dirty: RedrawType[node.dirty],\n    ...node.parent?.isVirtual ? {\n      virtualParentDirty: RedrawType[node.parent.dirty],\n      virtualParent: node.parent\n    } : {},\n    ...node.children.map((c) => buildTree(c)).reduce((result, childTree) => {\n      let { name: treeNodeName } = childTree;\n      const {\n        node: {\n          visible,\n          opacity,\n          zIndex,\n          zIndexSubOrder,\n          translationX,\n          translationY,\n          rotation,\n          scalingX,\n          scalingY\n        },\n        node: childNode,\n        virtualParent\n      } = childTree;\n      if (!visible || opacity <= 0) {\n        treeNodeName = `(${treeNodeName})`;\n      }\n      if (childNode instanceof Group && childNode.isLayer()) {\n        treeNodeName = `*${treeNodeName}*`;\n      }\n      const key = [\n        `${treeNodeName ?? \"<unknown>\"}`,\n        `z: ${zIndex}`,\n        zIndexSubOrder && `zo: ${zIndexSubOrder.map((v) => typeof v === \"function\" ? `${v()} (fn)` : v).join(\" / \")}`,\n        virtualParent && `(virtual parent)`,\n        translationX && `x: ${translationX}`,\n        translationY && `y: ${translationY}`,\n        rotation && `r: ${rotation}`,\n        scalingX !== 1 && `sx: ${scalingX}`,\n        scalingY !== 1 && `sy: ${scalingY}`\n      ].filter((v) => !!v).join(\" \");\n      let selectedKey = key;\n      let index = 1;\n      while (result[selectedKey] != null && index < 100) {\n        selectedKey = `${key} (${index++})`;\n      }\n      result[selectedKey] = childTree;\n      return result;\n    }, {})\n  };\n}\nfunction buildDirtyTree(node) {\n  if (node.dirty === 0 /* NONE */) {\n    return { dirtyTree: {}, paths: [] };\n  }\n  const childrenDirtyTree = node.children.map((c) => buildDirtyTree(c)).filter((c) => c.paths.length > 0);\n  const name = Group.is(node) ? node.name ?? node.id : node.id;\n  const paths = childrenDirtyTree.length ? childrenDirtyTree.flatMap((c) => c.paths).map((p) => `${name}.${p}`) : [name];\n  return {\n    dirtyTree: {\n      name,\n      node,\n      dirty: RedrawType[node.dirty],\n      ...childrenDirtyTree.map((c) => c.dirtyTree).filter((t) => t.dirty != null).reduce((result, childTree) => {\n        result[childTree.name ?? \"<unknown>\"] = childTree;\n        return result;\n      }, {})\n    },\n    paths\n  };\n}\nfunction pct(rendered, skipped) {\n  const total = rendered + skipped;\n  return `${rendered} / ${total} (${Math.round(100 * rendered / total)}%)`;\n}\nfunction time(name, start, end) {\n  const duration = end != null ? end - start : start;\n  return `${name}: ${Math.round(duration * 100) / 100}ms`;\n}\nfunction accumulate(iterator, mapper) {\n  let sum2 = 0;\n  for (const item of iterator) {\n    sum2 += mapper(item);\n  }\n  return sum2;\n}\n\n// packages/ag-charts-community/src/scene/scene.ts\nvar Scene = class {\n  constructor({ width, height, pixelRatio, domManager }) {\n    this.debug = Debug.create(true, \"scene\" /* SCENE */);\n    this.id = createId(this);\n    this.root = null;\n    this.isDirty = false;\n    this.domManager = domManager;\n    const canvasOpts = {\n      width,\n      height,\n      pixelRatio\n    };\n    if (domManager) {\n      canvasOpts.canvasConstructor = () => domManager.addChild(\"canvas\", \"scene-canvas\");\n    }\n    this.canvas = new HdpiCanvas(canvasOpts);\n    this.layersManager = new LayersManager(this.canvas, () => {\n      this.isDirty = true;\n    });\n  }\n  get width() {\n    return this.pendingSize?.[0] ?? this.canvas.width;\n  }\n  get height() {\n    return this.pendingSize?.[1] ?? this.canvas.height;\n  }\n  setContainer(value) {\n    const isElement = (v) => {\n      return typeof v.tagName !== \"undefined\";\n    };\n    if (isElement(value)) {\n      const { element: element2 } = this.canvas;\n      element2.parentElement?.removeChild(element2);\n      value.appendChild(element2);\n    } else {\n      this.domManager = value;\n      this.domManager.addChild(\"canvas\", \"scene-canvas\", this.canvas.element);\n    }\n    return this;\n  }\n  setRoot(node) {\n    if (this.root === node) {\n      return this;\n    }\n    this.isDirty = true;\n    this.root?._setLayerManager();\n    this.root = node;\n    if (node) {\n      node.visible = true;\n      node._setLayerManager(this.layersManager);\n    }\n    return this;\n  }\n  attachNode(node, rootGroupName) {\n    if (!rootGroupName) {\n      this.root?.appendChild(node);\n      return () => this.removeChild(node);\n    }\n    const parentGroup = this.root?.children.find((g) => g instanceof Group && g.name === rootGroupName);\n    if (!parentGroup)\n      throw new Error(\"AG Charts - Unrecognized root group name: \" + rootGroupName);\n    parentGroup.appendChild(node);\n    return () => parentGroup.removeChild(node);\n  }\n  appendChild(node) {\n    this.root?.appendChild(node);\n    return this;\n  }\n  removeChild(node) {\n    this.root?.removeChild(node);\n    return this;\n  }\n  download(fileName, fileFormat) {\n    downloadUrl(this.canvas.toDataURL(fileFormat), fileName?.trim() ?? \"image\");\n  }\n  /** NOTE: Integrated Charts undocumented image download method. */\n  getDataURL(fileFormat) {\n    return this.canvas.toDataURL(fileFormat);\n  }\n  resize(width, height) {\n    width = Math.round(width);\n    height = Math.round(height);\n    if (width > 0 && height > 0 && (width !== this.width || height !== this.height)) {\n      this.pendingSize = [width, height];\n      this.isDirty = true;\n      return true;\n    }\n    return false;\n  }\n  async render(opts) {\n    const { debugSplitTimes = { start: performance.now() }, extraDebugStats, seriesRect } = opts ?? {};\n    const { canvas, canvas: { context: ctx } = {}, root, pendingSize } = this;\n    if (!ctx) {\n      return;\n    }\n    const renderStartTime = performance.now();\n    if (pendingSize) {\n      this.layersManager.resize(...pendingSize);\n      this.pendingSize = void 0;\n    }\n    if (root && !root.visible) {\n      this.isDirty = false;\n      return;\n    }\n    if (root && !this.isDirty) {\n      if (this.debug.check()) {\n        this.debug(\"Scene.render() - no-op\", {\n          redrawType: RedrawType[root.dirty],\n          tree: buildTree(root)\n        });\n      }\n      debugStats(this.layersManager, debugSplitTimes, ctx, void 0, extraDebugStats, seriesRect);\n      return;\n    }\n    const renderCtx = {\n      ctx,\n      devicePixelRatio: this.canvas.pixelRatio ?? 1,\n      forceRender: true,\n      resized: Boolean(pendingSize),\n      debugNodes: {}\n    };\n    if (Debug.check(\"scene:stats:verbose\" /* SCENE_STATS_VERBOSE */)) {\n      renderCtx.stats = { layersRendered: 0, layersSkipped: 0, nodesRendered: 0, nodesSkipped: 0 };\n    }\n    let canvasCleared = false;\n    if (!root || root.dirty >= 1 /* TRIVIAL */) {\n      canvasCleared = true;\n      canvas.clear();\n    }\n    if (root && Debug.check(\"scene:dirtyTree\" /* SCENE_DIRTY_TREE */)) {\n      const { dirtyTree, paths } = buildDirtyTree(root);\n      Debug.create(\"scene:dirtyTree\" /* SCENE_DIRTY_TREE */)(\"Scene.render() - dirtyTree\", { dirtyTree, paths });\n    }\n    if (root && canvasCleared) {\n      this.debug(\"Scene.render() - before\", {\n        redrawType: RedrawType[root.dirty],\n        canvasCleared,\n        tree: buildTree(root)\n      });\n      if (root.visible) {\n        root.preRender();\n        ctx.save();\n        root.render(renderCtx);\n        ctx.restore();\n      }\n    }\n    debugSplitTimes[\"\\u270D\\uFE0F\"] = performance.now() - renderStartTime;\n    if (this.layersManager.size && canvasCleared) {\n      const layerRenderStart = performance.now();\n      ctx.save();\n      ctx.resetTransform();\n      this.layersManager.forEach((layer) => {\n        if (layer.canvas.enabled && layer.getVisibility()) {\n          ctx.globalAlpha = layer.getComputedOpacity();\n          layer.canvas.drawImage(ctx);\n        }\n      });\n      ctx.restore();\n      debugSplitTimes[\"\\u26D9\"] = performance.now() - layerRenderStart;\n    }\n    ctx.verifyDepthZero?.();\n    this.isDirty = false;\n    debugStats(this.layersManager, debugSplitTimes, ctx, renderCtx.stats, extraDebugStats, seriesRect);\n    debugSceneNodeHighlight(ctx, renderCtx.debugNodes);\n    if (root && this.debug.check()) {\n      this.debug(\"Scene.render() - after\", {\n        redrawType: RedrawType[root.dirty],\n        tree: buildTree(root),\n        canvasCleared\n      });\n    }\n  }\n  /** Alternative to destroy() that preserves re-usable resources. */\n  strip() {\n    const { context, pixelRatio } = this.canvas;\n    context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    this.layersManager.clear();\n    this.setRoot(null);\n    this.isDirty = false;\n  }\n  destroy() {\n    this.strip();\n    this.canvas.destroy();\n    Object.assign(this, { canvas: void 0 });\n  }\n};\nScene.className = \"Scene\";\n\n// packages/ag-charts-community/src/util/callbackCache.ts\nvar CallbackCache = class {\n  constructor() {\n    this.cache = /* @__PURE__ */ new WeakMap();\n  }\n  call(fn, ...params) {\n    let serialisedParams;\n    let paramCache = this.cache.get(fn);\n    try {\n      serialisedParams = JSON.stringify(params);\n    } catch (e) {\n      return this.invoke(fn, params, paramCache);\n    }\n    if (paramCache == null) {\n      paramCache = /* @__PURE__ */ new Map();\n      this.cache.set(fn, paramCache);\n    }\n    if (!paramCache.has(serialisedParams)) {\n      return this.invoke(fn, params, paramCache, serialisedParams);\n    }\n    return paramCache.get(serialisedParams);\n  }\n  invoke(fn, params, paramCache, serialisedParams) {\n    try {\n      const result = fn(...params);\n      if (paramCache && serialisedParams != null) {\n        paramCache.set(serialisedParams, result);\n      }\n      return result;\n    } catch (e) {\n      Logger.warnOnce(`User callback errored, ignoring`, e);\n      return;\n    }\n  }\n  invalidateCache() {\n    this.cache = /* @__PURE__ */ new WeakMap();\n  }\n};\n\n// packages/ag-charts-community/src/util/listeners.ts\nvar Listeners = class {\n  constructor() {\n    this.registeredListeners = /* @__PURE__ */ new Map();\n  }\n  addListener(eventType, handler) {\n    const record = { symbol: Symbol(eventType), handler };\n    if (this.registeredListeners.has(eventType)) {\n      this.registeredListeners.get(eventType).push(record);\n    } else {\n      this.registeredListeners.set(eventType, [record]);\n    }\n    return () => this.removeListener(record.symbol);\n  }\n  removeListener(eventSymbol) {\n    for (const [type, listeners] of this.registeredListeners.entries()) {\n      const matchIndex = listeners.findIndex((listener) => listener.symbol === eventSymbol);\n      if (matchIndex >= 0) {\n        listeners.splice(matchIndex, 1);\n        if (listeners.length === 0) {\n          this.registeredListeners.delete(type);\n        }\n        break;\n      }\n    }\n  }\n  dispatch(eventType, ...params) {\n    for (const listener of this.getListenersByType(eventType)) {\n      try {\n        listener.handler(...params);\n      } catch (e) {\n        Logger.errorOnce(e);\n      }\n    }\n  }\n  dispatchWrapHandlers(eventType, wrapFn, ...params) {\n    for (const listener of this.getListenersByType(eventType)) {\n      try {\n        wrapFn(listener.handler, ...params);\n      } catch (e) {\n        Logger.errorOnce(e);\n      }\n    }\n  }\n  getListenersByType(eventType) {\n    return this.registeredListeners.get(eventType) ?? [];\n  }\n  destroy() {\n    this.registeredListeners.clear();\n  }\n};\n\n// packages/ag-charts-community/src/chart/baseManager.ts\nvar BaseManager = class {\n  constructor() {\n    this.listeners = new Listeners();\n    this.destroyFns = [];\n  }\n  addListener(type, handler) {\n    return this.listeners.addListener(type, handler);\n  }\n  destroy() {\n    this.listeners.destroy();\n    this.destroyFns.forEach((fn) => fn());\n  }\n};\n\n// packages/ag-charts-community/src/chart/annotation/annotationManager.ts\nvar AnnotationManager = class extends BaseManager {\n  constructor(annotationRoot) {\n    super();\n    this.annotationRoot = annotationRoot;\n    this.mementoOriginatorKey = \"annotations\";\n    this.annotations = [];\n  }\n  createMemento() {\n    return this.annotations;\n  }\n  guardMemento(blob) {\n    return isArray(blob);\n  }\n  restoreMemento(_version, _mementoVersion, memento) {\n    const annotations2 = this.cleanData(memento).map((annotation) => {\n      const annotationTheme = this.getAnnotationTypeStyles(annotation.type);\n      return mergeDefaults(annotation, annotationTheme);\n    });\n    this.listeners.dispatch(\"restore-annotations\", {\n      type: \"restore-annotations\",\n      annotations: annotations2\n    });\n  }\n  updateData(annotations2) {\n    this.annotations = this.cleanData(annotations2 ?? []);\n  }\n  attachNode(node) {\n    this.annotationRoot.append(node);\n    return () => {\n      this.annotationRoot?.removeChild(node);\n      return this;\n    };\n  }\n  setAnnotationStyles(styles) {\n    this.styles = styles;\n  }\n  getAnnotationTypeStyles(type) {\n    return this.styles?.[type];\n  }\n  cleanData(annotations2) {\n    for (const annotation of annotations2) {\n      if (\"textAlign\" in annotation)\n        delete annotation.textAlign;\n    }\n    return annotations2;\n  }\n};\n\n// packages/ag-charts-community/src/chart/axis/axisManager.ts\nvar AxisManager = class {\n  constructor(sceneRoot) {\n    this.sceneRoot = sceneRoot;\n    this.axes = /* @__PURE__ */ new Map();\n    this.axisGridGroup = new Group({ name: \"Axes-Grids\", layer: true, zIndex: 1 /* AXIS_GRID_ZINDEX */ });\n    this.axisGroup = new Group({ name: \"Axes\", layer: true, zIndex: 2 /* AXIS_ZINDEX */ });\n    this.sceneRoot.appendChild(this.axisGroup);\n    this.sceneRoot.appendChild(this.axisGridGroup);\n  }\n  updateAxes(oldAxes, newAxes) {\n    for (const axis of oldAxes) {\n      if (newAxes.includes(axis))\n        continue;\n      axis.detachAxis(this.axisGroup, this.axisGridGroup);\n      axis.destroy();\n    }\n    for (const axis of newAxes) {\n      if (oldAxes?.includes(axis))\n        continue;\n      axis.attachAxis(this.axisGroup, this.axisGridGroup);\n    }\n    this.axes.clear();\n    for (const axis of newAxes) {\n      const ctx = axis.createAxisContext();\n      if (this.axes.has(ctx.direction)) {\n        this.axes.get(ctx.direction)?.push(ctx);\n      } else {\n        this.axes.set(ctx.direction, [ctx]);\n      }\n    }\n  }\n  getAxisContext(direction) {\n    return [...this.axes.get(direction) ?? []];\n  }\n  destroy() {\n    this.axes.clear();\n    this.sceneRoot.removeChild(this.axisGroup);\n    this.sceneRoot.removeChild(this.axisGridGroup);\n  }\n};\n\n// packages/ag-charts-community/src/chart/data/dataService.ts\nvar DataService = class extends Listeners {\n  constructor(animationManager) {\n    super();\n    this.animationManager = animationManager;\n    this.dispatchOnlyLatest = true;\n    this.dispatchThrottle = 0;\n    this.requestThrottle = 300;\n    this.isLoadingInitialData = false;\n    this.isLoadingData = false;\n    this.freshRequests = [];\n    this.requestCounter = 0;\n    this.debug = Debug.create(true, \"data-model\", \"data-source\");\n    this.throttledFetch = this.createThrottledFetch(this.requestThrottle);\n    this.throttledDispatch = this.createThrottledDispatch(this.dispatchThrottle);\n  }\n  updateCallback(dataSourceCallback) {\n    if (typeof dataSourceCallback !== \"function\")\n      return;\n    this.debug(\"DataService - updated data source callback\");\n    this.dataSourceCallback = dataSourceCallback;\n    this.isLoadingInitialData = true;\n    this.animationManager.skip();\n    this.dispatch(\"data-source-change\");\n  }\n  clearCallback() {\n    this.dataSourceCallback = void 0;\n  }\n  load(params) {\n    this.isLoadingData = true;\n    this.throttledFetch(params);\n  }\n  isLazy() {\n    return this.dataSourceCallback != null;\n  }\n  isLoading() {\n    return this.isLazy() && (this.isLoadingInitialData || this.isLoadingData);\n  }\n  createThrottledFetch(requestThrottle) {\n    return throttle((params) => this.fetch(params), requestThrottle, {\n      leading: false,\n      trailing: true\n    });\n  }\n  createThrottledDispatch(dispatchThrottle) {\n    return throttle(\n      (id, data) => {\n        this.debug(`DataService - dispatching 'data-load' | ${id}`);\n        this.dispatch(\"data-load\", { type: \"data-load\", data });\n      },\n      dispatchThrottle,\n      {\n        leading: true,\n        trailing: true\n      }\n    );\n  }\n  async fetch(params) {\n    if (!this.dataSourceCallback) {\n      throw new Error(\"DataService - [dataSource.getData] callback not initialised\");\n    }\n    const start = performance.now();\n    const id = this.requestCounter++;\n    this.debug(`DataService - requesting | ${id}`);\n    this.freshRequests.push(id);\n    let response;\n    try {\n      response = await this.dataSourceCallback(params);\n      this.debug(`DataService - response | ${performance.now() - start}ms | ${id}`);\n    } catch (error) {\n      this.debug(`DataService - request failed | ${id}`);\n      Logger.errorOnce(`DataService - request failed | [${error}]`);\n    }\n    this.isLoadingInitialData = false;\n    const requestIndex = this.freshRequests.findIndex((rid) => rid === id);\n    if (requestIndex === -1 || this.dispatchOnlyLatest && requestIndex !== this.freshRequests.length - 1) {\n      this.debug(`DataService - discarding stale request | ${id}`);\n      return;\n    }\n    this.freshRequests = this.freshRequests.slice(requestIndex + 1);\n    if (this.freshRequests.length === 0) {\n      this.isLoadingData = false;\n    }\n    if (Array.isArray(response)) {\n      this.throttledDispatch(id, response);\n    } else {\n      this.dispatch(\"data-error\");\n    }\n  }\n};\n__decorateClass([\n  ActionOnSet({\n    newValue(dispatchThrottle) {\n      this.throttledDispatch = this.createThrottledDispatch(dispatchThrottle);\n    }\n  })\n], DataService.prototype, \"dispatchThrottle\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(requestThrottle) {\n      this.throttledFetch = this.createThrottledFetch(requestThrottle);\n    }\n  })\n], DataService.prototype, \"requestThrottle\", 2);\n\n// packages/ag-charts-community/src/styles.css\nvar styles_default = '.ag-charts-wrapper,.ag-charts-wrapper:focus,.ag-charts-wrapper:after,.ag-charts-wrapper:before,.ag-charts-wrapper *,.ag-charts-wrapper *:focus,.ag-charts-wrapper *:after,.ag-charts-wrapper *:before{box-sizing:border-box;outline:none}.ag-charts-wrapper{position:relative}.ag-charts-canvas-center{width:100%;height:100%;position:absolute;touch-action:auto;display:flex;align-items:var(--ag-charts-align);justify-content:var(--ag-charts-justify)}.ag-charts-canvas-container,.ag-charts-canvas{position:relative}.ag-charts-canvas-container>*,.ag-charts-canvas>*{display:block}.ag-charts-canvas-proxy{position:absolute;top:0;left:0;opacity:0;pointer-events:none}.ag-charts-tab-guard{width:0;height:0;opacity:0}.ag-charts-canvas-overlay{pointer-events:none;position:absolute;inset:0}.ag-charts-canvas-overlay>*{position:absolute;pointer-events:auto}.ag-charts-theme-default,.ag-charts-theme-default-dark{--ag-charts-active-color: var(--ag-active-color, #2196f3);--ag-charts-background-color: var(--ag-background-color, #fff);--ag-charts-foreground-color: var(--ag-foreground-color, #181d1f);--ag-charts-border-color: var(--ag-border-color, #dddddd);--ag-charts-font-family: \"Verdana\", sans-serif;--ag-charts-font-size: var(--ag-font-size, 14px);--ag-charts-size: var(--ag-grid-size, 8px);--ag-charts-border: var(--ag-charts-border-color) var(--ag-borders, solid 1px);--ag-charts-border-critical: var(--ag-borders-critical, solid 1px);--ag-charts-layer-ui-overlay: 5;--ag-charts-layer-tooltip: 4;--ag-charts-layer-toolbar: 3;--ag-charts-layer-crosshair: 2;--ag-charts-layer-annotations: 1;--ag-charts-align: center;--ag-charts-justify: center;--ag-charts-axis-label-background-color: #474747;--ag-charts-axis-label-color: #ffffff;--ag-charts-toolbar-foreground-color: var(--ag-header-foreground-color, var(--ag-charts-foreground-color));--ag-charts-toolbar-background-color: var( --ag-header-background-color, color-mix(in srgb, var(--ag-charts-background-color), var(--ag-charts-foreground-color) 2%) );--ag-charts-toolbar-size: 34px;--ag-charts-toolbar-size-small: 24px;--ag-charts-toolbar-border: var(--ag-charts-border-critical, solid 1px) var(--ag-charts-border-color);--ag-charts-toolbar-hover-color: color-mix( in srgb, var(--ag-charts-background-color), var(--ag-charts-active-color) 12% );--ag-charts-toolbar-focus-color: var(--ag-charts-active-color);--ag-charts-toolbar-active-background-color: var(--ag-charts-toolbar-hover-color);--ag-charts-toolbar-active-color: var(--ag-charts-active-color);--ag-charts-toolbar-disabled-foreground-color: var( --ag-disabled-foreground-color, color-mix(in srgb, transparent, var(--ag-charts-toolbar-foreground-color) 50%) );--ag-charts-toolbar-disabled-background-color: color-mix( in srgb, var(--ag-charts-toolbar-background-color), var(--ag-charts-toolbar-foreground-color) 6% );--ag-charts-toolbar-gap: var(--ag-charts-size);--ag-charts-toolbar-font-size: 13px;--ag-charts-toolbar-font-size-small: 12px;--ag-charts-toolbar-button-padding: 6px;--ag-charts-toolbar-button-padding-small: 1px;--ag-charts-popover-background-color: var(--ag-charts-toolbar-background-color);--ag-charts-popover-foreground-color: var(--ag-charts-toolbar-foreground-color);--ag-charts-popover-border: var(--ag-charts-toolbar-border);--ag-charts-popover-active-color: var(--ag-charts-toolbar-active-color);--ag-charts-popover-hover-color: var(--ag-charts-toolbar-hover-color);--ag-charts-popover-active-background-color: var(--ag-charts-toolbar-active-background-color);--ag-charts-popover-font-size-small: var(--ag-charts-toolbar-font-size-small);--ag-charts-button-radius: var(--ag-border-radius, 4px);--ag-charts-focus-border-color: var(--ag-input-focus-border-color, var(--ag-charts-active-color));--ag-charts-focus-border: solid 1px var(--ag-charts-focus-border-color);--ag-charts-focus-border-shadow: var( --ag-input-focus-box-shadow, 0 0 0 3px color-mix(in srgb, transparent, var(--ag-input-focus-border-color, var(--ag-charts-active-color)) 20%) );--ag-charts-icon-font-family: \"agChartsDefault\";--ag-charts-icon-font-weight: normal;--ag-charts-icon-font-color: color-mix(in srgb, transparent, var(--ag-charts-foreground-color), 90%);--ag-charts-icon-size: 20px;--ag-charts-text-annotations-placeholder: #888888}.ag-charts-theme-default-dark{--ag-charts-background-color: var(--ag-background-color, color-mix(in srgb, #fff, #182230 97%));--ag-charts-foreground-color: var(--ag-foreground-color, #fff);--ag-charts-border-color: var(--ag-border-color, rgba(255, 255, 255, .16));--ag-charts-hover-color: var( --ag-row-hover-color, color-mix(in srgb, transparent, var(--ag-charts-active-color) 20%) );--ag-charts-axis-label-background-color: #9caebb;--ag-charts-axis-label-color: #000000;--ag-charts-toolbar-background-color: var(--ag-header-background-color, color-mix(in srgb, #fff, #182230 93%));--ag-charts-toolbar-hover-color: color-mix( in srgb, var(--ag-charts-background-color), var(--ag-charts-active-color) 18% );--ag-charts-focus-border-shadow: var( --ag-input-focus-box-shadow, 0 0 0 3px color-mix(in srgb, transparent, var(--ag-input-focus-border-color, var(--ag-charts-active-color)) 20%) );--ag-charts-text-annotations-placeholder: #aaaaaa}.ag-charts-icon{display:block;width:var(--ag-charts-icon-size);height:var(--ag-charts-icon-size);speak:none;speak:never;mask:var(--icon) center / contain no-repeat;background-color:currentColor;transition:background-color .25s ease-in-out}.ag-charts-icon-callout-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMyA0LjVBMS41IDEuNSAwIDAgMSA0LjUgM2gxMUExLjUgMS41IDAgMCAxIDE3IDQuNXY4YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtNC41MTRhMjYgMjYgMCAwIDAtMi4wMTcgMS41NGwtLjMxNC4yNmMtLjU1LjQ1Ny0xLjExNS45MjYtMS43NiAxLjQtLjY2OS40OTEtMS41NjItLjAxMi0xLjU2Mi0uOFYxNEg0LjVBMS41IDEuNSAwIDAgMSAzIDEyLjV6TTQuNSA0YS41LjUgMCAwIDAtLjUuNXY4YS41LjUgMCAwIDAgLjUuNWgxLjgzM3YzLjM3MmEzNiAzNiAwIDAgMCAxLjY3OC0xLjMzOGwuMzItLjI2NWEyNiAyNiAwIDAgMSAyLjIyNS0xLjY4NWwuMTI2LS4wODRIMTUuNWEuNS41IDAgMCAwIC41LS41di04YS41LjUgMCAwIDAtLjUtLjV6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-candlestick-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNyAxdjNoMnYxMkg3djNINnYtM0g0VjRoMlYxek01IDVoM3YxMEg1ek0xMSAxNFY2aDJWMy4yNWgxVjZoMnY4aC0ydjIuNzVoLTFWMTR6bTEtN2gzdjZoLTN6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-comment-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNy41MTMgMy45OTVhNi41IDYuNSAwIDAgMSA2LjA5OCAxMS40MWMtLjU4OC4zOTMtMS4yMTcuNTM2LTEuODI5LjU4NWExMyAxMyAwIDAgMS0xLjI3LjAxN0EyNyAyNyAwIDAgMCAxMCAxNkg0LjVhLjUuNSAwIDAgMS0uNS0uNVYxMHEwLS4yNDctLjAwNy0uNTEzYy0uMDA4LS40MTYtLjAxNi0uODU3LjAxNy0xLjI2OS4wNS0uNjEyLjE5Mi0xLjI0LjU4NS0xLjgzYTYuNSA2LjUgMCAwIDEgMi45MTgtMi4zOTNtMy41Ni42MWE1LjUgNS41IDAgMCAwLTUuNjQ2IDIuMzRjLS4yNjYuMzk3LS4zNzkuODQyLS40MiAxLjM1NC0uMDMuMzYtLjAyMi43MTgtLjAxNSAxLjEwOFE1IDkuNjg5IDUgMTB2NWg1cS4zMTEuMDAxLjU5My4wMDhjLjM5LjAwNy43NDcuMDE1IDEuMTA4LS4wMTUuNTEyLS4wNDEuOTU3LS4xNTQgMS4zNTUtLjQyYTUuNSA1LjUgMCAwIDAtMS45ODMtOS45NjciIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-crosshair-add-line{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTEwIDUuNWEuNS41IDAgMCAxIC41LjV2My41aDMuODc1YS41LjUgMCAwIDEgMCAxSDEwLjV2NC4yNWEuNS41IDAgMSAxLTEgMFYxMC41SDUuNjI1YS41LjUgMCAxIDEgMC0xSDkuNVY2YS41LjUgMCAwIDEgLjUtLjUiLz48L3N2Zz4=)}.ag-charts-icon-delete{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZD0iTTguNDk2IDguOTk2QS41LjUgMCAwIDEgOSA5LjQ5MnY0YS41LjUgMCAxIDEtMSAuMDA4di00YS41LjUgMCAwIDEgLjQ5Ni0uNTA0TTEyIDkuNWEuNS41IDAgMCAwLTEgMHY0YS41LjUgMCAwIDAgMSAweiIvPjxwYXRoIGZpbGw9IiMxMzE3MjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTYgNVYzLjVBMi41IDIuNSAwIDAgMSA4LjUgMWgzQTIuNSAyLjUgMCAwIDEgMTQgMy41VjVoMi44MzNhLjUuNSAwIDAgMSAwIDFIMTV2MTAuMjVjMCAuNDE1LS4wNjYuODYzLS4zIDEuMjIxLS4yNTcuMzk0LS42NzIuNjEyLTEuMi42MTJoLTdjLS41MjggMC0uOTQzLS4yMTgtMS4yLS42MTItLjIzNC0uMzU4LS4zLS44MDYtLjMtMS4yMjFWNkgzLjMzM2EuNS41IDAgMCAxIDAtMXptMS0xLjVBMS41IDEuNSAwIDAgMSA4LjUgMmgzQTEuNSAxLjUgMCAwIDEgMTMgMy41VjVIN3pNNiAxNi4yNVY2aDh2MTAuMjVjMCAuMzM1LS4wNTkuNTU0LS4xMzguNjc1LS4wNTUuMDg1LS4xNC4xNTgtLjM2Mi4xNThoLTdjLS4yMjIgMC0uMzA3LS4wNzMtLjM2Mi0uMTU4LS4wOC0uMTIxLS4xMzgtLjM0LS4xMzgtLjY3NSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-disjoint-channel,.ag-charts-icon-disjoint-channel-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTkuMDI4IDE3LjQ2YTIuMjUgMi4yNSAwIDAgMC00LjA5Mi0xLjg1bC05LjUxMS0yLjM3OGEyLjI1IDIuMjUgMCAxIDAtLjIyNS45NzRsOS40NzUgMi4zNjlhMi4yNTEgMi4yNTEgMCAwIDAgNC4zNTMuODg2bS0xLjY2Mi0xLjk2NWExLjI1IDEuMjUgMCAxIDEtLjg4NSAyLjMzOCAxLjI1IDEuMjUgMCAwIDEgLjg4NS0yLjMzOE00LjM0MyAxMy42NjlhMS4yNSAxLjI1IDAgMSAwLTIuMzM4LS44ODUgMS4yNSAxLjI1IDAgMCAwIDIuMzM4Ljg4NU0zLjk3IDguNzY5YTIuMjUgMi4yNSAwIDAgMCAxLjQ1NS0yLjExbDkuNTExLTIuMzc4YTIuMjUgMi4yNSAwIDEgMC0uMjYtLjk2NUw1LjIgNS42ODVhMi4yNSAyLjI1IDAgMSAwLTEuMjMgMy4wODRtLjM3My0yLjU0N2ExLjI1IDEuMjUgMCAxIDEtMi4zMzguODg1IDEuMjUgMS4yNSAwIDAgMSAyLjMzOC0uODg1bTEzLjc1LTMuNDM4YTEuMjUgMS4yNSAwIDEgMS0yLjMzOC44ODUgMS4yNSAxLjI1IDAgMCAxIDIuMzM4LS44ODUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-hollow-candlestick-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1vcGFjaXR5PSIuMTUiIGQ9Ik01IDVoM3YxMEg1eiIvPjxwYXRoIGZpbGw9IiMxMzE3MjIiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTcgMXYzaDJ2MTJIN3YzSDZ2LTNINFY0aDJWMXpNNSA1aDN2MTBINXptNyAyaDN2NmgtM3ptLTEgN1Y2aDJWMy4yNWgxVjZoMnY4aC0ydjIuNzVoLTFWMTR6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-horizontal-line,.ag-charts-icon-horizontal-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNLjUgOS41aDcuMzA2YTIuMjUgMi4yNSAwIDAgMSA0LjM4OCAwSDE5LjV2MWgtNy4zMDZhMi4yNSAyLjI1IDAgMCAxLTQuMzg4IDBILjV6bTkuNSAxLjc1YTEuMjUgMS4yNSAwIDEgMCAwLTIuNSAxLjI1IDEuMjUgMCAwIDAgMCAyLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-line-color{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTQuMjQyIDIuNzIyYy0uNjEyIDAtMS4yLjI0My0xLjYzMi42NzVsLTEuMzQzIDEuMzQ0YS41LjUgMCAwIDAtLjExMi4xMTJMNC4wNSAxMS45NTljLS4yMDcuMjA3LS4zNi40Ni0uNDQ2Ljc0di4wMDFsLS42OSAyLjc2N3YuMDAyYS44Mi44MiAwIDAgMCAxLjAyMiAxLjAyMWguMDAybDIuNjM0LS44MjJjLjI4LS4wODUuNTM0LS4yMzcuNzQtLjQ0M2w3LjEwNy03LjEwOGEuNS41IDAgMCAwIC4xMTItLjExMmwxLjM0My0xLjM0M2EyLjMwOCAyLjMwOCAwIDAgMC0xLjYzMi0zLjk0TTE0LjEyMiA3bDEuMDQ0LTEuMDQ1YTEuMzA4IDEuMzA4IDAgMSAwLTEuODQ5LTEuODVMMTIuMjcxIDUuMTV6bS0yLjU1OC0xLjE0Mi02LjgwNyA2LjgwOWEuOC44IDAgMCAwLS4xOTYuMzI1bC0uNzUgMi40NjggMi40Ny0uNzQ5YS44LjggMCAwIDAgLjMyNS0uMTk0bDYuODA4LTYuODF6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-line-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTcuMzYyIDQuODczLTQuNTk0IDYuNjU0LTQuODUtMy4zMTctNC4yNTEgNi45NzctLjg1NC0uNTJMNy42MTIgNi43OWw0Ljg5OSAzLjM1IDQuMDI4LTUuODM2eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-line-with-markers-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTguMTk4IDQuODg4LTMuNTU2IDQuOTE4YTIuMjUgMi4yNSAwIDEgMS0zLjg2Ni43NWwtMS40MzItLjlhMi4yNCAyLjI0IDAgMCAxLTIuMDA5LjQzNWwtMy44MjggNi40MjgtLjg2LS41MTJMNi40NSA5LjYyM2EyLjI1IDIuMjUgMCAxIDEgMy41MS0uNzYxbDEuMzI5LjgzNWEyLjI0IDIuMjQgMCAwIDEgMi41NTctLjQ5N2wzLjU0Mi00Ljg5OHptLTQuOTYgNS4xNTNhMS4yNSAxLjI1IDAgMSAwLS42NCAyLjQxOSAxLjI1IDEuMjUgMCAwIDAgLjY0LTIuNDE5TTkuMSA4LjMyMXEuMDY2LS4xOTIuMDY3LS40MDRhMS4yNSAxLjI1IDAgMSAwLS4wNjcuNDA0IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-lock,.ag-charts-icon-locked{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuMjA3IDMuNzY0YTIuODk0IDIuODk0IDAgMCAwLTIuODk1IDIuODk0VjloNS43ODlWNi42NThhMi44OTQgMi44OTQgMCAwIDAtMi44OTUtMi44OTRNMTQuMSA5VjYuNjU4YTMuODk0IDMuODk0IDAgMSAwLTcuNzg5IDB2Mi4zNDlBMi41IDIuNSAwIDAgMCA0IDExLjV2M0EyLjUgMi41IDAgMCAwIDYuNSAxN2g4YTIuNSAyLjUgMCAwIDAgMi41LTIuNXYtM0EyLjUgMi41IDAgMCAwIDE0LjUgOXpNNi41IDEwQTEuNSAxLjUgMCAwIDAgNSAxMS41djNBMS41IDEuNSAwIDAgMCA2LjUgMTZoOGExLjUgMS41IDAgMCAwIDEuNS0xLjV2LTNhMS41IDEuNSAwIDAgMC0xLjUtMS41eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-note-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMyA0LjVBMS41IDEuNSAwIDAgMSA0LjUgM2gxMUExLjUgMS41IDAgMCAxIDE3IDQuNXY4YTEuNSAxLjUgMCAwIDEtMS41IDEuNWgtMy4yMWwtMS40NjkgMi41N2ExIDEgMCAwIDEtMS42ODIuMDg1TDcuMjQzIDE0SDQuNUExLjUgMS41IDAgMCAxIDMgMTIuNXpNNC41IDRhLjUuNSAwIDAgMC0uNS41djhhLjUuNSAwIDAgMCAuNS41aDMuMjU3bDIuMTk2IDMuMDc0TDExLjcxIDEzaDMuNzlhLjUuNSAwIDAgMCAuNS0uNXYtOGEuNS41IDAgMCAwLS41LS41eiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNi41IDYuNUEuNS41IDAgMCAxIDcgNmg2YS41LjUgMCAwIDEgMCAxSDdhLjUuNSAwIDAgMS0uNS0uNU02LjUgOS41QS41LjUgMCAwIDEgNyA5aDZhLjUuNSAwIDAgMSAwIDFIN2EuNS41IDAgMCAxLS41LS41IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-ohlc-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZD0iTTEzIDExaC0zdi0xaDNWM2gxdjJoNHYxaC00djExaC0xek02IDE3di0yaDN2LTFINlY0SDV2MUgydjFoM3YxMXoiLz48L3N2Zz4=)}.ag-charts-icon-fill-color{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtOC4wNzEgNC4wNi0uOTI0LS45MjQuNzA3LS43MDcgNy4yODggNy4yODgtNC45NSA0Ljk1YTMuNSAzLjUgMCAwIDEtNC45NSAwbC0xLjQxNC0xLjQxNGEzLjUgMy41IDAgMCAxIDAtNC45NXptLjcwNy43MDhMNC41MzYgOS4wMWEyLjUgMi41IDAgMCAwIDAgMy41MzZMNS45NSAxMy45NmEyLjUgMi41IDAgMCAwIDMuNTM1IDBsNC4yNDMtNC4yNDN6bTYuOSA3LjIwMi0uMzQ1LjM2My0uMzQ0LS4zNjNhLjUuNSAwIDAgMSAuNjg4IDBtLS4zNDUgMS4wOGE4IDggMCAwIDAtLjI4LjMyMyA0LjMgNC4zIDAgMCAwLS40MDkuNTgyYy0uMTEzLjIwMS0uMTQ0LjMyNi0uMTQ0LjM3OGEuODMzLjgzMyAwIDAgMCAxLjY2NyAwYzAtLjA1Mi0uMDMxLS4xNzctLjE0NC0uMzc4YTQuMyA0LjMgMCAwIDAtLjQxLS41ODIgOCA4IDAgMCAwLS4yOC0uMzIybS0uMzQ0LTEuMDguMzQ0LjM2My4zNDQtLjM2My4wMDIuMDAyLjAwNC4wMDQuMDEzLjAxMmE2IDYgMCAwIDEgLjIwNi4yMDhjLjEzMS4xMzYuMzA4LjMyNy40ODUuNTQ1LjE3Ni4yMTUuMzYzLjQ2Ny41MDcuNzI0LjEzNy4yNDMuMjczLjU1My4yNzMuODY4YTEuODMzIDEuODMzIDAgMSAxLTMuNjY3IDBjMC0uMzE1LjEzNi0uNjI1LjI3My0uODY4LjE0NC0uMjU3LjMzLS41MDkuNTA3LS43MjRhOSA5IDAgMCAxIC42NDUtLjcwOGwuMDQ2LS4wNDUuMDEzLS4wMTIuMDA0LS4wMDR6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-pan-end{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0ibTYuNjQ2IDEzLjgxMy0uMzUzLjM1NC43MDcuNzA3LjM1NC0uMzU0ek0xMS4xNjYgMTBsLjM1NC4zNTQuMzU0LS4zNTQtLjM1NC0uMzU0ek03LjM1NSA1LjQ4IDcgNS4xMjZsLS43MDcuNzA3LjM1My4zNTR6bTAgOS4wNCA0LjE2Ni00LjE2Ni0uNzA3LS43MDgtNC4xNjcgNC4xNjd6bTQuMTY2LTQuODc0TDcuMzU0IDUuNDhsLS43MDguNzA3IDQuMTY3IDQuMTY3ek0xMy4wODMgNXYxMGgxVjV6Ii8+PC9zdmc+)}.ag-charts-icon-pan-left{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTIuNzkgNS44MzMgOC42MjUgMTBsNC4xNjYgNC4xNjctLjcwNy43MDdMNy4yMSAxMGw0Ljg3My00Ljg3NHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-right{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNy4yMSAxNC4xNjcgMTEuMzc2IDEwIDcuMjEgNS44MzNsLjcwNy0uNzA3TDEyLjc5IDEwbC00Ljg3MyA0Ljg3NHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-start{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTYgNXYxMGgxVjV6TTkuNjI0IDEwbDQuMTY2LTQuMTY3LS43MDctLjcwN0w4LjIxIDEwbDQuODc0IDQuODc0LjcwNy0uNzA3eiIvPjwvc3ZnPg==)}.ag-charts-icon-parallel-channel,.ag-charts-icon-parallel-channel-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTcuNzIgNS4zMzFBMi4yNSAyLjI1IDAgMSAwIDE0LjcwNSAzLjZsLTkuNDkgNC41NjJhMi4yNSAyLjI1IDAgMSAwIC4yMDkgMS4wMWw5LjY2Mi00LjY0NmEyLjI1IDIuMjUgMCAwIDAgMi42MzQuODA1bS4zNzMtMi41NDdhMS4yNSAxLjI1IDAgMSAxLTIuMzM4Ljg4NSAxLjI1IDEuMjUgMCAwIDEgMi4zMzgtLjg4NU00LjM0MyA4LjY3YTEuMjUgMS4yNSAwIDEgMS0yLjMzOC44ODUgMS4yNSAxLjI1IDAgMCAxIDIuMzM4LS44ODVNNS4zMDcgMTYuNzI4YTIuMjUgMi4yNSAwIDEgMS0uNTI1LS44NThsOS45MjMtNC43N2EyLjI1IDIuMjUgMCAxIDEgLjM4MS45MjZ6bS0uOTY0LjI3NGExLjI1IDEuMjUgMCAxIDEtMi4zMzguODg1IDEuMjUgMS4yNSAwIDAgMSAyLjMzOC0uODg1bTEzLjAyMy01LjEwNmExLjI1IDEuMjUgMCAxIDAtLjg4NS0yLjMzOSAxLjI1IDEuMjUgMCAwIDAgLjg4NSAyLjMzOSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-price-label-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNC41IDNBMS41IDEuNSAwIDAgMCAzIDQuNVYxM2ExLjUgMS41IDAgMCAwIDEuNSAxLjVoLjgzM3YuMDU3Yy4yNDItLjI5OS41OTctLjUwMyAxLS41NDhWMTMuNUg0LjVBLjUuNSAwIDAgMSA0IDEzVjQuNWEuNS41IDAgMCAxIC41LS41aDExYS41LjUgMCAwIDEgLjUuNXY4YS41LjUgMCAwIDEtLjUuNWgtNC44MThsLS4xMjYuMDg0YTI2IDI2IDAgMCAwLTIuMjI1IDEuNjg1bC0uMzIuMjY1LS4wNjguMDU2YTEuNSAxLjUgMCAwIDEtMi42MDkgMS4zNTRjLjAzMy43NjMuOTA1IDEuMjM4IDEuNTYuNzU2LjY0Ni0uNDc0IDEuMjEtLjk0MyAxLjc2MS0xLjRsLjMxMy0uMjZBMjYgMjYgMCAwIDEgMTAuOTg2IDE0SDE1LjVhMS41IDEuNSAwIDAgMCAxLjUtMS41di04QTEuNSAxLjUgMCAwIDAgMTUuNSAzeiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNOC43MTYgMTQuODE1YTIuMjUgMi4yNSAwIDEgMS00LjIxIDEuNTkzIDIuMjUgMi4yNSAwIDAgMSA0LjIxLTEuNTkzbS0xLjY2MiAxLjk2NmExLjI1IDEuMjUgMCAxIDAtLjg4NS0yLjMzOSAxLjI1IDEuMjUgMCAwIDAgLjg4NSAyLjMzOSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-reset{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTIuMDQgNC40NDVhNS44MSA1LjgxIDAgMCAwLTcuMjU3IDIuNDUzLjUuNSAwIDAgMS0uODY1LS41MDJBNi44MSA2LjgxIDAgMSAxIDMgOS44MTNhLjUuNSAwIDAgMSAxIDAgNS44MSA1LjgxIDAgMSAwIDguMDQtNS4zNjgiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTQuMjg5IDMuMDAyYS41LjUgMCAwIDEgLjUuNXYyLjY1NWgyLjY1NWEuNS41IDAgMCAxIDAgMUg0LjI5YS41LjUgMCAwIDEtLjUtLjVWMy41MDJhLjUuNSAwIDAgMSAuNS0uNSIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9zdmc+)}.ag-charts-icon-step-line-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzE4MUQxRiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNiA0aDV2OGgzVjhoNXYxaC00djRoLTVWNUg3djEwSDJ2LTFoNHoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-text-annotation{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00IDRIMTZWN0gxNVY1SDEwLjVWMTVIMTRWMTZINlYxNUg5LjVWNUg1VjdINFY0WiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg==)}.ag-charts-icon-trend-line,.ag-charts-icon-trend-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNS4zMTQgMTAuOTM4YTIuMjUgMi4yNSAwIDEgMSAuMDEtMWg5LjM1MmEyLjI1IDIuMjUgMCAxIDEgLjAxIDF6bS0yLjE4OS43MjlhMS4yNSAxLjI1IDAgMSAwIDAtMi41IDEuMjUgMS4yNSAwIDAgMCAwIDIuNW0xMy43NSAwYTEuMjUgMS4yNSAwIDEgMCAwLTIuNSAxLjI1IDEuMjUgMCAwIDAgMCAyLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-unlock,.ag-charts-icon-unlocked{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuNjUxIDMuNWEyLjg5NCAyLjg5NCAwIDAgMC0yLjg5NCAyLjg5NFY5SDE0LjVhMi41IDIuNSAwIDAgMSAyLjUgMi41djNhMi41IDIuNSAwIDAgMS0yLjUgMi41aC04QTIuNSAyLjUgMCAwIDEgNCAxNC41di0zQTIuNSAyLjUgMCAwIDEgNi41IDloLjI1N1Y2LjM5NGEzLjg5NCAzLjg5NCAwIDEgMSA3Ljc4OSAwIC41LjUgMCAwIDEtMSAwQTIuODk0IDIuODk0IDAgMCAwIDEwLjY1IDMuNU02LjUgMTBBMS41IDEuNSAwIDAgMCA1IDExLjV2M0ExLjUgMS41IDAgMCAwIDYuNSAxNmg4YTEuNSAxLjUgMCAwIDAgMS41LTEuNXYtM2ExLjUgMS41IDAgMCAwLTEuNS0xLjV6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-vertical-line,.ag-charts-icon-vertical-line-drawing{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNMTAuNSA3LjgwNmEyLjI1IDIuMjUgMCAwIDEgMCA0LjM4OFYxOS41aC0xdi03LjMwNmEyLjI1IDIuMjUgMCAwIDEgMC00LjM4OFYuNWgxem0tLjUuOTQ0YTEuMjUgMS4yNSAwIDEgMSAwIDIuNSAxLjI1IDEuMjUgMCAwIDEgMC0yLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-zoom-in{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZD0iTTEwIDUuNWEuNS41IDAgMCAxIC41LjV2My41aDMuODc1YS41LjUgMCAwIDEgMCAxSDEwLjV2NC4yNWEuNS41IDAgMSAxLTEgMFYxMC41SDUuNjI1YS41LjUgMCAxIDEgMC0xSDkuNVY2YS41LjUgMCAwIDEgLjUtLjUiLz48L3N2Zz4=)}.ag-charts-icon-zoom-out{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNS41IDEwYS41LjUgMCAwIDEgLjUtLjVoOGEuNS41IDAgMCAxIDAgMUg2YS41LjUgMCAwIDEtLjUtLjUiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-high-low-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNNyA0aDJ2MTJINFY0aDNNNSA1aDN2MTBINXpNMTEgMTRWNmg1djhoLTVtMS03aDN2NmgtM3oiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-icon-hlc-series{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzEzMTcyMiIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJtMTguMTYzIDEuODM3LTUuMzM0IDExLjYyMUw2Ljk1NyA4LjEybC00LjE5OSA5LjYyMi0uOTE2LS40IDQuNzU2LTEwLjlMMTIuNDkgMTEuOCAxNy4yNTQgMS40MnoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjxwYXRoIGZpbGw9IiMwMDAiIGZpbGwtb3BhY2l0eT0iLjQiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTUuODI1IDIuNzA0LjU1IDEzLjc4NWwuOTAyLjQzIDQuNzI0LTkuOTE5IDYuMDM0IDUuMDI5IDMuMjU1LTguMTQtLjkyOC0uMzctMi43NDUgNi44NnptNy44NTIgMTQuNjM2IDUuNzgtMTMuMTM5LS45MTUtLjQwMi01LjIxOSAxMS44Ni02LjAwNS01LjUwNC0zLjI3OCA3LjY0OC45Mi4zOTQgMi43MjItNi4zNTJ6IiBjbGlwLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ag-charts-icon-zoom-in-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik04Ljc1IDQuNWEuNzUuNzUgMCAwIDAtMS41IDB2Mi43NUg0LjVhLjc1Ljc1IDAgMCAwIDAgMS41aDIuNzV2Mi43NWEuNzUuNzUgMCAwIDAgMS41IDBWOC43NWgyLjc1YS43NS43NSAwIDAgMCAwLTEuNUg4Ljc1VjQuNVoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-zoom-out-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0zLjc1IDhhLjc1Ljc1IDAgMCAxIC43NS0uNzVoN2EuNzUuNzUgMCAwIDEgMCAxLjVoLTdBLjc1Ljc1IDAgMCAxIDMuNzUgOFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-zoom-in-alt,.ag-charts-icon-zoom-in-alt-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20taW4iPjxjaXJjbGUgY3g9IjExIiBjeT0iMTEiIHI9IjgiLz48bGluZSB4MT0iMjEiIHgyPSIxNi42NSIgeTE9IjIxIiB5Mj0iMTYuNjUiLz48bGluZSB4MT0iMTEiIHgyPSIxMSIgeTE9IjgiIHkyPSIxNCIvPjxsaW5lIHgxPSI4IiB4Mj0iMTQiIHkxPSIxMSIgeTI9IjExIi8+PC9zdmc+)}.ag-charts-icon-zoom-out-alt,.ag-charts-icon-zoom-out-alt-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXpvb20tb3V0Ij48Y2lyY2xlIGN4PSIxMSIgY3k9IjExIiByPSI4Ii8+PGxpbmUgeDE9IjIxIiB4Mj0iMTYuNjUiIHkxPSIyMSIgeTI9IjE2LjY1Ii8+PGxpbmUgeDE9IjgiIHgyPSIxNCIgeTE9IjExIiB5Mj0iMTEiLz48L3N2Zz4=)}.ag-charts-icon-reset-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00LjQxMiA0LjA1OCAyLjc1IDIuMzk2VjYuNzVoLjc0NGEuNzYuNzYgMCAwIDAgLjAxMiAwaDMuNTk4TDUuNDc4IDUuMTI1YTQuMTI1IDQuMTI1IDAgMCAxIDIuNTIzLS44NzUgMy43NSAzLjc1IDAgMSAxLTMuMTE5IDUuODMzLjc1Ljc1IDAgMCAwLTEuMjQ3LjgzNEE1LjI1IDUuMjUgMCAxIDAgOCAyLjc1aC0uMDAzYTUuNjI1IDUuNjI1IDAgMCAwLTMuNTg1IDEuMzA4WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-pan-left-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMC4wMyA0LjQ3YS43NS43NSAwIDAgMSAwIDEuMDZMNy41NiA4bDIuNDcgMi40N2EuNzUuNzUgMCAxIDEtMS4wNiAxLjA2bC0zLTNhLjc1Ljc1IDAgMCAxIDAtMS4wNmwzLTNhLjc1Ljc1IDAgMCAxIDEuMDYgMFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-pan-right-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik01Ljk3IDExLjUzYS43NS43NSAwIDAgMSAwLTEuMDZMOC40NCA4IDUuOTcgNS41M2EuNzUuNzUgMCAwIDEgMS4wNi0xLjA2bDMgM2EuNzUuNzUgMCAwIDEgMCAxLjA2bC0zIDNhLjc1Ljc1IDAgMCAxLTEuMDYgMFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-pan-start-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLWNoZXZyb24tZmlyc3QiPjxwYXRoIGQ9Im0xNyAxOC02LTYgNi02Ii8+PHBhdGggZD0iTTcgNnYxMiIvPjwvc3ZnPg==)}.ag-charts-icon-pan-end-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLWNoZXZyb24tbGFzdCI+PHBhdGggZD0ibTcgMTggNi02LTYtNiIvPjxwYXRoIGQ9Ik0xNyA2djEyIi8+PC9zdmc+)}.ag-charts-icon-trend-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMi41IiBjeT0iOCIgcj0iMS43NSIgc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjEuNSIvPjxjaXJjbGUgY3g9IjEzLjUiIGN5PSI4IiByPSIxLjc1IiBzdHJva2U9IiMwMDAiIHN0cm9rZS13aWR0aD0iMS41Ii8+PHBhdGggc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjEuNSIgZD0iTTQgOGg4Ii8+PC9zdmc+)}.ag-charts-icon-horizontal-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMC4zODYgOC43NWEyLjUwMSAyLjUwMSAwIDAgMS00Ljc3MiAwSC43NWEuNzUuNzUgMCAwIDEgMC0xLjVoNC44NjRhMi41MDEgMi41MDEgMCAwIDEgNC43NzIgMGg0Ljg2NGEuNzUuNzUgMCAwIDEgMCAxLjVoLTQuODY0Wk05IDhhMSAxIDAgMSAxLTIgMCAxIDEgMCAwIDEgMiAwWiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-vertical-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik04Ljc1IDUuNjE0YTIuNTAxIDIuNTAxIDAgMCAxIDAgNC43NzJ2NC44NjRhLjc1Ljc1IDAgMCAxLTEuNSAwdi00Ljg2NGEyLjUwMSAyLjUwMSAwIDAgMSAwLTQuNzcyVi43NWEuNzUuNzUgMCAwIDEgMS41IDB2NC44NjRaTTggN2ExIDEgMCAxIDEgMCAyIDEgMSAwIDAgMSAwLTJaIiBmaWxsPSIjMDAwIi8+PC9zdmc+)}.ag-charts-icon-parallel-channel-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC40MjQgNC45MmEyLjUgMi41IDAgMSAwLTMuMzc3LTIuMTRsLTYuNjMgMi45YTIuNTAxIDIuNTAxIDAgMSAwIC42MDcgMS4zNzJsNi41ODUtMi44OGEyLjUwMSAyLjUwMSAwIDAgMCAyLjgxNS43NDhabS4wNS0yLjY5M2ExIDEgMCAxIDEtMS44Ny43MDggMSAxIDAgMCAxIDEuODctLjcwOFptLTExIDQuNzVhMSAxIDAgMSAxLTEuODcuNzA4IDEgMSAwIDAgMSAxLjg3LS43MDhabTEuNTUgNi4wNzVhMi41MDEgMi41MDEgMCAxIDEtLjYwNy0xLjM3Mmw2LjYzLTIuOWEyLjUwMSAyLjUwMSAwIDEgMSAuNTYyIDEuMzkxbC02LjU4NSAyLjg4Wm0tMS41NS0uMDc1YTEgMSAwIDEgMS0xLjg3LjcwOCAxIDEgMCAwIDEgMS44Ny0uNzA4Wm0xMC40Mi0zLjQ2YTEgMSAwIDEgMC0uNzA5LTEuODcgMSAxIDAgMCAwIC43MDggMS44N1oiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-disjoint-channel-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC40MjQgNC45MmEyLjUgMi41IDAgMSAwLTMuMzgzLTIuNDUzTDQuNjkgNC4wNTVhMi41IDIuNSAwIDEgMCAuMzQ0IDEuNDZsNi4zOTItMS41OThhMi41MDEgMi41MDEgMCAwIDAgMyAxLjAwM1ptLjA1LTIuNjkzYTEgMSAwIDEgMS0xLjg3LjcwOCAxIDEgMCAwIDEgMS44Ny0uNzA4Wm0tMTEgMi43NWExIDEgMCAxIDEtMS44Ny43MDggMSAxIDAgMCAxIDEuODctLjcwOFptMS41NiA1LjQyYTIuNSAyLjUgMCAxIDAtLjM0NSAxLjQ2MWw2LjM1MiAxLjU4OGEyLjUgMi41IDAgMSAwIC4zODQtMS40NWwtNi4zOTItMS41OThabS0xLjU2LjUzOGExIDEgMCAxIDAtMS44Ny0uNzA4IDEgMSAwIDAgMCAxLjg3LjcwOFptMTAuNDIgMS40NjFhMSAxIDAgMSAxLS43MDkgMS44NyAxIDEgMCAwIDEgLjcwOC0xLjg3WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-line-color-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgY2xpcC1wYXRoPSJ1cmwoI2EpIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEyLjc4OC41ODNhMi42MyAyLjYzIDAgMCAwLTEuODYuNzdMOS41NDQgMi43MzhhLjc1Ny43NTcgMCAwIDAtLjE0LjE0TDIuMDMyIDEwLjI1di4wMDFjLS4yNDIuMjQxLS40Mi41MzgtLjUyLjg2NGwtLjAwMi4wMDItLjg4IDIuOTAyLS4wMDEuMDAzYTEuMDgzIDEuMDgzIDAgMCAwIDEuMzUgMS4zNDdoLjAwMWwyLjkwMi0uODhoLjAwMWMuMzI2LS4xLjYyMy0uMjc3Ljg2NS0uNTE4di0uMDAxbDcuMzc1LTcuMzc2YS43NjMuNzYzIDAgMCAwIC4xMzktLjEzOWwxLjM4NC0xLjM4NEEyLjYzIDIuNjMgMCAwIDAgMTIuNzg4LjU4M1ptLS4xMjYgNC4zNTIuOTI0LS45MjRhMS4xMyAxLjEzIDAgMCAwLTEuNTk3LTEuNTk3bC0uOTI0LjkyNCAxLjU5NyAxLjU5N1ptLTIuNjU3LS41MzYtNi45MTMgNi45MTRIMy4wOWEuNTgzLjU4MyAwIDAgMC0uMTQ2LjI0MmwtLjY1MyAyLjE1MyAyLjE1NS0uNjU0YS41ODMuNTgzIDAgMCAwIC4yNDEtLjE0NGw2LjkxNC02LjkxNC0xLjU5Ny0xLjU5N1oiIGZpbGw9IiMwMDAiLz48L2c+PGRlZnM+PGNsaXBQYXRoIGlkPSJhIj48cGF0aCBmaWxsPSIjZmZmIiBkPSJNMCAwaDE2djE2SDB6Ii8+PC9jbGlwUGF0aD48L2RlZnM+PC9zdmc+)}.ag-charts-icon-delete-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjA4MyAyLjY2N2MwLS4wOS4wNTMtLjI0Mi4xOTctLjM4Ny4xNDUtLjE0NC4yOTctLjE5Ny4zODctLjE5N2gyLjY2N2MuMDg5IDAgLjI0MS4wNTMuMzg2LjE5Ny4xNDUuMTQ1LjE5Ny4yOTcuMTk3LjM4N3YuNTgzSDYuMDg0di0uNTgzWk01LjMzIDQuNzVIMTEuOTE3djguNTgzYzAgLjA5LS4wNTIuMjQyLS4xOTcuMzg3LS4xNDUuMTQ0LS4yOTcuMTk3LS4zODYuMTk3SDQuNjY3Yy0uMDkgMC0uMjQyLS4wNTMtLjM4Ny0uMTk3LS4xNDQtLjE0NS0uMTk3LS4yOTctLjE5Ny0uMzg3VjQuNzVINS4zM1ptLS43NDUtMS41di0uNTgzYzAtLjU3OC4yOC0xLjA5Mi42MzYtMS40NDcuMzU1LS4zNTYuODctLjYzNyAxLjQ0Ny0uNjM3aDIuNjY3Yy41NzcgMCAxLjA5MS4yODEgMS40NDcuNjM3LjM1NS4zNTUuNjM2Ljg3LjYzNiAxLjQ0N3YuNTgzSDE0YS43NS43NSAwIDAgMSAwIDEuNWgtLjU4M3Y4LjU4M2MwIC41NzgtLjI4MSAxLjA5Mi0uNjM2IDEuNDQ3LS4zNTYuMzU2LS44Ny42MzctMS40NDcuNjM3SDQuNjY3Yy0uNTc3IDAtMS4wOTItLjI4MS0xLjQ0Ny0uNjM3LS4zNTUtLjM1NS0uNjM3LS44Ny0uNjM3LTEuNDQ3VjQuNzVIMmEuNzUuNzUgMCAwIDEgMC0xLjVoMi41ODNabTIuMDgzIDMuMzMzYS43NS43NSAwIDAgMSAuNzUuNzV2NGEuNzUuNzUgMCAxIDEtMS41IDB2LTRhLjc1Ljc1IDAgMCAxIC43NS0uNzVabTMuNDE3Ljc1YS43NS43NSAwIDAgMC0xLjUgMHY0YS43NS43NSAwIDEgMCAxLjUgMHYtNFoiIGZpbGw9IiMwMDAiLz48L3N2Zz4=)}.ag-charts-icon-lock-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjE3MyAyLjg0YTIuNTgzIDIuNTgzIDAgMCAxIDQuNDEgMS44Mjd2MS45MTZINS40MTZWNC42NjdjMC0uNjg1LjI3My0xLjM0My43NTctMS44MjdaTTMuOTE3IDYuNTgzVjQuNjY3YTQuMDgzIDQuMDgzIDAgMCAxIDguMTY2IDB2MS45MTZoLjU4NGMxLjE1IDAgMi4wODMuOTMzIDIuMDgzIDIuMDg0djQuNjY2YzAgMS4xNS0uOTMzIDIuMDg0LTIuMDgzIDIuMDg0SDMuMzMzYTIuMDgzIDIuMDgzIDAgMCAxLTIuMDgzLTIuMDg0VjguNjY3YzAtMS4xNTEuOTMzLTIuMDg0IDIuMDgzLTIuMDg0aC41ODNabTcuNDE2IDEuNWgtOGEuNTgzLjU4MyAwIDAgMC0uNTgzLjU4NHY0LjY2NmMwIC4zMjIuMjYxLjU4NC41ODMuNTg0aDkuMzM0YS41ODMuNTgzIDAgMCAwIC41ODMtLjU4NFY4LjY2N2EuNTgzLjU4MyAwIDAgMC0uNTgzLS41ODRoLTEuMzM0WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-unlock-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTciIGhlaWdodD0iMTYiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjkyMyAyLjg0YTIuNTgzIDIuNTgzIDAgMCAxIDMuNjUzIDAgMyAzIDAgMCAxIC41Ny43OThjLjEzNC4yNzguMTcuNDc0LjE3LjU0NWEuNzUuNzUgMCAwIDAgMS41IDBjMC0uMzgxLS4xMzItLjgwOS0uMzItMS4xOThhNC41MDEgNC41MDEgMCAwIDAtLjg1OS0xLjIwNiA0LjA4MyA0LjA4MyAwIDAgMC02Ljk3IDIuODg4djEuOTE2aC0uNTg0QzIuOTMzIDYuNTgzIDIgNy41MTYgMiA4LjY2N3Y0LjY2NmMwIDEuMTUuOTMzIDIuMDg0IDIuMDgzIDIuMDg0aDkuMzM0YzEuMTUgMCAyLjA4My0uOTMzIDIuMDgzLTIuMDg0VjguNjY3YzAtMS4xNTEtLjkzMy0yLjA4NC0yLjA4My0yLjA4NGgtNy4yNVY0LjY2N2MwLS42ODUuMjcyLTEuMzQzLjc1Ni0xLjgyN1pNNS40MTcgOC4wODNINC4wODJhLjU4My41ODMgMCAwIDAtLjU4My41ODR2NC42NjZjMCAuMzIyLjI2MS41ODQuNTgzLjU4NGg5LjMzNGEuNTgzLjU4MyAwIDAgMCAuNTgzLS41ODRWOC42NjdhLjU4My41ODMgMCAwIDAtLjU4My0uNTg0aC04WiIgZmlsbD0iIzAwMCIvPjwvc3ZnPg==)}.ag-charts-icon-plus-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9ImN1cnJlbnRDb2xvciIgc3Ryb2tlLXdpZHRoPSIyIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGNsYXNzPSJsdWNpZGUgbHVjaWRlLXBsdXMiPjxwYXRoIGQ9Ik01IDEyaDE0Ii8+PHBhdGggZD0iTTEyIDV2MTQiLz48L3N2Zz4=)}.ag-charts-icon-crossline-add-line-legacy{--icon: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgZmlsbD0ibm9uZSI+PHBhdGggZmlsbD0iIzAwMCIgZmlsbC1ydWxlPSJldmVub2RkIiBkPSJNOC43NSA0LjVhLjc1Ljc1IDAgMCAwLTEuNSAwdjIuNzVINC41YS43NS43NSAwIDAgMCAwIDEuNWgyLjc1djIuNzVhLjc1Ljc1IDAgMCAwIDEuNSAwVjguNzVoMi43NWEuNzUuNzUgMCAwIDAgMC0xLjVIOC43NXoiIGNsaXAtcnVsZT0iZXZlbm9kZCIvPjwvc3ZnPg==)}.ag-charts-focus.ag-charts-focus__indicator{position:absolute;display:block;pointer-events:none;user-select:none;width:100%;height:100%}.ag-charts-focus.ag-charts-focus__indicator>div{position:absolute;outline:var(--ag-charts-focus-border);outline-width:2px;box-shadow:var(--ag-charts-focus-border-shadow)}.ag-charts-focus.ag-charts-focus__indicator>svg{width:100%;height:100%;fill:none;stroke:var(--ag-charts-focus-border-color);stroke-width:2px}.ag-charts-focus--hidden{visibility:hidden}.ag-charts-toolbar{align-items:center;background:none;border:none;display:flex;flex-wrap:nowrap;opacity:1;position:absolute;transform:translateY(0);transition:opacity .2s ease-in-out,transform .2s ease-in-out}.ag-charts-toolbar--hidden,.ag-charts-toolbar--prevent-flash{visibility:hidden}.ag-charts-toolbar--floating-hidden{opacity:0;transition:opacity .4s ease-in-out}.ag-charts-toolbar--small{--ag-charts-toolbar-size: var(--ag-charts-toolbar-size-small);--ag-charts-toolbar-font-size: var(--ag-charts-toolbar-font-size-small);--ag-charts-toolbar-button-padding: var(--ag-charts-toolbar-button-padding-small)}.ag-charts-toolbar--top,.ag-charts-toolbar--bottom{flex-direction:row;width:100%}.ag-charts-toolbar--left,.ag-charts-toolbar--right{flex-direction:column}.ag-charts-toolbar--floating,.ag-charts-toolbar--floating-top,.ag-charts-toolbar--floating-bottom{background:none;border:none;flex-direction:row;pointer-events:none;width:100%}.ag-charts-toolbar--floating{padding:0;width:auto;z-index:var(--ag-charts-layer-toolbar)}.ag-charts-toolbar--floating-top{height:calc(var(--ag-charts-toolbar-size) + 10px);padding-top:10px}.ag-charts-toolbar--floating-bottom{height:calc(var(--ag-charts-toolbar-size) + 10px);padding-bottom:10px;overflow:hidden}.ag-charts-toolbar__align{display:flex;flex-direction:inherit;flex-wrap:inherit;gap:var(--ag-charts-toolbar-gap);max-width:100%;width:100%}.ag-charts-toolbar__align--start{justify-content:start}.ag-charts-toolbar__align--center{justify-content:center}.ag-charts-toolbar__align--end{justify-content:end}.ag-charts-toolbar__align--center,.ag-charts-toolbar__align--end{margin-left:auto}.ag-charts-toolbar--left .ag-charts-toolbar__align--center,.ag-charts-toolbar--left .ag-charts-toolbar__align--end,.ag-charts-toolbar--right .ag-charts-toolbar__align--center,.ag-charts-toolbar--right .ag-charts-toolbar__align--end{margin-left:0;margin-top:auto}.ag-charts-toolbar--floating-top .ag-charts-toolbar__align,.ag-charts-toolbar--floating-bottom .ag-charts-toolbar__align{transition:transform .4s ease-in-out;width:auto}.ag-charts-toolbar__section{display:inherit;flex-direction:inherit;flex-wrap:inherit;justify-content:inherit;max-width:inherit;width:inherit}.ag-charts-toolbar__button{--transition: background-color .25s ease-in-out, border-color .25s ease-in-out, color .25s ease-in-out;align-items:center;background:var(--ag-charts-toolbar-background-color);border:var(--ag-charts-toolbar-border);color:var(--ag-charts-toolbar-foreground-color);display:flex;font:var(--ag-charts-toolbar-font-size) var(--ag-charts-font-family);justify-content:center;margin:0 0 0 -1px;min-height:var(--ag-charts-toolbar-size);min-width:var(--ag-charts-toolbar-size);padding:var(--ag-charts-toolbar-button-padding);pointer-events:all;position:relative;transition:var(--transition);white-space:nowrap}.ag-charts-toolbar__button[data-toolbar-group=ranges]{padding:var(--ag-charts-toolbar-button-padding) calc(var(--ag-charts-toolbar-button-padding) * 1.5)}.ag-charts-toolbar--top,.ag-charts-toolbar--bottom,.ag-charts-toolbar--floating,.ag-charts-toolbar--floating-top,.ag-charts-toolbar--floating-bottom{.ag-charts-toolbar__button:nth-child(1 of:not(.ag-charts-toolbar__button--hidden-toggled)){border-bottom-left-radius:var(--ag-charts-button-radius);border-top-left-radius:var(--ag-charts-button-radius);margin:0}.ag-charts-toolbar__button:nth-last-child(1 of:not(.ag-charts-toolbar__button--hidden-toggled)){border-bottom-right-radius:var(--ag-charts-button-radius);border-top-right-radius:var(--ag-charts-button-radius)}}.ag-charts-toolbar--left,.ag-charts-toolbar--right{.ag-charts-toolbar__button{border-radius:0;margin:-1px 0 0;max-width:100%}.ag-charts-toolbar__button:nth-child(1 of:not(.ag-charts-toolbar__button--hidden-toggled)){border-top-left-radius:var(--ag-charts-button-radius);border-top-right-radius:var(--ag-charts-button-radius);margin:0}.ag-charts-toolbar__button:nth-last-child(1 of:not(.ag-charts-toolbar__button--hidden-toggled)){border-bottom-left-radius:var(--ag-charts-button-radius);border-bottom-right-radius:var(--ag-charts-button-radius)}}.ag-charts-toolbar__button--hidden-value,.ag-charts-toolbar__button--hidden-toggled{display:none}.ag-charts-toolbar__button:hover{background:var(--ag-charts-toolbar-hover-color);z-index:1}.ag-charts-toolbar__button:focus-visible{border-color:var(--ag-charts-toolbar-focus-color);box-shadow:var(--ag-charts-focus-border-shadow);z-index:3}.ag-charts-toolbar__button.ag-charts-toolbar__button--active{background:var(--ag-charts-toolbar-active-background-color);border-color:var(--ag-charts-toolbar-active-color);color:var(--ag-charts-toolbar-active-color);z-index:2}.ag-charts-toolbar__button[aria-disabled=true]{background:var(--ag-charts-toolbar-disabled-background-color);color:var(--ag-charts-toolbar-disabled-foreground-color)}.ag-charts-toolbar__button:not([aria-disabled=true]){cursor:pointer}.ag-charts-toolbar__button--fill-visible:after{content:\"\";display:block;position:absolute;bottom:3px;left:5px;right:5px;height:4px;border-radius:99px;box-shadow:inset 0 0 0 1px color-mix(in srgb,var(--ag-charts-foreground-color) 10%,transparent);background:var(--fill)}.ag-charts-toolbar__button--fill-visible[aria-disabled=true]:after{filter:grayscale(1);opacity:.5}.ag-charts-toolbar__icon+.ag-charts-toolbar__label{margin-left:var(--ag-charts-toolbar-gap)}.ag-charts-toolbar__icon,.ag-charts-toolbar__label{pointer-events:none}.ag-chart-overlay{color:#181d1f;pointer-events:none}.ag-chart-overlay.ag-chart-dark-overlay{color:#fff}.ag-chart-overlay--loading{color:#8c8c8c}.ag-chart-overlay__loading-background{background:#fff;pointer-events:none}.ag-chart-overlay.ag-chart-dark-overlay .ag-chart-overlay__loading-background{background:#192232}.ag-chart-tooltip{transition:transform .1s ease;width:max-content;z-index:99999;font:12px Verdana,sans-serif;color:#464646;box-shadow:0 4px 8px #00000014}.ag-chart-tooltip-wrap-always{overflow-wrap:break-word;word-break:break-word;hyphens:none}.ag-chart-tooltip-wrap-hyphenate{overflow-wrap:break-word;word-break:break-word;hyphens:auto}.ag-chart-tooltip-wrap-on-space{overflow-wrap:normal;word-break:normal}.ag-chart-tooltip-wrap-never{white-space:pre;text-overflow:ellipsis}.ag-chart-tooltip-no-interaction{pointer-events:none;user-select:none}.ag-chart-tooltip-no-animation{transition:none!important}.ag-chart-tooltip-hidden{visibility:hidden}.ag-chart-tooltip-title{overflow:hidden;position:relative;padding:8px 14px;border-top-left-radius:2px;border-top-right-radius:2px;color:#fff;background-color:#888;z-index:1;text-overflow:inherit}.ag-chart-tooltip-title:only-child{border-bottom-left-radius:2px;border-bottom-right-radius:2px}.ag-chart-tooltip-content{overflow:hidden;padding:6px 14px;line-height:1.7em;background:#fff;border-bottom-left-radius:2px;border-bottom-right-radius:2px;border:1px solid rgba(0,0,0,.15);text-overflow:inherit}.ag-chart-tooltip-arrow:before{content:\"\";position:absolute;top:100%;left:50%;transform:translate(-50%);border:5px solid #d9d9d9;border-left-color:transparent;border-right-color:transparent;border-bottom-color:transparent;width:0;height:0;margin:0 auto}.ag-chart-tooltip-arrow:after{content:\"\";position:absolute;top:calc(100% - 1px);left:50%;transform:translate(-50%);border:5px solid white;border-left-color:transparent;border-right-color:transparent;border-bottom-color:transparent;width:0;height:0;margin:0 auto}\\n';\n\n// packages/ag-charts-community/src/util/guardedElement.ts\nvar GuardedElement = class {\n  constructor(element2, topTabGuard, bottomTabGuard) {\n    this.element = element2;\n    this.topTabGuard = topTabGuard;\n    this.bottomTabGuard = bottomTabGuard;\n    this.destroyFns = [];\n    this.guardTabIndex = 0;\n    this.element.tabIndex = -1;\n    this.initEventListener(this.element, \"blur\", () => this.onBlur());\n    this.initEventListener(this.element, \"focus\", () => this.onFocus());\n    this.initEventListener(this.topTabGuard, \"focus\", (ev) => this.onTabStart(ev, this.topTabGuard));\n    this.initEventListener(this.bottomTabGuard, \"focus\", (ev) => this.onTabStart(ev, this.bottomTabGuard));\n  }\n  set tabIndex(index) {\n    if (index >= 0) {\n      this.guardTabIndex = index;\n    }\n    if (index > 0) {\n      this.topTabGuard.tabIndex = index;\n      this.bottomTabGuard.style.display = \"none\";\n    } else {\n      this.topTabGuard.tabIndex = index;\n      this.bottomTabGuard.tabIndex = index;\n    }\n  }\n  destroy() {\n    for (const fn of this.destroyFns)\n      fn();\n    this.destroyFns.length = 0;\n  }\n  initEventListener(elem, type, handler) {\n    elem.addEventListener(type, handler);\n    this.destroyFns.push(() => elem.removeEventListener(type, handler));\n  }\n  onBlur() {\n    if (this.element.tabIndex === -1) {\n      this.tabIndex = this.guardTabIndex;\n      this.guardTarget = void 0;\n      this.guessedDelta = void 0;\n    }\n  }\n  onFocus() {\n    if (this.element.tabIndex === -1) {\n      this.tabIndex = -1;\n    }\n  }\n  onTabStart(event, target) {\n    if (target.tabIndex > 0) {\n      this.guessedDelta = 0;\n      if (event.relatedTarget != null && \"tabIndex\" in event.relatedTarget) {\n        const prevTabIndex = Number(event.relatedTarget[\"tabIndex\"]);\n        if (!isNaN(prevTabIndex) && prevTabIndex > 0) {\n          this.guessedDelta = prevTabIndex < target.tabIndex ? 1 : -1;\n        }\n      }\n    }\n    this.guardTarget = target;\n    this.element.focus();\n  }\n  getBrowserFocusDelta() {\n    const { guessedDelta, guardTarget, topTabGuard, bottomTabGuard: botTabGuard } = this;\n    if (guessedDelta !== void 0)\n      return guessedDelta;\n    if (guardTarget === topTabGuard)\n      return 1;\n    if (guardTarget === botTabGuard)\n      return -1;\n    return 0;\n  }\n};\n\n// packages/ag-charts-community/src/util/sizeMonitor.ts\nvar SizeMonitor = class {\n  constructor() {\n    this.elements = /* @__PURE__ */ new Map();\n    this.documentReady = false;\n    this.queuedObserveRequests = [];\n    this.onLoad = () => {\n      this.documentReady = true;\n      this.queuedObserveRequests.forEach(([el, cb]) => this.observe(el, cb));\n      this.queuedObserveRequests = [];\n    };\n    if (typeof ResizeObserver === \"undefined\")\n      return;\n    this.resizeObserver = new ResizeObserver((entries) => {\n      for (const {\n        target,\n        contentRect: { width, height }\n      } of entries) {\n        const entry = this.elements.get(target);\n        this.checkSize(entry, target, width, height);\n      }\n    });\n    this.documentReady = getDocument(\"readyState\") === \"complete\";\n    if (!this.documentReady) {\n      getWindow()?.addEventListener(\"load\", this.onLoad);\n    }\n  }\n  destroy() {\n    getWindow()?.removeEventListener(\"load\", this.onLoad);\n    this.resizeObserver?.disconnect();\n    this.resizeObserver = null;\n  }\n  checkSize(entry, element2, width, height) {\n    if (!entry)\n      return;\n    if (width !== entry.size?.width || height !== entry.size?.height) {\n      entry.size = { width, height };\n      entry.cb(entry.size, element2);\n    }\n  }\n  // Only a single callback is supported.\n  observe(element2, cb) {\n    if (!this.documentReady) {\n      this.queuedObserveRequests.push([element2, cb]);\n      return;\n    }\n    if (this.elements.has(element2)) {\n      this.removeFromQueue(element2);\n    } else {\n      this.resizeObserver?.observe(element2);\n    }\n    const entry = { cb };\n    this.elements.set(element2, entry);\n    this.checkSize(entry, element2, element2.offsetWidth, element2.offsetHeight);\n  }\n  unobserve(element2) {\n    this.resizeObserver?.unobserve(element2);\n    this.elements.delete(element2);\n    this.removeFromQueue(element2);\n    if (!this.elements.size) {\n      this.destroy();\n    }\n  }\n  removeFromQueue(element2) {\n    this.queuedObserveRequests = this.queuedObserveRequests.filter(([el]) => el !== element2);\n  }\n};\n\n// packages/ag-charts-community/src/chart/dom/domLayout.html\nvar domLayout_default = '<div role=\"presentation\" class=\"ag-charts-wrapper ag-charts-styles\" data-ag-charts><div role=\"presentation\" class=\"ag-charts-canvas-center\"><div role=\"figure\" class=\"ag-charts-canvas-container\"><div role=\"presentation\" class=\"ag-charts-tab-guard\"></div><div role=\"presentation\" class=\"ag-charts-canvas\"></div><div role=\"presentation\" class=\"ag-charts-canvas-proxy\"></div><div role=\"presentation\" class=\"ag-charts-tab-guard\"></div><div role=\"presentation\" class=\"ag-charts-canvas-overlay\"></div></div></div></div>';\n\n// packages/ag-charts-community/src/chart/dom/domManager.ts\nvar CANVAS_CENTER_CLASS = \"canvas-center\";\nvar DOM_ELEMENT_CLASSES = [\"styles\", CANVAS_CENTER_CLASS, \"canvas\", \"canvas-proxy\", \"canvas-overlay\"];\nvar domElementConfig = /* @__PURE__ */ new Map([\n  [\"styles\", { childElementType: \"style\" }],\n  [\"canvas\", { childElementType: \"canvas\", eventTypes: [\"focus\", \"blur\"] }],\n  [\"canvas-proxy\", { childElementType: \"div\" }],\n  [\"canvas-overlay\", { childElementType: \"div\" }],\n  [CANVAS_CENTER_CLASS, { childElementType: \"div\" }]\n]);\nfunction setupObserver(element2, cb) {\n  if (typeof IntersectionObserver === \"undefined\")\n    return;\n  const observer = new IntersectionObserver(\n    (entries) => {\n      for (const entry of entries) {\n        if (entry.target === element2) {\n          cb(entry.intersectionRatio);\n        }\n      }\n    },\n    { root: element2 }\n  );\n  observer.observe(element2);\n  return observer;\n}\nvar NULL_DOMRECT = {\n  x: 0,\n  y: 0,\n  width: 0,\n  height: 0,\n  top: 0,\n  bottom: 0,\n  left: 0,\n  right: 0,\n  toJSON() {\n    return NULL_DOMRECT;\n  }\n};\nvar DOMManager = class extends BaseManager {\n  constructor(container) {\n    super();\n    this.styles = {};\n    this.container = void 0;\n    this.containerSize = void 0;\n    this.sizeMonitor = new SizeMonitor();\n    const templateEl = createElement(\"div\");\n    templateEl.innerHTML = domLayout_default;\n    this.element = templateEl.children.item(0);\n    this.rootElements = DOM_ELEMENT_CLASSES.reduce(\n      (r, c) => {\n        const cssClass = `ag-charts-${c}`;\n        const el = this.element.classList.contains(cssClass) ? this.element : this.element.querySelector(`.${cssClass}`);\n        if (!el)\n          throw new Error(`AG Charts - unable to find DOM element ${cssClass}`);\n        r[c] = { element: el, children: /* @__PURE__ */ new Map(), listeners: [] };\n        return r;\n      },\n      {}\n    );\n    let hidden = false;\n    this.observer = setupObserver(this.element, (intersectionRatio) => {\n      if (intersectionRatio === 0 && !hidden) {\n        this.listeners.dispatch(\"hidden\", { type: \"hidden\" });\n      }\n      hidden = intersectionRatio === 0;\n    });\n    this.setSizeOptions();\n    this.addStyles(\"ag-charts-community\", styles_default);\n    if (container) {\n      this.setContainer(container);\n    }\n  }\n  destroy() {\n    super.destroy();\n    this.observer?.unobserve(this.element);\n    if (this.container) {\n      this.sizeMonitor.unobserve(this.container);\n    }\n    Object.values(this.rootElements).forEach((el) => {\n      el.children.forEach((c) => c.remove());\n      el.element.remove();\n    });\n    this.guardedElement?.destroy();\n    this.element.remove();\n  }\n  setSizeOptions(minWidth = 300, minHeight = 300, optionsWidth, optionsHeight) {\n    const { style } = this.element;\n    style.width = `${optionsWidth ?? minWidth}px`;\n    style.height = `${optionsHeight ?? minHeight}px`;\n  }\n  updateContainerSize() {\n    const { style: centerStyle } = this.rootElements[CANVAS_CENTER_CLASS].element;\n    centerStyle.width = `${this.containerSize?.width ?? 0}px`;\n    centerStyle.height = `${this.containerSize?.height ?? 0}px`;\n  }\n  setContainer(newContainer) {\n    if (newContainer === this.container)\n      return;\n    if (this.container) {\n      this.container.removeChild(this.element);\n      this.sizeMonitor.unobserve(this.container);\n    }\n    const isShadowDom = this.getDocumentRoot(newContainer) != null;\n    if (!isShadowDom) {\n      for (const id of this.rootElements[\"styles\"].children.keys()) {\n        this.removeChild(\"styles\", id);\n      }\n    }\n    newContainer.appendChild(this.element);\n    this.sizeMonitor.observe(newContainer, (size) => {\n      this.containerSize = size;\n      this.updateContainerSize();\n      this.listeners.dispatch(\"resize\", { type: \"resize\" });\n    });\n    this.container = newContainer;\n    for (const [id, styles] of Object.entries(this.styles)) {\n      this.addStyles(id, styles);\n    }\n    this.listeners.dispatch(\"container-changed\", { type: \"container-changed\" });\n  }\n  setThemeClass(themeClassName) {\n    const themeClassNamePrefix = \"ag-charts-theme-\";\n    this.element.classList.forEach((className) => {\n      if (className.startsWith(themeClassNamePrefix) && className !== themeClassName) {\n        this.element.classList.remove(className);\n      }\n    });\n    this.element.classList.add(themeClassName);\n  }\n  createTabGuards() {\n    const canvasElement = this.rootElements[\"canvas\"].element.querySelector(\"canvas\");\n    const tabGuards = this.element.querySelectorAll(\".ag-charts-tab-guard\");\n    if (canvasElement == null || tabGuards[0] == null || tabGuards[1] == null) {\n      throw new Error(\"AG Charts - error initialising canvas tab guards\");\n    }\n    return new GuardedElement(canvasElement, tabGuards[0], tabGuards[1]);\n  }\n  setTabIndex(tabIndex) {\n    this.guardedElement ?? (this.guardedElement = this.createTabGuards());\n    this.guardedElement.tabIndex = tabIndex;\n  }\n  getBrowserFocusDelta() {\n    return this.guardedElement?.getBrowserFocusDelta() ?? 0;\n  }\n  addEventListenerOnElement(elementType, type, listener, options) {\n    const { element: element2 } = this.rootElements[elementType];\n    element2.addEventListener(type, listener, options);\n    return () => {\n      element2.removeEventListener(type, listener, options);\n    };\n  }\n  addEventListener(type, listener, options) {\n    this.element.addEventListener(type, listener, options);\n    domElementConfig.forEach((config, elType) => {\n      if (!config.eventTypes?.includes(type))\n        return;\n      const els = this.rootElements[elType];\n      els.listeners.push([type, listener, options]);\n      els.children.forEach((el) => {\n        el.addEventListener(type, listener);\n      });\n    });\n  }\n  removeEventListener(type, listener, options) {\n    this.element.removeEventListener(type, listener, options);\n    domElementConfig.forEach((config, elType) => {\n      if (!config.eventTypes?.includes(type))\n        return;\n      const els = this.rootElements[elType];\n      els.listeners = els.listeners.filter(([t, l]) => t !== type && l !== listener);\n      els.children.forEach((el) => {\n        el.removeEventListener(type, listener, options);\n      });\n    });\n  }\n  /** Get the main chart area client bound rect. */\n  getBoundingClientRect() {\n    return this.rootElements[\"canvas\"].element.getBoundingClientRect();\n  }\n  /**\n   * Get the client bounding rect for overlay elements that might float outside the bounds of the\n   * main chart area.\n   */\n  getOverlayClientRect() {\n    const window2 = getWindow();\n    const windowBBox = new BBox(0, 0, window2.innerWidth, window2.innerHeight);\n    const container = this.getRawOverlayClientRect();\n    const containerBBox = BBox.fromDOMRect(container ?? this.getBoundingClientRect());\n    return windowBBox.intersection(containerBBox)?.toDOMRect() ?? NULL_DOMRECT;\n  }\n  getRawOverlayClientRect() {\n    let element2 = this.element;\n    while (element2 != null) {\n      const styleMap = element2.computedStyleMap?.();\n      const overflowX = styleMap?.get(\"overflow-x\")?.toString();\n      const overflowY = styleMap?.get(\"overflow-y\")?.toString();\n      if (overflowX != null && overflowX !== \"visible\" || overflowY && overflowY !== \"visible\") {\n        return element2.getBoundingClientRect();\n      }\n      element2 = element2.parentElement;\n    }\n    const docRoot = this.getDocumentRoot();\n    if (docRoot) {\n      return docRoot.getBoundingClientRect();\n    }\n  }\n  getDocumentRoot(current = this.container) {\n    const docRoot = current?.ownerDocument?.body ?? getDocument(\"body\");\n    while (current != null) {\n      if (current === docRoot) {\n        return void 0;\n      }\n      if (current.parentNode instanceof DocumentFragment) {\n        return current;\n      }\n      current = current.parentNode;\n    }\n    return void 0;\n  }\n  getChildBoundingClientRect(type) {\n    const { children } = this.rootElements[type];\n    const childRects = [];\n    for (const child of children.values()) {\n      childRects.push(BBox.fromDOMRect(child.getBoundingClientRect()));\n    }\n    return BBox.merge(childRects);\n  }\n  calculateCanvasPosition(el) {\n    let x = 0;\n    let y = 0;\n    const { x: cx = 0, y: cy = 0 } = this.getChildBoundingClientRect(\"canvas\") ?? {};\n    const elRect = el.getBoundingClientRect();\n    x = elRect.x - cx;\n    y = elRect.y - cy;\n    return { x, y };\n  }\n  isManagedChildDOMElement(el, domElementClass, id) {\n    const { children } = this.rootElements[domElementClass];\n    const search = children?.get(id);\n    return search != null && el.contains(search);\n  }\n  isEventOverElement(event) {\n    const element2 = event.target;\n    return element2 != null && this.element.contains(element2);\n  }\n  addStyles(id, styles) {\n    this.styles[id] = styles;\n    if (this.container == null)\n      return;\n    const dataAttribute = \"data-ag-charts\";\n    const documentRoot = this.getDocumentRoot();\n    let styleElement;\n    if (documentRoot != null) {\n      styleElement = this.addChild(\"styles\", id);\n    } else {\n      const head = getDocument(\"head\");\n      for (const child of head.children) {\n        if (child.getAttribute(dataAttribute) === id)\n          return;\n      }\n      styleElement = createElement(\"style\");\n      head.appendChild(styleElement);\n    }\n    if (styleElement.getAttribute(dataAttribute) === id) {\n      return;\n    }\n    styleElement.setAttribute(dataAttribute, id);\n    styleElement.innerHTML = styles;\n  }\n  removeStyles(id) {\n    this.removeChild(\"styles\", id);\n  }\n  updateCursor(style) {\n    this.element.style.cursor = style;\n  }\n  getCursor() {\n    return this.element.style.cursor;\n  }\n  addChild(domElementClass, id, child) {\n    const { element: element2, children, listeners } = this.rootElements[domElementClass];\n    if (!children) {\n      throw new Error(\"AG Charts - unable to create DOM elements after destroy()\");\n    }\n    const existing = children.get(id);\n    if (existing != null)\n      return existing;\n    const { childElementType = \"div\" } = domElementConfig.get(domElementClass) ?? {};\n    if (child && child.tagName.toLowerCase() !== childElementType.toLowerCase()) {\n      throw new Error(\"AG Charts - mismatching DOM element type\");\n    }\n    const newChild = child ?? createElement(childElementType);\n    for (const [type, fn, opts] of listeners) {\n      newChild.addEventListener(type, fn, opts);\n    }\n    children.set(id, newChild);\n    element2?.appendChild(newChild);\n    return newChild;\n  }\n  removeChild(domElementClass, id) {\n    const { children } = this.rootElements[domElementClass];\n    if (!children)\n      return;\n    children.get(id)?.remove();\n    children.delete(id);\n  }\n  incrementDataCounter(name) {\n    const { dataset } = this.element;\n    dataset[name] ?? (dataset[name] = \"0\");\n    dataset[name] = String(Number(dataset[name]) + 1);\n  }\n  getIconClassNames(icon) {\n    return `ag-charts-icon ag-charts-icon-${icon}`;\n  }\n};\n\n// packages/ag-charts-community/src/scene/polyRoots.ts\nfunction linearRoot(a, b) {\n  const t = -b / a;\n  return a !== 0 && t >= 0 && t <= 1 ? [t] : [];\n}\nfunction quadraticRoots(a, b, c) {\n  if (a === 0) {\n    return linearRoot(b, c);\n  }\n  const D = b * b - 4 * a * c;\n  const roots = [];\n  if (D === 0) {\n    const t = -b / (2 * a);\n    if (t >= 0 && t <= 1) {\n      roots.push(t);\n    }\n  } else if (D > 0) {\n    const rD = Math.sqrt(D);\n    const t1 = (-b - rD) / (2 * a);\n    const t2 = (-b + rD) / (2 * a);\n    if (t1 >= 0 && t1 <= 1) {\n      roots.push(t1);\n    }\n    if (t2 >= 0 && t2 <= 1) {\n      roots.push(t2);\n    }\n  }\n  return roots;\n}\nfunction cubicRoots(a, b, c, d) {\n  if (a === 0) {\n    return quadraticRoots(b, c, d);\n  }\n  const A = b / a;\n  const B = c / a;\n  const C = d / a;\n  const Q = (3 * B - A * A) / 9;\n  const R = (9 * A * B - 27 * C - 2 * A * A * A) / 54;\n  const D = Q * Q * Q + R * R;\n  const third = 1 / 3;\n  const roots = [];\n  if (D >= 0) {\n    const rD = Math.sqrt(D);\n    const S = Math.sign(R + rD) * Math.pow(Math.abs(R + rD), third);\n    const T = Math.sign(R - rD) * Math.pow(Math.abs(R - rD), third);\n    const Im = Math.abs(Math.sqrt(3) * (S - T) / 2);\n    const t = -third * A + (S + T);\n    if (t >= 0 && t <= 1) {\n      roots.push(t);\n    }\n    if (Im === 0) {\n      const t2 = -third * A - (S + T) / 2;\n      if (t2 >= 0 && t2 <= 1) {\n        roots.push(t2);\n      }\n    }\n  } else {\n    const theta = Math.acos(R / Math.sqrt(-Q * Q * Q));\n    const thirdA = third * A;\n    const twoSqrtQ = 2 * Math.sqrt(-Q);\n    const t1 = twoSqrtQ * Math.cos(third * theta) - thirdA;\n    const t2 = twoSqrtQ * Math.cos(third * (theta + 2 * Math.PI)) - thirdA;\n    const t3 = twoSqrtQ * Math.cos(third * (theta + 4 * Math.PI)) - thirdA;\n    if (t1 >= 0 && t1 <= 1) {\n      roots.push(t1);\n    }\n    if (t2 >= 0 && t2 <= 1) {\n      roots.push(t2);\n    }\n    if (t3 >= 0 && t3 <= 1) {\n      roots.push(t3);\n    }\n  }\n  return roots;\n}\n\n// packages/ag-charts-community/src/scene/intersection.ts\nfunction segmentIntersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n  const d = (ax2 - ax1) * (by2 - by1) - (ay2 - ay1) * (bx2 - bx1);\n  if (d === 0) {\n    return 0;\n  }\n  const ua = ((bx2 - bx1) * (ay1 - by1) - (ax1 - bx1) * (by2 - by1)) / d;\n  const ub = ((ax2 - ax1) * (ay1 - by1) - (ay2 - ay1) * (ax1 - bx1)) / d;\n  if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n    return 1;\n  }\n  return 0;\n}\nfunction cubicSegmentIntersections(px1, py1, px2, py2, px3, py3, px4, py4, x1, y1, x2, y2) {\n  let intersections = 0;\n  const A = y1 - y2;\n  const B = x2 - x1;\n  const C = x1 * (y2 - y1) - y1 * (x2 - x1);\n  const bx = bezierCoefficients(px1, px2, px3, px4);\n  const by = bezierCoefficients(py1, py2, py3, py4);\n  const a = A * bx[0] + B * by[0];\n  const b = A * bx[1] + B * by[1];\n  const c = A * bx[2] + B * by[2];\n  const d = A * bx[3] + B * by[3] + C;\n  const roots = cubicRoots(a, b, c, d);\n  for (const t of roots) {\n    const tt = t * t;\n    const ttt = t * tt;\n    const x = bx[0] * ttt + bx[1] * tt + bx[2] * t + bx[3];\n    const y = by[0] * ttt + by[1] * tt + by[2] * t + by[3];\n    let s;\n    if (x1 === x2) {\n      s = (y - y1) / (y2 - y1);\n    } else {\n      s = (x - x1) / (x2 - x1);\n    }\n    if (s >= 0 && s <= 1) {\n      intersections++;\n    }\n  }\n  return intersections;\n}\nfunction bezierCoefficients(P1, P2, P3, P4) {\n  return [\n    // Bzier expressed as matrix operations:\n    -P1 + 3 * P2 - 3 * P3 + P4,\n    //                 |-1  3 -3  1| |P1|\n    3 * P1 - 6 * P2 + 3 * P3,\n    //   [t^3 t^2 t 1] | 3 -6  3  0| |P2|\n    -3 * P1 + 3 * P2,\n    //                 |-3  3  0  0| |P3|\n    P1\n    //                 | 1  0  0  0| |P4|\n  ];\n}\nfunction arcIntersections(cx, cy, r, startAngle, endAngle, counterClockwise, x1, y1, x2, y2) {\n  if (isNaN(cx) || isNaN(cy)) {\n    return 0;\n  }\n  if (counterClockwise) {\n    [endAngle, startAngle] = [startAngle, endAngle];\n  }\n  const k = (y2 - y1) / (x2 - x1);\n  const y0 = y1 - k * x1;\n  const a = Math.pow(k, 2) + 1;\n  const b = 2 * (k * (y0 - cy) - cx);\n  const c = Math.pow(cx, 2) + Math.pow(y0 - cy, 2) - Math.pow(r, 2);\n  const d = Math.pow(b, 2) - 4 * a * c;\n  if (d < 0) {\n    return 0;\n  }\n  const i1x = (-b + Math.sqrt(d)) / 2 / a;\n  const i2x = (-b - Math.sqrt(d)) / 2 / a;\n  let intersections = 0;\n  [i1x, i2x].forEach((x) => {\n    const isXInsideLine = x >= Math.min(x1, x2) && x <= Math.max(x1, x2);\n    if (!isXInsideLine) {\n      return;\n    }\n    const y = k * x + y0;\n    const adjacent = x - cx;\n    const opposite = y - cy;\n    const angle2 = Math.atan2(opposite, adjacent);\n    if (isBetweenAngles(angle2, startAngle, endAngle)) {\n      intersections++;\n    }\n  });\n  return intersections;\n}\n\n// packages/ag-charts-community/src/scene/extendedPath2D.ts\nvar ExtendedPath2D = class {\n  constructor() {\n    // The methods of this class will likely be called many times per animation frame,\n    // and any allocation can trigger a GC cycle during animation, so we attempt\n    // to minimize the number of allocations.\n    this.path2d = new Path2D();\n    this.previousCommands = [];\n    this.previousParams = [];\n    this.previousClosedPath = false;\n    this.commands = [];\n    this.params = [];\n    this.openedPath = false;\n    this.closedPath = false;\n  }\n  isDirty() {\n    return this.closedPath !== this.previousClosedPath || this.previousCommands.length !== this.commands.length || this.previousParams.length !== this.params.length || this.previousCommands.toString() !== this.commands.toString() || this.previousParams.toString() !== this.params.toString();\n  }\n  getPath2D() {\n    return this.path2d;\n  }\n  moveTo(x, y) {\n    this.openedPath = true;\n    this.path2d.moveTo(x, y);\n    this.commands.push(0 /* Move */);\n    this.params.push(x, y);\n  }\n  lineTo(x, y) {\n    if (this.openedPath) {\n      this.path2d.lineTo(x, y);\n      this.commands.push(1 /* Line */);\n      this.params.push(x, y);\n    } else {\n      this.moveTo(x, y);\n    }\n  }\n  rect(x, y, width, height) {\n    this.moveTo(x, y);\n    this.lineTo(x + width, y);\n    this.lineTo(x + width, y + height);\n    this.lineTo(x, y + height);\n    this.closePath();\n  }\n  roundRect(x, y, width, height, radii) {\n    radii = Math.min(radii, width / 2, height / 2);\n    this.moveTo(x, y + radii);\n    this.arc(x + radii, y + radii, radii, Math.PI, 1.5 * Math.PI);\n    this.lineTo(x + radii, y);\n    this.lineTo(x + width - radii, y);\n    this.arc(x + width - radii, y + radii, radii, 1.5 * Math.PI, 2 * Math.PI);\n    this.lineTo(x + width, y + radii);\n    this.lineTo(x + width, y + height - radii);\n    this.arc(x + width - radii, y + height - radii, radii, 0, Math.PI / 2);\n    this.lineTo(x + width - radii, y + height);\n    this.lineTo(x + radii, y + height);\n    this.arc(x + +radii, y + height - radii, radii, Math.PI / 2, Math.PI);\n    this.lineTo(x, y + height - radii);\n    this.closePath();\n  }\n  arc(x, y, r, sAngle, eAngle, counterClockwise) {\n    this.openedPath = true;\n    this.path2d.arc(x, y, r, sAngle, eAngle, counterClockwise);\n    this.commands.push(2 /* Arc */);\n    this.params.push(x, y, r, sAngle, eAngle, counterClockwise ? 1 : 0);\n  }\n  cubicCurveTo(cx1, cy1, cx2, cy2, x, y) {\n    if (!this.openedPath) {\n      this.moveTo(cx1, cy1);\n    }\n    this.path2d.bezierCurveTo(cx1, cy1, cx2, cy2, x, y);\n    this.commands.push(3 /* Curve */);\n    this.params.push(cx1, cy1, cx2, cy2, x, y);\n  }\n  closePath() {\n    if (this.openedPath) {\n      this.path2d.closePath();\n      this.commands.push(4 /* ClosePath */);\n      this.openedPath = false;\n      this.closedPath = true;\n    }\n  }\n  clear(trackChanges) {\n    if (trackChanges) {\n      this.previousCommands = this.commands;\n      this.previousParams = this.params;\n      this.previousClosedPath = this.closedPath;\n    }\n    this.path2d = new Path2D();\n    this.openedPath = false;\n    this.closedPath = false;\n    this.commands = [];\n    this.params = [];\n  }\n  isPointInPath(x, y) {\n    const commands = this.commands;\n    const params = this.params;\n    const cn = commands.length;\n    const ox = -1e4;\n    const oy = -1e4;\n    let sx = NaN;\n    let sy = NaN;\n    let px = 0;\n    let py = 0;\n    let intersectionCount = 0;\n    for (let ci = 0, pi = 0; ci < cn; ci++) {\n      switch (commands[ci]) {\n        case 0 /* Move */:\n          intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);\n          px = params[pi++];\n          sx = px;\n          py = params[pi++];\n          sy = py;\n          break;\n        case 1 /* Line */:\n          intersectionCount += segmentIntersection(px, py, params[pi++], params[pi++], ox, oy, x, y);\n          px = params[pi - 2];\n          py = params[pi - 1];\n          break;\n        case 3 /* Curve */:\n          intersectionCount += cubicSegmentIntersections(\n            px,\n            py,\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            ox,\n            oy,\n            x,\n            y\n          );\n          px = params[pi - 2];\n          py = params[pi - 1];\n          break;\n        case 2 /* Arc */:\n          const cx = params[pi++];\n          const cy = params[pi++];\n          const r = params[pi++];\n          const startAngle = params[pi++];\n          const endAngle = params[pi++];\n          const counterClockwise = Boolean(params[pi++]);\n          intersectionCount += arcIntersections(\n            cx,\n            cy,\n            r,\n            startAngle,\n            endAngle,\n            counterClockwise,\n            ox,\n            oy,\n            x,\n            y\n          );\n          if (!isNaN(sx)) {\n            const startX = cx + Math.cos(startAngle) * r;\n            const startY = cy + Math.sin(startAngle) * r;\n            intersectionCount += segmentIntersection(px, py, startX, startY, ox, oy, x, y);\n          }\n          px = cx + Math.cos(endAngle) * r;\n          py = cy + Math.sin(endAngle) * r;\n          break;\n        case 4 /* ClosePath */:\n          intersectionCount += segmentIntersection(sx, sy, px, py, ox, oy, x, y);\n          break;\n      }\n    }\n    return intersectionCount % 2 === 1;\n  }\n  distanceSquared(x, y) {\n    let best = Infinity;\n    const commands = this.commands;\n    const params = this.params;\n    const cn = commands.length;\n    let sx = NaN;\n    let sy = NaN;\n    let px = 0;\n    let py = 0;\n    for (let ci = 0, pi = 0; ci < cn; ci++) {\n      switch (commands[ci]) {\n        case 0 /* Move */:\n          px = sx = params[pi++];\n          py = sy = params[pi++];\n          break;\n        case 1 /* Line */: {\n          const nx = params[pi++];\n          const ny = params[pi++];\n          best = lineDistanceSquared(x, y, px, py, nx, ny, best);\n          break;\n        }\n        case 3 /* Curve */:\n          Logger.error(\"Command.Curve distanceSquare not implemented\");\n          break;\n        case 2 /* Arc */: {\n          const cx = params[pi++];\n          const cy = params[pi++];\n          const r = params[pi++];\n          const startAngle = params[pi++];\n          const endAngle = params[pi++];\n          const startX = cx + Math.cos(startAngle) * r;\n          const startY = cy + Math.sin(startAngle) * r;\n          const counterClockwise = Boolean(params[pi++]);\n          best = lineDistanceSquared(x, y, px, py, startX, startY, best);\n          best = arcDistanceSquared(x, y, cx, cy, r, startAngle, endAngle, counterClockwise, best);\n          px = cx + Math.cos(endAngle) * r;\n          py = cy + Math.sin(endAngle) * r;\n          break;\n        }\n        case 4 /* ClosePath */:\n          best = lineDistanceSquared(x, y, px, py, sx, sy, best);\n          break;\n      }\n    }\n    return best;\n  }\n  getPoints() {\n    const { commands, params } = this;\n    const coords = [];\n    let pi = 0;\n    for (let ci = 0; ci < commands.length; ci++) {\n      switch (commands[ci]) {\n        case 0 /* Move */:\n        case 1 /* Line */:\n          coords.push({ x: params[pi++], y: params[pi++] });\n          break;\n        case 3 /* Curve */:\n          pi += 4;\n          coords.push({ x: params[pi++], y: params[pi++] });\n          break;\n        case 2 /* Arc */:\n          coords.push({ x: params[pi++], y: params[pi++] });\n          pi += 4;\n          break;\n        case 4 /* ClosePath */:\n          break;\n      }\n    }\n    return coords;\n  }\n  // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d\n  computeSVGDataPath(ox, oy) {\n    const buffer = [];\n    const { commands, params } = this;\n    let pi = 0;\n    for (let ci = 0; ci < commands.length; ci++) {\n      switch (commands[ci]) {\n        case 0 /* Move */:\n          buffer.push(\"M\", ox + params[pi++], oy + params[pi++]);\n          break;\n        case 1 /* Line */:\n          buffer.push(\"L\", ox + params[pi++], oy + params[pi++]);\n          break;\n        case 3 /* Curve */:\n          buffer.push(\n            \"C\",\n            ox + params[pi++],\n            oy + params[pi++],\n            ox + params[pi++],\n            oy + params[pi++],\n            ox + params[pi++],\n            oy + params[pi++]\n          );\n          break;\n        case 2 /* Arc */:\n          const [cx, cy, r, a0, a1, ccw] = [\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++],\n            params[pi++]\n          ];\n          const x0 = ox + cx + Math.cos(a0) * r;\n          const y0 = oy + cy + Math.sin(a0) * r;\n          const x1 = ox + cx + Math.cos(a1) * r;\n          const y1 = oy + cy + Math.sin(a1) * r;\n          const largeArcFlag = angleDiff(a0, a1, !!ccw) > Math.PI ? 1 : 0;\n          const sweepFlag = (ccw + 1) % 2;\n          const move = buffer.length === 0 ? \"M\" : \"L\";\n          buffer.push(move, x0, y0, \"A\", r, r, 0, largeArcFlag, sweepFlag, x1, y1);\n          break;\n        case 4 /* ClosePath */:\n          buffer.push(\"Z\");\n          break;\n      }\n    }\n    return buffer.join(\" \");\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/path.ts\nfunction ScenePathChangeDetection(opts) {\n  const { redraw = 3 /* MAJOR */, changeCb, convertor } = opts ?? {};\n  return SceneChangeDetection({ redraw, type: \"path\", convertor, changeCb });\n}\nvar Path = class extends Shape {\n  constructor() {\n    super(...arguments);\n    /**\n     * Declare a path to retain for later rendering and hit testing\n     * using custom Path2D class. Think of it as a TypeScript version\n     * of the native Path2D (with some differences) that works in all browsers.\n     */\n    this.path = new ExtendedPath2D();\n    this._clipX = NaN;\n    this._clipY = NaN;\n    /**\n     * The path only has to be updated when certain attributes change.\n     * For example, if transform attributes (such as `translationX`)\n     * are changed, we don't have to update the path. The `dirtyPath` flag\n     * is how we keep track if the path has to be updated or not.\n     */\n    this._dirtyPath = true;\n  }\n  set clipX(value) {\n    this._clipX = value;\n    this.dirtyPath = true;\n  }\n  set clipY(value) {\n    this._clipY = value;\n    this.dirtyPath = true;\n  }\n  set dirtyPath(value) {\n    if (this._dirtyPath !== value) {\n      this._dirtyPath = value;\n      if (value) {\n        this.markDirty(this, 3 /* MAJOR */);\n      }\n    }\n  }\n  get dirtyPath() {\n    return this._dirtyPath;\n  }\n  checkPathDirty() {\n    if (this._dirtyPath) {\n      return;\n    }\n    this.dirtyPath = this.path.isDirty() || (this.fillShadow?.isDirty() ?? false) || (this._clipPath?.isDirty() ?? false);\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    return this.path.closedPath && this.path.isPointInPath(point.x, point.y);\n  }\n  distanceSquared(x, y) {\n    const point = this.transformPoint(x, y);\n    return this.distanceSquaredTransformedPoint(point.x, point.y);\n  }\n  computeSVGDataPath() {\n    const { x, y } = this.inverseTransformPoint(0, 0);\n    if (this.dirtyPath) {\n      this.updatePath();\n      this.dirtyPath = false;\n    }\n    return this.path.computeSVGDataPath(x, y);\n  }\n  distanceSquaredTransformedPoint(x, y) {\n    if (this.path.closedPath && this.path.isPointInPath(x, y)) {\n      return 0;\n    }\n    return this.path.distanceSquared(x, y);\n  }\n  isDirtyPath() {\n    return false;\n  }\n  updatePath() {\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    this.transformRenderContext(renderCtx);\n    if (this.dirtyPath || this.isDirtyPath()) {\n      this.updatePath();\n      this.dirtyPath = false;\n    }\n    if (!isNaN(this._clipX) && !isNaN(this._clipY) && this.clipMode != null) {\n      ctx.save();\n      const margin = this.strokeWidth / 2;\n      this._clipPath ?? (this._clipPath = new ExtendedPath2D());\n      this._clipPath.clear();\n      this._clipPath.rect(-margin, -margin, this._clipX + margin, this._clipY + margin + margin);\n      if (this.clipMode === \"normal\") {\n        ctx.clip(this._clipPath?.getPath2D());\n      }\n      if (this._clipX > 0 && this._clipY > 0) {\n        this.drawPath(ctx);\n      }\n      if (this.clipMode === \"punch-out\") {\n        ctx.clip(this._clipPath?.getPath2D());\n        const { x = -1e4, y = -1e4, width = 2e4, height = 2e4 } = this.getBBox() ?? {};\n        ctx.clearRect(x, y, width, height);\n      }\n      ctx.restore();\n    } else {\n      this.drawPath(ctx);\n    }\n    this.fillShadow?.markClean();\n    super.render(renderCtx);\n  }\n  drawPath(ctx) {\n    this.fillStroke(ctx, this.path.getPath2D());\n  }\n};\nPath.className = \"Path\";\n__decorateClass([\n  ScenePathChangeDetection()\n], Path.prototype, \"clipMode\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Path.prototype, \"clipX\", 1);\n__decorateClass([\n  ScenePathChangeDetection()\n], Path.prototype, \"clipY\", 1);\n\n// packages/ag-charts-community/src/chart/dom/focusStyles.ts\nvar focusStyles_exports = {};\n__export(focusStyles_exports, {\n  block: () => block,\n  elements: () => elements,\n  modifiers: () => modifiers\n});\nvar block = \"ag-charts-focus\";\nvar elements = { indicator: \"ag-charts-focus__indicator\", svg: \"ag-charts-focus__svg\" };\nvar modifiers = { hidden: \"ag-charts-focus--hidden\" };\n\n// packages/ag-charts-community/src/chart/dom/focusIndicator.ts\nvar FocusIndicator = class {\n  constructor(domManager) {\n    this.domManager = domManager;\n    const { block: block3, elements: elements3, modifiers: modifiers3 } = focusStyles_exports;\n    this.div = getDocument().createElement(\"div\");\n    this.svg = getDocument().createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    this.path = getDocument().createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n    this.svg.append(this.path);\n    this.element = domManager.addChild(\"canvas-overlay\", block3);\n    this.element.classList.add(block3, elements3.indicator, modifiers3.hidden);\n    this.element.ariaHidden = \"true\";\n    this.element.append(this.svg);\n  }\n  destroy() {\n    this.domManager.removeStyles(block);\n    this.domManager.removeChild(\"canvas-overlay\", block);\n  }\n  updateBounds(bounds) {\n    if (bounds === void 0) {\n      this.element.classList.add(modifiers.hidden);\n    } else if (bounds instanceof Path) {\n      this.path.setAttribute(\"d\", bounds.computeSVGDataPath());\n      this.show(this.svg);\n    } else {\n      setElementBBox(this.div, bounds);\n      this.show(this.div);\n    }\n  }\n  show(child) {\n    this.element.classList.remove(modifiers.hidden);\n    this.element.innerHTML = \"\";\n    this.element.append(child);\n  }\n};\n\n// packages/ag-charts-community/src/chart/dom/boundedText.ts\nvar BoundedText = class {\n  set textContent(text) {\n    this.textElement.textContent = text;\n    const bboxCalculator = this.textElement;\n    const bbox = bboxCalculator.getBBox?.();\n    if (bbox) {\n      this.svgElement.setAttribute(\"viewBox\", `${bbox.x} ${bbox.y} ${bbox.width} ${bbox.height}`);\n    }\n  }\n  get textContent() {\n    return this.textElement.textContent;\n  }\n  constructor() {\n    this.textElement = createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\n    this.textElement.role = \"presentation\";\n    this.svgElement = createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n    this.svgElement.appendChild(this.textElement);\n    this.svgElement.style.width = \"100%\";\n    this.svgElement.style.opacity = \"0\";\n    this.svgElement.role = \"presentation\";\n    this.boundedContainer = createElement(\"div\");\n    this.boundedContainer.appendChild(this.svgElement);\n    this.boundedContainer.role = \"presentation\";\n  }\n  remove() {\n    this.boundedContainer.remove();\n  }\n  getContainer() {\n    return this.boundedContainer;\n  }\n  updateBounds(bounds) {\n    setElementBBox(this.boundedContainer, bounds);\n  }\n};\n\n// packages/ag-charts-community/src/chart/dom/proxyInteractionService.ts\nfunction checkType(type, meta) {\n  return meta.params?.type === type;\n}\nfunction allocateResult(type) {\n  if (\"button\" === type) {\n    return createElement(\"button\");\n  } else if (\"slider\" === type) {\n    return createElement(\"input\");\n  } else if (\"toolbar\" === type || \"group\" === type) {\n    return createElement(\"div\");\n  } else if (\"text\" === type) {\n    return new BoundedText();\n  } else {\n    throw Error(\"AG Charts - error allocating meta\");\n  }\n}\nfunction allocateMeta(params) {\n  const meta = { params, result: void 0 };\n  meta.result = allocateResult(meta.params.type);\n  return meta;\n}\nvar ProxyInteractionService = class {\n  constructor(updateService, localeManager, domManager, focusIndicator) {\n    this.localeManager = localeManager;\n    this.domManager = domManager;\n    this.focusIndicator = focusIndicator;\n    // This debug option make the proxies button partially transparent instead of fully transparent.\n    // To enabled this option, set window.agChartsDebug = ['showDOMProxies'].\n    this.debugShowDOMProxies = Debug.check(\"showDOMProxies\");\n    this.destroyFns = [];\n    this.destroyFns.push(updateService.addListener(\"update-complete\", () => this.update()));\n  }\n  destroy() {\n    this.destroyFns.forEach((fn) => fn());\n  }\n  update() {\n    if (this.focusable) {\n      this.focusIndicator.updateBounds(this.focusable.computeTransformedBBox());\n    }\n  }\n  addLocalisation(fn) {\n    fn();\n    this.destroyFns.push(this.localeManager.addListener(\"locale-changed\", fn));\n  }\n  createProxyContainer(args) {\n    const meta = allocateMeta(args);\n    const { params, result: div } = meta;\n    this.domManager.addChild(\"canvas-overlay\", params.id, div);\n    div.classList.add(...params.classList);\n    div.style.pointerEvents = \"none\";\n    div.role = params.type;\n    div.ariaOrientation = params.ariaOrientation;\n    if (typeof params.ariaHidden === \"boolean\") {\n      div.ariaHidden = params.ariaHidden.toString();\n    }\n    this.addLocalisation(() => {\n      div.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);\n    });\n    return div;\n  }\n  createProxyElement(args) {\n    const meta = allocateMeta(args);\n    if (checkType(\"button\", meta)) {\n      const { params, result: button } = meta;\n      this.initInteract(params, button);\n      if (typeof params.textContent === \"string\") {\n        button.textContent = params.textContent;\n      } else {\n        const { textContent } = params;\n        this.addLocalisation(() => {\n          button.textContent = this.localeManager.t(textContent.id, textContent.params);\n        });\n      }\n    }\n    if (checkType(\"slider\", meta)) {\n      const { params, result: slider } = meta;\n      this.initInteract(params, slider);\n      slider.type = \"range\";\n      slider.role = \"presentation\";\n      slider.style.margin = \"0px\";\n      slider.ariaOrientation = params.ariaOrientation;\n      this.addLocalisation(() => {\n        slider.ariaLabel = this.localeManager.t(params.ariaLabel.id, params.ariaLabel.params);\n      });\n    }\n    if (checkType(\"text\", meta)) {\n      const { params, result: text } = meta;\n      this.initElement(params, text.getContainer());\n    }\n    return meta.result;\n  }\n  initElement(params, element2) {\n    const { id, parent } = params;\n    element2.id = id;\n    element2.style.pointerEvents = \"none\";\n    element2.style.opacity = this.debugShowDOMProxies ? \"0.25\" : \"0\";\n    element2.style.position = \"absolute\";\n    element2.style.overflow = \"hidden\";\n    if (typeof parent === \"string\") {\n      this.domManager.addChild(parent, id, element2);\n    } else {\n      parent.appendChild(element2);\n    }\n  }\n  initInteract(params, element2) {\n    const { focusable, onclick, onchange, onfocus, onblur, tabIndex } = params;\n    this.initElement(params, element2);\n    if (tabIndex !== void 0) {\n      element2.tabIndex = tabIndex;\n    }\n    element2.addEventListener(\"focus\", (_event) => {\n      this.focusable = focusable;\n      element2.style.setProperty(\"pointerEvents\", null);\n      this.focusIndicator.updateBounds(focusable.computeTransformedBBox());\n    });\n    element2.addEventListener(\"blur\", (_event) => {\n      this.focusable = void 0;\n      element2.style.pointerEvents = \"none\";\n      this.focusIndicator.updateBounds(void 0);\n    });\n    if (onclick) {\n      element2.addEventListener(\"click\", onclick);\n    }\n    if (onfocus) {\n      element2.addEventListener(\"focus\", onfocus);\n    }\n    if (onblur) {\n      element2.addEventListener(\"blur\", onblur);\n    }\n    if (onchange) {\n      element2.addEventListener(\"change\", onchange);\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/animationBatch.ts\nvar AnimationBatch = class {\n  constructor(maxAnimationTime) {\n    this.maxAnimationTime = maxAnimationTime;\n    this.debug = Debug.create(true, \"animation\");\n    this.controllers = /* @__PURE__ */ new Map();\n    this.stoppedCbs = /* @__PURE__ */ new Set();\n    this.currentPhase = 0;\n    this.phases = new Map(PHASE_ORDER.map((p) => [p, []]));\n    this.skipAnimations = false;\n    this.animationTimeConsumed = 0;\n    /** Guard against premature animation execution. */\n    this.isReady = false;\n  }\n  get size() {\n    return this.controllers.size;\n  }\n  get consumedTimeMs() {\n    return this.animationTimeConsumed;\n  }\n  isActive() {\n    return this.controllers.size > 0;\n  }\n  getActiveControllers() {\n    return this.phases.get(PHASE_ORDER[this.currentPhase]) ?? [];\n  }\n  checkOverlappingId(id) {\n    if (id != null && this.controllers.has(id)) {\n      this.controllers.get(id).stop();\n      this.debug(`Skipping animation batch due to update of existing animation: ${id}`);\n      this.skip();\n    }\n  }\n  addAnimation(animation) {\n    if (animation.isComplete)\n      return;\n    const animationPhaseIdx = PHASE_ORDER.indexOf(animation.phase);\n    if (animationPhaseIdx < this.currentPhase) {\n      this.debug(`Skipping animation due to being for an earlier phase`, animation.id);\n      animation.stop();\n      return;\n    }\n    this.controllers.set(animation.id, animation);\n    this.phases.get(animation.phase)?.push(animation);\n  }\n  removeAnimation(animation) {\n    this.controllers.delete(animation.id);\n    const phase = this.phases.get(animation.phase);\n    const index = phase?.indexOf(animation);\n    if (index != null && index >= 0) {\n      phase?.splice(index, 1);\n    }\n  }\n  progress(deltaTime) {\n    if (!this.isReady)\n      return;\n    let unusedTime = deltaTime === 0 ? 0.01 : deltaTime;\n    const refresh = () => {\n      const phase2 = PHASE_ORDER[this.currentPhase];\n      return {\n        phaseControllers: [...this.getActiveControllers()],\n        phase: phase2,\n        phaseMeta: PHASE_METADATA[phase2]\n      };\n    };\n    let { phase, phaseControllers, phaseMeta } = refresh();\n    const arePhasesComplete = () => PHASE_ORDER[this.currentPhase] == null;\n    const progressPhase = () => {\n      ({ phase, phaseControllers, phaseMeta } = refresh());\n      while (!arePhasesComplete() && phaseControllers.length === 0) {\n        this.currentPhase++;\n        ({ phase, phaseControllers, phaseMeta } = refresh());\n        this.debug(`AnimationBatch - phase changing to ${phase}`, { unusedTime }, phaseControllers);\n      }\n    };\n    const total = this.controllers.size;\n    this.debug(`AnimationBatch - ${deltaTime}ms; phase ${phase} with ${phaseControllers?.length} of ${total}`);\n    do {\n      const phaseDeltaTime = unusedTime;\n      const skipPhase = phaseMeta.skipIfNoEarlierAnimations && this.animationTimeConsumed === 0;\n      let completeCount = 0;\n      for (const controller of phaseControllers) {\n        if (skipPhase) {\n          controller.stop();\n        } else {\n          unusedTime = Math.min(controller.update(phaseDeltaTime), unusedTime);\n        }\n        if (controller.isComplete) {\n          completeCount++;\n          this.removeAnimation(controller);\n        }\n      }\n      this.animationTimeConsumed += phaseDeltaTime - unusedTime;\n      this.debug(`AnimationBatch - updated ${phaseControllers.length} controllers; ${completeCount} completed`);\n      this.debug(`AnimationBatch - animationTimeConsumed: ${this.animationTimeConsumed}`);\n      progressPhase();\n    } while (unusedTime > 0 && !arePhasesComplete());\n    if (this.animationTimeConsumed > this.maxAnimationTime) {\n      Logger.warnOnce(\n        \"Animation batch exceeded max animation time, skipping.\",\n        new Map(this.controllers.entries())\n      );\n      this.stop();\n    }\n  }\n  ready() {\n    if (this.isReady)\n      return;\n    this.isReady = true;\n    this.debug(`AnimationBatch - ready; skipped: ${this.skipAnimations}`, [...this.controllers]);\n    let skipAll = true;\n    for (const [, controller] of this.controllers) {\n      if (controller.duration > 0 && PHASE_METADATA[controller.phase].skipIfNoEarlierAnimations !== true) {\n        skipAll = false;\n        break;\n      }\n    }\n    if (!skipAll) {\n      for (const [, controller] of this.controllers) {\n        if (controller.autoplay) {\n          controller.play(true);\n        }\n      }\n    }\n  }\n  skip(skip = true) {\n    if (this.skipAnimations === false && skip === true) {\n      for (const controller of this.controllers.values()) {\n        controller.stop();\n      }\n      this.controllers.clear();\n    }\n    this.skipAnimations = skip;\n  }\n  play() {\n    for (const controller of this.controllers.values()) {\n      controller.play();\n    }\n  }\n  pause() {\n    for (const controller of this.controllers.values()) {\n      controller.pause();\n    }\n  }\n  stop() {\n    for (const controller of this.controllers.values()) {\n      try {\n        controller.stop();\n        this.removeAnimation(controller);\n      } catch (error) {\n        Logger.error(\"Error during animation stop\", error);\n      }\n    }\n    this.dispatchStopped();\n  }\n  stopByAnimationId(id) {\n    if (id != null && this.controllers.has(id)) {\n      const controller = this.controllers.get(id);\n      if (controller) {\n        controller.stop();\n        this.removeAnimation(controller);\n      }\n    }\n  }\n  stopByAnimationGroupId(id) {\n    for (const controller of this.controllers.values()) {\n      if (controller.groupId === id) {\n        this.stopByAnimationId(controller.id);\n      }\n    }\n  }\n  dispatchStopped() {\n    this.stoppedCbs.forEach((cb) => cb());\n    this.stoppedCbs.clear();\n  }\n  isSkipped() {\n    return this.skipAnimations;\n  }\n  destroy() {\n    this.stop();\n    this.controllers.clear();\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/preventableEvent.ts\nfunction buildPreventable(obj) {\n  const self = {\n    ...obj,\n    preventDefault() {\n      self.sourceEvent?.preventDefault();\n    }\n  };\n  return self;\n}\nfunction dispatchTypedEvent(listeners, event) {\n  listeners.dispatchWrapHandlers(event.type, (handler, e) => handler(e), buildPreventable(event));\n}\n\n// packages/ag-charts-community/src/chart/interaction/interactionManager.ts\nvar POINTER_INTERACTION_TYPES = [\n  \"click\",\n  \"dblclick\",\n  \"contextmenu\",\n  \"hover\",\n  \"drag-start\",\n  \"drag\",\n  \"drag-end\",\n  \"leave\",\n  \"enter\",\n  \"page-left\",\n  \"wheel\"\n];\nvar FOCUS_INTERACTION_TYPES = [\"blur\", \"focus\"];\nvar KEY_INTERACTION_TYPES = [\"keydown\", \"keyup\"];\nvar SHADOW_DOM_HANDLERS = [\"mousemove\", \"mouseup\"];\nvar WINDOW_EVENT_HANDLERS = [\"pagehide\", \"mousemove\", \"mouseup\"];\nvar EVENT_HANDLERS = [\n  \"click\",\n  \"dblclick\",\n  \"contextmenu\",\n  \"mousedown\",\n  \"mouseleave\",\n  \"mouseenter\",\n  \"touchstart\",\n  \"touchmove\",\n  \"touchend\",\n  \"touchcancel\",\n  \"wheel\",\n  \"blur\",\n  \"focus\",\n  \"keydown\",\n  \"keyup\"\n];\nvar InteractionState = /* @__PURE__ */ ((InteractionState2) => {\n  InteractionState2[InteractionState2[\"Default\"] = 16] = \"Default\";\n  InteractionState2[InteractionState2[\"ZoomDrag\"] = 8] = \"ZoomDrag\";\n  InteractionState2[InteractionState2[\"Annotations\"] = 4] = \"Annotations\";\n  InteractionState2[InteractionState2[\"ContextMenu\"] = 2] = \"ContextMenu\";\n  InteractionState2[InteractionState2[\"Animation\"] = 1] = \"Animation\";\n  InteractionState2[InteractionState2[\"All\"] = 31] = \"All\";\n  return InteractionState2;\n})(InteractionState || {});\nvar PointerCapture = /* @__PURE__ */ ((PointerCapture2) => {\n  PointerCapture2[\"Retain\"] = \"retain\";\n  PointerCapture2[\"Exclusive\"] = \"exclusive\";\n  return PointerCapture2;\n})(PointerCapture || {});\nvar pointerCaptures = new Set(Object.values(PointerCapture));\nfunction isPointerEvent(type) {\n  return POINTER_INTERACTION_TYPES.includes(type);\n}\nfunction isFocusEvent(type) {\n  return FOCUS_INTERACTION_TYPES.includes(type);\n}\nfunction isKeyEvent(type) {\n  return KEY_INTERACTION_TYPES.includes(type);\n}\nvar _InteractionManager = class _InteractionManager extends BaseManager {\n  constructor(keyboardOptions, domManager) {\n    super();\n    this.keyboardOptions = keyboardOptions;\n    this.domManager = domManager;\n    this.debug = Debug.create(true, \"interaction\");\n    this.eventHandler = (event) => this.processEvent(event);\n    this.overlayEventHandler = (event) => this.processCanvasOverlayEvent(event);\n    this.mouseDown = false;\n    this.touchDown = false;\n    this.pointerCaptureCanvasElement = void 0;\n    this.clickHistory = [{ offsetX: NaN, offsetY: NaN, type: \"mousedown\" }];\n    this.dblclickHistory = [\n      { offsetX: NaN, offsetY: NaN, type: \"mousedown\" },\n      { offsetX: NaN, offsetY: NaN, type: \"mouseup\" },\n      { offsetX: NaN, offsetY: NaN, type: \"mousedown\" }\n    ];\n    this.stateQueue = 16 /* Default */ | 1 /* Animation */;\n    this.rootElement = this.domManager.getDocumentRoot();\n    for (const type of EVENT_HANDLERS) {\n      if (type.startsWith(\"touch\") || type === \"wheel\") {\n        this.domManager.addEventListener(type, this.eventHandler, { passive: false });\n      } else {\n        this.domManager.addEventListener(type, this.eventHandler);\n      }\n    }\n    for (const type of WINDOW_EVENT_HANDLERS) {\n      getWindow().addEventListener(type, this.eventHandler);\n    }\n    this.destroyFns.push(\n      this.domManager.addEventListenerOnElement(\"canvas-overlay\", \"mouseover\", this.overlayEventHandler),\n      this.domManager.addEventListenerOnElement(\"canvas-overlay\", \"mouseout\", this.overlayEventHandler)\n    );\n    this.containerChanged(true);\n    this.domManager.addListener(\"container-changed\", () => this.containerChanged());\n  }\n  containerChanged(force = false) {\n    const newRoot = this.domManager.getDocumentRoot();\n    if (!force && newRoot === this.rootElement)\n      return;\n    for (const type of SHADOW_DOM_HANDLERS) {\n      this.rootElement?.removeEventListener(type, this.eventHandler);\n    }\n    this.rootElement = newRoot;\n    this.debug(\"[InteractionManager] Switching rootElement to:\", this.rootElement);\n    for (const type of SHADOW_DOM_HANDLERS) {\n      this.rootElement?.addEventListener(type, this.eventHandler);\n    }\n  }\n  destroy() {\n    super.destroy();\n    for (const type of WINDOW_EVENT_HANDLERS) {\n      getWindow().removeEventListener(type, this.eventHandler);\n    }\n    for (const type of SHADOW_DOM_HANDLERS) {\n      this.rootElement?.removeEventListener(type, this.eventHandler);\n    }\n    for (const type of EVENT_HANDLERS) {\n      this.domManager.removeEventListener(type, this.eventHandler);\n    }\n    this.domManager.removeStyles(\"interactionManager\");\n  }\n  // Wrapper to only broadcast events when the InteractionManager is a given state.\n  addListener(type, handler, triggeringStates = 16 /* Default */) {\n    return super.addListener(type, (e) => {\n      const currentState = this.getState();\n      if (currentState & triggeringStates) {\n        handler(e);\n      }\n    });\n  }\n  pushState(state) {\n    this.stateQueue |= state;\n  }\n  popState(state) {\n    this.stateQueue &= ~state;\n  }\n  getState() {\n    return this.stateQueue & -this.stateQueue;\n  }\n  processCanvasOverlayEvent(event) {\n    const coords = this.calculateCoordinates(event);\n    if (coords == null)\n      return;\n    let target = event.target;\n    let pointerCapture = null;\n    while (target != null) {\n      pointerCapture = target.getAttribute(\"data-pointer-capture\");\n      if (pointerCapture == null) {\n        target = target.parentElement;\n      } else {\n        break;\n      }\n    }\n    if (target == null || pointerCapture == null || !pointerCaptures.has(pointerCapture))\n      return;\n    const isOverCanvasOverlay = event.type === \"mouseover\";\n    const pointerCaptureCanvasElement = isOverCanvasOverlay ? target : void 0;\n    if (this.pointerCaptureCanvasElement === pointerCaptureCanvasElement)\n      return;\n    this.pointerCaptureCanvasElement = pointerCaptureCanvasElement;\n    if (pointerCapture === \"exclusive\" /* Exclusive */) {\n      dispatchTypedEvent(\n        this.listeners,\n        this.buildPointerEvent({ type: isOverCanvasOverlay ? \"leave\" : \"enter\", event, ...coords })\n      );\n    }\n  }\n  processEvent(event) {\n    const type = this.decideInteractionEventTypes(event);\n    const target = event.target;\n    if (event.type === \"click\" && target?.ariaDisabled === \"true\") {\n      event.preventDefault();\n      return;\n    }\n    if (type != null) {\n      this.dispatchEvent(event, type).catch((e) => Logger.errorOnce(e));\n    }\n  }\n  async dispatchEvent(event, type) {\n    if (isPointerEvent(type)) {\n      this.dispatchPointerEvent(event, type);\n      return;\n    }\n    const { relatedElement, targetElement } = this.extractElements(event);\n    if (isFocusEvent(type)) {\n      const sourceEvent = event;\n      dispatchTypedEvent(this.listeners, { type, sourceEvent, relatedElement, targetElement });\n    } else if (isKeyEvent(type)) {\n      const sourceEvent = event;\n      dispatchTypedEvent(this.listeners, { type, sourceEvent, relatedElement, targetElement });\n    }\n  }\n  extractElements(event) {\n    let relatedElement;\n    let targetElement;\n    if (\"relatedTarget\" in event && event[\"relatedTarget\"] instanceof HTMLElement) {\n      relatedElement = event[\"relatedTarget\"];\n    }\n    if (\"target\" in event && event[\"target\"] instanceof HTMLElement) {\n      targetElement = event[\"target\"];\n    }\n    return { relatedElement, targetElement };\n  }\n  dispatchPointerEvent(event, type) {\n    const coords = this.calculateCoordinates(event);\n    if (coords == null)\n      return;\n    dispatchTypedEvent(this.listeners, this.buildPointerEvent({ type, event, ...coords }));\n  }\n  getEventHTMLTarget(event) {\n    if (event.target instanceof HTMLElement) {\n      return event.target;\n    } else if (event.currentTarget instanceof HTMLElement) {\n      return event.currentTarget;\n    }\n    return void 0;\n  }\n  recordDown(event) {\n    if (event instanceof MouseEvent) {\n      partialAssign([\"offsetX\", \"offsetY\"], this.clickHistory[0], event);\n      partialAssign([\"offsetX\", \"offsetY\"], this.dblclickHistory[2], this.dblclickHistory[0]);\n      partialAssign([\"offsetX\", \"offsetY\"], this.dblclickHistory[0], event);\n    }\n    this.dragStartElement = this.getEventHTMLTarget(event);\n  }\n  recordUp(event) {\n    if (event instanceof MouseEvent) {\n      partialAssign([\"offsetX\", \"offsetY\"], this.dblclickHistory[1], event);\n    }\n    this.dragStartElement = void 0;\n  }\n  decideInteractionEventTypes(event) {\n    const dragStart = \"drag-start\";\n    if (this.pointerCaptureCanvasElement?.isConnected === false) {\n      this.pointerCaptureCanvasElement = void 0;\n    }\n    if (this.pointerCaptureCanvasElement != null) {\n      return;\n    }\n    switch (event.type) {\n      case \"blur\":\n      case \"focus\":\n      case \"keydown\":\n      case \"keyup\":\n        return this.keyboardOptions.enabled ? event.type : void 0;\n      case \"click\":\n      case \"dblclick\":\n      case \"contextmenu\":\n      case \"wheel\":\n        return event.type;\n      case \"mousedown\":\n        if (!this.isEventOverElement(event)) {\n          return;\n        }\n        this.mouseDown = true;\n        this.recordDown(event);\n        return dragStart;\n      case \"touchstart\":\n        if (!this.isEventOverElement(event)) {\n          return;\n        }\n        this.touchDown = true;\n        this.recordDown(event);\n        return dragStart;\n      case \"touchmove\":\n      case \"mousemove\":\n        if (!this.mouseDown && !this.touchDown && !this.isEventOverElement(event)) {\n          return;\n        }\n        return this.mouseDown || this.touchDown ? \"drag\" : \"hover\";\n      case \"mouseup\":\n        if (!this.mouseDown && !this.isEventOverElement(event)) {\n          return;\n        }\n        this.mouseDown = false;\n        this.recordUp(event);\n        return \"drag-end\";\n      case \"touchend\":\n        if (!this.touchDown && !this.isEventOverElement(event)) {\n          return;\n        }\n        this.touchDown = false;\n        this.recordUp(event);\n        return \"drag-end\";\n      case \"mouseleave\":\n      case \"touchcancel\":\n        return \"leave\";\n      case \"mouseenter\":\n        return \"enter\";\n      case \"pagehide\":\n        return \"page-left\";\n    }\n  }\n  isEventOverElement(event) {\n    return this.domManager.isEventOverElement(event);\n  }\n  calculateCoordinates(event) {\n    if (event instanceof MouseEvent) {\n      return this.getMouseEventCoords(event);\n    } else if (typeof TouchEvent !== \"undefined\" && event instanceof TouchEvent) {\n      const lastTouch = event.touches[0] ?? event.changedTouches[0];\n      const { clientX, clientY, pageX, pageY } = lastTouch;\n      return { ..._InteractionManager.NULL_COORDS, clientX, clientY, pageX, pageY };\n    } else if (event instanceof PageTransitionEvent) {\n      if (event.persisted) {\n        return;\n      }\n      return _InteractionManager.NULL_COORDS;\n    }\n  }\n  getMouseEventCoords(event) {\n    const { clientX, clientY, pageX, pageY } = event;\n    let { offsetX, offsetY } = event;\n    const target = this.getEventHTMLTarget(event);\n    const { x = 0, y = 0 } = target ? this.domManager.calculateCanvasPosition(target) : {};\n    if (this.dragStartElement != null && event.target !== this.dragStartElement) {\n      const offsetDragStart = this.domManager.calculateCanvasPosition(this.dragStartElement);\n      offsetX -= offsetDragStart.x - x;\n      offsetY -= offsetDragStart.y - y;\n    } else {\n      offsetX += x;\n      offsetY += y;\n    }\n    return { clientX, clientY, pageX, pageY, offsetX, offsetY };\n  }\n  isWheelEvent(event) {\n    return event.type === \"wheel\";\n  }\n  buildPointerEvent(opts) {\n    const { type, event, clientX, clientY } = opts;\n    let { offsetX, offsetY, pageX, pageY } = opts;\n    if (!isFiniteNumber(offsetX) || !isFiniteNumber(offsetY)) {\n      const rect = this.domManager.getBoundingClientRect();\n      offsetX = clientX - rect.left;\n      offsetY = clientY - rect.top;\n    }\n    if (!isFiniteNumber(pageX) || !isFiniteNumber(pageY)) {\n      const pageRect = this.rootElement?.getBoundingClientRect();\n      pageX = clientX - (pageRect?.left ?? 0);\n      pageY = clientY - (pageRect?.top ?? 0);\n    }\n    let [deltaX, deltaY] = [NaN, NaN];\n    if (this.isWheelEvent(event)) {\n      const factor = event.deltaMode === 0 ? 0.01 : 1;\n      deltaX = event.deltaX * factor;\n      deltaY = event.deltaY * factor;\n    }\n    let pointerHistory = [];\n    if (event.type === \"click\") {\n      pointerHistory = this.clickHistory;\n    } else if (event.type === \"dblclick\") {\n      pointerHistory = this.dblclickHistory;\n    }\n    const { relatedElement, targetElement } = this.extractElements(event);\n    const button = \"button\" in event ? Number(event.button) : 0;\n    const builtEvent = {\n      type,\n      offsetX,\n      offsetY,\n      pageX,\n      pageY,\n      deltaX,\n      deltaY,\n      button,\n      pointerHistory,\n      sourceEvent: event,\n      relatedElement,\n      targetElement\n    };\n    this.debug(\"InteractionManager - builtEvent: \", builtEvent);\n    return builtEvent;\n  }\n};\n_InteractionManager.NULL_COORDS = {\n  clientX: -Infinity,\n  clientY: -Infinity,\n  pageX: -Infinity,\n  pageY: -Infinity,\n  offsetX: -Infinity,\n  offsetY: -Infinity\n};\nvar InteractionManager = _InteractionManager;\n\n// packages/ag-charts-community/src/chart/interaction/animationManager.ts\nfunction validAnimationDuration(testee) {\n  if (testee == null)\n    return true;\n  return !isNaN(testee) && testee >= 0 && testee <= 2;\n}\nvar AnimationManager = class extends BaseManager {\n  constructor(interactionManager, chartUpdateMutex) {\n    super();\n    this.interactionManager = interactionManager;\n    this.chartUpdateMutex = chartUpdateMutex;\n    this.defaultDuration = 1e3;\n    this.batch = new AnimationBatch(this.defaultDuration * 1.5);\n    this.debug = Debug.create(true, \"animation\");\n    this.rafAvailable = typeof requestAnimationFrame !== \"undefined\";\n    this.isPlaying = false;\n    this.requestId = null;\n    this.skipAnimations = false;\n    this.currentAnonymousAnimationId = 0;\n  }\n  /**\n   * Create an animation to tween a value between the `from` and `to` properties. If an animation already exists\n   * with the same `id`, immediately stop it.\n   */\n  animate({ ...opts }) {\n    const batch = this.batch;\n    try {\n      batch.checkOverlappingId(opts.id);\n    } catch (error) {\n      this.failsafeOnError(error);\n      return;\n    }\n    let { id } = opts;\n    if (id == null) {\n      id = `__${this.currentAnonymousAnimationId}`;\n      this.currentAnonymousAnimationId += 1;\n    }\n    const skip = this.isSkipped() || opts.phase === \"none\";\n    if (skip) {\n      this.debug(\"AnimationManager - skipping animation\");\n    }\n    const { delay, duration } = opts;\n    if (!validAnimationDuration(delay)) {\n      throw new Error(`Animation delay of ${delay} is unsupported (${id})`);\n    }\n    if (!validAnimationDuration(duration)) {\n      throw new Error(`Animation duration of ${duration} is unsupported (${id})`);\n    }\n    const animation = new Animation({\n      ...opts,\n      id,\n      skip,\n      autoplay: this.isPlaying ? opts.autoplay : false,\n      phase: opts.phase,\n      defaultDuration: this.defaultDuration\n    });\n    if (this.forceTimeJump(animation, this.defaultDuration)) {\n      return;\n    }\n    this.batch.addAnimation(animation);\n    return animation;\n  }\n  play() {\n    if (this.isPlaying) {\n      return;\n    }\n    this.isPlaying = true;\n    this.debug(\"AnimationManager.play()\");\n    try {\n      this.batch.play();\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n    this.requestAnimation();\n  }\n  pause() {\n    if (!this.isPlaying) {\n      return;\n    }\n    this.isPlaying = false;\n    this.cancelAnimation();\n    this.debug(\"AnimationManager.pause()\");\n    try {\n      this.batch.pause();\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n  }\n  stop() {\n    this.isPlaying = false;\n    this.cancelAnimation();\n    this.debug(\"AnimationManager.stop()\");\n    this.batch.stop();\n  }\n  stopByAnimationId(id) {\n    try {\n      this.batch.stopByAnimationId(id);\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n  }\n  stopByAnimationGroupId(id) {\n    try {\n      this.batch.stopByAnimationGroupId(id);\n    } catch (error) {\n      this.failsafeOnError(error);\n    }\n  }\n  reset() {\n    if (this.isPlaying) {\n      this.stop();\n      this.play();\n    } else {\n      this.stop();\n    }\n  }\n  skip(skip = true) {\n    this.skipAnimations = skip;\n  }\n  isSkipped() {\n    return !this.rafAvailable || this.skipAnimations || this.batch.isSkipped();\n  }\n  isActive() {\n    return this.isPlaying && this.batch.isActive();\n  }\n  skipCurrentBatch() {\n    if (this.debug.check()) {\n      this.debug(`AnimationManager - skipCurrentBatch()`, { stack: new Error().stack });\n    }\n    this.batch.skip();\n  }\n  /** Mocking point for tests to guarantee that animation updates happen. */\n  isSkippingFrames() {\n    return true;\n  }\n  /** Mocking point for tests to capture requestAnimationFrame callbacks. */\n  scheduleAnimationFrame(cb) {\n    this.requestId = requestAnimationFrame(cb);\n  }\n  /** Mocking point for tests to skip animations to a specific point in time. */\n  forceTimeJump(_animation, _defaultDuration) {\n    return false;\n  }\n  requestAnimation() {\n    if (!this.rafAvailable)\n      return;\n    if (!this.batch.isActive() || this.requestId !== null)\n      return;\n    let prevTime;\n    const onAnimationFrame = async (time2) => {\n      const executeAnimationFrame = async () => {\n        const deltaTime = time2 - (prevTime ?? time2);\n        prevTime = time2;\n        this.debug(\"AnimationManager - onAnimationFrame()\", {\n          controllersCount: this.batch.size,\n          deltaTime\n        });\n        this.interactionManager.pushState(1 /* Animation */);\n        try {\n          this.batch.progress(deltaTime);\n        } catch (error) {\n          this.failsafeOnError(error);\n        }\n        this.listeners.dispatch(\"animation-frame\", {\n          type: \"animation-frame\",\n          deltaMs: deltaTime\n        });\n      };\n      if (this.isSkippingFrames()) {\n        await this.chartUpdateMutex.acquireImmediately(executeAnimationFrame);\n      } else {\n        await this.chartUpdateMutex.acquire(executeAnimationFrame);\n      }\n      if (this.batch.isActive()) {\n        this.scheduleAnimationFrame(onAnimationFrame);\n      } else {\n        this.batch.stop();\n        this.listeners.dispatch(\"animation-stop\", {\n          type: \"animation-stop\",\n          deltaMs: this.batch.consumedTimeMs\n        });\n      }\n    };\n    this.listeners.dispatch(\"animation-start\", {\n      type: \"animation-start\",\n      deltaMs: 0\n    });\n    this.scheduleAnimationFrame(onAnimationFrame);\n  }\n  cancelAnimation() {\n    if (this.requestId === null)\n      return;\n    cancelAnimationFrame(this.requestId);\n    this.requestId = null;\n    this.startBatch();\n  }\n  failsafeOnError(error, cancelAnimation = true) {\n    Logger.error(\"Error during animation, skipping animations\", error);\n    if (cancelAnimation) {\n      this.cancelAnimation();\n    }\n  }\n  startBatch(skipAnimations) {\n    this.debug(`AnimationManager - startBatch() with skipAnimations=${skipAnimations}.`);\n    this.reset();\n    this.batch.stop();\n    this.batch.destroy();\n    this.batch = new AnimationBatch(this.defaultDuration * 1.5);\n    if (skipAnimations === true) {\n      this.batch.skip();\n    }\n  }\n  endBatch() {\n    if (this.batch.isActive()) {\n      this.batch.ready();\n      this.requestAnimation();\n    } else {\n      this.interactionManager.popState(1 /* Animation */);\n      if (this.batch.isSkipped()) {\n        this.batch.skip(false);\n      }\n    }\n  }\n  onBatchStop(cb) {\n    this.batch.stoppedCbs.add(cb);\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/ariaAnnouncementServices.ts\nvar AriaAnnouncementService = class _AriaAnnouncementService {\n  constructor(localeManager, domManager, layoutService) {\n    this.localeManager = localeManager;\n    this.domManager = domManager;\n    this.layoutService = layoutService;\n    this.debug = Debug.create(true, \"aria\");\n    this.destroyFns = [];\n    this.liveElem = _AriaAnnouncementService.createAnnouncer();\n    this.domManager.addChild(\"canvas-proxy\", \"ag-charts-canvas-proxy\", this.liveElem);\n    this.destroyFns.push(\n      this.layoutService.addListener(\"layout-complete\", (ev) => this.onResize(ev)),\n      () => this.domManager.removeChild(\"canvas-proxy\", \"ag-charts-canvas-proxy\")\n    );\n  }\n  static createAnnouncer() {\n    const e = getDocument().createElement(\"div\");\n    e.classList.add(\"ag-charts-aria-announcer\");\n    setAttribute(e, \"role\", \"status\");\n    setAttribute(e, \"aria-live\", \"assertive\");\n    return e;\n  }\n  destroy() {\n    this.destroyFns.forEach((fn) => fn());\n  }\n  onResize(event) {\n    this.liveElem.style.width = `${event.chart.width}px`;\n    this.liveElem.style.height = `${event.chart.height}px`;\n  }\n  announceValue(id, params) {\n    const { localeManager, liveElem } = this;\n    const value = localeManager.t(id, params);\n    this.debug(`AriaAnnouncementService - announceValue: ${value}`);\n    liveElem.textContent = \"\\xA0\";\n    setTimeout(() => liveElem.innerText = value, 16);\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/chartEventManager.ts\nvar ChartEventManager = class extends BaseManager {\n  legendItemClick(series, itemId, enabled, legendItemName) {\n    const event = {\n      type: \"legend-item-click\",\n      series,\n      itemId,\n      enabled,\n      legendItemName\n    };\n    this.listeners.dispatch(\"legend-item-click\", event);\n  }\n  legendItemDoubleClick(series, itemId, enabled, numVisibleItems, legendItemName) {\n    const event = {\n      type: \"legend-item-double-click\",\n      series,\n      itemId,\n      enabled,\n      legendItemName,\n      numVisibleItems\n    };\n    this.listeners.dispatch(\"legend-item-double-click\", event);\n  }\n  axisHover(axisId, direction) {\n    const event = {\n      type: \"axis-hover\",\n      axisId,\n      direction\n    };\n    this.listeners.dispatch(\"axis-hover\", event);\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/contextMenuRegistry.ts\nvar ContextMenuRegistry = class _ContextMenuRegistry {\n  constructor(regionManager) {\n    this.defaultActions = [];\n    this.disabledActions = /* @__PURE__ */ new Set();\n    this.hiddenActions = /* @__PURE__ */ new Set();\n    this.listeners = new Listeners();\n    const { Default: Default2, ContextMenu } = InteractionState;\n    this.destroyFns = [regionManager.listenAll(\"contextmenu\", (e) => this.onContextMenu(e), Default2 | ContextMenu)];\n  }\n  destroy() {\n    this.destroyFns.forEach((d) => d());\n  }\n  onContextMenu(event) {\n    const type = _ContextMenuRegistry.toContextType(event.region);\n    if (type === \"all\") {\n      this.dispatchContext(\"all\", event, {});\n    }\n  }\n  static toContextType(region) {\n    if (region === \"legend\" || region === \"series\") {\n      return region;\n    }\n    return \"all\";\n  }\n  static check(type, event) {\n    return event.type === type;\n  }\n  static checkCallback(desiredType, type, _callback) {\n    return desiredType === type;\n  }\n  dispatchContext(type, pointerEvent, context) {\n    const { offsetX: x, offsetY: y, sourceEvent } = pointerEvent;\n    this.listeners.dispatch(\"\", buildPreventable({ type, x, y, context, sourceEvent }));\n  }\n  addListener(handler) {\n    return this.listeners.addListener(\"\", handler);\n  }\n  filterActions(type) {\n    return this.defaultActions.filter((action) => {\n      return action.id && !this.hiddenActions.has(action.id) && [\"all\", type].includes(action.type);\n    });\n  }\n  registerDefaultAction(action) {\n    if (action.id && this.defaultActions.find(({ id }) => id === action.id)) {\n      return;\n    }\n    this.defaultActions.push(action);\n  }\n  enableAction(actionId) {\n    this.disabledActions.delete(actionId);\n  }\n  disableAction(actionId) {\n    this.disabledActions.add(actionId);\n  }\n  setActionVisiblity(actionId, visible) {\n    if (visible) {\n      this.hiddenActions.delete(actionId);\n    } else {\n      this.hiddenActions.add(actionId);\n    }\n  }\n  isDisabled(actionId) {\n    return this.disabledActions.has(actionId);\n  }\n};\n\n// packages/ag-charts-community/src/util/stateTracker.ts\nvar StateTracker = class extends Map {\n  constructor(defaultValue, defaultState) {\n    super();\n    this.defaultValue = defaultValue;\n    this.defaultState = defaultState;\n  }\n  set(key, value) {\n    this.delete(key);\n    if (typeof value !== \"undefined\") {\n      super.set(key, value);\n    }\n    return this;\n  }\n  stateId() {\n    return Array.from(this.keys()).pop() ?? this.defaultState;\n  }\n  stateValue() {\n    return Array.from(this.values()).pop() ?? this.defaultValue;\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/cursorManager.ts\nvar Cursor = /* @__PURE__ */ ((Cursor2) => {\n  Cursor2[\"Auto\"] = \"auto\";\n  Cursor2[\"Default\"] = \"default\";\n  Cursor2[\"Grab\"] = \"grab\";\n  Cursor2[\"Grabbing\"] = \"grabbing\";\n  Cursor2[\"Move\"] = \"move\";\n  Cursor2[\"NotAllowed\"] = \"not-allowed\";\n  Cursor2[\"Pointer\"] = \"pointer\";\n  Cursor2[\"EWResize\"] = \"ew-resize\";\n  Cursor2[\"NSResize\"] = \"ns-resize\";\n  Cursor2[\"ZoomIn\"] = \"zoom-in\";\n  Cursor2[\"ZoomOut\"] = \"zoom-out\";\n  return Cursor2;\n})(Cursor || {});\nvar CursorManager = class {\n  constructor(domManager) {\n    this.domManager = domManager;\n    this.stateTracker = new StateTracker(\"default\");\n  }\n  updateCursor(callerId, style) {\n    this.stateTracker.set(callerId, style);\n    this.domManager.updateCursor(this.stateTracker.stateValue());\n  }\n  getCursor() {\n    return this.domManager.getCursor();\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/gestureDetector.ts\nfunction distanceSquared(finger1, finger2) {\n  const dx = finger1.screenX - finger2.screenX;\n  const dy = finger1.screenY - finger2.screenY;\n  return dx * dx + dy * dy;\n}\nfunction distance(finger1, finger2) {\n  return Math.sqrt(distanceSquared(finger1, finger2));\n}\nvar MIN_DISTANCE_TO_START_PINCH = 1;\nvar GestureDetector = class extends BaseManager {\n  constructor(domManager) {\n    super();\n    this.domManager = domManager;\n    this.touchstart = (event) => this.onTouchStart(event);\n    this.touchmove = (event) => this.onTouchMove(event);\n    this.touchend = (event) => this.onTouchEnd(event);\n    this.touchcancel = (event) => this.onTouchCancel(event);\n    this.pinch = {\n      finger1: { identifier: NaN, screenX: NaN, screenY: NaN },\n      finger2: { identifier: NaN, screenX: NaN, screenY: NaN },\n      origin: { x: NaN, y: NaN },\n      distance: NaN,\n      status: 0 /* Off */\n    };\n    this.domManager.addEventListener(\"touchstart\", this.touchstart, { passive: true });\n    this.domManager.addEventListener(\"touchmove\", this.touchmove, { passive: false });\n    this.domManager.addEventListener(\"touchend\", this.touchend);\n    this.domManager.addEventListener(\"touchcancel\", this.touchcancel);\n  }\n  destroy() {\n    this.domManager.removeEventListener(\"touchstart\", this.touchstart);\n    this.domManager.removeEventListener(\"touchmove\", this.touchmove);\n    this.domManager.removeEventListener(\"touchend\", this.touchend);\n    this.domManager.removeEventListener(\"touchcancel\", this.touchcancel);\n  }\n  findPinchTouches(moveEvent) {\n    const { touches } = moveEvent;\n    const { finger1, finger2 } = this.pinch;\n    if (this.pinch.status !== 0 /* Off */ && touches.length === 2) {\n      if (touches[0].identifier === finger1.identifier && touches[1].identifier === finger2.identifier) {\n        return [touches[0], touches[1]];\n      }\n      if (touches[0].identifier === finger2.identifier && touches[1].identifier === finger1.identifier) {\n        return [touches[1], touches[0]];\n      }\n    }\n  }\n  copyTouchData(event) {\n    const keys = [\"identifier\", \"screenX\", \"screenY\"];\n    partialAssign(keys, this.pinch.finger1, event.touches[0]);\n    partialAssign(keys, this.pinch.finger2, event.touches[1]);\n    this.pinch.distance = distance(this.pinch.finger1, this.pinch.finger2);\n  }\n  dispatchPinchEvent(type, deltaDistance, sourceEvent) {\n    const { finger1, finger2, origin } = this.pinch;\n    this.listeners.dispatch(type, buildPreventable({ sourceEvent, type, finger1, finger2, deltaDistance, origin }));\n  }\n  onTouchStart(event) {\n    this.stopPinchTracking(event);\n    const { pinch } = this;\n    if (event.touches.length === 2) {\n      pinch.status = 1 /* Initialized */;\n      this.copyTouchData(event);\n      pinch.origin.x = (event.touches[0].clientX + event.touches[1].clientX) / 2;\n      pinch.origin.y = (event.touches[0].clientY + event.touches[1].clientY) / 2;\n    }\n  }\n  onTouchMove(event) {\n    const pinchTouches = this.findPinchTouches(event);\n    if (pinchTouches !== void 0) {\n      const [touch1, touch2] = pinchTouches;\n      const { pinch } = this;\n      const newDistance = distance(touch1, touch2);\n      const deltaDistance = newDistance - pinch.distance;\n      if (pinch.status === 1 /* Initialized */) {\n        if (Math.abs(deltaDistance) > MIN_DISTANCE_TO_START_PINCH) {\n          pinch.status = 2 /* Running */;\n          this.copyTouchData(event);\n          this.dispatchPinchEvent(\"pinch-start\", 0, event);\n        }\n      } else if (pinch.status === 2 /* Running */) {\n        pinch.distance = newDistance;\n        this.copyTouchData(event);\n        this.dispatchPinchEvent(\"pinch-move\", deltaDistance, event);\n      } else {\n        Logger.error(`unexpected pinch.status: ${pinch.status}`);\n      }\n    }\n  }\n  onTouchEnd(event) {\n    this.stopPinchTracking(event);\n  }\n  onTouchCancel(event) {\n    this.stopPinchTracking(event);\n  }\n  stopPinchTracking(event) {\n    const { pinch } = this;\n    if (pinch.status === 2 /* Running */) {\n      this.dispatchPinchEvent(\"pinch-end\", 0, event);\n    }\n    this.pinch.status = 0 /* Off */;\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/highlightManager.ts\nvar HighlightManager = class extends BaseManager {\n  constructor() {\n    super(...arguments);\n    this.highlightStates = new StateTracker();\n  }\n  updateHighlight(callerId, highlightedDatum) {\n    const { activeHighlight: previousHighlight } = this;\n    this.highlightStates.set(callerId, highlightedDatum);\n    this.activeHighlight = this.highlightStates.stateValue();\n    if (!this.isEqual(this.activeHighlight, previousHighlight)) {\n      this.listeners.dispatch(\"highlight-change\", {\n        type: \"highlight-change\",\n        currentHighlight: this.activeHighlight,\n        previousHighlight,\n        callerId\n      });\n    }\n  }\n  getActiveHighlight() {\n    return this.activeHighlight;\n  }\n  isEqual(a, b) {\n    return a === b || a != null && b != null && a?.series === b?.series && a?.itemId === b?.itemId && a?.datum === b?.datum;\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/keyNavManager.ts\nvar KeyNavManager = class extends BaseManager {\n  constructor(interactionManager, domManager) {\n    super();\n    this.domManager = domManager;\n    this.hasBrowserFocus = false;\n    this.isMouseBlurred = false;\n    this.isClicking = false;\n    this.destroyFns.push(\n      interactionManager.addListener(\"drag-start\", (e) => this.onClickStart(e), 31 /* All */),\n      interactionManager.addListener(\"click\", (e) => this.onClickStop(e), 31 /* All */),\n      interactionManager.addListener(\"drag-end\", (e) => this.onClickStop(e), 31 /* All */),\n      interactionManager.addListener(\"wheel\", (e) => this.mouseBlur(e)),\n      interactionManager.addListener(\"hover\", (e) => this.mouseBlur(e)),\n      interactionManager.addListener(\"drag\", (e) => this.mouseBlur(e)),\n      interactionManager.addListener(\"blur\", (e) => this.onBlur(e), 31 /* All */),\n      interactionManager.addListener(\"focus\", (e) => this.onFocus(e), 31 /* All */),\n      interactionManager.addListener(\"keydown\", (e) => this.onKeyDown(e), 31 /* All */)\n    );\n  }\n  destroy() {\n    super.destroy();\n  }\n  onClickStart(event) {\n    this.isClicking = true;\n    this.mouseBlur(event);\n  }\n  onClickStop(event) {\n    this.mouseBlur(event);\n    this.isClicking = false;\n  }\n  mouseBlur(event) {\n    if (!this.hasBrowserFocus)\n      return;\n    if (!this.isMouseBlurred) {\n      this.dispatch(\"blur\", 0, event);\n      this.isMouseBlurred = true;\n    }\n  }\n  onBlur(event) {\n    this.hasBrowserFocus = false;\n    this.isMouseBlurred = false;\n    this.dispatch(\"blur\", 0, event);\n  }\n  onFocus(event) {\n    const delta3 = this.domManager.getBrowserFocusDelta();\n    this.dispatch(\"browserfocus\", delta3, event);\n    this.hasBrowserFocus = true;\n    const tabFocusFromClick = event.relatedElement == null && event.targetElement?.tagName === \"CANVAS\";\n    if (this.isClicking || tabFocusFromClick) {\n      this.isMouseBlurred = true;\n      return;\n    }\n    this.dispatch(\"tab\", delta3, event);\n  }\n  onKeyDown(event) {\n    if (!this.hasBrowserFocus)\n      return;\n    this.isMouseBlurred = false;\n    const { code, altKey, shiftKey, metaKey, ctrlKey } = event.sourceEvent;\n    if (code === \"Tab\") {\n      if (shiftKey) {\n        return this.dispatch(\"tab\", -1, event);\n      } else {\n        return this.dispatch(\"tab\", 1, event);\n      }\n    }\n    if (altKey || shiftKey || metaKey || ctrlKey)\n      return;\n    switch (code) {\n      case \"ArrowDown\":\n        return this.dispatch(\"nav-vert\", 1, event);\n      case \"ArrowUp\":\n        return this.dispatch(\"nav-vert\", -1, event);\n      case \"ArrowLeft\":\n        return this.dispatch(\"nav-hori\", -1, event);\n      case \"ArrowRight\":\n        return this.dispatch(\"nav-hori\", 1, event);\n      case \"ZoomIn\":\n      case \"Add\":\n        return this.dispatch(\"nav-zoom\", 1, event);\n      case \"ZoomOut\":\n      case \"Substract\":\n        return this.dispatch(\"nav-zoom\", -1, event);\n      case \"Space\":\n      case \"Enter\":\n        return this.dispatch(\"submit\", 0, event);\n      case \"Escape\":\n        return this.dispatch(\"cancel\", 0, event);\n      case \"Backspace\":\n      case \"Delete\":\n        return this.dispatch(\"delete\", 0, event);\n    }\n    switch (event.sourceEvent.key) {\n      case \"+\":\n        return this.dispatch(\"nav-zoom\", 1, event);\n      case \"-\":\n        return this.dispatch(\"nav-zoom\", -1, event);\n    }\n  }\n  dispatch(type, delta3, sourceEvent) {\n    dispatchTypedEvent(this.listeners, { type, delta: delta3, sourceEvent });\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/regionManager.ts\nvar REGION_TAB_ORDERING = [\"series\"];\nvar RegionListeners = class extends Listeners {\n};\nfunction addHandler(listeners, interactionManager, type, handler, triggeringStates = 16 /* Default */) {\n  return listeners?.addListener(type, (e) => {\n    const currentState = interactionManager.getState();\n    if (currentState & triggeringStates) {\n      handler(e);\n    }\n  }) ?? (() => {\n  });\n}\nvar RegionManager = class {\n  constructor(interactionManager, keyNavManager, focusIndicator) {\n    this.interactionManager = interactionManager;\n    this.keyNavManager = keyNavManager;\n    this.focusIndicator = focusIndicator;\n    this.currentTabIndex = 0;\n    this.isDragging = false;\n    this.leftCanvas = false;\n    this.regions = /* @__PURE__ */ new Map();\n    this.destroyFns = [];\n    this.allRegionsListeners = new RegionListeners();\n    this.destroyFns.push(\n      ...POINTER_INTERACTION_TYPES.map(\n        (eventName) => interactionManager.addListener(eventName, this.processPointerEvent.bind(this), 31 /* All */)\n      ),\n      this.keyNavManager.addListener(\"blur\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"browserfocus\", this.onBrowserFocus.bind(this)),\n      this.keyNavManager.addListener(\"tab\", this.onTab.bind(this)),\n      this.keyNavManager.addListener(\"nav-vert\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"nav-hori\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"nav-zoom\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"submit\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"cancel\", this.onNav.bind(this)),\n      this.keyNavManager.addListener(\"delete\", this.onNav.bind(this))\n    );\n  }\n  destroy() {\n    this.destroyFns.forEach((fn) => fn());\n    this.currentRegion = void 0;\n    for (const region of this.regions.values()) {\n      region.listeners.destroy();\n    }\n    this.focusIndicator.destroy();\n    this.regions.clear();\n  }\n  addRegion(name, ...bboxproviders) {\n    if (this.regions.has(name)) {\n      throw new Error(`AG Charts - Region: ${name} already exists`);\n    }\n    const region = {\n      properties: { name, bboxproviders: [...bboxproviders] },\n      listeners: new RegionListeners()\n    };\n    this.regions.set(name, region);\n    return this.makeObserver(region);\n  }\n  updateRegion(name, ...bboxprovider) {\n    const region = this.regions.get(name);\n    if (region) {\n      region.properties.bboxproviders = [...bboxprovider];\n    } else {\n      throw new Error(\"AG Charts - unknown region: \" + name);\n    }\n  }\n  getRegion(name) {\n    return this.makeObserver(this.regions.get(name));\n  }\n  listenAll(type, handler, triggeringStates = 16 /* Default */) {\n    return addHandler(this.allRegionsListeners, this.interactionManager, type, handler, triggeringStates);\n  }\n  // This method return a wrapper object that matches the interface of InteractionManager.addListener.\n  // The intent is to allow the InteractionManager and RegionManager to be used almost interchangeably.\n  makeObserver(region) {\n    const { interactionManager } = this;\n    class ObservableRegionImplementation {\n      addListener(type, handler, triggeringStates = 16 /* Default */) {\n        return addHandler(region?.listeners, interactionManager, type, handler, triggeringStates);\n      }\n    }\n    return new ObservableRegionImplementation();\n  }\n  checkPointerHistory(targetRegion, event) {\n    for (const historyEvent of event.pointerHistory) {\n      const { region: historyRegion } = this.pickRegion(historyEvent.offsetX, historyEvent.offsetY);\n      if (targetRegion.properties.name !== historyRegion?.properties.name) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // Create and dispatch a copy of the InteractionEvent.\n  dispatch(region, partialEvent, bboxProviderId) {\n    if (region == null)\n      return;\n    const event = buildPreventable({\n      ...partialEvent,\n      region: region.properties.name,\n      bboxProviderId\n    });\n    this.allRegionsListeners.dispatch(event.type, event);\n    region.listeners.dispatch(event.type, event);\n  }\n  // Process events during a drag action. Returns false if this event should follow the standard\n  // RegionManager.processEvent flow, or true if this event already processed by this function.\n  handleDragging(event) {\n    const { currentRegion } = this;\n    switch (event.type) {\n      case \"drag-start\":\n        this.isDragging = true;\n        this.leftCanvas = false;\n        break;\n      case \"leave\":\n        this.leftCanvas = true;\n        return this.isDragging;\n      case \"enter\":\n        this.leftCanvas = false;\n        return this.isDragging;\n      case \"drag\":\n        if (this.isDragging) {\n          this.dispatch(currentRegion, event);\n          return true;\n        }\n        break;\n      case \"drag-end\":\n        if (this.isDragging) {\n          this.isDragging = false;\n          this.dispatch(currentRegion, event);\n          if (this.leftCanvas) {\n            this.dispatch(currentRegion, { ...event, type: \"leave\" });\n          }\n          return true;\n        }\n        break;\n    }\n    return false;\n  }\n  processPointerEvent(event) {\n    if (this.handleDragging(event)) {\n      return;\n    }\n    const { currentRegion } = this;\n    if (event.type === \"leave\") {\n      this.dispatch(currentRegion, { ...event, type: \"leave\" });\n      this.currentRegion = void 0;\n      return;\n    }\n    const { region: newRegion, bboxProviderId } = this.pickRegion(event.offsetX, event.offsetY);\n    if (currentRegion !== void 0 && newRegion?.properties.name !== currentRegion.properties.name) {\n      this.dispatch(currentRegion, { ...event, type: \"leave\" }, this.currentBBoxProviderId);\n    }\n    if (newRegion !== void 0 && newRegion.properties.name !== currentRegion?.properties.name) {\n      this.dispatch(newRegion, { ...event, type: \"enter\" }, bboxProviderId);\n    }\n    if (newRegion !== void 0 && this.checkPointerHistory(newRegion, event)) {\n      this.dispatch(newRegion, event, bboxProviderId);\n    }\n    this.currentRegion = newRegion;\n    this.currentBBoxProviderId = bboxProviderId;\n  }\n  pickRegion(x, y) {\n    let currentArea = Infinity;\n    let currentRegion;\n    let currentBBoxProviderId;\n    for (const region of this.regions.values()) {\n      for (const provider of region.properties.bboxproviders) {\n        if (provider.visible === false)\n          continue;\n        const bbox = provider.computeTransformedRegionBBox?.() ?? provider.computeTransformedBBox();\n        const area2 = bbox.width * bbox.height;\n        if (area2 < currentArea && bbox.containsPoint(x, y)) {\n          currentArea = area2;\n          currentRegion = region;\n          currentBBoxProviderId = provider.id;\n        }\n      }\n    }\n    return { region: currentRegion, bboxProviderId: currentBBoxProviderId };\n  }\n  getTabRegion(tabIndex) {\n    if (tabIndex !== void 0 && tabIndex >= 0 && tabIndex < REGION_TAB_ORDERING.length) {\n      return this.regions.get(REGION_TAB_ORDERING[tabIndex]);\n    }\n    return void 0;\n  }\n  getNextInteractableTabIndex(currentIndex, delta3) {\n    const direction = delta3 < 0 ? -1 : 1;\n    let i = currentIndex;\n    while (delta3 !== 0) {\n      const region = this.getTabRegion(i + direction);\n      if (region === void 0) {\n        return void 0;\n      } else {\n        delta3 = delta3 - direction;\n      }\n      i = i + direction;\n    }\n    return i;\n  }\n  validateCurrentTabIndex() {\n    const focusedRegion = this.getTabRegion(this.currentTabIndex);\n    if (focusedRegion !== void 0) {\n      this.currentTabIndex = this.getNextInteractableTabIndex(-1, 1) ?? 0;\n    }\n  }\n  onBrowserFocus(event) {\n    if (event.delta > 0) {\n      this.currentTabIndex = -1;\n    } else if (event.delta < 0) {\n      this.currentTabIndex = REGION_TAB_ORDERING.length;\n    }\n  }\n  onTab(event) {\n    this.validateCurrentTabIndex();\n    const newTabIndex = this.getNextInteractableTabIndex(this.currentTabIndex, event.delta);\n    const newRegion = this.getTabRegion(newTabIndex);\n    const focusedRegion = this.getTabRegion(this.currentTabIndex);\n    if (newTabIndex !== void 0) {\n      this.currentTabIndex = newTabIndex;\n    }\n    if (focusedRegion !== void 0 && newRegion?.properties.name !== focusedRegion.properties.name) {\n      const { delta: delta3, sourceEvent } = event;\n      const blurEvent = buildPreventable({ type: \"blur\", delta: delta3, sourceEvent });\n      this.dispatch(focusedRegion, blurEvent);\n    }\n    if (newRegion === void 0) {\n      this.focusIndicator.updateBounds(void 0);\n    } else {\n      this.dispatch(newRegion, event);\n    }\n  }\n  onNav(event) {\n    const focusedRegion = this.getTabRegion(this.currentTabIndex);\n    this.dispatch(focusedRegion, event);\n  }\n};\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarTypes.ts\nvar TOOLBAR_ALIGNMENTS = [\"start\", \"center\", \"end\"];\nvar TOOLBAR_GROUPS = [\"seriesType\", \"annotations\", \"annotationOptions\", \"ranges\", \"zoom\"];\nvar TOOLBAR_GROUP_ORDERING = {\n  seriesType: 0,\n  annotations: 1,\n  annotationOptions: 2,\n  ranges: 3,\n  zoom: 4\n};\nvar ToolbarPosition = /* @__PURE__ */ ((ToolbarPosition2) => {\n  ToolbarPosition2[\"Top\"] = \"top\";\n  ToolbarPosition2[\"Right\"] = \"right\";\n  ToolbarPosition2[\"Bottom\"] = \"bottom\";\n  ToolbarPosition2[\"Left\"] = \"left\";\n  ToolbarPosition2[\"Floating\"] = \"floating\";\n  ToolbarPosition2[\"FloatingTop\"] = \"floating-top\";\n  ToolbarPosition2[\"FloatingBottom\"] = \"floating-bottom\";\n  return ToolbarPosition2;\n})(ToolbarPosition || {});\nvar TOOLBAR_POSITIONS = Object.values(ToolbarPosition);\nfunction isAnimatingFloatingPosition(position) {\n  return [\"floating-top\" /* FloatingTop */, \"floating-bottom\" /* FloatingBottom */].includes(position);\n}\n\n// packages/ag-charts-community/src/chart/interaction/toolbarManager.ts\nvar ToolbarManager = class extends BaseManager {\n  static isGroup(group, event) {\n    return event.group === group;\n  }\n  static isChildElement(domManager, element2) {\n    for (const position of TOOLBAR_POSITIONS) {\n      if (domManager.isManagedChildDOMElement(element2, \"canvas-overlay\", `toolbar-${position}`)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  pressButton(group, id, value, rect) {\n    this.listeners.dispatch(\"button-pressed\", { type: \"button-pressed\", group, id, value, rect });\n  }\n  cancel(group) {\n    this.listeners.dispatch(\"cancelled\", { type: \"cancelled\", group });\n  }\n  toggleButton(group, id, options) {\n    const { active = false, enabled = true, visible = true } = options;\n    this.listeners.dispatch(\"button-toggled\", { type: \"button-toggled\", group, id, active, enabled, visible });\n  }\n  updateButton(group, id, options) {\n    this.listeners.dispatch(\"button-updated\", { type: \"button-updated\", group, id, ...options });\n  }\n  toggleGroup(caller, group, options) {\n    const { active, visible } = options;\n    this.listeners.dispatch(\"group-toggled\", { type: \"group-toggled\", caller, group, active, visible });\n  }\n  changeFloatingAnchor(group, anchor) {\n    this.listeners.dispatch(\"floating-anchor-changed\", { type: \"floating-anchor-changed\", group, anchor });\n  }\n  buttonMoved(group, value, rect, groupRect) {\n    this.listeners.dispatch(\"button-moved\", { type: \"button-moved\", group, value, rect, groupRect });\n  }\n  proxyGroupOptions(caller, group, options) {\n    this.listeners.dispatch(\"proxy-group-options\", { type: \"proxy-group-options\", caller, group, options });\n  }\n};\n\n// packages/ag-charts-community/src/chart/interaction/tooltipManager.ts\nvar TooltipManager = class {\n  constructor(domManager, tooltip) {\n    this.domManager = domManager;\n    this.tooltip = tooltip;\n    this.stateTracker = new StateTracker();\n    this.suppressState = new StateTracker(false);\n    this.appliedState = null;\n    tooltip.setup(domManager);\n    domManager.addListener(\"hidden\", () => this.tooltip.toggle(false));\n  }\n  updateTooltip(callerId, meta, content) {\n    if (!this.tooltip.enabled)\n      return;\n    content ?? (content = this.stateTracker.get(callerId)?.content);\n    this.stateTracker.set(callerId, { content, meta });\n    this.applyStates();\n  }\n  removeTooltip(callerId) {\n    if (!this.tooltip.enabled)\n      return;\n    this.stateTracker.delete(callerId);\n    this.applyStates();\n  }\n  suppressTooltip(callerId) {\n    this.suppressState.set(callerId, true);\n  }\n  unsuppressTooltip(callerId) {\n    this.suppressState.delete(callerId);\n  }\n  getTooltipMeta(callerId) {\n    return this.stateTracker.get(callerId)?.meta;\n  }\n  destroy() {\n    this.domManager.removeStyles(\"tooltip\");\n  }\n  applyStates() {\n    const id = this.stateTracker.stateId();\n    const state = id ? this.stateTracker.get(id) : null;\n    if (this.suppressState.stateValue() || state?.meta == null || state?.content == null) {\n      this.appliedState = null;\n      this.tooltip.toggle(false);\n      return;\n    }\n    const canvasRect = this.domManager.getBoundingClientRect();\n    const boundingRect = this.tooltip.bounds === \"extended\" ? this.domManager.getOverlayClientRect() : canvasRect;\n    if (this.appliedState?.content === state?.content) {\n      const renderInstantly = this.tooltip.isVisible();\n      this.tooltip.show(boundingRect, canvasRect, state?.meta, null, renderInstantly);\n    } else {\n      this.tooltip.show(boundingRect, canvasRect, state?.meta, state?.content);\n    }\n    this.appliedState = state;\n  }\n  static makeTooltipMeta(event, datum) {\n    const { offsetX, offsetY } = event;\n    const { tooltip } = datum.series.properties;\n    const meta = {\n      offsetX,\n      offsetY,\n      enableInteraction: tooltip.interaction?.enabled ?? false,\n      lastPointerEvent: { type: event.type, offsetX, offsetY },\n      showArrow: tooltip.showArrow,\n      position: {\n        type: tooltip.position.type,\n        xOffset: tooltip.position.xOffset,\n        yOffset: tooltip.position.yOffset\n      }\n    };\n    const refPoint = datum.yBar?.upperPoint ?? datum.midPoint ?? datum.series.datumMidPoint?.(datum);\n    if (tooltip.position.type === \"node\" && refPoint) {\n      const { x, y } = refPoint;\n      const point = datum.series.contentGroup.inverseTransformPoint(x, y);\n      return {\n        ...meta,\n        offsetX: Math.round(point.x),\n        offsetY: Math.round(point.y)\n      };\n    }\n    return meta;\n  }\n};\n\n// packages/ag-charts-community/src/chart/layout/layoutService.ts\nvar LayoutService = class extends Listeners {\n  constructor() {\n    super(...arguments);\n    this.layoutComplete = \"layout-complete\";\n    this.debug = Debug.create(true, \"layout\");\n  }\n  addListener(eventType, handler) {\n    if (this.isLayoutStage(eventType) || this.isLayoutComplete(eventType)) {\n      return super.addListener(eventType, handler);\n    }\n    throw new Error(`AG Charts - unsupported listener type: ${eventType}`);\n  }\n  dispatchPerformLayout(stage, ctx) {\n    if (this.isLayoutStage(stage)) {\n      return this.getListenersByType(stage).reduce((result, listener) => {\n        try {\n          const newCtx = listener.handler(result);\n          this.debug(\"[LayoutService] Context updated to: \", { ...newCtx }, listener);\n          return newCtx;\n        } catch (e) {\n          Logger.errorOnce(e);\n          return result;\n        }\n      }, ctx);\n    }\n    return ctx;\n  }\n  dispatchLayoutComplete(event) {\n    this.dispatch(this.layoutComplete, event);\n  }\n  isLayoutStage(eventType) {\n    return eventType !== this.layoutComplete;\n  }\n  isLayoutComplete(eventType) {\n    return eventType === this.layoutComplete;\n  }\n};\n\n// packages/ag-charts-community/src/chart/locale/defaultMessageFormatter.ts\nvar messageRegExp = /\\$\\{(\\w+)}(?:\\[(\\w+)])?/gi;\nvar formatters = {\n  number: new Intl.NumberFormat(\"en-US\"),\n  percent: new Intl.NumberFormat(\"en-US\", { style: \"percent\" }),\n  date: new Intl.DateTimeFormat(\"en-US\", { dateStyle: \"full\" }),\n  time: new Intl.DateTimeFormat(\"en-US\", { timeStyle: \"full\" }),\n  datetime: new Intl.DateTimeFormat(\"en-US\", { dateStyle: \"full\", timeStyle: \"full\" })\n};\nvar defaultMessageFormatter = ({ defaultValue, variables }) => {\n  return defaultValue?.replaceAll(messageRegExp, (_, match, format) => {\n    const value = variables[match];\n    const formatter = format != null ? formatters[format] : void 0;\n    if (format != null && formatter == null) {\n      Logger.warnOnce(`Format style [${format}] is not supported`);\n    }\n    if (formatter != null) {\n      return formatter.format(value);\n    } else if (typeof value === \"number\") {\n      return formatters.number.format(value);\n    } else if (value instanceof Date) {\n      return formatters.datetime.format(value);\n    }\n    return String(value);\n  });\n};\n\n// packages/ag-charts-community/src/chart/locale/localeManager.ts\nvar LocaleManager = class extends Listeners {\n  constructor() {\n    super(...arguments);\n    this.localeText = void 0;\n    this.getLocaleText = void 0;\n  }\n  setLocaleText(localeText) {\n    if (this.localeText !== localeText) {\n      this.localeText = localeText;\n      this.dispatch(\"locale-changed\");\n    }\n  }\n  setLocaleTextFormatter(getLocaleText) {\n    this.getLocaleText = getLocaleText;\n    if (this.getLocaleText !== getLocaleText) {\n      this.getLocaleText = getLocaleText;\n      this.dispatch(\"locale-changed\");\n    }\n  }\n  t(key, variables = {}) {\n    const { localeText = AG_CHARTS_LOCALE_EN_US, getLocaleText } = this;\n    const defaultValue = localeText[key];\n    return getLocaleText?.({ key, defaultValue, variables }) ?? defaultMessageFormatter({ key, defaultValue, variables }) ?? key;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesStateManager.ts\nvar SeriesStateManager = class {\n  constructor() {\n    this.groups = {};\n  }\n  registerSeries({\n    id,\n    seriesGrouping,\n    visible,\n    type\n  }) {\n    var _a;\n    if (!seriesGrouping)\n      return;\n    (_a = this.groups)[type] ?? (_a[type] = {});\n    this.groups[type][id] = { grouping: seriesGrouping, visible };\n  }\n  deregisterSeries({ id, type }) {\n    if (this.groups[type]) {\n      delete this.groups[type][id];\n    }\n    if (this.groups[type] && Object.keys(this.groups[type]).length === 0) {\n      delete this.groups[type];\n    }\n  }\n  getVisiblePeerGroupIndex({\n    type,\n    seriesGrouping,\n    visible\n  }) {\n    if (!seriesGrouping)\n      return { visibleGroupCount: visible ? 1 : 0, visibleSameStackCount: visible ? 1 : 0, index: 0 };\n    const visibleGroupsSet = /* @__PURE__ */ new Set();\n    const visibleSameStackSet = /* @__PURE__ */ new Set();\n    for (const entry of Object.values(this.groups[type] ?? {})) {\n      if (!entry.visible)\n        continue;\n      visibleGroupsSet.add(entry.grouping.groupIndex);\n      if (entry.grouping.groupIndex === seriesGrouping.groupIndex) {\n        visibleSameStackSet.add(entry.grouping.stackIndex);\n      }\n    }\n    const visibleGroups = Array.from(visibleGroupsSet);\n    visibleGroups.sort((a, b) => a - b);\n    return {\n      visibleGroupCount: visibleGroups.length,\n      visibleSameStackCount: visibleSameStackSet.size,\n      index: visibleGroups.indexOf(seriesGrouping.groupIndex)\n    };\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartUpdateType.ts\nvar ChartUpdateType = /* @__PURE__ */ ((ChartUpdateType3) => {\n  ChartUpdateType3[ChartUpdateType3[\"FULL\"] = 0] = \"FULL\";\n  ChartUpdateType3[ChartUpdateType3[\"UPDATE_DATA\"] = 1] = \"UPDATE_DATA\";\n  ChartUpdateType3[ChartUpdateType3[\"PROCESS_DATA\"] = 2] = \"PROCESS_DATA\";\n  ChartUpdateType3[ChartUpdateType3[\"PERFORM_LAYOUT\"] = 3] = \"PERFORM_LAYOUT\";\n  ChartUpdateType3[ChartUpdateType3[\"SERIES_UPDATE\"] = 4] = \"SERIES_UPDATE\";\n  ChartUpdateType3[ChartUpdateType3[\"PRE_SCENE_RENDER\"] = 5] = \"PRE_SCENE_RENDER\";\n  ChartUpdateType3[ChartUpdateType3[\"SCENE_RENDER\"] = 6] = \"SCENE_RENDER\";\n  ChartUpdateType3[ChartUpdateType3[\"NONE\"] = 7] = \"NONE\";\n  return ChartUpdateType3;\n})(ChartUpdateType || {});\n\n// packages/ag-charts-community/src/chart/updateService.ts\nvar UpdateService = class extends Listeners {\n  constructor(updateCallback) {\n    super();\n    this.updateCallback = updateCallback;\n  }\n  update(type = 0 /* FULL */, options) {\n    this.updateCallback(type, options);\n  }\n  dispatchUpdateComplete(rects) {\n    this.dispatch(\"update-complete\", {\n      type: \"update-complete\",\n      minRect: rects?.minRect,\n      minVisibleRect: rects?.minVisibleRect\n    });\n  }\n  dispatchPreSceneRender(rects) {\n    this.dispatch(\"pre-scene-render\", { type: \"pre-scene-render\", ...rects });\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartContext.ts\nvar ChartContext = class {\n  constructor(chart, vars) {\n    const { scene, root, syncManager, container, updateCallback, updateMutex, overrideDevicePixelRatio } = vars;\n    this.chartService = chart;\n    this.syncManager = syncManager;\n    this.zoomManager = chart.zoomManager;\n    this.domManager = new DOMManager(container);\n    scene?.setContainer(this.domManager);\n    this.scene = scene ?? new Scene({ pixelRatio: overrideDevicePixelRatio, domManager: this.domManager });\n    this.scene.setRoot(root);\n    this.axisManager = new AxisManager(root);\n    this.localeManager = new LocaleManager();\n    this.annotationManager = new AnnotationManager(chart.annotationRoot);\n    this.chartEventManager = new ChartEventManager();\n    this.cursorManager = new CursorManager(this.domManager);\n    this.highlightManager = new HighlightManager();\n    this.interactionManager = new InteractionManager(chart.keyboard, this.domManager);\n    this.keyNavManager = new KeyNavManager(this.interactionManager, this.domManager);\n    this.focusIndicator = new FocusIndicator(this.domManager);\n    this.regionManager = new RegionManager(this.interactionManager, this.keyNavManager, this.focusIndicator);\n    this.contextMenuRegistry = new ContextMenuRegistry(this.regionManager);\n    this.toolbarManager = new ToolbarManager();\n    this.gestureDetector = new GestureDetector(this.domManager);\n    this.layoutService = new LayoutService();\n    this.ariaAnnouncementService = new AriaAnnouncementService(\n      this.localeManager,\n      this.domManager,\n      this.layoutService\n    );\n    this.updateService = new UpdateService(updateCallback);\n    this.proxyInteractionService = new ProxyInteractionService(\n      this.updateService,\n      this.localeManager,\n      this.domManager,\n      this.focusIndicator\n    );\n    this.seriesStateManager = new SeriesStateManager();\n    this.stateManager = new StateManager();\n    this.callbackCache = new CallbackCache();\n    this.animationManager = new AnimationManager(this.interactionManager, updateMutex);\n    this.animationManager.skip();\n    this.animationManager.play();\n    this.dataService = new DataService(this.animationManager);\n    this.tooltipManager = new TooltipManager(this.domManager, chart.tooltip);\n  }\n  destroy() {\n    this.tooltipManager.destroy();\n    this.contextMenuRegistry.destroy();\n    this.regionManager.destroy();\n    this.proxyInteractionService.destroy();\n    this.focusIndicator.destroy();\n    this.keyNavManager.destroy();\n    this.interactionManager.destroy();\n    this.animationManager.stop();\n    this.animationManager.destroy();\n    this.ariaAnnouncementService.destroy();\n    this.chartEventManager.destroy();\n    this.highlightManager.destroy();\n    this.callbackCache.invalidateCache();\n    this.animationManager.reset();\n    this.syncManager.destroy();\n    this.domManager.destroy();\n    this.axisManager.destroy();\n  }\n};\n\n// packages/ag-charts-community/src/chart/chartHighlight.ts\nvar ChartHighlight = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.range = \"tooltip\";\n  }\n};\n__decorateClass([\n  Validate(UNION([\"tooltip\", \"node\"], \"a range\"))\n], ChartHighlight.prototype, \"range\", 2);\n\n// packages/ag-charts-community/src/chart/data/dataDomain.ts\nvar DiscreteDomain = class _DiscreteDomain {\n  constructor() {\n    this.domain = /* @__PURE__ */ new Set();\n  }\n  static is(value) {\n    return value instanceof _DiscreteDomain;\n  }\n  extend(val) {\n    this.domain.add(val);\n  }\n  getDomain() {\n    return Array.from(this.domain);\n  }\n};\nvar ContinuousDomain = class _ContinuousDomain {\n  constructor() {\n    this.domain = [Infinity, -Infinity];\n  }\n  static is(value) {\n    return value instanceof _ContinuousDomain;\n  }\n  static extendDomain(values, domain = [Infinity, -Infinity]) {\n    for (const value of values) {\n      if (typeof value !== \"number\") {\n        continue;\n      }\n      if (domain[0] > value) {\n        domain[0] = value;\n      }\n      if (domain[1] < value) {\n        domain[1] = value;\n      }\n    }\n    return domain;\n  }\n  extend(value) {\n    if (this.domain[0] > value) {\n      this.domain[0] = value;\n    }\n    if (this.domain[1] < value) {\n      this.domain[1] = value;\n    }\n  }\n  getDomain() {\n    return [...this.domain];\n  }\n};\n\n// packages/ag-charts-community/src/chart/data/dataModel.ts\nfunction toKeyString(keys) {\n  return keys.map((key) => isObject(key) ? JSON.stringify(key) : key).join(\"-\");\n}\nfunction round2(val) {\n  const accuracy = 1e4;\n  if (Number.isInteger(val)) {\n    return val;\n  } else if (Math.abs(val) > accuracy) {\n    return Math.trunc(val);\n  }\n  return Math.round(val * accuracy) / accuracy;\n}\nfunction fixNumericExtentInternal(extent2) {\n  if (extent2 == null) {\n    return [];\n  }\n  let [min, max] = extent2.map(Number);\n  if (min === 0 && max === 0) {\n    return [0, 1];\n  }\n  if (min === Infinity && max === -Infinity) {\n    return [];\n  } else if (min === Infinity) {\n    min = 0;\n  } else if (max === -Infinity) {\n    max = 0;\n  }\n  return isFiniteNumber(min) && isFiniteNumber(max) ? [min, max] : [];\n}\nfunction fixNumericExtent(extent2, axis) {\n  const fixedExtent = fixNumericExtentInternal(extent2);\n  if (fixedExtent.length === 0) {\n    return fixedExtent;\n  }\n  let [min, max] = fixedExtent;\n  if (min === max) {\n    const [paddingMin, paddingMax] = axis?.calculatePadding(min, max) ?? [1, 1];\n    min -= paddingMin;\n    max += paddingMax;\n  }\n  return [min, max];\n}\nfunction getMissCount(scopeProvider, missMap) {\n  return missMap?.get(scopeProvider.id) ?? 0;\n}\nvar INVALID_VALUE = Symbol(\"invalid\");\nfunction getPathComponents(path) {\n  const components = [];\n  let matchIndex = 0;\n  let matchGroup;\n  const regExp = /((?:(?:^|\\.)\\s*\\w+|\\[\\s*(?:'(?:[^']|\\\\')*'|\"(?:[^\"]|\\\\\")*\"|-?\\d+)\\s*\\])\\s*)/g;\n  while (matchGroup = regExp.exec(path)) {\n    if (matchGroup.index !== matchIndex) {\n      return;\n    }\n    matchIndex = matchGroup.index + matchGroup[0].length;\n    const match = matchGroup[1].trim();\n    if (match.startsWith(\".\")) {\n      components.push(match.slice(1).trim());\n    } else if (match.startsWith(\"[\")) {\n      const accessor = match.slice(1, -1).trim();\n      if (accessor.startsWith(`'`)) {\n        components.push(accessor.slice(1, -1).replace(/(?<!\\\\)\\\\'/g, `'`));\n      } else if (accessor.startsWith(`\"`)) {\n        components.push(accessor.slice(1, -1).replace(/(?<!\\\\)\\\\\"/g, `\"`));\n      } else {\n        components.push(accessor);\n      }\n    } else {\n      components.push(match);\n    }\n  }\n  if (matchIndex !== path.length)\n    return;\n  return components;\n}\nfunction createPathAccessor(components) {\n  return (datum) => {\n    let current = datum;\n    for (const component of components) {\n      current = current[component];\n    }\n    return current;\n  };\n}\nvar DataModel = class {\n  constructor(opts, mode = \"standalone\") {\n    this.opts = opts;\n    this.mode = mode;\n    this.debug = Debug.create(true, \"data-model\");\n    this.scopeCache = /* @__PURE__ */ new Map();\n    this.keys = [];\n    this.values = [];\n    this.aggregates = [];\n    this.groupProcessors = [];\n    this.propertyProcessors = [];\n    this.reducers = [];\n    this.processors = [];\n    let keys = true;\n    for (const next of opts.props) {\n      if (next.type === \"key\" && !keys) {\n        throw new Error(\"AG Charts - internal config error: keys must come before values.\");\n      }\n      if (next.type === \"value\" && keys) {\n        keys = false;\n      }\n    }\n    const verifyMatchGroupId = ({ matchGroupIds = [] }) => {\n      for (const matchGroupId of matchGroupIds) {\n        if (this.values.every((def) => def.groupId !== matchGroupId)) {\n          throw new Error(\n            `AG Charts - internal config error: matchGroupIds properties must match defined groups (${matchGroupId}).`\n          );\n        }\n      }\n    };\n    for (const def of opts.props) {\n      switch (def.type) {\n        case \"key\":\n          this.keys.push({ ...def, index: this.keys.length, missing: /* @__PURE__ */ new Map() });\n          break;\n        case \"value\":\n          if (def.property == null) {\n            throw new Error(\n              `AG Charts - internal config error: no properties specified for value definitions: ${JSON.stringify(\n                def\n              )}`\n            );\n          }\n          this.values.push({ ...def, index: this.values.length, missing: /* @__PURE__ */ new Map() });\n          break;\n        case \"aggregate\":\n          verifyMatchGroupId(def);\n          this.aggregates.push({ ...def, index: this.aggregates.length });\n          break;\n        case \"group-value-processor\":\n          verifyMatchGroupId(def);\n          this.groupProcessors.push({ ...def, index: this.groupProcessors.length });\n          break;\n        case \"property-value-processor\":\n          this.propertyProcessors.push({ ...def, index: this.propertyProcessors.length });\n          break;\n        case \"reducer\":\n          this.reducers.push({ ...def, index: this.reducers.length });\n          break;\n        case \"processor\":\n          this.processors.push({ ...def, index: this.processors.length });\n          break;\n      }\n    }\n  }\n  resolveProcessedDataDefById(scope, searchId) {\n    const def = this.scopeCache.get(scope.id)?.get(searchId);\n    if (!def) {\n      throw new Error(`AG Charts - didn't find property definition for [${searchId}, ${scope.id}]`);\n    }\n    return { index: def.index, def };\n  }\n  resolveProcessedDataIndexById(scope, searchId) {\n    return this.resolveProcessedDataDefById(scope, searchId).index;\n  }\n  resolveProcessedDataDefsByIds(scope, searchIds) {\n    return searchIds.map((searchId) => [searchId, this.resolveProcessedDataDefById(scope, searchId)]);\n  }\n  resolveProcessedDataDefsValues(defs, { keys, values }) {\n    const result = {};\n    for (const [searchId, { index, def }] of defs) {\n      const processedData = def.type === \"key\" ? keys : values;\n      result[searchId] = processedData[index];\n    }\n    return result;\n  }\n  getDomain(scope, searchId, type = \"value\", processedData) {\n    const domains = this.getDomainsByType(type, processedData);\n    return domains?.[this.resolveProcessedDataIndexById(scope, searchId)] ?? [];\n  }\n  getDomainsByType(type, processedData) {\n    switch (type) {\n      case \"key\":\n        return processedData.domain.keys;\n      case \"value\":\n        return processedData.domain.values;\n      case \"aggregate\":\n        return processedData.domain.aggValues;\n      case \"group-value-processor\":\n        return processedData.domain.groups;\n      default:\n        return null;\n    }\n  }\n  processData(data, sources) {\n    const {\n      opts: { groupByKeys, groupByFn },\n      aggregates,\n      groupProcessors,\n      reducers,\n      processors,\n      propertyProcessors\n    } = this;\n    const start = performance.now();\n    if (groupByKeys && this.keys.length === 0) {\n      return;\n    }\n    let processedData = this.extractData(data, sources);\n    if (groupByKeys) {\n      processedData = this.groupData(processedData);\n    } else if (groupByFn) {\n      processedData = this.groupData(processedData, groupByFn(processedData));\n    }\n    if (groupProcessors.length > 0) {\n      this.postProcessGroups(processedData);\n    }\n    if (aggregates.length > 0) {\n      this.aggregateData(processedData);\n    }\n    if (propertyProcessors.length > 0) {\n      this.postProcessProperties(processedData);\n    }\n    if (reducers.length > 0) {\n      this.reduceData(processedData);\n    }\n    if (processors.length > 0) {\n      this.postProcessData(processedData);\n    }\n    if (data.length > 0) {\n      for (const def of iterate(this.keys, this.values)) {\n        for (const [scope, missCount] of def.missing) {\n          if (missCount >= data.length) {\n            const scopeHint = scope == null ? \"\" : ` for ${scope}`;\n            Logger.warnOnce(`the key '${def.property}' was not found in any data element${scopeHint}.`);\n          }\n        }\n      }\n    }\n    const end = performance.now();\n    processedData.time = end - start;\n    if (this.debug.check()) {\n      logProcessedData(processedData);\n    }\n    this.scopeCache.clear();\n    for (const def of iterate(this.keys, this.values, this.aggregates)) {\n      if (!def.idsMap)\n        continue;\n      for (const [scope, ids] of def.idsMap) {\n        for (const id of ids) {\n          if (!this.scopeCache.has(scope)) {\n            this.scopeCache.set(scope, /* @__PURE__ */ new Map([[id, def]]));\n          } else if (this.scopeCache.get(scope)?.has(id)) {\n            throw new Error(\"duplicate definition ids on the same scope are not allowed.\");\n          } else {\n            this.scopeCache.get(scope).set(id, def);\n          }\n        }\n      }\n    }\n    return processedData;\n  }\n  valueGroupIdxLookup({ matchGroupIds }) {\n    const result = [];\n    for (const [index, def] of this.values.entries()) {\n      if (!matchGroupIds || def.groupId && matchGroupIds.includes(def.groupId)) {\n        result.push(index);\n      }\n    }\n    return result;\n  }\n  valueIdxLookup(scopes, prop) {\n    const noScopesToMatch = scopes == null || scopes.length === 0;\n    const propId = typeof prop === \"string\" ? prop : prop.id;\n    const hasMatchingScopeId = (def) => {\n      if (def.idsMap) {\n        for (const [scope, ids] of def.idsMap) {\n          if (scopes?.includes(scope) && ids.has(propId)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const result = this.values.findIndex((def) => {\n      const validDefScopes = def.scopes == null || noScopesToMatch && !def.scopes.length || def.scopes.some((s) => scopes?.includes(s));\n      return validDefScopes && (def.property === propId || def.id === propId || hasMatchingScopeId(def));\n    });\n    if (result === -1) {\n      throw new Error(\n        `AG Charts - configuration error, unknown property ${JSON.stringify(prop)} in scope(s) ${JSON.stringify(\n          scopes\n        )}`\n      );\n    }\n    return result;\n  }\n  extractData(data, sources) {\n    const { dataDomain, processValue, scopes, allScopesHaveSameDefs } = this.initDataDomainProcessor();\n    const sourcesById = new Map(sources?.map((s) => [s.id, s]));\n    const { keys: keyDefs, values: valueDefs } = this;\n    const resultData = new Array(data.length);\n    let resultDataIdx = 0;\n    let partialValidDataCount = 0;\n    for (const [datumIdx, datum] of data.entries()) {\n      const sourceDatums = {};\n      const validScopes = scopes.size > 0 ? new Set(scopes) : void 0;\n      const keys = new Array(keyDefs.length);\n      let keyIdx = 0;\n      let key;\n      for (const def of keyDefs) {\n        key = processValue(def, datum, key);\n        if (key === INVALID_VALUE)\n          break;\n        if (keys) {\n          keys[keyIdx++] = key;\n        }\n      }\n      if (key === INVALID_VALUE)\n        continue;\n      const values = valueDefs.length > 0 ? new Array(valueDefs.length) : void 0;\n      let value;\n      for (const [valueDefIdx, def] of valueDefs.entries()) {\n        for (const scope of def.scopes ?? scopes) {\n          const source = sourcesById.get(scope);\n          const valueDatum = source?.data[datumIdx] ?? datum;\n          value = processValue(def, valueDatum, value, scope);\n          if (value === INVALID_VALUE || !values)\n            continue;\n          if (source != null && def.includeProperty !== false) {\n            const property = def.includeProperty && def.id != null ? def.id : def.property;\n            sourceDatums[scope] ?? (sourceDatums[scope] = {});\n            sourceDatums[scope][property] = value;\n          }\n          values[valueDefIdx] = value;\n        }\n        if (value === INVALID_VALUE) {\n          if (allScopesHaveSameDefs)\n            break;\n          for (const scope of def.scopes ?? scopes) {\n            validScopes?.delete(scope);\n          }\n          if (validScopes?.size === 0)\n            break;\n        }\n      }\n      if (value === INVALID_VALUE && allScopesHaveSameDefs)\n        continue;\n      if (validScopes?.size === 0)\n        continue;\n      const result = { datum: { ...datum, ...sourceDatums }, keys, values };\n      if (!allScopesHaveSameDefs && validScopes && validScopes.size < scopes.size) {\n        partialValidDataCount++;\n        result.validScopes = new Set(validScopes);\n      }\n      resultData[resultDataIdx++] = result;\n    }\n    resultData.length = resultDataIdx;\n    const propertyDomain = (def) => {\n      const defDomain = dataDomain.get(def);\n      const result = defDomain.getDomain();\n      if (ContinuousDomain.is(defDomain) && result[0] > result[1]) {\n        return [];\n      }\n      return result;\n    };\n    return {\n      type: \"ungrouped\",\n      input: { count: data.length },\n      data: resultData,\n      domain: {\n        keys: keyDefs.map(propertyDomain),\n        values: valueDefs.map(propertyDomain)\n      },\n      defs: {\n        allScopesHaveSameDefs,\n        keys: keyDefs,\n        values: valueDefs\n      },\n      partialValidDataCount,\n      time: 0\n    };\n  }\n  groupData(data, groupingFn) {\n    const processedData = /* @__PURE__ */ new Map();\n    for (const dataEntry of data.data) {\n      const { keys, values, datum, validScopes } = dataEntry;\n      const group = groupingFn?.(dataEntry) ?? keys;\n      const groupStr = toKeyString(group);\n      if (processedData.has(groupStr)) {\n        const existingData = processedData.get(groupStr);\n        existingData.values.push(values);\n        existingData.datum.push(datum);\n        if (validScopes != null && existingData.validScopes != null) {\n          for (const scope of existingData.validScopes) {\n            if (!validScopes.has(scope)) {\n              existingData.validScopes.delete(scope);\n            }\n          }\n        }\n      } else {\n        processedData.set(groupStr, {\n          keys: group,\n          values: [values],\n          datum: [datum],\n          validScopes\n        });\n      }\n    }\n    const resultData = new Array(processedData.size);\n    const resultGroups = new Array(processedData.size);\n    let dataIndex = 0;\n    for (const { keys, values, datum, validScopes } of processedData.values()) {\n      if (validScopes?.size === 0)\n        continue;\n      resultGroups[dataIndex] = keys;\n      resultData[dataIndex++] = {\n        keys,\n        values,\n        datum,\n        validScopes\n      };\n    }\n    return {\n      ...data,\n      type: \"grouped\",\n      data: resultData,\n      domain: {\n        ...data.domain,\n        groups: resultGroups\n      }\n    };\n  }\n  aggregateData(processedData) {\n    const isUngrouped = processedData.type === \"ungrouped\";\n    processedData.domain.aggValues = [];\n    for (const [index, def] of this.aggregates.entries()) {\n      const indices = this.valueGroupIdxLookup(def);\n      const domain = [Infinity, -Infinity];\n      for (const datum of processedData.data) {\n        datum.aggValues ?? (datum.aggValues = new Array(this.aggregates.length));\n        if (datum.validScopes)\n          continue;\n        const values = isUngrouped ? [datum.values] : datum.values;\n        let groupAggValues = def.groupAggregateFunction?.() ?? [Infinity, -Infinity];\n        for (const distinctValues of values) {\n          const valuesToAgg = indices.map((valueIdx) => distinctValues[valueIdx]);\n          const valuesAgg = def.aggregateFunction(valuesToAgg, datum.keys);\n          if (valuesAgg) {\n            groupAggValues = def.groupAggregateFunction?.(valuesAgg, groupAggValues) ?? ContinuousDomain.extendDomain(valuesAgg, groupAggValues);\n          }\n        }\n        const finalValues = (def.finalFunction?.(groupAggValues) ?? groupAggValues).map((v) => round2(v));\n        datum.aggValues[index] = finalValues;\n        ContinuousDomain.extendDomain(finalValues, domain);\n      }\n      processedData.domain.aggValues.push(domain);\n    }\n  }\n  postProcessGroups(processedData) {\n    const { groupProcessors } = this;\n    const affectedIndices = /* @__PURE__ */ new Set();\n    const updatedDomains = /* @__PURE__ */ new Map();\n    const groupProcessorIndices = /* @__PURE__ */ new Map();\n    const groupProcessorInitFns = /* @__PURE__ */ new Map();\n    for (const processor of groupProcessors) {\n      const indices = this.valueGroupIdxLookup(processor);\n      groupProcessorIndices.set(processor, indices);\n      groupProcessorInitFns.set(processor, processor.adjust());\n      for (const idx of indices) {\n        const valueDef = this.values[idx];\n        const isDiscrete = valueDef.valueType === \"category\";\n        affectedIndices.add(idx);\n        updatedDomains.set(idx, isDiscrete ? new DiscreteDomain() : new ContinuousDomain());\n      }\n    }\n    const updateDomains = (values) => {\n      for (const valueIndex of affectedIndices) {\n        updatedDomains.get(valueIndex)?.extend(values[valueIndex]);\n      }\n    };\n    for (const group of processedData.data) {\n      for (const processor of groupProcessors) {\n        if (group.validScopes)\n          continue;\n        const valueIndexes = groupProcessorIndices.get(processor) ?? [];\n        const adjustFn = groupProcessorInitFns.get(processor)?.();\n        if (!adjustFn)\n          continue;\n        if (processedData.type === \"grouped\") {\n          for (const values of group.values) {\n            if (values) {\n              adjustFn(values, valueIndexes);\n            }\n          }\n        } else if (group.values) {\n          adjustFn(group.values, valueIndexes);\n        }\n      }\n      if (processedData.type === \"grouped\") {\n        for (const values of group.values) {\n          updateDomains(values);\n        }\n      } else {\n        updateDomains(group.values);\n      }\n    }\n    for (const [idx, dataDomain] of updatedDomains) {\n      processedData.domain.values[idx] = dataDomain.getDomain();\n    }\n  }\n  postProcessProperties(processedData) {\n    for (const { adjust, property, scopes } of this.propertyProcessors) {\n      adjust()(processedData, this.valueIdxLookup(scopes, property));\n    }\n  }\n  reduceData(processedData) {\n    processedData.reduced ?? (processedData.reduced = {});\n    for (const def of this.reducers) {\n      const reducer = def.reducer();\n      let accValue = def.initialValue;\n      for (const datum of processedData.data) {\n        if (!datum.validScopes || def.scopes?.some((s) => datum.validScopes?.has(s))) {\n          accValue = reducer(accValue, datum);\n        }\n      }\n      processedData.reduced[def.property] = accValue;\n    }\n  }\n  postProcessData(processedData) {\n    processedData.reduced ?? (processedData.reduced = {});\n    for (const def of this.processors) {\n      processedData.reduced[def.property] = def.calculate(processedData);\n    }\n  }\n  initDataDomainProcessor() {\n    const { keys: keyDefs, values: valueDefs } = this;\n    const scopes = /* @__PURE__ */ new Set();\n    for (const valueDef of valueDefs) {\n      if (!valueDef.scopes)\n        continue;\n      for (const scope of valueDef.scopes) {\n        scopes.add(scope);\n      }\n    }\n    const dataDomain = /* @__PURE__ */ new Map();\n    const processorFns = /* @__PURE__ */ new Map();\n    let allScopesHaveSameDefs = true;\n    const initDataDomain = () => {\n      for (const def of iterate(keyDefs, valueDefs)) {\n        if (def.valueType === \"category\") {\n          dataDomain.set(def, new DiscreteDomain());\n        } else {\n          dataDomain.set(def, new ContinuousDomain());\n          allScopesHaveSameDefs && (allScopesHaveSameDefs = (def.scopes ?? []).length === scopes.size);\n        }\n      }\n    };\n    initDataDomain();\n    const accessors = this.buildAccessors(iterate(keyDefs, valueDefs));\n    const processValue = (def, datum, previousDatum, scope) => {\n      let valueInDatum;\n      let value;\n      if (accessors.has(def.property)) {\n        try {\n          value = accessors.get(def.property)(datum);\n        } catch (error) {\n        }\n        valueInDatum = value != null;\n      } else {\n        valueInDatum = def.property in datum;\n        value = valueInDatum ? datum[def.property] : def.missingValue;\n      }\n      if (def.forceValue != null) {\n        const valueNegative = valueInDatum && isNegative(value);\n        value = valueNegative ? -1 * def.forceValue : def.forceValue;\n        valueInDatum = true;\n      }\n      const missingValueDef = \"missingValue\" in def;\n      if (!valueInDatum && !missingValueDef) {\n        const missCount = def.missing.get(scope) ?? 0;\n        def.missing.set(scope, missCount + 1);\n      }\n      if (!dataDomain.has(def)) {\n        initDataDomain();\n      }\n      if (valueInDatum && def.validation?.(value, datum) === false) {\n        if (\"invalidValue\" in def) {\n          value = def.invalidValue;\n        } else {\n          if (this.mode !== \"integrated\") {\n            Logger.warnOnce(\n              `invalid value of type [${typeof value}] for [${def.scopes} / ${def.id}] ignored:`,\n              `[${value}]`\n            );\n          }\n          return INVALID_VALUE;\n        }\n      }\n      if (def.processor) {\n        if (!processorFns.has(def)) {\n          processorFns.set(def, def.processor());\n        }\n        value = processorFns.get(def)?.(value, previousDatum === INVALID_VALUE ? void 0 : previousDatum);\n      }\n      dataDomain.get(def)?.extend(value);\n      return value;\n    };\n    return { dataDomain, processValue, initDataDomain, scopes, allScopesHaveSameDefs };\n  }\n  buildAccessors(defs) {\n    const result = /* @__PURE__ */ new Map();\n    if (this.mode === \"integrated\") {\n      return result;\n    }\n    for (const def of defs) {\n      const isPath = def.property.includes(\".\") || def.property.includes(\"[\");\n      if (!isPath)\n        continue;\n      const components = getPathComponents(def.property);\n      if (components == null) {\n        Logger.warnOnce(\"Invalid property path [%s]\", def.property);\n        continue;\n      }\n      const accessor = createPathAccessor(components);\n      result.set(def.property, accessor);\n    }\n    return result;\n  }\n};\nfunction logProcessedData(processedData) {\n  const logValues = (name, data) => {\n    if (data.length > 0) {\n      Logger.log(`DataModel.processData() - ${name}`);\n      Logger.table(data);\n    }\n  };\n  Logger.log(\"DataModel.processData() - processedData\", processedData);\n  logValues(\"Key Domains\", processedData.domain.keys);\n  logValues(\"Group Domains\", processedData.domain.groups ?? []);\n  logValues(\"Value Domains\", processedData.domain.values);\n  logValues(\"Aggregate Domains\", processedData.domain.aggValues ?? []);\n  if (processedData.type === \"grouped\") {\n    const flattenedValues = processedData.data.reduce((acc, next) => {\n      const keys = next.keys ?? [];\n      const aggValues = next.aggValues ?? [];\n      const skipKeys = next.keys.map(() => void 0);\n      const skipAggValues = aggValues?.map(() => void 0);\n      acc.push(\n        ...next.values.map((v, i) => [\n          ...i === 0 ? keys : skipKeys,\n          ...v ?? [],\n          ...i == 0 ? aggValues : skipAggValues\n        ])\n      );\n      return acc;\n    }, []);\n    logValues(\"Values\", flattenedValues);\n  } else {\n    const flattenedValues = processedData.data.reduce((acc, next) => {\n      const aggValues = next.aggValues ?? [];\n      acc.push([...next.keys, ...next.values, ...aggValues]);\n      return acc;\n    }, []);\n    logValues(\"Values\", flattenedValues);\n  }\n}\n\n// packages/ag-charts-community/src/chart/data/dataController.ts\nvar _DataController = class _DataController {\n  constructor(mode) {\n    this.mode = mode;\n    this.debug = Debug.create(true, \"data-model\");\n    this.requested = [];\n    this.status = \"setup\";\n  }\n  async request(id, data, opts) {\n    if (this.status !== \"setup\") {\n      throw new Error(`AG Charts - data request after data setup phase.`);\n    }\n    return new Promise((resolve, reject) => {\n      this.requested.push({ id, opts, data, resolve, reject });\n    });\n  }\n  execute() {\n    if (this.status !== \"setup\") {\n      throw new Error(`AG Charts - data request after data setup phase.`);\n    }\n    this.status = \"executed\";\n    this.debug(\"DataController.execute() - requested\", this.requested);\n    const valid = this.validateRequests(this.requested);\n    this.debug(\"DataController.execute() - validated\", valid);\n    const merged = this.mergeRequested(valid);\n    this.debug(\"DataController.execute() - merged\", merged);\n    if (this.debug.check()) {\n      getWindow().processedData = [];\n    }\n    const scopes = this.requested.map(({ id }) => id);\n    const needsValueExtraction = this.hasMultipleDataSources(valid);\n    for (const { opts, data, resolves, rejects, ids } of merged) {\n      try {\n        const dataModel = new DataModel(opts, this.mode);\n        const processedData = dataModel.processData(data, valid);\n        if (this.debug.check()) {\n          getWindow(\"processedData\").push(processedData);\n        }\n        if (processedData?.partialValidDataCount === 0) {\n          resolves.forEach(\n            (resolve, requestIdx) => resolve({\n              dataModel,\n              processedData: this.processScopedData(\n                ids[requestIdx],\n                processedData,\n                scopes,\n                needsValueExtraction\n              )\n            })\n          );\n        } else if (processedData) {\n          this.splitResult(dataModel, processedData, ids, resolves);\n        } else {\n          rejects.forEach((cb) => cb(new Error(`AG Charts - no processed data generated`)));\n        }\n      } catch (error) {\n        rejects.forEach((cb) => cb(error));\n      }\n    }\n  }\n  hasMultipleDataSources(validRequests) {\n    if (validRequests.length) {\n      const [{ data }, ...restRequests] = validRequests;\n      return restRequests.some((v) => data !== v.data);\n    }\n    return false;\n  }\n  processScopedData(id, processedData, ids, needsValueExtraction) {\n    const extractDatum = (datum) => {\n      if (Array.isArray(datum)) {\n        return datum.map(extractDatum);\n      }\n      const extracted = needsValueExtraction ? { ...datum, ...datum[id] } : datum;\n      for (const otherId of ids) {\n        delete extracted[otherId];\n      }\n      return extracted;\n    };\n    const extractValues = (values) => {\n      if (Array.isArray(values)) {\n        return values.map(extractValues);\n      }\n      return values?.[id] ?? values;\n    };\n    return {\n      ...processedData,\n      data: processedData.data.map((datum) => ({\n        ...datum,\n        datum: extractDatum(datum.datum),\n        values: needsValueExtraction ? datum.values?.map(extractValues) : datum.values\n      }))\n    };\n  }\n  validateRequests(requested) {\n    const valid = [];\n    for (const [index, request] of requested.entries()) {\n      if (index > 0 && request.data.length !== requested[0].data.length && request.opts.groupByData === false) {\n        request.reject(\n          new Error(\"all series[].data arrays must be of the same length and have matching keys.\")\n        );\n      } else {\n        valid.push(request);\n      }\n    }\n    return valid;\n  }\n  mergeRequested(requested) {\n    const grouped = [];\n    for (const request of requested) {\n      const match = grouped.find(_DataController.groupMatch(request));\n      if (match) {\n        match.push(request);\n      } else {\n        grouped.push([request]);\n      }\n    }\n    return grouped.map(_DataController.mergeRequests);\n  }\n  splitResult(dataModel, processedData, scopes, resolves) {\n    for (let i = 0; i < scopes.length; i++) {\n      const scope = scopes[i];\n      const resolve = resolves[i];\n      resolve({\n        dataModel,\n        processedData: {\n          ...processedData,\n          data: processedData.data.filter(({ validScopes }) => validScopes?.has(scope) ?? true)\n        }\n      });\n    }\n  }\n  static groupMatch({ data, opts }) {\n    function keys(props) {\n      return props.filter((p) => p.type === \"key\").map((p) => p.property).join(\";\");\n    }\n    return ([group]) => (opts.groupByData === false || group.data === data) && group.opts.groupByKeys === opts.groupByKeys && group.opts.groupByFn === opts.groupByFn && keys(group.opts.props) === keys(opts.props);\n  }\n  static mergeRequests(requests) {\n    return requests.reduce(\n      (result, { id, data, resolve, reject, opts: { props, ...opts } }) => {\n        result.ids.push(id);\n        result.rejects.push(reject);\n        result.resolves.push(resolve);\n        result.data ?? (result.data = data);\n        result.opts ?? (result.opts = { ...opts, props: [] });\n        for (const prop of props) {\n          const clone = { ...prop, scopes: [id] };\n          _DataController.createIdsMap(id, clone);\n          const match = result.opts.props.find(\n            (existing) => existing.type === clone.type && _DataController.deepEqual(existing, clone)\n          );\n          if (!match) {\n            result.opts.props.push(clone);\n            continue;\n          }\n          match.scopes ?? (match.scopes = []);\n          match.scopes.push(...clone.scopes ?? []);\n          if ((match.type === \"key\" || match.type === \"value\") && clone.idsMap?.size) {\n            _DataController.mergeIdsMap(clone.idsMap, match.idsMap);\n          }\n        }\n        return result;\n      },\n      { ids: [], rejects: [], resolves: [], data: null, opts: null }\n    );\n  }\n  static mergeIdsMap(fromMap, toMap) {\n    for (const [scope, ids] of fromMap) {\n      const toMapValue = toMap.get(scope);\n      if (toMapValue != null) {\n        for (const id of ids) {\n          toMapValue.add(id);\n        }\n      } else {\n        toMap.set(scope, new Set(ids));\n      }\n    }\n  }\n  static createIdsMap(scope, prop) {\n    if (prop.id == null)\n      return;\n    prop.idsMap ?? (prop.idsMap = /* @__PURE__ */ new Map());\n    if (prop.idsMap.has(scope)) {\n      prop.idsMap.get(scope).add(prop.id);\n    } else {\n      prop.idsMap.set(scope, /* @__PURE__ */ new Set([prop.id]));\n    }\n  }\n  static deepEqual(a, b) {\n    if (a === b) {\n      return true;\n    }\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n      if (a.constructor !== b.constructor) {\n        return false;\n      }\n      let i, length2;\n      if (Array.isArray(a)) {\n        length2 = a.length;\n        if (length2 !== b.length) {\n          return false;\n        }\n        for (i = length2 - 1; i >= 0; i--) {\n          if (!_DataController.deepEqual(a[i], b[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      const keys = Object.keys(a);\n      length2 = keys.length;\n      if (length2 !== Object.keys(b).length) {\n        return false;\n      }\n      for (i = length2 - 1; i >= 0; i--) {\n        const key = keys[i];\n        if (!_DataController.skipKeys.has(key) && (!Object.hasOwn(b, key) || !_DataController.deepEqual(a[key], b[key]))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n};\n// optimized version of deep equality for `mergeRequests` which can potentially loop over 1M times\n_DataController.skipKeys = /* @__PURE__ */ new Set([\"id\", \"idsMap\", \"type\", \"scopes\"]);\nvar DataController = _DataController;\n\n// packages/ag-charts-community/src/chart/factory/axisRegistry.ts\nvar AxisRegistry = class {\n  constructor() {\n    this.axesMap = /* @__PURE__ */ new Map();\n    this.hidden = /* @__PURE__ */ new Set();\n    this.themeTemplates = /* @__PURE__ */ new Map();\n  }\n  register(axisType, module) {\n    this.axesMap.set(axisType, module.moduleFactory);\n    if (module.themeTemplate) {\n      this.setThemeTemplate(axisType, module.themeTemplate);\n    }\n    if (module.hidden) {\n      this.hidden.add(axisType);\n    }\n  }\n  create(axisType, moduleContext) {\n    const axisFactory = this.axesMap.get(axisType);\n    if (axisFactory) {\n      return axisFactory(moduleContext);\n    }\n    throw new Error(`AG Charts - unknown axis type: ${axisType}`);\n  }\n  has(axisType) {\n    return this.axesMap.has(axisType);\n  }\n  keys() {\n    return this.axesMap.keys();\n  }\n  publicKeys() {\n    return [...this.keys()].filter((k) => !this.hidden.has(k));\n  }\n  setThemeTemplate(axisType, themeTemplate) {\n    this.themeTemplates.set(axisType, themeTemplate);\n    return this;\n  }\n  getThemeTemplate(axisType) {\n    return this.themeTemplates.get(axisType);\n  }\n};\nvar axisRegistry = new AxisRegistry();\n\n// packages/ag-charts-community/src/chart/factory/expectedEnterpriseModules.ts\nvar EXPECTED_ENTERPRISE_MODULES = [\n  {\n    type: \"root\",\n    optionsKey: \"animation\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"]\n  },\n  { type: \"root\", optionsKey: \"annotations\", chartTypes: [\"cartesian\"] },\n  {\n    type: \"root\",\n    optionsKey: \"background\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n    optionsInnerKey: \"image\"\n  },\n  {\n    type: \"root\",\n    optionsKey: \"foreground\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n    optionsInnerKey: \"image\"\n  },\n  {\n    type: \"root\",\n    optionsKey: \"chartToolbar\",\n    chartTypes: [\"cartesian\"]\n  },\n  {\n    type: \"root\",\n    optionsKey: \"contextMenu\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"]\n  },\n  { type: \"root\", optionsKey: \"statusBar\", chartTypes: [\"cartesian\"], identifier: \"status-bar\" },\n  {\n    type: \"root\",\n    optionsKey: \"dataSource\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"]\n  },\n  { type: \"root\", optionsKey: \"sync\", chartTypes: [\"cartesian\"] },\n  { type: \"root\", optionsKey: \"zoom\", chartTypes: [\"cartesian\", \"topology\"] },\n  {\n    type: \"legend\",\n    optionsKey: \"gradientLegend\",\n    chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n    identifier: \"gradient\"\n  },\n  { type: \"root\", optionsKey: \"navigator\", chartTypes: [\"cartesian\"], optionsInnerKey: \"miniChart\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"angle-category\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"angle-number\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"radius-category\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"polar\"], identifier: \"radius-number\" },\n  { type: \"axis\", optionsKey: \"axes[]\", chartTypes: [\"cartesian\"], identifier: \"ordinal-time\" },\n  { type: \"axis-option\", optionsKey: \"crosshair\", chartTypes: [\"cartesian\"] },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"box-plot\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"candlestick\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"ohlc\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"bullet\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"heatmap\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"range-area\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"range-bar\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"cartesian\"], identifier: \"waterfall\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"nightingale\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radar-area\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radar-line\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radial-bar\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"polar\"], identifier: \"radial-column\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"hierarchy\"], identifier: \"sunburst\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"hierarchy\"], identifier: \"treemap\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-shape\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-line\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-marker\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-shape-background\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"topology\"], identifier: \"map-line-background\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"flow-proportion\"], identifier: \"chord\" },\n  { type: \"series\", optionsKey: \"series[]\", chartTypes: [\"flow-proportion\"], identifier: \"sankey\" },\n  { type: \"series-option\", optionsKey: \"errorBar\", chartTypes: [\"cartesian\"], identifier: \"error-bars\" }\n];\nfunction isEnterpriseSeriesType(type) {\n  return EXPECTED_ENTERPRISE_MODULES.some((s) => s.type === \"series\" && s.identifier === type);\n}\nfunction getEnterpriseSeriesChartTypes(type) {\n  return EXPECTED_ENTERPRISE_MODULES.find((s) => s.type === \"series\" && s.identifier === type)?.chartTypes;\n}\nfunction isEnterpriseCartesian(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"cartesian\");\n  return type === \"cartesian\";\n}\nfunction isEnterprisePolar(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"polar\");\n  return type === \"polar\";\n}\nfunction isEnterpriseHierarchy(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"hierarchy\");\n  return type === \"hierarchy\";\n}\nfunction isEnterpriseTopology(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"topology\");\n  return type === \"topology\";\n}\nfunction isEnterpriseFlowProportion(seriesType2) {\n  const type = getEnterpriseSeriesChartTypes(seriesType2)?.find((v) => v === \"flow-proportion\");\n  return type === \"flow-proportion\";\n}\nfunction isEnterpriseModule(module) {\n  return module.packageType === \"enterprise\";\n}\nfunction verifyIfModuleExpected(module) {\n  if (!isEnterpriseModule(module)) {\n    throw new Error(\"AG Charts - internal configuration error, only enterprise modules need verification.\");\n  }\n  const stub = EXPECTED_ENTERPRISE_MODULES.find((s) => {\n    return s.type === module.type && s.optionsKey === module.optionsKey && s.identifier === module.identifier && module.chartTypes.every((t) => s.chartTypes.includes(t));\n  });\n  if (stub) {\n    stub.useCount ?? (stub.useCount = 0);\n    stub.useCount++;\n  }\n  return stub != null;\n}\nfunction getUnusedExpectedModules() {\n  return EXPECTED_ENTERPRISE_MODULES.filter(({ useCount }) => useCount == null || useCount === 0);\n}\n\n// packages/ag-charts-community/src/chart/factory/legendRegistry.ts\nvar LegendRegistry = class {\n  constructor() {\n    this.legendMap = /* @__PURE__ */ new Map();\n    this.themeTemplates = /* @__PURE__ */ new Map();\n  }\n  register(legendType, { optionsKey, moduleFactory, themeTemplate }) {\n    this.legendMap.set(legendType, { optionsKey, moduleFactory });\n    this.themeTemplates.set(optionsKey, themeTemplate);\n  }\n  create(legendType, moduleContext) {\n    const legendFactory = this.legendMap.get(legendType)?.moduleFactory;\n    if (legendFactory) {\n      return legendFactory(moduleContext);\n    }\n    throw new Error(`AG Charts - unknown legend type: ${legendType}`);\n  }\n  getThemeTemplates() {\n    return Object.fromEntries(this.themeTemplates);\n  }\n  getKeys() {\n    return Array.from(this.legendMap.entries()).reduce(\n      (result, [legendType, record]) => {\n        result[legendType] = record.optionsKey;\n        return result;\n      },\n      {}\n    );\n  }\n};\nvar legendRegistry = new LegendRegistry();\n\n// packages/ag-charts-community/src/chart/factory/chartTypes.ts\nvar ChartTypes = class extends Map {\n  get(seriesType2) {\n    return super.get(seriesType2) ?? \"unknown\";\n  }\n  isCartesian(seriesType2) {\n    return this.get(seriesType2) === \"cartesian\";\n  }\n  isPolar(seriesType2) {\n    return this.get(seriesType2) === \"polar\";\n  }\n  isHierarchy(seriesType2) {\n    return this.get(seriesType2) === \"hierarchy\";\n  }\n  isTopology(seriesType2) {\n    return this.get(seriesType2) === \"topology\";\n  }\n  isFlowProportion(seriesType2) {\n    return this.get(seriesType2) === \"flow-proportion\";\n  }\n  get seriesTypes() {\n    return Array.from(this.keys());\n  }\n  get cartesianTypes() {\n    return this.seriesTypes.filter((t) => this.isCartesian(t));\n  }\n  get polarTypes() {\n    return this.seriesTypes.filter((t) => this.isPolar(t));\n  }\n  get hierarchyTypes() {\n    return this.seriesTypes.filter((t) => this.isHierarchy(t));\n  }\n  get topologyTypes() {\n    return this.seriesTypes.filter((t) => this.isTopology(t));\n  }\n  get flowProportionTypes() {\n    return this.seriesTypes.filter((t) => this.isFlowProportion(t));\n  }\n};\nvar ChartDefaults = class extends Map {\n  set(chartType2, defaults) {\n    return super.set(chartType2, mergeDefaults(defaults, this.get(chartType2)));\n  }\n};\nvar chartTypes = new ChartTypes();\nvar publicChartTypes = new ChartTypes();\nvar chartDefaults = new ChartDefaults();\n\n// packages/ag-charts-community/src/chart/factory/seriesRegistry.ts\nvar SeriesRegistry = class {\n  constructor() {\n    this.seriesMap = /* @__PURE__ */ new Map();\n    this.themeTemplates = /* @__PURE__ */ new Map();\n  }\n  register(seriesType2, {\n    chartTypes: [chartType2],\n    moduleFactory,\n    tooltipDefaults,\n    defaultAxes,\n    themeTemplate,\n    paletteFactory,\n    solo,\n    stackable,\n    groupable,\n    stackedByDefault,\n    swapDefaultAxesCondition,\n    hidden\n  }) {\n    this.setThemeTemplate(seriesType2, themeTemplate);\n    this.seriesMap.set(seriesType2, {\n      moduleFactory,\n      tooltipDefaults,\n      defaultAxes,\n      paletteFactory,\n      solo,\n      stackable,\n      groupable,\n      stackedByDefault,\n      swapDefaultAxesCondition\n    });\n    chartTypes.set(seriesType2, chartType2);\n    if (!hidden) {\n      publicChartTypes.set(seriesType2, chartType2);\n    }\n  }\n  create(seriesType2, moduleContext) {\n    const seriesFactory = this.seriesMap.get(seriesType2)?.moduleFactory;\n    if (seriesFactory) {\n      return seriesFactory(moduleContext);\n    }\n    throw new Error(`AG Charts - unknown series type: ${seriesType2}`);\n  }\n  cloneDefaultAxes(seriesType2) {\n    const defaultAxes = this.seriesMap.get(seriesType2)?.defaultAxes;\n    return defaultAxes ? { axes: deepClone(defaultAxes) } : null;\n  }\n  setThemeTemplate(seriesType2, themeTemplate) {\n    const currentTemplate = this.themeTemplates.get(seriesType2);\n    this.themeTemplates.set(seriesType2, mergeDefaults(themeTemplate, currentTemplate));\n  }\n  getThemeTemplate(seriesType2) {\n    return this.themeTemplates.get(seriesType2);\n  }\n  getPaletteFactory(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.paletteFactory;\n  }\n  getTooltipDefauls(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.tooltipDefaults;\n  }\n  isSolo(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.solo ?? false;\n  }\n  isGroupable(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.groupable ?? false;\n  }\n  isStackable(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.stackable ?? false;\n  }\n  isStackedByDefault(seriesType2) {\n    return this.seriesMap.get(seriesType2)?.stackedByDefault ?? false;\n  }\n  isDefaultAxisSwapNeeded(options) {\n    let result;\n    for (const series of options.series ?? []) {\n      const { type = \"line\" } = series;\n      const isDefaultAxisSwapped = this.seriesMap.get(type)?.swapDefaultAxesCondition?.(series);\n      if (isDefaultAxisSwapped != null) {\n        if (result != null && result != isDefaultAxisSwapped) {\n          throw new Error(\"AG Charts - The provided series have incompatible directions\");\n        }\n        result = isDefaultAxisSwapped;\n      }\n    }\n    return result;\n  }\n};\nvar seriesRegistry = new SeriesRegistry();\n\n// packages/ag-charts-community/src/chart/interaction/syncManager.ts\nvar _SyncManager = class _SyncManager extends BaseManager {\n  constructor(chart) {\n    super();\n    this.chart = chart;\n  }\n  subscribe(groupId = _SyncManager.DEFAULT_GROUP) {\n    let syncGroup = this.get(groupId);\n    if (!syncGroup) {\n      syncGroup = /* @__PURE__ */ new Set();\n      _SyncManager.chartsGroups.set(groupId, syncGroup);\n    }\n    syncGroup.add(this.chart);\n    return this;\n  }\n  unsubscribe(groupId = _SyncManager.DEFAULT_GROUP) {\n    this.get(groupId)?.delete(this.chart);\n    return this;\n  }\n  getChart() {\n    return this.chart;\n  }\n  getGroup(groupId = _SyncManager.DEFAULT_GROUP) {\n    const syncGroup = this.get(groupId);\n    return syncGroup ? Array.from(syncGroup) : [];\n  }\n  getGroupSiblings(groupId = _SyncManager.DEFAULT_GROUP) {\n    return this.getGroup(groupId).filter((chart) => chart !== this.chart);\n  }\n  get(groupId) {\n    return _SyncManager.chartsGroups.get(groupId);\n  }\n};\n_SyncManager.chartsGroups = /* @__PURE__ */ new Map();\n_SyncManager.DEFAULT_GROUP = Symbol(\"sync-group-default\");\nvar SyncManager = _SyncManager;\n\n// packages/ag-charts-community/src/chart/interaction/zoomManager.ts\nvar ZoomManager = class extends BaseManager {\n  constructor() {\n    super(...arguments);\n    this.axisZoomManagers = /* @__PURE__ */ new Map();\n    this.state = new StateTracker(void 0, \"initial\");\n    this.rejectCallbacks = /* @__PURE__ */ new Map();\n  }\n  updateAxes(axes) {\n    const zoomManagers = new Map(axes.map((axis) => [axis.id, this.axisZoomManagers.get(axis.id)]));\n    this.axisZoomManagers.clear();\n    for (const axis of axes) {\n      this.axisZoomManagers.set(axis.id, zoomManagers.get(axis.id) ?? new AxisZoomManager(axis));\n    }\n    if (this.state.size > 0 && axes.length > 0) {\n      this.updateZoom(this.state.stateId(), this.state.stateValue());\n    }\n  }\n  updateZoom(callerId, newZoom, canChangeInitial = true, rejectCallback) {\n    if (rejectCallback) {\n      this.rejectCallbacks.set(callerId, rejectCallback);\n    }\n    if (this.axisZoomManagers.size === 0) {\n      const stateId = this.state.stateId();\n      if (stateId === \"initial\" || stateId === callerId || canChangeInitial) {\n        this.state.set(callerId, newZoom);\n        if (stateId !== callerId) {\n          this.rejectCallbacks.get(stateId)?.(callerId);\n        }\n      } else {\n        rejectCallback?.(stateId);\n      }\n      return;\n    }\n    this.state.set(callerId, newZoom);\n    this.axisZoomManagers.forEach((axis) => {\n      axis.updateZoom(callerId, newZoom?.[axis.getDirection()]);\n    });\n    this.applyChanges(callerId);\n  }\n  updateAxisZoom(callerId, axisId, newZoom) {\n    this.axisZoomManagers.get(axisId)?.updateZoom(callerId, newZoom);\n    this.applyChanges(callerId);\n  }\n  // Fire this event to signal to listeners that the view is changing through a zoom and/or pan change.\n  fireZoomPanStartEvent(callerId) {\n    this.listeners.dispatch(\"zoom-pan-start\", { type: \"zoom-pan-start\", callerId });\n  }\n  getZoom() {\n    let x;\n    let y;\n    this.axisZoomManagers.forEach((axis) => {\n      if (axis.getDirection() === \"x\" /* X */) {\n        x ?? (x = axis.getZoom());\n      } else if (axis.getDirection() === \"y\" /* Y */) {\n        y ?? (y = axis.getZoom());\n      }\n    });\n    if (x || y) {\n      return { x, y };\n    }\n  }\n  getAxisZoom(axisId) {\n    return this.axisZoomManagers.get(axisId)?.getZoom() ?? { min: 0, max: 1 };\n  }\n  getAxisZooms() {\n    const axes = {};\n    for (const [axisId, axis] of this.axisZoomManagers.entries()) {\n      axes[axisId] = {\n        direction: axis.getDirection(),\n        zoom: axis.getZoom()\n      };\n    }\n    return axes;\n  }\n  applyChanges(callerId) {\n    const changed = Array.from(this.axisZoomManagers.values(), (axis) => axis.applyChanges()).some(Boolean);\n    if (!changed) {\n      return;\n    }\n    const axes = {};\n    for (const [axisId, axis] of this.axisZoomManagers.entries()) {\n      axes[axisId] = axis.getZoom();\n    }\n    this.listeners.dispatch(\"zoom-change\", { type: \"zoom-change\", ...this.getZoom(), axes, callerId });\n  }\n};\nvar AxisZoomManager = class {\n  constructor(axis) {\n    this.axis = axis;\n    const [min = 0, max = 1] = axis.visibleRange;\n    this.state = new StateTracker({ min, max });\n    this.currentZoom = this.state.stateValue();\n  }\n  getDirection() {\n    return this.axis.direction;\n  }\n  updateZoom(callerId, newZoom) {\n    this.state.set(callerId, newZoom);\n  }\n  getZoom() {\n    return deepClone(this.state.stateValue());\n  }\n  applyChanges() {\n    const prevZoom = this.currentZoom;\n    this.currentZoom = this.state.stateValue();\n    return prevZoom.min !== this.currentZoom.min || prevZoom.max !== this.currentZoom.max;\n  }\n};\n\n// packages/ag-charts-community/src/chart/keyboard.ts\nvar Keyboard = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], Keyboard.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], Keyboard.prototype, \"tabIndex\", 2);\n\n// packages/ag-charts-community/src/chart/mapping/prepareAxis.ts\nvar CartesianAxisPositions = [\"top\", \"right\", \"bottom\", \"left\"];\nfunction isAxisPosition(position) {\n  return typeof position === \"string\" && CartesianAxisPositions.includes(position);\n}\nfunction guessInvalidPositions(axes) {\n  const invalidAxes = [];\n  const usedPositions = [];\n  const guesses = [...CartesianAxisPositions];\n  for (const axis of axes) {\n    if (axis instanceof CartesianAxis) {\n      if (isAxisPosition(axis.position)) {\n        usedPositions.push(axis.position);\n      } else {\n        invalidAxes.push(axis);\n      }\n    }\n  }\n  for (const axis of invalidAxes) {\n    let nextGuess;\n    do {\n      nextGuess = guesses.pop();\n    } while (nextGuess && usedPositions.includes(nextGuess));\n    if (nextGuess == null)\n      break;\n    axis.position = nextGuess;\n  }\n}\n\n// packages/ag-charts-community/src/chart/mapping/prepareSeries.ts\nvar MATCHING_KEYS = [\"direction\", \"xKey\", \"yKey\", \"sizeKey\", \"angleKey\", \"radiusKey\", \"normalizedTo\"];\nfunction matchSeriesOptions(series, optSeries, oldOptsSeries) {\n  const generateKey = (type, i, opts) => {\n    const result = [type];\n    for (const key of MATCHING_KEYS) {\n      if (key in i && i[key] != null)\n        result.push(`${key}=${i[key]}`);\n    }\n    if (opts?.seriesGrouping) {\n      result.push(`seriesGrouping.groupId=${opts?.seriesGrouping.groupId}`);\n    }\n    return result.join(\";\");\n  };\n  const seriesMap = /* @__PURE__ */ new Map();\n  let idx = 0;\n  for (const s of series) {\n    const key = generateKey(s.type, s.properties, oldOptsSeries?.[idx]);\n    if (!seriesMap.has(key)) {\n      seriesMap.set(key, []);\n    }\n    seriesMap.get(key)?.push([s, idx++]);\n  }\n  const optsMap = /* @__PURE__ */ new Map();\n  for (const o of optSeries) {\n    const key = generateKey(o.type, o, o);\n    if (!optsMap.has(key)) {\n      optsMap.set(key, []);\n    }\n    optsMap.get(key)?.push(o);\n  }\n  const overlap = [...seriesMap.keys()].some((k) => optsMap.has(k));\n  if (!overlap) {\n    return { status: \"no-overlap\", oldKeys: seriesMap.keys(), newKeys: optsMap.keys() };\n  }\n  const changes = [];\n  let targetIdx = -1;\n  for (const [key, optArray] of optsMap.entries()) {\n    for (const opts of optArray) {\n      targetIdx++;\n      const seriesArray = seriesMap.get(key);\n      if (seriesArray == null || seriesArray.length < 1) {\n        changes.push({ opts, idx: targetIdx, status: \"add\" });\n        seriesMap.delete(key);\n        continue;\n      }\n      const [outputSeries, outputIdx] = seriesArray.shift();\n      const previousOpts = oldOptsSeries?.[outputIdx] ?? {};\n      const diff2 = jsonDiff(previousOpts, opts ?? {});\n      const { groupIndex, stackIndex } = diff2?.seriesGrouping ?? {};\n      if (groupIndex != null || stackIndex != null) {\n        changes.push({ opts, series: outputSeries, diff: diff2, idx: outputIdx, status: \"series-grouping\" });\n      } else if (diff2) {\n        changes.push({ opts, series: outputSeries, diff: diff2, idx: outputIdx, status: \"update\" });\n      } else {\n        changes.push({ opts, series: outputSeries, idx: outputIdx, status: \"no-op\" });\n      }\n      if (seriesArray.length === 0) {\n        seriesMap.delete(key);\n      }\n    }\n  }\n  for (const seriesArray of seriesMap.values()) {\n    for (const [outputSeries, outputIdx] of seriesArray) {\n      changes.push({ series: outputSeries, idx: outputIdx, status: \"remove\" });\n    }\n  }\n  return { status: \"overlap\", changes };\n}\n\n// packages/ag-charts-community/src/chart/mapping/types.ts\nfunction optionsType(input) {\n  return input.series?.[0]?.type ?? \"line\";\n}\nfunction isAgCartesianChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return true;\n  }\n  if (specifiedType === \"cartesian\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isCartesian(specifiedType) || isEnterpriseCartesian(specifiedType);\n}\nfunction isAgPolarChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"polar\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isPolar(specifiedType) || isEnterprisePolar(specifiedType);\n}\nfunction isAgHierarchyChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"hierarchy\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isHierarchy(specifiedType) || isEnterpriseHierarchy(specifiedType);\n}\nfunction isAgTopologyChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"topology\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isTopology(specifiedType) || isEnterpriseTopology(specifiedType);\n}\nfunction isAgFlowProportionChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === \"flow-proportion\") {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return chartTypes.isFlowProportion(specifiedType) || isEnterpriseFlowProportion(specifiedType);\n}\nfunction isAgPolarChartOptionsWithSeriesBasedLegend(input) {\n  const specifiedType = optionsType(input);\n  return isAgPolarChartOptions(input) && specifiedType !== \"pie\" && specifiedType !== \"donut\";\n}\nfunction isSeriesOptionType(input) {\n  if (input == null) {\n    return false;\n  }\n  return chartTypes.has(input);\n}\nfunction isAxisOptionType(input) {\n  if (input == null) {\n    return false;\n  }\n  return axisRegistry.has(input);\n}\n\n// packages/ag-charts-community/src/chart/modulesManager.ts\nvar ModulesManager = class extends ModuleMap {\n  applyOptions(options) {\n    for (const m of this.moduleMap.values()) {\n      if (m.module.optionsKey in options && isProperties(m.moduleInstance)) {\n        m.moduleInstance.set(options[m.module.optionsKey]);\n      }\n    }\n  }\n  *legends() {\n    for (const { module, moduleInstance } of this.moduleMap.values()) {\n      if (module.type !== \"legend\")\n        continue;\n      yield {\n        legendType: module.identifier,\n        legend: moduleInstance\n      };\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/overlay/overlay.ts\nvar DEFAULT_OVERLAY_CLASS = \"ag-chart-overlay\";\nvar DEFAULT_OVERLAY_DARK_CLASS = \"ag-chart-dark-overlay\";\nvar Overlay = class extends BaseProperties {\n  constructor(className, defaultMessageId) {\n    super();\n    this.className = className;\n    this.defaultMessageId = defaultMessageId;\n  }\n  getText(localeManager) {\n    return localeManager.t(this.text ?? this.defaultMessageId);\n  }\n  getElement(animationManager, localeManager, rect) {\n    this.content?.remove();\n    this.focusBox = rect;\n    if (this.renderer) {\n      const htmlContent = this.renderer();\n      if (htmlContent instanceof HTMLElement) {\n        this.content = htmlContent;\n      } else {\n        const tempDiv = createElement(\"div\");\n        tempDiv.innerHTML = htmlContent;\n        this.content = tempDiv.firstElementChild;\n      }\n    } else {\n      const content = createElement(\"div\", {\n        display: \"flex\",\n        alignItems: \"center\",\n        justifyContent: \"center\",\n        boxSizing: \"border-box\",\n        height: \"100%\",\n        margin: \"8px\",\n        font: \"12px Verdana, sans-serif\"\n      });\n      content.innerText = this.getText(localeManager);\n      this.content = content;\n      animationManager?.animate({\n        from: 0,\n        to: 1,\n        id: \"overlay\",\n        phase: \"add\",\n        groupId: \"opacity\",\n        onUpdate(value) {\n          content.style.opacity = String(value);\n        },\n        onStop() {\n          content.style.opacity = \"1\";\n        }\n      });\n    }\n    return this.content;\n  }\n  removeElement(cleanup = () => this.content?.remove(), animationManager) {\n    if (!this.content)\n      return;\n    if (animationManager) {\n      const { content } = this;\n      animationManager.animate({\n        from: 1,\n        to: 0,\n        phase: \"remove\",\n        id: \"overlay\",\n        groupId: \"opacity\",\n        onUpdate(value) {\n          content.style.opacity = String(value);\n        },\n        onStop() {\n          cleanup?.();\n        }\n      });\n    } else {\n      cleanup?.();\n    }\n    this.content = void 0;\n    this.focusBox = void 0;\n  }\n};\n__decorateClass([\n  Validate(STRING, { optional: true })\n], Overlay.prototype, \"text\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], Overlay.prototype, \"renderer\", 2);\n\n// packages/ag-charts-community/src/chart/overlay/chartOverlays.ts\nvar ChartOverlays = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.darkTheme = false;\n    this.loading = new Overlay(\"ag-chart-loading-overlay\", \"overlayLoadingData\");\n    this.noData = new Overlay(\"ag-chart-no-data-overlay\", \"overlayNoData\");\n    this.noVisibleSeries = new Overlay(\"ag-chart-no-visible-series\", \"overlayNoVisibleSeries\");\n  }\n  getFocusInfo(localeManager) {\n    for (const overlay of [this.loading, this.noData, this.noVisibleSeries]) {\n      if (overlay.focusBox !== void 0) {\n        return { text: overlay.getText(localeManager), rect: overlay.focusBox };\n      }\n    }\n    return void 0;\n  }\n  destroy() {\n    this.loading.removeElement();\n    this.noData.removeElement();\n    this.noVisibleSeries.removeElement();\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], ChartOverlays.prototype, \"darkTheme\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartOverlays.prototype, \"loading\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartOverlays.prototype, \"noData\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ChartOverlays.prototype, \"noVisibleSeries\", 2);\n\n// packages/ag-charts-community/src/chart/overlay/loadingSpinner.ts\nfunction getLoadingSpinner(text, defaultDuration) {\n  const { animationDuration } = PHASE_METADATA[\"add\"];\n  const duration = animationDuration * defaultDuration;\n  const container = createElement(\"div\", `${DEFAULT_OVERLAY_CLASS}--loading`, {\n    display: \"flex\",\n    alignItems: \"center\",\n    justifyContent: \"center\",\n    flexDirection: \"column\",\n    height: \"100%\",\n    boxSizing: \"border-box\",\n    font: \"13px Verdana, sans-serif\",\n    // FONT_SIZE.MEDIUM\n    userSelect: \"none\",\n    animation: `ag-charts-loading ${duration}ms linear 50ms both`\n  });\n  const matrix = createElement(\"span\", {\n    width: \"45px\",\n    height: \"40px\",\n    backgroundImage: [\n      \"linear-gradient(#0000 calc(1 * 100% / 6), #ccc 0 calc(3 * 100% / 6), #0000 0), \",\n      \"linear-gradient(#0000 calc(2 * 100% / 6), #ccc 0 calc(4 * 100% / 6), #0000 0), \",\n      \"linear-gradient(#0000 calc(3 * 100% / 6), #ccc 0 calc(5 * 100% / 6), #0000 0)\"\n    ].join(\"\"),\n    backgroundSize: \"10px 400%\",\n    backgroundRepeat: \"no-repeat\",\n    animation: \"ag-charts-loading-matrix 1s infinite linear\"\n  });\n  const label = createElement(\"p\", { marginTop: \"1em\" });\n  label.innerText = text;\n  const background = createElement(\"div\", `${DEFAULT_OVERLAY_CLASS}__loading-background`, {\n    position: \"absolute\",\n    inset: \"0\",\n    opacity: \"0.5\",\n    zIndex: \"-1\"\n  });\n  const animationStyles = createElement(\"style\");\n  animationStyles.innerText = [\n    \"@keyframes ag-charts-loading { from { opacity: 0 } to { opacity: 1 } }\",\n    \"@keyframes ag-charts-loading-matrix {\",\n    \"0% { background-position: 0% 0%, 50% 0%, 100% 0%; }\",\n    \"100% { background-position: 0% 100%, 50% 100%, 100% 100%; }\",\n    \"}\"\n  ].join(\" \");\n  container.replaceChildren(animationStyles, matrix, label, background);\n  return container;\n}\n\n// packages/ag-charts-community/src/chart/data/aggregateFunctions.ts\nfunction sumValues(values, accumulator = [0, 0]) {\n  for (const value of values) {\n    if (typeof value !== \"number\") {\n      continue;\n    }\n    if (value < 0) {\n      accumulator[0] += value;\n    }\n    if (value > 0) {\n      accumulator[1] += value;\n    }\n  }\n  return accumulator;\n}\nfunction sum(id, matchGroupId) {\n  const result = {\n    id,\n    matchGroupIds: [matchGroupId],\n    type: \"aggregate\",\n    aggregateFunction: (values) => sumValues(values)\n  };\n  return result;\n}\nfunction groupSum(id, matchGroupId) {\n  return {\n    id,\n    type: \"aggregate\",\n    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,\n    aggregateFunction: (values) => sumValues(values),\n    groupAggregateFunction: (next, acc = [0, 0]) => {\n      acc[0] += next?.[0] ?? 0;\n      acc[1] += next?.[1] ?? 0;\n      return acc;\n    }\n  };\n}\nfunction range2(id, matchGroupId) {\n  const result = {\n    id,\n    matchGroupIds: [matchGroupId],\n    type: \"aggregate\",\n    aggregateFunction: (values) => ContinuousDomain.extendDomain(values)\n  };\n  return result;\n}\nfunction groupCount(id) {\n  return {\n    id,\n    type: \"aggregate\",\n    aggregateFunction: () => [0, 1],\n    groupAggregateFunction: (next, acc = [0, 0]) => {\n      acc[0] += next?.[0] ?? 0;\n      acc[1] += next?.[1] ?? 0;\n      return acc;\n    }\n  };\n}\nfunction groupAverage(id, matchGroupId) {\n  const def = {\n    id,\n    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,\n    type: \"aggregate\",\n    aggregateFunction: (values) => sumValues(values),\n    groupAggregateFunction: (next, acc = [0, 0, -1]) => {\n      acc[0] += next?.[0] ?? 0;\n      acc[1] += next?.[1] ?? 0;\n      acc[2]++;\n      return acc;\n    },\n    finalFunction: (acc = [0, 0, 0]) => {\n      const result = acc[0] + acc[1];\n      if (result >= 0) {\n        return [0, result / acc[2]];\n      }\n      return [result / acc[2], 0];\n    }\n  };\n  return def;\n}\nfunction area(id, aggFn, matchGroupId) {\n  const result = {\n    id,\n    matchGroupIds: matchGroupId ? [matchGroupId] : void 0,\n    type: \"aggregate\",\n    aggregateFunction: (values, keyRange = []) => {\n      const keyWidth = keyRange[1] - keyRange[0];\n      return aggFn.aggregateFunction(values).map((v) => v / keyWidth);\n    }\n  };\n  if (aggFn.groupAggregateFunction) {\n    result.groupAggregateFunction = aggFn.groupAggregateFunction;\n  }\n  return result;\n}\nfunction accumulatedValue(onlyPositive) {\n  return () => {\n    let value = 0;\n    return (datum) => {\n      if (!isFiniteNumber(datum)) {\n        return datum;\n      }\n      value += onlyPositive ? Math.max(0, datum) : datum;\n      return value;\n    };\n  };\n}\nfunction trailingAccumulatedValue() {\n  return () => {\n    let value = 0;\n    return (datum) => {\n      if (!isFiniteNumber(datum)) {\n        return datum;\n      }\n      const trailingValue = value;\n      value += datum;\n      return trailingValue;\n    };\n  };\n}\n\n// packages/ag-charts-community/src/util/memo.ts\nvar memorizedFns = /* @__PURE__ */ new WeakMap();\nfunction memo(params, fnGenerator) {\n  const serialisedParams = JSON.stringify(params, null, 0);\n  if (!memorizedFns.has(fnGenerator)) {\n    memorizedFns.set(fnGenerator, /* @__PURE__ */ new Map());\n  }\n  if (!memorizedFns.get(fnGenerator)?.has(serialisedParams)) {\n    memorizedFns.get(fnGenerator)?.set(serialisedParams, fnGenerator(params));\n  }\n  return memorizedFns.get(fnGenerator)?.get(serialisedParams);\n}\n\n// packages/ag-charts-community/src/chart/data/processors.ts\nvar SMALLEST_KEY_INTERVAL = {\n  type: \"reducer\",\n  property: \"smallestKeyInterval\",\n  initialValue: Infinity,\n  reducer: () => {\n    let prevX = NaN;\n    return (smallestSoFar = Infinity, next) => {\n      const nextX = next.keys[0];\n      const interval = Math.abs(nextX - prevX);\n      prevX = nextX;\n      if (!isNaN(interval) && interval > 0 && interval < smallestSoFar) {\n        return interval;\n      }\n      return smallestSoFar;\n    };\n  }\n};\nvar LARGEST_KEY_INTERVAL = {\n  type: \"reducer\",\n  property: \"largestKeyInterval\",\n  initialValue: -Infinity,\n  reducer: () => {\n    let prevX = NaN;\n    return (largestSoFar = -Infinity, next) => {\n      const nextX = next.keys[0];\n      const interval = Math.abs(nextX - prevX);\n      prevX = nextX;\n      if (!isNaN(interval) && interval > 0 && interval > largestSoFar) {\n        return interval;\n      }\n      return largestSoFar;\n    };\n  }\n};\nvar SORT_DOMAIN_GROUPS = {\n  type: \"processor\",\n  property: \"sortedGroupDomain\",\n  calculate: ({ domain: { groups } }) => groups?.slice().sort((a, b) => {\n    for (let i = 0; i < a.length; i++) {\n      const result = a[i] - b[i];\n      if (result !== 0) {\n        return result;\n      }\n    }\n    return 0;\n  })\n};\nfunction normaliseFnBuilder({ normaliseTo, mode }) {\n  const normalise = (val, extent2) => {\n    const result = val * normaliseTo / extent2;\n    if (result >= 0) {\n      return Math.min(normaliseTo, result);\n    }\n    return Math.max(-normaliseTo, result);\n  };\n  return () => () => (values, valueIndexes) => {\n    const valuesExtent = [0, 0];\n    for (const valueIdx of valueIndexes) {\n      const value = values[valueIdx];\n      const valueExtent = typeof value === \"number\" ? value : Math.max(...value);\n      const valIdx = valueExtent < 0 ? 0 : 1;\n      if (mode === \"sum\") {\n        valuesExtent[valIdx] += valueExtent;\n      } else if (valIdx === 0) {\n        valuesExtent[valIdx] = Math.min(valuesExtent[valIdx], valueExtent);\n      } else {\n        valuesExtent[valIdx] = Math.max(valuesExtent[valIdx], valueExtent);\n      }\n    }\n    const extent2 = Math.max(Math.abs(valuesExtent[0]), valuesExtent[1]);\n    for (const valueIdx of valueIndexes) {\n      const value = values[valueIdx];\n      values[valueIdx] = typeof value === \"number\" ? normalise(value, extent2) : value.map((v) => normalise(v, extent2));\n    }\n  };\n}\nfunction normaliseGroupTo(matchGroupIds, normaliseTo, mode = \"sum\") {\n  return {\n    type: \"group-value-processor\",\n    matchGroupIds,\n    adjust: memo({ normaliseTo, mode }, normaliseFnBuilder)\n  };\n}\nfunction normalisePropertyFnBuilder({\n  normaliseTo,\n  zeroDomain,\n  rangeMin,\n  rangeMax\n}) {\n  const normaliseSpan = normaliseTo[1] - normaliseTo[0];\n  const normalise = (val, start, span) => {\n    const result = normaliseTo[0] + (val - start) / span * normaliseSpan;\n    if (span === 0) {\n      return zeroDomain;\n    } else if (result >= normaliseTo[1]) {\n      return normaliseTo[1];\n    } else if (result < normaliseTo[0]) {\n      return normaliseTo[0];\n    }\n    return result;\n  };\n  return () => (pData, pIdx) => {\n    let [start, end] = pData.domain.values[pIdx];\n    if (rangeMin != null)\n      start = rangeMin;\n    if (rangeMax != null)\n      end = rangeMax;\n    const span = end - start;\n    pData.domain.values[pIdx] = [normaliseTo[0], normaliseTo[1]];\n    for (const group of pData.data) {\n      let groupValues = group.values;\n      if (pData.type === \"ungrouped\") {\n        groupValues = [groupValues];\n      }\n      for (const values of groupValues) {\n        values[pIdx] = normalise(values[pIdx], start, span);\n      }\n    }\n  };\n}\nfunction normalisePropertyTo(property, normaliseTo, zeroDomain, rangeMin, rangeMax) {\n  return {\n    type: \"property-value-processor\",\n    property,\n    adjust: memo({ normaliseTo, rangeMin, rangeMax, zeroDomain }, normalisePropertyFnBuilder)\n  };\n}\nfunction animationValidation(valueKeyIds) {\n  return {\n    type: \"processor\",\n    property: \"animationValidation\",\n    calculate(result) {\n      const { keys, values } = result.defs;\n      const { input, data } = result;\n      let uniqueKeys = true;\n      let orderedKeys = true;\n      const valueKeys = [];\n      for (let k = 0; k < values.length; k++) {\n        if (!valueKeyIds?.includes(values[k].id))\n          continue;\n        valueKeys.push([k, values[k]]);\n      }\n      const processKey = (idx, def, type) => {\n        if (def.valueType === \"category\") {\n          const keyValues = result.domain[type][idx];\n          uniqueKeys && (uniqueKeys = keyValues.length === input.count);\n          return;\n        }\n        let lastValue = data[0]?.[type][idx];\n        for (let d = 1; (uniqueKeys || orderedKeys) && d < data.length; d++) {\n          const keyValue = data[d][type][idx];\n          orderedKeys && (orderedKeys = lastValue <= keyValue);\n          uniqueKeys && (uniqueKeys = lastValue !== keyValue);\n          lastValue = keyValue;\n        }\n      };\n      for (let k = 0; (uniqueKeys || orderedKeys) && k < keys.length; k++) {\n        processKey(k, keys[k], \"keys\");\n      }\n      for (let k = 0; (uniqueKeys || orderedKeys) && k < valueKeys.length; k++) {\n        const [idx, key] = valueKeys[k];\n        processKey(idx, key, \"values\");\n      }\n      return { uniqueKeys, orderedKeys };\n    }\n  };\n}\nfunction buildGroupAccFn({ mode, separateNegative }) {\n  return () => () => (values, valueIndexes) => {\n    const acc = [0, 0];\n    for (const valueIdx of valueIndexes) {\n      const currentVal = values[valueIdx];\n      const accIndex = isNegative(currentVal) && separateNegative ? 0 : 1;\n      if (!isFiniteNumber(currentVal))\n        continue;\n      if (mode === \"normal\")\n        acc[accIndex] += currentVal;\n      values[valueIdx] = acc[accIndex];\n      if (mode === \"trailing\")\n        acc[accIndex] += currentVal;\n    }\n  };\n}\nfunction buildGroupWindowAccFn({ mode, sum: sum2 }) {\n  return () => {\n    const lastValues = [];\n    let firstRow = true;\n    return () => {\n      return (values, valueIndexes) => {\n        let acc = 0;\n        for (const valueIdx of valueIndexes) {\n          const currentVal = values[valueIdx];\n          const lastValue = firstRow && sum2 === \"current\" ? 0 : lastValues[valueIdx];\n          lastValues[valueIdx] = currentVal;\n          const sumValue = sum2 === \"current\" ? currentVal : lastValue;\n          if (!isFiniteNumber(currentVal) || !isFiniteNumber(lastValue)) {\n            values[valueIdx] = acc;\n            continue;\n          }\n          if (mode === \"normal\") {\n            acc += sumValue;\n          }\n          values[valueIdx] = acc;\n          if (mode === \"trailing\") {\n            acc += sumValue;\n          }\n        }\n        firstRow = false;\n      };\n    };\n  };\n}\nfunction accumulateGroup(matchGroupId, mode, sum2, separateNegative = false) {\n  let adjust;\n  if (mode.startsWith(\"window\")) {\n    const modeParam = mode.endsWith(\"-trailing\") ? \"trailing\" : \"normal\";\n    adjust = memo({ mode: modeParam, sum: sum2 }, buildGroupWindowAccFn);\n  } else {\n    adjust = memo({ mode, separateNegative }, buildGroupAccFn);\n  }\n  return {\n    type: \"group-value-processor\",\n    matchGroupIds: [matchGroupId],\n    adjust\n  };\n}\nfunction groupStackAccFn() {\n  return () => (values, valueIndexes) => {\n    const acc = new Float64Array(32);\n    let stackCount = 0;\n    for (const valueIdx of valueIndexes) {\n      const currentValue = values[valueIdx];\n      acc[stackCount] = Number.isFinite(currentValue) ? currentValue : NaN;\n      stackCount += 1;\n      values[valueIdx] = acc.subarray(0, stackCount);\n    }\n  };\n}\nfunction accumulateStack(matchGroupId) {\n  return {\n    type: \"group-value-processor\",\n    matchGroupIds: [matchGroupId],\n    adjust: groupStackAccFn\n  };\n}\nfunction diff(previousData, updateMovedData = true) {\n  return {\n    type: \"processor\",\n    property: \"diff\",\n    calculate: (processedData) => {\n      const moved = /* @__PURE__ */ new Map();\n      const added = /* @__PURE__ */ new Map();\n      const updated = /* @__PURE__ */ new Map();\n      const removed = /* @__PURE__ */ new Map();\n      const length2 = Math.max(previousData.data.length, processedData.data.length);\n      for (let i = 0; i < length2; i++) {\n        const prev = previousData.data[i];\n        const datum = processedData.data[i];\n        const prevId = prev ? createDatumId(prev.keys) : \"\";\n        const datumId = datum ? createDatumId(datum.keys) : \"\";\n        if (datum && prev && prevId === datumId) {\n          if (!arraysEqual(prev.values, datum.values)) {\n            updated.set(datumId, datum);\n          }\n          continue;\n        }\n        if (removed.has(datumId)) {\n          if (updateMovedData || !arraysEqual(removed.get(datumId).values, datum.values)) {\n            updated.set(datumId, datum);\n            moved.set(datumId, datum);\n          }\n          removed.delete(datumId);\n        } else if (datum) {\n          added.set(datumId, datum);\n        }\n        if (added.has(prevId)) {\n          if (updateMovedData || !arraysEqual(added.get(prevId).values, prev.values)) {\n            updated.set(prevId, prev);\n            moved.set(prevId, prev);\n          }\n          added.delete(prevId);\n        } else if (prev) {\n          updated.delete(prevId);\n          removed.set(prevId, prev);\n        }\n      }\n      const changed = added.size > 0 || updated.size > 0 || removed.size > 0;\n      return { changed, added, updated, removed, moved };\n    }\n  };\n}\nfunction createDatumId(keys, ...extraKeys) {\n  let result;\n  if (isArray(keys)) {\n    result = keys.map((key) => transformIntegratedCategoryValue(key)).join(\"___\");\n  } else {\n    result = transformIntegratedCategoryValue(keys);\n  }\n  const primitiveType = typeof result === \"string\" || typeof result === \"number\" || typeof result === \"boolean\" || result instanceof Date;\n  if (primitiveType && extraKeys.length > 0) {\n    result += `___${extraKeys.join(\"___\")}`;\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/chart/series/series.ts\nvar SeriesNodePickMode = /* @__PURE__ */ ((SeriesNodePickMode2) => {\n  SeriesNodePickMode2[SeriesNodePickMode2[\"EXACT_SHAPE_MATCH\"] = 0] = \"EXACT_SHAPE_MATCH\";\n  SeriesNodePickMode2[SeriesNodePickMode2[\"NEAREST_BY_MAIN_AXIS_FIRST\"] = 1] = \"NEAREST_BY_MAIN_AXIS_FIRST\";\n  SeriesNodePickMode2[SeriesNodePickMode2[\"NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST\"] = 2] = \"NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST\";\n  SeriesNodePickMode2[SeriesNodePickMode2[\"NEAREST_NODE\"] = 3] = \"NEAREST_NODE\";\n  return SeriesNodePickMode2;\n})(SeriesNodePickMode || {});\nfunction basicContinuousCheckDatumValidation(value) {\n  return value != null && isContinuous(value);\n}\nfunction basicDiscreteCheckDatumValidation(value) {\n  return value != null;\n}\nfunction getValidationFn(scaleType) {\n  switch (scaleType) {\n    case \"number\":\n    case \"log\":\n    case \"ordinal-time\":\n    case \"time\":\n    case \"color\":\n      return basicContinuousCheckDatumValidation;\n    default:\n      return basicDiscreteCheckDatumValidation;\n  }\n}\nfunction getValueType(scaleType) {\n  switch (scaleType) {\n    case \"number\":\n    case \"log\":\n    case \"time\":\n    case \"color\":\n      return \"range\";\n    default:\n      return \"category\";\n  }\n}\nfunction keyProperty(propName, scaleType, opts = {}) {\n  const result = {\n    property: propName,\n    type: \"key\",\n    valueType: getValueType(scaleType),\n    validation: getValidationFn(scaleType),\n    ...opts\n  };\n  return result;\n}\nfunction valueProperty(propName, scaleType, opts = {}) {\n  const result = {\n    property: propName,\n    type: \"value\",\n    valueType: getValueType(scaleType),\n    validation: getValidationFn(scaleType),\n    ...opts\n  };\n  return result;\n}\nfunction rangedValueProperty(propName, opts = {}) {\n  const { min = -Infinity, max = Infinity, ...defOpts } = opts;\n  return {\n    type: \"value\",\n    property: propName,\n    valueType: \"range\",\n    validation: basicContinuousCheckDatumValidation,\n    processor: () => (datum) => isFiniteNumber(datum) ? clamp(min, datum, max) : datum,\n    ...defOpts\n  };\n}\nfunction accumulativeValueProperty(propName, scaleType, opts = {}) {\n  const { onlyPositive, ...defOpts } = opts;\n  const result = {\n    ...valueProperty(propName, scaleType, defOpts),\n    processor: accumulatedValue(onlyPositive)\n  };\n  return result;\n}\nfunction trailingAccumulatedValueProperty(propName, scaleType, opts = {}) {\n  const result = {\n    ...valueProperty(propName, scaleType, opts),\n    processor: trailingAccumulatedValue()\n  };\n  return result;\n}\nfunction groupAccumulativeValueProperty(propName, mode, sum2 = \"current\", opts, scaleType) {\n  return [\n    valueProperty(propName, scaleType, opts),\n    accumulateGroup(opts.groupId, mode, sum2, opts.separateNegative),\n    ...opts.rangeId != null ? [range2(opts.rangeId, opts.groupId)] : []\n  ];\n}\nfunction groupStackValueProperty(propName, scaleType, opts) {\n  return [valueProperty(propName, scaleType, opts), accumulateStack(opts.groupId)];\n}\nvar SeriesNodeEvent = class {\n  constructor(type, event, { datum }, series) {\n    this.type = type;\n    this.event = event;\n    this.datum = datum;\n    this.seriesId = series.id;\n  }\n};\nvar SeriesGroupingChangedEvent = class {\n  constructor(series, seriesGrouping, oldGrouping) {\n    this.series = series;\n    this.seriesGrouping = seriesGrouping;\n    this.oldGrouping = oldGrouping;\n    this.type = \"groupingChanged\";\n  }\n};\nvar Series = class extends Observable {\n  constructor(seriesOpts) {\n    super();\n    this.destroyFns = [];\n    this.seriesGrouping = void 0;\n    this.NodeEvent = SeriesNodeEvent;\n    this.internalId = createId(this);\n    // The group node that contains all the nodes used to render this series.\n    this.rootGroup = new Group({ name: \"seriesRoot\", isVirtual: true });\n    this.axes = {\n      [\"x\" /* X */]: void 0,\n      [\"y\" /* Y */]: void 0\n    };\n    this.directions = [\"x\" /* X */, \"y\" /* Y */];\n    // Flag to determine if we should recalculate node data.\n    this.nodeDataRefresh = true;\n    this.moduleMap = new ModuleMap();\n    this._declarationOrder = -1;\n    this.seriesListeners = new Listeners();\n    this._pickNodeCache = new LRUCache();\n    const {\n      moduleCtx,\n      pickModes = [1 /* NEAREST_BY_MAIN_AXIS_FIRST */],\n      directionKeys = {},\n      directionNames = {},\n      contentGroupVirtual = true,\n      canHaveAxes = false\n    } = seriesOpts;\n    this.ctx = moduleCtx;\n    this.directionKeys = directionKeys;\n    this.directionNames = directionNames;\n    this.canHaveAxes = canHaveAxes;\n    this.contentGroup = this.rootGroup.appendChild(\n      new Group({\n        name: `${this.internalId}-content`,\n        isVirtual: contentGroupVirtual,\n        zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"data\")\n      })\n    );\n    this.highlightGroup = new Group({\n      name: `${this.internalId}-highlight`,\n      isVirtual: contentGroupVirtual,\n      zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n      zIndexSubOrder: this.getGroupZIndexSubOrder(\"highlight\")\n    });\n    this.highlightNode = this.highlightGroup.appendChild(new Group({ name: \"highlightNode\", zIndex: 0 }));\n    this.highlightLabel = this.highlightGroup.appendChild(new Group({ name: \"highlightLabel\", zIndex: 10 }));\n    this.pickModes = pickModes;\n    this.labelGroup = this.rootGroup.appendChild(\n      new Group({\n        name: `${this.internalId}-series-labels`,\n        zIndex: 8 /* SERIES_LABEL_ZINDEX */\n      })\n    );\n    this.annotationGroup = new Group({\n      name: `${this.id}-annotation`,\n      isVirtual: contentGroupVirtual,\n      zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n      zIndexSubOrder: this.getGroupZIndexSubOrder(\"annotation\")\n    });\n  }\n  get id() {\n    return this.properties?.id ?? this.internalId;\n  }\n  get type() {\n    return this.constructor.type ?? \"\";\n  }\n  get data() {\n    return this._data ?? this._chartData;\n  }\n  set visible(value) {\n    this.properties.visible = value;\n    this.visibleMaybeChanged();\n  }\n  get visible() {\n    return this.properties.visible;\n  }\n  get hasData() {\n    return this.data != null && this.data.length > 0;\n  }\n  get tooltipEnabled() {\n    return this.properties.tooltip?.enabled ?? false;\n  }\n  onDataChange() {\n    this.nodeDataRefresh = true;\n    this._pickNodeCache.clear();\n  }\n  setOptionsData(input) {\n    this._data = input;\n    this.onDataChange();\n  }\n  setChartData(input) {\n    this._chartData = input;\n    if (this.data === input) {\n      this.onDataChange();\n    }\n  }\n  onSeriesGroupingChange(prev, next) {\n    const { internalId, type, visible } = this;\n    if (prev) {\n      this.ctx.seriesStateManager.deregisterSeries({ id: internalId, type });\n    }\n    if (next) {\n      this.ctx.seriesStateManager.registerSeries({ id: internalId, type, visible, seriesGrouping: next });\n    }\n    this.fireEvent(new SeriesGroupingChangedEvent(this, next, prev));\n  }\n  getBandScalePadding() {\n    return { inner: 1, outer: 0 };\n  }\n  getGroupZIndexSubOrder(type, subIndex = 0) {\n    let mainAdjust = 0;\n    switch (type) {\n      case \"data\":\n      case \"paths\":\n        break;\n      case \"labels\":\n        mainAdjust += 2e4;\n        break;\n      case \"marker\":\n        mainAdjust += 1e4;\n        break;\n      case \"highlight\":\n        subIndex += 15e3;\n        break;\n      case \"annotation\":\n        mainAdjust += 15e3;\n        break;\n    }\n    const main = () => this._declarationOrder + mainAdjust;\n    return [main, subIndex];\n  }\n  addListener(type, listener) {\n    return this.seriesListeners.addListener(type, listener);\n  }\n  dispatch(type, event) {\n    this.seriesListeners.dispatch(type, event);\n  }\n  addChartEventListeners() {\n    return;\n  }\n  destroy() {\n    this.destroyFns.forEach((f) => f());\n    this.destroyFns = [];\n    this.ctx.seriesStateManager.deregisterSeries(this);\n  }\n  getDirectionValues(direction, properties) {\n    const resolvedDirection = this.resolveKeyDirection(direction);\n    const keys = properties?.[resolvedDirection];\n    const values = [];\n    if (!keys) {\n      return values;\n    }\n    const addValues = (...items) => {\n      for (const value of items) {\n        if (Array.isArray(value)) {\n          addValues(...value);\n        } else if (typeof value === \"object\") {\n          addValues(...Object.values(value));\n        } else {\n          values.push(value);\n        }\n      }\n    };\n    addValues(...keys.map((key) => this.properties[key]));\n    return values;\n  }\n  getKeys(direction) {\n    return this.getDirectionValues(direction, this.directionKeys);\n  }\n  getKeyProperties(direction) {\n    return this.directionKeys[this.resolveKeyDirection(direction)] ?? [];\n  }\n  getNames(direction) {\n    return this.getDirectionValues(direction, this.directionNames);\n  }\n  resolveKeyDirection(direction) {\n    return direction;\n  }\n  // The union of the series domain ('community') and series-option domains ('enterprise').\n  getDomain(direction) {\n    const seriesDomain = this.getSeriesDomain(direction);\n    const moduleDomains = this.moduleMap.mapModules((module) => module.getDomain(direction));\n    return seriesDomain.concat(moduleDomains.flat());\n  }\n  // Indicate that something external changed and we should recalculate nodeData.\n  markNodeDataDirty() {\n    this.nodeDataRefresh = true;\n    this._pickNodeCache.clear();\n    this.visibleMaybeChanged();\n  }\n  visibleMaybeChanged() {\n    this.ctx.seriesStateManager.registerSeries(this);\n  }\n  getOpacity() {\n    const defaultOpacity = 1;\n    const { dimOpacity = 1, enabled = true } = this.properties.highlightStyle.series;\n    if (!enabled || dimOpacity === defaultOpacity) {\n      return defaultOpacity;\n    }\n    switch (this.isItemIdHighlighted()) {\n      case 0 /* None */:\n      case 1 /* This */:\n        return defaultOpacity;\n      case 2 /* Other */:\n      default:\n        return dimOpacity;\n    }\n  }\n  getStrokeWidth(defaultStrokeWidth) {\n    const { strokeWidth, enabled = true } = this.properties.highlightStyle.series;\n    if (!enabled || strokeWidth === void 0) {\n      return defaultStrokeWidth;\n    }\n    switch (this.isItemIdHighlighted()) {\n      case 1 /* This */:\n        return strokeWidth;\n      case 0 /* None */:\n      case 2 /* Other */:\n        return defaultStrokeWidth;\n    }\n  }\n  isItemIdHighlighted() {\n    const series = this.ctx.highlightManager?.getActiveHighlight()?.series;\n    if (series == null) {\n      return 0 /* None */;\n    }\n    if (series !== this) {\n      return 2 /* Other */;\n    }\n    return 1 /* This */;\n  }\n  getModuleTooltipParams() {\n    return this.moduleMap.mapModules((module) => module.getTooltipParams()).reduce((total, current) => Object.assign(total, current), {});\n  }\n  pickNode(point, intent, exactMatchOnly = false) {\n    const { pickModes, visible, rootGroup } = this;\n    if (!visible || !rootGroup.visible)\n      return;\n    if (intent === \"highlight\" && !this.properties.highlight.enabled)\n      return;\n    if (intent === \"highlight-tooltip\" && !this.properties.highlight.enabled)\n      return;\n    if (intent === \"highlight\" && !this.properties.highlight.enabled)\n      return;\n    let maxDistance = Infinity;\n    if (intent === \"tooltip\" || intent === \"highlight-tooltip\") {\n      const { tooltip } = this.properties;\n      maxDistance = typeof tooltip.range === \"number\" ? tooltip.range : Infinity;\n      exactMatchOnly || (exactMatchOnly = tooltip.range === \"exact\");\n    } else if (intent === \"event\") {\n      const { nodeClickRange } = this.properties;\n      maxDistance = typeof nodeClickRange === \"number\" ? nodeClickRange : Infinity;\n      exactMatchOnly || (exactMatchOnly = nodeClickRange === \"exact\");\n    }\n    const selectedPickModes = pickModes.filter(\n      (m) => !exactMatchOnly || m === 0 /* EXACT_SHAPE_MATCH */\n    );\n    const { x, y } = point;\n    const key = JSON.stringify({ x, y, maxDistance, selectedPickModes });\n    if (this._pickNodeCache.has(key)) {\n      return this._pickNodeCache.get(key);\n    }\n    for (const pickMode of selectedPickModes) {\n      let match;\n      switch (pickMode) {\n        case 0 /* EXACT_SHAPE_MATCH */:\n          match = this.pickNodeExactShape(point);\n          break;\n        case 1 /* NEAREST_BY_MAIN_AXIS_FIRST */:\n        case 2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */:\n          match = this.pickNodeMainAxisFirst(\n            point,\n            pickMode === 2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */\n          );\n          break;\n        case 3 /* NEAREST_NODE */:\n          match = this.pickNodeClosestDatum(point);\n          break;\n      }\n      if (match && match.distance <= maxDistance) {\n        return this._pickNodeCache.set(key, { pickMode, match: match.datum, distance: match.distance });\n      }\n    }\n    return this._pickNodeCache.set(key, void 0);\n  }\n  pickNodeExactShape(point) {\n    const match = this.contentGroup.pickNode(point.x, point.y);\n    if (match && match.datum.missing !== true) {\n      return { datum: match.datum, distance: 0 };\n    }\n    return void 0;\n  }\n  pickNodeClosestDatum(_point) {\n    throw new Error(\"AG Charts - Series.pickNodeClosestDatum() not implemented\");\n  }\n  pickNodeNearestDistantObject(point, items) {\n    const match = nearestSquared(point.x, point.y, items);\n    if (match.nearest !== void 0 && match.nearest.datum.missing !== true) {\n      return { datum: match.nearest.datum, distance: Math.sqrt(match.distanceSquared) };\n    }\n    return void 0;\n  }\n  pickNodeMainAxisFirst(_point, _requireCategoryAxis) {\n    throw new Error(\"AG Charts - Series.pickNodeMainAxisFirst() not implemented\");\n  }\n  fireNodeClickEvent(event, datum) {\n    this.fireEvent(new this.NodeEvent(\"nodeClick\", event, datum, this));\n  }\n  fireNodeDoubleClickEvent(event, datum) {\n    this.fireEvent(new this.NodeEvent(\"nodeDoubleClick\", event, datum, this));\n  }\n  createNodeContextMenuActionEvent(event, datum) {\n    return new this.NodeEvent(\"nodeContextMenuAction\", event, datum, this);\n  }\n  toggleSeriesItem(itemId, enabled) {\n    this.visible = enabled;\n    this.nodeDataRefresh = true;\n    this._pickNodeCache.clear();\n    this.dispatch(\"visibility-changed\", { itemId, enabled });\n  }\n  isEnabled() {\n    return this.visible;\n  }\n  getModuleMap() {\n    return this.moduleMap;\n  }\n  createModuleContext() {\n    return { ...this.ctx, series: this };\n  }\n  getLabelText(label, params, defaultFormatter = String) {\n    if (label.formatter) {\n      return this.ctx.callbackCache.call(label.formatter, { seriesId: this.id, ...params }) ?? defaultFormatter(params.value);\n    }\n    return defaultFormatter(params.value);\n  }\n  getMarkerStyle(marker, params, defaultStyle = marker.getStyle()) {\n    const defaultSize = { size: params.datum.point?.size ?? 0 };\n    const markerStyle = mergeDefaults(defaultSize, defaultStyle);\n    if (marker.itemStyler) {\n      const style = this.ctx.callbackCache.call(marker.itemStyler, {\n        seriesId: this.id,\n        ...markerStyle,\n        ...params,\n        datum: params.datum.datum\n      });\n      return mergeDefaults(style, markerStyle);\n    }\n    return markerStyle;\n  }\n  updateMarkerStyle(markerNode, marker, params, defaultStyle = marker.getStyle(), { applyTranslation = true } = {}) {\n    const { point } = params.datum;\n    const activeStyle = this.getMarkerStyle(marker, params, defaultStyle);\n    const visible = this.visible && activeStyle.size > 0 && point && !isNaN(point.x) && !isNaN(point.y);\n    if (applyTranslation) {\n      markerNode.setProperties({ visible, ...activeStyle, translationX: point?.x, translationY: point?.y });\n    } else {\n      markerNode.setProperties({ visible, ...activeStyle });\n    }\n    if (typeof marker.shape === \"function\" && !markerNode.dirtyPath) {\n      markerNode.path.clear(true);\n      markerNode.updatePath();\n      markerNode.checkPathDirty();\n    }\n  }\n  getMinRects(_width, _height) {\n    return;\n  }\n  get nodeDataDependencies() {\n    return this._nodeDataDependencies ?? { seriesRectWidth: NaN, seriesRectHeight: NaN };\n  }\n  checkResize(newSeriesRect) {\n    const { width: seriesRectWidth, height: seriesRectHeight } = newSeriesRect ?? { width: NaN, height: NaN };\n    const newNodeDataDependencies = newSeriesRect ? { seriesRectWidth, seriesRectHeight } : void 0;\n    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n    if (resize) {\n      this._nodeDataDependencies = newNodeDataDependencies;\n      this.markNodeDataDirty();\n    }\n    return resize;\n  }\n  pickFocus(_opts) {\n    return void 0;\n  }\n};\nSeries.highlightedZIndex = 1e12;\n__decorateClass([\n  ActionOnSet({\n    changeValue: function(newVal, oldVal) {\n      this.onSeriesGroupingChange(oldVal, newVal);\n    }\n  })\n], Series.prototype, \"seriesGrouping\", 2);\n\n// packages/ag-charts-community/src/chart/series/util.ts\nfunction convertValuesToScaleByDefs({\n  defs,\n  values,\n  xAxis,\n  yAxis\n}) {\n  if (!(xAxis && yAxis)) {\n    throw new Error(\"Axes must be defined\");\n  }\n  const result = {};\n  for (const [searchId, { def }] of defs) {\n    if (Object.hasOwn(values, searchId)) {\n      const { scale: scale2 } = def.type === \"key\" ? xAxis : yAxis;\n      result[searchId] = Math.round(scale2.convert(values[searchId]));\n    }\n  }\n  return result;\n}\nfunction pickNode(inputSeries, point, intent, exactMatchOnly) {\n  const reverseSeries = [...inputSeries].reverse();\n  let result;\n  for (const series of reverseSeries) {\n    if (!series.visible || !series.rootGroup.visible) {\n      continue;\n    }\n    const { match, distance: distance3 } = series.pickNode(point, intent, exactMatchOnly) ?? {};\n    if (!match || distance3 == null) {\n      continue;\n    }\n    if (!result || result.distance > distance3) {\n      result = { series, distance: distance3, datum: match };\n    }\n    if (distance3 === 0) {\n      break;\n    }\n  }\n  return result;\n}\n\n// packages/ag-charts-community/src/chart/series/seriesAreaClickManager.ts\nvar SeriesAreaClickManager = class extends BaseManager {\n  constructor(id, chart, ctx) {\n    super();\n    this.id = id;\n    this.chart = chart;\n    this.ctx = ctx;\n    this.series = [];\n    const seriesRegion = this.ctx.regionManager.getRegion(\"series\" /* SERIES */);\n    const horizontalAxesRegion = this.ctx.regionManager.getRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */);\n    const verticalAxesRegion = this.ctx.regionManager.getRegion(\"vertical-axes\" /* VERTICAL_AXES */);\n    this.destroyFns.push(\n      this.ctx.regionManager.listenAll(\"click\", (event) => this.onClick(event)),\n      this.ctx.regionManager.listenAll(\"dblclick\", (event) => this.onClick(event)),\n      this.ctx.layoutService.addListener(\"layout-complete\", (event) => this.layoutComplete(event)),\n      seriesRegion.addListener(\"hover\", (event) => this.onHover(event)),\n      seriesRegion.addListener(\"leave\", () => this.onLeave()),\n      horizontalAxesRegion.addListener(\"leave\", () => this.onLeave()),\n      verticalAxesRegion.addListener(\"leave\", () => this.onLeave())\n    );\n  }\n  seriesChanged(series) {\n    this.series = series;\n  }\n  dataChanged() {\n    this.lastHover = void 0;\n  }\n  preSceneRender() {\n    if (this.lastHover) {\n      this.onHover(this.lastHover);\n    }\n  }\n  update(type, opts) {\n    this.ctx.updateService.update(type, opts);\n  }\n  layoutComplete(event) {\n    this.seriesRect = event.series.paddedRect;\n  }\n  onLeave() {\n    this.lastHover = void 0;\n    this.ctx.cursorManager.updateCursor(this.id);\n  }\n  onHover({ offsetX, offsetY }) {\n    const found = pickNode(this.series, { x: offsetX, y: offsetY }, \"event\");\n    if (found?.series.hasEventListener(\"nodeClick\") || found?.series.hasEventListener(\"nodeDoubleClick\")) {\n      this.ctx.cursorManager.updateCursor(this.id, \"pointer\");\n    } else {\n      this.ctx.cursorManager.updateCursor(this.id);\n    }\n  }\n  onClick(event) {\n    if (this.seriesRect?.containsPoint(event.offsetX, event.offsetY) && this.checkSeriesNodeClick(event)) {\n      this.update(4 /* SERIES_UPDATE */);\n      event.preventDefault();\n      return;\n    }\n    const newEvent = { type: event.type === \"click\" ? \"click\" : \"doubleClick\", event: event.sourceEvent };\n    this.chart.fireEvent(newEvent);\n  }\n  checkSeriesNodeClick(event) {\n    const result = pickNode(this.series, { x: event.offsetX, y: event.offsetY }, \"event\");\n    if (result == null)\n      return false;\n    if (event.type === \"click\") {\n      result.series.fireNodeClickEvent(event.sourceEvent, result.datum);\n      return true;\n    }\n    if (event.type === \"dblclick\") {\n      event.preventZoomDblClick = result.distance === 0;\n      result.series.fireNodeDoubleClickEvent(event.sourceEvent, result.datum);\n      return true;\n    }\n    return false;\n  }\n};\n\n// packages/ag-charts-community/src/chart/keyboardUtil.ts\nfunction computeCenter(bboxOrPath) {\n  if (bboxOrPath instanceof BBox) {\n    return bboxOrPath.computeCenter();\n  }\n  return bboxOrPath?.computeTransformedBBox()?.computeCenter();\n}\nfunction drawPickedFocus(focusIndicator, pick) {\n  const { bounds, showFocusBox } = pick;\n  if (showFocusBox) {\n    focusIndicator?.updateBounds(bounds);\n  }\n}\nfunction makeKeyboardPointerEvent(focusIndicator, pick) {\n  drawPickedFocus(focusIndicator, pick);\n  const { x: offsetX, y: offsetY } = computeCenter(pick.bounds) ?? {};\n  if (offsetX !== void 0 && offsetY !== void 0) {\n    return { type: \"keyboard\", offsetX, offsetY };\n  }\n  return void 0;\n}\n\n// packages/ag-charts-community/src/chart/series/seriesAreaFocusManager.ts\nvar SeriesAreaFocusManager = class extends BaseManager {\n  constructor(id, chart, ctx, chartType2, overlays) {\n    super();\n    this.id = id;\n    this.chart = chart;\n    this.ctx = ctx;\n    this.chartType = chartType2;\n    this.overlays = overlays;\n    this.series = [];\n    this.focus = {\n      hasFocus: false,\n      series: void 0,\n      seriesIndex: 0,\n      datumIndex: 0,\n      datum: void 0\n    };\n    const seriesRegion = this.ctx.regionManager.getRegion(\"series\" /* SERIES */);\n    this.destroyFns.push(\n      this.ctx.layoutService.addListener(\"layout-complete\", (event) => this.layoutComplete(event)),\n      this.ctx.animationManager.addListener(\"animation-start\", () => this.onAnimationStart()),\n      seriesRegion.addListener(\"blur\", () => this.onBlur()),\n      seriesRegion.addListener(\"tab\", (event) => this.onTab(event)),\n      seriesRegion.addListener(\"nav-vert\", (event) => this.onNavVert(event)),\n      seriesRegion.addListener(\"nav-hori\", (event) => this.onNavHori(event)),\n      seriesRegion.addListener(\"submit\", (event) => this.onSubmit(event)),\n      this.ctx.keyNavManager.addListener(\"browserfocus\", (event) => this.onBrowserFocus(event)),\n      this.ctx.zoomManager.addListener(\"zoom-change\", () => {\n        this.ctx.focusIndicator.updateBounds(void 0);\n      })\n    );\n  }\n  seriesChanged(series) {\n    this.series = series;\n    this.onBlur();\n  }\n  dataChanged() {\n    this.ctx.focusIndicator.updateBounds(void 0);\n  }\n  preSceneRender() {\n    this.refreshFocus();\n  }\n  layoutComplete(event) {\n    this.seriesRect = event.series.rect;\n  }\n  refreshFocus() {\n    if (this.focus.hasFocus) {\n      this.handleSeriesFocus(0, 0);\n    }\n  }\n  onTab(event) {\n    this.handleFocus(0, 0);\n    event.preventDefault();\n    this.focus.hasFocus = true;\n  }\n  onNavVert(event) {\n    this.focus.seriesIndex += event.delta;\n    this.handleFocus(event.delta, 0);\n    event.preventDefault();\n  }\n  onNavHori(event) {\n    this.focus.datumIndex += event.delta;\n    this.handleFocus(0, event.delta);\n    event.preventDefault();\n  }\n  onBrowserFocus(event) {\n    if (event.delta > 0) {\n      this.focus.datum = void 0;\n      this.focus.series = void 0;\n      this.focus.datumIndex = 0;\n      this.focus.seriesIndex = 0;\n    } else if (event.delta < 0) {\n      this.focus.datum = void 0;\n      this.focus.series = void 0;\n      this.focus.datumIndex = Infinity;\n      this.focus.seriesIndex = Infinity;\n    }\n  }\n  onAnimationStart() {\n    if (this.focus.hasFocus) {\n      this.onBlur();\n    }\n  }\n  onBlur() {\n    this.ctx.focusIndicator.updateBounds(void 0);\n    this.focus.hasFocus = false;\n  }\n  handleFocus(seriesIndexDelta, datumIndexDelta) {\n    this.focus.hasFocus = true;\n    const overlayFocus = this.overlays.getFocusInfo(this.ctx.localeManager);\n    if (overlayFocus == null) {\n      this.handleSeriesFocus(seriesIndexDelta, datumIndexDelta);\n    } else {\n      this.ctx.focusIndicator.updateBounds(overlayFocus.rect);\n      this.ctx.ariaAnnouncementService.announceValue(overlayFocus.text);\n    }\n  }\n  handleSeriesFocus(otherIndexDelta, datumIndexDelta) {\n    if (this.chartType === \"hierarchy\") {\n      this.handleHierarchySeriesFocus(otherIndexDelta, datumIndexDelta);\n      return;\n    }\n    const { focus, seriesRect, series } = this;\n    const visibleSeries = series.filter((s) => s.visible);\n    if (visibleSeries.length === 0)\n      return;\n    focus.seriesIndex = clamp(0, focus.seriesIndex, visibleSeries.length - 1);\n    focus.series = visibleSeries[focus.seriesIndex];\n    const { datumIndex, seriesIndex: otherIndex } = focus;\n    const pick = focus.series.pickFocus({ datumIndex, datumIndexDelta, otherIndex, otherIndexDelta, seriesRect });\n    this.updatePickedFocus(pick);\n  }\n  handleHierarchySeriesFocus(otherIndexDelta, datumIndexDelta) {\n    this.focus.series = this.series[0];\n    const {\n      focus: { series, seriesIndex: otherIndex, datumIndex },\n      seriesRect\n    } = this;\n    if (series === void 0)\n      return;\n    const pick = series.pickFocus({ datumIndex, datumIndexDelta, otherIndex, otherIndexDelta, seriesRect });\n    this.updatePickedFocus(pick);\n  }\n  updatePickedFocus(pick) {\n    const { focus } = this;\n    if (pick === void 0 || focus.series === void 0)\n      return;\n    const { datum, datumIndex } = pick;\n    focus.datumIndex = datumIndex;\n    focus.datum = datum;\n    const keyboardEvent = makeKeyboardPointerEvent(this.ctx.focusIndicator, pick);\n    if (keyboardEvent !== void 0) {\n      const html = focus.series.getTooltipHtml(datum);\n      const meta = TooltipManager.makeTooltipMeta(keyboardEvent, datum);\n      const aria = this.getDatumAriaText(datum, html);\n      this.ctx.highlightManager.updateHighlight(this.id, datum);\n      this.ctx.tooltipManager.updateTooltip(this.id, meta, html);\n      this.ctx.ariaAnnouncementService.announceValue(\"ariaAnnounceHoverDatum\", { datum: aria });\n    }\n  }\n  onSubmit(event) {\n    const { series, datum } = this.focus;\n    const sourceEvent = event.sourceEvent.sourceEvent;\n    if (series !== void 0 && datum !== void 0) {\n      series.fireNodeClickEvent(sourceEvent, datum);\n    } else {\n      this.chart.fireEvent({\n        type: \"click\",\n        event: sourceEvent\n      });\n    }\n    event.preventDefault();\n  }\n  getDatumAriaText(datum, html) {\n    const description = html.ariaLabel;\n    return datum.series.getDatumAriaText?.(datum, description) ?? description;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesAreaHighlightManager.ts\nvar SeriesAreaHighlightManager = class extends BaseManager {\n  constructor(id, chart, ctx, highlight) {\n    super();\n    this.id = id;\n    this.chart = chart;\n    this.ctx = ctx;\n    this.highlight = highlight;\n    this.series = [];\n    this.hoverScheduler = debouncedAnimationFrame(() => {\n      if (!this.pendingHoverEvent)\n        return;\n      if (this.chart.performUpdateType <= 4 /* SERIES_UPDATE */) {\n        this.hoverScheduler.schedule();\n        return;\n      }\n      this.handleHover(false);\n    });\n    const seriesRegion = this.ctx.regionManager.getRegion(\"series\" /* SERIES */);\n    const horizontalAxesRegion = this.ctx.regionManager.getRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */);\n    const verticalAxesRegion = this.ctx.regionManager.getRegion(\"vertical-axes\" /* VERTICAL_AXES */);\n    const mouseMoveStates = 16 /* Default */ | 4 /* Annotations */;\n    this.destroyFns.push(\n      this.ctx.layoutService.addListener(\"layout-complete\", (event) => this.layoutComplete(event)),\n      this.ctx.highlightManager.addListener(\"highlight-change\", (event) => this.changeHighlightDatum(event)),\n      seriesRegion.addListener(\"hover\", (event) => this.onHover(event), mouseMoveStates),\n      seriesRegion.addListener(\"drag\", (event) => this.onHover(event), mouseMoveStates),\n      horizontalAxesRegion.addListener(\"hover\", (event) => this.onHover(event)),\n      verticalAxesRegion.addListener(\"hover\", (event) => this.onHover(event)),\n      // Cases where highlight should be cleared.\n      this.ctx.domManager.addListener(\"resize\", () => this.clearHighlight()),\n      seriesRegion.addListener(\"leave\", () => this.clearHighlight(), mouseMoveStates),\n      seriesRegion.addListener(\"blur\", () => this.clearHighlight()),\n      this.ctx.animationManager.addListener(\"animation-start\", () => this.clearHighlight()),\n      this.ctx.zoomManager.addListener(\"zoom-pan-start\", () => this.clearHighlight()),\n      this.ctx.zoomManager.addListener(\"zoom-change\", () => this.clearHighlight())\n    );\n  }\n  seriesChanged(series) {\n    this.series = series;\n  }\n  dataChanged() {\n    this.stashedHoverEvent ?? (this.stashedHoverEvent = this.appliedHoverEvent);\n    this.clearHighlight();\n  }\n  preSceneRender() {\n    if (this.stashedHoverEvent != null) {\n      this.pendingHoverEvent = this.stashedHoverEvent;\n      this.stashedHoverEvent = void 0;\n      this.handleHover(true);\n    }\n  }\n  update(type, opts) {\n    this.ctx.updateService.update(type, opts);\n  }\n  layoutComplete(event) {\n    this.hoverRect = event.series.paddedRect;\n  }\n  clearHighlight() {\n    this.pendingHoverEvent = void 0;\n    this.appliedHoverEvent = void 0;\n    this.ctx.highlightManager.updateHighlight(this.id);\n  }\n  onHover(event) {\n    this.pendingHoverEvent = event;\n    this.hoverScheduler.schedule();\n  }\n  handleHover(redisplay) {\n    this.appliedHoverEvent = this.pendingHoverEvent;\n    this.pendingHoverEvent = void 0;\n    const event = this.appliedHoverEvent;\n    if (!event)\n      return;\n    const state = this.ctx.interactionManager.getState();\n    if (state !== 16 /* Default */ && state !== 4 /* Annotations */)\n      return;\n    const { offsetX, offsetY } = event;\n    if (redisplay ? this.ctx.animationManager.isActive() : !this.hoverRect?.containsPoint(offsetX, offsetY)) {\n      this.clearHighlight();\n      return;\n    }\n    const { range: range3 } = this.highlight;\n    const intent = range3 === \"tooltip\" ? \"highlight-tooltip\" : \"highlight\";\n    const found = pickNode(this.series, { x: event.offsetX, y: event.offsetY }, intent);\n    if (found) {\n      this.ctx.highlightManager.updateHighlight(this.id, found.datum);\n      return;\n    }\n    this.ctx.highlightManager.updateHighlight(this.id);\n  }\n  changeHighlightDatum(event) {\n    const seriesToUpdate = /* @__PURE__ */ new Set();\n    const { series: newSeries = void 0, datum: newDatum } = event.currentHighlight ?? {};\n    const { series: lastSeries = void 0, datum: lastDatum } = event.previousHighlight ?? {};\n    if (lastSeries) {\n      seriesToUpdate.add(lastSeries);\n    }\n    if (newSeries) {\n      seriesToUpdate.add(newSeries);\n    }\n    if (lastSeries?.properties.cursor && lastDatum) {\n      this.ctx.cursorManager.updateCursor(lastSeries.id);\n    }\n    if (newSeries?.properties.cursor && newSeries?.properties.cursor !== \"default\" && newDatum) {\n      this.ctx.cursorManager.updateCursor(newSeries.id, newSeries.properties.cursor);\n    }\n    const updateAll = newSeries == null || lastSeries == null;\n    if (updateAll) {\n      this.update(4 /* SERIES_UPDATE */);\n    } else {\n      this.update(4 /* SERIES_UPDATE */, { seriesToUpdate });\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesAreaTooltipManager.ts\nvar SeriesAreaTooltipManager = class extends BaseManager {\n  constructor(id, chart, ctx, tooltip) {\n    super();\n    this.id = id;\n    this.chart = chart;\n    this.ctx = ctx;\n    this.tooltip = tooltip;\n    this.series = [];\n    this.hoverScheduler = debouncedAnimationFrame(() => {\n      if (!this.lastHover)\n        return;\n      if (this.chart.performUpdateType <= 4 /* SERIES_UPDATE */) {\n        this.hoverScheduler.schedule();\n        return;\n      }\n      this.handleHover(this.lastHover, false);\n    });\n    const seriesRegion = this.ctx.regionManager.getRegion(\"series\" /* SERIES */);\n    const horizontalAxesRegion = this.ctx.regionManager.getRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */);\n    const verticalAxesRegion = this.ctx.regionManager.getRegion(\"vertical-axes\" /* VERTICAL_AXES */);\n    this.destroyFns.push(\n      this.ctx.layoutService.addListener(\"layout-complete\", (event) => this.layoutComplete(event)),\n      seriesRegion.addListener(\n        \"hover\",\n        (event) => this.onHover(event),\n        16 /* Default */ | 4 /* Annotations */\n      ),\n      horizontalAxesRegion.addListener(\"hover\", (event) => this.onHover(event)),\n      verticalAxesRegion.addListener(\"hover\", (event) => this.onHover(event)),\n      // Events that clear tooltip.\n      seriesRegion.addListener(\"leave\", () => this.clearTooltip()),\n      seriesRegion.addListener(\"blur\", () => this.clearTooltip()),\n      seriesRegion.addListener(\"contextmenu\", () => this.clearTooltip(), 31 /* All */),\n      horizontalAxesRegion.addListener(\"leave\", () => this.clearTooltip()),\n      verticalAxesRegion.addListener(\"leave\", () => this.clearTooltip()),\n      this.ctx.animationManager.addListener(\"animation-start\", () => this.clearTooltip()),\n      this.ctx.domManager.addListener(\"resize\", () => this.clearTooltip()),\n      this.ctx.zoomManager.addListener(\"zoom-pan-start\", () => this.clearTooltip()),\n      this.ctx.zoomManager.addListener(\"zoom-change\", () => this.clearTooltip())\n    );\n  }\n  seriesChanged(series) {\n    this.series = series;\n  }\n  dataChanged() {\n    this.ctx.tooltipManager.removeTooltip(this.id);\n  }\n  preSceneRender() {\n    if (this.lastHover != null) {\n      this.handleHover(this.lastHover, true);\n    }\n  }\n  layoutComplete(event) {\n    this.hoverRect = event.series.paddedRect;\n  }\n  onHover(event) {\n    this.lastHover = event;\n    this.hoverScheduler.schedule();\n  }\n  clearTooltip() {\n    this.ctx.tooltipManager.removeTooltip(this.id);\n    this.lastHover = void 0;\n  }\n  handleHover(event, redisplay) {\n    const state = this.ctx.interactionManager.getState();\n    if (state !== 16 /* Default */ && state !== 4 /* Annotations */)\n      return;\n    const { offsetX, offsetY, targetElement } = event;\n    if (redisplay ? this.ctx.animationManager.isActive() : !this.hoverRect?.containsPoint(offsetX, offsetY)) {\n      this.clearTooltip();\n      return;\n    }\n    if (targetElement && this.tooltip.interactive && this.ctx.domManager.isManagedChildDOMElement(targetElement, \"canvas-overlay\", DEFAULT_TOOLTIP_CLASS)) {\n      return;\n    }\n    const pick = pickNode(this.series, { x: offsetX, y: offsetY }, \"tooltip\");\n    if (!pick) {\n      this.clearTooltip();\n      return;\n    }\n    const html = pick.series.getTooltipHtml(pick.datum);\n    const tooltipEnabled = this.tooltip.enabled && pick.series.tooltipEnabled;\n    const shouldUpdateTooltip = tooltipEnabled && html != null;\n    if (shouldUpdateTooltip) {\n      const meta = TooltipManager.makeTooltipMeta(event, pick.datum);\n      this.ctx.tooltipManager.updateTooltip(this.id, meta, html);\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesAreaManager.ts\nvar SeriesAreaManager = class extends BaseManager {\n  constructor(chart, ctx, chartType2, tooltip, highlight, overlays) {\n    super();\n    this.ctx = ctx;\n    this.id = createId(this);\n    this.series = [];\n    this.subManagers = [\n      new SeriesAreaFocusManager(this.id, chart, ctx, chartType2, overlays),\n      new SeriesAreaHighlightManager(this.id, chart, ctx, highlight),\n      new SeriesAreaTooltipManager(this.id, chart, ctx, tooltip),\n      new SeriesAreaClickManager(this.id, chart, ctx)\n    ];\n    const seriesRegion = this.ctx.regionManager.getRegion(\"series\" /* SERIES */);\n    this.destroyFns.push(\n      () => this.subManagers.forEach((s) => s.destroy()),\n      seriesRegion.addListener(\"contextmenu\", (event) => this.onContextMenu(event), 31 /* All */),\n      this.ctx.updateService.addListener(\"pre-scene-render\", () => this.preSceneRender())\n    );\n  }\n  dataChanged() {\n    for (const manager of this.subManagers) {\n      manager.dataChanged?.();\n    }\n  }\n  preSceneRender() {\n    for (const manager of this.subManagers) {\n      manager.preSceneRender?.();\n    }\n  }\n  seriesChanged(series) {\n    this.series = series;\n    for (const manager of this.subManagers) {\n      manager.seriesChanged(series);\n    }\n  }\n  onContextMenu(event) {\n    const { Default: Default2, ContextMenu } = InteractionState;\n    let pickedNode;\n    if (this.ctx.interactionManager.getState() & (Default2 | ContextMenu)) {\n      const match = pickNode(this.series, { x: event.offsetX, y: event.offsetY }, \"context-menu\");\n      if (match) {\n        this.ctx.highlightManager.updateHighlight(this.id);\n        pickedNode = match.datum;\n      }\n    }\n    this.ctx.contextMenuRegistry.dispatchContext(\"series\", event, { pickedNode });\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesLayerManager.ts\nvar SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION = 30;\nvar SeriesLayerManager = class {\n  constructor(seriesRoot, highlightRoot, annotationRoot) {\n    this.seriesRoot = seriesRoot;\n    this.highlightRoot = highlightRoot;\n    this.annotationRoot = annotationRoot;\n    this.groups = {};\n    this.series = {};\n    this.expectedSeriesCount = 1;\n    this.mode = \"normal\";\n  }\n  setSeriesCount(count) {\n    this.expectedSeriesCount = count;\n  }\n  requestGroup(seriesConfig) {\n    var _a, _b;\n    const {\n      internalId,\n      type,\n      rootGroup: seriesRootGroup,\n      highlightGroup: seriesHighlightGroup,\n      annotationGroup: seriesAnnotationGroup,\n      seriesGrouping\n    } = seriesConfig;\n    const { groupIndex = internalId } = seriesGrouping ?? {};\n    if (this.series[internalId] != null) {\n      throw new Error(`AG Charts - series already has an allocated layer: ${this.series[internalId]}`);\n    }\n    if (Object.keys(this.series).length === 0) {\n      this.mode = this.expectedSeriesCount >= SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION ? \"aggressive-grouping\" : \"normal\";\n    }\n    (_a = this.groups)[type] ?? (_a[type] = {});\n    const lookupIndex = this.lookupIdx(groupIndex);\n    let groupInfo = this.groups[type][lookupIndex];\n    if (!groupInfo) {\n      groupInfo = (_b = this.groups[type])[lookupIndex] ?? (_b[lookupIndex] = {\n        type,\n        id: lookupIndex,\n        seriesIds: [],\n        group: this.seriesRoot.appendChild(\n          new Group({\n            name: `${type}-content`,\n            layer: true,\n            zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n            zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder(\"data\")\n          })\n        ),\n        highlight: this.highlightRoot.appendChild(\n          new Group({\n            name: `${type}-highlight`,\n            zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n            zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder(\"highlight\")\n          })\n        ),\n        annotation: this.annotationRoot.appendChild(\n          new Group({\n            name: `${type}-annotation`,\n            zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n            zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder(\"annotation\")\n          })\n        )\n      });\n    }\n    this.series[internalId] = { layerState: groupInfo, seriesConfig };\n    groupInfo.seriesIds.push(internalId);\n    groupInfo.group.appendChild(seriesRootGroup);\n    groupInfo.highlight.appendChild(seriesHighlightGroup);\n    groupInfo.annotation.appendChild(seriesAnnotationGroup);\n    return groupInfo.group;\n  }\n  changeGroup(seriesConfig) {\n    const { internalId, seriesGrouping, type, rootGroup, highlightGroup, annotationGroup, oldGrouping } = seriesConfig;\n    const { groupIndex = internalId } = seriesGrouping ?? {};\n    if (this.groups[type]?.[groupIndex]?.seriesIds.includes(internalId)) {\n      return;\n    }\n    if (this.series[internalId] != null) {\n      this.releaseGroup({\n        internalId,\n        seriesGrouping: oldGrouping,\n        type,\n        rootGroup,\n        highlightGroup,\n        annotationGroup\n      });\n    }\n    this.requestGroup(seriesConfig);\n  }\n  releaseGroup(seriesConfig) {\n    const { internalId, rootGroup, highlightGroup, annotationGroup, type } = seriesConfig;\n    if (this.series[internalId] == null) {\n      throw new Error(`AG Charts - series doesn't have an allocated layer: ${internalId}`);\n    }\n    const groupInfo = this.series[internalId]?.layerState;\n    if (groupInfo) {\n      groupInfo.seriesIds = groupInfo.seriesIds.filter((v) => v !== internalId);\n      groupInfo.group.removeChild(rootGroup);\n      groupInfo.highlight.removeChild(highlightGroup);\n      groupInfo.annotation.removeChild(annotationGroup);\n    }\n    if (groupInfo?.seriesIds.length === 0) {\n      this.seriesRoot.removeChild(groupInfo.group);\n      this.highlightRoot.removeChild(groupInfo.highlight);\n      this.annotationRoot.removeChild(groupInfo.annotation);\n      delete this.groups[groupInfo.type][groupInfo.id];\n      delete this.groups[type][internalId];\n    } else if (groupInfo?.seriesIds.length > 0) {\n      const leadSeriesConfig = this.series[groupInfo?.seriesIds?.[0]]?.seriesConfig;\n      groupInfo.group.zIndexSubOrder = leadSeriesConfig?.getGroupZIndexSubOrder(\"data\");\n      groupInfo.highlight.zIndexSubOrder = leadSeriesConfig?.getGroupZIndexSubOrder(\"highlight\");\n      groupInfo.annotation.zIndexSubOrder = leadSeriesConfig?.getGroupZIndexSubOrder(\"annotation\");\n    }\n    delete this.series[internalId];\n  }\n  lookupIdx(groupIndex) {\n    if (this.mode === \"normal\") {\n      return groupIndex;\n    }\n    if (typeof groupIndex === \"string\") {\n      groupIndex = Number(groupIndex.split(\"-\").at(-1));\n      if (!groupIndex) {\n        return 0;\n      }\n    }\n    return Math.floor(\n      clamp(0, groupIndex / this.expectedSeriesCount, 1) * SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION\n    );\n  }\n  destroy() {\n    for (const groups of Object.values(this.groups)) {\n      for (const groupInfo of Object.values(groups)) {\n        this.seriesRoot.removeChild(groupInfo.group);\n        this.highlightRoot.removeChild(groupInfo.highlight);\n        this.annotationRoot.removeChild(groupInfo.annotation);\n      }\n    }\n    this.groups = {};\n    this.series = {};\n  }\n};\n\n// packages/ag-charts-community/src/chart/update/baseLayoutProcessor.ts\nvar BaseLayoutProcessor = class {\n  constructor(chartLike, layoutService) {\n    this.chartLike = chartLike;\n    this.layoutService = layoutService;\n    this.destroyFns = [];\n    this.destroyFns.push(\n      // eslint-disable-next-line sonarjs/no-duplicate-string\n      this.layoutService.addListener(\"start-layout\", (e) => this.positionPadding(e)),\n      this.layoutService.addListener(\"layout-complete\", (e) => this.alignCaptions(e)),\n      this.layoutService.addListener(\"start-layout\", (e) => this.positionCaptions(e))\n    );\n  }\n  destroy() {\n    this.destroyFns.forEach((cb) => cb());\n  }\n  positionPadding(ctx) {\n    const { shrinkRect } = ctx;\n    const { padding } = this.chartLike;\n    shrinkRect.shrink(padding.left, \"left\");\n    shrinkRect.shrink(padding.top, \"top\");\n    shrinkRect.shrink(padding.right, \"right\");\n    shrinkRect.shrink(padding.bottom, \"bottom\");\n    return { ...ctx, shrinkRect };\n  }\n  positionCaptions(ctx) {\n    const { shrinkRect, positions, padding } = ctx;\n    const { title, subtitle, footnote, titlePadding } = this.chartLike;\n    const paddedShrinkRect = shrinkRect.clone().shrink(titlePadding);\n    const newShrinkRect = shrinkRect.clone();\n    const updateCaption = (caption) => {\n      const defaultCaptionHeight = shrinkRect.height / 10;\n      const captionLineHeight = caption.lineHeight ?? caption.fontSize * Text.defaultLineHeightRatio;\n      const maxWidth = shrinkRect.width;\n      const maxHeight = Math.max(captionLineHeight, defaultCaptionHeight);\n      caption.computeTextWrap(maxWidth, maxHeight);\n    };\n    const computeX = (align) => {\n      if (align === \"left\") {\n        return paddedShrinkRect.x;\n      } else if (align === \"right\") {\n        return paddedShrinkRect.x + paddedShrinkRect.width;\n      } else if (align !== \"center\") {\n        Logger.error(`invalid textAlign value: ${align}`);\n      }\n      return paddedShrinkRect.x + paddedShrinkRect.width / 2;\n    };\n    const positionTopAndShrinkBBox = (caption, spacing) => {\n      const baseY = paddedShrinkRect.y;\n      caption.node.x = computeX(caption.textAlign);\n      caption.node.y = baseY;\n      caption.node.textBaseline = \"top\";\n      updateCaption(caption);\n      const bbox = caption.node.getBBox();\n      const bboxHeight = Math.ceil(bbox.y - baseY + bbox.height + spacing);\n      if (caption.layoutStyle === \"block\") {\n        newShrinkRect.shrink(bboxHeight + 2 * titlePadding, \"top\");\n        paddedShrinkRect.shrink(bboxHeight, \"top\");\n      }\n      return bbox;\n    };\n    const positionBottomAndShrinkBBox = (caption, spacing) => {\n      const baseY = paddedShrinkRect.y + paddedShrinkRect.height;\n      caption.node.x = computeX(caption.textAlign);\n      caption.node.y = baseY;\n      caption.node.textBaseline = \"bottom\";\n      updateCaption(caption);\n      const bbox = caption.node.getBBox();\n      const bboxHeight = Math.ceil(baseY - bbox.y + spacing);\n      if (caption.layoutStyle === \"block\") {\n        newShrinkRect.shrink(bboxHeight + 2 * titlePadding, \"bottom\");\n        paddedShrinkRect.shrink(bboxHeight, \"bottom\");\n      }\n      return bbox;\n    };\n    title.node.visible = title.enabled;\n    subtitle.node.visible = subtitle.enabled;\n    footnote.node.visible = footnote.enabled;\n    if (title.enabled) {\n      const { spacing = subtitle.enabled ? Caption.SMALL_PADDING : Caption.LARGE_PADDING } = title;\n      positions.title = positionTopAndShrinkBBox(title, spacing);\n    }\n    if (subtitle.enabled) {\n      positions.subtitle = positionTopAndShrinkBBox(subtitle, subtitle.spacing ?? 0);\n    }\n    if (footnote.enabled) {\n      positions.footnote = positionBottomAndShrinkBBox(footnote, footnote.spacing ?? 0);\n    }\n    padding.title = titlePadding;\n    return { ...ctx, shrinkRect: newShrinkRect, positions };\n  }\n  alignCaptions(ctx) {\n    const { rect } = ctx.series;\n    const { title, subtitle, footnote, titlePadding } = this.chartLike;\n    for (const caption of [title, subtitle, footnote]) {\n      if (caption.layoutStyle !== \"overlay\")\n        continue;\n      if (caption.textAlign === \"left\") {\n        caption.node.x = rect.x + titlePadding;\n      } else if (caption.textAlign === \"right\") {\n        const bbox = caption.node.getBBox();\n        caption.node.x = rect.x + rect.width - bbox.width - titlePadding;\n      }\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/update/dataWindowProcessor.ts\nvar DataWindowProcessor = class {\n  constructor(chart, dataService, updateService, zoomManager) {\n    this.chart = chart;\n    this.dataService = dataService;\n    this.updateService = updateService;\n    this.zoomManager = zoomManager;\n    this.dirtyZoom = false;\n    this.dirtyDataSource = false;\n    this.lastAxisZooms = /* @__PURE__ */ new Map();\n    this.destroyFns = [];\n    this.destroyFns.push(\n      this.dataService.addListener(\"data-source-change\", () => this.onDataSourceChange()),\n      this.dataService.addListener(\"data-load\", () => this.onDataLoad()),\n      this.dataService.addListener(\"data-error\", () => this.onDataError()),\n      this.updateService.addListener(\"update-complete\", () => this.onUpdateComplete()),\n      this.zoomManager.addListener(\"zoom-change\", () => this.onZoomChange())\n    );\n  }\n  destroy() {\n    this.destroyFns.forEach((cb) => cb());\n  }\n  onDataLoad() {\n    this.updateService.update(1 /* UPDATE_DATA */);\n  }\n  onDataError() {\n    this.updateService.update(3 /* PERFORM_LAYOUT */);\n  }\n  onDataSourceChange() {\n    this.dirtyDataSource = true;\n  }\n  onUpdateComplete() {\n    if (!this.dirtyZoom && !this.dirtyDataSource)\n      return;\n    this.updateWindow().catch((e) => Logger.errorOnce(e));\n  }\n  onZoomChange() {\n    this.dirtyZoom = true;\n  }\n  async updateWindow() {\n    if (!this.dataService.isLazy())\n      return;\n    const axis = this.getValidAxis();\n    let window2;\n    let shouldRefresh = true;\n    if (axis) {\n      const zoom2 = this.zoomManager.getAxisZoom(axis.id);\n      window2 = this.getAxisWindow(axis, zoom2);\n      shouldRefresh = this.shouldRefresh(axis, zoom2);\n    }\n    this.dirtyZoom = false;\n    this.dirtyDataSource = false;\n    if (!shouldRefresh)\n      return;\n    this.dataService.load({ windowStart: window2?.min, windowEnd: window2?.max });\n  }\n  getValidAxis() {\n    return this.chart.axes.find((axis) => axis.type === \"time\");\n  }\n  shouldRefresh(axis, zoom2) {\n    if (this.dirtyDataSource)\n      return true;\n    if (!this.dirtyZoom)\n      return false;\n    const lastZoom = this.lastAxisZooms.get(axis.id);\n    if (lastZoom && zoom2.min === lastZoom.min && zoom2.max === lastZoom.max) {\n      return false;\n    }\n    this.lastAxisZooms.set(axis.id, zoom2);\n    return true;\n  }\n  getAxisWindow(axis, zoom2) {\n    const domain = axis.scale.getDomain?.();\n    if (!zoom2 || !domain || domain.length === 0 || isNaN(Number(domain[0])))\n      return;\n    const diff2 = Number(domain[1]) - Number(domain[0]);\n    const min = new Date(Number(domain[0]) + diff2 * zoom2.min);\n    const max = new Date(Number(domain[0]) + diff2 * zoom2.max);\n    return { min, max };\n  }\n};\n\n// packages/ag-charts-community/src/chart/update/overlaysProcessor.ts\nvar OverlaysProcessor = class {\n  constructor(chartLike, overlays, dataService, layoutService, localeManager, animationManager, domManager) {\n    this.chartLike = chartLike;\n    this.overlays = overlays;\n    this.dataService = dataService;\n    this.layoutService = layoutService;\n    this.localeManager = localeManager;\n    this.animationManager = animationManager;\n    this.domManager = domManager;\n    this.destroyFns = [];\n    this.overlayElem = this.domManager.addChild(\"canvas-overlay\", \"overlay\");\n    this.overlayElem.role = \"status\";\n    this.overlayElem.ariaAtomic = \"false\";\n    this.overlayElem.ariaLive = \"polite\";\n    this.overlayElem.classList.toggle(DEFAULT_OVERLAY_CLASS);\n    this.destroyFns.push(this.layoutService.addListener(\"layout-complete\", (e) => this.onLayoutComplete(e)));\n  }\n  destroy() {\n    this.destroyFns.forEach((cb) => cb());\n    this.domManager.removeStyles(\"overlays\");\n    this.domManager.removeChild(\"canvas-overlay\", \"overlay\");\n  }\n  onLayoutComplete({ series: { rect } }) {\n    const isLoading = this.dataService.isLoading();\n    const hasData = this.chartLike.series.some((s) => s.hasData);\n    const anySeriesVisible = this.chartLike.series.some((s) => s.visible);\n    if (this.overlays.darkTheme) {\n      this.overlayElem.classList.add(DEFAULT_OVERLAY_DARK_CLASS);\n    } else {\n      this.overlayElem.classList.remove(DEFAULT_OVERLAY_DARK_CLASS);\n    }\n    this.overlayElem.style.left = `${rect.x}px`;\n    this.overlayElem.style.top = `${rect.y}px`;\n    this.overlayElem.style.width = `${rect.width}px`;\n    this.overlayElem.style.height = `${rect.height}px`;\n    this.toggleOverlay(this.overlays.loading, rect, isLoading);\n    this.toggleOverlay(this.overlays.noData, rect, !isLoading && !hasData);\n    this.toggleOverlay(this.overlays.noVisibleSeries, rect, hasData && !anySeriesVisible);\n  }\n  toggleOverlay(overlay, seriesRect, visible) {\n    this.overlayElem.ariaHidden = (!visible).toString();\n    if (visible) {\n      const element2 = overlay.getElement(this.animationManager, this.localeManager, seriesRect);\n      this.overlayElem.appendChild(element2);\n    } else {\n      overlay.removeElement(() => {\n        this.overlayElem.innerText = \"\\xA0\";\n      }, this.animationManager);\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/chart.ts\nvar debug = Debug.create(true, \"opts\");\nvar SeriesArea = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.padding = new Padding(0);\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], SeriesArea.prototype, \"clip\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesArea.prototype, \"padding\", 2);\nvar _Chart = class _Chart extends Observable {\n  constructor(options, resources) {\n    var _a;\n    super();\n    this.id = createId(this);\n    this.seriesRoot = new Group({ name: `${this.id}-series-root` });\n    this.highlightRoot = new Group({\n      name: `${this.id}-highlight-root`,\n      layer: true,\n      zIndex: 5 /* SERIES_HIGHLIGHT_ZINDEX */,\n      nonEmptyChildDerivedZIndex: true\n    });\n    this.annotationRoot = new Group({\n      name: `${this.id}-annotation-root`,\n      layer: true,\n      zIndex: 10 /* SERIES_ANNOTATION_ZINDEX */\n    });\n    this.debug = Debug.create();\n    this.extraDebugStats = {};\n    this.data = [];\n    this._firstAutoSize = true;\n    this.padding = new Padding(20);\n    this.titlePadding = 0;\n    this.seriesArea = new SeriesArea();\n    this.title = new Caption();\n    this.subtitle = new Caption();\n    this.footnote = new Caption();\n    this.keyboard = new Keyboard();\n    this.mode = \"standalone\";\n    this.destroyed = false;\n    this._skipSync = false;\n    this._destroyFns = [];\n    this.chartAnimationPhase = \"initial\";\n    this.modulesManager = new ModulesManager();\n    // FIXME: zoomManager should be owned by ctx, but it can't because it is used by CartesianChart.onAxisChange before ctx is initialised\n    this.zoomManager = new ZoomManager();\n    this.processors = [];\n    this.queuedUserOptions = [];\n    this._pendingFactoryUpdatesCount = 0;\n    this._performUpdateNoRenderCount = 0;\n    this._performUpdateSkipAnimations = false;\n    this.performUpdateType = 7 /* NONE */;\n    this.updateShortcutCount = 0;\n    this.seriesToUpdate = /* @__PURE__ */ new Set();\n    this.updateMutex = new Mutex();\n    this.updateRequestors = {};\n    this.performUpdateTrigger = debouncedCallback(async ({ count }) => {\n      if (this.destroyed)\n        return;\n      this.updateMutex.acquire(async () => {\n        try {\n          await this.performUpdate(count);\n        } catch (error) {\n          Logger.error(\"update error\", error);\n        }\n      }).catch((e) => Logger.errorOnce(e));\n    });\n    this._performUpdateSplits = {};\n    this.axes = [];\n    this.series = [];\n    this.onSeriesNodeClick = (event) => {\n      const seriesNodeClickEvent = {\n        ...event,\n        type: \"seriesNodeClick\"\n      };\n      Object.defineProperty(seriesNodeClickEvent, \"series\", {\n        enumerable: false,\n        // Should display the deprecation warning\n        get: () => event.series\n      });\n      this.fireEvent(seriesNodeClickEvent);\n    };\n    this.onSeriesNodeDoubleClick = (event) => {\n      const seriesNodeDoubleClick = {\n        ...event,\n        type: \"seriesNodeDoubleClick\"\n      };\n      this.fireEvent(seriesNodeDoubleClick);\n    };\n    this.seriesGroupingChanged = (event) => {\n      if (!(event instanceof SeriesGroupingChangedEvent))\n        return;\n      const { series, seriesGrouping, oldGrouping } = event;\n      if (series.rootGroup.parent == null)\n        return;\n      this.seriesLayerManager.changeGroup({\n        internalId: series.internalId,\n        type: series.type,\n        rootGroup: series.rootGroup,\n        highlightGroup: series.highlightGroup,\n        annotationGroup: series.annotationGroup,\n        getGroupZIndexSubOrder: (type) => series.getGroupZIndexSubOrder(type),\n        seriesGrouping,\n        oldGrouping\n      });\n    };\n    this.dataProcessListeners = /* @__PURE__ */ new Set();\n    this.chartOptions = options;\n    const scene = resources?.scene;\n    const container = resources?.container;\n    const root = new Group({ name: \"root\" });\n    const titleGroup = new Group({ name: \"titles\", layer: true, zIndex: 8 /* SERIES_LABEL_ZINDEX */ });\n    root.visible = false;\n    root.append(titleGroup);\n    root.append(this.seriesRoot);\n    root.append(this.highlightRoot);\n    root.append(this.annotationRoot);\n    titleGroup.append(this.title.node);\n    titleGroup.append(this.subtitle.node);\n    titleGroup.append(this.footnote.node);\n    const { overrideDevicePixelRatio } = options.specialOverrides;\n    this.tooltip = new Tooltip();\n    this.seriesLayerManager = new SeriesLayerManager(this.seriesRoot, this.highlightRoot, this.annotationRoot);\n    const ctx = this.ctx = new ChartContext(this, {\n      scene,\n      root,\n      syncManager: new SyncManager(this),\n      container,\n      updateCallback: (type = 0 /* FULL */, opts) => this.update(type, opts),\n      updateMutex: this.updateMutex,\n      overrideDevicePixelRatio\n    });\n    this._destroyFns.push(\n      ctx.domManager.addListener(\"resize\", () => this.parentResize(ctx.domManager.containerSize))\n    );\n    this.overlays = new ChartOverlays();\n    (_a = this.overlays.loading).renderer ?? (_a.renderer = () => getLoadingSpinner(this.overlays.loading.getText(ctx.localeManager), ctx.animationManager.defaultDuration));\n    this.processors = [\n      new BaseLayoutProcessor(this, ctx.layoutService),\n      new DataWindowProcessor(this, ctx.dataService, ctx.updateService, ctx.zoomManager),\n      new OverlaysProcessor(\n        this,\n        this.overlays,\n        ctx.dataService,\n        ctx.layoutService,\n        ctx.localeManager,\n        ctx.animationManager,\n        ctx.domManager\n      )\n    ];\n    this.highlight = new ChartHighlight();\n    this.container = container;\n    const moduleContext = this.getModuleContext();\n    ctx.regionManager.addRegion(\"series\" /* SERIES */, this.seriesRoot, this.ctx.axisManager.axisGridGroup);\n    ctx.regionManager.addRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */);\n    ctx.regionManager.addRegion(\"vertical-axes\" /* VERTICAL_AXES */);\n    const thisChart = this;\n    this.seriesAreaManager = new SeriesAreaManager(\n      {\n        fireEvent: this.fireEvent.bind(thisChart),\n        get performUpdateType() {\n          return thisChart.performUpdateType;\n        }\n      },\n      ctx,\n      this.getChartType(),\n      this.tooltip,\n      this.highlight,\n      this.overlays\n    );\n    ctx.regionManager.addRegion(\"root\", root);\n    this._destroyFns.push(\n      ctx.dataService.addListener(\"data-load\", (event) => {\n        this.data = event.data;\n      }),\n      this.title.registerInteraction(moduleContext),\n      this.subtitle.registerInteraction(moduleContext),\n      this.footnote.registerInteraction(moduleContext),\n      ctx.interactionManager.addListener(\"page-left\", () => this.destroy()),\n      ctx.animationManager.addListener(\"animation-frame\", () => {\n        this.update(6 /* SCENE_RENDER */);\n      }),\n      ctx.zoomManager.addListener(\"zoom-change\", () => {\n        this.series.map((s) => s.animationState?.transition(\"updateData\"));\n        const skipAnimations = this.chartAnimationPhase !== \"initial\";\n        this.update(3 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });\n      })\n    );\n    this.parentResize(ctx.domManager.containerSize);\n  }\n  static getInstance(element2) {\n    return _Chart.chartsInstances.get(element2);\n  }\n  /** NOTE: This is exposed for use by Integrated charts only. */\n  get canvasElement() {\n    return this.ctx.scene.canvas.element;\n  }\n  download(fileName, fileFormat) {\n    this.ctx.scene.download(fileName, fileFormat);\n  }\n  getCanvasDataURL(fileFormat) {\n    return this.ctx.scene.getDataURL(fileFormat);\n  }\n  getOptions() {\n    return this.queuedUserOptions.at(-1) ?? this.chartOptions.userOptions;\n  }\n  getModuleContext() {\n    return this.ctx;\n  }\n  getCaptionText() {\n    return [this.title, this.subtitle, this.footnote].filter((caption) => caption.enabled && caption.text).map((caption) => caption.text).join(\". \");\n  }\n  getAriaLabel() {\n    return this.ctx.localeManager.t(\"ariaAnnounceChart\", { seriesCount: this.series.length });\n  }\n  resetAnimations() {\n    this.chartAnimationPhase = \"initial\";\n    for (const series of this.series) {\n      series.resetAnimation(this.chartAnimationPhase);\n    }\n    for (const axis of this.axes) {\n      axis.resetAnimation(this.chartAnimationPhase);\n    }\n    this.animationRect = void 0;\n    this.ctx.animationManager.reset();\n  }\n  skipAnimations() {\n    this.ctx.animationManager.skipCurrentBatch();\n    this._performUpdateSkipAnimations = true;\n  }\n  destroy(opts) {\n    if (this.destroyed) {\n      return;\n    }\n    const keepTransferableResources = opts?.keepTransferableResources;\n    let result;\n    this.performUpdateType = 7 /* NONE */;\n    this._destroyFns.forEach((fn) => fn());\n    this.processors.forEach((p) => p.destroy());\n    this.tooltip.destroy(this.ctx.domManager);\n    this.overlays.destroy();\n    this.modulesManager.destroy();\n    if (keepTransferableResources) {\n      this.ctx.scene.strip();\n      result = {\n        container: this.container,\n        scene: this.ctx.scene\n      };\n    } else {\n      this.ctx.scene.destroy();\n      this.container = void 0;\n    }\n    this.destroySeries(this.series);\n    this.seriesLayerManager.destroy();\n    this.axes.forEach((a) => a.destroy());\n    this.axes = [];\n    this.animationRect = void 0;\n    this.ctx.destroy();\n    this.zoomManager.destroy();\n    this.destroyed = true;\n    Object.freeze(this);\n    return result;\n  }\n  requestFactoryUpdate(cb) {\n    if (this.destroyed)\n      return;\n    this._pendingFactoryUpdatesCount++;\n    this.updateMutex.acquire(async () => {\n      if (this.destroyed)\n        return;\n      await cb(this);\n      if (this.destroyed)\n        return;\n      this._pendingFactoryUpdatesCount--;\n    }).catch((e) => Logger.errorOnce(e));\n  }\n  update(type = 0 /* FULL */, opts) {\n    const {\n      forceNodeDataRefresh = false,\n      skipAnimations,\n      seriesToUpdate = this.series,\n      newAnimationBatch\n    } = opts ?? {};\n    if (forceNodeDataRefresh) {\n      this.series.forEach((series) => series.markNodeDataDirty());\n    }\n    for (const series of seriesToUpdate) {\n      this.seriesToUpdate.add(series);\n    }\n    if (skipAnimations) {\n      this.ctx.animationManager.skipCurrentBatch();\n      this._performUpdateSkipAnimations = true;\n    }\n    if (newAnimationBatch && this.ctx.animationManager.isActive()) {\n      this._performUpdateSkipAnimations = true;\n    }\n    this._skipSync = opts?.skipSync ?? false;\n    if (this.debug.check()) {\n      let stack = new Error().stack ?? \"<unknown>\";\n      stack = stack.replace(/\\([^)]*/g, \"\");\n      this.updateRequestors[stack] = type;\n    }\n    if (type < this.performUpdateType) {\n      this.performUpdateType = type;\n      this.performUpdateTrigger.schedule(opts?.backOffMs);\n    }\n  }\n  async performUpdate(count) {\n    const { performUpdateType, extraDebugStats, _performUpdateSplits: splits, ctx } = this;\n    const seriesToUpdate = [...this.seriesToUpdate];\n    this.performUpdateType = 7 /* NONE */;\n    this.seriesToUpdate.clear();\n    if (this.updateShortcutCount === 0 && performUpdateType < 6 /* SCENE_RENDER */) {\n      ctx.animationManager.startBatch(this._performUpdateSkipAnimations);\n      ctx.animationManager.onBatchStop(() => this.chartAnimationPhase = \"ready\");\n    }\n    this.debug(\"Chart.performUpdate() - start\", ChartUpdateType[performUpdateType]);\n    let previousSplit = performance.now();\n    splits.start ?? (splits.start = previousSplit);\n    const updateSplits = (splitName) => {\n      splits[splitName] ?? (splits[splitName] = 0);\n      splits[splitName] += performance.now() - previousSplit;\n      previousSplit = performance.now();\n    };\n    let updateDeferred = false;\n    switch (performUpdateType) {\n      case 0 /* FULL */:\n        this.updateDOM();\n      case 1 /* UPDATE_DATA */:\n        await this.updateData();\n        updateSplits(\"\\u2B07\\uFE0F\");\n      case 2 /* PROCESS_DATA */:\n        await this.processData();\n        this.seriesAreaManager.dataChanged();\n        updateSplits(\"\\u{1F3ED}\");\n      case 3 /* PERFORM_LAYOUT */:\n        if (this.checkUpdateShortcut(3 /* PERFORM_LAYOUT */))\n          break;\n        if (!this.checkFirstAutoSize(seriesToUpdate)) {\n          updateDeferred = true;\n          break;\n        }\n        await this.processLayout();\n        updateSplits(\"\\u2316\");\n      case 4 /* SERIES_UPDATE */:\n        if (this.checkUpdateShortcut(4 /* SERIES_UPDATE */))\n          break;\n        const { seriesRect } = this;\n        await Promise.all(seriesToUpdate.map((series) => series.update({ seriesRect })));\n        updateSplits(\"\\u{1F914}\");\n      case 5 /* PRE_SCENE_RENDER */:\n        if (this.checkUpdateShortcut(5 /* PRE_SCENE_RENDER */))\n          break;\n        ctx.updateService.dispatchPreSceneRender(this.getMinRects());\n        updateSplits(\"\\u2196\");\n      case 6 /* SCENE_RENDER */:\n        if (this.checkUpdateShortcut(6 /* SCENE_RENDER */))\n          break;\n        ctx.animationManager.endBatch();\n        extraDebugStats[\"updateShortcutCount\"] = this.updateShortcutCount;\n        await ctx.scene.render({ debugSplitTimes: splits, extraDebugStats, seriesRect: this.seriesRect });\n        this.extraDebugStats = {};\n        for (const key in splits) {\n          delete splits[key];\n        }\n        this.ctx.domManager.incrementDataCounter(\"sceneRenders\");\n      case 7 /* NONE */:\n        this.updateShortcutCount = 0;\n        this.updateRequestors = {};\n        this._performUpdateSkipAnimations = false;\n        ctx.animationManager.endBatch();\n    }\n    if (!updateDeferred) {\n      ctx.updateService.dispatchUpdateComplete(this.getMinRects());\n    }\n    const end = performance.now();\n    this.debug(\"Chart.performUpdate() - end\", {\n      chart: this,\n      durationMs: Math.round((end - splits[\"start\"]) * 100) / 100,\n      count,\n      performUpdateType: ChartUpdateType[performUpdateType]\n    });\n  }\n  updateThemeClassName() {\n    const { theme } = this.chartOptions.processedOptions;\n    const themeClassNamePrefix = \"ag-charts-theme-\";\n    const validThemeClassNames = [`${themeClassNamePrefix}default`, `${themeClassNamePrefix}default-dark`];\n    let themeClassName = validThemeClassNames[0];\n    let isDark = false;\n    if (typeof theme === \"string\") {\n      themeClassName = theme.replace(\"ag-\", themeClassNamePrefix);\n      isDark = theme.includes(\"-dark\");\n    } else if (typeof theme?.baseTheme === \"string\") {\n      themeClassName = theme.baseTheme.replace(\"ag-\", themeClassNamePrefix);\n      isDark = theme.baseTheme.includes(\"-dark\");\n    }\n    if (!validThemeClassNames.includes(themeClassName)) {\n      themeClassName = isDark ? validThemeClassNames[1] : validThemeClassNames[0];\n    }\n    this.ctx.domManager.setThemeClass(themeClassName);\n  }\n  updateDOM() {\n    this.updateThemeClassName();\n    const { enabled, tabIndex } = this.keyboard;\n    this.ctx.domManager.setTabIndex(enabled ? tabIndex ?? 0 : -1);\n    setAttribute(this.ctx.scene.canvas.element, \"role\", \"img\");\n    setAttribute(this.ctx.scene.canvas.element, \"aria-label\", this.getAriaLabel());\n  }\n  checkUpdateShortcut(checkUpdateType) {\n    const maxShortcuts = 3;\n    if (this.updateShortcutCount > maxShortcuts) {\n      Logger.warn(\n        `exceeded the maximum number of simultaneous updates (${maxShortcuts + 1}), discarding changes and rendering`,\n        this.updateRequestors\n      );\n      return false;\n    }\n    if (this.performUpdateType <= checkUpdateType) {\n      this.updateShortcutCount++;\n      return true;\n    }\n    return false;\n  }\n  checkFirstAutoSize(seriesToUpdate) {\n    if (this.width != null && this.height != null) {\n    } else if (!this._lastAutoSize) {\n      const count = this._performUpdateNoRenderCount++;\n      const backOffMs = (count + 1) ** 2 * 40;\n      if (count < 8) {\n        this.update(3 /* PERFORM_LAYOUT */, { seriesToUpdate, backOffMs });\n        this.debug(\"Chart.checkFirstAutoSize() - backing off until first size update\", backOffMs);\n        return false;\n      }\n      this.debug(\"Chart.checkFirstAutoSize() - timeout for first size update.\");\n    }\n    this._performUpdateNoRenderCount = 0;\n    return true;\n  }\n  onAxisChange(newValue, oldValue) {\n    if (oldValue == null && newValue.length === 0)\n      return;\n    this.ctx.axisManager.updateAxes(oldValue ?? [], newValue);\n  }\n  onSeriesChange(newValue, oldValue) {\n    const seriesToDestroy = oldValue?.filter((series) => !newValue.includes(series)) ?? [];\n    this.destroySeries(seriesToDestroy);\n    this.seriesLayerManager?.setSeriesCount(newValue.length);\n    for (const series of newValue) {\n      if (oldValue?.includes(series))\n        continue;\n      if (series.rootGroup.parent == null) {\n        this.seriesLayerManager.requestGroup(series);\n      }\n      const chart = this;\n      series.chart = {\n        get mode() {\n          return chart.mode;\n        },\n        get isMiniChart() {\n          return false;\n        },\n        get seriesRect() {\n          return chart.seriesRect;\n        },\n        placeLabels() {\n          return chart.placeLabels();\n        }\n      };\n      series.resetAnimation(this.chartAnimationPhase);\n      this.addSeriesListeners(series);\n      series.addChartEventListeners();\n    }\n    this.seriesAreaManager?.seriesChanged(newValue);\n  }\n  destroySeries(allSeries) {\n    allSeries?.forEach((series) => {\n      series.removeEventListener(\"nodeClick\", this.onSeriesNodeClick);\n      series.removeEventListener(\"nodeDoubleClick\", this.onSeriesNodeDoubleClick);\n      series.removeEventListener(\"groupingChanged\", this.seriesGroupingChanged);\n      series.destroy();\n      this.seriesLayerManager.releaseGroup(series);\n      series.chart = void 0;\n    });\n  }\n  addSeriesListeners(series) {\n    if (this.hasEventListener(\"seriesNodeClick\")) {\n      series.addEventListener(\"nodeClick\", this.onSeriesNodeClick);\n    }\n    if (this.hasEventListener(\"seriesNodeDoubleClick\")) {\n      series.addEventListener(\"nodeDoubleClick\", this.onSeriesNodeDoubleClick);\n    }\n    series.addEventListener(\"groupingChanged\", this.seriesGroupingChanged);\n  }\n  updateAllSeriesListeners() {\n    this.series.forEach((series) => {\n      series.removeEventListener(\"nodeClick\", this.onSeriesNodeClick);\n      series.removeEventListener(\"nodeDoubleClick\", this.onSeriesNodeDoubleClick);\n      this.addSeriesListeners(series);\n    });\n  }\n  assignSeriesToAxes() {\n    this.axes.forEach((axis) => {\n      axis.boundSeries = this.series.filter((s) => {\n        const seriesAxis = s.axes[axis.direction];\n        return seriesAxis === axis;\n      });\n    });\n  }\n  assignAxesToSeries() {\n    const directionToAxesMap = groupBy(this.axes, (axis) => axis.direction);\n    this.series.forEach((series) => {\n      series.directions.forEach((direction) => {\n        const directionAxes = directionToAxesMap[direction];\n        if (!directionAxes) {\n          Logger.warnOnce(\n            `no available axis for direction [${direction}]; check series and axes configuration.`\n          );\n          return;\n        }\n        const seriesKeys = series.getKeys(direction);\n        const newAxis = directionAxes.find(\n          (axis) => !axis.keys.length || seriesKeys.some((key) => axis.keys.includes(key))\n        );\n        if (!newAxis) {\n          Logger.warnOnce(\n            `no matching axis for direction [${direction}] and keys [${seriesKeys}]; check series and axes configuration.`\n          );\n          return;\n        }\n        series.axes[direction] = newAxis;\n      });\n    });\n  }\n  parentResize(size) {\n    if (size == null || this.width != null && this.height != null)\n      return;\n    let { width, height } = size;\n    width = Math.floor(width);\n    height = Math.floor(height);\n    if (width === 0 && height === 0)\n      return;\n    const [autoWidth = 0, authHeight = 0] = this._lastAutoSize ?? [];\n    if (autoWidth === width && authHeight === height)\n      return;\n    this._lastAutoSize = [width, height];\n    this.resize(\"SizeMonitor\", {});\n  }\n  resize(source, opts) {\n    const { scene, animationManager } = this.ctx;\n    const { inWidth, inHeight, inMinWidth, inMinHeight } = opts;\n    this.ctx.domManager.setSizeOptions(\n      inMinWidth ?? this.minWidth,\n      inMinHeight ?? this.minHeight,\n      inWidth ?? this.width,\n      inHeight ?? this.height\n    );\n    const width = inWidth ?? this.width ?? this._lastAutoSize?.[0];\n    const height = inHeight ?? this.height ?? this._lastAutoSize?.[1];\n    this.debug(`Chart.resize() from ${source}`, { width, height, stack: new Error().stack });\n    if (width == null || height == null || !isFiniteNumber(width) || !isFiniteNumber(height))\n      return;\n    if (scene.resize(width, height)) {\n      animationManager.reset();\n      let skipAnimations = true;\n      if ((this.width == null || this.height == null) && this._firstAutoSize) {\n        skipAnimations = false;\n        this._firstAutoSize = false;\n      }\n      this.update(3 /* PERFORM_LAYOUT */, { forceNodeDataRefresh: true, skipAnimations });\n    }\n  }\n  async updateData() {\n    this.series.forEach((s) => s.setChartData(this.data));\n    const modulePromises = this.modulesManager.mapModules((m) => m.updateData?.({ data: this.data }));\n    await Promise.all(modulePromises);\n  }\n  async processData() {\n    if (this.series.some((s) => s.canHaveAxes)) {\n      this.assignAxesToSeries();\n      const syncModule = this.modulesManager.getModule(\"sync\");\n      if (syncModule?.enabled) {\n        syncModule.syncAxes(this._skipSync);\n      } else {\n        this.assignSeriesToAxes();\n      }\n    }\n    const dataController = new DataController(this.mode);\n    const seriesPromises = this.series.map((s) => s.processData(dataController));\n    const modulePromises = this.modulesManager.mapModules((m) => m.processData?.({ dataController }));\n    dataController.execute();\n    await Promise.all([...seriesPromises, ...modulePromises]);\n    for (const { legendType, legend } of this.modulesManager.legends()) {\n      legend.data = this.getLegendData(legendType, this.mode !== \"integrated\");\n    }\n    this.dataProcessListeners.forEach((resolve) => resolve());\n    this.dataProcessListeners.clear();\n  }\n  placeLabels() {\n    const visibleSeries = [];\n    const data = [];\n    for (const series of this.series) {\n      if (!series.visible)\n        continue;\n      const labelData = series.getLabelData();\n      if (isPointLabelDatum(labelData?.[0])) {\n        data.push(labelData);\n        visibleSeries.push(series);\n      }\n    }\n    const { seriesRect } = this;\n    const { top, right, bottom, left } = this.seriesArea.padding;\n    const labels = seriesRect && data.length > 0 ? placeLabels(data, {\n      x: -left,\n      y: -top,\n      width: seriesRect.width + left + right,\n      height: seriesRect.height + top + bottom\n    }) : [];\n    return new Map(labels.map((l, i) => [visibleSeries[i], l]));\n  }\n  getLegendData(legendType, warnConflicts) {\n    var _a;\n    const legendData = this.series.filter((s) => s.properties.showInLegend).flatMap((s) => s.getLegendData(legendType));\n    const isCategoryLegendData = (data) => data.every((d) => d.legendType === \"category\");\n    if (warnConflicts && isCategoryLegendData(legendData)) {\n      const seriesMarkerFills = {};\n      const seriesTypeMap = new Map(this.series.map((s) => [s.id, s.type]));\n      for (const {\n        seriesId,\n        symbols: [{ marker }],\n        label\n      } of legendData) {\n        if (marker.fill == null)\n          continue;\n        const seriesType2 = seriesTypeMap.get(seriesId);\n        const markerFill = seriesMarkerFills[seriesType2] ?? (seriesMarkerFills[seriesType2] = {});\n        markerFill[_a = label.text] ?? (markerFill[_a] = marker.fill);\n        if (markerFill[label.text] !== marker.fill) {\n          Logger.warnOnce(\n            `legend item '${label.text}' has multiple fill colors, this may cause unexpected behaviour.`\n          );\n        }\n      }\n    }\n    return legendData;\n  }\n  async processLayout() {\n    const oldRect = this.animationRect;\n    await this.performLayout();\n    if (oldRect && !this.animationRect?.equals(oldRect)) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n    this.debug(\"Chart.performUpdate() - seriesRect\", this.seriesRect);\n  }\n  async performLayout() {\n    const { width, height } = this.ctx.scene;\n    let ctx = { shrinkRect: new BBox(0, 0, width, height), positions: {}, padding: {} };\n    ctx = this.ctx.layoutService.dispatchPerformLayout(\"start-layout\", ctx);\n    ctx = this.ctx.layoutService.dispatchPerformLayout(\"before-series\", ctx);\n    for (const m of this.modulesManager.modules()) {\n      if (m.performLayout != null) {\n        ctx = await m.performLayout(ctx);\n      }\n    }\n    return ctx.shrinkRect;\n  }\n  async waitForUpdate(timeoutMs = 1e4, failOnTimeout = false) {\n    const start = performance.now();\n    if (this._pendingFactoryUpdatesCount > 0) {\n      await this.updateMutex.waitForClearAcquireQueue();\n    }\n    while (this.performUpdateType !== 7 /* NONE */) {\n      if (performance.now() - start > timeoutMs) {\n        const message = `Chart.waitForUpdate() timeout of ${timeoutMs} reached - first chart update taking too long.`;\n        if (failOnTimeout) {\n          throw new Error(message);\n        } else {\n          Logger.warnOnce(message);\n        }\n      }\n      await sleep(50);\n    }\n    await this.updateMutex.waitForClearAcquireQueue();\n  }\n  waitForDataProcess(timeout) {\n    return new Promise((resolve) => {\n      this.dataProcessListeners.add(resolve);\n      if (isNumber(timeout)) {\n        setTimeout(() => {\n          if (this.dataProcessListeners.has(resolve)) {\n            this.dataProcessListeners.delete(resolve);\n            resolve();\n          }\n        }, timeout);\n      }\n    });\n  }\n  getMinRects() {\n    const { width, height } = this.ctx.scene;\n    const minRects = this.series.map((series) => series.getMinRects(width, height)).filter(isDefined);\n    if (minRects.length === 0)\n      return;\n    let maxWidth = 0;\n    let maxHeight = 0;\n    let maxVisibleWidth = 0;\n    let maxVisibleHeight = 0;\n    for (const { minRect: minRect2, minVisibleRect: minVisibleRect2 } of minRects) {\n      maxWidth = Math.max(maxWidth, minRect2.width);\n      maxHeight = Math.max(maxHeight, minRect2.height);\n      maxVisibleWidth = Math.max(maxVisibleWidth, minVisibleRect2.width);\n      maxVisibleHeight = Math.max(maxVisibleHeight, minVisibleRect2.height);\n    }\n    const minRect = new BBox(0, 0, maxWidth, maxHeight);\n    let minVisibleRect = minRect.clone();\n    if (maxVisibleWidth > 0 && maxVisibleHeight > 0) {\n      minVisibleRect = new BBox(0, 0, maxVisibleWidth, maxVisibleHeight);\n    }\n    return { minRect, minVisibleRect };\n  }\n  filterMiniChartSeries(series) {\n    return series?.filter((s) => s.showInMiniChart !== false);\n  }\n  applyOptions(newChartOptions) {\n    const isDifferentOpts = newChartOptions !== this.chartOptions;\n    const oldOpts = isDifferentOpts ? this.chartOptions.processedOptions : {};\n    const newOpts = newChartOptions.processedOptions;\n    const deltaOptions = newChartOptions.diffOptions(oldOpts);\n    if (deltaOptions == null)\n      return;\n    debug(\"Chart.applyOptions() - applying delta\", deltaOptions);\n    const modulesChanged = this.applyModules(newOpts);\n    const skip = [\n      \"type\",\n      \"data\",\n      \"series\",\n      \"listeners\",\n      \"preset\",\n      \"theme\",\n      \"legend.listeners\",\n      \"navigator.miniChart.series\",\n      \"navigator.miniChart.label\",\n      \"locale.localeText\",\n      \"axes\",\n      \"topology\",\n      \"nodes\",\n      \"initialState\"\n    ];\n    if (deltaOptions.listeners) {\n      this.registerListeners(this, deltaOptions.listeners);\n    }\n    jsonApply(this, deltaOptions, { skip });\n    let forceNodeDataRefresh = false;\n    let seriesStatus = \"no-op\";\n    if (deltaOptions.series != null) {\n      seriesStatus = this.applySeries(this, deltaOptions.series, oldOpts?.series);\n      forceNodeDataRefresh = true;\n    }\n    if (seriesStatus === \"replaced\") {\n      this.resetAnimations();\n    }\n    if (this.applyAxes(this, newOpts, oldOpts, seriesStatus, [], true)) {\n      forceNodeDataRefresh = true;\n    }\n    if (deltaOptions.data) {\n      this.data = deltaOptions.data;\n    }\n    if (deltaOptions.legend?.listeners && this.modulesManager.isEnabled(\"legend\")) {\n      Object.assign(this.legend.listeners, deltaOptions.legend.listeners);\n    }\n    if (deltaOptions.listeners) {\n      this.updateAllSeriesListeners();\n    }\n    if (deltaOptions.locale?.localeText) {\n      this.modulesManager.getModule(\"locale\").localeText = deltaOptions.locale?.localeText;\n    }\n    this.chartOptions = newChartOptions;\n    const navigatorModule = this.modulesManager.getModule(\"navigator\");\n    const zoomModule = this.modulesManager.getModule(\"zoom\");\n    if (!navigatorModule?.enabled && !zoomModule?.enabled) {\n      this.ctx.zoomManager.updateZoom(\"chart\");\n    }\n    const miniChart = navigatorModule?.miniChart;\n    const miniChartSeries = newOpts.navigator?.miniChart?.series ?? newOpts.series;\n    if (miniChart?.enabled === true && miniChartSeries != null) {\n      this.applyMiniChartOptions(miniChart, miniChartSeries, newOpts, oldOpts);\n    } else if (miniChart?.enabled === false) {\n      miniChart.series = [];\n      miniChart.axes = [];\n    }\n    this.ctx.annotationManager.setAnnotationStyles(newChartOptions.annotationThemes);\n    forceNodeDataRefresh || (forceNodeDataRefresh = this.shouldForceNodeDataRefresh(deltaOptions, seriesStatus));\n    const majorChange = forceNodeDataRefresh || modulesChanged;\n    const updateType = majorChange ? 0 /* FULL */ : 3 /* PERFORM_LAYOUT */;\n    this.maybeResetAnimations(seriesStatus);\n    debug(\"Chart.applyOptions() - update type\", ChartUpdateType[updateType], {\n      seriesStatus,\n      forceNodeDataRefresh\n    });\n    this.update(updateType, { forceNodeDataRefresh, newAnimationBatch: true });\n    if (deltaOptions.initialState) {\n      this.applyInitialState(newChartOptions.userOptions.initialState);\n    }\n  }\n  applyInitialState(initialState) {\n    const {\n      ctx: { annotationManager, stateManager }\n    } = this;\n    if (initialState?.annotations != null) {\n      const annotations2 = initialState.annotations.map((annotation) => {\n        const annotationTheme = annotationManager.getAnnotationTypeStyles(annotation.type);\n        return mergeDefaults(annotation, annotationTheme);\n      });\n      stateManager.setState(annotationManager, annotations2);\n    }\n  }\n  maybeResetAnimations(seriesStatus) {\n    if (this.mode !== \"standalone\")\n      return;\n    switch (seriesStatus) {\n      case \"series-grouping-change\":\n      case \"replaced\":\n        this.resetAnimations();\n        break;\n      default:\n    }\n  }\n  shouldForceNodeDataRefresh(deltaOptions, seriesStatus) {\n    const seriesDataUpdate = !!deltaOptions.data || seriesStatus === \"data-change\" || seriesStatus === \"replaced\";\n    const legendKeys = legendRegistry.getKeys();\n    const optionsHaveLegend = Object.values(legendKeys).some(\n      (legendKey) => deltaOptions[legendKey] != null\n    );\n    const otherRefreshUpdate = deltaOptions.title != null && deltaOptions.subtitle != null;\n    return seriesDataUpdate || optionsHaveLegend || otherRefreshUpdate;\n  }\n  applyMiniChartOptions(miniChart, miniChartSeries, completeOptions, oldOpts) {\n    const oldSeries = oldOpts?.navigator?.miniChart?.series ?? oldOpts?.series;\n    const miniChartSeriesStatus = this.applySeries(\n      miniChart,\n      this.filterMiniChartSeries(miniChartSeries),\n      this.filterMiniChartSeries(oldSeries)\n    );\n    this.applyAxes(miniChart, completeOptions, oldOpts, miniChartSeriesStatus, [\n      \"axes[].tick\",\n      \"axes[].thickness\",\n      \"axes[].title\",\n      \"axes[].crosshair\",\n      \"axes[].gridLine\",\n      \"axes[].label\"\n    ]);\n    const axes = miniChart.axes;\n    const horizontalAxis = axes.find((axis) => axis.direction === \"x\" /* X */);\n    for (const axis of axes) {\n      axis.gridLine.enabled = false;\n      axis.label.enabled = axis === horizontalAxis;\n      axis.tick.enabled = false;\n      axis.interactionEnabled = false;\n    }\n    if (horizontalAxis != null) {\n      const miniChartOpts = completeOptions.navigator?.miniChart;\n      const labelOptions = miniChartOpts?.label;\n      const intervalOptions = miniChartOpts?.label?.interval;\n      horizontalAxis.line.enabled = false;\n      horizontalAxis.label.set(\n        without(labelOptions, [\"interval\", \"rotation\", \"minSpacing\", \"autoRotate\", \"autoRotateAngle\"])\n      );\n      horizontalAxis.tick.set(\n        without(intervalOptions, [\"enabled\", \"width\", \"size\", \"color\", \"interval\", \"step\"])\n      );\n      const step = intervalOptions?.step;\n      if (step != null) {\n        horizontalAxis.interval.step = step;\n      }\n    }\n  }\n  applyModules(options) {\n    const { type: chartType2 } = this.constructor;\n    let modulesChanged = false;\n    for (const module of moduleRegistry.byType(\"root\", \"legend\")) {\n      const isConfigured = options[module.optionsKey] != null;\n      const shouldBeEnabled = isConfigured && module.chartTypes.includes(chartType2);\n      if (shouldBeEnabled === this.modulesManager.isEnabled(module))\n        continue;\n      if (shouldBeEnabled) {\n        this.modulesManager.addModule(module, (m) => m.moduleFactory(this.getModuleContext()));\n        if (module.type === \"legend\") {\n          this.modulesManager.getModule(module)?.attachLegend(this.ctx.scene);\n        }\n        this[module.optionsKey] = this.modulesManager.getModule(module);\n      } else {\n        this.modulesManager.removeModule(module);\n        delete this[module.optionsKey];\n      }\n      modulesChanged = true;\n    }\n    return modulesChanged;\n  }\n  applySeries(chart, optSeries, oldOptSeries) {\n    if (!optSeries) {\n      return \"no-change\";\n    }\n    const matchResult = matchSeriesOptions(chart.series, optSeries, oldOptSeries);\n    if (matchResult.status === \"no-overlap\") {\n      debug(`Chart.applySeries() - creating new series instances, status: ${matchResult.status}`, matchResult);\n      chart.series = optSeries.map((opts) => this.createSeries(opts));\n      return \"replaced\";\n    }\n    debug(`Chart.applySeries() - matchResult`, matchResult);\n    const seriesInstances = [];\n    let dataChanged = false;\n    let groupingChanged = false;\n    let isUpdated = false;\n    for (const change of matchResult.changes) {\n      groupingChanged || (groupingChanged = change.status === \"series-grouping\");\n      dataChanged || (dataChanged = change.diff?.data != null);\n      isUpdated || (isUpdated = change.status !== \"no-op\");\n      switch (change.status) {\n        case \"add\":\n          const newSeries = this.createSeries(change.opts);\n          seriesInstances.push(newSeries);\n          debug(`Chart.applySeries() - created new series`, newSeries);\n          break;\n        case \"remove\":\n          debug(`Chart.applySeries() - removing series at previous idx ${change.idx}`, change.series);\n          break;\n        case \"no-op\":\n          seriesInstances.push(change.series);\n          debug(`Chart.applySeries() - no change to series at previous idx ${change.idx}`, change.series);\n          break;\n        case \"series-grouping\":\n        case \"update\":\n        default:\n          const { series, diff: diff2, idx } = change;\n          debug(`Chart.applySeries() - applying series diff previous idx ${idx}`, diff2, series);\n          this.applySeriesValues(series, diff2);\n          series.markNodeDataDirty();\n          seriesInstances.push(series);\n      }\n    }\n    for (let idx = 0; idx < seriesInstances.length; idx++) {\n      seriesInstances[idx]._declarationOrder = idx;\n    }\n    debug(`Chart.applySeries() - final series instances`, seriesInstances);\n    chart.series = seriesInstances;\n    if (groupingChanged) {\n      return \"series-grouping-change\";\n    }\n    if (dataChanged) {\n      return \"data-change\";\n    }\n    return isUpdated ? \"updated\" : \"no-op\";\n  }\n  applyAxes(chart, options, oldOpts, seriesStatus, skip = [], registerRegions = false) {\n    if (!(\"axes\" in options) || !options.axes) {\n      return false;\n    }\n    skip = [\"axes[].type\", ...skip];\n    const { axes } = options;\n    const forceRecreate = seriesStatus === \"replaced\";\n    const matchingTypes = !forceRecreate && chart.axes.length === axes.length && chart.axes.every((a, i) => a.type === axes[i].type);\n    if (matchingTypes && isAgCartesianChartOptions(oldOpts)) {\n      chart.axes.forEach((axis, index) => {\n        const previousOpts = oldOpts.axes?.[index] ?? {};\n        const axisDiff = jsonDiff(previousOpts, axes[index]);\n        debug(`Chart.applyAxes() - applying axis diff idx ${index}`, axisDiff);\n        const path = `axes[${index}]`;\n        jsonApply(axis, axisDiff, { path, skip });\n      });\n      return true;\n    }\n    debug(`Chart.applyAxes() - creating new axes instances; seriesStatus: ${seriesStatus}`);\n    chart.axes = this.createAxis(axes, skip);\n    const axisGroups = {\n      [\"x\" /* X */]: [],\n      [\"y\" /* Y */]: []\n    };\n    chart.axes.forEach((axis) => axisGroups[axis.direction].push(axis.getRegionBBoxProvider()));\n    if (registerRegions) {\n      this.ctx.regionManager.updateRegion(\"horizontal-axes\" /* HORIZONTAL_AXES */, ...axisGroups[\"x\" /* X */]);\n      this.ctx.regionManager.updateRegion(\"vertical-axes\" /* VERTICAL_AXES */, ...axisGroups[\"y\" /* Y */]);\n    }\n    return true;\n  }\n  createSeries(seriesOptions) {\n    const seriesInstance = seriesRegistry.create(seriesOptions.type, this.getModuleContext());\n    this.applySeriesOptionModules(seriesInstance, seriesOptions);\n    this.applySeriesValues(seriesInstance, seriesOptions);\n    return seriesInstance;\n  }\n  applySeriesOptionModules(series, options) {\n    const moduleContext = series.createModuleContext();\n    const moduleMap = series.getModuleMap();\n    for (const module of moduleRegistry.byType(\"series-option\")) {\n      if (module.optionsKey in options && module.seriesTypes.includes(series.type)) {\n        moduleMap.addModule(module, (m) => m.moduleFactory(moduleContext));\n      }\n    }\n  }\n  applySeriesValues(target, options) {\n    const moduleMap = target.getModuleMap();\n    const { type: _, data, listeners, seriesGrouping, showInMiniChart: __, ...seriesOptions } = options;\n    for (const moduleDef of EXPECTED_ENTERPRISE_MODULES) {\n      if (moduleDef.type !== \"series-option\")\n        continue;\n      if (moduleDef.optionsKey in seriesOptions) {\n        const module = moduleMap.getModule(moduleDef.optionsKey);\n        if (module) {\n          const moduleOptions = seriesOptions[moduleDef.optionsKey];\n          delete seriesOptions[moduleDef.optionsKey];\n          module.properties.set(moduleOptions);\n        }\n      }\n    }\n    target.properties.set(seriesOptions);\n    if (\"data\" in options) {\n      target.setOptionsData(data);\n    }\n    if (listeners) {\n      this.registerListeners(target, listeners);\n    }\n    if (\"seriesGrouping\" in options) {\n      if (seriesGrouping == null) {\n        target.seriesGrouping = void 0;\n      } else {\n        target.seriesGrouping = { ...target.seriesGrouping, ...seriesGrouping };\n      }\n    }\n  }\n  createAxis(options, skip) {\n    const newAxes = [];\n    const moduleContext = this.getModuleContext();\n    for (let index = 0; index < options.length; index++) {\n      const axisOptions = options[index];\n      const axis = axisRegistry.create(axisOptions.type, moduleContext);\n      this.applyAxisModules(axis, axisOptions);\n      jsonApply(axis, axisOptions, { path: `axes[${index}]`, skip });\n      newAxes.push(axis);\n    }\n    guessInvalidPositions(newAxes);\n    return newAxes;\n  }\n  applyAxisModules(axis, options) {\n    const moduleContext = axis.createModuleContext();\n    const moduleMap = axis.getModuleMap();\n    for (const module of moduleRegistry.byType(\"axis-option\")) {\n      const shouldBeEnabled = options[module.optionsKey] != null;\n      if (shouldBeEnabled === moduleMap.isEnabled(module))\n        continue;\n      if (shouldBeEnabled) {\n        moduleMap.addModule(module, (m) => m.moduleFactory(moduleContext));\n        axis[module.optionsKey] = moduleMap.getModule(module);\n      } else {\n        moduleMap.removeModule(module);\n        delete axis[module.optionsKey];\n      }\n    }\n  }\n  registerListeners(source, listeners) {\n    source.clearEventListeners();\n    for (const [property, listener] of Object.entries(listeners)) {\n      if (isFunction(listener)) {\n        source.addEventListener(property, listener);\n      }\n    }\n  }\n};\n_Chart.chartsInstances = /* @__PURE__ */ new WeakMap();\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      if (this.destroyed)\n        return;\n      this.ctx.domManager.setContainer(value);\n      _Chart.chartsInstances.set(value, this);\n    },\n    oldValue(value) {\n      _Chart.chartsInstances.delete(value);\n    }\n  })\n], _Chart.prototype, \"container\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"width option\", { inWidth: value });\n    }\n  })\n], _Chart.prototype, \"width\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"height option\", { inHeight: value });\n    }\n  })\n], _Chart.prototype, \"height\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"minWidth option\", { inMinWidth: value });\n    }\n  })\n], _Chart.prototype, \"minWidth\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(value) {\n      this.resize(\"minHeight option\", { inMinHeight: value });\n    }\n  })\n], _Chart.prototype, \"minHeight\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], _Chart.prototype, \"titlePadding\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"seriesArea\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"title\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"subtitle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"footnote\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], _Chart.prototype, \"keyboard\", 2);\n__decorateClass([\n  Validate(UNION([\"standalone\", \"integrated\"], \"a chart mode\"))\n], _Chart.prototype, \"mode\", 2);\n__decorateClass([\n  ActionOnSet({\n    changeValue(newValue, oldValue) {\n      this.onAxisChange(newValue, oldValue);\n    }\n  })\n], _Chart.prototype, \"axes\", 2);\n__decorateClass([\n  ActionOnSet({\n    changeValue(newValue, oldValue) {\n      this.onSeriesChange(newValue, oldValue);\n    }\n  })\n], _Chart.prototype, \"series\", 2);\nvar Chart = _Chart;\n\n// packages/ag-charts-community/src/scene/util/quadtree.ts\nvar QuadtreeNearest = class {\n  constructor(capacity, maxdepth, boundary) {\n    this.root = new QuadtreeNodeNearest(capacity, maxdepth, boundary);\n  }\n  clear(boundary) {\n    this.root.clear(boundary);\n  }\n  addValue(hitTester, value) {\n    const elem = {\n      hitTester,\n      value,\n      distanceSquared: (x, y) => {\n        return hitTester.distanceSquared(x, y);\n      }\n    };\n    this.root.addElem(elem);\n  }\n  find(x, y) {\n    const arg = { best: { nearest: void 0, distanceSquared: Infinity } };\n    this.root.find(x, y, arg);\n    return arg.best;\n  }\n};\nvar QuadtreeSubdivisions = class {\n  constructor(nw, ne, sw, se) {\n    this.nw = nw;\n    this.ne = ne;\n    this.sw = sw;\n    this.se = se;\n  }\n  addElem(elem) {\n    this.nw.addElem(elem);\n    this.ne.addElem(elem);\n    this.sw.addElem(elem);\n    this.se.addElem(elem);\n  }\n  find(x, y, arg) {\n    this.nw.find(x, y, arg);\n    this.ne.find(x, y, arg);\n    this.sw.find(x, y, arg);\n    this.se.find(x, y, arg);\n  }\n};\nvar QuadtreeNode = class {\n  constructor(capacity, maxdepth, boundary) {\n    this.capacity = capacity;\n    this.maxdepth = maxdepth;\n    this.boundary = boundary ?? BBox.NaN;\n    this.elems = [];\n    this.subdivisions = void 0;\n  }\n  clear(boundary) {\n    this.elems.length = 0;\n    this.boundary = boundary;\n    this.subdivisions = void 0;\n  }\n  addElem(e) {\n    if (this.addCondition(e)) {\n      if (this.subdivisions === void 0) {\n        if (this.maxdepth === 0 || this.elems.length < this.capacity) {\n          this.elems.push(e);\n        } else {\n          this.subdivide(e);\n        }\n      } else {\n        this.subdivisions.addElem(e);\n      }\n    }\n  }\n  find(x, y, arg) {\n    if (this.findCondition(x, y, arg)) {\n      if (this.subdivisions === void 0) {\n        this.findAction(x, y, arg);\n      } else {\n        this.subdivisions.find(x, y, arg);\n      }\n    }\n  }\n  subdivide(newElem) {\n    this.subdivisions = this.makeSubdivisions();\n    for (const e of this.elems) {\n      this.subdivisions.addElem(e);\n    }\n    this.subdivisions.addElem(newElem);\n    this.elems.length = 0;\n  }\n  makeSubdivisions() {\n    const { x, y, width, height } = this.boundary;\n    const { capacity } = this;\n    const depth = this.maxdepth - 1;\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n    const nwBoundary = new BBox(x, y, halfWidth, halfHeight);\n    const neBoundary = new BBox(x + halfWidth, y, halfWidth, halfHeight);\n    const swBoundary = new BBox(x, y + halfHeight, halfWidth, halfHeight);\n    const seBoundary = new BBox(x + halfWidth, y + halfHeight, halfWidth, halfHeight);\n    return new QuadtreeSubdivisions(\n      this.child(capacity, depth, nwBoundary),\n      this.child(capacity, depth, neBoundary),\n      this.child(capacity, depth, swBoundary),\n      this.child(capacity, depth, seBoundary)\n    );\n  }\n};\nvar QuadtreeNodeNearest = class _QuadtreeNodeNearest extends QuadtreeNode {\n  addCondition(e) {\n    const { x, y } = e.hitTester.midPoint;\n    return this.boundary.containsPoint(x, y);\n  }\n  findCondition(x, y, arg) {\n    const { best } = arg;\n    return best.distanceSquared !== 0 && this.boundary.distanceSquared(x, y) < best.distanceSquared;\n  }\n  findAction(x, y, arg) {\n    const other = nearestSquared(x, y, this.elems, arg.best.distanceSquared);\n    if (other.nearest !== void 0 && other.distanceSquared < arg.best.distanceSquared) {\n      arg.best = other;\n    }\n  }\n  child(capacity, depth, boundary) {\n    return new _QuadtreeNodeNearest(capacity, depth, boundary);\n  }\n};\n\n// packages/ag-charts-community/src/chart/marker/marker.ts\nvar Marker = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.x = 0;\n    this.y = 0;\n    this.size = 12;\n  }\n  computeBBox() {\n    const { x, y, size } = this;\n    const { center } = this.constructor;\n    return new BBox(x - size * center.x, y - size * center.y, size, size);\n  }\n  computeTransformedBBox() {\n    return super.computeTransformedBBox();\n  }\n  applyPath(s, moves) {\n    const { path } = this;\n    let { x, y } = this;\n    if (this.repeat != null) {\n      x = 0;\n      y = 0;\n    }\n    path.clear();\n    for (const { x: mx, y: my, t } of moves) {\n      x += mx * s;\n      y += my * s;\n      if (t === \"move\") {\n        path.moveTo(x, y);\n      } else {\n        path.lineTo(x, y);\n      }\n    }\n    path.closePath();\n  }\n  executeFill(ctx, path) {\n    if (!path)\n      return;\n    if (this.repeat == null) {\n      return super.executeFill(ctx, path);\n    }\n    ctx.save();\n    let x = this.translationX;\n    let y = this.translationY;\n    for (const translation of this.repeat) {\n      ctx.translate(translation.x - x, translation.y - y);\n      ctx.fill(path);\n      x = translation.x;\n      y = translation.y;\n    }\n    ctx.restore();\n  }\n  executeStroke(ctx, path) {\n    if (!path)\n      return;\n    if (this.repeat == null) {\n      return super.executeStroke(ctx, path);\n    }\n    ctx.save();\n    let x = this.translationX;\n    let y = this.translationY;\n    for (const translation of this.repeat) {\n      ctx.translate(translation.x - x, translation.y - y);\n      ctx.stroke(path);\n      x = translation.x;\n      y = translation.y;\n    }\n    ctx.restore();\n  }\n};\nMarker.center = { x: 0.5, y: 0.5 };\n__decorateClass([\n  ScenePathChangeDetection()\n], Marker.prototype, \"x\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Marker.prototype, \"y\", 2);\n__decorateClass([\n  ScenePathChangeDetection({ convertor: Math.abs })\n], Marker.prototype, \"size\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Marker.prototype, \"repeat\", 2);\n\n// packages/ag-charts-community/src/chart/marker/circle.ts\nvar Circle = class extends Marker {\n  updatePath() {\n    const { x, y, path, size } = this;\n    const r = size / 2;\n    path.clear();\n    path.arc(x, y, r, 0, Math.PI * 2);\n    path.closePath();\n  }\n};\nCircle.className = \"Circle\";\n\n// packages/ag-charts-community/src/chart/marker/cross.ts\nvar _Cross = class _Cross extends Marker {\n  updatePath() {\n    const s = this.size / 4.2;\n    super.applyPath(s, _Cross.moves);\n  }\n};\n_Cross.className = \"Cross\";\n_Cross.moves = [\n  { x: -1, y: 0, t: \"move\" },\n  { x: -1, y: -1 },\n  { x: 1, y: -1 },\n  { x: 1, y: 1 },\n  { x: 1, y: -1 },\n  { x: 1, y: 1 },\n  { x: -1, y: 1 },\n  { x: 1, y: 1 },\n  { x: -1, y: 1 },\n  { x: -1, y: -1 },\n  { x: -1, y: 1 },\n  { x: -1, y: -1 }\n];\nvar Cross = _Cross;\n\n// packages/ag-charts-community/src/chart/marker/diamond.ts\nvar _Diamond = class _Diamond extends Marker {\n  updatePath() {\n    const s = this.size / 2;\n    super.applyPath(s, _Diamond.moves);\n  }\n};\n_Diamond.className = \"Diamond\";\n_Diamond.moves = [\n  { x: 0, y: -1, t: \"move\" },\n  { x: 1, y: 1 },\n  { x: -1, y: 1 },\n  { x: -1, y: -1 },\n  { x: 1, y: -1 }\n];\nvar Diamond = _Diamond;\n\n// packages/ag-charts-community/src/chart/marker/heart.ts\nvar Heart = class extends Marker {\n  rad(degree2) {\n    return degree2 / 180 * Math.PI;\n  }\n  updatePath() {\n    const { x, path, size, rad } = this;\n    const r = size / 4;\n    const y = this.y + r / 2;\n    path.clear();\n    path.arc(x - r, y - r, r, rad(130), rad(330));\n    path.arc(x + r, y - r, r, rad(220), rad(50));\n    path.lineTo(x, y + r);\n    path.closePath();\n  }\n};\nHeart.className = \"Heart\";\n\n// packages/ag-charts-community/src/chart/marker/pin.ts\nvar Pin = class extends Marker {\n  updatePath() {\n    const { path, x, y } = this;\n    const s = this.size;\n    const cx = 0.5;\n    const cy = 1;\n    path.clear();\n    path.moveTo(x + (0.15625 - cx) * s, y + (0.34375 - cy) * s);\n    path.cubicCurveTo(\n      x + (0.15625 - cx) * s,\n      y + (0.151491 - cy) * s,\n      x + (0.307741 - cx) * s,\n      y + (0 - cy) * s,\n      x + (0.5 - cx) * s,\n      y + (0 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.692259 - cx) * s,\n      y + (0 - cy) * s,\n      x + (0.84375 - cx) * s,\n      y + (0.151491 - cy) * s,\n      x + (0.84375 - cx) * s,\n      y + (0.34375 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.84375 - cx) * s,\n      y + (0.493824 - cy) * s,\n      x + (0.784625 - cx) * s,\n      y + (0.600181 - cy) * s,\n      x + (0.716461 - cx) * s,\n      y + (0.695393 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.699009 - cx) * s,\n      y + (0.719769 - cy) * s,\n      x + (0.681271 - cx) * s,\n      y + (0.743104 - cy) * s,\n      x + (0.663785 - cx) * s,\n      y + (0.766105 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.611893 - cx) * s,\n      y + (0.834367 - cy) * s,\n      x + (0.562228 - cx) * s,\n      y + (0.899699 - cy) * s,\n      x + (0.528896 - cx) * s,\n      y + (0.980648 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.524075 - cx) * s,\n      y + (0.992358 - cy) * s,\n      x + (0.512663 - cx) * s,\n      y + (1 - cy) * s,\n      x + (0.5 - cx) * s,\n      y + (1 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.487337 - cx) * s,\n      y + (1 - cy) * s,\n      x + (0.475925 - cx) * s,\n      y + (0.992358 - cy) * s,\n      x + (0.471104 - cx) * s,\n      y + (0.980648 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.487337 - cx) * s,\n      y + (1 - cy) * s,\n      x + (0.475925 - cx) * s,\n      y + (0.992358 - cy) * s,\n      x + (0.471104 - cx) * s,\n      y + (0.980648 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.437772 - cx) * s,\n      y + (0.899699 - cy) * s,\n      x + (0.388107 - cx) * s,\n      y + (0.834367 - cy) * s,\n      x + (0.336215 - cx) * s,\n      y + (0.766105 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.318729 - cx) * s,\n      y + (0.743104 - cy) * s,\n      x + (0.300991 - cx) * s,\n      y + (0.719769 - cy) * s,\n      x + (0.283539 - cx) * s,\n      y + (0.695393 - cy) * s\n    );\n    path.cubicCurveTo(\n      x + (0.215375 - cx) * s,\n      y + (0.600181 - cy) * s,\n      x + (0.15625 - cx) * s,\n      y + (0.493824 - cy) * s,\n      x + (0.15625 - cx) * s,\n      y + (0.34375 - cy) * s\n    );\n    path.closePath();\n  }\n};\nPin.className = \"MapPin\";\nPin.center = { x: 0.5, y: 1 };\n\n// packages/ag-charts-community/src/chart/marker/plus.ts\nvar _Plus = class _Plus extends Marker {\n  updatePath() {\n    const s = this.size / 3;\n    super.applyPath(s, _Plus.moves);\n  }\n};\n_Plus.className = \"Plus\";\n_Plus.moves = [\n  { x: -0.5, y: -0.5, t: \"move\" },\n  { x: 0, y: -1 },\n  { x: 1, y: 0 },\n  { x: 0, y: 1 },\n  { x: 1, y: 0 },\n  { x: 0, y: 1 },\n  { x: -1, y: 0 },\n  { x: 0, y: 1 },\n  { x: -1, y: 0 },\n  { x: 0, y: -1 },\n  { x: -1, y: 0 },\n  { x: 0, y: -1 }\n];\nvar Plus = _Plus;\n\n// packages/ag-charts-community/src/chart/marker/square.ts\nvar Square = class extends Marker {\n  updatePath() {\n    const { path, x, y } = this;\n    const hs = this.size / 2;\n    path.clear();\n    path.moveTo(this.align(x - hs), this.align(y - hs));\n    path.lineTo(this.align(x + hs), this.align(y - hs));\n    path.lineTo(this.align(x + hs), this.align(y + hs));\n    path.lineTo(this.align(x - hs), this.align(y + hs));\n    path.closePath();\n  }\n};\nSquare.className = \"Square\";\n\n// packages/ag-charts-community/src/chart/marker/star.ts\nvar Star = class extends Marker {\n  updatePath() {\n    const { x, y, path, size } = this;\n    const spikes = 5;\n    const innerRadius = size / 2;\n    const rotation = Math.PI / 2;\n    path.clear();\n    for (let i = 0; i < spikes * 2; i++) {\n      const radius = i % 2 === 0 ? size : innerRadius;\n      const angle2 = i * Math.PI / spikes - rotation;\n      const xCoordinate = x + Math.cos(angle2) * radius;\n      const yCoordinate = y + Math.sin(angle2) * radius;\n      path.lineTo(xCoordinate, yCoordinate);\n    }\n    path.closePath();\n  }\n};\nStar.className = \"Star\";\n\n// packages/ag-charts-community/src/chart/marker/triangle.ts\nvar _Triangle = class _Triangle extends Marker {\n  updatePath() {\n    const s = this.size * 1.1;\n    super.applyPath(s, _Triangle.moves);\n  }\n};\n_Triangle.className = \"Triangle\";\n_Triangle.moves = [\n  { x: 0, y: -0.48, t: \"move\" },\n  { x: 0.5, y: 0.87 },\n  { x: -1, y: 0 }\n];\nvar Triangle = _Triangle;\n\n// packages/ag-charts-community/src/chart/marker/util.ts\nvar MARKER_SHAPES = {\n  circle: Circle,\n  cross: Cross,\n  diamond: Diamond,\n  heart: Heart,\n  pin: Pin,\n  plus: Plus,\n  square: Square,\n  star: Star,\n  triangle: Triangle\n};\nvar MARKER_SUPPORTED_SHAPES = Object.keys(MARKER_SHAPES);\nfunction isMarkerShape(shape) {\n  return typeof shape === \"string\" && MARKER_SUPPORTED_SHAPES.includes(shape);\n}\nfunction getMarker(shape = Square) {\n  if (isMarkerShape(shape)) {\n    return MARKER_SHAPES[shape];\n  }\n  if (typeof shape === \"function\") {\n    return shape;\n  }\n  return Square;\n}\n\n// packages/ag-charts-community/src/chart/series/dataModelSeries.ts\nvar DataModelSeries = class extends Series {\n  constructor() {\n    super(...arguments);\n    this.showFocusBox = true;\n  }\n  getScaleInformation({\n    xScale,\n    yScale\n  }) {\n    const isContinuousX = ContinuousScale.is(xScale);\n    const isContinuousY = ContinuousScale.is(yScale);\n    return { isContinuousX, isContinuousY, xScaleType: xScale?.type, yScaleType: yScale?.type };\n  }\n  getModulePropertyDefinitions() {\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    return this.moduleMap.mapModules((mod2) => mod2.getPropertyDefinitions(this.getScaleInformation({ xScale, yScale }))).flat();\n  }\n  // Request data, but with message dispatching to series-options (modules).\n  async requestDataModel(dataController, data, opts) {\n    opts.props.push(...this.getModulePropertyDefinitions());\n    const { dataModel, processedData } = await dataController.request(this.id, data ?? [], opts);\n    this.dataModel = dataModel;\n    this.processedData = processedData;\n    this.dispatch(\"data-processed\", { dataModel, processedData });\n    return { dataModel, processedData };\n  }\n  isProcessedDataAnimatable() {\n    const validationResults = this.processedData?.reduced?.animationValidation;\n    if (!validationResults) {\n      return true;\n    }\n    const { orderedKeys, uniqueKeys } = validationResults;\n    return orderedKeys && uniqueKeys;\n  }\n  checkProcessedDataAnimatable() {\n    if (!this.isProcessedDataAnimatable()) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  pickFocus(opts) {\n    const nodeData = this.getNodeData();\n    if (nodeData === void 0 || nodeData.length === 0) {\n      return void 0;\n    }\n    const datumIndex = this.computeFocusDatumIndex(opts, nodeData);\n    if (datumIndex === void 0) {\n      return void 0;\n    }\n    const { showFocusBox } = this;\n    const datum = nodeData[datumIndex];\n    const derivedOpts = { ...opts, datumIndex };\n    const bounds = this.computeFocusBounds(derivedOpts);\n    if (bounds !== void 0) {\n      return { bounds, showFocusBox, datum, datumIndex };\n    }\n  }\n  computeFocusDatumIndex(opts, nodeData) {\n    const isDatumEnabled = (datumIndex2) => {\n      const { missing = false, enabled = true, focusable = true } = nodeData[datumIndex2];\n      return !missing && enabled && focusable;\n    };\n    const searchBackward = (datumIndex2) => {\n      while (datumIndex2 >= 0 && !isDatumEnabled(datumIndex2)) {\n        datumIndex2--;\n      }\n      return datumIndex2 === -1 ? void 0 : datumIndex2;\n    };\n    const searchForward = (datumIndex2) => {\n      while (datumIndex2 < nodeData.length && !isDatumEnabled(datumIndex2)) {\n        datumIndex2++;\n      }\n      return datumIndex2 === nodeData.length ? void 0 : datumIndex2;\n    };\n    let datumIndex;\n    const clampedIndex = clamp(0, opts.datumIndex, nodeData.length - 1);\n    if (opts.datumIndexDelta < 0) {\n      datumIndex = searchBackward(clampedIndex);\n    } else if (opts.datumIndexDelta > 0) {\n      datumIndex = searchForward(clampedIndex);\n    } else {\n      datumIndex ?? (datumIndex = searchForward(clampedIndex));\n      datumIndex ?? (datumIndex = searchBackward(clampedIndex));\n    }\n    if (datumIndex === void 0) {\n      if (opts.datumIndexDelta === 0) {\n        return void 0;\n      } else {\n        return opts.datumIndex - opts.datumIndexDelta;\n      }\n    } else {\n      return datumIndex;\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/seriesProperties.ts\nvar SeriesItemHighlightStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"rgba(255,255,255, 0.33)\";\n    this.stroke = `rgba(0, 0, 0, 0.4)`;\n    this.strokeWidth = 2;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], SeriesItemHighlightStyle.prototype, \"lineDashOffset\", 2);\nvar SeriesHighlightStyle = class extends BaseProperties {\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], SeriesHighlightStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], SeriesHighlightStyle.prototype, \"dimOpacity\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], SeriesHighlightStyle.prototype, \"enabled\", 2);\nvar TextHighlightStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.color = \"black\";\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], TextHighlightStyle.prototype, \"color\", 2);\nvar HighlightProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], HighlightProperties.prototype, \"enabled\", 2);\nvar HighlightStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.item = new SeriesItemHighlightStyle();\n    this.series = new SeriesHighlightStyle();\n    this.text = new TextHighlightStyle();\n  }\n};\n__decorateClass([\n  Validate(OBJECT)\n], HighlightStyle.prototype, \"item\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HighlightStyle.prototype, \"series\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HighlightStyle.prototype, \"text\", 2);\nvar SeriesProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.visible = true;\n    this.showInLegend = true;\n    this.cursor = \"default\";\n    this.nodeClickRange = \"exact\";\n    this.highlight = new HighlightProperties();\n    this.highlightStyle = new HighlightStyle();\n  }\n};\n__decorateClass([\n  Validate(STRING, { optional: true })\n], SeriesProperties.prototype, \"id\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesProperties.prototype, \"visible\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesProperties.prototype, \"showInLegend\", 2);\n__decorateClass([\n  Validate(STRING)\n], SeriesProperties.prototype, \"cursor\", 2);\n__decorateClass([\n  Validate(INTERACTION_RANGE)\n], SeriesProperties.prototype, \"nodeClickRange\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesProperties.prototype, \"highlight\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesProperties.prototype, \"highlightStyle\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/cartesianSeries.ts\nvar DEFAULT_CARTESIAN_DIRECTION_KEYS = {\n  [\"x\" /* X */]: [\"xKey\"],\n  [\"y\" /* Y */]: [\"yKey\"]\n};\nvar DEFAULT_CARTESIAN_DIRECTION_NAMES = {\n  [\"x\" /* X */]: [\"xName\"],\n  [\"y\" /* Y */]: [\"yName\"]\n};\nvar CartesianSeriesNodeEvent = class extends SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.xKey = series.properties.xKey;\n    this.yKey = series.properties.yKey;\n  }\n};\nvar CartesianSeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.pickOutsideVisibleMinorAxis = false;\n  }\n};\n__decorateClass([\n  Validate(STRING, { optional: true })\n], CartesianSeriesProperties.prototype, \"legendItemName\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], CartesianSeriesProperties.prototype, \"pickOutsideVisibleMinorAxis\", 2);\nvar CartesianSeries = class extends DataModelSeries {\n  constructor({\n    pathsPerSeries = [\"path\"],\n    hasMarkers = false,\n    hasHighlightedLabels = false,\n    pathsZIndexSubOrderOffset = [],\n    datumSelectionGarbageCollection = true,\n    markerSelectionGarbageCollection = true,\n    animationAlwaysUpdateSelections = false,\n    animationResetFns,\n    directionKeys,\n    directionNames,\n    ...otherOpts\n  }) {\n    super({\n      directionKeys,\n      directionNames,\n      canHaveAxes: true,\n      ...otherOpts\n    });\n    this.NodeEvent = CartesianSeriesNodeEvent;\n    this.dataNodeGroup = this.contentGroup.appendChild(\n      new Group({\n        name: `${this.id}-series-dataNodes`,\n        zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"data\")\n      })\n    );\n    this.markerGroup = this.contentGroup.appendChild(\n      new Group({\n        name: `${this.id}-series-markers`,\n        zIndex: 4 /* SERIES_LAYER_ZINDEX */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"marker\")\n      })\n    );\n    this.labelGroup = this.contentGroup.appendChild(\n      new Group({\n        name: `${this.id}-series-labels`,\n        zIndex: 8 /* SERIES_LABEL_ZINDEX */,\n        zIndexSubOrder: this.getGroupZIndexSubOrder(\"labels\")\n      })\n    );\n    this.labelSelection = Selection.select(this.labelGroup, Text);\n    this.highlightSelection = Selection.select(\n      this.highlightNode,\n      () => this.opts.hasMarkers ? this.markerFactory() : this.nodeFactory()\n    );\n    this.highlightLabelSelection = Selection.select(this.highlightLabel, Text);\n    this.annotationSelections = /* @__PURE__ */ new Set();\n    this.minRectsCache = {\n      dirtyNodeData: true\n    };\n    this.debug = Debug.create();\n    if (!directionKeys || !directionNames)\n      throw new Error(`Unable to initialise series type ${this.type}`);\n    this.opts = {\n      pathsPerSeries,\n      hasMarkers,\n      hasHighlightedLabels,\n      pathsZIndexSubOrderOffset,\n      directionKeys,\n      directionNames,\n      animationResetFns,\n      animationAlwaysUpdateSelections,\n      datumSelectionGarbageCollection,\n      markerSelectionGarbageCollection\n    };\n    this.paths = [];\n    for (let index = 0; index < pathsPerSeries.length; index++) {\n      this.paths[index] = new Path({ name: `${this.id}-${pathsPerSeries[index]}` });\n      this.paths[index].zIndex = 4 /* SERIES_LAYER_ZINDEX */;\n      this.paths[index].zIndexSubOrder = this.getGroupZIndexSubOrder(\"paths\", index);\n      this.contentGroup.appendChild(this.paths[index]);\n    }\n    this.datumSelection = Selection.select(\n      this.dataNodeGroup,\n      () => this.nodeFactory(),\n      datumSelectionGarbageCollection\n    );\n    this.markerSelection = Selection.select(\n      this.markerGroup,\n      () => this.markerFactory(),\n      markerSelectionGarbageCollection\n    );\n    this.animationState = new StateMachine(\n      \"empty\",\n      {\n        empty: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateEmptyUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\",\n          disable: \"disabled\"\n        },\n        ready: {\n          updateData: \"waiting\",\n          clear: \"clearing\",\n          highlight: (data) => this.animateReadyHighlight(data),\n          highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),\n          resize: (data) => this.animateReadyResize(data),\n          reset: \"empty\",\n          skip: \"ready\",\n          disable: \"disabled\"\n        },\n        waiting: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateWaitingUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\",\n          disable: \"disabled\"\n        },\n        disabled: {\n          update: (data) => this.resetAllAnimation(data),\n          reset: \"empty\"\n        },\n        clearing: {\n          update: {\n            target: \"empty\",\n            action: (data) => this.animateClearingUpdateEmpty(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        }\n      },\n      () => this.checkProcessedDataAnimatable()\n    );\n  }\n  get contextNodeData() {\n    return this._contextNodeData;\n  }\n  getNodeData() {\n    return this.contextNodeData?.nodeData;\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    } else if (phase === \"ready\") {\n      this.animationState.transition(\"skip\");\n    } else if (phase === \"disabled\") {\n      this.animationState.transition(\"disable\");\n    }\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event)),\n      this.ctx.chartEventManager.addListener(\n        \"legend-item-double-click\",\n        (event) => this.onLegendItemDoubleClick(event)\n      )\n    );\n  }\n  destroy() {\n    super.destroy();\n    this._contextNodeData = void 0;\n  }\n  async update({ seriesRect }) {\n    const { visible, _contextNodeData: previousContextData } = this;\n    const series = this.ctx.highlightManager?.getActiveHighlight()?.series;\n    const seriesHighlighted = series === this;\n    const resize = this.checkResize(seriesRect);\n    const highlightItems = await this.updateHighlightSelection(seriesHighlighted);\n    await this.updateSelections(visible);\n    await this.updateNodes(highlightItems, seriesHighlighted, visible);\n    const animationData = this.getAnimationData(seriesRect, previousContextData);\n    if (!animationData)\n      return;\n    if (resize) {\n      this.animationState.transition(\"resize\", animationData);\n    }\n    this.animationState.transition(\"update\", animationData);\n  }\n  async updateSelections(anySeriesItemEnabled) {\n    var _a;\n    const animationSkipUpdate = !this.opts.animationAlwaysUpdateSelections && this.ctx.animationManager.isSkipped();\n    if (!anySeriesItemEnabled && animationSkipUpdate) {\n      return;\n    }\n    if (!this.nodeDataRefresh && !this.isPathOrSelectionDirty()) {\n      return;\n    }\n    if (this.nodeDataRefresh) {\n      this.nodeDataRefresh = false;\n      this.debug(`CartesianSeries.updateSelections() - calling createNodeData() for`, this.id);\n      this.markQuadtreeDirty();\n      this._contextNodeData = await this.createNodeData();\n      const animationValid = this.isProcessedDataAnimatable();\n      if (this._contextNodeData) {\n        (_a = this._contextNodeData).animationValid ?? (_a.animationValid = animationValid);\n      }\n      this.minRectsCache.dirtyNodeData = true;\n      const { dataModel, processedData } = this;\n      if (dataModel !== void 0 && processedData !== void 0) {\n        this.dispatch(\"data-update\", { dataModel, processedData });\n      }\n    }\n    await this.updateSeriesSelections();\n  }\n  async updateSeriesSelections(seriesHighlighted) {\n    const { datumSelection, labelSelection, markerSelection, paths } = this;\n    const contextData = this._contextNodeData;\n    if (!contextData)\n      return;\n    const { nodeData, labelData, itemId } = contextData;\n    await this.updatePaths({ seriesHighlighted, itemId, contextData, paths });\n    this.datumSelection = await this.updateDatumSelection({ nodeData, datumSelection });\n    this.labelSelection = await this.updateLabelSelection({ labelData, labelSelection });\n    if (this.opts.hasMarkers) {\n      this.markerSelection = await this.updateMarkerSelection({ nodeData, markerSelection });\n    }\n  }\n  markerFactory() {\n    const MarkerShape = getMarker();\n    return new MarkerShape();\n  }\n  getGroupZIndexSubOrder(type, subIndex = 0) {\n    const result = super.getGroupZIndexSubOrder(type, subIndex);\n    if (type === \"paths\") {\n      const [superFn] = result;\n      const pathOffset = this.opts.pathsZIndexSubOrderOffset[subIndex] ?? 0;\n      result[0] = isFunction(superFn) ? () => Number(superFn()) + pathOffset : Number(superFn) + pathOffset;\n    }\n    return result;\n  }\n  async updateNodes(highlightedItems, seriesHighlighted, anySeriesItemEnabled) {\n    const {\n      highlightSelection,\n      highlightLabelSelection,\n      opts: { hasMarkers, hasHighlightedLabels }\n    } = this;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const visible = this.visible && this._contextNodeData != null && anySeriesItemEnabled;\n    this.rootGroup.visible = animationEnabled || visible;\n    this.contentGroup.visible = animationEnabled || visible;\n    this.highlightGroup.visible = (animationEnabled || visible) && seriesHighlighted;\n    const opacity = this.getOpacity();\n    if (hasMarkers) {\n      await this.updateMarkerNodes({\n        markerSelection: highlightSelection,\n        isHighlight: true\n      });\n      this.animationState.transition(\"highlightMarkers\", highlightSelection);\n    } else {\n      await this.updateDatumNodes({\n        datumSelection: highlightSelection,\n        isHighlight: true\n      });\n      this.animationState.transition(\"highlight\", highlightSelection);\n    }\n    if (hasHighlightedLabels) {\n      await this.updateLabelNodes({ labelSelection: highlightLabelSelection });\n    }\n    const { dataNodeGroup, markerGroup, datumSelection, labelSelection, markerSelection, paths, labelGroup } = this;\n    const { itemId } = this.contextNodeData ?? {};\n    dataNodeGroup.opacity = opacity;\n    dataNodeGroup.visible = animationEnabled || visible;\n    labelGroup.visible = visible;\n    if (hasMarkers) {\n      markerGroup.opacity = opacity;\n      markerGroup.zIndex = dataNodeGroup.zIndex >= 4 /* SERIES_LAYER_ZINDEX */ ? dataNodeGroup.zIndex : dataNodeGroup.zIndex + 1;\n      markerGroup.visible = visible;\n    }\n    if (labelGroup) {\n      labelGroup.opacity = opacity;\n    }\n    await this.updatePathNodes({\n      seriesHighlighted,\n      itemId,\n      paths,\n      opacity,\n      visible,\n      animationEnabled\n    });\n    if (!dataNodeGroup.visible) {\n      return;\n    }\n    await this.updateDatumNodes({ datumSelection, highlightedItems, isHighlight: false });\n    await this.updateLabelNodes({ labelSelection });\n    if (hasMarkers) {\n      await this.updateMarkerNodes({ markerSelection, isHighlight: false });\n    }\n  }\n  getHighlightLabelData(labelData, highlightedItem) {\n    const labelItems = labelData.filter(\n      (ld) => ld.datum === highlightedItem.datum && ld.itemId === highlightedItem.itemId\n    );\n    return labelItems.length === 0 ? void 0 : labelItems;\n  }\n  getHighlightData(_nodeData, highlightedItem) {\n    return highlightedItem ? [highlightedItem] : void 0;\n  }\n  async updateHighlightSelection(seriesHighlighted) {\n    const { highlightSelection, highlightLabelSelection, _contextNodeData: contextNodeData } = this;\n    if (!contextNodeData)\n      return;\n    const highlightedDatum = this.ctx.highlightManager?.getActiveHighlight();\n    const item = seriesHighlighted && highlightedDatum?.datum ? highlightedDatum : void 0;\n    let labelItems;\n    let highlightItems;\n    if (item != null) {\n      const labelsEnabled = this.isLabelEnabled();\n      const { labelData, nodeData } = contextNodeData;\n      highlightItems = this.getHighlightData(nodeData, item);\n      labelItems = labelsEnabled ? this.getHighlightLabelData(labelData, item) : void 0;\n    }\n    this.highlightSelection = await this.updateHighlightSelectionItem({\n      items: highlightItems,\n      highlightSelection\n    });\n    this.highlightLabelSelection = await this.updateHighlightSelectionLabel({\n      items: labelItems,\n      highlightLabelSelection\n    });\n    return highlightItems;\n  }\n  markQuadtreeDirty() {\n    this.quadtree = void 0;\n  }\n  *datumNodesIter() {\n    for (const { node } of this.datumSelection) {\n      if (node.datum.missing === true)\n        continue;\n      yield node;\n    }\n  }\n  getQuadTree() {\n    if (this.quadtree === void 0) {\n      const { width, height } = this.ctx.scene.canvas;\n      const canvasRect = new BBox(0, 0, width, height);\n      this.quadtree = new QuadtreeNearest(100, 10, canvasRect);\n      this.initQuadTree(this.quadtree);\n    }\n    return this.quadtree;\n  }\n  initQuadTree(_quadtree) {\n  }\n  pickNodeExactShape(point) {\n    const result = super.pickNodeExactShape(point);\n    if (result) {\n      return result;\n    }\n    const { x, y } = point;\n    const {\n      opts: { hasMarkers }\n    } = this;\n    let match;\n    const { dataNodeGroup, markerGroup } = this;\n    match = dataNodeGroup.pickNode(x, y);\n    if (!match && hasMarkers) {\n      match = markerGroup?.pickNode(x, y);\n    }\n    if (match && match.datum.missing !== true) {\n      return { datum: match.datum, distance: 0 };\n    }\n    for (const mod2 of this.moduleMap.modules()) {\n      const { datum } = mod2.pickNodeExact(point) ?? {};\n      if (datum == null)\n        continue;\n      if (datum?.missing === true)\n        continue;\n      return { datum, distance: 0 };\n    }\n  }\n  pickNodeClosestDatum(point) {\n    const { x, y } = point;\n    const { axes, rootGroup, _contextNodeData: contextNodeData } = this;\n    if (!contextNodeData)\n      return;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const hitPoint = rootGroup.transformPoint(x, y);\n    let minDistance = Infinity;\n    let closestDatum;\n    for (const datum of contextNodeData.nodeData) {\n      const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;\n      if (isNaN(datumX) || isNaN(datumY)) {\n        continue;\n      }\n      const isInRange = xAxis?.inRange(datumX) && yAxis?.inRange(datumY);\n      if (!isInRange) {\n        continue;\n      }\n      const distance3 = Math.max((hitPoint.x - datumX) ** 2 + (hitPoint.y - datumY) ** 2, 0);\n      if (distance3 < minDistance) {\n        minDistance = distance3;\n        closestDatum = datum;\n      }\n    }\n    for (const mod2 of this.moduleMap.modules()) {\n      const modPick = mod2.pickNodeNearest(point);\n      if (modPick !== void 0 && modPick.distanceSquared < minDistance) {\n        minDistance = modPick.distanceSquared;\n        closestDatum = modPick.datum;\n        break;\n      }\n    }\n    if (closestDatum) {\n      const distance3 = Math.max(Math.sqrt(minDistance) - (closestDatum.point?.size ?? 0), 0);\n      return { datum: closestDatum, distance: distance3 };\n    }\n  }\n  pickNodeMainAxisFirst(point, requireCategoryAxis) {\n    const { x, y } = point;\n    const { axes, rootGroup, _contextNodeData: contextNodeData } = this;\n    const { pickOutsideVisibleMinorAxis } = this.properties;\n    if (!contextNodeData)\n      return;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const directions2 = [xAxis, yAxis].filter((a) => a instanceof CategoryAxis).map((a) => a.direction);\n    if (requireCategoryAxis && directions2.length === 0) {\n      return;\n    }\n    const [majorDirection = \"x\" /* X */] = directions2;\n    const hitPoint = rootGroup.transformPoint(x, y);\n    const hitPointCoords = [hitPoint.x, hitPoint.y];\n    if (majorDirection !== \"x\" /* X */)\n      hitPointCoords.reverse();\n    const minDistance = [Infinity, Infinity];\n    let closestDatum;\n    for (const datum of contextNodeData.nodeData) {\n      const { x: datumX = NaN, y: datumY = NaN } = datum.point ?? datum.midPoint ?? {};\n      if (isNaN(datumX) || isNaN(datumY) || datum.missing === true) {\n        continue;\n      }\n      const visible = [xAxis?.inRange(datumX), yAxis?.inRange(datumY)];\n      if (majorDirection !== \"x\" /* X */)\n        visible.reverse();\n      if (!visible[0] || !pickOutsideVisibleMinorAxis && !visible[1]) {\n        continue;\n      }\n      const datumPoint = [datumX, datumY];\n      if (majorDirection !== \"x\" /* X */)\n        datumPoint.reverse();\n      let newMinDistance = true;\n      for (let i = 0; i < datumPoint.length; i++) {\n        const dist = Math.abs(datumPoint[i] - hitPointCoords[i]);\n        if (dist > minDistance[i]) {\n          newMinDistance = false;\n          break;\n        }\n        if (dist < minDistance[i]) {\n          minDistance[i] = dist;\n          minDistance.fill(Infinity, i + 1, minDistance.length);\n        }\n      }\n      if (newMinDistance) {\n        closestDatum = datum;\n      }\n    }\n    if (closestDatum) {\n      let closestDistanceSquared = Math.max(\n        minDistance[0] ** 2 + minDistance[1] ** 2 - (closestDatum.point?.size ?? 0),\n        0\n      );\n      for (const mod2 of this.moduleMap.modules()) {\n        const modPick = mod2.pickNodeMainAxisFirst(point);\n        if (modPick !== void 0 && modPick.distanceSquared < closestDistanceSquared) {\n          closestDatum = modPick.datum;\n          closestDistanceSquared = modPick.distanceSquared;\n          break;\n        }\n      }\n      return { datum: closestDatum, distance: Math.sqrt(closestDistanceSquared) };\n    }\n  }\n  onLegendItemClick(event) {\n    const { legendItemName } = this.properties;\n    const { enabled, itemId, series } = event;\n    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;\n    if (series.id === this.id || matchedLegendItemName) {\n      this.toggleSeriesItem(itemId, enabled);\n    }\n  }\n  onLegendItemDoubleClick(event) {\n    const { enabled, itemId, series, numVisibleItems } = event;\n    const { legendItemName } = this.properties;\n    const matchedLegendItemName = legendItemName != null && legendItemName === event.legendItemName;\n    if (series.id === this.id || matchedLegendItemName) {\n      this.toggleSeriesItem(itemId, true);\n    } else if (enabled && numVisibleItems === 1) {\n      this.toggleSeriesItem(itemId, true);\n    } else {\n      this.toggleSeriesItem(itemId, false);\n    }\n  }\n  isPathOrSelectionDirty() {\n    return false;\n  }\n  getLabelData() {\n    return [];\n  }\n  shouldFlipXY() {\n    return false;\n  }\n  /**\n   * Get the minimum bounding box that contains any adjacent two nodes. The axes are treated independently, so this\n   * may not represent the same two points for both directions. The dimensions represent the greatest distance\n   * between any two adjacent nodes.\n   */\n  getMinRects(width, height) {\n    const { dirtyNodeData, sizeCache, minRect, minVisibleRect } = this.minRectsCache;\n    const newSizeCache = JSON.stringify({ width, height });\n    const dirtySize = newSizeCache !== sizeCache;\n    if (!dirtySize && !dirtyNodeData && minRect && minVisibleRect) {\n      return { minRect, minVisibleRect };\n    }\n    const rects = this.computeMinRects(width, height);\n    this.minRectsCache = {\n      dirtyNodeData: false,\n      sizeCache: newSizeCache,\n      minRect: rects?.minRect,\n      minVisibleRect: rects?.minVisibleRect\n    };\n    return rects;\n  }\n  computeMinRects(width, height) {\n    const context = this._contextNodeData;\n    if (!context?.nodeData.length) {\n      return;\n    }\n    const { nodeData } = context;\n    const minRectXs = Array(nodeData.length);\n    const minRectYs = Array(nodeData.length);\n    for (const [i, { midPoint }] of nodeData.entries()) {\n      minRectXs[i] = midPoint?.x ?? 0;\n      minRectYs[i] = midPoint?.y ?? 0;\n    }\n    minRectXs.sort((a, b) => a - b);\n    minRectYs.sort((a, b) => a - b);\n    let zeroX, widthX, zeroY, heightY;\n    let maxWidth = 0;\n    let maxHeight = 0;\n    for (let i = 1; i < nodeData.length; i++) {\n      if (minRectXs[i] >= 0)\n        zeroX ?? (zeroX = i);\n      if (minRectXs[i] > width)\n        widthX ?? (widthX = i);\n      if (minRectYs[i] >= 0)\n        zeroY ?? (zeroY = i);\n      if (minRectYs[i] > height)\n        heightY ?? (heightY = i);\n      maxWidth = Math.max(maxWidth, minRectXs[i] - minRectXs[i - 1]);\n      maxHeight = Math.max(maxHeight, minRectYs[i] - minRectYs[i - 1]);\n    }\n    widthX ?? (widthX = nodeData.length);\n    heightY ?? (heightY = nodeData.length);\n    const minVisibleRectXs = zeroX != null && widthX != null ? minRectXs.slice(zeroX, widthX) : [];\n    const minVisibleRectYs = zeroY != null && heightY != null ? minRectYs.slice(zeroY, heightY) : [];\n    let maxVisibleWidth = 0;\n    let maxVisibleHeight = 0;\n    for (let i = 1; i < Math.max(minVisibleRectXs.length, minVisibleRectYs.length); i++) {\n      const x1 = minVisibleRectXs[i];\n      const x2 = minVisibleRectXs[i - 1];\n      const y1 = minVisibleRectYs[i];\n      const y2 = minVisibleRectYs[i - 1];\n      if (x1 != null && x2 != null) {\n        maxVisibleWidth = Math.max(maxVisibleWidth, x1 - x2);\n      }\n      if (y1 != null && y2 != null) {\n        maxVisibleHeight = Math.max(maxVisibleHeight, y1 - y2);\n      }\n    }\n    const minRect = new BBox(0, 0, maxWidth, maxHeight);\n    const minVisibleRect = new BBox(0, 0, maxVisibleWidth, maxVisibleHeight);\n    return { minRect, minVisibleRect };\n  }\n  updateHighlightSelectionItem(opts) {\n    const {\n      opts: { hasMarkers }\n    } = this;\n    const { items, highlightSelection } = opts;\n    const nodeData = items ?? [];\n    if (hasMarkers) {\n      const markerSelection = highlightSelection;\n      return this.updateMarkerSelection({ nodeData, markerSelection });\n    } else {\n      return this.updateDatumSelection({\n        nodeData,\n        datumSelection: highlightSelection\n      });\n    }\n  }\n  updateHighlightSelectionLabel(opts) {\n    return this.updateLabelSelection({\n      labelData: opts.items ?? [],\n      labelSelection: opts.highlightLabelSelection\n    });\n  }\n  async updateDatumSelection(opts) {\n    return opts.datumSelection;\n  }\n  async updateDatumNodes(_opts) {\n  }\n  async updateMarkerSelection(opts) {\n    return opts.markerSelection;\n  }\n  async updateMarkerNodes(_opts) {\n  }\n  async updatePaths(opts) {\n    opts.paths.forEach((p) => p.visible = false);\n  }\n  async updatePathNodes(opts) {\n    const { paths, opacity, visible } = opts;\n    for (const path of paths) {\n      path.opacity = opacity;\n      path.visible = visible;\n    }\n  }\n  resetPathAnimation(data) {\n    const { path } = this.opts?.animationResetFns ?? {};\n    if (path) {\n      data.paths.forEach((paths) => {\n        resetMotion([paths], path);\n      });\n    }\n  }\n  resetDatumAnimation(data) {\n    const { datum } = this.opts?.animationResetFns ?? {};\n    if (datum) {\n      resetMotion([data.datumSelection], datum);\n    }\n  }\n  resetLabelAnimation(data) {\n    const { label } = this.opts?.animationResetFns ?? {};\n    if (label) {\n      resetMotion([data.labelSelection], label);\n    }\n  }\n  resetMarkerAnimation(data) {\n    const { marker } = this.opts?.animationResetFns ?? {};\n    if (marker && this.opts.hasMarkers) {\n      resetMotion([data.markerSelection], marker);\n    }\n  }\n  resetAllAnimation(data) {\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    this.resetPathAnimation(data);\n    this.resetDatumAnimation(data);\n    this.resetLabelAnimation(data);\n    this.resetMarkerAnimation(data);\n    if (data.contextData?.animationValid === false) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  animateEmptyUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateWaitingUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateReadyHighlight(data) {\n    const { datum } = this.opts?.animationResetFns ?? {};\n    if (datum) {\n      resetMotion([data], datum);\n    }\n  }\n  animateReadyHighlightMarkers(data) {\n    const { marker } = this.opts?.animationResetFns ?? {};\n    if (marker) {\n      resetMotion([data], marker);\n    }\n  }\n  animateReadyResize(data) {\n    this.resetAllAnimation(data);\n  }\n  animateClearingUpdateEmpty(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animationTransitionClear() {\n    const animationData = this.getAnimationData();\n    if (!animationData)\n      return;\n    this.animationState.transition(\"clear\", animationData);\n  }\n  getAnimationData(seriesRect, previousContextData) {\n    const { _contextNodeData: contextData } = this;\n    if (!contextData)\n      return;\n    const animationData = {\n      datumSelection: this.datumSelection,\n      markerSelection: this.markerSelection,\n      labelSelection: this.labelSelection,\n      annotationSelections: [...this.annotationSelections],\n      contextData,\n      previousContextData,\n      paths: this.paths,\n      seriesRect\n    };\n    return animationData;\n  }\n  calculateScaling() {\n    const result = {};\n    for (const direction of Object.values(ChartAxisDirection)) {\n      const axis = this.axes[direction];\n      if (!axis)\n        continue;\n      if (axis.scale instanceof LogScale) {\n        const { range: range3, domain } = axis.scale;\n        result[direction] = {\n          type: \"log\",\n          convert: (d) => axis.scale.convert(d),\n          domain: [domain[0], domain[1]],\n          range: [range3[0], range3[1]]\n        };\n      } else if (axis.scale instanceof ContinuousScale) {\n        const { range: range3 } = axis.scale;\n        const domain = axis.scale.getDomain();\n        result[direction] = {\n          type: \"continuous\",\n          domain: [domain[0], domain[1]],\n          range: [range3[0], range3[1]]\n        };\n      } else if (axis.scale) {\n        const { domain } = axis.scale;\n        result[direction] = {\n          type: \"category\",\n          domain,\n          range: domain.map((d) => axis.scale.convert(d))\n        };\n      }\n    }\n    return result;\n  }\n};\n\n// packages/ag-charts-community/src/chart/cartesianChart.ts\nvar directions = [\"top\", \"right\", \"bottom\", \"left\"];\nvar CartesianChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n    /** Integrated Charts feature state - not used in Standalone Charts. */\n    this.paired = true;\n    this.firstSeriesTranslation = true;\n    this._lastCrossLineIds = void 0;\n    this._lastAxisAreaWidths = /* @__PURE__ */ new Map();\n    this._lastClipSeries = false;\n    this._lastVisibility = {\n      crossLines: true,\n      series: true\n    };\n  }\n  onAxisChange(newValue, oldValue) {\n    super.onAxisChange(newValue, oldValue);\n    this.zoomManager.updateAxes(newValue);\n  }\n  destroySeries(series) {\n    super.destroySeries(series);\n    this.firstSeriesTranslation = true;\n  }\n  getChartType() {\n    return \"cartesian\";\n  }\n  async performLayout() {\n    const shrinkRect = await super.performLayout();\n    const { firstSeriesTranslation, seriesRoot, annotationRoot, highlightRoot } = this;\n    const { animationRect, seriesRect, visibility, clipSeries } = this.updateAxes(shrinkRect);\n    this.seriesRoot.visible = visibility.series;\n    this.seriesRect = seriesRect;\n    this.animationRect = animationRect;\n    const { x, y } = seriesRect;\n    if (firstSeriesTranslation) {\n      for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n        group.translationX = Math.floor(x);\n        group.translationY = Math.floor(y);\n      }\n      this.firstSeriesTranslation = false;\n    } else {\n      const { translationX, translationY } = seriesRoot;\n      staticFromToMotion(\n        this.id,\n        \"seriesRect\",\n        this.ctx.animationManager,\n        [seriesRoot, highlightRoot, annotationRoot],\n        { translationX, translationY },\n        { translationX: Math.floor(x), translationY: Math.floor(y) },\n        { phase: \"update\" }\n      );\n    }\n    const seriesPaddedRect = seriesRect.clone().grow(this.seriesArea.padding);\n    const clipRect = this.seriesArea.clip || clipSeries ? seriesPaddedRect : void 0;\n    seriesRoot.setClipRectInGroupCoordinateSpace(clipRect);\n    highlightRoot.setClipRectInGroupCoordinateSpace(clipRect);\n    annotationRoot.setClipRectInGroupCoordinateSpace(clipRect);\n    this.ctx.layoutService.dispatchLayoutComplete({\n      type: \"layout-complete\",\n      chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },\n      clipSeries,\n      series: {\n        rect: seriesRect,\n        paddedRect: seriesPaddedRect,\n        visible: visibility.series,\n        shouldFlipXY: this.shouldFlipXY()\n      },\n      axes: this.axes.map((axis) => axis.getLayoutState())\n    });\n    const modulePromises = this.modulesManager.mapModules((m) => m.performCartesianLayout?.({ seriesRect }));\n    await Promise.all(modulePromises);\n    return shrinkRect;\n  }\n  updateAxes(inputShrinkRect) {\n    const crossLineIds = this.axes.flatMap((axis) => axis.crossLines ?? []).map((crossLine) => crossLine.id);\n    const axesValid = this._lastCrossLineIds != null && this._lastCrossLineIds.length === crossLineIds.length && this._lastCrossLineIds.every((id, index) => crossLineIds[index] === id);\n    let axisAreaWidths;\n    let clipSeries;\n    let visibility;\n    if (axesValid) {\n      axisAreaWidths = new Map(this._lastAxisAreaWidths.entries());\n      clipSeries = this._lastClipSeries;\n      visibility = { ...this._lastVisibility };\n    } else {\n      axisAreaWidths = /* @__PURE__ */ new Map();\n      clipSeries = false;\n      visibility = { crossLines: true, series: true };\n      this._lastCrossLineIds = crossLineIds;\n    }\n    const liveAxisWidths = new Set(this.axes.map((a) => a.position));\n    for (const position of axisAreaWidths.keys()) {\n      if (!liveAxisWidths.has(position)) {\n        axisAreaWidths.delete(position);\n      }\n    }\n    const stableOutputs = (otherAxisWidths, otherClipSeries, otherVisibility) => {\n      if ([...otherAxisWidths.keys()].some((k) => !axisAreaWidths.has(k))) {\n        return false;\n      }\n      if (visibility.crossLines !== otherVisibility.crossLines || visibility.series !== otherVisibility.series || clipSeries !== otherClipSeries) {\n        return false;\n      }\n      return [...axisAreaWidths.entries()].every(([p, w]) => {\n        const otherW = otherAxisWidths.get(p);\n        if (w != null || otherW != null) {\n          return w === otherW;\n        }\n        return true;\n      });\n    };\n    const ceilValues = (map) => {\n      for (const [key, value] of map.entries()) {\n        if (value && Math.abs(value) === Infinity) {\n          map.set(key, 0);\n          continue;\n        }\n        map.set(key, value != null ? Math.ceil(value) : value);\n      }\n      return map;\n    };\n    let lastPassAxisAreaWidths = /* @__PURE__ */ new Map();\n    let lastPassVisibility = {};\n    let lastPassClipSeries = false;\n    let seriesRect = this.seriesRect?.clone();\n    let count = 0;\n    let primaryTickCounts = {};\n    do {\n      axisAreaWidths = new Map(lastPassAxisAreaWidths.entries());\n      clipSeries = lastPassClipSeries;\n      Object.assign(visibility, lastPassVisibility);\n      const result = this.updateAxesPass(axisAreaWidths, inputShrinkRect.clone(), seriesRect);\n      lastPassAxisAreaWidths = ceilValues(result.axisAreaWidths);\n      lastPassVisibility = result.visibility;\n      lastPassClipSeries = result.clipSeries;\n      ({ seriesRect, primaryTickCounts } = result);\n      if (count++ > 10) {\n        Logger.warn(\"unable to find stable axis layout.\");\n        break;\n      }\n    } while (!stableOutputs(lastPassAxisAreaWidths, lastPassClipSeries, lastPassVisibility));\n    this.axes.forEach((axis) => {\n      axis.update(primaryTickCounts[axis.direction]);\n    });\n    const clipRectPadding = 5;\n    this.axes.forEach((axis) => {\n      axis.setCrossLinesVisible(visibility.crossLines);\n      if (!seriesRect) {\n        return;\n      }\n      axis.clipGrid(\n        seriesRect.x,\n        seriesRect.y,\n        seriesRect.width + clipRectPadding,\n        seriesRect.height + clipRectPadding\n      );\n      switch (axis.position) {\n        case \"left\":\n        case \"right\":\n          axis.clipTickLines(\n            inputShrinkRect.x,\n            seriesRect.y,\n            inputShrinkRect.width + clipRectPadding,\n            seriesRect.height + clipRectPadding\n          );\n          break;\n        case \"top\":\n        case \"bottom\":\n          axis.clipTickLines(\n            seriesRect.x,\n            inputShrinkRect.y,\n            seriesRect.width + clipRectPadding,\n            inputShrinkRect.height + clipRectPadding\n          );\n          break;\n      }\n    });\n    this._lastAxisAreaWidths = axisAreaWidths;\n    this._lastVisibility = visibility;\n    this._lastClipSeries = clipSeries;\n    return { seriesRect, animationRect: inputShrinkRect, visibility, clipSeries };\n  }\n  updateAxesPass(axisAreaWidths, bounds, lastPassSeriesRect) {\n    const axisWidths = /* @__PURE__ */ new Map();\n    const axisGroups = /* @__PURE__ */ new Map();\n    const visibility = {\n      series: true,\n      crossLines: true\n    };\n    let clipSeries = false;\n    const primaryTickCounts = {};\n    const paddedBounds = this.applySeriesPadding(bounds);\n    const crossLinePadding = lastPassSeriesRect ? this.buildCrossLinePadding(axisAreaWidths) : {};\n    const axisAreaBound = this.buildAxisBound(paddedBounds, axisAreaWidths, crossLinePadding, visibility);\n    const seriesRect = this.buildSeriesRect(axisAreaBound, axisAreaWidths);\n    for (const axis of this.axes) {\n      const { position = \"left\" } = axis;\n      const { clipSeries: newClipSeries, axisThickness } = this.calculateAxisDimensions({\n        axis,\n        seriesRect,\n        paddedBounds,\n        primaryTickCounts,\n        clipSeries\n      });\n      axisWidths.set(axis.id, axisThickness);\n      if (!axisGroups.has(position))\n        axisGroups.set(position, []);\n      axisGroups.get(position)?.push(axis);\n      clipSeries = clipSeries || newClipSeries;\n    }\n    const newAxisAreaWidths = /* @__PURE__ */ new Map();\n    const axisOffsets = /* @__PURE__ */ new Map();\n    for (const [position, axes] of axisGroups.entries()) {\n      newAxisAreaWidths.set(position, this.calculateAxisArea(axes, axisWidths, axisOffsets));\n    }\n    for (const [position, axes] of axisGroups.entries()) {\n      this.positionAxes({\n        axes,\n        position,\n        axisWidths,\n        axisOffsets,\n        axisAreaWidths: newAxisAreaWidths,\n        axisBound: axisAreaBound,\n        seriesRect\n      });\n    }\n    return { clipSeries, seriesRect, axisAreaWidths: newAxisAreaWidths, visibility, primaryTickCounts };\n  }\n  buildCrossLinePadding(axisAreaSize) {\n    const crossLinePadding = {};\n    this.axes.forEach((axis) => {\n      axis.crossLines?.forEach((crossLine) => {\n        crossLine.calculatePadding?.(crossLinePadding);\n      });\n    });\n    for (const [side, padding = 0] of Object.entries(crossLinePadding)) {\n      crossLinePadding[side] = Math.max(padding - (axisAreaSize.get(side) ?? 0), 0);\n    }\n    return crossLinePadding;\n  }\n  applySeriesPadding(bounds) {\n    const paddedRect = bounds.clone();\n    const reversedAxes = this.axes.slice().reverse();\n    directions.forEach((dir) => {\n      const padding = this.seriesArea.padding[dir];\n      const axis = reversedAxes.find((a) => a.position === dir);\n      if (axis) {\n        axis.seriesAreaPadding = padding;\n      } else {\n        paddedRect.shrink(padding, dir);\n      }\n    });\n    return paddedRect;\n  }\n  buildAxisBound(bounds, axisAreaWidths, crossLinePadding, visibility) {\n    const result = bounds.clone();\n    const { top = 0, right = 0, bottom = 0, left = 0 } = crossLinePadding;\n    const horizontalPadding = left + right;\n    const verticalPadding = top + bottom;\n    const totalWidth = (axisAreaWidths.get(\"left\") ?? 0) + (axisAreaWidths.get(\"right\") ?? 0) + horizontalPadding;\n    const totalHeight = (axisAreaWidths.get(\"top\") ?? 0) + (axisAreaWidths.get(\"bottom\") ?? 0) + verticalPadding;\n    if (result.width <= totalWidth || result.height <= totalHeight) {\n      visibility.crossLines = false;\n      visibility.series = false;\n      return result;\n    }\n    result.x += left;\n    result.y += top;\n    result.width -= horizontalPadding;\n    result.height -= verticalPadding;\n    return result;\n  }\n  buildSeriesRect(axisBound, axisAreaWidths) {\n    const result = axisBound.clone();\n    result.x += axisAreaWidths.get(\"left\") ?? 0;\n    result.y += axisAreaWidths.get(\"top\") ?? 0;\n    result.width -= (axisAreaWidths.get(\"left\") ?? 0) + (axisAreaWidths.get(\"right\") ?? 0);\n    result.height -= (axisAreaWidths.get(\"top\") ?? 0) + (axisAreaWidths.get(\"bottom\") ?? 0);\n    result.width = Math.max(0, result.width);\n    result.height = Math.max(0, result.height);\n    return result;\n  }\n  clampToOutsideSeriesRect(seriesRect, value, dimension, direction) {\n    const { x, y, width, height } = seriesRect;\n    const clampBounds = [x, y, x + width, y + height];\n    const compareTo = clampBounds[(dimension === \"x\" ? 0 : 1) + (direction === 1 ? 0 : 2)];\n    const clampFn = direction === 1 ? Math.min : Math.max;\n    return clampFn(value, compareTo);\n  }\n  calculateAxisDimensions(opts) {\n    const { axis, seriesRect, paddedBounds, primaryTickCounts } = opts;\n    let { clipSeries } = opts;\n    const { position = \"left\", direction } = axis;\n    this.sizeAxis(axis, seriesRect, position);\n    let primaryTickCount = axis.nice ? primaryTickCounts[direction] : void 0;\n    const isVertical = direction === \"y\" /* Y */;\n    const paddedBoundsCoefficient = 0.3;\n    if (axis.thickness) {\n      axis.maxThickness = axis.thickness;\n    } else {\n      axis.maxThickness = (isVertical ? paddedBounds.width : paddedBounds.height) * paddedBoundsCoefficient;\n    }\n    const layout = axis.calculateLayout(primaryTickCount);\n    primaryTickCount = layout.primaryTickCount;\n    primaryTickCounts[direction] ?? (primaryTickCounts[direction] = primaryTickCount);\n    clipSeries || (clipSeries = axis.dataDomain.clipped || axis.visibleRange[0] > 0 || axis.visibleRange[1] < 1);\n    let axisThickness;\n    if (axis.thickness != null && axis.thickness > 0) {\n      axisThickness = axis.thickness;\n    } else {\n      axisThickness = isVertical ? layout.bbox.width : layout.bbox.height;\n    }\n    axisThickness = Math.ceil(axisThickness);\n    return { clipSeries, axisThickness, primaryTickCount };\n  }\n  sizeAxis(axis, seriesRect, position) {\n    const isCategory = axis instanceof CategoryAxis || axis instanceof GroupedCategoryAxis;\n    const isLeftRight = position === \"left\" || position === \"right\";\n    let { min, max } = this.ctx.zoomManager.getAxisZoom(axis.id);\n    const { width, height } = seriesRect;\n    const minStart = 0;\n    const maxEnd = isLeftRight ? height : width;\n    let start = minStart;\n    let end = maxEnd;\n    const { width: axisWidth, unit, align } = axis.layoutConstraints;\n    if (unit === \"px\") {\n      end = start + axisWidth;\n    } else {\n      end = end * axisWidth / 100;\n    }\n    if (align === \"end\") {\n      start = maxEnd - (end - start);\n      end = maxEnd;\n    }\n    if (isCategory && isLeftRight) {\n      [min, max] = [1 - max, 1 - min];\n    } else if (isLeftRight) {\n      [start, end] = [end, start];\n    }\n    axis.range = [start, end];\n    axis.visibleRange = [min, max];\n    axis.gridLength = isLeftRight ? width : height;\n  }\n  calculateAxisArea(axes, axisWidths, axisOffsets) {\n    let totalAxisWidth = 0;\n    let currentOffset = 0;\n    for (const axis of axes) {\n      axisOffsets.set(axis.id, currentOffset);\n      const axisThickness = axisWidths.get(axis.id) ?? 0;\n      totalAxisWidth = Math.max(totalAxisWidth, currentOffset + axisThickness);\n      if (axis.layoutConstraints.stacked) {\n        currentOffset += axisThickness + 15;\n      }\n    }\n    return totalAxisWidth;\n  }\n  positionAxes(opts) {\n    const { axes, axisBound, axisWidths, axisOffsets, axisAreaWidths, seriesRect, position } = opts;\n    const axisAreaWidth = axisAreaWidths.get(position) ?? 0;\n    let mainDimension = \"x\";\n    let minorDimension = \"y\";\n    let direction = 1;\n    let axisBoundMainOffset = 0;\n    if (position === \"top\" || position === \"bottom\") {\n      mainDimension = \"y\";\n      minorDimension = \"x\";\n      axisBoundMainOffset += 1;\n    }\n    axisBoundMainOffset += axisBound[mainDimension];\n    if (position === \"right\" || position === \"bottom\") {\n      direction = -1;\n      axisBoundMainOffset += mainDimension === \"x\" ? axisBound.width : axisBound.height;\n    }\n    for (const axis of axes) {\n      const minorOffset = axisAreaWidths.get(minorDimension === \"x\" ? \"left\" : \"top\") ?? 0;\n      axis.translation[minorDimension] = axisBound[minorDimension] + minorOffset;\n      const axisThickness = axisWidths.get(axis.id) ?? 0;\n      const axisOffset = axisOffsets.get(axis.id) ?? 0;\n      axis.translation[mainDimension] = this.clampToOutsideSeriesRect(\n        seriesRect,\n        axisBoundMainOffset + direction * (axisOffset + axisThickness),\n        mainDimension,\n        direction\n      );\n      axis.gridPadding = axisAreaWidth - axisOffset - axisThickness;\n      axis.updatePosition();\n    }\n  }\n  shouldFlipXY() {\n    return !this.series.some((series) => !(series instanceof CartesianSeries && series.shouldFlipXY()));\n  }\n};\nCartesianChart.className = \"CartesianChart\";\nCartesianChart.type = \"cartesian\";\n\n// packages/ag-charts-community/src/chart/chartProxy.ts\nvar _AgChartInstanceProxy = class _AgChartInstanceProxy {\n  constructor(chart, factoryApi, licenseManager) {\n    this.factoryApi = factoryApi;\n    this.licenseManager = licenseManager;\n    this.chart = chart;\n    chart.publicApi = this;\n  }\n  static isInstance(x) {\n    if (x instanceof _AgChartInstanceProxy) {\n      return true;\n    }\n    if (x.constructor?.name === \"AgChartInstanceProxy\" && x.chart != null) {\n      return true;\n    }\n    return x.chart != null && this.validateImplementation(x);\n  }\n  static validateImplementation(x) {\n    const chartProps = [\"getOptions\", \"destroy\"];\n    const signatureProps = Object.keys(Object.getPrototypeOf(x) ?? {});\n    return chartProps.every((prop) => signatureProps.includes(prop));\n  }\n  async update(options) {\n    this.factoryApi.createOrUpdate(options, this);\n    await this.chart.waitForUpdate();\n  }\n  async updateDelta(deltaOptions) {\n    this.factoryApi.updateUserDelta(this, deltaOptions);\n    await this.chart.waitForUpdate();\n  }\n  getOptions() {\n    const options = deepClone(this.chart.getOptions());\n    for (const key in options) {\n      if (key.startsWith(\"_\")) {\n        delete options[key];\n      }\n    }\n    return options;\n  }\n  waitForUpdate() {\n    return this.chart.waitForUpdate();\n  }\n  async download(opts) {\n    const clone = await this.prepareResizedChart(this, opts);\n    try {\n      clone.chart.download(opts?.fileName, opts?.fileFormat);\n    } finally {\n      clone.destroy();\n    }\n  }\n  async getImageDataURL(opts) {\n    const clone = await this.prepareResizedChart(this, opts);\n    try {\n      return clone.chart.getCanvasDataURL(opts?.fileFormat);\n    } finally {\n      clone.destroy();\n    }\n  }\n  getState() {\n    return this.factoryApi.caretaker.save(this.chart.ctx.annotationManager);\n  }\n  async setState(state) {\n    this.factoryApi.caretaker.restore(state, this.chart.ctx.annotationManager);\n    await this.chart.waitForUpdate();\n  }\n  resetAnimations() {\n    this.chart.resetAnimations();\n  }\n  skipAnimations() {\n    this.chart.skipAnimations();\n  }\n  destroy() {\n    this.chart.publicApi = void 0;\n    this.chart.destroy();\n  }\n  async prepareResizedChart(proxy, opts = {}) {\n    const { chart } = proxy;\n    const width = opts.width ?? chart.width ?? chart.ctx.scene.canvas.width;\n    const height = opts.height ?? chart.height ?? chart.ctx.scene.canvas.height;\n    const state = proxy.getState();\n    const isEnterprise = moduleRegistry.hasEnterpriseModules();\n    const overrideOptions = {};\n    const processedOptions = chart.chartOptions.getOptions();\n    if (isEnterprise) {\n      overrideOptions.animation = { enabled: false };\n      if (isAgCartesianChartOptions(processedOptions)) {\n        overrideOptions.toolbar = { enabled: false };\n      }\n      if (this.licenseManager?.isDisplayWatermark()) {\n        overrideOptions.foreground = {\n          text: this.licenseManager.getWatermarkMessage(),\n          image: {\n            url: `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjU4IiBoZWlnaHQ9IjQwIiB2aWV3Qm94PSIwIDAgMjU4IDQwIiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNMjUuNzc5IDI4LjY1N0gxMy4zNTlMMTEuMTczIDM0LjAxMkg1LjY3Mjk3TDE3LjE4MiA3LjA1OTk5SDIxLjk1M0wzMy40NjIgMzQuMDEySDI3Ljk2MkwyNS43NzYgMjguNjU3SDI1Ljc3OVpNMjQuMDY4IDI0LjM5N0wxOS41ODggMTMuNDM0TDE1LjEwNyAyNC4zOTdIMjQuMDY4Wk02Mi4wOTIgMTguODIzSDQ5LjgxN1YyMy4wODZINTYuNzc1QzU2LjU1NSAyNS4yMjIgNTUuNzU1IDI2LjkyNyA1NC4zNzIgMjguMjAyQzUyLjk4OSAyOS40NzYgNTEuMTY2IDMwLjExNSA0OC45MDkgMzAuMTE1QzQ3LjYyMiAzMC4xMTUgNDYuNDUgMjkuODg1IDQ1LjM5MyAyOS40MjNDNDQuMzU4MyAyOC45NzgxIDQzLjQzMjYgMjguMzEzOCA0Mi42OCAyNy40NzZDNDEuOTI3IDI2LjYzOSA0MS4zNDQgMjUuNjMxIDQwLjkzMSAyNC40NTNDNDAuNTE5IDIzLjI3NSA0MC4zMTEgMjEuOTcgNDAuMzExIDIwLjUzN0M0MC4zMTEgMTkuMTA1IDQwLjUxNiAxNy44IDQwLjkzMSAxNi42MjFDNDEuMzQ0IDE1LjQ0MyA0MS45MjcgMTQuNDM2IDQyLjY4IDEzLjU5OEM0My40Mzc2IDEyLjc1NzcgNDQuMzY5NiAxMi4wOTMyIDQ1LjQxMSAxMS42NTFDNDYuNDc4IDExLjE4OSA0Ny42NTYgMTAuOTYgNDguOTQ2IDEwLjk2QzUxLjYxMiAxMC45NiA1My42MzcgMTEuNjAyIDU1LjAyIDEyLjg4NUw1OC4zIDkuNjA0OTlDNTUuODE3IDcuNjY5OTkgNTIuNjc2IDYuNjk5OTkgNDguODcyIDYuNjk5OTlDNDYuNzYgNi42OTk5OSA0NC44NTMgNy4wMzQ5OSA0My4xNTQgNy43MDA5OUM0MS40NTUgOC4zNjc5OSAzOS45OTggOS4zMDM5OSAzOC43ODMgMTAuNTA0QzM3LjU2NyAxMS43MDcgMzYuNjM0IDEzLjE1OCAzNS45NzcgMTQuODU3QzM1LjMxOSAxNi41NTYgMzQuOTk0IDE4LjQ1MSAzNC45OTQgMjAuNTRDMzQuOTk0IDIyLjYzIDM1LjMyOSAyNC40OTQgMzUuOTk1IDI2LjIwNUMzNi42NjIgMjcuOTE2IDM3LjYwNSAyOS4zNzQgMzguODE3IDMwLjU3N0M0MC4wMzIgMzEuNzggNDEuNDg2IDMyLjcxMyA0My4xODggMzMuMzgzQzQ0Ljg4OCAzNC4wNDkgNDYuNzgyIDM0LjM4NCA0OC44NzIgMzQuMzg0QzUwLjk2MSAzNC4zODQgNTIuNzUgMzQuMDQ5IDU0LjM5IDMzLjM4M0M1Ni4wMzEgMzIuNzE2IDU3LjQyNiAzMS43OCA1OC41NzkgMzAuNTc3QzU5LjczMyAyOS4zNzQgNjAuNjE5IDI3LjkxNiA2MS4yMzkgMjYuMjA1QzYxLjg2IDI0LjQ5NCA2Mi4xNyAyMi42MDUgNjIuMTcgMjAuNTRDNjIuMTY5NiAxOS45Njg4IDYyLjE0NDUgMTkuMzk4IDYyLjA5NSAxOC44MjlMNjIuMDkyIDE4LjgyM1pNMTUxLjgxIDE2Ljk4MUMxNTMuNDEgMTQuNjA5IDE1Ny40MTkgMTQuMzU4IDE1OS4wMjIgMTQuMzU4VjE4LjkxQzE1Ni45NTcgMTguOTEgMTU0Ljk4NSAxOC45OTYgMTUzLjc1NyAxOS44OTJDMTUyLjUyOSAyMC43OTIgMTUxLjkxOSAyMS45ODIgMTUxLjkxOSAyMy40NjRWMzMuOTlIMTQ2Ljk2NFYxNC4zNThIMTUxLjczNkwxNTEuODEgMTYuOTgxWk0xNDMuMDExIDE0LjM2MVYzNC4wMzFIMTM4LjI0TDEzOC4xMzEgMzEuMDQ1QzEzNy40NjYgMzIuMDc2IDEzNi41NTEgMzIuOTIxOSAxMzUuNDcxIDMzLjUwNEMxMzQuMzc2IDM0LjA5OSAxMzMuMDY4IDM0LjM5NiAxMzEuNTM2IDM0LjM5NkMxMzAuMiAzNC4zOTYgMTI4Ljk2MyAzNC4xNTIgMTI3LjgyMiAzMy42NjhDMTI2LjcgMzMuMTk2NCAxMjUuNjg5IDMyLjQ5NSAxMjQuODU1IDMxLjYwOUMxMjQuMDE4IDMwLjcyMiAxMjMuMzU0IDI5LjY2MiAxMjIuODcxIDI4LjQyMkMxMjIuMzg0IDI3LjE4NSAxMjIuMTQyIDI1LjgxMSAxMjIuMTQyIDI0LjMwNEMxMjIuMTQyIDIyLjc5OCAxMjIuMzg0IDIxLjM3OCAxMjIuODcxIDIwLjExNkMxMjMuMzU3IDE4Ljg1NCAxMjQuMDE4IDE3Ljc3MiAxMjQuODU1IDE2Ljg3M0MxMjUuNjg4IDE1Ljk3NjQgMTI2LjY5OCAxNS4yNjM2IDEyNy44MjIgMTQuNzhDMTI4Ljk2MyAxNC4yODEgMTMwLjIwMyAxNC4wMzMgMTMxLjUzNiAxNC4wMzNDMTMzLjA0MyAxNC4wMzMgMTM0LjMzIDE0LjMxOCAxMzUuMzk3IDE0Ljg4OEMxMzYuNDYyIDE1LjQ1ODkgMTM3LjM3NSAxNi4yNzggMTM4LjA1NyAxNy4yNzZWMTQuMzYxSDE0My4wMTFaTTEzMi42MzEgMzAuMTMzQzEzNC4yNTYgMzAuMTMzIDEzNS41NjcgMjkuNTk0IDEzNi41NjUgMjguNTEyQzEzNy41NjEgMjcuNDMgMTM4LjA2IDI1Ljk5MSAxMzguMDYgMjQuMTk2QzEzOC4wNiAyMi40MDEgMTM3LjU2MSAyMC45OSAxMzYuNTY1IDE5Ljg5OUMxMzUuNTcgMTguODA3IDEzNC4yNTkgMTguMjU4IDEzMi42MzEgMTguMjU4QzEzMS4wMDMgMTguMjU4IDEyOS43MjkgMTguODA0IDEyOC43MzQgMTkuODk5QzEyNy43MzggMjAuOTkzIDEyNy4yMzkgMjIuNDM4IDEyNy4yMzkgMjQuMjMzQzEyNy4yMzkgMjYuMDI4IDEyNy43MzUgMjcuNDMzIDEyOC43MzQgMjguNTE1QzEyOS43MjkgMjkuNTk0IDEzMS4wMjggMzAuMTM2IDEzMi42MzEgMzAuMTM2VjMwLjEzM1pNOTMuNjk4IDI3Ljg3NkM5My41Nzk1IDI4LjAwMjUgOTMuNDU2NCAyOC4xMjQ2IDkzLjMyOSAyOC4yNDJDOTEuOTQ3IDI5LjUxNiA5MC4xMjMgMzAuMTU1IDg3Ljg2NiAzMC4xNTVDODYuNTggMzAuMTU1IDg1LjQwOCAyOS45MjYgODQuMzUgMjkuNDY0QzgzLjMxNTUgMjkuMDE4OSA4Mi4zODk4IDI4LjM1NDYgODEuNjM3IDI3LjUxN0M4MC44ODQgMjYuNjc5IDgwLjMwMSAyNS42NzIgNzkuODg5IDI0LjQ5NEM3OS40NzYgMjMuMzE1IDc5LjI2OSAyMi4wMSA3OS4yNjkgMjAuNTc4Qzc5LjI2OSAxOS4xNDUgNzkuNDczIDE3Ljg0IDc5Ljg4OSAxNi42NjJDODAuMzAxIDE1LjQ4NCA4MC44ODQgMTQuNDc2IDgxLjYzNyAxMy42MzlDODIuMzk0OSAxMi43OTg3IDgzLjMyNzMgMTIuMTM0MiA4NC4zNjkgMTEuNjkyQzg1LjQzNiAxMS4yMyA4Ni42MTQgMTEgODcuOTAzIDExQzkwLjU3IDExIDkyLjU5NSAxMS42NDIgOTMuOTc3IDEyLjkyNkw5Ny4yNTggOS42NDQ5OUM5NC43NzQgNy43MTA5OSA5MS42MzMgNi43Mzk5OSA4Ny44MjkgNi43Mzk5OUM4NS43MTggNi43Mzk5OSA4My44MTEgNy4wNzQ5OSA4Mi4xMTIgNy43NDE5OUM4MC40MTMgOC40MDc5OSA3OC45NTYgOS4zNDQ5OSA3Ny43NCAxMC41NDVDNzYuNTI1IDExLjc0NyA3NS41OTIgMTMuMTk5IDc0LjkzNCAxNC44OThDNzQuMjc3IDE2LjU5NyA3My45NTEgMTguNDkxIDczLjk1MSAyMC41ODFDNzMuOTUxIDIyLjY3IDc0LjI4NiAyNC41MzQgNzQuOTUzIDI2LjI0NUM3NS42MTkgMjcuOTU3IDc2LjU2MiAyOS40MTQgNzcuNzc0IDMwLjYxN0M3OC45OSAzMS44MiA4MC40NDQgMzIuNzUzIDgyLjE0NiAzMy40MjNDODMuODQ1IDM0LjA5IDg1LjczOSAzNC40MjQgODcuODI5IDM0LjQyNEM4OS45MTkgMzQuNDI0IDkxLjcwOCAzNC4wOSA5My4zNDggMzMuNDIzQzk0LjcxOCAzMi44NjUgOTUuOTE4IDMyLjEyMSA5Ni45NDggMzEuMTkxQzk3LjE0OSAzMS4wMDggOTcuMzQ4IDMwLjgxNSA5Ny41MzcgMzAuNjJMOTMuNzAxIDI3Ljg4NUw5My42OTggMjcuODc2Wk0xMTAuODAyIDE0LjAxNUMxMDkuMTk5IDE0LjAxNSAxMDYuODM2IDE0LjQ3MSAxMDUuNjExIDE2LjE1OEwxMDUuNTM3IDYuMDE1OTlIMTAwLjc2NVYzMy45MzlIMTA1LjcyVjIyLjY0MUMxMDUuNzcxIDIxLjQ2MDcgMTA2LjI4OCAyMC4zNDg4IDEwNy4xNTcgMTkuNTQ4OUMxMDguMDI3IDE4Ljc0OTEgMTA5LjE3OCAxOC4zMjY2IDExMC4zNTggMTguMzc0QzExMy4zOTcgMTguMzc0IDExNC4yNjggMjEuMTU5IDExNC4yNjggMjIuNjQxVjMzLjkzOUgxMTkuMjIzVjIxLjA1OUMxMTkuMjIzIDIxLjA1OSAxMTkuMTQyIDE0LjAxNSAxMTAuODAyIDE0LjAxNVpNMTczLjc2MyAxNC4zNThIMTY5Ljk5OVY4LjcxNDk5SDE2NS4wNDhWMTQuMzU4SDE2MS4yODRWMTguOTE2SDE2NS4wNDhWMzQuMDAzSDE2OS45OTlWMTguOTE2SDE3My43NjNWMTQuMzU4Wk0xOTAuNzg3IDI1LjI2MkMxOTAuMTI5IDI0LjUwMTQgMTg5LjMwNyAyMy44OTk0IDE4OC4zODQgMjMuNTAxQzE4Ny40ODggMjMuMTE3IDE4Ni4zMzEgMjIuNzMyIDE4NC45NDggMjIuMzY0QzE4NC4xNjUgMjIuMTQzOSAxODMuMzkgMjEuODk3OCAxODIuNjIzIDIxLjYyNkMxODIuMTYzIDIxLjQ2MjEgMTgxLjc0MSAyMS4yMDY2IDE4MS4zODMgMjAuODc1QzE4MS4yMzUgMjAuNzQyMSAxODEuMTE4IDIwLjU3ODkgMTgxLjAzOSAyMC4zOTY0QzE4MC45NjEgMjAuMjE0IDE4MC45MjIgMjAuMDE2NiAxODAuOTI3IDE5LjgxOEMxODAuOTI3IDE5LjI3MiAxODEuMTU2IDE4Ljg0NCAxODEuNjI1IDE4LjUxQzE4Mi4xMjEgMTguMTU2IDE4Mi44NjIgMTcuOTc2IDE4My44MjYgMTcuOTc2QzE4NC43OSAxNy45NzYgMTg1LjU4NyAxOC4yMDkgMTg2LjE0OCAxOC42NjhDMTg2LjcwNiAxOS4xMjQgMTg3LjAwNyAxOS43MjUgMTg3LjA3MiAyMC41TDE4Ny4wOTQgMjAuNzgySDE5MS42MzNMMTkxLjYxNyAyMC40NkMxOTEuNTIxIDE4LjQ4NSAxOTAuNzcxIDE2LjkgMTg5LjM4NSAxNS43NUMxODguMDEyIDE0LjYxMiAxODYuMTg1IDE0LjAzMyAxODMuOTYyIDE0LjAzM0MxODIuNDc3IDE0LjAzMyAxODEuMTQxIDE0LjI4NyAxNzkuOTk0IDE0Ljc4NkMxNzguODMxIDE1LjI5MSAxNzcuOTI2IDE1Ljk5NSAxNzcuMjk2IDE2Ljg4MkMxNzYuNjczIDE3Ljc0NTUgMTc2LjMzOCAxOC43ODQgMTc2LjM0MSAxOS44NDlDMTc2LjM0MSAyMS4xNjcgMTc2LjY5OCAyMi4yNDkgMTc3LjM5OSAyMy4wNjRDMTc4LjA2IDIzLjg0MzIgMTc4Ljg5OCAyNC40NTM0IDE3OS44NDIgMjQuODQ0QzE4MC43NDQgMjUuMjE2IDE4MS45MjggMjUuNjA3IDE4My4zNjEgMjZDMTg0LjgwNiAyNi40MSAxODUuODcyIDI2Ljc4NSAxODYuNTMgMjcuMTIzQzE4Ny4xIDI3LjQxNCAxODcuMzc5IDI3Ljg0NSAxODcuMzc5IDI4LjQ0NEMxODcuMzc5IDI5LjA0MiAxODcuMTIyIDI5LjQ2NyAxODYuNTk1IDI5LjgzOUMxODYuMDQzIDMwLjIyNiAxODUuMjM3IDMwLjQyNSAxODQuMjAxIDMwLjQyNUMxODMuMTY2IDMwLjQyNSAxODIuMzk0IDMwLjE3NCAxODEuNzQ5IDI5LjY3NEMxODEuMTEzIDI5LjE4MSAxODAuNzcyIDI4LjU4OSAxODAuNzEgMjcuODY0TDE4MC42ODUgMjcuNTgySDE3Ni4wMTNMMTc2LjAyNSAyNy45MDFDMTc2LjA2NyAyOS4wOTU1IDE3Ni40NzIgMzAuMjQ4NyAxNzcuMTg4IDMxLjIwNkMxNzcuOTA3IDMyLjE4IDE3OC44OTMgMzIuOTU4IDE4MC4xMTggMzMuNTE5QzE4MS4zMzYgMzQuMDc3IDE4Mi43MzIgMzQuMzYyIDE4NC4yNjYgMzQuMzYyQzE4NS44MDEgMzQuMzYyIDE4Ny4xMDkgMzQuMTA4IDE4OC4yMzggMzMuNjA5QzE4OS4zNzYgMzMuMTA0IDE5MC4yNzIgMzIuMzk0IDE5MC45MDEgMzEuNDk0QzE5MS41MzQgMzAuNTkyIDE5MS44NTMgMjkuNTU0IDE5MS44NTMgMjguNDAzQzE5MS44MjggMjcuMTEgMTkxLjQ2NiAyNi4wNTMgMTkwLjc3NyAyNS4yNjJIMTkwLjc4N1oiIGZpbGw9IiM5QjlCOUIiLz4KPHBhdGggZD0iTTI0MS45ODIgMjUuNjU4MlYxNy43MTE3SDIyOC40NDFMMjIwLjQ5NCAyNS42NTgySDI0MS45ODJaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNTcuMjM5IDUuOTUwODFIMjQwLjI2NUwyMzIuMjU1IDEzLjg5NzNIMjU3LjIzOVY1Ljk1MDgxWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjEyLjYxMSAzMy42MDQ4TDIxNi42OCAyOS41MzYxSDIzMC40MTJWMzcuNDgyN0gyMTIuNjExVjMzLjYwNDhaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yMTUuNTk5IDIxLjc4MDNIMjI0LjM3MkwyMzIuMzgyIDEzLjgzMzdIMjE1LjU5OVYyMS43ODAzWiIgZmlsbD0iIzlCOUI5QiIvPgo8cGF0aCBkPSJNMjA2IDMzLjYwNDdIMjEyLjYxMUwyMjAuNDk0IDI1LjY1ODJIMjA2VjMzLjYwNDdaIiBmaWxsPSIjOUI5QjlCIi8+CjxwYXRoIGQ9Ik0yNDAuMjY1IDUuOTUwODFMMjM2LjE5NyAxMC4wMTk0SDIxMC4yNTlWMi4wNzI4OEgyNDAuMjY1VjUuOTUwODFaIiBmaWxsPSIjOUI5QjlCIi8+Cjwvc3ZnPgo=`,\n            width: 170,\n            height: 25,\n            right: 25,\n            bottom: 50,\n            opacity: 0.7\n          }\n        };\n      }\n    }\n    const options = mergeDefaults(\n      {\n        container: document.createElement(\"div\"),\n        width,\n        height\n      },\n      overrideOptions,\n      processedOptions\n    );\n    const cloneProxy = await this.factoryApi.createOrUpdate(options);\n    await cloneProxy.setState(state);\n    cloneProxy.chart.ctx.zoomManager.updateZoom(\"agChartV2\", chart.ctx.zoomManager.getZoom());\n    chart.series.forEach((series, index) => {\n      if (!series.visible) {\n        cloneProxy.chart.series[index].visible = false;\n      }\n    });\n    chart.update(0 /* FULL */, { forceNodeDataRefresh: true });\n    await cloneProxy.waitForUpdate();\n    return cloneProxy;\n  }\n};\n_AgChartInstanceProxy.chartInstances = /* @__PURE__ */ new WeakMap();\n__decorateClass([\n  ActionOnSet({\n    oldValue(chart) {\n      _AgChartInstanceProxy.chartInstances.delete(chart);\n    },\n    newValue(chart) {\n      _AgChartInstanceProxy.chartInstances.set(chart, this);\n    }\n  })\n], _AgChartInstanceProxy.prototype, \"chart\", 2);\nvar AgChartInstanceProxy = _AgChartInstanceProxy;\n\n// packages/ag-charts-community/src/scale/linearScale.ts\nvar LinearScale = class extends ContinuousScale {\n  constructor() {\n    super([0, 1], [0, 1]);\n    this.type = \"number\";\n  }\n  toDomain(d) {\n    return d;\n  }\n  ticks() {\n    const count = this.tickCount ?? ContinuousScale.defaultTickCount;\n    if (!this.domain || this.domain.length < 2 || count < 1 || !this.domain.every(isFinite)) {\n      return [];\n    }\n    this.refresh();\n    const [d0, d1] = this.getDomain();\n    if (this.interval) {\n      const step = Math.abs(this.interval);\n      if (!isDenseInterval((d1 - d0) / step, this.getPixelRange())) {\n        return range(d0, d1, step);\n      }\n    }\n    return createTicks(d0, d1, count, this.minTickCount, this.maxTickCount);\n  }\n  update() {\n    if (!this.domain || this.domain.length < 2) {\n      return;\n    }\n    if (this.nice) {\n      this.updateNiceDomain();\n    }\n  }\n  getTickStep(start, stop) {\n    return this.interval ?? tickStep(start, stop, this.tickCount, this.minTickCount, this.maxTickCount);\n  }\n  /**\n   * Extends the domain so that it starts and ends on nice round values.\n   */\n  updateNiceDomain() {\n    const count = this.tickCount;\n    if (count < 1) {\n      this.niceDomain = [...this.domain];\n      return;\n    }\n    let [start, stop] = this.domain;\n    if (count === 1) {\n      [start, stop] = niceTicksDomain(start, stop);\n    } else {\n      const roundStart = start > stop ? Math.ceil : Math.floor;\n      const roundStop = stop < start ? Math.floor : Math.ceil;\n      const maxAttempts = 4;\n      for (let i = 0; i < maxAttempts; i++) {\n        const prev0 = start;\n        const prev1 = stop;\n        const step = this.getTickStep(start, stop);\n        const [d0, d1] = this.domain;\n        if (step >= 1) {\n          start = roundStart(d0 / step) * step;\n          stop = roundStop(d1 / step) * step;\n        } else {\n          const s = 1 / step;\n          start = roundStart(d0 * s) / s;\n          stop = roundStop(d1 * s) / s;\n        }\n        if (start === prev0 && stop === prev1) {\n          break;\n        }\n      }\n    }\n    this.niceDomain = [start, stop];\n  }\n  tickFormat({ ticks: specifiedTicks, specifier }) {\n    return tickFormat(specifiedTicks ?? this.ticks(), specifier);\n  }\n};\n\n// packages/ag-charts-community/src/util/secondaryAxisTicks.ts\nfunction calculateNiceSecondaryAxis(domain, primaryTickCount, reverse) {\n  let [start, stop] = findMinMax(domain);\n  start = calculateNiceStart(Math.floor(start), stop, primaryTickCount);\n  const step = getTickStep(start, stop, primaryTickCount);\n  const segments = primaryTickCount - 1;\n  stop = start + segments * step;\n  const d = reverse ? [stop, start] : [start, stop];\n  const ticks = getTicks(start, step, primaryTickCount);\n  return { domain: d, ticks };\n}\nfunction calculateNiceStart(a, b, count) {\n  const rawStep = Math.abs(b - a) / (count - 1);\n  const order = Math.floor(Math.log10(rawStep));\n  const magnitude = Math.pow(10, order);\n  return Math.floor(a / magnitude) * magnitude;\n}\nfunction getTicks(start, step, count) {\n  const stepPower = Math.floor(Math.log10(step));\n  const fractionDigits = step > 0 && step < 1 ? Math.abs(stepPower) : 0;\n  const f = Math.pow(10, fractionDigits);\n  const ticks = [];\n  for (let i = 0; i < count; i++) {\n    const tick = start + step * i;\n    ticks[i] = Math.round(tick * f) / f;\n  }\n  return ticks;\n}\nfunction getTickStep(start, stop, count) {\n  const segments = count - 1;\n  const rawStep = (stop - start) / segments;\n  return calculateNextNiceStep(rawStep);\n}\nfunction calculateNextNiceStep(rawStep) {\n  const order = Math.floor(Math.log10(rawStep));\n  const magnitude = Math.pow(10, order);\n  const step = rawStep / magnitude * 10;\n  if (step > 0 && step <= 1) {\n    return magnitude / 10;\n  }\n  if (step > 1 && step <= 2) {\n    return 2 * magnitude / 10;\n  }\n  if (step > 1 && step <= 5) {\n    return 5 * magnitude / 10;\n  }\n  if (step > 5 && step <= 10) {\n    return 10 * magnitude / 10;\n  }\n  if (step > 10 && step <= 20) {\n    return 20 * magnitude / 10;\n  }\n  if (step > 20 && step <= 40) {\n    return 40 * magnitude / 10;\n  }\n  if (step > 40 && step <= 50) {\n    return 50 * magnitude / 10;\n  }\n  if (step > 50 && step <= 100) {\n    return 100 * magnitude / 10;\n  }\n  return step;\n}\n\n// packages/ag-charts-community/src/chart/axis/numberAxis.ts\nvar NumberAxis = class extends CartesianAxis {\n  constructor(moduleCtx, scale2 = new LinearScale()) {\n    super(moduleCtx, scale2);\n    this.min = NaN;\n    this.max = NaN;\n  }\n  normaliseDataDomain(d) {\n    const { min, max } = this;\n    const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);\n    return { domain: extent2, clipped };\n  }\n  updateSecondaryAxisTicks(primaryTickCount) {\n    if (this.dataDomain == null) {\n      throw new Error(\"AG Charts - dataDomain not calculated, cannot perform tick calculation.\");\n    }\n    if (this.dataDomain.domain.length === 0) {\n      return [];\n    }\n    const { domain, ticks } = calculateNiceSecondaryAxis(\n      this.dataDomain.domain,\n      primaryTickCount ?? 0,\n      this.reverse\n    );\n    this.scale.nice = false;\n    this.scale.domain = domain;\n    this.scale.update();\n    return ticks;\n  }\n};\nNumberAxis.className = \"NumberAxis\";\nNumberAxis.type = \"number\";\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, LESS_THAN(\"max\"))),\n  Default(NaN)\n], NumberAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, GREATER_THAN(\"min\"))),\n  Default(NaN)\n], NumberAxis.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/chart/axis/logAxis.ts\nvar NON_ZERO_NUMBER = predicateWithMessage((value) => isNumber(value) && value !== 0, \"a non-zero number\");\nvar LogAxis = class extends NumberAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new LogScale());\n    this.min = NaN;\n    this.max = NaN;\n  }\n  normaliseDataDomain(d) {\n    const { min, max } = this;\n    const { extent: extent2, clipped } = normalisedExtentWithMetadata(d, min, max);\n    const isInverted = extent2[0] > extent2[1];\n    const crossesZero = extent2[0] < 0 && extent2[1] > 0;\n    const hasZeroExtent = extent2[0] === 0 && extent2[1] === 0;\n    const invalidDomain = isInverted || crossesZero || hasZeroExtent;\n    if (invalidDomain) {\n      if (crossesZero) {\n        Logger.warn(\n          `the data domain crosses zero, the chart data cannot be rendered. See log axis documentation for more information.`\n        );\n      } else if (hasZeroExtent) {\n        Logger.warn(`the data domain has 0 extent, no data is rendered.`);\n      }\n    }\n    if (extent2[0] === 0) {\n      extent2[0] = 1;\n    }\n    if (extent2[1] === 0) {\n      extent2[1] = -1;\n    }\n    return { domain: extent2, clipped };\n  }\n  set base(value) {\n    this.scale.base = value;\n  }\n  get base() {\n    return this.scale.base;\n  }\n};\nLogAxis.className = \"LogAxis\";\nLogAxis.type = \"log\";\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, NON_ZERO_NUMBER, LESS_THAN(\"max\"))),\n  Default(NaN)\n], LogAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate(AND(NUMBER_OR_NAN, NON_ZERO_NUMBER, GREATER_THAN(\"min\"))),\n  Default(NaN)\n], LogAxis.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/chart/axis/timeAxis.ts\nvar TimeAxis = class extends CartesianAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new TimeScale());\n    this.min = void 0;\n    this.max = void 0;\n  }\n  normaliseDataDomain(d) {\n    let { min, max } = this;\n    let clipped = false;\n    if (typeof min === \"number\") {\n      min = new Date(min);\n    }\n    if (typeof max === \"number\") {\n      max = new Date(max);\n    }\n    if (d.length > 2) {\n      d = (extent(d) ?? [0, 1e3]).map((x) => new Date(x));\n    }\n    if (min instanceof Date) {\n      clipped || (clipped = min > d[0]);\n      d = [min, d[1]];\n    }\n    if (max instanceof Date) {\n      clipped || (clipped = max < d[1]);\n      d = [d[0], max];\n    }\n    if (d[0] > d[1]) {\n      d = [];\n    }\n    return { domain: d, clipped };\n  }\n  onFormatChange(ticks, fractionDigits, domain, format) {\n    if (format) {\n      super.onFormatChange(ticks, fractionDigits, domain, format);\n    } else {\n      this.labelFormatter = this.scale.tickFormat({ ticks, domain });\n      this.datumFormatter = this.scale.tickFormat({ ticks, domain, formatOffset: 1 });\n    }\n  }\n  calculatePadding() {\n    return [0, 0];\n  }\n};\nTimeAxis.className = \"TimeAxis\";\nTimeAxis.type = \"time\";\n__decorateClass([\n  Validate(AND(DATE_OR_DATETIME_MS, LESS_THAN(\"max\")), { optional: true })\n], TimeAxis.prototype, \"min\", 2);\n__decorateClass([\n  Validate(AND(DATE_OR_DATETIME_MS, GREATER_THAN(\"min\")), { optional: true })\n], TimeAxis.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/scene/util/corner.ts\nvar drawCorner = (path, { x0, y0, x1, y1, cx, cy }, cornerRadius, move) => {\n  if (move) {\n    path.moveTo(x0, y0);\n  }\n  if (x0 !== x1 || y0 !== y1) {\n    const r0 = Math.atan2(y0 - cy, x0 - cx);\n    const r1 = Math.atan2(y1 - cy, x1 - cx);\n    path.arc(cx, cy, cornerRadius, r0, r1);\n  } else {\n    path.lineTo(x0, y0);\n  }\n};\n\n// packages/ag-charts-community/src/scene/shape/rect.ts\nvar epsilon = 1e-6;\nvar cornerEdges = (leadingEdge, trailingEdge, leadingInset, trailingInset, cornerRadius) => {\n  let leadingClipped = false;\n  let trailingClipped = false;\n  let leading0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - leadingInset ** 2, 0));\n  let leading1 = 0;\n  let trailing0 = 0;\n  let trailing1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - trailingInset ** 2, 0));\n  if (leading0 > leadingEdge) {\n    leadingClipped = true;\n    leading0 = leadingEdge;\n    leading1 = leadingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (trailingInset - leadingEdge) ** 2));\n  } else if (leading0 < epsilon) {\n    leading0 = 0;\n  }\n  if (trailing1 > trailingEdge) {\n    trailingClipped = true;\n    trailing0 = trailingInset - Math.sqrt(Math.max(cornerRadius ** 2 - (leadingInset - trailingEdge) ** 2));\n    trailing1 = trailingEdge;\n  } else if (trailing1 < epsilon) {\n    trailing1 = 0;\n  }\n  return { leading0, leading1, trailing0, trailing1, leadingClipped, trailingClipped };\n};\nvar insetCornerRadiusRect = (path, x, y, width, height, cornerRadii, clipBBox) => {\n  let {\n    topLeft: topLeftCornerRadius,\n    topRight: topRightCornerRadius,\n    bottomRight: bottomRightCornerRadius,\n    bottomLeft: bottomLeftCornerRadius\n  } = cornerRadii;\n  const maxVerticalCornerRadius = Math.max(\n    topLeftCornerRadius + bottomLeftCornerRadius,\n    topRightCornerRadius + bottomRightCornerRadius\n  );\n  const maxHorizontalCornerRadius = Math.max(\n    topLeftCornerRadius + topRightCornerRadius,\n    bottomLeftCornerRadius + bottomRightCornerRadius\n  );\n  if (maxVerticalCornerRadius <= 0 && maxHorizontalCornerRadius <= 0) {\n    if (clipBBox == null) {\n      path.rect(x, y, width, height);\n    } else {\n      path.rect(clipBBox.x, clipBBox.y, clipBBox.width, clipBBox.height);\n    }\n    return;\n  } else if (clipBBox == null && topLeftCornerRadius === topRightCornerRadius && topLeftCornerRadius === bottomRightCornerRadius && topLeftCornerRadius === bottomLeftCornerRadius) {\n    path.roundRect(x, y, width, height, topLeftCornerRadius);\n    return;\n  }\n  if (width < 0) {\n    x += width;\n    width = Math.abs(width);\n  }\n  if (height < 0) {\n    y += height;\n    height = Math.abs(height);\n  }\n  if (width <= 0 || height <= 0)\n    return;\n  if (clipBBox == null) {\n    clipBBox = new BBox(x, y, width, height);\n  } else {\n    const x0 = Math.max(x, clipBBox.x);\n    const x1 = Math.min(x + width, clipBBox.x + clipBBox.width);\n    const y0 = Math.max(y, clipBBox.y);\n    const y1 = Math.min(y + height, clipBBox.y + clipBBox.height);\n    clipBBox = new BBox(x0, y0, x1 - x0, y1 - y0);\n  }\n  const borderScale = Math.max(maxVerticalCornerRadius / height, maxHorizontalCornerRadius / width, 1);\n  if (borderScale > 1) {\n    topLeftCornerRadius /= borderScale;\n    topRightCornerRadius /= borderScale;\n    bottomRightCornerRadius /= borderScale;\n    bottomLeftCornerRadius /= borderScale;\n  }\n  let drawTopLeftCorner = true;\n  let drawTopRightCorner = true;\n  let drawBottomRightCorner = true;\n  let drawBottomLeftCorner = true;\n  let topLeftCorner;\n  let topRightCorner;\n  let bottomRightCorner;\n  let bottomLeftCorner;\n  if (drawTopLeftCorner) {\n    const nodes = cornerEdges(\n      clipBBox.height,\n      clipBBox.width,\n      Math.max(x + topLeftCornerRadius - clipBBox.x, 0),\n      Math.max(y + topLeftCornerRadius - clipBBox.y, 0),\n      topLeftCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawBottomLeftCorner = false;\n    if (nodes.trailingClipped)\n      drawTopRightCorner = false;\n    const x0 = Math.max(clipBBox.x + nodes.leading1, clipBBox.x);\n    const y0 = Math.max(clipBBox.y + nodes.leading0, clipBBox.y);\n    const x1 = Math.max(clipBBox.x + nodes.trailing1, clipBBox.x);\n    const y1 = Math.max(clipBBox.y + nodes.trailing0, clipBBox.y);\n    const cx = x + topLeftCornerRadius;\n    const cy = y + topLeftCornerRadius;\n    topLeftCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  if (drawTopRightCorner) {\n    const nodes = cornerEdges(\n      clipBBox.width,\n      clipBBox.height,\n      Math.max(y + topRightCornerRadius - clipBBox.y, 0),\n      Math.max(clipBBox.x + clipBBox.width - (x + width - topRightCornerRadius), 0),\n      topRightCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawTopLeftCorner = false;\n    if (nodes.trailingClipped)\n      drawBottomRightCorner = false;\n    const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading0, clipBBox.x + clipBBox.width);\n    const y0 = Math.max(clipBBox.y + nodes.leading1, clipBBox.y);\n    const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing0, clipBBox.x + clipBBox.width);\n    const y1 = Math.max(clipBBox.y + nodes.trailing1, clipBBox.y);\n    const cx = x + width - topRightCornerRadius;\n    const cy = y + topRightCornerRadius;\n    topRightCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  if (drawBottomRightCorner) {\n    const nodes = cornerEdges(\n      clipBBox.height,\n      clipBBox.width,\n      Math.max(clipBBox.x + clipBBox.width - (x + width - bottomRightCornerRadius), 0),\n      Math.max(clipBBox.y + clipBBox.height - (y + height - bottomRightCornerRadius), 0),\n      bottomRightCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawTopRightCorner = false;\n    if (nodes.trailingClipped)\n      drawBottomLeftCorner = false;\n    const x0 = Math.min(clipBBox.x + clipBBox.width - nodes.leading1, clipBBox.x + clipBBox.width);\n    const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading0, clipBBox.y + clipBBox.height);\n    const x1 = Math.min(clipBBox.x + clipBBox.width - nodes.trailing1, clipBBox.x + clipBBox.width);\n    const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing0, clipBBox.y + clipBBox.height);\n    const cx = x + width - bottomRightCornerRadius;\n    const cy = y + height - bottomRightCornerRadius;\n    bottomRightCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  if (drawBottomLeftCorner) {\n    const nodes = cornerEdges(\n      clipBBox.width,\n      clipBBox.height,\n      Math.max(clipBBox.y + clipBBox.height - (y + height - bottomLeftCornerRadius), 0),\n      Math.max(x + bottomLeftCornerRadius - clipBBox.x, 0),\n      bottomLeftCornerRadius\n    );\n    if (nodes.leadingClipped)\n      drawBottomRightCorner = false;\n    if (nodes.trailingClipped)\n      drawTopLeftCorner = false;\n    const x0 = Math.max(clipBBox.x + nodes.leading0, clipBBox.x);\n    const y0 = Math.min(clipBBox.y + clipBBox.height - nodes.leading1, clipBBox.y + clipBBox.height);\n    const x1 = Math.max(clipBBox.x + nodes.trailing0, clipBBox.x);\n    const y1 = Math.min(clipBBox.y + clipBBox.height - nodes.trailing1, clipBBox.y + clipBBox.height);\n    const cx = x + bottomLeftCornerRadius;\n    const cy = y + height - bottomLeftCornerRadius;\n    bottomLeftCorner = { x0, y0, x1, y1, cx, cy };\n  }\n  let didMove = false;\n  if (drawTopLeftCorner && topLeftCorner != null) {\n    drawCorner(path, topLeftCorner, topLeftCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  if (drawTopRightCorner && topRightCorner != null) {\n    drawCorner(path, topRightCorner, topRightCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  if (drawBottomRightCorner && bottomRightCorner != null) {\n    drawCorner(path, bottomRightCorner, bottomRightCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  if (drawBottomLeftCorner && bottomLeftCorner != null) {\n    drawCorner(path, bottomLeftCorner, bottomLeftCornerRadius, !didMove);\n    didMove || (didMove = true);\n  }\n  path.closePath();\n};\nvar Rect = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.borderPath = new ExtendedPath2D();\n    this.x = 0;\n    this.y = 0;\n    this.width = 10;\n    this.height = 10;\n    this.topLeftCornerRadius = 0;\n    this.topRightCornerRadius = 0;\n    this.bottomRightCornerRadius = 0;\n    this.bottomLeftCornerRadius = 0;\n    this.clipBBox = void 0;\n    this.crisp = false;\n    this.lastUpdatePathStrokeWidth = Shape.defaultStyles.strokeWidth;\n    this.effectiveStrokeWidth = Shape.defaultStyles.strokeWidth;\n    this.hittester = super.isPointInPath;\n    this.distanceCalculator = super.distanceSquaredTransformedPoint;\n    /**\n     * When the rectangle's width or height is less than a pixel\n     * and crisp mode is on, the rectangle will still fit into the pixel,\n     * but will be less opaque to make an effect of holding less space.\n     */\n    this.microPixelEffectOpacity = 1;\n  }\n  set cornerRadius(cornerRadius) {\n    this.topLeftCornerRadius = cornerRadius;\n    this.topRightCornerRadius = cornerRadius;\n    this.bottomRightCornerRadius = cornerRadius;\n    this.bottomLeftCornerRadius = cornerRadius;\n  }\n  isDirtyPath() {\n    return this.lastUpdatePathStrokeWidth !== this.strokeWidth || Boolean(this.path.isDirty() || this.borderPath.isDirty());\n  }\n  updatePath() {\n    const {\n      path,\n      borderPath,\n      crisp,\n      topLeftCornerRadius: topLeft,\n      topRightCornerRadius: topRight,\n      bottomRightCornerRadius: bottomRight,\n      bottomLeftCornerRadius: bottomLeft\n    } = this;\n    let { x, y, width: w, height: h, strokeWidth, clipBBox } = this;\n    const pixelRatio = this.layerManager?.canvas.pixelRatio ?? 1;\n    const pixelSize = 1 / pixelRatio;\n    let microPixelEffectOpacity = 1;\n    path.clear(true);\n    borderPath.clear(true);\n    if (crisp) {\n      if (w <= pixelSize) {\n        microPixelEffectOpacity *= w / pixelSize;\n      }\n      if (h <= pixelSize) {\n        microPixelEffectOpacity *= h / pixelSize;\n      }\n      w = this.align(x, w);\n      h = this.align(y, h);\n      x = this.align(x);\n      y = this.align(y);\n      clipBBox = clipBBox != null ? new BBox(\n        this.align(clipBBox.x),\n        this.align(clipBBox.y),\n        this.align(clipBBox.x, clipBBox.width),\n        this.align(clipBBox.y, clipBBox.height)\n      ) : void 0;\n    }\n    if (strokeWidth) {\n      if (w < pixelSize) {\n        const lx = x + pixelSize / 2;\n        borderPath.moveTo(lx, y);\n        borderPath.lineTo(lx, y + h);\n        strokeWidth = pixelSize;\n        this.borderClipPath = void 0;\n      } else if (h < pixelSize) {\n        const ly = y + pixelSize / 2;\n        borderPath.moveTo(x, ly);\n        borderPath.lineTo(x + w, ly);\n        strokeWidth = pixelSize;\n        this.borderClipPath = void 0;\n      } else if (strokeWidth < w && strokeWidth < h) {\n        const halfStrokeWidth = strokeWidth / 2;\n        x += halfStrokeWidth;\n        y += halfStrokeWidth;\n        w -= strokeWidth;\n        h -= strokeWidth;\n        const adjustedClipBBox = clipBBox?.clone().shrink(halfStrokeWidth);\n        const cornerRadii = {\n          topLeft: topLeft > 0 ? topLeft - strokeWidth : 0,\n          topRight: topRight > 0 ? topRight - strokeWidth : 0,\n          bottomRight: bottomRight > 0 ? bottomRight - strokeWidth : 0,\n          bottomLeft: bottomLeft > 0 ? bottomLeft - strokeWidth : 0\n        };\n        this.borderClipPath = void 0;\n        if (w > 0 && h > 0 && (adjustedClipBBox == null || adjustedClipBBox?.width > 0 && adjustedClipBBox?.height > 0)) {\n          insetCornerRadiusRect(path, x, y, w, h, cornerRadii, adjustedClipBBox);\n          insetCornerRadiusRect(borderPath, x, y, w, h, cornerRadii, adjustedClipBBox);\n        }\n      } else {\n        this.borderClipPath = this.borderClipPath ?? new ExtendedPath2D();\n        this.borderClipPath.clear(true);\n        this.borderClipPath.rect(x, y, w, h);\n        borderPath.rect(x, y, w, h);\n      }\n    } else {\n      const cornerRadii = { topLeft, topRight, bottomRight, bottomLeft };\n      this.borderClipPath = void 0;\n      insetCornerRadiusRect(path, x, y, w, h, cornerRadii, clipBBox);\n    }\n    if ([topLeft, topRight, bottomRight, bottomLeft].every((r) => r === 0)) {\n      this.hittester = (hitX, hitY) => {\n        const point = this.transformPoint(hitX, hitY);\n        return this.getBBox().containsPoint(point.x, point.y);\n      };\n      this.distanceSquared = (hitX, hitY) => this.getBBox().distanceSquared(hitX, hitY);\n    } else {\n      this.hittester = super.isPointInPath;\n      this.distanceCalculator = super.distanceSquaredTransformedPoint;\n    }\n    this.effectiveStrokeWidth = strokeWidth;\n    this.lastUpdatePathStrokeWidth = strokeWidth;\n    this.microPixelEffectOpacity = microPixelEffectOpacity;\n  }\n  computeBBox() {\n    const { x, y, width, height, clipBBox } = this;\n    return clipBBox?.clone() ?? new BBox(x, y, width, height);\n  }\n  isPointInPath(x, y) {\n    return this.hittester(x, y);\n  }\n  get midPoint() {\n    return { x: this.x + this.width / 2, y: this.y + this.height / 2 };\n  }\n  distanceSquared(x, y) {\n    return this.distanceCalculator(x, y);\n  }\n  applyFillAlpha(ctx) {\n    const { fillOpacity, microPixelEffectOpacity, opacity } = this;\n    ctx.globalAlpha *= opacity * fillOpacity * microPixelEffectOpacity;\n  }\n  renderStroke(ctx) {\n    const { stroke, effectiveStrokeWidth } = this;\n    if (stroke && effectiveStrokeWidth) {\n      const { globalAlpha } = ctx;\n      const {\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        lineCap,\n        lineJoin,\n        borderPath,\n        borderClipPath,\n        opacity,\n        microPixelEffectOpacity\n      } = this;\n      if (borderClipPath) {\n        ctx.clip(borderClipPath.getPath2D());\n      }\n      ctx.strokeStyle = stroke;\n      ctx.globalAlpha *= opacity * strokeOpacity * microPixelEffectOpacity;\n      ctx.lineWidth = effectiveStrokeWidth;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      ctx.stroke(borderPath.getPath2D());\n      ctx.globalAlpha = globalAlpha;\n    }\n  }\n};\nRect.className = \"Rect\";\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"x\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"y\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"width\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"height\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"topLeftCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"topRightCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"bottomRightCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"bottomLeftCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"clipBBox\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Rect.prototype, \"crisp\", 2);\n\n// packages/ag-charts-community/src/chart/background/background.ts\nvar Background = class extends BaseModuleInstance {\n  constructor(ctx, zIndex = 0 /* SERIES_BACKGROUND_ZINDEX */, layer = false) {\n    super();\n    this.zIndex = zIndex;\n    this.layer = layer;\n    this.rectNode = new Rect();\n    this.textNode = new Text();\n    this.fill = \"white\";\n    this.node = new Group({ name: \"background\", zIndex: this.zIndex, layer: this.layer });\n    this.node.append([this.rectNode, this.textNode]);\n    this.visible = true;\n    this.destroyFns.push(\n      ctx.scene.attachNode(this.node),\n      ctx.layoutService.addListener(\"layout-complete\", (e) => this.onLayoutComplete(e))\n    );\n  }\n  onLayoutComplete(e) {\n    const { width, height } = e.chart;\n    this.rectNode.width = width;\n    this.rectNode.height = height;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN),\n  ProxyPropertyOnWrite(\"node\", \"visible\")\n], Background.prototype, \"visible\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"rectNode\", \"fill\")\n], Background.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], Background.prototype, \"image\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true }),\n  ProxyPropertyOnWrite(\"textNode\")\n], Background.prototype, \"text\", 2);\n\n// packages/ag-charts-community/src/chart/background/backgroundModule.ts\nvar BackgroundModule = {\n  type: \"root\",\n  optionsKey: \"background\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n  moduleFactory: (ctx) => new Background(ctx)\n};\n\n// packages/ag-charts-community/src/scene/spriteRenderer.ts\nvar SpriteRenderer = class {\n  constructor() {\n    this.offscreenCanvas = new OffscreenCanvas(1, 1);\n    const ctx = this.offscreenCanvas.getContext(\"2d\");\n    if (ctx == null)\n      throw new TypeError(`AG Charts - invalid 2d context`);\n    this.renderCtx = {\n      ctx,\n      devicePixelRatio: 1,\n      forceRender: true,\n      resized: false,\n      debugNodes: {}\n    };\n  }\n  resize({ spritePixelRatio, spriteWidth, spriteHeight }) {\n    this.offscreenCanvas.width = Math.max(spriteWidth, 0) * spritePixelRatio;\n    this.offscreenCanvas.height = Math.max(spriteHeight, 0) * spritePixelRatio;\n  }\n  renderSprite(nodes, opts) {\n    nodes = toIterable(nodes);\n    const {\n      renderCtx,\n      renderCtx: { ctx },\n      offscreenCanvas\n    } = this;\n    const { scale: scale2 = 1, translateX = 0, translateY = 0 } = opts ?? {};\n    ctx.resetTransform();\n    ctx.clearRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);\n    ctx.save();\n    ctx.beginPath();\n    ctx.setTransform(scale2, 0, 0, scale2, translateX, translateY);\n    for (const node of nodes) {\n      node.render(renderCtx);\n    }\n    ctx.closePath();\n    ctx.restore();\n    return offscreenCanvas.transferToImageBitmap();\n  }\n};\n\n// packages/ag-charts-community/src/util/keynavUtil.ts\nfunction addRemovableEventListener(destroyFns, button, type, listener) {\n  button.addEventListener(type, listener);\n  destroyFns.push(() => button.removeEventListener(type, listener));\n}\nfunction addEscapeEventListener(destroyFns, elem, onEscape) {\n  addRemovableEventListener(destroyFns, elem, \"keydown\", (event) => {\n    if (event.key === \"Escape\") {\n      onEscape(event);\n    }\n  });\n}\nfunction matchesKey(event, key, ...morekeys) {\n  return !(event.shiftKey || event.altKey || event.ctrlKey || event.metaKey) && (event.key === key || morekeys.some((altkey) => event.key === altkey));\n}\nfunction linkTwoButtons(destroyFns, src, dst, key) {\n  if (!dst)\n    return;\n  addRemovableEventListener(destroyFns, src, \"keydown\", (event) => {\n    if (matchesKey(event, key)) {\n      dst.focus();\n    }\n  });\n}\nfunction linkThreeButtons(destroyFns, curr, next, nextKey, prev, prevKey) {\n  linkTwoButtons(destroyFns, curr, prev, prevKey);\n  linkTwoButtons(destroyFns, curr, next, nextKey);\n  addRemovableEventListener(destroyFns, curr, \"keydown\", (event) => {\n    if (matchesKey(event, nextKey, prevKey)) {\n      event.preventDefault();\n    }\n  });\n}\nvar PREV_NEXT_KEYS = {\n  horizontal: { nextKey: \"ArrowRight\", prevKey: \"ArrowLeft\" },\n  vertical: { nextKey: \"ArrowDown\", prevKey: \"ArrowUp\" }\n};\nfunction initToolbarKeyNav(opts) {\n  const { orientation, toolbar, buttons, onEscape, onFocus, onBlur } = opts;\n  const { nextKey, prevKey } = PREV_NEXT_KEYS[orientation];\n  const ariaHidden = buttons.length === 0;\n  toolbar.role = \"toolbar\";\n  toolbar.ariaOrientation = orientation;\n  toolbar.ariaHidden = ariaHidden.toString();\n  const setTabIndices = (event) => {\n    if (event.target && \"tabIndex\" in event.target) {\n      buttons.forEach((b) => b.tabIndex = -1);\n      event.target.tabIndex = 0;\n    }\n  };\n  const destroyFns = [];\n  for (let i = 0; i < buttons.length; i++) {\n    const prev = buttons[i - 1];\n    const curr = buttons[i];\n    const next = buttons[i + 1];\n    addRemovableEventListener(destroyFns, curr, \"focus\", setTabIndices);\n    if (onFocus)\n      addRemovableEventListener(destroyFns, curr, \"focus\", onFocus);\n    if (onBlur)\n      addRemovableEventListener(destroyFns, curr, \"blur\", onBlur);\n    if (onEscape)\n      addEscapeEventListener(destroyFns, curr, onEscape);\n    linkThreeButtons(destroyFns, curr, prev, prevKey, next, nextKey);\n    curr.tabIndex = i === 0 ? 0 : -1;\n  }\n  return destroyFns;\n}\nfunction initMenuKeyNav(opts) {\n  const { orientation, menu, buttons, onEscape } = opts;\n  const { nextKey, prevKey } = PREV_NEXT_KEYS[orientation];\n  menu.role = \"menu\";\n  menu.ariaOrientation = orientation;\n  const destroyFns = [];\n  for (let i = 0; i < buttons.length; i++) {\n    const prev = buttons[(buttons.length + i - 1) % buttons.length];\n    const curr = buttons[i];\n    const next = buttons[(buttons.length + i + 1) % buttons.length];\n    if (onEscape)\n      addEscapeEventListener(destroyFns, curr, onEscape);\n    linkThreeButtons(destroyFns, curr, prev, prevKey, next, nextKey);\n    curr.tabIndex = -1;\n  }\n  menu.tabIndex = -1;\n  if (onEscape)\n    addEscapeEventListener(destroyFns, menu, onEscape);\n  addRemovableEventListener(destroyFns, menu, \"keydown\", (ev) => {\n    if (ev.target === menu && (ev.key === nextKey || ev.key === prevKey)) {\n      ev.preventDefault();\n      buttons[0]?.focus();\n    }\n  });\n  return destroyFns;\n}\nfunction makeAccessibleClickListener(element2, onclick) {\n  return (event) => {\n    if (element2.ariaDisabled === \"true\") {\n      return event.preventDefault();\n    }\n    onclick(event);\n  };\n}\n\n// packages/ag-charts-community/src/chart/gridLayout.ts\nfunction gridLayout({\n  orientation,\n  bboxes,\n  maxHeight,\n  maxWidth,\n  itemPaddingY = 0,\n  itemPaddingX = 0,\n  forceResult = false\n}) {\n  const horizontal = orientation === \"horizontal\";\n  const primary = {\n    max: horizontal ? maxWidth : maxHeight,\n    fn: horizontal ? (b) => b.width : (b) => b.height,\n    padding: horizontal ? itemPaddingX : itemPaddingY\n  };\n  const secondary = {\n    max: horizontal ? maxHeight : maxWidth,\n    fn: horizontal ? (b) => b.height : (b) => b.width,\n    padding: horizontal ? itemPaddingY : itemPaddingX\n  };\n  let processedBBoxCount = 0;\n  const rawPages = [];\n  while (processedBBoxCount < bboxes.length) {\n    const unprocessedBBoxes = bboxes.slice(processedBBoxCount);\n    const result = processBBoxes(unprocessedBBoxes, processedBBoxCount, primary, secondary, forceResult);\n    if (!result) {\n      return;\n    }\n    processedBBoxCount += result.processedBBoxCount;\n    rawPages.push(result.pageIndices);\n  }\n  return buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX);\n}\nfunction processBBoxes(bboxes, indexOffset, primary, secondary, forceResult) {\n  const minGuess = 1;\n  let startingGuess = estimateStartingGuess(bboxes, primary);\n  if (startingGuess < minGuess) {\n    if (!forceResult) {\n      return;\n    }\n    startingGuess = minGuess;\n  }\n  let guess = startingGuess;\n  while (guess >= minGuess) {\n    const pageIndices = calculatePage(bboxes, indexOffset, guess, primary, secondary, forceResult);\n    if (pageIndices == null && guess <= minGuess) {\n      return;\n    }\n    if (pageIndices == null) {\n      guess--;\n      continue;\n    }\n    if (typeof pageIndices === \"number\") {\n      if (pageIndices <= minGuess) {\n        return;\n      }\n      guess = pageIndices < guess && pageIndices > minGuess ? pageIndices : guess;\n      guess--;\n      continue;\n    }\n    const processedBBoxCount = pageIndices.length * pageIndices[0].length;\n    return { processedBBoxCount, pageIndices };\n  }\n}\nfunction calculatePage(bboxes, indexOffset, primaryCount, primary, secondary, forceResult) {\n  const result = [];\n  let sumSecondary = 0;\n  let currentMaxSecondary = 0;\n  let currentPrimaryIndices = [];\n  const maxPrimaryValues = [];\n  for (let bboxIndex = 0; bboxIndex < bboxes.length; bboxIndex++) {\n    const primaryValueIdx = (bboxIndex + primaryCount) % primaryCount;\n    if (primaryValueIdx === 0) {\n      sumSecondary += currentMaxSecondary;\n      currentMaxSecondary = 0;\n      if (currentPrimaryIndices.length > 0) {\n        result.push(currentPrimaryIndices);\n      }\n      currentPrimaryIndices = [];\n    }\n    const primaryValue = primary.fn(bboxes[bboxIndex]) + primary.padding;\n    maxPrimaryValues[primaryValueIdx] = Math.max(maxPrimaryValues[primaryValueIdx] ?? 0, primaryValue);\n    currentMaxSecondary = Math.max(currentMaxSecondary, secondary.fn(bboxes[bboxIndex]) + secondary.padding);\n    const currentSecondaryDimension = sumSecondary + currentMaxSecondary;\n    const returnResult = !forceResult || result.length > 0;\n    if (currentSecondaryDimension > secondary.max && returnResult) {\n      currentPrimaryIndices = [];\n      break;\n    }\n    const sumPrimary = maxPrimaryValues.reduce((sum2, next) => sum2 + next, 0);\n    if (sumPrimary > primary.max && !forceResult) {\n      if (maxPrimaryValues.length < primaryCount) {\n        return maxPrimaryValues.length;\n      }\n      return;\n    }\n    currentPrimaryIndices.push(bboxIndex + indexOffset);\n  }\n  if (currentPrimaryIndices.length > 0) {\n    result.push(currentPrimaryIndices);\n  }\n  return result.length > 0 ? result : void 0;\n}\nfunction buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX) {\n  let maxPageWidth = 0;\n  let maxPageHeight = 0;\n  const pages = rawPages.map((indices) => {\n    if (orientation === \"horizontal\") {\n      indices = transpose(indices);\n    }\n    let endIndex = 0;\n    const columns = indices.map((colIndices) => {\n      const colBBoxes = colIndices.map((bboxIndex) => {\n        endIndex = Math.max(bboxIndex, endIndex);\n        return bboxes[bboxIndex];\n      });\n      let columnHeight = 0;\n      let columnWidth = 0;\n      colBBoxes.forEach((bbox) => {\n        columnHeight += bbox.height + itemPaddingY;\n        columnWidth = Math.max(columnWidth, bbox.width + itemPaddingX);\n      });\n      return {\n        indices: colIndices,\n        bboxes: colBBoxes,\n        columnHeight: Math.ceil(columnHeight),\n        columnWidth: Math.ceil(columnWidth)\n      };\n    });\n    let pageWidth = 0;\n    let pageHeight = 0;\n    columns.forEach((column) => {\n      pageWidth += column.columnWidth;\n      pageHeight = Math.max(pageHeight, column.columnHeight);\n    });\n    maxPageWidth = Math.max(pageWidth, maxPageWidth);\n    maxPageHeight = Math.max(pageHeight, maxPageHeight);\n    return {\n      columns,\n      startIndex: indices[0][0],\n      endIndex,\n      pageWidth,\n      pageHeight\n    };\n  });\n  return { pages, maxPageWidth, maxPageHeight };\n}\nfunction transpose(data) {\n  const result = [];\n  for (const _ of data[0]) {\n    result.push([]);\n  }\n  data.forEach((innerData, dataIdx) => {\n    innerData.forEach((item, itemIdx) => {\n      result[itemIdx][dataIdx] = item;\n    });\n  });\n  return result;\n}\nfunction estimateStartingGuess(bboxes, primary) {\n  const n = bboxes.length;\n  let primarySum = 0;\n  for (let bboxIndex = 0; bboxIndex < n; bboxIndex++) {\n    primarySum += primary.fn(bboxes[bboxIndex]) + primary.padding;\n    if (primarySum > primary.max) {\n      const ratio2 = n / bboxIndex;\n      if (ratio2 < 2) {\n        return Math.ceil(n / 2);\n      }\n      return bboxIndex;\n    }\n  }\n  return n;\n}\n\n// packages/ag-charts-community/src/scene/image.ts\nvar Image = class extends Node {\n  constructor(sourceImage) {\n    super();\n    this.sourceImage = sourceImage;\n    this.x = 0;\n    this.y = 0;\n    this.width = 0;\n    this.height = 0;\n    this.opacity = 1;\n  }\n  updateBitmap(newBitmap, bitmapPixelRatio, x, y) {\n    this.sourceImage = newBitmap;\n    this.width = newBitmap.width / bitmapPixelRatio;\n    this.height = newBitmap.height / bitmapPixelRatio;\n    this.x = x / bitmapPixelRatio;\n    this.y = y / bitmapPixelRatio;\n    this.markDirty(this, 3 /* MAJOR */);\n  }\n  render(renderCtx) {\n    const { ctx, forceRender, stats } = renderCtx;\n    if (this.dirty === 0 /* NONE */ && !forceRender) {\n      if (stats)\n        stats.nodesSkipped++;\n      return;\n    }\n    const image = this.sourceImage;\n    if (!image)\n      return;\n    this.transformRenderContext(renderCtx);\n    ctx.globalAlpha = this.opacity;\n    ctx.drawImage(image, 0, 0, image.width, image.height, this.x, this.y, this.width, this.height);\n    super.render(renderCtx);\n  }\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"x\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"y\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"width\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"height\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], Image.prototype, \"opacity\", 2);\n\n// packages/ag-charts-community/src/chart/legendMarkerLabel.ts\nvar LegendMarkerLabel = class extends Group {\n  constructor() {\n    super({ name: \"markerLabelGroup\" });\n    this.label = new Text();\n    this.symbolsGroup = new Group({\n      name: \"legend-markerLabel-symbols\"\n    });\n    this.bitmap = new Image();\n    this.bitmapDirty = true;\n    this.enabled = true;\n    this.pageIndex = NaN;\n    this._markers = [];\n    this._lines = [];\n    const { markers, label, lines } = this;\n    label.textBaseline = \"middle\";\n    label.fontSize = 12;\n    label.fontFamily = \"Verdana, sans-serif\";\n    label.fill = \"black\";\n    label.y = 1;\n    this.updateSymbols(markers, lines);\n    this.append(argsIterable(this.symbolsGroup, label));\n  }\n  destroy() {\n    super.destroy();\n    this.proxyButton?.remove();\n  }\n  get markers() {\n    return this._markers;\n  }\n  get lines() {\n    return this._lines;\n  }\n  updateSymbols(markers, lines) {\n    if (arraysEqual(this._markers, markers) && arraysEqual(this._lines, lines))\n      return;\n    this.bitmapDirty = true;\n    this._markers = markers;\n    this._lines = lines;\n    this.symbolsGroup.clear();\n    this.symbolsGroup.append([this.bitmap, ...markers, ...lines]);\n  }\n  setEnabled(enabled) {\n    this.enabled = enabled;\n    this.refreshVisibilities();\n  }\n  refreshVisibilities() {\n    const opacity = this.enabled ? 1 : 0.5;\n    this.label.opacity = opacity;\n    this.opacity = opacity;\n    this.bitmap.opacity = opacity;\n    this.setBitmapVisibility(!this.enabled);\n  }\n  setBitmapVisibility(visible) {\n    const { lines, markers } = this;\n    [lines, markers].forEach((shapes) => shapes.forEach((shape) => shape.visible = !visible));\n    this.bitmap.visible = visible;\n  }\n  // The BBox of this.bitmap is `spritePadding` pixels bigger in each direction than BBox of the markers and lines.\n  // This padding allows the SpriteRenderer to draw antialiasing pixels that can extend beyond the shapes' bounds.\n  update(spriteRenderer, { spriteAAPadding, spritePixelRatio: scale2 }, dimensionProps) {\n    const { markers, lines } = this;\n    let spriteX = 0;\n    let spriteY = 0;\n    let shift = 0;\n    for (let i = 0; i < Math.max(markers.length, lines.length); i++) {\n      const { length: length2, spacing } = dimensionProps[i] ?? 0;\n      const marker = markers[i];\n      const line = lines[i];\n      const size = marker?.size ?? 0;\n      let lineTop = Infinity;\n      let markerTop = Infinity;\n      let markerLeft = Infinity;\n      if (marker) {\n        const center = marker.constructor.center;\n        const radius = (size + marker.strokeWidth) / 2;\n        marker.x = (center.x - 0.5) * size + length2 / 2 + shift;\n        marker.y = (center.y - 0.5) * size;\n        markerTop = marker.y - radius;\n        markerLeft = marker.x - radius;\n      }\n      if (line) {\n        line.x1 = shift;\n        line.x2 = shift + length2;\n        line.y1 = 0;\n        line.y2 = 0;\n        line.markDirtyTransform();\n        lineTop = -line.strokeWidth / 2;\n      }\n      shift += spacing + Math.max(length2, size);\n      spriteX = Math.min(spriteX, line.x1, line.x2, markerLeft);\n      spriteY = Math.min(spriteY, lineTop, markerTop);\n    }\n    const lastSymbolProps = dimensionProps.at(-1);\n    const lastLine = this.lines.at(-1);\n    const lastMarker = this.markers.at(-1);\n    const lineEnd = lastLine ? lastLine.x2 : -Infinity;\n    const markerEnd = (lastMarker?.x ?? 0) + (lastMarker?.size ?? 0) / 2;\n    this.label.x = Math.max(lineEnd, markerEnd) + (lastSymbolProps?.spacing ?? 0);\n    if (this.bitmapDirty) {\n      this.setBitmapVisibility(false);\n      const translateX = (spriteAAPadding + spriteX) * scale2;\n      const translateY = (spriteAAPadding - spriteY) * scale2;\n      const sprite = spriteRenderer.renderSprite(this.symbolsGroup, {\n        scale: scale2,\n        translateX: Math.floor(translateX),\n        translateY: Math.floor(translateY)\n      });\n      this.bitmap.updateBitmap(sprite, scale2, Math.ceil(-translateX), Math.ceil(-translateY));\n      this.bitmapDirty = false;\n      this.refreshVisibilities();\n    }\n    if (dimensionProps.length < 2) {\n      return;\n    }\n    const bbox = this.symbolsGroup.getBBox();\n    const clippedWidth = Math.max(lastMarker?.size ?? 0, lastSymbolProps?.length ?? 0);\n    const clipRect = new BBox(bbox.x + clippedWidth / 2, bbox.y, clippedWidth, bbox.height);\n    this.symbolsGroup.setClipRectInGroupCoordinateSpace(clipRect);\n  }\n  computeBBox() {\n    const { label, lines, markers } = this;\n    return Group.computeBBox(arraysIterable([label], lines, markers), { skipInvisible: false });\n  }\n};\nLegendMarkerLabel.className = \"MarkerLabel\";\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"text\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\")\n], LegendMarkerLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  ProxyPropertyOnWrite(\"label\", \"fill\")\n], LegendMarkerLabel.prototype, \"color\", 2);\n\n// packages/ag-charts-community/src/chart/pagination/pagination.ts\nvar PaginationLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.color = \"black\";\n    this.fontStyle = void 0;\n    this.fontWeight = void 0;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING)\n], PaginationLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], PaginationLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], PaginationLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], PaginationLabel.prototype, \"fontFamily\", 2);\nvar PaginationMarkerStyle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.size = 15;\n    this.fill = void 0;\n    this.fillOpacity = void 0;\n    this.stroke = void 0;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarkerStyle.prototype, \"size\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], PaginationMarkerStyle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], PaginationMarkerStyle.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], PaginationMarkerStyle.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarkerStyle.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PaginationMarkerStyle.prototype, \"strokeOpacity\", 2);\nvar PaginationMarker = class extends BaseProperties {\n  constructor(parent) {\n    super();\n    this.parent = parent;\n    this.shape = Triangle;\n    this.size = 15;\n    this.padding = 8;\n  }\n};\n__decorateClass([\n  ActionOnSet({\n    changeValue() {\n      if (this.parent.marker === this) {\n        this.parent.onMarkerShapeChange();\n      }\n    }\n  })\n], PaginationMarker.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarker.prototype, \"size\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PaginationMarker.prototype, \"padding\", 2);\nvar Pagination = class extends BaseProperties {\n  constructor(chartUpdateCallback, pageUpdateCallback, regionManager, cursorManager) {\n    super();\n    this.chartUpdateCallback = chartUpdateCallback;\n    this.pageUpdateCallback = pageUpdateCallback;\n    this.regionManager = regionManager;\n    this.cursorManager = cursorManager;\n    this.id = createId(this);\n    this.marker = new PaginationMarker(this);\n    this.activeStyle = new PaginationMarkerStyle();\n    this.inactiveStyle = new PaginationMarkerStyle();\n    this.highlightStyle = new PaginationMarkerStyle();\n    this.label = new PaginationLabel();\n    this.group = new Group({ name: \"pagination\" });\n    this.labelNode = new Text();\n    this.destroyFns = [];\n    this.totalPages = 0;\n    this.currentPage = 0;\n    this.translationX = 0;\n    this.translationY = 0;\n    this.nextButtonDisabled = false;\n    this.previousButtonDisabled = false;\n    this._visible = true;\n    this._enabled = true;\n    this._orientation = \"vertical\";\n    this._nextButton = new Triangle();\n    this._previousButton = new Triangle();\n    this.labelNode.setProperties({\n      textBaseline: \"middle\",\n      fontSize: 12,\n      fontFamily: \"Verdana, sans-serif\",\n      fill: \"black\",\n      y: 1\n    });\n    this.group.append([this.nextButton, this.previousButton, this.labelNode]);\n    const region = this.regionManager.addRegion(\"pagination\", this.group);\n    this.destroyFns.push(\n      region.addListener(\"click\", (event) => this.onPaginationClick(event)),\n      region.addListener(\"hover\", (event) => this.onPaginationMouseMove(event))\n    );\n    this.update();\n    this.updateMarkers();\n  }\n  destroy() {\n    this.destroyFns.forEach((f) => f());\n  }\n  set visible(value) {\n    this._visible = value;\n    this.updateGroupVisibility();\n  }\n  get visible() {\n    return this._visible;\n  }\n  set enabled(value) {\n    this._enabled = value;\n    this.updateGroupVisibility();\n  }\n  get enabled() {\n    return this._enabled;\n  }\n  updateGroupVisibility() {\n    this.group.visible = this.enabled && this.visible;\n  }\n  set orientation(value) {\n    this._orientation = value;\n    switch (value) {\n      case \"horizontal\": {\n        this.previousButton.rotation = -Math.PI / 2;\n        this.nextButton.rotation = Math.PI / 2;\n        break;\n      }\n      case \"vertical\":\n      default: {\n        this.previousButton.rotation = 0;\n        this.nextButton.rotation = Math.PI;\n      }\n    }\n  }\n  get orientation() {\n    return this._orientation;\n  }\n  set nextButton(value) {\n    if (this._nextButton !== value) {\n      this.group.removeChild(this._nextButton);\n      this._nextButton = value;\n      this.group.appendChild(value);\n    }\n  }\n  get nextButton() {\n    return this._nextButton;\n  }\n  set previousButton(value) {\n    if (this._previousButton !== value) {\n      this.group.removeChild(this._previousButton);\n      this._previousButton = value;\n      this.group.appendChild(value);\n    }\n  }\n  get previousButton() {\n    return this._previousButton;\n  }\n  update() {\n    this.updateLabel();\n    this.updatePositions();\n    this.enableOrDisableButtons();\n  }\n  updatePositions() {\n    this.group.translationX = this.translationX;\n    this.group.translationY = this.translationY;\n    this.updateLabelPosition();\n    this.updateNextButtonPosition();\n  }\n  updateLabelPosition() {\n    const { size: markerSize, padding: markerPadding } = this.marker;\n    this.nextButton.size = markerSize;\n    this.previousButton.size = markerSize;\n    this.labelNode.x = markerSize / 2 + markerPadding;\n  }\n  updateNextButtonPosition() {\n    const labelBBox = this.labelNode.getBBox();\n    this.nextButton.translationX = labelBBox.x + labelBBox.width + this.marker.size / 2 + this.marker.padding;\n  }\n  updateLabel() {\n    const {\n      currentPage,\n      totalPages: pages,\n      labelNode,\n      label: { color, fontStyle, fontWeight, fontSize, fontFamily }\n    } = this;\n    labelNode.text = `${currentPage + 1} / ${pages}`;\n    labelNode.fill = color;\n    labelNode.fontStyle = fontStyle;\n    labelNode.fontWeight = fontWeight;\n    labelNode.fontSize = fontSize;\n    labelNode.fontFamily = fontFamily;\n  }\n  updateMarkers() {\n    const {\n      nextButton,\n      previousButton,\n      nextButtonDisabled,\n      previousButtonDisabled,\n      activeStyle,\n      inactiveStyle,\n      highlightStyle,\n      highlightActive\n    } = this;\n    const buttonStyle = (button, disabled) => {\n      if (disabled) {\n        return inactiveStyle;\n      } else if (button === highlightActive) {\n        return highlightStyle;\n      }\n      return activeStyle;\n    };\n    this.updateMarker(nextButton, buttonStyle(\"next\", nextButtonDisabled));\n    this.updateMarker(previousButton, buttonStyle(\"previous\", previousButtonDisabled));\n  }\n  updateMarker(marker, style) {\n    const { size } = this.marker;\n    marker.size = size;\n    marker.fill = style.fill;\n    marker.fillOpacity = style.fillOpacity ?? 1;\n    marker.stroke = style.stroke;\n    marker.strokeWidth = style.strokeWidth;\n    marker.strokeOpacity = style.strokeOpacity;\n  }\n  enableOrDisableButtons() {\n    const { currentPage, totalPages } = this;\n    const zeroPagesToDisplay = totalPages === 0;\n    const onLastPage = currentPage === totalPages - 1;\n    const onFirstPage = currentPage === 0;\n    this.nextButtonDisabled = onLastPage || zeroPagesToDisplay;\n    this.previousButtonDisabled = onFirstPage || zeroPagesToDisplay;\n  }\n  nextButtonContainsPoint(offsetX, offsetY) {\n    return !this.nextButtonDisabled && this.nextButton.containsPoint(offsetX, offsetY);\n  }\n  previousButtonContainsPoint(offsetX, offsetY) {\n    return !this.previousButtonDisabled && this.previousButton.containsPoint(offsetX, offsetY);\n  }\n  clickNext() {\n    this.incrementPage();\n    this.onPaginationChanged();\n  }\n  clickPrevious() {\n    this.decrementPage();\n    this.onPaginationChanged();\n  }\n  setPage(pageNumber) {\n    pageNumber = clamp(0, pageNumber, this.totalPages - 1);\n    if (this.currentPage !== pageNumber) {\n      this.currentPage = pageNumber;\n      this.onPaginationChanged();\n    }\n  }\n  onPaginationClick(event) {\n    const { offsetX, offsetY } = event;\n    event.preventDefault();\n    if (this.nextButtonContainsPoint(offsetX, offsetY)) {\n      this.clickNext();\n    } else if (this.previousButtonContainsPoint(offsetX, offsetY)) {\n      this.clickPrevious();\n    }\n  }\n  onPaginationMouseMove(event) {\n    const { offsetX, offsetY } = event;\n    if (this.nextButtonContainsPoint(offsetX, offsetY)) {\n      this.cursorManager.updateCursor(this.id, \"pointer\");\n      this.highlightActive = \"next\";\n    } else if (this.previousButtonContainsPoint(offsetX, offsetY)) {\n      this.cursorManager.updateCursor(this.id, \"pointer\");\n      this.highlightActive = \"previous\";\n    } else {\n      this.cursorManager.updateCursor(this.id);\n      this.highlightActive = void 0;\n    }\n    this.updateMarkers();\n    this.chartUpdateCallback(6 /* SCENE_RENDER */);\n  }\n  onPaginationChanged() {\n    this.pageUpdateCallback(this.currentPage);\n  }\n  incrementPage() {\n    this.currentPage = Math.min(this.currentPage + 1, this.totalPages - 1);\n  }\n  decrementPage() {\n    this.currentPage = Math.max(this.currentPage - 1, 0);\n  }\n  onMarkerShapeChange() {\n    const Marker2 = getMarker(this.marker.shape || Triangle);\n    this.previousButton = new Marker2();\n    this.nextButton = new Marker2();\n    this.updatePositions();\n    this.updateMarkers();\n    this.chartUpdateCallback(6 /* SCENE_RENDER */);\n  }\n  attachPagination(node) {\n    node.append(this.group);\n  }\n  getBBox() {\n    return this.group.getBBox(true);\n  }\n  computeCSSBounds() {\n    const prev = this._previousButton.computeTransformedBBox();\n    const next = this._nextButton.computeTransformedBBox();\n    return { prev, next };\n  }\n};\nPagination.className = \"Pagination\";\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"activeStyle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"inactiveStyle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"highlightStyle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Pagination.prototype, \"label\", 2);\n\n// packages/ag-charts-community/src/chart/legend.ts\nvar LegendLabel = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.maxLength = void 0;\n    this.color = \"black\";\n    this.fontStyle = void 0;\n    this.fontWeight = void 0;\n    this.fontSize = 12;\n    this.fontFamily = \"Verdana, sans-serif\";\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendLabel.prototype, \"maxLength\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], LegendLabel.prototype, \"color\", 2);\n__decorateClass([\n  Validate(FONT_STYLE, { optional: true })\n], LegendLabel.prototype, \"fontStyle\", 2);\n__decorateClass([\n  Validate(FONT_WEIGHT, { optional: true })\n], LegendLabel.prototype, \"fontWeight\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendLabel.prototype, \"fontSize\", 2);\n__decorateClass([\n  Validate(STRING)\n], LegendLabel.prototype, \"fontFamily\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], LegendLabel.prototype, \"formatter\", 2);\nvar LegendMarker = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.size = 15;\n    this.padding = 8;\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => target.parent?.onMarkerShapeChange())\n], LegendMarker.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendMarker.prototype, \"size\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendMarker.prototype, \"padding\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendMarker.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], LegendMarker.prototype, \"enabled\", 2);\nvar LegendLine = class extends BaseProperties {\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendLine.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendLine.prototype, \"length\", 2);\nvar LegendItem = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.paddingX = 16;\n    this.paddingY = 8;\n    this.showSeriesStroke = false;\n    this.marker = new LegendMarker();\n    this.label = new LegendLabel();\n    this.line = new LegendLine();\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LegendItem.prototype, \"maxWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendItem.prototype, \"paddingX\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LegendItem.prototype, \"paddingY\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], LegendItem.prototype, \"showSeriesStroke\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LegendItem.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LegendItem.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LegendItem.prototype, \"line\", 2);\nvar LegendListeners = class extends BaseProperties {\n};\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], LegendListeners.prototype, \"legendItemClick\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], LegendListeners.prototype, \"legendItemDoubleClick\", 2);\nvar ID_LEGEND_VISIBILITY = \"legend-visibility\";\nvar ID_LEGEND_OTHER_SERIES = \"legend-other-series\";\nvar Legend = class extends BaseProperties {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.id = createId(this);\n    this.group = new Group({ name: \"legend\", layer: true, zIndex: 13 /* LEGEND_ZINDEX */ });\n    this.itemSelection = Selection.select(\n      this.group,\n      LegendMarkerLabel\n    );\n    this.spriteRenderer = new SpriteRenderer();\n    this.oldSize = [0, 0];\n    this.pages = [];\n    this.maxPageSize = [0, 0];\n    /** Item index to track on re-pagination, so current page updates appropriately. */\n    this.paginationTrackingIndex = 0;\n    this.truncatedItems = /* @__PURE__ */ new Set();\n    this._data = [];\n    this.toggleSeries = true;\n    this.item = new LegendItem();\n    this.listeners = new LegendListeners();\n    this.enabled = true;\n    this.position = \"bottom\";\n    this.spacing = 20;\n    this.destroyFns = [];\n    this.size = [0, 0];\n    this._visible = true;\n    this.item.marker.parent = this;\n    this.pagination = new Pagination(\n      (type) => ctx.updateService.update(type),\n      (page) => this.updatePageNumber(page),\n      ctx.regionManager,\n      ctx.cursorManager\n    );\n    this.pagination.attachPagination(this.group);\n    ctx.contextMenuRegistry.registerDefaultAction({\n      id: ID_LEGEND_VISIBILITY,\n      type: \"legend\",\n      label: \"contextMenuToggleSeriesVisibility\",\n      action: (params) => this.contextToggleVisibility(params)\n    });\n    ctx.contextMenuRegistry.registerDefaultAction({\n      id: ID_LEGEND_OTHER_SERIES,\n      type: \"legend\",\n      label: \"contextMenuToggleOtherSeries\",\n      action: (params) => this.contextToggleOtherSeries(params)\n    });\n    const { Default: Default2, Animation: Animation2, ContextMenu } = InteractionState;\n    const animationState = Default2 | Animation2;\n    const contextMenuState = Default2 | Animation2 | ContextMenu;\n    const region = ctx.regionManager.addRegion(\"legend\", this.group);\n    this.destroyFns.push(\n      region.addListener(\"contextmenu\", (e) => this.checkContextClick(e), contextMenuState),\n      region.addListener(\"click\", (e) => this.checkLegendClick(e), animationState),\n      region.addListener(\"dblclick\", (e) => this.checkLegendDoubleClick(e), animationState),\n      region.addListener(\"hover\", (e) => this.handleLegendMouseMove(e), animationState),\n      region.addListener(\"leave\", () => this.handleLegendMouseExit(), animationState),\n      region.addListener(\"enter\", (e) => this.handleLegendMouseEnter(e), animationState),\n      ctx.layoutService.addListener(\"start-layout\", (e) => this.positionLegend(e)),\n      ctx.localeManager.addListener(\"locale-changed\", () => this.onLocaleChanged()),\n      () => this.group.parent?.removeChild(this.group)\n    );\n    this.proxyLegendToolbar = this.ctx.proxyInteractionService.createProxyContainer({\n      type: \"toolbar\",\n      id: `${this.id}-toolbar`,\n      classList: [\"ag-charts-proxy-legend-toolbar\"],\n      ariaLabel: { id: \"ariaLabelLegend\" },\n      ariaOrientation: \"horizontal\",\n      ariaHidden: true\n    });\n    this.proxyLegendPagination = this.ctx.proxyInteractionService.createProxyContainer({\n      type: \"group\",\n      id: `${this.id}-pagination`,\n      classList: [\"ag-charts-proxy-legend-pagination\"],\n      ariaLabel: { id: \"ariaLabelLegendPagination\" },\n      ariaOrientation: \"horizontal\",\n      ariaHidden: true\n    });\n  }\n  set data(value) {\n    this._data = value;\n    this.updateGroupVisibility();\n  }\n  get data() {\n    return this._data;\n  }\n  destroy() {\n    this.ctx.domManager.removeChild(\"canvas-overlay\", `${this.id}-toolbar`);\n    this.ctx.domManager.removeChild(\"canvas-overlay\", `${this.id}-pagination`);\n    this.destroyFns.forEach((f) => f());\n    this.pagination.destroy();\n    this.itemSelection.clear();\n  }\n  initLegendItemToolbar() {\n    this.itemSelection.each((markerLabel, _, i) => {\n      markerLabel.proxyButton ?? (markerLabel.proxyButton = this.ctx.proxyInteractionService.createProxyElement({\n        type: \"button\",\n        id: `ag-charts-legend-item-${i}`,\n        textContent: this.getItemAriaText(i),\n        parent: this.proxyLegendToolbar,\n        focusable: markerLabel,\n        // Retrieve the datum from the node rather than from the method parameter.\n        // The method parameter `datum` gets destroyed when the data is refreshed\n        // using Series.getLegendData(). But the scene node will stay the same.\n        onclick: () => {\n          this.doClick(markerLabel.datum);\n          markerLabel.proxyButton.textContent = this.getItemAriaText(i, !markerLabel.datum.enabled);\n        },\n        onblur: () => this.handleLegendMouseExit(),\n        onfocus: () => {\n          const bounds = markerLabel?.computeTransformedBBox();\n          const event = makeKeyboardPointerEvent(this.ctx.focusIndicator, { bounds, showFocusBox: true });\n          this.doHover(event, markerLabel.datum);\n          this.pagination.setPage(markerLabel.pageIndex);\n        }\n      }));\n    });\n    const buttons = this.itemSelection.nodes().map((markerLabel) => markerLabel.proxyButton).filter((button) => !!button);\n    initToolbarKeyNav({\n      orientation: this.getOrientation(),\n      buttons,\n      toolbar: this.proxyLegendToolbar\n    });\n  }\n  onMarkerShapeChange() {\n    this.itemSelection.clear();\n    this.group.markDirty(this.group, 2 /* MINOR */);\n  }\n  getOrientation() {\n    if (this.orientation !== void 0) {\n      return this.orientation;\n    }\n    switch (this.position) {\n      case \"right\":\n      case \"left\":\n        return \"vertical\";\n      case \"bottom\":\n      case \"top\":\n        return \"horizontal\";\n    }\n  }\n  set visible(value) {\n    this._visible = value;\n    this.updateGroupVisibility();\n  }\n  get visible() {\n    return this._visible;\n  }\n  updateGroupVisibility() {\n    this.group.visible = this.enabled && this.visible && this.data.length > 0;\n  }\n  attachLegend(scene) {\n    scene.appendChild(this.group);\n  }\n  getItemLabel(datum) {\n    const {\n      ctx: { callbackCache }\n    } = this;\n    const { formatter } = this.item.label;\n    if (formatter) {\n      return callbackCache.call(formatter, {\n        itemId: datum.itemId,\n        value: datum.label.text,\n        seriesId: datum.seriesId\n      });\n    }\n    return datum.label.text;\n  }\n  /**\n   * The method is given the desired size of the legend, which only serves as a hint.\n   * The vertically oriented legend will take as much horizontal space as needed, but will\n   * respect the height constraints, and the horizontal legend will take as much vertical\n   * space as needed in an attempt not to exceed the given width.\n   * After the layout is done, the {@link size} will contain the actual size of the legend.\n   * If the actual size is not the same as the previous actual size, the legend will fire\n   * the 'layoutChange' event to communicate that another layout is needed, and the above\n   * process should be repeated.\n   * @param width\n   * @param height\n   */\n  calcLayout(width, height) {\n    const {\n      paddingX,\n      paddingY,\n      label,\n      maxWidth,\n      label: { maxLength = Infinity, fontStyle, fontWeight, fontSize, fontFamily }\n    } = this.item;\n    const data = [...this.data];\n    if (this.reverseOrder) {\n      data.reverse();\n    }\n    const proxyToolbarNeedsUpdate = this.itemSelection.nodes().length === 0;\n    this.itemSelection.update(data);\n    if (proxyToolbarNeedsUpdate) {\n      this.initLegendItemToolbar();\n    }\n    const bboxes = [];\n    const font = TextUtils.toFontString(label);\n    const itemMaxWidthPercentage = 0.8;\n    const maxItemWidth = maxWidth ?? width * itemMaxWidthPercentage;\n    const spriteDims = this.calculateSpriteDimensions();\n    this.spriteRenderer.resize(spriteDims);\n    this.itemSelection.each((markerLabel, datum) => {\n      markerLabel.fontStyle = fontStyle;\n      markerLabel.fontWeight = fontWeight;\n      markerLabel.fontSize = fontSize;\n      markerLabel.fontFamily = fontFamily;\n      const paddedSymbolWidth = this.updateMarkerLabel(markerLabel, datum, spriteDims);\n      const id = datum.itemId ?? datum.id;\n      const labelText = this.getItemLabel(datum);\n      const text = (labelText ?? \"<unknown>\").replace(/\\r?\\n/g, \" \");\n      markerLabel.text = this.truncate(text, maxLength, maxItemWidth, paddedSymbolWidth, font, id);\n      bboxes.push(markerLabel.getBBox());\n    });\n    width = Math.max(1, width);\n    height = Math.max(1, height);\n    if (!isFinite(width)) {\n      return {};\n    }\n    const size = this.size;\n    const oldSize = this.oldSize;\n    size[0] = width;\n    size[1] = height;\n    if (size[0] !== oldSize[0] || size[1] !== oldSize[1]) {\n      oldSize[0] = size[0];\n      oldSize[1] = size[1];\n    }\n    const { pages, maxPageHeight, maxPageWidth } = this.updatePagination(bboxes, width, height);\n    const oldPages = this.pages;\n    this.pages = pages;\n    this.maxPageSize = [maxPageWidth - paddingX, maxPageHeight - paddingY];\n    const pageNumber = this.pagination.currentPage;\n    const page = this.pages[pageNumber];\n    if (this.pages.length < 1 || !page) {\n      this.visible = false;\n      return { oldPages };\n    }\n    this.visible = true;\n    this.updatePositions(pageNumber);\n    this.update();\n    return { oldPages };\n  }\n  calcSymbolsEnabled(symbol) {\n    const { showSeriesStroke, marker } = this.item;\n    const markerEnabled = !!marker.enabled || !showSeriesStroke || (symbol.marker.enabled ?? true);\n    const lineEnabled = !!(symbol.line && showSeriesStroke);\n    return { markerEnabled, lineEnabled };\n  }\n  calcSymbolsLengths(symbol) {\n    const { marker, line } = this.item;\n    const { markerEnabled, lineEnabled } = this.calcSymbolsEnabled(symbol);\n    const { strokeWidth: markerStrokeWidth } = this.getMarkerStyles(symbol);\n    const { strokeWidth: lineStrokeWidth } = lineEnabled ? this.getLineStyles(symbol) : { strokeWidth: 0 };\n    const markerLength = markerEnabled ? marker.size : 0;\n    const lineLength = lineEnabled ? line.length ?? 25 : 0;\n    return { markerLength, markerStrokeWidth, lineLength, lineStrokeWidth };\n  }\n  calculateSpriteDimensions() {\n    let spriteAAPadding = 0;\n    let spriteWidth = 0;\n    let spriteHeight = 0;\n    let markerWidth = 0;\n    this.itemSelection.each((_, datum) => {\n      datum.symbols.forEach((symbol) => {\n        const { markerLength, markerStrokeWidth, lineLength, lineStrokeWidth } = this.calcSymbolsLengths(symbol);\n        const markerTotalLength = markerLength + markerStrokeWidth;\n        markerWidth = Math.max(markerWidth, lineLength, markerLength);\n        spriteWidth = Math.max(spriteWidth, lineLength, markerTotalLength);\n        spriteHeight = Math.max(spriteHeight, lineStrokeWidth, markerTotalLength);\n        spriteAAPadding = Math.max(spriteAAPadding, markerStrokeWidth + 0.5);\n      });\n    });\n    spriteWidth += spriteAAPadding * 2;\n    spriteHeight += spriteAAPadding * 2;\n    const spritePixelRatio = getWindow().devicePixelRatio;\n    return { spritePixelRatio, spriteAAPadding, spriteWidth, spriteHeight, markerWidth };\n  }\n  updateMarkerLabel(markerLabel, datum, spriteDims) {\n    const { marker: itemMarker, paddingX } = this.item;\n    const { markerWidth } = spriteDims;\n    const dimensionProps = [];\n    let paddedSymbolWidth = paddingX;\n    if (markerLabel.markers.length !== datum.symbols.length && markerLabel.lines.length !== datum.symbols.length) {\n      const markers = [];\n      const lines = [];\n      datum.symbols.forEach((symbol) => {\n        const { shape: markerShape = symbol.marker.shape } = itemMarker;\n        const MarkerCtr = getMarker(markerShape);\n        lines.push(new Line());\n        markers.push(new MarkerCtr());\n      });\n      markerLabel.updateSymbols(markers, lines);\n    }\n    datum.symbols.forEach((symbol, i) => {\n      const spacing = symbol.marker.padding ?? itemMarker.padding;\n      const { markerEnabled, lineEnabled } = this.calcSymbolsEnabled(symbol);\n      markerLabel.markers[i].size = markerEnabled || !lineEnabled ? itemMarker.size : 0;\n      dimensionProps.push({ length: markerWidth, spacing });\n      if (markerEnabled || lineEnabled) {\n        paddedSymbolWidth += spacing + markerWidth;\n      }\n      const marker = markerLabel.markers[i];\n      const line = markerLabel.lines[i];\n      if (marker) {\n        const { strokeWidth, fill, stroke, fillOpacity, strokeOpacity } = this.getMarkerStyles(symbol);\n        marker.fill = fill;\n        marker.stroke = stroke;\n        marker.strokeWidth = strokeWidth;\n        marker.fillOpacity = fillOpacity;\n        marker.strokeOpacity = strokeOpacity;\n      }\n      if (line) {\n        const lineStyles = this.getLineStyles(symbol);\n        line.stroke = lineStyles.stroke;\n        line.strokeOpacity = lineStyles.strokeOpacity;\n        line.strokeWidth = lineStyles.strokeWidth;\n        line.lineDash = lineStyles.lineDash;\n      }\n    });\n    markerLabel.update(this.spriteRenderer, spriteDims, dimensionProps);\n    return paddedSymbolWidth;\n  }\n  truncate(text, maxCharLength, maxItemWidth, paddedMarkerWidth, font, id) {\n    let addEllipsis = false;\n    if (text.length > maxCharLength) {\n      text = text.substring(0, maxCharLength);\n      addEllipsis = true;\n    }\n    const measurer = CachedTextMeasurerPool.getMeasurer({ font });\n    const result = TextWrapper.truncateLine(text, measurer, maxItemWidth - paddedMarkerWidth, addEllipsis);\n    if (result.endsWith(TextUtils.EllipsisChar)) {\n      this.truncatedItems.add(id);\n    } else {\n      this.truncatedItems.delete(id);\n    }\n    return result;\n  }\n  updatePagination(bboxes, width, height) {\n    const orientation = this.getOrientation();\n    const trackingIndex = Math.min(this.paginationTrackingIndex, bboxes.length);\n    this.pagination.orientation = orientation;\n    this.pagination.translationX = 0;\n    this.pagination.translationY = 0;\n    const { pages, maxPageHeight, maxPageWidth, paginationBBox, paginationVertical } = this.calculatePagination(\n      bboxes,\n      width,\n      height\n    );\n    const newCurrentPage = pages.findIndex((p) => p.endIndex >= trackingIndex);\n    this.pagination.currentPage = clamp(0, newCurrentPage, pages.length - 1);\n    const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;\n    const paginationComponentPadding = 8;\n    const legendItemsWidth = maxPageWidth - itemPaddingX;\n    const legendItemsHeight = maxPageHeight - itemPaddingY;\n    let paginationX = 0;\n    let paginationY = -paginationBBox.y - this.item.marker.size / 2;\n    if (paginationVertical) {\n      paginationY += legendItemsHeight + paginationComponentPadding;\n    } else {\n      paginationX += -paginationBBox.x + legendItemsWidth + paginationComponentPadding;\n      paginationY += (legendItemsHeight - paginationBBox.height) / 2;\n    }\n    this.pagination.translationX = paginationX;\n    this.pagination.translationY = paginationY;\n    this.pagination.update();\n    this.pagination.updateMarkers();\n    let pageIndex = 0;\n    this.itemSelection.each((markerLabel, _, nodeIndex) => {\n      if (nodeIndex > (pages[pageIndex]?.endIndex ?? Infinity)) {\n        pageIndex++;\n      }\n      markerLabel.pageIndex = pageIndex;\n    });\n    return {\n      maxPageHeight,\n      maxPageWidth,\n      pages\n    };\n  }\n  updateItemProxyButtons() {\n    this.itemSelection.each((markerLabel) => {\n      const bbox = markerLabel.computeTransformedBBox()?.clone();\n      bbox.translate(this.group.translationX, this.group.translationY);\n      setElementBBox(markerLabel.proxyButton, bbox);\n    });\n  }\n  updatePaginationProxyButtons(oldPages) {\n    this.proxyLegendPagination.style.display = this.pagination.visible ? \"absolute\" : \"none\";\n    const oldNeedsButtons = (oldPages?.length ?? this.pages.length) > 1;\n    const newNeedsButtons = this.pages.length > 1;\n    if (oldNeedsButtons !== newNeedsButtons) {\n      if (newNeedsButtons) {\n        this.proxyPrevButton = this.ctx.proxyInteractionService.createProxyElement({\n          type: \"button\",\n          id: `${this.id}-prev-page`,\n          textContent: { id: \"ariaLabelLegendPagePrevious\" },\n          tabIndex: 0,\n          parent: this.proxyLegendPagination,\n          focusable: this.pagination.previousButton,\n          onclick: () => this.pagination.clickPrevious()\n        });\n        this.proxyNextButton ?? (this.proxyNextButton = this.ctx.proxyInteractionService.createProxyElement({\n          type: \"button\",\n          id: `${this.id}-next-page`,\n          textContent: { id: \"ariaLabelLegendPageNext\" },\n          tabIndex: 0,\n          parent: this.proxyLegendPagination,\n          focusable: this.pagination.nextButton,\n          onclick: () => this.pagination.clickNext()\n        }));\n      } else {\n        this.proxyNextButton?.remove();\n        this.proxyPrevButton?.remove();\n        [this.proxyNextButton, this.proxyPrevButton] = [void 0, void 0];\n      }\n    }\n    const { prev, next } = this.pagination.computeCSSBounds();\n    setElementBBox(this.proxyPrevButton, prev);\n    setElementBBox(this.proxyNextButton, next);\n  }\n  calculatePagination(bboxes, width, height) {\n    const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;\n    const orientation = this.getOrientation();\n    const paginationVertical = [\"left\", \"right\"].includes(this.position);\n    let paginationBBox = this.pagination.getBBox();\n    let lastPassPaginationBBox = new BBox(0, 0, 0, 0);\n    let pages = [];\n    let maxPageWidth = 0;\n    let maxPageHeight = 0;\n    let count = 0;\n    const stableOutput = (bbox) => {\n      return bbox.width === paginationBBox.width && bbox.height === paginationBBox.height;\n    };\n    const forceResult = this.maxWidth !== void 0 && this.maxHeight !== void 0;\n    do {\n      if (count++ > 10) {\n        Logger.warn(\"unable to find stable legend layout.\");\n        break;\n      }\n      paginationBBox = lastPassPaginationBBox;\n      const maxWidth = width - (paginationVertical ? 0 : paginationBBox.width);\n      const maxHeight = height - (paginationVertical ? paginationBBox.height : 0);\n      const layout = gridLayout({\n        orientation,\n        bboxes,\n        maxHeight,\n        maxWidth,\n        itemPaddingY,\n        itemPaddingX,\n        forceResult\n      });\n      pages = layout?.pages ?? [];\n      maxPageWidth = layout?.maxPageWidth ?? 0;\n      maxPageHeight = layout?.maxPageHeight ?? 0;\n      const totalPages = pages.length;\n      this.pagination.visible = totalPages > 1;\n      this.pagination.totalPages = totalPages;\n      this.pagination.update();\n      lastPassPaginationBBox = this.pagination.getBBox();\n      if (!this.pagination.visible) {\n        break;\n      }\n    } while (!stableOutput(lastPassPaginationBBox));\n    return { maxPageWidth, maxPageHeight, pages, paginationBBox, paginationVertical };\n  }\n  updatePositions(pageNumber = 0) {\n    const {\n      item: { paddingY },\n      itemSelection,\n      pages\n    } = this;\n    if (pages.length < 1 || !pages[pageNumber]) {\n      return;\n    }\n    const { columns, startIndex: visibleStart, endIndex: visibleEnd } = pages[pageNumber];\n    let x = 0;\n    let y = 0;\n    const columnCount = columns.length;\n    const rowCount = columns[0].indices.length;\n    const horizontal = this.getOrientation() === \"horizontal\";\n    const itemHeight = columns[0].bboxes[0].height + paddingY;\n    const rowSumColumnWidths = [];\n    itemSelection.each((markerLabel, _, i) => {\n      if (i < visibleStart || i > visibleEnd) {\n        markerLabel.visible = false;\n        return;\n      }\n      const pageIndex = i - visibleStart;\n      let columnIndex;\n      let rowIndex;\n      if (horizontal) {\n        columnIndex = pageIndex % columnCount;\n        rowIndex = Math.floor(pageIndex / columnCount);\n      } else {\n        columnIndex = Math.floor(pageIndex / rowCount);\n        rowIndex = pageIndex % rowCount;\n      }\n      markerLabel.visible = true;\n      const column = columns[columnIndex];\n      if (!column) {\n        return;\n      }\n      y = Math.floor(itemHeight * rowIndex);\n      x = Math.floor(rowSumColumnWidths[rowIndex] ?? 0);\n      rowSumColumnWidths[rowIndex] = (rowSumColumnWidths[rowIndex] ?? 0) + column.columnWidth;\n      markerLabel.translationX = x;\n      markerLabel.translationY = y;\n    });\n  }\n  updatePageNumber(pageNumber) {\n    const { pages } = this;\n    const { startIndex, endIndex } = pages[pageNumber];\n    if (startIndex === 0) {\n      this.paginationTrackingIndex = 0;\n    } else if (pageNumber === pages.length - 1) {\n      this.paginationTrackingIndex = endIndex;\n    } else {\n      this.paginationTrackingIndex = Math.floor((startIndex + endIndex) / 2);\n    }\n    this.pagination.update();\n    this.pagination.updateMarkers();\n    this.updatePositions(pageNumber);\n    this.ctx.updateService.update(6 /* SCENE_RENDER */);\n  }\n  update() {\n    const {\n      label: { color }\n    } = this.item;\n    this.itemSelection.each((markerLabel, datum) => {\n      markerLabel.setEnabled(datum.enabled);\n      markerLabel.color = color;\n    });\n    this.updateContextMenu();\n  }\n  updateContextMenu() {\n    const { toggleSeries } = this;\n    this.ctx.contextMenuRegistry.setActionVisiblity(ID_LEGEND_VISIBILITY, toggleSeries);\n    this.ctx.contextMenuRegistry.setActionVisiblity(ID_LEGEND_OTHER_SERIES, toggleSeries);\n  }\n  getLineStyles(datum) {\n    const { stroke, strokeOpacity = 1, strokeWidth, lineDash } = datum.line ?? {};\n    const defaultLineStrokeWidth = Math.min(2, strokeWidth ?? 1);\n    return {\n      stroke,\n      strokeOpacity,\n      strokeWidth: this.item.line.strokeWidth ?? defaultLineStrokeWidth,\n      lineDash\n    };\n  }\n  getMarkerStyles(datum) {\n    const { fill, stroke, strokeOpacity = 1, fillOpacity = 1, strokeWidth } = datum.marker;\n    const defaultLineStrokeWidth = Math.min(2, strokeWidth ?? 1);\n    return {\n      fill,\n      stroke,\n      strokeOpacity,\n      fillOpacity,\n      strokeWidth: this.item.marker.strokeWidth ?? defaultLineStrokeWidth\n    };\n  }\n  getDatumForPoint(x, y) {\n    const visibleChildBBoxes = [];\n    const closestLeftTop = { dist: Infinity, datum: void 0 };\n    for (const child of this.group.children) {\n      if (!child.visible)\n        continue;\n      if (!(child instanceof LegendMarkerLabel))\n        continue;\n      const childBBox = child.getBBox().clone();\n      childBBox.grow(this.item.paddingX / 2, \"horizontal\");\n      childBBox.grow(this.item.paddingY / 2, \"vertical\");\n      if (childBBox.containsPoint(x, y)) {\n        return child.datum;\n      }\n      const distX = x - childBBox.x - this.item.paddingX / 2;\n      const distY = y - childBBox.y - this.item.paddingY / 2;\n      const dist = distX ** 2 + distY ** 2;\n      const toTheLeftTop = distX >= 0 && distY >= 0;\n      if (toTheLeftTop && dist < closestLeftTop.dist) {\n        closestLeftTop.dist = dist;\n        closestLeftTop.datum = child.datum;\n      }\n      visibleChildBBoxes.push(childBBox);\n    }\n    const pageBBox = BBox.merge(visibleChildBBoxes);\n    if (!pageBBox.containsPoint(x, y)) {\n      return;\n    }\n    return closestLeftTop.datum;\n  }\n  computePagedBBox() {\n    let actualBBox = this.group.getBBox();\n    if (this.pages.length <= 1) {\n      return actualBBox;\n    }\n    const [maxPageWidth, maxPageHeight] = this.maxPageSize;\n    actualBBox = actualBBox.clone();\n    actualBBox.height = Math.max(maxPageHeight, actualBBox.height);\n    actualBBox.width = Math.max(maxPageWidth, actualBBox.width);\n    return actualBBox;\n  }\n  contextToggleVisibility(params) {\n    const datum = this.data.find((v) => v.itemId === params.itemId);\n    this.doClick(datum);\n  }\n  contextToggleOtherSeries(params) {\n    const datum = this.data.find((v) => v.itemId === params.itemId);\n    this.doDoubleClick(datum);\n  }\n  checkContextClick(event) {\n    const legendItem = this.getDatumForPoint(event.offsetX, event.offsetY);\n    if (this.preventHidingAll && this.contextMenuDatum?.enabled && this.getVisibleItemCount() <= 1) {\n      this.ctx.contextMenuRegistry.disableAction(ID_LEGEND_VISIBILITY);\n    } else {\n      this.ctx.contextMenuRegistry.enableAction(ID_LEGEND_VISIBILITY);\n    }\n    this.ctx.contextMenuRegistry.dispatchContext(\"legend\", event, { legendItem });\n  }\n  checkLegendClick(event) {\n    const datum = this.getDatumForPoint(event.offsetX, event.offsetY);\n    if (this.doClick(datum)) {\n      event.preventDefault();\n    }\n  }\n  getVisibleItemCount() {\n    return this.ctx.chartService.series.flatMap((s) => s.getLegendData(\"category\")).filter((d) => d.enabled).length;\n  }\n  doClick(datum) {\n    const {\n      listeners: { legendItemClick },\n      ctx: { chartService, highlightManager },\n      preventHidingAll,\n      toggleSeries\n    } = this;\n    if (!datum) {\n      return false;\n    }\n    const { id, itemId, enabled } = datum;\n    const series = chartService.series.find((s) => s.id === id);\n    if (!series) {\n      return false;\n    }\n    let newEnabled = enabled;\n    if (toggleSeries) {\n      newEnabled = !enabled;\n      if (preventHidingAll && !newEnabled) {\n        const numVisibleItems = this.getVisibleItemCount();\n        if (numVisibleItems < 2) {\n          newEnabled = true;\n        }\n      }\n      const status = newEnabled ? \"ariaAnnounceVisible\" : \"ariaAnnounceHidden\";\n      this.ctx.ariaAnnouncementService.announceValue(status);\n      this.ctx.chartEventManager.legendItemClick(series, itemId, newEnabled, datum.legendItemName);\n    }\n    if (newEnabled) {\n      highlightManager.updateHighlight(this.id, {\n        series,\n        itemId,\n        datum: void 0\n      });\n    } else {\n      highlightManager.updateHighlight(this.id);\n    }\n    this.ctx.updateService.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true });\n    legendItemClick?.({ type: \"click\", enabled: newEnabled, itemId, seriesId: series.id });\n    return true;\n  }\n  checkLegendDoubleClick(event) {\n    const datum = this.getDatumForPoint(event.offsetX, event.offsetY);\n    if (this.doDoubleClick(datum)) {\n      event.preventDefault();\n    }\n  }\n  doDoubleClick(datum) {\n    const {\n      listeners: { legendItemDoubleClick },\n      ctx: { chartService },\n      toggleSeries\n    } = this;\n    if (chartService.mode === \"integrated\") {\n      return false;\n    }\n    if (!datum) {\n      return false;\n    }\n    const { id, itemId, seriesId } = datum;\n    const series = chartService.series.find((s) => s.id === id);\n    if (!series) {\n      return false;\n    }\n    if (toggleSeries) {\n      const legendData = chartService.series.flatMap((s) => s.getLegendData(\"category\"));\n      const numVisibleItems = legendData.filter((d) => d.enabled).length;\n      const clickedItem = legendData.find((d) => d.itemId === itemId && d.seriesId === seriesId);\n      this.ctx.chartEventManager.legendItemDoubleClick(\n        series,\n        itemId,\n        clickedItem?.enabled ?? false,\n        numVisibleItems,\n        clickedItem?.legendItemName\n      );\n    }\n    this.ctx.updateService.update(2 /* PROCESS_DATA */, { forceNodeDataRefresh: true });\n    legendItemDoubleClick?.({ type: \"dblclick\", enabled: true, itemId, seriesId: series.id });\n    return true;\n  }\n  handleLegendMouseMove(event) {\n    if (!this.enabled) {\n      return;\n    }\n    const { offsetX, offsetY } = event;\n    event.preventDefault();\n    const datum = this.getDatumForPoint(offsetX, offsetY);\n    this.doHover(event, datum);\n  }\n  doHover(event, datum) {\n    const { toggleSeries, listeners } = this;\n    if (event === void 0 || datum === void 0) {\n      this.ctx.cursorManager.updateCursor(this.id);\n      this.updateHighlight();\n      return;\n    }\n    const series = datum ? this.ctx.chartService.series.find((s) => s.id === datum?.id) : void 0;\n    if (datum && this.truncatedItems.has(datum.itemId ?? datum.id)) {\n      const { offsetX, offsetY } = event;\n      this.ctx.tooltipManager.updateTooltip(\n        this.id,\n        { offsetX, offsetY, lastPointerEvent: event, showArrow: false },\n        toTooltipHtml({ content: this.getItemLabel(datum) })\n      );\n    } else {\n      this.ctx.tooltipManager.removeTooltip(this.id);\n    }\n    if (toggleSeries || listeners.legendItemClick != null || listeners.legendItemDoubleClick != null) {\n      this.ctx.cursorManager.updateCursor(this.id, \"pointer\");\n    }\n    if (datum?.enabled && series) {\n      this.updateHighlight({\n        series,\n        itemId: datum?.itemId,\n        datum: void 0\n      });\n    } else {\n      this.updateHighlight();\n    }\n  }\n  handleLegendMouseExit() {\n    this.ctx.cursorManager.updateCursor(this.id);\n    this.ctx.tooltipManager.removeTooltip(this.id);\n    this.updateHighlight();\n  }\n  updateHighlight(datum) {\n    const state = this.ctx.interactionManager.getState();\n    if (state === 16 /* Default */) {\n      this.ctx.highlightManager.updateHighlight(this.id, datum);\n    } else if (state === 1 /* Animation */) {\n      this.pendingHighlightDatum = datum;\n      this.ctx.animationManager.onBatchStop(() => {\n        this.ctx.highlightManager.updateHighlight(this.id, this.pendingHighlightDatum);\n      });\n    }\n  }\n  handleLegendMouseEnter(event) {\n    const {\n      enabled,\n      toggleSeries,\n      listeners: { legendItemClick: clickListener, legendItemDoubleClick: dblclickListener }\n    } = this;\n    const datum = this.getDatumForPoint(event.offsetX, event.offsetY);\n    if (enabled && datum !== void 0 && (toggleSeries || clickListener != null || dblclickListener != null)) {\n      this.ctx.cursorManager.updateCursor(this.id, \"pointer\");\n    }\n  }\n  onLocaleChanged() {\n    this.itemSelection.each(({ proxyButton }, _, i) => {\n      if (proxyButton != null) {\n        proxyButton.textContent = this.getItemAriaText(i);\n      }\n    });\n  }\n  getItemAriaText(nodeIndex, enabled) {\n    const datum = this.data[nodeIndex];\n    const label = datum && this.getItemLabel(datum);\n    enabled ?? (enabled = datum.enabled);\n    const lm = this.ctx.localeManager;\n    if (nodeIndex >= 0 && label) {\n      const index = nodeIndex + 1;\n      const count = this.data.length;\n      const part1 = lm.t(\"ariaLabelLegendItem\", { label, index, count });\n      const part2 = lm.t(enabled ? \"ariaAnnounceVisible\" : \"ariaAnnounceHidden\");\n      return [part1, part2].join(\"\");\n    }\n    return lm.t(\"ariaLabelLegendItemUnknown\");\n  }\n  positionLegend(ctx) {\n    const { shrinkRect } = ctx;\n    const newShrinkRect = shrinkRect.clone();\n    if (!this.enabled || !this.data.length) {\n      return { ...ctx, shrinkRect: newShrinkRect };\n    }\n    const [legendWidth, legendHeight] = this.calculateLegendDimensions(shrinkRect);\n    this.group.translationX = 0;\n    this.group.translationY = 0;\n    const { oldPages } = this.calcLayout(legendWidth, legendHeight);\n    const legendBBox = this.computePagedBBox();\n    const calculateTranslationPerpendicularDimension = () => {\n      switch (this.position) {\n        case \"top\":\n        case \"left\":\n          return 0;\n        case \"bottom\":\n          return shrinkRect.height - legendBBox.height;\n        case \"right\":\n        default:\n          return shrinkRect.width - legendBBox.width;\n      }\n    };\n    if (this.visible) {\n      const legendPadding = this.spacing;\n      let translationX;\n      let translationY;\n      switch (this.position) {\n        case \"top\":\n        case \"bottom\":\n          translationX = (shrinkRect.width - legendBBox.width) / 2;\n          translationY = calculateTranslationPerpendicularDimension();\n          newShrinkRect.shrink(legendBBox.height + legendPadding, this.position);\n          break;\n        case \"left\":\n        case \"right\":\n        default:\n          translationX = calculateTranslationPerpendicularDimension();\n          translationY = (shrinkRect.height - legendBBox.height) / 2;\n          newShrinkRect.shrink(legendBBox.width + legendPadding, this.position);\n      }\n      this.group.translationX = Math.floor(-legendBBox.x + shrinkRect.x + translationX);\n      this.group.translationY = Math.floor(-legendBBox.y + shrinkRect.y + translationY);\n      this.proxyLegendToolbar.style.removeProperty(\"display\");\n      this.proxyLegendToolbar.ariaOrientation = this.getOrientation();\n    } else {\n      this.proxyLegendToolbar.style.display = \"none\";\n    }\n    this.updateItemProxyButtons();\n    this.updatePaginationProxyButtons(oldPages);\n    return { ...ctx, shrinkRect: newShrinkRect };\n  }\n  calculateLegendDimensions(shrinkRect) {\n    const { width, height } = shrinkRect;\n    const aspectRatio = width / height;\n    const maxCoefficient = 0.5;\n    const minHeightCoefficient = 0.2;\n    const minWidthCoefficient = 0.25;\n    let legendWidth, legendHeight;\n    switch (this.position) {\n      case \"top\":\n      case \"bottom\":\n        const heightCoefficient = aspectRatio < 1 ? Math.min(maxCoefficient, minHeightCoefficient * (1 / aspectRatio)) : minHeightCoefficient;\n        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width) : width;\n        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height) : Math.round(height * heightCoefficient);\n        break;\n      case \"left\":\n      case \"right\":\n      default:\n        const widthCoefficient = aspectRatio > 1 ? Math.min(maxCoefficient, minWidthCoefficient * aspectRatio) : minWidthCoefficient;\n        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width) : Math.round(width * widthCoefficient);\n        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height) : height;\n    }\n    return [legendWidth, legendHeight];\n  }\n};\nLegend.className = \"Legend\";\n__decorateClass([\n  Validate(BOOLEAN)\n], Legend.prototype, \"toggleSeries\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Legend.prototype, \"pagination\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Legend.prototype, \"item\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], Legend.prototype, \"listeners\", 2);\n__decorateClass([\n  ObserveChanges((target) => target.updateGroupVisibility()),\n  Validate(BOOLEAN)\n], Legend.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITION)\n], Legend.prototype, \"position\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Legend.prototype, \"maxWidth\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], Legend.prototype, \"maxHeight\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], Legend.prototype, \"reverseOrder\", 2);\n__decorateClass([\n  Validate(UNION([\"horizontal\", \"vertical\"], \"an orientation\"), { optional: true })\n], Legend.prototype, \"orientation\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], Legend.prototype, \"preventHidingAll\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Legend.prototype, \"spacing\", 2);\n\n// packages/ag-charts-community/src/chart/legendModule.ts\nvar CommunityLegendModule = {\n  type: \"legend\",\n  optionsKey: \"legend\",\n  identifier: \"category\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n  moduleFactory: (ctx) => new Legend(ctx),\n  packageType: \"community\"\n};\n\n// packages/ag-charts-community/src/chart/locale/locale.ts\nvar Locale = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.localeText = void 0;\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => {\n    target.ctx.localeManager.setLocaleText(target.localeText);\n  }),\n  Validate(PLAIN_OBJECT, { optional: true })\n], Locale.prototype, \"localeText\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.ctx.localeManager.setLocaleTextFormatter(target.getLocaleText);\n  }),\n  Validate(FUNCTION, { optional: true })\n], Locale.prototype, \"getLocaleText\", 2);\n\n// packages/ag-charts-community/src/chart/locale/localeModule.ts\nvar LocaleModule = {\n  type: \"root\",\n  optionsKey: \"locale\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\", \"polar\", \"hierarchy\", \"topology\", \"flow-proportion\"],\n  moduleFactory: (ctx) => new Locale(ctx)\n};\n\n// packages/ag-charts-community/src/chart/navigator/shapes/rangeHandle.ts\nvar RangeHandle = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.zIndex = 3;\n    this.centerX = 0;\n    this.centerY = 0;\n    this.width = 8;\n    this.height = 16;\n    this.gripLineGap = 2;\n    this.gripLineLength = 8;\n  }\n  setCenter(x, y) {\n    this.dirtyPath = true;\n    this.centerX = x;\n    this.centerY = y;\n  }\n  static align(minHandle, maxHandle, x, y, width, height, min, max) {\n    const handlePixelAlign = minHandle.strokeWidth / 2;\n    const minHandleX = minHandle.align(x + width * min) + handlePixelAlign;\n    const maxHandleX = minHandleX + minHandle.align(x + width * min, width * (max - min)) - 2 * handlePixelAlign;\n    const handleY = minHandle.align(y + height / 2) + handlePixelAlign;\n    minHandle.setCenter(minHandleX, handleY);\n    maxHandle.setCenter(maxHandleX, handleY);\n  }\n  computeBBox() {\n    const { centerX, centerY, width, height } = this;\n    const x = centerX - width / 2;\n    const y = centerY - height / 2;\n    return new BBox(x, y, width, height);\n  }\n  computeTransformedBBox() {\n    return super.computeTransformedBBox();\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    const bbox = this.getBBox();\n    return bbox.containsPoint(point.x, point.y);\n  }\n  updatePath() {\n    const { centerX, centerY, path, strokeWidth, gripLineGap, gripLineLength } = this;\n    const pixelRatio = this.layerManager?.canvas?.pixelRatio ?? 1;\n    path.clear();\n    const halfWidth = Math.floor(this.width / 2 * pixelRatio) / pixelRatio;\n    const halfHeight = Math.floor(this.height / 2 * pixelRatio) / pixelRatio;\n    path.moveTo(centerX - halfWidth, centerY - halfHeight);\n    path.lineTo(centerX + halfWidth, centerY - halfHeight);\n    path.lineTo(centerX + halfWidth, centerY + halfHeight);\n    path.lineTo(centerX - halfWidth, centerY + halfHeight);\n    path.closePath();\n    const dx = Math.floor((gripLineGap + strokeWidth) / 2 * pixelRatio) / pixelRatio;\n    const dy = Math.floor(gripLineLength / 2 * pixelRatio) / pixelRatio;\n    path.moveTo(centerX - dx, centerY - dy);\n    path.lineTo(centerX - dx, centerY + dy);\n    path.moveTo(centerX + dx, centerY - dy);\n    path.lineTo(centerX + dx, centerY + dy);\n  }\n};\nRangeHandle.className = \"RangeHandle\";\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: \"path\" })\n], RangeHandle.prototype, \"width\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: \"path\" })\n], RangeHandle.prototype, \"height\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: \"path\" })\n], RangeHandle.prototype, \"gripLineGap\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */, type: \"path\" })\n], RangeHandle.prototype, \"gripLineLength\", 2);\n\n// packages/ag-charts-community/src/chart/navigator/shapes/rangeMask.ts\nvar RangeMask = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.zIndex = 2;\n    this.x = 0;\n    this.y = 0;\n    this.width = 200;\n    this.height = 30;\n    this.min = 0;\n    this.max = 1;\n  }\n  layout(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.dirtyPath = true;\n  }\n  update(min, max) {\n    this.min = isNaN(min) ? this.min : min;\n    this.max = isNaN(max) ? this.max : max;\n    this.dirtyPath = true;\n  }\n  computeBBox() {\n    const { x, y, width, height } = this;\n    return new BBox(x, y, width, height);\n  }\n  computeVisibleRangeBBox() {\n    const { x, y, width, height, min, max } = this;\n    const minX = x + width * min;\n    const maxX = x + width * max;\n    return new BBox(minX, y, maxX - minX, height);\n  }\n  updatePath() {\n    const { path, x, y, width, height, min, max, strokeWidth } = this;\n    const pixelAlign = strokeWidth / 2;\n    path.clear();\n    const ax = this.align(x) + pixelAlign;\n    const ay = this.align(y) + pixelAlign;\n    const axw = ax + this.align(x, width) - 2 * pixelAlign;\n    const ayh = ay + this.align(y, height) - 2 * pixelAlign;\n    path.moveTo(ax, ay);\n    path.lineTo(axw, ay);\n    path.lineTo(axw, ayh);\n    path.lineTo(ax, ayh);\n    path.closePath();\n    const minX = this.align(x + width * min) + pixelAlign;\n    const maxX = minX + this.align(x + width * min, width * (max - min)) - 2 * pixelAlign;\n    path.moveTo(minX, ay);\n    path.lineTo(minX, ayh);\n    path.lineTo(maxX, ayh);\n    path.lineTo(maxX, ay);\n    path.closePath();\n  }\n};\nRangeMask.className = \"RangeMask\";\n\n// packages/ag-charts-community/src/chart/navigator/shapes/rangeSelector.ts\nvar RangeSelector = class extends Group {\n  constructor(children) {\n    super({ name: \"rangeSelectorGroup\", layer: true, zIndex: 14 /* NAVIGATOR_ZINDEX */ });\n    this.x = 0;\n    this.y = 0;\n    this.width = 200;\n    this.height = 30;\n    this.lOffset = 0;\n    this.rOffset = 0;\n    this.isContainerNode = true;\n    this.background = new Group({ name: \"navigator-background\" });\n    this.background.zIndex = 1;\n    this.appendChild(this.background);\n    this.append(children);\n  }\n  layout(x, y, width, height, lOffset, rOffset) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.lOffset = lOffset;\n    this.rOffset = rOffset;\n    this.background.translationX = x;\n    this.background.translationY = y;\n  }\n  updateBackground(oldGroup, newGroup) {\n    if (oldGroup != null) {\n      this.background.removeChild(oldGroup);\n    }\n    if (newGroup != null) {\n      this.background.appendChild(newGroup);\n    }\n  }\n  computeBBox() {\n    const { x, y, width, height, lOffset, rOffset } = this;\n    return new BBox(x - lOffset, y, width + (lOffset + rOffset), height);\n  }\n};\n\n// packages/ag-charts-community/src/chart/navigator/navigator.ts\nvar Navigator = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.miniChart = void 0;\n    this.enabled = false;\n    this.mask = new RangeMask();\n    this.minHandle = new RangeHandle();\n    this.maxHandle = new RangeHandle();\n    this.maskVisibleRange = {\n      id: \"navigator-mask-visible-range\",\n      getBBox: () => this.mask.computeVisibleRangeBBox(),\n      computeTransformedBBox: () => this.mask.computeVisibleRangeBBox()\n    };\n    this.height = 30;\n    this.spacing = 10;\n    this.x = 0;\n    this.y = 0;\n    this.width = 0;\n    this.rangeSelector = new RangeSelector([this.mask, this.minHandle, this.maxHandle]);\n    this._min = 0;\n    this._max = 1;\n    this.minRange = 1e-3;\n    const region = ctx.regionManager.addRegion(\"navigator\", this.rangeSelector);\n    const dragStates = 16 /* Default */ | 1 /* Animation */ | 8 /* ZoomDrag */;\n    this.destroyFns.push(\n      ctx.scene.attachNode(this.rangeSelector),\n      region.addListener(\"hover\", (event) => this.onHover(event), dragStates),\n      region.addListener(\"drag-start\", (event) => this.onDragStart(event), dragStates),\n      region.addListener(\"drag\", (event) => this.onDrag(event), dragStates),\n      region.addListener(\"drag-end\", () => this.onDragEnd(), dragStates),\n      region.addListener(\"leave\", (event) => this.onLeave(event), dragStates),\n      this.ctx.localeManager.addListener(\"locale-changed\", () => this.updateZoom()),\n      ctx.zoomManager.addListener(\"zoom-change\", (event) => this.onZoomChange(event))\n    );\n    this.proxyNavigatorToolbar = this.ctx.proxyInteractionService.createProxyContainer({\n      type: \"toolbar\",\n      id: `navigator-toolbar`,\n      classList: [\"ag-charts-proxy-navigator-toolbar\"],\n      ariaOrientation: \"vertical\",\n      ariaLabel: { id: \"ariaLabelNavigator\" }\n    });\n    this.updateGroupVisibility();\n    this.proxyNavigatorElements = [\n      this.ctx.proxyInteractionService.createProxyElement({\n        type: \"slider\",\n        id: \"ag-charts-navigator-min\",\n        ariaLabel: { id: \"ariaLabelNavigatorMinimum\" },\n        ariaOrientation: \"horizontal\",\n        parent: this.proxyNavigatorToolbar,\n        focusable: this.minHandle,\n        onchange: (ev) => this.onMinSliderChange(ev)\n      }),\n      this.ctx.proxyInteractionService.createProxyElement({\n        type: \"slider\",\n        id: \"ag-charts-navigator-pan\",\n        ariaLabel: { id: \"ariaLabelNavigatorRange\" },\n        ariaOrientation: \"horizontal\",\n        parent: this.proxyNavigatorToolbar,\n        focusable: this.maskVisibleRange,\n        onchange: (ev) => this.onPanSliderChange(ev)\n      }),\n      this.ctx.proxyInteractionService.createProxyElement({\n        type: \"slider\",\n        id: \"ag-charts-navigator-max\",\n        ariaLabel: { id: \"ariaLabelNavigatorMaximum\" },\n        ariaOrientation: \"horizontal\",\n        parent: this.proxyNavigatorToolbar,\n        focusable: this.maxHandle,\n        onchange: (ev) => this.onMaxSliderChange(ev)\n      })\n    ];\n    initToolbarKeyNav({\n      orientation: \"vertical\",\n      toolbar: this.proxyNavigatorToolbar,\n      buttons: this.proxyNavigatorElements\n    });\n    this.destroyFns.push(() => {\n      this.proxyNavigatorElements.forEach((e) => e.remove());\n      this.proxyNavigatorToolbar.remove();\n    });\n  }\n  updateBackground(oldGroup, newGroup) {\n    this.rangeSelector?.updateBackground(oldGroup, newGroup);\n  }\n  updateGroupVisibility() {\n    const { enabled } = this;\n    if (this.rangeSelector == null || enabled === this.rangeSelector.visible)\n      return;\n    this.rangeSelector.visible = enabled;\n    this.proxyNavigatorToolbar.ariaHidden = (!enabled).toString();\n    if (enabled) {\n      this.updateZoom();\n    } else {\n      this.ctx.zoomManager.updateZoom(\"navigator\");\n    }\n  }\n  async performLayout(ctx) {\n    const { shrinkRect } = ctx;\n    if (this.enabled) {\n      const navigatorTotalHeight = this.height + this.spacing;\n      shrinkRect.shrink(navigatorTotalHeight, \"bottom\");\n      this.y = shrinkRect.y + shrinkRect.height + this.spacing;\n    } else {\n      this.y = 0;\n    }\n    return { ...ctx, shrinkRect };\n  }\n  async performCartesianLayout(opts) {\n    const { x, width } = opts.seriesRect;\n    if (this.enabled) {\n      const { y, height } = this;\n      this.layoutNodes(x, y, width, height);\n      setElementBBox(this.proxyNavigatorToolbar, { x, y, width, height });\n      this.proxyNavigatorToolbar.style.removeProperty(\"display\");\n    } else {\n      this.proxyNavigatorToolbar.style.display = \"none\";\n    }\n    this.x = x;\n    this.width = width;\n  }\n  onHover(event) {\n    if (!this.enabled)\n      return;\n    const { mask, minHandle, maxHandle } = this;\n    const { offsetX, offsetY } = event;\n    if (minHandle.containsPoint(offsetX, offsetY) || maxHandle.containsPoint(offsetX, offsetY)) {\n      this.ctx.cursorManager.updateCursor(\"navigator\", \"ew-resize\");\n    } else if (mask.computeVisibleRangeBBox().containsPoint(offsetX, offsetY)) {\n      this.ctx.cursorManager.updateCursor(\"navigator\", \"grab\");\n    } else {\n      this.ctx.cursorManager.updateCursor(\"navigator\");\n    }\n  }\n  onDragStart(event) {\n    if (!this.enabled)\n      return;\n    const { mask, minHandle, maxHandle, x, width, _min: min } = this;\n    const { offsetX, offsetY } = event;\n    if (minHandle.zIndex < maxHandle.zIndex) {\n      if (maxHandle.containsPoint(offsetX, offsetY)) {\n        this.dragging = \"max\";\n      } else if (minHandle.containsPoint(offsetX, offsetY)) {\n        this.dragging = \"min\";\n      }\n    } else if (minHandle.containsPoint(offsetX, offsetY)) {\n      this.dragging = \"min\";\n    } else if (maxHandle.containsPoint(offsetX, offsetY)) {\n      this.dragging = \"max\";\n    }\n    if (this.dragging == null && mask.computeVisibleRangeBBox().containsPoint(offsetX, offsetY)) {\n      this.dragging = \"pan\";\n      this.panStart = (offsetX - x) / width - min;\n    }\n    if (this.dragging != null) {\n      this.ctx.zoomManager.fireZoomPanStartEvent(\"navigator\");\n    }\n  }\n  onDrag(event) {\n    if (!this.enabled || this.dragging == null)\n      return;\n    const { dragging, minRange, panStart, x, width } = this;\n    let { _min: min, _max: max } = this;\n    const { offsetX } = event;\n    const ratio2 = (offsetX - x) / width;\n    if (dragging === \"min\") {\n      min = clamp(0, ratio2, max - minRange);\n    } else if (dragging === \"max\") {\n      max = clamp(min + minRange, ratio2, 1);\n    } else if (dragging === \"pan\" && panStart != null) {\n      const span = max - min;\n      min = clamp(0, ratio2 - panStart, 1 - span);\n      max = min + span;\n    }\n    this._min = min;\n    this._max = max;\n    this.updateZoom();\n  }\n  onDragEnd() {\n    this.dragging = void 0;\n  }\n  onLeave(_event) {\n    this.ctx.cursorManager.updateCursor(\"navigator\");\n  }\n  onZoomChange(event) {\n    const { x } = event;\n    if (!x)\n      return;\n    this._min = x.min;\n    this._max = x.max;\n    this.updateNodes(x.min, x.max);\n    this.setPanSliderValue(x.min, x.max);\n    this.setSliderRatio(this.proxyNavigatorElements[0], x.min);\n    this.setSliderRatio(this.proxyNavigatorElements[2], x.max);\n  }\n  onPanSliderChange(_event) {\n    const ratio2 = this.getSliderRatio(this.proxyNavigatorElements[1]);\n    const span = this._max - this._min;\n    this._min = clamp(0, ratio2, 1 - span);\n    this._max = this._min + span;\n    this.updateZoom();\n  }\n  onMinSliderChange(_event) {\n    const slider = this.proxyNavigatorElements[0];\n    this._min = this.setSliderRatioClamped(slider, 0, this._max - this.minRange);\n    this.updateZoom();\n  }\n  onMaxSliderChange(_event) {\n    const slider = this.proxyNavigatorElements[2];\n    this._max = this.setSliderRatioClamped(slider, this._min + this.minRange, 1);\n    this.updateZoom();\n  }\n  setPanSliderValue(min, max) {\n    this.proxyNavigatorElements[1].value = `${Math.round(min * 100)}`;\n    this.proxyNavigatorElements[1].ariaValueText = this.ctx.localeManager.t(\"ariaValuePanRange\", { min, max });\n  }\n  setSliderRatioClamped(slider, clampMin, clampMax) {\n    const ratio2 = this.getSliderRatio(slider);\n    const clampedRatio = clamp(clampMin, ratio2, clampMax);\n    if (clampedRatio !== ratio2) {\n      this.setSliderRatio(slider, clampedRatio);\n    }\n    return clampedRatio;\n  }\n  setSliderRatio(slider, ratio2) {\n    const value = Math.round(ratio2 * 100);\n    slider.value = `${value}`;\n    slider.ariaValueText = formatPercentage(value);\n  }\n  getSliderRatio(slider) {\n    return parseFloat(slider.value) / 100;\n  }\n  layoutNodes(x, y, width, height) {\n    const { rangeSelector, mask, minHandle, maxHandle, _min: min, _max: max } = this;\n    rangeSelector.layout(x, y, width, height, minHandle.width / 2, maxHandle.width / 2);\n    mask.layout(x, y, width, height);\n    RangeHandle.align(minHandle, maxHandle, x, y, width, height, min, max);\n    if (min + (max - min) / 2 < 0.5) {\n      minHandle.zIndex = 3;\n      maxHandle.zIndex = 4;\n    } else {\n      minHandle.zIndex = 4;\n      maxHandle.zIndex = 3;\n    }\n    [minHandle, this.maskVisibleRange, maxHandle].forEach((node, index) => {\n      const bbox = node.getBBox();\n      const tbox = { x: bbox.x - x, y: bbox.y - y, height: bbox.height, width: bbox.width };\n      setElementBBox(this.proxyNavigatorElements[index], tbox);\n    });\n  }\n  updateNodes(min, max) {\n    this.mask.update(min, max);\n  }\n  updateZoom() {\n    if (!this.enabled)\n      return;\n    const { _min: min, _max: max } = this;\n    if (min == null || max == null)\n      return;\n    const warnOnConflict = (stateId) => {\n      if (this.min == null && this.max == null)\n        return;\n      Logger.warnOnce(\n        `Could not apply [navigator.min] or [navigator.max] as [${stateId}] has modified the initial zoom state.`\n      );\n    };\n    return this.ctx.zoomManager.updateZoom(\"navigator\", { x: { min, max } }, false, warnOnConflict);\n  }\n};\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], Navigator.prototype, \"miniChart\", 2);\n__decorateClass([\n  Validate(BOOLEAN),\n  ObserveChanges((target) => target.updateGroupVisibility())\n], Navigator.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Navigator.prototype, \"height\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], Navigator.prototype, \"spacing\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(min) {\n      this._min = min;\n      this.updateZoom();\n    }\n  }),\n  Validate(AND(RATIO, LESS_THAN(\"max\")), { optional: true })\n], Navigator.prototype, \"min\", 2);\n__decorateClass([\n  ActionOnSet({\n    newValue(max) {\n      this._max = max;\n      this.updateZoom();\n    }\n  }),\n  Validate(AND(RATIO, GREATER_THAN(\"min\")), { optional: true })\n], Navigator.prototype, \"max\", 2);\n\n// packages/ag-charts-community/src/chart/navigator/navigatorModule.ts\nvar NavigatorModule = {\n  type: \"root\",\n  optionsKey: \"navigator\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  moduleFactory: (ctx) => new Navigator(ctx),\n  themeTemplate: {\n    navigator: {\n      enabled: false,\n      height: 30,\n      mask: {\n        fill: \"#999999\",\n        stroke: \"#999999\",\n        strokeWidth: 1,\n        fillOpacity: 0.2\n      },\n      minHandle: {\n        fill: \"#f2f2f2\",\n        stroke: \"#999999\",\n        strokeWidth: 1,\n        width: 9,\n        height: 16,\n        gripLineGap: 1,\n        gripLineLength: 8\n      },\n      maxHandle: {\n        fill: \"#f2f2f2\",\n        stroke: \"#999999\",\n        strokeWidth: 1,\n        width: 9,\n        height: 16,\n        gripLineGap: 1,\n        gripLineLength: 8\n      }\n    }\n  }\n};\n\n// packages/ag-charts-community/src/module/theme.ts\nfunction singleSeriesPaletteFactory({ takeColors }) {\n  const {\n    fills: [fill],\n    strokes: [stroke]\n  } = takeColors(1);\n  return { fill, stroke };\n}\nfunction markerPaletteFactory(params) {\n  return { marker: singleSeriesPaletteFactory(params) };\n}\n\n// packages/ag-charts-community/src/chart/themes/constants.ts\nvar FONT_SIZE = /* @__PURE__ */ ((FONT_SIZE2) => {\n  FONT_SIZE2[FONT_SIZE2[\"SMALL\"] = 12] = \"SMALL\";\n  FONT_SIZE2[FONT_SIZE2[\"MEDIUM\"] = 13] = \"MEDIUM\";\n  FONT_SIZE2[FONT_SIZE2[\"LARGE\"] = 17] = \"LARGE\";\n  return FONT_SIZE2;\n})(FONT_SIZE || {});\nvar FONT_WEIGHT2 = /* @__PURE__ */ ((FONT_WEIGHT3) => {\n  FONT_WEIGHT3[\"NORMAL\"] = \"normal\";\n  FONT_WEIGHT3[\"BOLD\"] = \"bold\";\n  FONT_WEIGHT3[\"BOLDER\"] = \"bolder\";\n  FONT_WEIGHT3[\"LIGHTER\"] = \"lighter\";\n  return FONT_WEIGHT3;\n})(FONT_WEIGHT2 || {});\nvar POSITION2 = /* @__PURE__ */ ((POSITION3) => {\n  POSITION3[\"TOP\"] = \"top\";\n  POSITION3[\"RIGHT\"] = \"right\";\n  POSITION3[\"BOTTOM\"] = \"bottom\";\n  POSITION3[\"LEFT\"] = \"left\";\n  return POSITION3;\n})(POSITION2 || {});\nvar CARTESIAN_AXIS_TYPE = /* @__PURE__ */ ((CARTESIAN_AXIS_TYPE2) => {\n  CARTESIAN_AXIS_TYPE2[\"CATEGORY\"] = \"category\";\n  CARTESIAN_AXIS_TYPE2[\"ORDINAL_TIME\"] = \"ordinal-time\";\n  CARTESIAN_AXIS_TYPE2[\"NUMBER\"] = \"number\";\n  CARTESIAN_AXIS_TYPE2[\"TIME\"] = \"time\";\n  CARTESIAN_AXIS_TYPE2[\"LOG\"] = \"log\";\n  return CARTESIAN_AXIS_TYPE2;\n})(CARTESIAN_AXIS_TYPE || {});\nvar POLAR_AXIS_TYPE = /* @__PURE__ */ ((POLAR_AXIS_TYPE2) => {\n  POLAR_AXIS_TYPE2[\"ANGLE_CATEGORY\"] = \"angle-category\";\n  POLAR_AXIS_TYPE2[\"ANGLE_NUMBER\"] = \"angle-number\";\n  POLAR_AXIS_TYPE2[\"RADIUS_CATEGORY\"] = \"radius-category\";\n  POLAR_AXIS_TYPE2[\"RADIUS_NUMBER\"] = \"radius-number\";\n  return POLAR_AXIS_TYPE2;\n})(POLAR_AXIS_TYPE || {});\nvar POLAR_AXIS_SHAPE = /* @__PURE__ */ ((POLAR_AXIS_SHAPE2) => {\n  POLAR_AXIS_SHAPE2[\"CIRCLE\"] = \"circle\";\n  POLAR_AXIS_SHAPE2[\"POLYGON\"] = \"polygon\";\n  return POLAR_AXIS_SHAPE2;\n})(POLAR_AXIS_SHAPE || {});\n\n// packages/ag-charts-community/src/chart/themes/symbols.ts\nvar IS_DARK_THEME = Symbol(\"is-dark-theme\");\nvar DEFAULT_FONT_FAMILY = Symbol(\"default-font\");\nvar DEFAULT_LABEL_COLOUR = Symbol(\"default-label-colour\");\nvar DEFAULT_INVERTED_LABEL_COLOUR = Symbol(\"default-inverted-label-colour\");\nvar DEFAULT_INSIDE_SERIES_LABEL_COLOUR = Symbol(\"default-inside-series-label-colour\");\nvar DEFAULT_MUTED_LABEL_COLOUR = Symbol(\"default-muted-label-colour\");\nvar DEFAULT_AXIS_GRID_COLOUR = Symbol(\"default-axis-grid-colour\");\nvar DEFAULT_AXIS_LINE_COLOUR = Symbol(\"default-axis-line-colour\");\nvar DEFAULT_CROSS_LINES_COLOUR = Symbol(\"default-cross-lines-colour\");\nvar DEFAULT_BACKGROUND_COLOUR = Symbol(\"default-background-colour\");\nvar DEFAULT_SHADOW_COLOUR = Symbol(\"default-shadow-colour\");\nvar DEFAULT_COLOURS = Symbol(\"default-colours\");\nvar DEFAULT_PADDING = Symbol(\"default-padding\");\nvar DEFAULT_CAPTION_LAYOUT_STYLE = Symbol(\"default-caption-layout-style\");\nvar DEFAULT_CAPTION_ALIGNMENT = Symbol(\"default-caption-alignment\");\nvar PALETTE_UP_STROKE = Symbol(\"palette-up-stroke\");\nvar PALETTE_DOWN_STROKE = Symbol(\"palette-down-stroke\");\nvar PALETTE_UP_FILL = Symbol(\"palette-up-fill\");\nvar PALETTE_DOWN_FILL = Symbol(\"palette-down-fill\");\nvar PALETTE_NEUTRAL_STROKE = Symbol(\"palette-neutral-stroke\");\nvar PALETTE_NEUTRAL_FILL = Symbol(\"palette-neutral-fill\");\nvar PALETTE_ALT_UP_STROKE = Symbol(\"palette-alt-up-stroke\");\nvar PALETTE_ALT_DOWN_STROKE = Symbol(\"palette-alt-down-stroke\");\nvar PALETTE_ALT_UP_FILL = Symbol(\"palette-alt-up-fill\");\nvar PALETTE_ALT_DOWN_FILL = Symbol(\"palette-alt-down-fill\");\nvar PALETTE_ALT_NEUTRAL_FILL = Symbol(\"palette-gray-fill\");\nvar PALETTE_ALT_NEUTRAL_STROKE = Symbol(\"palette-gray-stroke\");\nvar DEFAULT_POLAR_SERIES_STROKE = Symbol(\"default-polar-series-stroke\");\nvar DEFAULT_DIVERGING_SERIES_COLOUR_RANGE = Symbol(\n  \"default-diverging-series-colour-range\"\n);\nvar DEFAULT_HIERARCHY_FILLS = Symbol(\"default-hierarchy-fills\");\nvar DEFAULT_HIERARCHY_STROKES = Symbol(\"default-hierarchy-strokes\");\nvar DEFAULT_ANNOTATION_COLOR = Symbol(\"default-annotation-stroke\");\nvar DEFAULT_TEXT_ANNOTATION_COLOR = Symbol(\"default-text-annotation-color\");\nvar DEFAULT_ANNOTATION_BACKGROUND_FILL = Symbol(\"default-annotation-background-fill\");\nvar DEFAULT_ANNOTATION_HANDLE_FILL = Symbol(\"default-annotation-handle-fill\");\nvar DEFAULT_TEXTBOX_FILL = Symbol(\"default-textbox-fill\");\nvar DEFAULT_TEXTBOX_STROKE = Symbol(\"default-textbox-stroke\");\nvar DEFAULT_TEXTBOX_COLOR = Symbol(\"default-textbox-color\");\nvar DEFAULT_TOOLBAR_POSITION = Symbol(\"default-toolbar-position\");\nvar DEFAULT_GRIDLINE_ENABLED = Symbol(\"default-gridline-enabled\");\n\n// packages/ag-charts-community/src/motion/pathMotion.ts\nfunction pathMotion(groupId, subId, animationManager, paths, fns) {\n  const { addPhaseFn, updatePhaseFn, removePhaseFn } = fns;\n  const animate = (phase, path, updateFn) => {\n    animationManager.animate({\n      id: `${groupId}_${subId}_${path.id}_${phase}`,\n      groupId,\n      from: 0,\n      to: 1,\n      ease: easeOut,\n      collapsable: false,\n      onUpdate(ratio2, preInit) {\n        if (preInit && phase !== \"removed\")\n          return;\n        path.path.clear(true);\n        updateFn(ratio2, path);\n        path.checkPathDirty();\n      },\n      onStop() {\n        if (phase !== \"added\")\n          return;\n        path.path.clear(true);\n        updateFn(1, path);\n        path.checkPathDirty();\n      },\n      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase]\n    });\n  };\n  for (const path of paths) {\n    if (!animationManager.isSkipped()) {\n      animate(\"removed\", path, removePhaseFn);\n      animate(\"updated\", path, updatePhaseFn);\n    }\n    animate(\"added\", path, addPhaseFn);\n  }\n}\n\n// packages/ag-charts-community/src/util/sanitize.ts\nvar element = null;\nfunction sanitizeHtml(text) {\n  if (text == null) {\n    return;\n  } else if (text === \"\") {\n    return \"\";\n  }\n  element ?? (element = createElement(\"div\"));\n  element.textContent = String(text);\n  return element.innerHTML;\n}\n\n// packages/ag-charts-community/src/chart/series/seriesLabelUtil.ts\nfunction seriesLabelFadeInAnimation({ id }, subId, animationManager, ...labelSelections) {\n  staticFromToMotion(\n    id,\n    subId,\n    animationManager,\n    labelSelections,\n    { opacity: 0 },\n    { opacity: 1 },\n    { phase: \"trailing\" }\n  );\n}\nfunction seriesLabelFadeOutAnimation({ id }, subId, animationManager, ...labelSelections) {\n  staticFromToMotion(\n    id,\n    subId,\n    animationManager,\n    labelSelections,\n    { opacity: 1 },\n    { opacity: 0 },\n    { phase: \"remove\" }\n  );\n}\nfunction resetLabelFn(_node) {\n  return { opacity: 1 };\n}\n\n// packages/ag-charts-community/src/scene/util/changeDetectableProperties.ts\nvar ChangeDetectableProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this._dirty = 3 /* MAJOR */;\n  }\n  markDirty(_source, type = 1 /* TRIVIAL */) {\n    if (this._dirty < type) {\n      this._dirty = type;\n    }\n  }\n  markClean(_opts) {\n    this._dirty = 0 /* NONE */;\n  }\n  isDirty() {\n    return this._dirty > 0 /* NONE */;\n  }\n};\n\n// packages/ag-charts-community/src/scene/dropShadow.ts\nvar DropShadow = class extends ChangeDetectableProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.color = \"rgba(0, 0, 0, 0.5)\";\n    this.xOffset = 0;\n    this.yOffset = 0;\n    this.blur = 5;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(COLOR_STRING),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"color\", 2);\n__decorateClass([\n  Validate(NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"xOffset\", 2);\n__decorateClass([\n  Validate(NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"yOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], DropShadow.prototype, \"blur\", 2);\n\n// packages/ag-charts-community/src/chart/series/seriesMarker.ts\nvar MARKER_SHAPE = predicateWithMessage(\n  (value) => isMarkerShape(value) || typeof value === \"function\" && Object.create(value.prototype) instanceof Marker,\n  `a marker shape keyword such as 'circle', 'diamond' or 'square' or an object extending the Marker class`\n);\nvar SeriesMarker = class extends ChangeDetectableProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.shape = Circle;\n    this.size = 6;\n    this.fillOpacity = 1;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n  }\n  getStyle() {\n    const { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = this;\n    return { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity };\n  }\n  getDiameter() {\n    return this.size + this.strokeWidth;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(MARKER_SHAPE),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"size\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], SeriesMarker.prototype, \"itemStyler\", 2);\n\n// packages/ag-charts-community/src/chart/series/seriesTooltip.ts\nvar SeriesTooltipInteraction = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesTooltipInteraction.prototype, \"enabled\", 2);\nvar SeriesTooltip = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.interaction = new SeriesTooltipInteraction();\n    this.position = new TooltipPosition();\n    this.range = void 0;\n  }\n  toTooltipHtml(defaults, params) {\n    if (this.renderer) {\n      return toTooltipHtml(this.renderer(params), defaults);\n    }\n    return toTooltipHtml(defaults);\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], SeriesTooltip.prototype, \"enabled\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], SeriesTooltip.prototype, \"showArrow\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], SeriesTooltip.prototype, \"renderer\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesTooltip.prototype, \"interaction\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], SeriesTooltip.prototype, \"position\", 2);\n__decorateClass([\n  Validate(INTERACTION_RANGE, { optional: true })\n], SeriesTooltip.prototype, \"range\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/interpolationProperties.ts\nvar INTERPOLATION_TYPE = UNION([\"linear\", \"smooth\", \"step\"], \"a line style\");\nvar INTERPOLATION_STEP_POSITION = UNION([\"start\", \"middle\", \"end\"]);\nvar InterpolationProperties = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.type = \"linear\";\n    this.tension = 1;\n    this.position = \"end\";\n  }\n};\n__decorateClass([\n  Validate(INTERPOLATION_TYPE)\n], InterpolationProperties.prototype, \"type\", 2);\n__decorateClass([\n  Validate(RATIO)\n], InterpolationProperties.prototype, \"tension\", 2);\n__decorateClass([\n  Validate(INTERPOLATION_STEP_POSITION)\n], InterpolationProperties.prototype, \"position\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesProperties.ts\nvar AreaSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.xName = void 0;\n    this.fill = \"#c16068\";\n    this.fillOpacity = 1;\n    this.stroke = \"#874349\";\n    this.strokeWidth = 2;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.interpolation = new InterpolationProperties();\n    this.shadow = new DropShadow();\n    this.marker = new SeriesMarker();\n    this.label = new Label();\n    this.tooltip = new SeriesTooltip();\n    this.connectMissingData = false;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], AreaSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AreaSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING)\n], AreaSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], AreaSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], AreaSeriesProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], AreaSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], AreaSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], AreaSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AreaSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], AreaSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], AreaSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], AreaSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"interpolation\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], AreaSeriesProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], AreaSeriesProperties.prototype, \"connectMissingData\", 2);\n\n// packages/ag-charts-community/src/scene/util/bezier.ts\nfunction evaluateBezier(p0, p1, p2, p3, t) {\n  return (1 - t) ** 3 * p0 + 3 * (1 - t) ** 2 * t * p1 + 3 * (1 - t) + t ** 2 * p2 + t ** 3 * p3;\n}\nfunction solveBezier(p0, p1, p2, p3, value) {\n  if (value <= Math.min(p0, p3)) {\n    return p0 < p3 ? 0 : 1;\n  } else if (value >= Math.max(p0, p3)) {\n    return p0 < p3 ? 1 : 0;\n  }\n  let t0 = 0;\n  let t1 = 1;\n  let t = NaN;\n  for (let i = 0; i < 8; i += 1) {\n    t = (t0 + t1) / 2;\n    const curveValue = (1 - t) ** 3 * p0 + 3 * (1 - t) ** 2 * t * p1 + 3 * (1 - t) * t ** 2 * p2 + t ** 3 * p3;\n    if (curveValue < value) {\n      t0 = t;\n    } else {\n      t1 = t;\n    }\n  }\n  return t;\n}\nfunction splitBezier(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, t) {\n  const x01 = (1 - t) * p0x + t * p1x;\n  const y01 = (1 - t) * p0y + t * p1y;\n  const x12 = (1 - t) * p1x + t * p2x;\n  const y12 = (1 - t) * p1y + t * p2y;\n  const x23 = (1 - t) * p2x + t * p3x;\n  const y23 = (1 - t) * p2y + t * p3y;\n  const x012 = (1 - t) * x01 + t * x12;\n  const y012 = (1 - t) * y01 + t * y12;\n  const x123 = (1 - t) * x12 + t * x23;\n  const y123 = (1 - t) * y12 + t * y23;\n  const x0123 = (1 - t) * x012 + t * x123;\n  const y0123 = (1 - t) * y012 + t * y123;\n  return [\n    [\n      { x: p0x, y: p0y },\n      { x: x01, y: y01 },\n      { x: x012, y: y012 },\n      { x: x0123, y: y0123 }\n    ],\n    [\n      { x: x0123, y: y0123 },\n      { x: x123, y: y123 },\n      { x: x23, y: y23 },\n      { x: p3x, y: p3y }\n    ]\n  ];\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolation.ts\nfunction spanRange(span) {\n  switch (span.type) {\n    case \"linear\":\n    case \"step\":\n      return [\n        { x: span.x0, y: span.y0 },\n        { x: span.x1, y: span.y1 }\n      ];\n    case \"cubic\":\n      return [\n        { x: span.cp0x, y: span.cp0y },\n        { x: span.cp3x, y: span.cp3y }\n      ];\n  }\n}\nfunction reverseSpan(span) {\n  switch (span.type) {\n    case \"linear\":\n      return {\n        type: \"linear\",\n        moveTo: span.moveTo,\n        x0: span.x1,\n        y0: span.y1,\n        x1: span.x0,\n        y1: span.y0\n      };\n    case \"cubic\":\n      return {\n        type: \"cubic\",\n        moveTo: span.moveTo,\n        cp0x: span.cp3x,\n        cp0y: span.cp3y,\n        cp1x: span.cp2x,\n        cp1y: span.cp2y,\n        cp2x: span.cp1x,\n        cp2y: span.cp1y,\n        cp3x: span.cp0x,\n        cp3y: span.cp0y\n      };\n    case \"step\":\n      return {\n        type: \"step\",\n        moveTo: span.moveTo,\n        x0: span.x1,\n        y0: span.y1,\n        x1: span.x0,\n        y1: span.y0,\n        stepX: span.stepX\n      };\n  }\n}\nfunction collapseSpanToPoint(span, point) {\n  const { x, y } = point;\n  switch (span.type) {\n    case \"linear\":\n      return {\n        type: \"linear\",\n        moveTo: span.moveTo,\n        x0: x,\n        y0: y,\n        x1: x,\n        y1: y\n      };\n    case \"step\":\n      return {\n        type: \"step\",\n        moveTo: span.moveTo,\n        x0: x,\n        y0: y,\n        x1: x,\n        y1: y,\n        stepX: x\n      };\n    case \"cubic\":\n      return {\n        type: \"cubic\",\n        moveTo: span.moveTo,\n        cp0x: x,\n        cp0y: y,\n        cp1x: x,\n        cp1y: y,\n        cp2x: x,\n        cp2y: y,\n        cp3x: x,\n        cp3y: y\n      };\n  }\n}\nfunction rescaleSpan(span, nextStart, nextEnd) {\n  const [prevStart, prevEnd] = spanRange(span);\n  const widthScale = prevEnd.x !== prevStart.x ? (nextEnd.x - nextStart.x) / (prevEnd.x - prevStart.x) : 0;\n  const heightScale = prevEnd.y !== prevStart.y ? (nextEnd.y - nextStart.y) / (prevEnd.y - prevStart.y) : 0;\n  switch (span.type) {\n    case \"linear\":\n      return {\n        type: \"linear\",\n        moveTo: span.moveTo,\n        x0: nextStart.x,\n        y0: nextStart.y,\n        x1: nextEnd.x,\n        y1: nextEnd.y\n      };\n    case \"cubic\":\n      return {\n        type: \"cubic\",\n        moveTo: span.moveTo,\n        cp0x: nextStart.x,\n        cp0y: nextStart.y,\n        cp1x: nextEnd.x - (span.cp2x - prevStart.x) * widthScale,\n        cp1y: nextEnd.y - (span.cp2y - prevStart.y) * heightScale,\n        cp2x: nextEnd.x - (span.cp1x - prevStart.x) * widthScale,\n        cp2y: nextEnd.y - (span.cp1y - prevStart.y) * heightScale,\n        cp3x: nextEnd.x,\n        cp3y: nextEnd.y\n      };\n    case \"step\":\n      return {\n        type: \"step\",\n        moveTo: span.moveTo,\n        x0: nextStart.x,\n        y0: nextStart.y,\n        x1: nextEnd.x,\n        y1: nextEnd.y,\n        stepX: nextEnd.x - (span.stepX - prevStart.x) * widthScale\n      };\n  }\n}\nfunction setMoveTo(span, moveTo) {\n  return span.moveTo !== moveTo ? { ...span, moveTo } : span;\n}\nfunction splitSpanAtX(span, x) {\n  const [start, end] = spanRange(span);\n  let x0;\n  let y0;\n  let x1;\n  let y1;\n  if (start.x < end.x) {\n    x0 = start.x;\n    y0 = start.y;\n    x1 = end.x;\n    y1 = end.y;\n  } else {\n    x0 = end.x;\n    y0 = end.y;\n    x1 = start.x;\n    y1 = start.y;\n  }\n  if (x < x0) {\n    return [rescaleSpan(span, start, start), setMoveTo(span, false)];\n  } else if (x > x1) {\n    return [span, setMoveTo(rescaleSpan(span, end, end), false)];\n  }\n  switch (span.type) {\n    case \"linear\": {\n      const midY = y0 === y1 ? y0 : (y1 - y0) / (x1 - x0) * (x - x0) + y0;\n      return [\n        { type: \"linear\", moveTo: span.moveTo, x0, y0, x1: x, y1: midY },\n        { type: \"linear\", moveTo: false, x0: x, y0: midY, x1, y1 }\n      ];\n    }\n    case \"step\":\n      if (x < span.stepX) {\n        return [\n          { type: \"step\", moveTo: span.moveTo, x0, y0, x1: x, y1: y0, stepX: x },\n          { type: \"step\", moveTo: false, x0: x, y0, x1, y1, stepX: span.stepX }\n        ];\n      } else {\n        return [\n          { type: \"step\", moveTo: span.moveTo, x0, y0, x1: x, y1, stepX: span.stepX },\n          { type: \"step\", moveTo: false, x0: x, y0: y1, x1, y1, stepX: x }\n        ];\n      }\n    case \"cubic\": {\n      const t = solveBezier(span.cp0x, span.cp1x, span.cp2x, span.cp3x, x);\n      const [a, b] = splitBezier(\n        span.cp0x,\n        span.cp0y,\n        span.cp1x,\n        span.cp1y,\n        span.cp2x,\n        span.cp2y,\n        span.cp3x,\n        span.cp3y,\n        t\n      );\n      return [\n        {\n          type: \"cubic\",\n          moveTo: span.moveTo,\n          cp0x: a[0].x,\n          cp0y: a[0].y,\n          cp1x: a[1].x,\n          cp1y: a[1].y,\n          cp2x: a[2].x,\n          cp2y: a[2].y,\n          cp3x: a[3].x,\n          cp3y: a[3].y\n        },\n        {\n          type: \"cubic\",\n          moveTo: false,\n          cp0x: b[0].x,\n          cp0y: b[0].y,\n          cp1x: b[1].x,\n          cp1y: b[1].y,\n          cp2x: b[2].x,\n          cp2y: b[2].y,\n          cp3x: b[3].x,\n          cp3y: b[3].y\n        }\n      ];\n    }\n  }\n}\nfunction clipSpanX(span, x0, x1) {\n  const { moveTo } = span;\n  const [start, end] = spanRange(span);\n  let spanX0;\n  let spanY0;\n  let spanX1;\n  let spanY1;\n  if (start.x < end.x) {\n    spanX0 = start.x;\n    spanY0 = start.y;\n    spanX1 = end.x;\n    spanY1 = end.y;\n  } else {\n    spanX0 = end.x;\n    spanY0 = end.y;\n    spanX1 = start.x;\n    spanY1 = start.y;\n  }\n  if (x1 < spanX0) {\n    return rescaleSpan(span, start, start);\n  } else if (x0 > spanX1) {\n    return rescaleSpan(span, end, end);\n  }\n  switch (span.type) {\n    case \"linear\": {\n      const m = spanY0 === spanY1 ? void 0 : (spanY1 - spanY0) / (spanX1 - spanX0);\n      const y0 = m == null ? spanY0 : m * (x0 - spanX0) + spanY0;\n      const y1 = m == null ? spanY0 : m * (x1 - spanX0) + spanY0;\n      return { type: \"linear\", moveTo, x0, y0, x1, y1 };\n    }\n    case \"step\":\n      if (x1 <= span.stepX) {\n        const y = span.y0;\n        return { type: \"step\", moveTo, x0, y0: y, x1, y1: y, stepX: x1 };\n      } else if (x0 >= span.stepX) {\n        const y = span.y1;\n        return { type: \"step\", moveTo, x0, y0: y, x1, y1: y, stepX: x0 };\n      } else {\n        const { y0, y1, stepX } = span;\n        return { type: \"step\", moveTo, x0, y0, x1, y1, stepX };\n      }\n    case \"cubic\": {\n      const t0 = solveBezier(span.cp0x, span.cp1x, span.cp2x, span.cp3x, x0);\n      let [_unused, bezier] = splitBezier(\n        span.cp0x,\n        span.cp0y,\n        span.cp1x,\n        span.cp1y,\n        span.cp2x,\n        span.cp2y,\n        span.cp3x,\n        span.cp3y,\n        t0\n      );\n      const t1 = solveBezier(bezier[0].x, bezier[1].x, bezier[2].x, bezier[3].x, x1);\n      [bezier, _unused] = splitBezier(\n        bezier[0].x,\n        bezier[0].y,\n        bezier[1].x,\n        bezier[1].y,\n        bezier[2].x,\n        bezier[2].y,\n        bezier[3].x,\n        bezier[3].y,\n        t1\n      );\n      return {\n        type: \"cubic\",\n        moveTo,\n        cp0x: bezier[0].x,\n        cp0y: bezier[0].y,\n        cp1x: bezier[1].x,\n        cp1y: bezier[1].y,\n        cp2x: bezier[2].x,\n        cp2y: bezier[2].y,\n        cp3x: bezier[3].x,\n        cp3y: bezier[3].y\n      };\n    }\n  }\n}\nfunction interpolateSpans(a, b, ratio2) {\n  if (a.type === \"cubic\" && b.type === \"cubic\") {\n    return {\n      type: \"cubic\",\n      moveTo: a.moveTo,\n      cp0x: (b.cp0x - a.cp0x) * ratio2 + a.cp0x,\n      cp0y: (b.cp0y - a.cp0y) * ratio2 + a.cp0y,\n      cp1x: (b.cp1x - a.cp1x) * ratio2 + a.cp1x,\n      cp1y: (b.cp1y - a.cp1y) * ratio2 + a.cp1y,\n      cp2x: (b.cp2x - a.cp2x) * ratio2 + a.cp2x,\n      cp2y: (b.cp2y - a.cp2y) * ratio2 + a.cp2y,\n      cp3x: (b.cp3x - a.cp3x) * ratio2 + a.cp3x,\n      cp3y: (b.cp3y - a.cp3y) * ratio2 + a.cp3y\n    };\n  } else if (a.type === \"step\" && b.type === \"step\") {\n    return {\n      type: \"step\",\n      moveTo: a.moveTo,\n      x0: (b.x0 - a.x0) * ratio2 + a.x0,\n      y0: (b.y0 - a.y0) * ratio2 + a.y0,\n      x1: (b.x1 - a.x1) * ratio2 + a.x1,\n      y1: (b.y1 - a.y1) * ratio2 + a.y1,\n      stepX: (b.stepX - a.stepX) * ratio2 + a.stepX\n    };\n  }\n  const [aStart, aEnd] = spanRange(a);\n  const [bStart, bEnd] = spanRange(b);\n  return {\n    type: \"linear\",\n    moveTo: a.moveTo,\n    x0: (bStart.x - aStart.x) * ratio2 + aStart.x,\n    y0: (bStart.y - aStart.y) * ratio2 + aStart.y,\n    x1: (bEnd.x - aEnd.x) * ratio2 + aEnd.x,\n    y1: (bEnd.y - aEnd.y) * ratio2 + aEnd.y\n  };\n}\nfunction plotSpan(path, span, moveTo = span.moveTo ? 1 /* MoveTo */ : 0 /* None */) {\n  const [start] = spanRange(span);\n  switch (moveTo) {\n    case 1 /* MoveTo */:\n      path.moveTo(start.x, start.y);\n      break;\n    case 2 /* LineTo */:\n      path.lineTo(start.x, start.y);\n      break;\n  }\n  switch (span.type) {\n    case \"linear\":\n      path.lineTo(span.x1, span.y1);\n      break;\n    case \"cubic\":\n      path.cubicCurveTo(span.cp1x, span.cp1y, span.cp2x, span.cp2y, span.cp3x, span.cp3y);\n      break;\n    case \"step\":\n      path.lineTo(span.stepX, span.y0);\n      path.lineTo(span.stepX, span.y1);\n      path.lineTo(span.x1, span.y1);\n      break;\n  }\n}\nfunction linearPoints(points) {\n  const spans = [];\n  let i = 0;\n  let x0 = NaN;\n  let y0 = NaN;\n  for (const { x: x1, y: y1 } of points) {\n    if (i > 0) {\n      const moveTo = i === 1;\n      spans.push({ type: \"linear\", moveTo, x0, y0, x1, y1 });\n    }\n    i += 1;\n    x0 = x1;\n    y0 = y1;\n  }\n  return spans;\n}\nvar lineSteps = {\n  start: 0,\n  middle: 0.5,\n  end: 1\n};\nfunction stepPoints(points, position) {\n  const spans = [];\n  let i = 0;\n  let x0 = NaN;\n  let y0 = NaN;\n  const p0 = typeof position === \"number\" ? position : lineSteps[position];\n  for (const { x: x1, y: y1 } of points) {\n    if (i > 0) {\n      const moveTo = i === 1;\n      const stepX = x0 + (x1 - x0) * p0;\n      spans.push({ type: \"step\", moveTo, x0, y0, x1, y1, stepX });\n    }\n    i += 1;\n    x0 = x1;\n    y0 = y1;\n  }\n  return spans;\n}\nvar flatnessRatio = 0.05;\nfunction smoothPoints(iPoints, tension) {\n  const points = Array.isArray(iPoints) ? iPoints : Array.from(iPoints);\n  if (points.length <= 1)\n    return [];\n  const gradients = points.map((c, i) => {\n    const p = i === 0 ? c : points[i - 1];\n    const n = i === points.length - 1 ? c : points[i + 1];\n    const isTerminalPoint = i === 0 || i === points.length - 1;\n    if (Math.sign(p.y - c.y) === Math.sign(n.y - c.y)) {\n      return 0;\n    }\n    if (!isTerminalPoint) {\n      const range3 = Math.abs(p.y - n.y);\n      const prevRatio = Math.abs(c.y - p.y) / range3;\n      const nextRatio = Math.abs(c.y - n.y) / range3;\n      if (prevRatio <= flatnessRatio || 1 - prevRatio <= flatnessRatio || nextRatio <= flatnessRatio || 1 - nextRatio <= flatnessRatio) {\n        return 0;\n      }\n    }\n    return (n.y - p.y) / (n.x - p.x);\n  });\n  if (gradients[1] === 0) {\n    gradients[0] *= 2;\n  }\n  if (gradients[gradients.length - 2] === 0) {\n    gradients[gradients.length - 1] *= 2;\n  }\n  const spans = [];\n  for (let i = 1; i < points.length; i += 1) {\n    const prev = points[i - 1];\n    const prevM = gradients[i - 1];\n    const cur = points[i];\n    const curM = gradients[i];\n    const dx = cur.x - prev.x;\n    const dy = cur.y - prev.y;\n    let dcp1x = dx * tension / 3;\n    let dcp1y = dx * prevM * tension / 3;\n    let dcp2x = dx * tension / 3;\n    let dcp2y = dx * curM * tension / 3;\n    if (curM === 0 && Math.abs(dcp1y) > Math.abs(dy)) {\n      dcp1x *= Math.abs(dy / dcp1y);\n      dcp1y = Math.sign(dcp1y) * Math.abs(dy);\n    }\n    if (prevM === 0 && Math.abs(dcp2y) > Math.abs(dy)) {\n      dcp2x *= Math.abs(dy / dcp2y);\n      dcp2y = Math.sign(dcp2y) * Math.abs(dy);\n    }\n    spans.push({\n      type: \"cubic\",\n      moveTo: i === 1,\n      cp0x: prev.x,\n      cp0y: prev.y,\n      cp1x: prev.x + dcp1x,\n      cp1y: prev.y + dcp1y,\n      cp2x: cur.x - dcp2x,\n      cp2y: cur.y - dcp2y,\n      cp3x: cur.x,\n      cp3y: cur.y\n    });\n  }\n  return spans;\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/markerUtil.ts\nfunction markerFadeInAnimation({ id }, animationManager, status, ...markerSelections) {\n  const params = { phase: status ? NODE_UPDATE_STATE_TO_PHASE_MAPPING[status] : \"trailing\" };\n  staticFromToMotion(id, \"markers\", animationManager, markerSelections, { opacity: 0 }, { opacity: 1 }, params);\n  markerSelections.forEach((s) => s.cleanup());\n}\nfunction markerScaleInAnimation({ id }, animationManager, ...markerSelections) {\n  staticFromToMotion(\n    id,\n    \"markers\",\n    animationManager,\n    markerSelections,\n    { scalingX: 0, scalingY: 0 },\n    { scalingX: 1, scalingY: 1 },\n    { phase: \"initial\" }\n  );\n  markerSelections.forEach((s) => s.cleanup());\n}\nfunction markerSwipeScaleInAnimation({ id, nodeDataDependencies }, animationManager, ...markerSelections) {\n  const seriesWidth = nodeDataDependencies.seriesRectWidth;\n  const fromFn = (_, datum) => {\n    const x = datum.midPoint?.x ?? seriesWidth;\n    let delay = clamp(0, inverseEaseOut(x / seriesWidth), 1);\n    if (isNaN(delay)) {\n      delay = 0;\n    }\n    return { scalingX: 0, scalingY: 0, delay, duration: QUICK_TRANSITION, phase: \"initial\" };\n  };\n  const toFn = () => {\n    return { scalingX: 1, scalingY: 1 };\n  };\n  fromToMotion(id, \"markers\", animationManager, markerSelections, { fromFn, toFn });\n}\nfunction resetMarkerFn(_node) {\n  return { opacity: 1, scalingX: 1, scalingY: 1 };\n}\nfunction resetMarkerPositionFn(_node, datum) {\n  return {\n    translationX: datum.point?.x ?? NaN,\n    translationY: datum.point?.y ?? NaN\n  };\n}\nfunction prepareMarkerAnimation(pairMap, parentStatus) {\n  const readFirstPair = (xValue, type) => {\n    const val = pairMap[type][xValue];\n    return Array.isArray(val) ? val[0] : val;\n  };\n  const markerStatus = (datum) => {\n    const { xValue } = datum;\n    if (pairMap.moved[xValue]) {\n      return { point: readFirstPair(xValue, \"moved\"), status: \"updated\" };\n    } else if (pairMap.removed[xValue]) {\n      return { point: readFirstPair(xValue, \"removed\"), status: \"removed\" };\n    } else if (pairMap.added[xValue]) {\n      return { point: readFirstPair(xValue, \"added\"), status: \"added\" };\n    }\n    return { status: \"unknown\" };\n  };\n  const fromFn = (marker, datum) => {\n    const { status, point } = markerStatus(datum);\n    if (status === \"unknown\")\n      return { opacity: 0 };\n    const defaults = {\n      translationX: point?.from?.x ?? marker.translationX,\n      translationY: point?.from?.y ?? marker.translationY,\n      opacity: marker.opacity,\n      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]\n    };\n    if (parentStatus === \"added\") {\n      return {\n        ...defaults,\n        opacity: 0,\n        translationX: point?.to?.x,\n        translationY: point?.to?.y,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"added\"]\n      };\n    }\n    if (status === \"added\") {\n      defaults.opacity = 0;\n    }\n    return defaults;\n  };\n  const toFn = (_marker, datum) => {\n    const { status, point } = markerStatus(datum);\n    if (status === \"unknown\")\n      return { opacity: 0 };\n    const defaults = {\n      translationX: datum.point.x,\n      translationY: datum.point.y,\n      opacity: 1,\n      phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[status]\n    };\n    if (status === \"removed\" || parentStatus === \"removed\") {\n      return {\n        ...defaults,\n        translationX: point?.to?.x,\n        translationY: point?.to?.y,\n        opacity: 0,\n        phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[\"removed\"]\n      };\n    }\n    return defaults;\n  };\n  return { fromFn, toFn };\n}\nfunction computeMarkerFocusBounds(series, { datumIndex }) {\n  const nodeData = series.getNodeData();\n  if (nodeData === void 0)\n    return void 0;\n  const datum = nodeData[datumIndex];\n  if (datum === void 0 || datum.point === void 0)\n    return void 0;\n  const size = series.getFormattedMarkerStyle(datum).size;\n  const radius = size / 2;\n  const { x, y } = series.contentGroup.inverseTransformPoint(datum.point.x - radius, datum.point.y - radius);\n  return new BBox(x, y, size, size);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/linePlotter.ts\nfunction plotLinearPoints(path, points, continuePath) {\n  let didMove = continuePath;\n  for (const { x, y } of points) {\n    if (didMove) {\n      path.lineTo(x, y);\n    } else {\n      path.moveTo(x, y);\n      didMove = true;\n    }\n  }\n}\nvar flatnessRatio2 = 0.05;\nfunction plotSmoothPoints(path, iPoints, tension, continuePath) {\n  const points = Array.isArray(iPoints) ? iPoints : Array.from(iPoints);\n  if (points.length === 0)\n    return;\n  if (continuePath) {\n    path.lineTo(points[0].x, points[0].y);\n  } else {\n    path.moveTo(points[0].x, points[0].y);\n  }\n  if (points.length <= 1)\n    return;\n  const gradients = points.map((c, i) => {\n    const p = i === 0 ? c : points[i - 1];\n    const n = i === points.length - 1 ? c : points[i + 1];\n    const isTerminalPoint = i === 0 || i === points.length - 1;\n    if (Math.sign(p.y - c.y) === Math.sign(n.y - c.y)) {\n      return 0;\n    }\n    if (!isTerminalPoint) {\n      const range3 = Math.abs(p.y - n.y);\n      const prevRatio = Math.abs(c.y - p.y) / range3;\n      const nextRatio = Math.abs(c.y - n.y) / range3;\n      if (prevRatio <= flatnessRatio2 || 1 - prevRatio <= flatnessRatio2 || nextRatio <= flatnessRatio2 || 1 - nextRatio <= flatnessRatio2) {\n        return 0;\n      }\n    }\n    return (n.y - p.y) / (n.x - p.x);\n  });\n  if (gradients[1] === 0) {\n    gradients[0] *= 2;\n  }\n  if (gradients[gradients.length - 2] === 0) {\n    gradients[gradients.length - 1] *= 2;\n  }\n  for (let i = 1; i < points.length; i += 1) {\n    const prev = points[i - 1];\n    const prevM = gradients[i - 1];\n    const cur = points[i];\n    const curM = gradients[i];\n    const dx = cur.x - prev.x;\n    const dy = cur.y - prev.y;\n    let dcp1x = dx * tension / 3;\n    let dcp1y = dx * prevM * tension / 3;\n    let dcp2x = dx * tension / 3;\n    let dcp2y = dx * curM * tension / 3;\n    if (curM === 0 && Math.abs(dcp1y) > Math.abs(dy)) {\n      dcp1x *= Math.abs(dy / dcp1y);\n      dcp1y = Math.sign(dcp1y) * Math.abs(dy);\n    }\n    if (prevM === 0 && Math.abs(dcp2y) > Math.abs(dy)) {\n      dcp2x *= Math.abs(dy / dcp2y);\n      dcp2y = Math.sign(dcp2y) * Math.abs(dy);\n    }\n    path.cubicCurveTo(prev.x + dcp1x, prev.y + dcp1y, cur.x - dcp2x, cur.y - dcp2y, cur.x, cur.y);\n  }\n}\nfunction plotStepPoints(path, points, align, continuePath) {\n  let lastPoint;\n  for (const point of points) {\n    if (lastPoint != null) {\n      const directionalAlign = lastPoint.x < point.x ? align : 1 - align;\n      const x = (point.x - lastPoint.x) * directionalAlign + lastPoint.x;\n      path.lineTo(x, lastPoint?.y ?? point.y);\n      path.lineTo(x, point.y);\n      path.lineTo(point.x, point.y);\n    } else if (continuePath) {\n      path.lineTo(point.x, point.y);\n    } else {\n      path.moveTo(point.x, point.y);\n    }\n    lastPoint = point;\n  }\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/pathUtil.ts\nfunction minMax(nodeData) {\n  return nodeData.reduce(\n    ({ min, max }, node) => {\n      if (min == null || min.point.x > node.point.x) {\n        min = node;\n      }\n      if (max == null || max.point.x < node.point.x) {\n        max = node;\n      }\n      return { min, max };\n    },\n    {}\n  );\n}\nfunction intersectionOnLine(a, b, targetX) {\n  const m = (b.y - a.y) / (b.x - a.x);\n  const y = (targetX - a.x) * m + a.y;\n  return { x: targetX, y };\n}\nfunction backfillPathPoint(results, process, skip, processFn) {\n  let prevMarkerIdx = -1, nextMarkerIdx = 0;\n  const toProcess = [];\n  while (nextMarkerIdx < results.length) {\n    if (results[nextMarkerIdx].change === process) {\n      toProcess.push(results[nextMarkerIdx]);\n      nextMarkerIdx++;\n      continue;\n    }\n    if (results[nextMarkerIdx].change === skip) {\n      nextMarkerIdx++;\n      continue;\n    }\n    if (toProcess.length > 0) {\n      processFn(toProcess, prevMarkerIdx, nextMarkerIdx);\n      toProcess.length = 0;\n    }\n    prevMarkerIdx = nextMarkerIdx;\n    nextMarkerIdx++;\n  }\n  if (toProcess.length > 0) {\n    processFn(toProcess, prevMarkerIdx, nextMarkerIdx);\n  }\n}\nfunction backfillPathPointData(result, splitMode) {\n  backfillPathPoint(result, \"out\", \"in\", (toProcess, sIdx, eIdx) => {\n    if (sIdx === -1 && result[eIdx]) {\n      toProcess.forEach((d) => d.to = result[eIdx].from);\n    } else if (eIdx === result.length && result[sIdx]) {\n      toProcess.forEach((d) => d.to = result[sIdx].from);\n    } else if (splitMode === \"intersect\" && result[sIdx]?.from && result[eIdx]?.from) {\n      toProcess.forEach((d) => d.to = intersectionOnLine(result[sIdx].from, result[eIdx].from, d.from.x));\n    } else {\n      toProcess.forEach((d) => d.to = d.from);\n    }\n  });\n  backfillPathPoint(result, \"in\", \"out\", (toProcess, sIdx, eIdx) => {\n    if (sIdx === -1 && result[eIdx]) {\n      toProcess.forEach((d) => d.from = result[eIdx].to);\n    } else if (eIdx === result.length && result[sIdx]) {\n      toProcess.forEach((d) => d.from = result[sIdx].to);\n    } else if (splitMode === \"intersect\" && result[sIdx]?.to && result[eIdx]?.to) {\n      toProcess.forEach((d) => d.from = intersectionOnLine(result[sIdx].to, result[eIdx].to, d.to.x));\n    } else {\n      toProcess.forEach((d) => d.from = d.to);\n    }\n  });\n}\nfunction calculatePoint(from2, to, ratio2) {\n  const x1 = isNaN(from2.x) ? to.x : from2.x;\n  const y1 = isNaN(from2.y) ? to.y : from2.y;\n  const xd = to.x - from2.x;\n  const yd = to.y - from2.y;\n  const xr = isNaN(xd) ? 0 : xd * ratio2;\n  const yr = isNaN(yd) ? 0 : yd * ratio2;\n  return {\n    x: x1 + xr,\n    y: y1 + yr\n  };\n}\nvar lineSteps2 = {\n  start: 0,\n  middle: 0.5,\n  end: 1\n};\nfunction plotPath(points, path, interpolation, continuePath = false) {\n  const { path: linePath } = path;\n  if (interpolation?.type === \"smooth\") {\n    plotSmoothPoints(linePath, points, interpolation.tension ?? 1, continuePath);\n  } else if (interpolation?.type === \"step\") {\n    plotStepPoints(linePath, points, lineSteps2[interpolation.position ?? \"end\"], continuePath);\n  } else {\n    plotLinearPoints(linePath, points, continuePath);\n  }\n}\nfunction splitPairData(pairData, ratios) {\n  let previousTo;\n  let points = void 0;\n  const out = [];\n  const flushCurrent = () => {\n    if (points != null) {\n      out.push(points);\n      points = void 0;\n    }\n  };\n  for (const data of pairData) {\n    const { from: from2, to } = data;\n    const ratio2 = ratios[data.change];\n    if (ratio2 == null || from2 == null || to == null)\n      continue;\n    const point = calculatePoint(from2, to, ratio2);\n    if (data.moveTo === false) {\n      points ?? (points = []);\n      points.push(point);\n    } else if (data.moveTo === true || !previousTo) {\n      flushCurrent();\n      points = [point];\n    } else if (previousTo) {\n      const moveToRatio = data.moveTo === \"in\" ? ratio2 : 1 - ratio2;\n      const { x: midPointX, y: midPointY } = calculatePoint(previousTo, point, moveToRatio);\n      points ?? (points = []);\n      points.push({ x: midPointX, y: midPointY });\n      flushCurrent();\n      points = [point];\n    }\n    previousTo = point;\n  }\n  flushCurrent();\n  return out;\n}\nfunction renderPartialPath(pairData, ratios, path, interpolation) {\n  splitPairData(pairData, ratios).forEach((points) => {\n    plotPath(points, path, interpolation);\n  });\n}\nfunction pathSwipeInAnimation({ id, visible, nodeDataDependencies }, animationManager, ...paths) {\n  const { seriesRectWidth: width, seriesRectHeight: height } = nodeDataDependencies;\n  staticFromToMotion(\n    id,\n    \"path_properties\",\n    animationManager,\n    paths,\n    { clipX: 0 },\n    { clipX: width },\n    {\n      phase: \"initial\",\n      start: { clipMode: \"normal\", clipY: height, visible },\n      finish: { clipMode: void 0, visible }\n    }\n  );\n}\nfunction pathFadeInAnimation({ id }, subId, animationManager, phase = \"add\", ...selection) {\n  staticFromToMotion(id, subId, animationManager, selection, { opacity: 0 }, { opacity: 1 }, { phase });\n}\nfunction pathFadeOutAnimation({ id }, subId, animationManager, ...selection) {\n  staticFromToMotion(id, subId, animationManager, selection, { opacity: 1 }, { opacity: 0 }, { phase: \"remove\" });\n}\nfunction buildResetPathFn(opts) {\n  return (_node) => {\n    return { visible: opts.getVisible(), opacity: opts.getOpacity(), clipScalingX: 1, clipMode: void 0 };\n  };\n}\nfunction updateClipPath({ nodeDataDependencies }, path) {\n  const toFinite = (value) => isFinite(value) ? value : 0;\n  path.clipX = toFinite(nodeDataDependencies.seriesRectWidth);\n  path.clipY = toFinite(nodeDataDependencies.seriesRectHeight);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/scaling.ts\nfunction isContinuousScaling(scaling) {\n  return scaling.type === \"continuous\" || scaling.type === \"log\";\n}\nfunction isCategoryScaling(scaling) {\n  return scaling.type === \"category\";\n}\nfunction areEqual(a, b) {\n  return a.domain.length === b.domain.length && a.range.length === b.range.length && a.domain.every((val, index) => val === b.domain[index]) && a.range.every((val, index) => val === b.range[index]);\n}\nfunction areScalingEqual(a, b) {\n  if (a === void 0 || b === void 0) {\n    return a !== void 0 || b !== void 0;\n  }\n  if (isContinuousScaling(a) && isContinuousScaling(b)) {\n    return a.type === b.type && areEqual(a, b);\n  }\n  if (isCategoryScaling(a) && isCategoryScaling(b)) {\n    return areEqual(a, b);\n  }\n  return false;\n}\nfunction isScaleValid(scale2) {\n  if (scale2 == null)\n    return false;\n  if (!scale2.range.every((v) => Number.isFinite(v)))\n    return false;\n  if (scale2.type === \"category\") {\n    return scale2.domain.every((v) => v != null);\n  }\n  return scale2.domain.every((v) => Number.isFinite(v) || v instanceof Date);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineUtil.ts\nfunction* pathRanges(points) {\n  let start = -1;\n  let end = 0;\n  for (const { point } of points) {\n    if (point.moveTo) {\n      const range3 = start >= 0 ? { start, end } : void 0;\n      start = end;\n      end = start;\n      if (range3 !== void 0) {\n        yield range3;\n      }\n    }\n    end += 1;\n  }\n  if (start !== -1) {\n    yield { start, end };\n  }\n}\nfunction* pathRangePoints(points, { start, end }) {\n  for (let i = start; i < end; i += 1) {\n    yield points[i].point;\n  }\n}\nfunction* pathRangePointsReverse(points, { start, end }) {\n  for (let i = end - 1; i >= start; i -= 1) {\n    yield points[i].point;\n  }\n}\nfunction integratedCategoryMatch(a, b) {\n  if (a == null || b == null)\n    return false;\n  if (typeof a !== \"object\" || typeof b !== \"object\")\n    return false;\n  if (\"id\" in a && \"id\" in b) {\n    return a.id === b.id;\n  }\n  return a.toString() === b.toString();\n}\nfunction scale(val, scaling) {\n  if (!scaling)\n    return NaN;\n  if (val instanceof Date) {\n    val = val.getTime();\n  }\n  if (scaling.type === \"continuous\" && typeof val === \"number\") {\n    const domainRatio = (val - scaling.domain[0]) / (scaling.domain[1] - scaling.domain[0]);\n    return domainRatio * (scaling.range[1] - scaling.range[0]) + scaling.range[0];\n  }\n  if (scaling.type === \"log\" && typeof val === \"number\") {\n    return scaling.convert(val);\n  }\n  const matchingIndex = scaling.domain.findIndex((d) => d === val);\n  if (matchingIndex >= 0) {\n    return scaling.range[matchingIndex];\n  }\n  const matchingIntegratedIndex = scaling.domain.findIndex((d) => integratedCategoryMatch(val, d));\n  if (matchingIntegratedIndex >= 0) {\n    return scaling.range[matchingIntegratedIndex];\n  }\n  return NaN;\n}\nfunction scalesChanged(newData, oldData) {\n  return !areScalingEqual(newData.scales.x, oldData.scales.x) || !areScalingEqual(newData.scales.y, oldData.scales.y);\n}\nfunction closeMatch(a, b) {\n  const an = Number(a);\n  const bn = Number(b);\n  if (!isNaN(an) && !isNaN(bn)) {\n    return Math.abs(bn - an) < 0.25;\n  }\n  return a === b;\n}\nfunction calculateMoveTo(from2 = false, to = false) {\n  if (from2 === to) {\n    return Boolean(from2);\n  }\n  return from2 ? \"in\" : \"out\";\n}\nfunction pairContinuousData(newData, oldData, opts = {}) {\n  const { backfillSplitMode = \"intersect\" } = opts;\n  const result = [];\n  const resultMap = {\n    added: {},\n    moved: {},\n    removed: {}\n  };\n  const pairUp = (from2, to, xValue, change = \"move\") => {\n    if (from2 && (isNaN(from2.point.x) || isNaN(from2.point.y))) {\n      from2 = to;\n    }\n    const resultPoint = {\n      from: from2?.point,\n      to: to?.point,\n      moveTo: calculateMoveTo(from2?.point.moveTo, to?.point.moveTo),\n      change\n    };\n    if (change === \"move\") {\n      resultMap.moved[xValue] = resultPoint;\n      oldIdx++;\n      newIdx++;\n    } else if (change === \"in\") {\n      resultMap.added[xValue] = resultPoint;\n      newIdx++;\n    } else if (change === \"out\") {\n      resultMap.removed[xValue] = resultPoint;\n      oldIdx++;\n    }\n    result.push(resultPoint);\n  };\n  const { min: minFromNode, max: maxFromNode } = minMax(oldData.nodeData);\n  const { min: minToNode, max: maxToNode } = minMax(newData.nodeData);\n  let oldIdx = 0;\n  let newIdx = 0;\n  while (oldIdx < oldData.nodeData.length || newIdx < newData.nodeData.length) {\n    const from2 = oldData.nodeData[oldIdx];\n    const to = newData.nodeData[newIdx];\n    const fromShifted = from2 ? scale(from2.xValue ?? NaN, newData.scales.x) : void 0;\n    const toUnshifted = to ? scale(to.xValue ?? NaN, oldData.scales.x) : void 0;\n    const NA = void 0;\n    if (fromShifted != null && closeMatch(fromShifted, to?.point.x)) {\n      pairUp(from2, to, to.xValue, \"move\");\n    } else if (fromShifted != null && fromShifted < (minToNode?.point.x ?? -Infinity)) {\n      pairUp(from2, NA, from2.xValue, \"out\");\n    } else if (fromShifted != null && fromShifted > (maxToNode?.point.x ?? Infinity)) {\n      pairUp(from2, NA, from2.xValue, \"out\");\n    } else if (toUnshifted != null && toUnshifted < (minFromNode?.point.x ?? -Infinity)) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else if (toUnshifted != null && toUnshifted > (maxFromNode?.point.x ?? Infinity)) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else if (fromShifted != null && fromShifted < to?.point.x) {\n      pairUp(from2, NA, from2.xValue, \"out\");\n    } else if (toUnshifted != null && toUnshifted < from2?.point.x) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else if (from2) {\n      pairUp(from2, NA, from2.xValue, \"out\");\n    } else if (to) {\n      pairUp(NA, to, to.xValue, \"in\");\n    } else {\n      throw new Error(\"Unable to process points\");\n    }\n  }\n  backfillPathPointData(result, backfillSplitMode);\n  return { result, resultMap };\n}\nfunction pairCategoryData(newData, oldData, diff2, opts = {}) {\n  const { backfillSplitMode = \"intersect\", multiDatum = false } = opts;\n  const result = [];\n  const resultMapSingle = {\n    added: {},\n    moved: {},\n    removed: {}\n  };\n  const resultMapMulti = {\n    added: {},\n    moved: {},\n    removed: {}\n  };\n  const pointResultMapping = {\n    in: \"added\",\n    move: \"moved\",\n    out: \"removed\"\n  };\n  let previousResultPoint = void 0;\n  let previousXValue = void 0;\n  const addToResultMap = (xValue, newPoint) => {\n    var _a;\n    const type = pointResultMapping[newPoint.change];\n    if (multiDatum) {\n      (_a = resultMapMulti[type])[xValue] ?? (_a[xValue] = []);\n      resultMapMulti[type][xValue].push(newPoint);\n    } else {\n      resultMapSingle[type][xValue] = newPoint;\n    }\n    previousResultPoint = newPoint;\n    previousXValue = transformIntegratedCategoryValue(xValue);\n  };\n  let oldIndex = 0;\n  let newIndex = 0;\n  let isXUnordered = false;\n  while (oldIndex < oldData.nodeData.length || newIndex < newData.nodeData.length) {\n    const before = oldData.nodeData[oldIndex];\n    const after = newData.nodeData[newIndex];\n    const bXValue = transformIntegratedCategoryValue(before?.xValue);\n    const aXValue = transformIntegratedCategoryValue(after?.xValue);\n    let resultPoint;\n    if (bXValue === aXValue) {\n      resultPoint = {\n        change: \"move\",\n        moveTo: calculateMoveTo(before.point.moveTo ?? false, after.point.moveTo),\n        from: before.point,\n        to: after.point\n      };\n      addToResultMap(before?.xValue, resultPoint);\n      oldIndex++;\n      newIndex++;\n    } else if (diff2?.removed.has(String(bXValue))) {\n      resultPoint = {\n        change: \"out\",\n        moveTo: before.point.moveTo ?? false,\n        from: before.point\n      };\n      addToResultMap(before?.xValue, resultPoint);\n      oldIndex++;\n    } else if (diff2?.added.has(String(aXValue))) {\n      resultPoint = {\n        change: \"in\",\n        moveTo: after.point.moveTo ?? false,\n        to: after.point\n      };\n      addToResultMap(after?.xValue, resultPoint);\n      newIndex++;\n    } else if (multiDatum && previousResultPoint && previousXValue === bXValue) {\n      resultPoint = {\n        ...previousResultPoint\n      };\n      addToResultMap(before?.xValue, resultPoint);\n      oldIndex++;\n    } else if (multiDatum && previousResultPoint && previousXValue === aXValue) {\n      resultPoint = {\n        ...previousResultPoint\n      };\n      addToResultMap(after?.xValue, resultPoint);\n      newIndex++;\n    } else {\n      isXUnordered = true;\n      break;\n    }\n    result.push(resultPoint);\n  }\n  let previousX = -Infinity;\n  isXUnordered || (isXUnordered = result.some((pathPoint) => {\n    const { change: marker, to: { x = -Infinity } = {} } = pathPoint;\n    if (marker === \"out\")\n      return;\n    const unordered = x < previousX;\n    previousX = x;\n    return unordered;\n  }));\n  if (isXUnordered) {\n    return { result: void 0, resultMap: void 0 };\n  }\n  backfillPathPointData(result, backfillSplitMode);\n  return { result, resultMap: multiDatum ? resultMapMulti : resultMapSingle };\n}\nfunction determinePathStatus(newData, oldData, pairData) {\n  let status = \"updated\";\n  const visible = (data) => {\n    return data.visible;\n  };\n  if (!visible(oldData) && visible(newData)) {\n    status = \"added\";\n  } else if (visible(oldData) && !visible(newData)) {\n    status = \"removed\";\n  } else {\n    for (let i = 0; i < pairData.length; i++) {\n      if (pairData[i].change !== \"move\")\n        break;\n      if (pairData[i].from?.x !== pairData[i].to?.x)\n        break;\n      if (pairData[i].from?.y !== pairData[i].to?.y)\n        break;\n      if (i === pairData.length - 1)\n        return \"no-op\";\n    }\n  }\n  return status;\n}\nfunction prepareLinePathPropertyAnimation(status, visibleToggleMode) {\n  const phase = visibleToggleMode === \"none\" ? \"updated\" : status;\n  const result = {\n    fromFn: (_path) => {\n      let mixin;\n      if (status === \"removed\") {\n        mixin = { finish: { visible: false } };\n      } else if (status === \"added\") {\n        mixin = { start: { visible: true } };\n      } else {\n        mixin = {};\n      }\n      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase], ...mixin };\n    },\n    toFn: (_path) => {\n      return { phase: NODE_UPDATE_STATE_TO_PHASE_MAPPING[phase] };\n    }\n  };\n  if (visibleToggleMode === \"fade\") {\n    return {\n      fromFn: (path) => {\n        const opacity = status === \"added\" ? 0 : path.opacity;\n        return { opacity, ...result.fromFn(path) };\n      },\n      toFn: (path) => {\n        const opacity = status === \"removed\" ? 0 : 1;\n        return { opacity, ...result.toFn(path) };\n      }\n    };\n  }\n  return result;\n}\nfunction prepareLinePathAnimationFns(newData, oldData, pairData, visibleToggleMode, interpolation, render) {\n  const status = determinePathStatus(newData, oldData, pairData);\n  const removePhaseFn = (ratio2, path) => {\n    render(pairData, { move: 0, out: ratio2 }, path, interpolation);\n  };\n  const updatePhaseFn = (ratio2, path) => {\n    render(pairData, { move: ratio2 }, path, interpolation);\n  };\n  const addPhaseFn = (ratio2, path) => {\n    render(pairData, { move: 1, in: ratio2 }, path, interpolation);\n  };\n  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);\n  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };\n}\nfunction prepareLinePathAnimation(newData, oldData, diff2, interpolation) {\n  const isCategoryBased = newData.scales.x?.type === \"category\";\n  const wasCategoryBased = oldData.scales.x?.type === \"category\";\n  if (isCategoryBased !== wasCategoryBased || !isScaleValid(newData.scales.x) || !isScaleValid(oldData.scales.x)) {\n    return;\n  }\n  const { result: pairData, resultMap: pairMap } = isCategoryBased ? pairCategoryData(newData, oldData, diff2) : pairContinuousData(newData, oldData);\n  let status = \"updated\";\n  if (oldData.visible && !newData.visible) {\n    status = \"removed\";\n  } else if (!oldData.visible && newData.visible) {\n    status = \"added\";\n  }\n  if (pairData === void 0 || pairMap === void 0) {\n    return;\n  }\n  const hasMotion = (diff2?.changed ?? true) || scalesChanged(newData, oldData) || status !== \"updated\";\n  const pathFns = prepareLinePathAnimationFns(newData, oldData, pairData, \"fade\", interpolation, renderPartialPath);\n  const marker = prepareMarkerAnimation(pairMap, status);\n  return { ...pathFns, marker, hasMotion };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineInterpolationUtil.ts\nfunction closeCmp(a, b, delta3 = 1e-6) {\n  if (a === b || 1 - Math.min(a, b) / Math.max(a, b) < delta3) {\n    return 0;\n  } else if (a < b) {\n    return -1;\n  } else {\n    return 1;\n  }\n}\nfunction closeMatch2(a, b, delta3) {\n  if (a === b) {\n    return true;\n  }\n  const an = Number(a);\n  const bn = Number(b);\n  return Number.isFinite(an) && Number.isFinite(bn) && closeCmp(an, bn, delta3) === 0;\n}\nfunction transformSpans(spanData, { x: xScale, y: yScale }) {\n  let rangeSpanData;\n  const interpolatingInvalidSpans = [];\n  let shiftedXStart = Infinity;\n  let shiftedXEnd = -Infinity;\n  for (const spanDatum of spanData) {\n    const x0 = scale(spanDatum.xValue0, xScale);\n    const y0 = scale(spanDatum.yValue0, yScale);\n    const x1 = scale(spanDatum.xValue1, xScale);\n    const y1 = scale(spanDatum.yValue1, yScale);\n    const startIsFinite = Number.isFinite(x0);\n    const endIsFinite = Number.isFinite(x1);\n    if (startIsFinite && endIsFinite && rangeSpanData == null) {\n      const unshifted = spanDatum.span;\n      const shifted = rescaleSpan(unshifted, { x: x0, y: y0 }, { x: x1, y: y1 });\n      const spanTransform = { unshifted, shifted };\n      shiftedXStart = Math.min(shiftedXStart, x0);\n      shiftedXEnd = Math.max(shiftedXEnd, x1);\n      interpolatingInvalidSpans.push(spanTransform);\n    } else if (startIsFinite && !endIsFinite && rangeSpanData == null) {\n      rangeSpanData = [spanDatum];\n    } else if (!startIsFinite && !endIsFinite && rangeSpanData != null) {\n      if (rangeSpanData != null) {\n        rangeSpanData.push(spanDatum);\n      }\n    } else if (!startIsFinite && endIsFinite && rangeSpanData != null) {\n      rangeSpanData.push(spanDatum);\n      const startSpanDatum = rangeSpanData.at(0);\n      const endSpanDatum = rangeSpanData.at(-1);\n      const transformStart = {\n        x: scale(startSpanDatum.xValue0, xScale),\n        y: scale(startSpanDatum.yValue0, yScale)\n      };\n      const transformEnd = {\n        x: scale(endSpanDatum.xValue1, xScale),\n        y: scale(endSpanDatum.yValue1, yScale)\n      };\n      const step = (transformEnd.x - transformStart.x) / (rangeSpanData.length - 1);\n      for (let i = 0; i < rangeSpanData.length; i += 1) {\n        const { span: interpolatingUnshifted, yValue0, yValue1 } = rangeSpanData[i];\n        const interpolatingShifted = rescaleSpan(\n          interpolatingUnshifted,\n          { x: transformStart.x + step * (i + 0), y: scale(yValue0, yScale) },\n          { x: transformStart.x + step * (i + 1), y: scale(yValue1, yScale) }\n        );\n        interpolatingInvalidSpans.push({ unshifted: interpolatingUnshifted, shifted: interpolatingShifted });\n      }\n      shiftedXStart = Math.min(shiftedXStart, transformStart.x);\n      shiftedXEnd = Math.max(shiftedXEnd, transformEnd.x);\n      rangeSpanData = void 0;\n    } else if (!startIsFinite && endIsFinite && rangeSpanData == null) {\n      const unshifted = spanDatum.span;\n      const shifted = rescaleSpan(unshifted, { x: x1, y: y0 }, { x: x1, y: y1 });\n      interpolatingInvalidSpans.push({ unshifted, shifted });\n    } else {\n      rangeSpanData = void 0;\n    }\n  }\n  if (rangeSpanData != null) {\n    const startSpanDatum = rangeSpanData.at(0);\n    const x = scale(startSpanDatum.xValue0, xScale);\n    for (const { span: interpolatingUnshifted, yValue0, yValue1 } of rangeSpanData) {\n      const interpolatingShifted = rescaleSpan(\n        interpolatingUnshifted,\n        { x, y: scale(yValue0, yScale) },\n        { x, y: scale(yValue1, yScale) }\n      );\n      interpolatingInvalidSpans.push({ unshifted: interpolatingUnshifted, shifted: interpolatingShifted });\n    }\n  }\n  const shiftedXRange = [shiftedXStart, shiftedXEnd];\n  return { interpolatingInvalidSpans, shiftedXRange };\n}\nfunction pairUpSpans(newData, oldData, splitMode) {\n  const oldSpans = transformSpans(oldData.data, newData.scales);\n  const newSpans = transformSpans(newData.data, oldData.scales);\n  const [oldRangeStartNewScale, oldRangeEndNewScale] = oldSpans.shiftedXRange;\n  const [newRangeStartOldScale, newRangeEndOldScale] = newSpans.shiftedXRange;\n  const removed = [];\n  const moved = [];\n  for (const oldSpanDatum of oldSpans.interpolatingInvalidSpans) {\n    const oldSpanOldScale = oldSpanDatum.unshifted;\n    const oldSpanNewScale = oldSpanDatum.shifted;\n    const [{ x: fromStartOldScale, y: fromStartOldScaleY }, { x: fromEndOldScale, y: fromEndOldScaleY }] = spanRange(oldSpanOldScale);\n    let hasCorrespondingSpan = false;\n    for (const newSpanDatum of newSpans.interpolatingInvalidSpans) {\n      const newSpanOldScale = newSpanDatum.shifted;\n      const newSpanNewScale = newSpanDatum.unshifted;\n      const [{ x: toStartOldScale }, { x: toEndOldScale }] = spanRange(newSpanOldScale);\n      if (closeCmp(fromStartOldScale, toEndOldScale) !== -1 || closeCmp(fromEndOldScale, toStartOldScale) !== 1) {\n        continue;\n      }\n      if (closeMatch2(fromStartOldScale, toStartOldScale) && closeMatch2(fromEndOldScale, toEndOldScale)) {\n        removed.push({ from: oldSpanOldScale, to: oldSpanOldScale });\n        moved.push({ from: oldSpanOldScale, to: newSpanNewScale });\n      } else if (fromStartOldScale <= toStartOldScale && fromEndOldScale >= toEndOldScale) {\n        removed.push({ from: oldSpanOldScale, to: oldSpanOldScale });\n        moved.push({ from: oldSpanOldScale, to: oldSpanNewScale });\n      } else {\n        const [{ x: fromStartNewScale }, { x: fromEndNewScale }] = spanRange(oldSpanNewScale);\n        const [{ x: toStartNewScale }, { x: toEndNewScale }] = spanRange(newSpanNewScale);\n        const xRangeStartOldScale = Math.max(fromStartOldScale, toStartOldScale);\n        const xRangeEndOldScale = Math.min(fromEndOldScale, toEndOldScale);\n        const clippedOldSpanOldScale = clipSpanX(oldSpanOldScale, xRangeStartOldScale, xRangeEndOldScale);\n        const clippedNewSpanOldScale = clipSpanX(newSpanOldScale, xRangeStartOldScale, xRangeEndOldScale);\n        const xRangeStartNewScale = Math.max(fromStartNewScale, toStartNewScale);\n        const xRangeEndNewScale = Math.min(fromEndNewScale, toEndNewScale);\n        const clippedNewSpanNewScale = clipSpanX(newSpanNewScale, xRangeStartNewScale, xRangeEndNewScale);\n        removed.push({ from: clippedOldSpanOldScale, to: clippedNewSpanOldScale });\n        moved.push({ from: clippedNewSpanOldScale, to: clippedNewSpanNewScale });\n      }\n      hasCorrespondingSpan = true;\n    }\n    if (hasCorrespondingSpan)\n      continue;\n    if (closeCmp(fromEndOldScale, newRangeStartOldScale) !== 1) {\n      removed.push({\n        from: oldSpanOldScale,\n        to: rescaleSpan(\n          oldSpanOldScale,\n          { x: newRangeStartOldScale, y: fromStartOldScaleY },\n          { x: newRangeStartOldScale, y: fromEndOldScaleY }\n        )\n      });\n    } else if (closeCmp(fromStartOldScale, newRangeEndOldScale) !== -1) {\n      removed.push({\n        from: oldSpanOldScale,\n        to: rescaleSpan(\n          oldSpanOldScale,\n          { x: newRangeEndOldScale, y: fromStartOldScaleY },\n          { x: newRangeEndOldScale, y: fromEndOldScaleY }\n        )\n      });\n    } else if (splitMode === 0 /* Zero */) {\n      const y = scale(0, oldData.scales.y);\n      removed.push({\n        from: oldSpanOldScale,\n        to: rescaleSpan(oldSpanOldScale, { x: fromStartOldScale, y }, { x: fromEndOldScale, y })\n      });\n    } else if (splitMode === 1 /* Divide */) {\n      const [left, right] = splitSpanAtX(oldSpanOldScale, (fromStartOldScale + fromEndOldScale) / 2);\n      removed.push(\n        { from: left, to: collapseSpanToPoint(left, { x: fromStartOldScale, y: fromStartOldScaleY }) },\n        { from: right, to: collapseSpanToPoint(right, { x: fromEndOldScale, y: fromEndOldScaleY }) }\n      );\n    }\n  }\n  const added = [];\n  for (const newSpanDatum of newData.data) {\n    const newSpanNewScale = newSpanDatum.span;\n    const [{ x: toStartNewScale, y: toStartNewScaleY }, { x: toEndNewScale, y: toEndNewScaleY }] = spanRange(newSpanNewScale);\n    let hasCorrespondingSpan = false;\n    for (const oldSpanDatum of oldSpans.interpolatingInvalidSpans) {\n      const oldSpanNewScale = oldSpanDatum.shifted;\n      const [{ x: fromStartNewScale }, { x: fromEndNewScale }] = spanRange(oldSpanNewScale);\n      if (closeCmp(fromStartNewScale, toEndNewScale) !== -1 || closeCmp(fromEndNewScale, toStartNewScale) !== 1) {\n        continue;\n      }\n      if (closeMatch2(fromStartNewScale, toStartNewScale) && closeMatch2(fromEndNewScale, toEndNewScale)) {\n        added.push({ from: newSpanNewScale, to: newSpanNewScale });\n      } else if (fromStartNewScale <= toStartNewScale && fromEndNewScale >= toEndNewScale) {\n        const clippedOldSpanNewScale = clipSpanX(oldSpanNewScale, toStartNewScale, toEndNewScale);\n        added.push({ from: clippedOldSpanNewScale, to: newSpanNewScale });\n      } else {\n        added.push({ from: newSpanNewScale, to: newSpanNewScale });\n      }\n      hasCorrespondingSpan = true;\n    }\n    if (hasCorrespondingSpan)\n      continue;\n    if (closeCmp(toEndNewScale, oldRangeStartNewScale) !== 1) {\n      added.push({\n        from: rescaleSpan(\n          newSpanNewScale,\n          { x: oldRangeStartNewScale, y: toStartNewScaleY },\n          { x: oldRangeStartNewScale, y: toEndNewScaleY }\n        ),\n        to: newSpanNewScale\n      });\n    } else if (closeCmp(toStartNewScale, oldRangeEndNewScale) !== -1) {\n      added.push({\n        from: rescaleSpan(\n          newSpanNewScale,\n          { x: oldRangeEndNewScale, y: toStartNewScaleY },\n          { x: oldRangeEndNewScale, y: toEndNewScaleY }\n        ),\n        to: newSpanNewScale\n      });\n    } else if (splitMode === 0 /* Zero */) {\n      const y = scale(0, newData.scales.y);\n      added.push({\n        from: rescaleSpan(newSpanNewScale, { x: toStartNewScale, y }, { x: toEndNewScale, y }),\n        to: newSpanNewScale\n      });\n    } else if (splitMode === 1 /* Divide */) {\n      const [left, right] = splitSpanAtX(newSpanNewScale, (toStartNewScale + toEndNewScale) / 2);\n      added.push(\n        { from: collapseSpanToPoint(left, { x: toStartNewScale, y: toStartNewScaleY }), to: newSpanNewScale },\n        { from: collapseSpanToPoint(right, { x: toEndNewScale, y: toEndNewScaleY }), to: newSpanNewScale }\n      );\n    }\n  }\n  return { added, moved, removed };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaUtil.ts\nvar AreaSeriesTag = /* @__PURE__ */ ((AreaSeriesTag2) => {\n  AreaSeriesTag2[AreaSeriesTag2[\"Fill\"] = 0] = \"Fill\";\n  AreaSeriesTag2[AreaSeriesTag2[\"Stroke\"] = 1] = \"Stroke\";\n  AreaSeriesTag2[AreaSeriesTag2[\"Marker\"] = 2] = \"Marker\";\n  AreaSeriesTag2[AreaSeriesTag2[\"Label\"] = 3] = \"Label\";\n  return AreaSeriesTag2;\n})(AreaSeriesTag || {});\nfunction plotSpans(ratio2, path, spans, phantomSpans) {\n  for (let i = 0; i < spans.length; i += 1) {\n    const span = spans[i];\n    const phantomSpan = phantomSpans[i];\n    plotSpan(path.path, interpolateSpans(span.from, span.to, ratio2), 1 /* MoveTo */);\n    plotSpan(path.path, reverseSpan(interpolateSpans(phantomSpan.from, phantomSpan.to, ratio2)), 2 /* LineTo */);\n    path.path.closePath();\n  }\n}\nfunction prepareAreaPathAnimationFns(status, spans, phantomSpans, visibleToggleMode) {\n  const removePhaseFn = (ratio2, path) => plotSpans(ratio2, path, spans.removed, phantomSpans.removed);\n  const updatePhaseFn = (ratio2, path) => plotSpans(ratio2, path, spans.moved, phantomSpans.moved);\n  const addPhaseFn = (ratio2, path) => plotSpans(ratio2, path, spans.added, phantomSpans.added);\n  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);\n  return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };\n}\nfunction prepareAreaPathAnimation(newData, oldData, diff2) {\n  const isCategoryBased = newData.scales.x?.type === \"category\";\n  const wasCategoryBased = oldData.scales.x?.type === \"category\";\n  if (isCategoryBased !== wasCategoryBased || !isScaleValid(newData.scales.x) || !isScaleValid(oldData.scales.x)) {\n    return;\n  }\n  let status = \"updated\";\n  if (oldData.visible && !newData.visible) {\n    status = \"removed\";\n  } else if (!oldData.visible && newData.visible) {\n    status = \"added\";\n  }\n  const spans = pairUpSpans(\n    { scales: newData.scales, data: newData.fillData.spans, visible: newData.visible },\n    { scales: oldData.scales, data: oldData.fillData.spans, visible: oldData.visible },\n    0 /* Zero */\n  );\n  const phantomSpans = pairUpSpans(\n    { scales: newData.scales, data: newData.fillData.phantomSpans, visible: newData.visible },\n    { scales: oldData.scales, data: oldData.fillData.phantomSpans, visible: oldData.visible },\n    0 /* Zero */\n  );\n  const prepareMarkerPairs = () => {\n    if (isCategoryBased) {\n      return pairCategoryData(newData, oldData, diff2, { backfillSplitMode: \"static\", multiDatum: true });\n    }\n    return pairContinuousData(newData, oldData, { backfillSplitMode: \"static\" });\n  };\n  const { resultMap: markerPairMap } = prepareMarkerPairs();\n  if (markerPairMap === void 0)\n    return;\n  const stackVisible = true;\n  const fadeMode = stackVisible ? \"none\" : \"fade\";\n  const fill = prepareAreaPathAnimationFns(status, spans, phantomSpans, fadeMode);\n  const marker = prepareMarkerAnimation(markerPairMap, status);\n  return { status, fill, marker };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaSeries.ts\nvar AreaSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pathsPerSeries: [\"fill\", \"stroke\"],\n      pathsZIndexSubOrderOffset: [0, 1e3],\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      pickModes: [1 /* NEAREST_BY_MAIN_AXIS_FIRST */, 0 /* EXACT_SHAPE_MATCH */],\n      animationResetFns: {\n        path: buildResetPathFn({ getVisible: () => this.visible, getOpacity: () => this.getOpacity() }),\n        label: resetLabelFn,\n        marker: (node, datum) => ({ ...resetMarkerFn(node), ...resetMarkerPositionFn(node, datum) })\n      }\n    });\n    this.properties = new AreaSeriesProperties();\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 1 } = {} } = this;\n    const { xKey, yKey, connectMissingData, normalizedTo } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const currentIds = {\n      value: `area-stack-${groupIndex}-yValue`,\n      values: `area-stack-${groupIndex}-yValues`,\n      stack: `area-stack-${groupIndex}-yValue-stack`,\n      marker: `area-stack-${groupIndex}-yValues-marker`\n    };\n    const extraProps = [];\n    if (isDefined(normalizedTo)) {\n      extraProps.push(normaliseGroupTo(Object.values(currentIds), normalizedTo, \"range\"));\n    }\n    if (!isContinuousX && animationEnabled && this.processedData) {\n      extraProps.push(diff(this.processedData));\n    }\n    if (animationEnabled) {\n      extraProps.push(animationValidation());\n    }\n    const common = { invalidValue: null };\n    if (connectMissingData && stackCount > 1) {\n      common.invalidValue = 0;\n    }\n    if (!visible) {\n      common.forceValue = 0;\n    }\n    await this.requestDataModel(dataController, data, {\n      props: [\n        keyProperty(xKey, xScaleType, { id: \"xValue\" }),\n        valueProperty(yKey, yScaleType, { id: `yValueRaw`, ...common }),\n        ...groupStackValueProperty(yKey, yScaleType, {\n          id: `yValueStack`,\n          ...common,\n          groupId: currentIds.stack\n        }),\n        valueProperty(yKey, yScaleType, {\n          id: `yValue`,\n          ...common,\n          groupId: currentIds.value\n        }),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window\",\n          \"current\",\n          {\n            id: `yValueEnd`,\n            ...common,\n            groupId: currentIds.values\n          },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"normal\",\n          \"current\",\n          {\n            id: `yValueCumulative`,\n            ...common,\n            groupId: currentIds.marker\n          },\n          yScaleType\n        ),\n        ...extraProps\n      ],\n      groupByKeys: true,\n      groupByData: false\n    });\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel, axes } = this;\n    if (!processedData || !dataModel || processedData.data.length === 0)\n      return [];\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    const keys = dataModel.getDomain(this, `xValue`, \"key\", processedData);\n    const yExtent = dataModel.getDomain(this, `yValueEnd`, \"value\", processedData);\n    if (direction === \"x\" /* X */) {\n      if (keyDef?.def.type === \"key\" && keyDef.def.valueType === \"category\") {\n        return keys;\n      }\n      return fixNumericExtent(extent(keys), xAxis);\n    } else if (yAxis instanceof LogAxis || yAxis instanceof TimeAxis) {\n      return fixNumericExtent(yExtent, yAxis);\n    } else {\n      const fixedYExtent = [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]];\n      return fixNumericExtent(fixedYExtent, yAxis);\n    }\n  }\n  async createNodeData() {\n    const { axes, data, processedData: { data: groupedData } = {}, dataModel } = this;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!xAxis || !yAxis || !data || !dataModel || !this.properties.isValid()) {\n      return;\n    }\n    const {\n      yKey,\n      xKey,\n      marker,\n      label,\n      fill: seriesFill,\n      stroke: seriesStroke,\n      connectMissingData\n    } = this.properties;\n    const { scale: xScale } = xAxis;\n    const { scale: yScale } = yAxis;\n    const { isContinuousY } = this.getScaleInformation({ xScale, yScale });\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const defs = dataModel.resolveProcessedDataDefsByIds(this, [`yValueEnd`, `yValueRaw`, `yValueCumulative`]);\n    const yValueStackIndex = dataModel.resolveProcessedDataIndexById(this, \"yValueStack\");\n    const createMarkerCoordinate = (xDatum, yEnd, rawYDatum) => {\n      let currY;\n      if (isDefined(this.properties.normalizedTo) ? isContinuousY && isContinuous(rawYDatum) : !isNaN(rawYDatum)) {\n        currY = yEnd;\n      }\n      return {\n        x: xScale.convert(xDatum) + xOffset,\n        y: yScale.convert(currY),\n        size: marker.size\n      };\n    };\n    const itemId = yKey;\n    const labelData = [];\n    const markerData = [];\n    const { visibleSameStackCount } = this.ctx.seriesStateManager.getVisiblePeerGroupIndex(this);\n    let datumIdx = -1;\n    groupedData?.forEach((datumGroup) => {\n      const {\n        keys,\n        keys: [xDatum],\n        datum: datumArray,\n        values: valuesArray\n      } = datumGroup;\n      valuesArray.forEach((values, valueIdx) => {\n        datumIdx++;\n        const seriesDatum = datumArray[valueIdx];\n        const dataValues2 = dataModel.resolveProcessedDataDefsValues(defs, { keys, values });\n        const { yValueRaw: yDatum, yValueCumulative, yValueEnd } = dataValues2;\n        const validPoint = Number.isFinite(yDatum);\n        const point = createMarkerCoordinate(xDatum, +yValueCumulative, yDatum);\n        if (validPoint && marker) {\n          markerData.push({\n            index: datumIdx,\n            series: this,\n            itemId,\n            datum: seriesDatum,\n            midPoint: { x: point.x, y: point.y },\n            cumulativeValue: yValueEnd,\n            yValue: yDatum,\n            xValue: xDatum,\n            yKey,\n            xKey,\n            point,\n            fill: marker.fill ?? seriesFill,\n            stroke: marker.stroke ?? seriesStroke,\n            strokeWidth: marker.strokeWidth ?? this.getStrokeWidth(this.properties.strokeWidth)\n          });\n        }\n        if (validPoint && label) {\n          const labelText = this.getLabelText(\n            label,\n            {\n              value: yDatum,\n              datum: seriesDatum,\n              xKey,\n              yKey,\n              xName: this.properties.xName,\n              yName: this.properties.yName\n            },\n            (value) => isFiniteNumber(value) ? value.toFixed(2) : String(value)\n          );\n          labelData.push({\n            index: datumIdx,\n            series: this,\n            itemId: yKey,\n            datum: seriesDatum,\n            x: point.x,\n            y: point.y,\n            label: labelText ? {\n              text: labelText,\n              fontStyle: label.fontStyle,\n              fontWeight: label.fontWeight,\n              fontSize: label.fontSize,\n              fontFamily: label.fontFamily,\n              textAlign: \"center\",\n              textBaseline: \"bottom\",\n              fill: label.color\n            } : void 0\n          });\n        }\n      });\n    });\n    const { interpolation } = this.properties;\n    const interpolatePoints = (points) => {\n      let spans;\n      const pointsIter = points.map((point) => point.point);\n      switch (interpolation.type) {\n        case \"linear\":\n          spans = linearPoints(pointsIter);\n          break;\n        case \"smooth\":\n          spans = smoothPoints(pointsIter, interpolation.tension);\n          break;\n        case \"step\":\n          spans = stepPoints(pointsIter, interpolation.position);\n          break;\n      }\n      return spans.map((span, i) => ({\n        span,\n        xValue0: points[i].xDatum,\n        yValue0: points[i].yDatum,\n        xValue1: points[i + 1].xDatum,\n        yValue1: points[i + 1].yDatum\n      }));\n    };\n    const spansForPoints = (points) => {\n      return points.flatMap((p) => {\n        return Array.isArray(p) ? interpolatePoints(p) : new Array(p.skip).fill(null);\n      });\n    };\n    const dataValues = groupedData?.flatMap((datumGroup) => {\n      const {\n        keys: [xDatum],\n        values: valuesArray\n      } = datumGroup;\n      return valuesArray.map((values) => ({ xDatum, values }));\n    });\n    const createPoint = (xDatum, yDatum) => ({\n      point: {\n        x: xScale.convert(xDatum) + xOffset,\n        y: yScale.convert(yDatum)\n      },\n      xDatum,\n      yDatum\n    });\n    const getSeriesSpans = (index) => {\n      const points = [];\n      if (dataValues == null)\n        return [];\n      for (let i = 0; i < dataValues.length; i += 1) {\n        const { xDatum, values } = dataValues[i];\n        const yValueStack = values[yValueStackIndex];\n        const yDatum = yValueStack[index];\n        const yDatumIsFinite = Number.isFinite(yDatum);\n        if (connectMissingData && !yDatumIsFinite)\n          continue;\n        const lastYValueStack = dataValues[i - 1]?.values[yValueStackIndex];\n        const nextYValueStack = dataValues[i + 1]?.values[yValueStackIndex];\n        let yValueEndBackwards = 0;\n        let yValueEndForwards = 0;\n        for (let j = 0; j <= index; j += 1) {\n          const value = yValueStack[j];\n          if (Number.isFinite(value)) {\n            const lastWasFinite = lastYValueStack == null || Number.isFinite(lastYValueStack[j]);\n            const nextWasFinite = nextYValueStack == null || Number.isFinite(nextYValueStack[j]);\n            if (lastWasFinite) {\n              yValueEndBackwards += value;\n            }\n            if (nextWasFinite) {\n              yValueEndForwards += value;\n            }\n          }\n        }\n        const currentPoints = points[points.length - 1];\n        if (!connectMissingData && (yValueEndBackwards !== yValueEndForwards || !yDatumIsFinite)) {\n          if (!yDatumIsFinite && Array.isArray(currentPoints) && currentPoints.length === 1) {\n            points[points.length - 1] = { skip: 1 };\n          } else {\n            const pointBackwards = createPoint(xDatum, yValueEndBackwards);\n            const pointForwards = createPoint(xDatum, yValueEndForwards);\n            if (Array.isArray(currentPoints)) {\n              currentPoints.push(pointBackwards);\n            } else if (currentPoints != null) {\n              currentPoints.skip += 1;\n            }\n            points.push(yDatumIsFinite ? [pointForwards] : { skip: 0 });\n          }\n        } else {\n          const yValueEnd = Math.max(yValueEndBackwards, yValueEndForwards);\n          const point = createPoint(xDatum, yValueEnd);\n          if (Array.isArray(currentPoints)) {\n            currentPoints.push(point);\n          } else if (currentPoints != null) {\n            currentPoints.skip += 1;\n            points.push([point]);\n          } else {\n            points.push([point]);\n          }\n        }\n      }\n      return spansForPoints(points);\n    };\n    const stackIndex = this.seriesGrouping?.stackIndex ?? 0;\n    const getAxisSpans = () => {\n      if (dataValues == null)\n        return [];\n      const yValueZeroPoints = dataValues.map(({ xDatum, values }) => {\n        const yValueStack = values[yValueStackIndex];\n        const yDatum = yValueStack[stackIndex];\n        if (connectMissingData && !Number.isFinite(yDatum))\n          return;\n        return createPoint(xDatum, 0);\n      }).filter((x) => x != null);\n      return interpolatePoints(yValueZeroPoints);\n    };\n    const currentSeriesSpans = getSeriesSpans(stackIndex);\n    const phantomSpans = currentSeriesSpans.map(() => null);\n    for (let j = stackIndex - 1; j >= -1; j -= 1) {\n      let spans;\n      for (let i = 0; i < phantomSpans.length; i += 1) {\n        if (phantomSpans[i] != null)\n          continue;\n        spans ?? (spans = j !== -1 ? getSeriesSpans(j) : getAxisSpans());\n        phantomSpans[i] = spans[i];\n      }\n    }\n    const fillSpans = currentSeriesSpans.map((span, index) => span ?? phantomSpans[index]);\n    const strokeSpans = currentSeriesSpans.filter((span) => span != null);\n    const context = {\n      itemId,\n      fillData: { itemId, spans: fillSpans, phantomSpans },\n      strokeData: { itemId, spans: strokeSpans },\n      labelData,\n      nodeData: markerData,\n      scales: this.calculateScaling(),\n      visible: this.visible,\n      stackVisible: visibleSameStackCount > 0\n    };\n    return context;\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updatePathNodes(opts) {\n    const { opacity, visible, animationEnabled } = opts;\n    const [fill, stroke] = opts.paths;\n    const strokeWidth = this.getStrokeWidth(this.properties.strokeWidth);\n    stroke.setProperties({\n      tag: 1 /* Stroke */,\n      fill: void 0,\n      lineJoin: stroke.lineCap = \"round\",\n      pointerEvents: 1 /* None */,\n      stroke: this.properties.stroke,\n      strokeWidth,\n      strokeOpacity: this.properties.strokeOpacity,\n      lineDash: this.properties.lineDash,\n      lineDashOffset: this.properties.lineDashOffset,\n      opacity,\n      visible\n    });\n    fill.setProperties({\n      tag: 0 /* Fill */,\n      stroke: void 0,\n      lineJoin: \"round\",\n      pointerEvents: 1 /* None */,\n      fill: this.properties.fill,\n      fillOpacity: this.properties.fillOpacity,\n      lineDash: this.properties.lineDash,\n      lineDashOffset: this.properties.lineDashOffset,\n      strokeOpacity: this.properties.strokeOpacity,\n      fillShadow: this.properties.shadow,\n      opacity,\n      visible: visible || animationEnabled,\n      strokeWidth\n    });\n    updateClipPath(this, stroke);\n    updateClipPath(this, fill);\n  }\n  async updatePaths(opts) {\n    this.updateAreaPaths(opts.paths, opts.contextData);\n  }\n  updateAreaPaths(paths, contextData) {\n    this.updateFillPath(paths, contextData);\n    this.updateStrokePath(paths, contextData);\n  }\n  updateFillPath(paths, contextData) {\n    const { spans, phantomSpans } = contextData.fillData;\n    const [fill] = paths;\n    const { path } = fill;\n    path.clear(true);\n    for (let i = 0; i < spans.length; i += 1) {\n      const { span } = spans[i];\n      const phantomSpan = phantomSpans[i].span;\n      plotSpan(path, span, 1 /* MoveTo */);\n      plotSpan(path, reverseSpan(phantomSpan), 2 /* LineTo */);\n      path.closePath();\n    }\n    fill.checkPathDirty();\n  }\n  updateStrokePath(paths, contextData) {\n    const { spans } = contextData.strokeData;\n    const [, stroke] = paths;\n    const { path } = stroke;\n    path.clear(true);\n    for (const { span } of spans) {\n      plotSpan(path, span);\n    }\n    stroke.checkPathDirty();\n  }\n  async updateMarkerSelection(opts) {\n    const { nodeData, markerSelection } = opts;\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    return markerSelection.update(this.properties.marker.enabled ? nodeData : []);\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, marker, fill, stroke, strokeWidth, fillOpacity, strokeOpacity, highlightStyle } = this.properties;\n    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle(), {\n      fill,\n      stroke,\n      strokeWidth,\n      fillOpacity,\n      strokeOpacity\n    });\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey }, baseStyle);\n    });\n    if (!highlighted) {\n      this.properties.marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    const { labelData, labelSelection } = opts;\n    return labelSelection.update(labelData, (text) => {\n      text.tag = 3 /* Label */;\n    });\n  }\n  async updateLabelNodes(opts) {\n    const { labelSelection } = opts;\n    const { enabled: labelEnabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.properties.label;\n    labelSelection.each((text, datum) => {\n      const { x, y, label } = datum;\n      if (label && labelEnabled && this.visible) {\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.textAlign = label.textAlign;\n        text.textBaseline = label.textBaseline;\n        text.text = label.text;\n        text.x = x;\n        text.y = y - 10;\n        text.fill = color;\n        text.visible = true;\n      } else {\n        text.visible = false;\n      }\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const { id: seriesId, axes, dataModel } = this;\n    const { xKey, xName, yName, tooltip, marker } = this.properties;\n    const { yKey, xValue, yValue, datum, itemId } = nodeDatum;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !(xAxis && yAxis && isFiniteNumber(yValue)) || !dataModel) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const xString = xAxis.formatDatum(xValue);\n    const yString = yAxis.formatDatum(yValue);\n    const title = sanitizeHtml(yName);\n    const content = sanitizeHtml(xString + \": \" + yString);\n    const baseStyle = mergeDefaults({ fill: this.properties.fill }, marker.getStyle(), {\n      stroke: this.properties.stroke,\n      strokeWidth: this.properties.strokeWidth\n    });\n    const { fill: color } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, xKey, yKey, highlighted: false },\n      baseStyle\n    );\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        color,\n        title,\n        seriesId\n      }\n    );\n  }\n  getLegendData(legendType) {\n    if (!this.data?.length || !this.properties.isValid() || !this.properties.showInLegend || legendType !== \"category\") {\n      return [];\n    }\n    const {\n      yKey,\n      yName,\n      fill,\n      stroke,\n      fillOpacity,\n      strokeOpacity,\n      strokeWidth,\n      lineDash,\n      marker,\n      visible,\n      legendItemName\n    } = this.properties;\n    const useAreaFill = !marker.enabled || marker.fill === void 0;\n    return [\n      {\n        legendType,\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: legendItemName ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape: marker.shape,\n              fill: useAreaFill ? fill : marker.fill,\n              fillOpacity: useAreaFill ? fillOpacity : marker.fillOpacity,\n              stroke: marker.stroke ?? stroke,\n              strokeOpacity: marker.strokeOpacity ?? strokeOpacity,\n              strokeWidth: marker.strokeWidth ?? 0,\n              enabled: marker.enabled || strokeWidth <= 0\n            },\n            line: {\n              stroke,\n              strokeOpacity,\n              strokeWidth,\n              lineDash\n            }\n          }\n        ],\n        legendItemName\n      }\n    ];\n  }\n  animateEmptyUpdateReady(animationData) {\n    const { markerSelection, labelSelection, contextData, paths } = animationData;\n    const { animationManager } = this.ctx;\n    this.updateAreaPaths(paths, contextData);\n    pathSwipeInAnimation(this, animationManager, ...paths);\n    resetMotion([markerSelection], resetMarkerPositionFn);\n    markerSwipeScaleInAnimation(this, animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n  }\n  animateReadyResize(animationData) {\n    const { contextData, paths } = animationData;\n    this.updateAreaPaths(paths, contextData);\n    super.animateReadyResize(animationData);\n  }\n  animateWaitingUpdateReady(animationData) {\n    const { animationManager } = this.ctx;\n    const { markerSelection, labelSelection, contextData, paths, previousContextData } = animationData;\n    const [fill, stroke] = paths;\n    if (fill == null && stroke == null)\n      return;\n    this.resetMarkerAnimation(animationData);\n    this.resetLabelAnimation(animationData);\n    const update = () => {\n      this.resetPathAnimation(animationData);\n      this.updateAreaPaths(paths, contextData);\n      this.updateStrokePath(paths, contextData);\n    };\n    const skip = () => {\n      animationManager.skipCurrentBatch();\n      update();\n    };\n    if (contextData == null || previousContextData == null) {\n      update();\n      markerFadeInAnimation(this, animationManager, \"added\", markerSelection);\n      pathFadeInAnimation(this, \"fill_path_properties\", animationManager, \"add\", fill);\n      pathFadeInAnimation(this, \"stroke\", animationManager, \"trailing\", stroke);\n      seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n      return;\n    }\n    const fns = prepareAreaPathAnimation(contextData, previousContextData, this.processedData?.reduced?.diff);\n    if (fns === void 0) {\n      skip();\n      return;\n    } else if (fns.status === \"no-op\") {\n      return;\n    }\n    markerFadeInAnimation(this, animationManager, void 0, markerSelection);\n    fromToMotion(this.id, \"fill_path_properties\", animationManager, [fill], fns.fill.pathProperties);\n    pathMotion(this.id, \"fill_path_update\", animationManager, [fill], fns.fill.path);\n    this.updateStrokePath(paths, contextData);\n    pathFadeInAnimation(this, \"stroke\", animationManager, \"trailing\", stroke);\n    seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey } = datum;\n    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, highlighted: true });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nAreaSeries.className = \"AreaSeries\";\nAreaSeries.type = \"area\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/areaSeriesModule.ts\nvar AreaSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"area\",\n  moduleFactory: (ctx) => new AreaSeries(ctx),\n  stackable: true,\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    },\n    {\n      type: \"category\" /* CATEGORY */,\n      position: \"bottom\" /* BOTTOM */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      nodeClickRange: \"nearest\",\n      tooltip: { position: { type: \"node\" } },\n      fillOpacity: 0.8,\n      strokeOpacity: 1,\n      strokeWidth: 0,\n      lineDash: [0],\n      lineDashOffset: 0,\n      shadow: {\n        enabled: false,\n        color: DEFAULT_SHADOW_COLOUR,\n        xOffset: 3,\n        yOffset: 3,\n        blur: 5\n      },\n      interpolation: {\n        type: \"linear\",\n        // @ts-expect-error - users shouldn't specify all options, but we have to for theming to work\n        tension: 1,\n        position: \"end\"\n      },\n      marker: {\n        enabled: false,\n        shape: \"circle\",\n        size: 7,\n        strokeWidth: 0\n      },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      }\n    }\n  },\n  paletteFactory: (params) => {\n    const { marker } = markerPaletteFactory(params);\n    return { fill: marker.fill, stroke: marker.stroke, marker };\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/quadtreeUtil.ts\nfunction* childrenIter(parent) {\n  for (const node of parent.children) {\n    yield node;\n  }\n}\nfunction addHitTestersToQuadtree(quadtree, hitTesters) {\n  for (const node of hitTesters) {\n    const datum = node.datum;\n    if (datum === void 0) {\n      Logger.error(\"undefined datum\");\n    } else {\n      quadtree.addValue(node, datum);\n    }\n  }\n}\nfunction findQuadtreeMatch(series, point) {\n  const { x, y } = series.contentGroup.transformPoint(point.x, point.y);\n  const { nearest, distanceSquared: distanceSquared3 } = series.getQuadTree().find(x, y);\n  if (nearest !== void 0) {\n    return { datum: nearest.value, distance: Math.sqrt(distanceSquared3) };\n  }\n  return void 0;\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/abstractBarSeries.ts\nvar AbstractBarSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.direction = \"vertical\";\n  }\n};\n__decorateClass([\n  Validate(DIRECTION)\n], AbstractBarSeriesProperties.prototype, \"direction\", 2);\nvar AbstractBarSeries = class extends CartesianSeries {\n  constructor() {\n    super(...arguments);\n    /**\n     * Used to get the position of bars within each group.\n     */\n    this.groupScale = new BandScale();\n    this.smallestDataInterval = void 0;\n    this.largestDataInterval = void 0;\n  }\n  getBandScalePadding() {\n    return { inner: 0.3, outer: 0.15 };\n  }\n  shouldFlipXY() {\n    return !this.isVertical();\n  }\n  isVertical() {\n    return this.properties.direction === \"vertical\";\n  }\n  getBarDirection() {\n    return this.shouldFlipXY() ? \"x\" /* X */ : \"y\" /* Y */;\n  }\n  getCategoryDirection() {\n    return this.shouldFlipXY() ? \"y\" /* Y */ : \"x\" /* X */;\n  }\n  getValueAxis() {\n    const direction = this.getBarDirection();\n    return this.axes[direction];\n  }\n  getCategoryAxis() {\n    const direction = this.getCategoryDirection();\n    return this.axes[direction];\n  }\n  updateGroupScale(xAxis) {\n    const {\n      groupScale,\n      smallestDataInterval,\n      ctx: { seriesStateManager }\n    } = this;\n    const xScale = xAxis.scale;\n    const xBandWidth = ContinuousScale.is(xScale) ? xScale.calcBandwidth(smallestDataInterval) : xScale.bandwidth;\n    const domain = [];\n    const { index: groupIndex, visibleGroupCount } = seriesStateManager.getVisiblePeerGroupIndex(this);\n    for (let groupIdx = 0; groupIdx < visibleGroupCount; groupIdx++) {\n      domain.push(String(groupIdx));\n    }\n    groupScale.domain = domain;\n    groupScale.range = [0, xBandWidth ?? 0];\n    if (xAxis instanceof CategoryAxis) {\n      groupScale.paddingInner = xAxis.groupPaddingInner;\n    } else if (xAxis instanceof GroupedCategoryAxis) {\n      groupScale.padding = 0.1;\n    } else {\n      groupScale.padding = 0;\n    }\n    groupScale.round = groupScale.padding !== 0;\n    const barWidth = groupScale.bandwidth >= 1 ? (\n      // Pixel-rounded value for low-volume bar charts.\n      groupScale.bandwidth\n    ) : (\n      // Handle high-volume bar charts gracefully.\n      groupScale.rawBandwidth\n    );\n    return { barWidth, groupIndex };\n  }\n  resolveKeyDirection(direction) {\n    if (this.getBarDirection() === \"x\" /* X */) {\n      if (direction === \"x\" /* X */) {\n        return \"y\" /* Y */;\n      }\n      return \"x\" /* X */;\n    }\n    return direction;\n  }\n  initQuadTree(quadtree) {\n    addHitTestersToQuadtree(quadtree, this.datumNodesIter());\n  }\n  pickNodeClosestDatum(point) {\n    return findQuadtreeMatch(this, point);\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/barSeriesProperties.ts\nvar BarSeriesLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.placement = \"inside\";\n  }\n};\n__decorateClass([\n  Validate(PLACEMENT)\n], BarSeriesLabel.prototype, \"placement\", 2);\nvar BarSeriesProperties = class extends AbstractBarSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"#c16068\";\n    this.fillOpacity = 1;\n    this.stroke = \"#874349\";\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.crisp = void 0;\n    this.shadow = new DropShadow();\n    this.label = new BarSeriesLabel();\n    this.tooltip = new SeriesTooltip();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], BarSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING)\n], BarSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"yFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BarSeriesProperties.prototype, \"stackGroup\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], BarSeriesProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], BarSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], BarSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], BarSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], BarSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], BarSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], BarSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], BarSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], BarSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(BOOLEAN, { optional: true })\n], BarSeriesProperties.prototype, \"crisp\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], BarSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(OBJECT, { optional: true })\n], BarSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BarSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BarSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/barUtil.ts\nfunction updateRect(rect, config) {\n  rect.crisp = config.crisp ?? true;\n  rect.fill = config.fill;\n  rect.stroke = config.stroke;\n  rect.strokeWidth = config.strokeWidth;\n  rect.fillOpacity = config.fillOpacity;\n  rect.strokeOpacity = config.strokeOpacity;\n  rect.lineDash = config.lineDash;\n  rect.lineDashOffset = config.lineDashOffset;\n  rect.fillShadow = config.fillShadow;\n  rect.topLeftCornerRadius = config.topLeftCornerRadius !== false ? config.cornerRadius ?? 0 : 0;\n  rect.topRightCornerRadius = config.topRightCornerRadius !== false ? config.cornerRadius ?? 0 : 0;\n  rect.bottomRightCornerRadius = config.bottomRightCornerRadius !== false ? config.cornerRadius ?? 0 : 0;\n  rect.bottomLeftCornerRadius = config.bottomLeftCornerRadius !== false ? config.cornerRadius ?? 0 : 0;\n  rect.visible = config.visible ?? true;\n}\nfunction getRectConfig({\n  datum,\n  isHighlighted,\n  style,\n  highlightStyle,\n  itemStyler,\n  seriesId,\n  ctx: { callbackCache },\n  ...opts\n}) {\n  const {\n    fill,\n    fillOpacity,\n    stroke,\n    strokeWidth,\n    strokeOpacity,\n    lineDash,\n    lineDashOffset,\n    cornerRadius = 0\n  } = mergeDefaults(isHighlighted && highlightStyle, style);\n  let format;\n  if (itemStyler) {\n    format = callbackCache.call(itemStyler, {\n      datum: datum.datum,\n      xKey: datum.xKey,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      cornerRadius,\n      highlighted: isHighlighted,\n      seriesId,\n      ...opts\n    });\n  }\n  return {\n    fill: format?.fill ?? fill,\n    fillOpacity: format?.fillOpacity ?? fillOpacity,\n    stroke: format?.stroke ?? stroke,\n    strokeWidth: format?.strokeWidth ?? strokeWidth,\n    strokeOpacity: format?.strokeOpacity ?? strokeOpacity,\n    lineDash: format?.lineDash ?? lineDash,\n    lineDashOffset: format?.lineDashOffset ?? lineDashOffset,\n    cornerRadius: format?.cornerRadius ?? cornerRadius,\n    topLeftCornerRadius: style.topLeftCornerRadius,\n    topRightCornerRadius: style.topRightCornerRadius,\n    bottomRightCornerRadius: style.bottomRightCornerRadius,\n    bottomLeftCornerRadius: style.bottomLeftCornerRadius,\n    fillShadow: style.fillShadow\n  };\n}\nfunction checkCrisp(scale2, visibleRange, smallestDataInterval, largestDataInterval) {\n  if (visibleRange != null) {\n    const [visibleMin, visibleMax] = visibleRange;\n    const isZoomed = visibleMin !== 0 || visibleMax !== 1;\n    if (isZoomed)\n      return false;\n  }\n  if (ContinuousScale.is(scale2)) {\n    const spacing = scale2.calcBandwidth(largestDataInterval) - scale2.calcBandwidth(smallestDataInterval);\n    if (spacing > 0 && spacing < 1)\n      return false;\n  }\n  return true;\n}\nvar isDatumNegative = (datum) => {\n  return isNegative(datum.yValue ?? 0);\n};\nfunction collapsedStartingBarPosition(isVertical, axes, mode) {\n  const { startingX, startingY } = getStartingValues(isVertical, axes);\n  const calculate = (datum, prevDatum) => {\n    let x = isVertical ? datum.x : startingX;\n    let y = isVertical ? startingY : datum.y;\n    let width = isVertical ? datum.width : 0;\n    let height = isVertical ? 0 : datum.height;\n    const { opacity } = datum;\n    if (prevDatum && (isNaN(x) || isNaN(y))) {\n      ({ x, y } = prevDatum);\n      width = isVertical ? prevDatum.width : 0;\n      height = isVertical ? 0 : prevDatum.height;\n      if (isVertical && !isDatumNegative(prevDatum)) {\n        y += prevDatum.height;\n      } else if (!isVertical && isDatumNegative(prevDatum)) {\n        x += prevDatum.width;\n      }\n    }\n    let clipBBox;\n    if (datum.clipBBox == null) {\n      clipBBox = void 0;\n    } else if (isDatumNegative(datum)) {\n      clipBBox = isVertical ? new BBox(x, y - height, width, height) : new BBox(x - width, y, width, height);\n    } else {\n      clipBBox = new BBox(x, y, width, height);\n    }\n    return { x, y, width, height, clipBBox, opacity };\n  };\n  return { isVertical, calculate, mode };\n}\nfunction midpointStartingBarPosition(isVertical, mode) {\n  return {\n    isVertical,\n    calculate: (datum) => {\n      return {\n        x: isVertical ? datum.x : datum.x + datum.width / 2,\n        y: isVertical ? datum.y + datum.height / 2 : datum.y,\n        width: isVertical ? datum.width : 0,\n        height: isVertical ? 0 : datum.height,\n        clipBBox: datum.clipBBox,\n        opacity: datum.opacity\n      };\n    },\n    mode\n  };\n}\nfunction prepareBarAnimationFunctions(initPos) {\n  const isRemoved = (datum) => datum == null || isNaN(datum.x) || isNaN(datum.y);\n  const fromFn = (rect, datum, status) => {\n    if (status === \"updated\" && isRemoved(datum)) {\n      status = \"removed\";\n    } else if (status === \"updated\" && isRemoved(rect.previousDatum)) {\n      status = \"added\";\n    }\n    let source;\n    if (status === \"added\" && rect.previousDatum == null && initPos.mode === \"fade\") {\n      source = { ...resetBarSelectionsFn(rect, datum), opacity: 0 };\n    } else if (status === \"unknown\" || status === \"added\") {\n      source = initPos.calculate(datum, rect.previousDatum);\n    } else {\n      source = {\n        x: rect.x,\n        y: rect.y,\n        width: rect.width,\n        height: rect.height,\n        clipBBox: rect.clipBBox,\n        opacity: rect.opacity\n      };\n    }\n    const phase = NODE_UPDATE_STATE_TO_PHASE_MAPPING[status];\n    return { ...source, phase };\n  };\n  const toFn = (rect, datum, status) => {\n    let source;\n    if (status === \"removed\" && rect.datum == null && initPos.mode === \"fade\") {\n      source = { ...resetBarSelectionsFn(rect, datum), opacity: 0 };\n    } else if (status === \"removed\" || isRemoved(datum)) {\n      source = initPos.calculate(datum, rect.previousDatum);\n    } else {\n      source = {\n        x: datum.x,\n        y: datum.y,\n        width: datum.width,\n        height: datum.height,\n        clipBBox: datum.clipBBox,\n        opacity: datum.opacity\n      };\n    }\n    return source;\n  };\n  return { toFn, fromFn };\n}\nfunction getStartingValues(isVertical, axes) {\n  const axis = axes[isVertical ? \"y\" /* Y */ : \"x\" /* X */];\n  let startingX = Infinity;\n  let startingY = 0;\n  if (!axis) {\n    return { startingX, startingY };\n  }\n  if (isVertical) {\n    startingY = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.max(...axis.range));\n  } else {\n    startingX = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.min(...axis.range));\n  }\n  return { startingX, startingY };\n}\nfunction resetBarSelectionsFn(_node, { x, y, width, height, clipBBox, opacity }) {\n  return { x, y, width, height, clipBBox, opacity };\n}\nfunction computeBarFocusBounds(datum, barGroup, seriesRect) {\n  if (datum === void 0)\n    return void 0;\n  const { x, y, width, height } = datum;\n  return barGroup.inverseTransformBBox(new BBox(x, y, width, height)).clip(seriesRect);\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/labelUtil.ts\nfunction updateLabelNode(textNode, label, labelDatum) {\n  if (label.enabled && labelDatum) {\n    const { x, y, text, textAlign, textBaseline } = labelDatum;\n    const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = label;\n    textNode.setProperties({\n      visible: true,\n      x,\n      y,\n      text,\n      fill,\n      fontStyle,\n      fontWeight,\n      fontSize,\n      fontFamily,\n      textAlign,\n      textBaseline\n    });\n  } else {\n    textNode.visible = false;\n  }\n}\nfunction adjustLabelPlacement({\n  isPositive,\n  isVertical,\n  placement,\n  padding = 0,\n  rect\n}) {\n  let x = rect.x + rect.width / 2;\n  let y = rect.y + rect.height / 2;\n  let textAlign = \"center\";\n  let textBaseline = \"middle\";\n  switch (placement) {\n    case \"start\": {\n      if (isVertical) {\n        y = isPositive ? rect.y + rect.height + padding : rect.y - padding;\n        textBaseline = isPositive ? \"top\" : \"bottom\";\n      } else {\n        x = isPositive ? rect.x - padding : rect.x + rect.width + padding;\n        textAlign = isPositive ? \"start\" : \"end\";\n      }\n      break;\n    }\n    case \"outside\":\n    case \"end\": {\n      if (isVertical) {\n        y = isPositive ? rect.y - padding : rect.y + rect.height + padding;\n        textBaseline = isPositive ? \"bottom\" : \"top\";\n      } else {\n        x = isPositive ? rect.x + rect.width + padding : rect.x - padding;\n        textAlign = isPositive ? \"start\" : \"end\";\n      }\n      break;\n    }\n  }\n  return { x, y, textAlign, textBaseline };\n}\n\n// packages/ag-charts-community/src/chart/series/cartesian/barSeries.ts\nvar BarSeries = class extends AbstractBarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      pathsPerSeries: [],\n      hasHighlightedLabels: true,\n      datumSelectionGarbageCollection: false,\n      animationAlwaysUpdateSelections: true,\n      animationResetFns: {\n        datum: resetBarSelectionsFn,\n        label: resetLabelFn\n      }\n    });\n    this.properties = new BarSeriesProperties();\n  }\n  crossFilteringEnabled() {\n    return this.properties.yFilterKey != null && (this.seriesGrouping == null || this.seriesGrouping.stackIndex === 0);\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || !this.data) {\n      return;\n    }\n    const { seriesGrouping: { groupIndex = this.id } = {}, data = [] } = this;\n    const { xKey, yKey, yFilterKey, normalizedTo } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.getCategoryAxis()?.scale;\n    const yScale = this.getValueAxis()?.scale;\n    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const stackGroupName = `bar-stack-${groupIndex}-yValues`;\n    const stackGroupTrailingName = `${stackGroupName}-trailing`;\n    const extraProps = [];\n    if (isFiniteNumber(normalizedTo)) {\n      extraProps.push(\n        normaliseGroupTo([stackGroupName, stackGroupTrailingName], Math.abs(normalizedTo), \"range\")\n      );\n    }\n    if (animationEnabled && this.processedData) {\n      extraProps.push(diff(this.processedData));\n    }\n    if (animationEnabled) {\n      extraProps.push(animationValidation());\n    }\n    const visibleProps = this.visible ? {} : { forceValue: 0 };\n    const { processedData } = await this.requestDataModel(dataController, data, {\n      props: [\n        keyProperty(xKey, xScaleType, { id: \"xValue\" }),\n        valueProperty(yKey, yScaleType, { id: `yValue-raw`, invalidValue: null, ...visibleProps }),\n        ...this.crossFilteringEnabled() ? [\n          valueProperty(yFilterKey, yScaleType, {\n            id: `yFilterValue`,\n            invalidValue: null,\n            ...visibleProps\n          })\n        ] : [],\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"normal\",\n          \"current\",\n          {\n            id: `yValue-end`,\n            rangeId: `yValue-range`,\n            invalidValue: null,\n            missingValue: 0,\n            groupId: stackGroupName,\n            separateNegative: true,\n            ...visibleProps\n          },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"trailing\",\n          \"current\",\n          {\n            id: `yValue-start`,\n            invalidValue: null,\n            missingValue: 0,\n            groupId: stackGroupTrailingName,\n            separateNegative: true,\n            ...visibleProps\n          },\n          yScaleType\n        ),\n        ...isContinuousX ? [SMALLEST_KEY_INTERVAL, LARGEST_KEY_INTERVAL] : [],\n        ...extraProps\n      ],\n      groupByKeys: true,\n      groupByData: false\n    });\n    this.smallestDataInterval = processedData.reduced?.smallestKeyInterval;\n    this.largestDataInterval = processedData.reduced?.largestKeyInterval;\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel, smallestDataInterval } = this;\n    if (!processedData || !dataModel || processedData.data.length === 0)\n      return [];\n    const categoryAxis = this.getCategoryAxis();\n    const valueAxis = this.getValueAxis();\n    const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    const keys = dataModel.getDomain(this, `xValue`, \"key\", processedData);\n    let yExtent = dataModel.getDomain(this, `yValue-end`, \"value\", processedData);\n    const yFilterExtent = this.crossFilteringEnabled() ? dataModel.getDomain(this, `yFilterValue`, \"value\", processedData) : void 0;\n    if (yFilterExtent != null) {\n      yExtent = [Math.min(yExtent[0], yFilterExtent[0]), Math.max(yExtent[1], yFilterExtent[1])];\n    }\n    if (direction === this.getCategoryDirection()) {\n      if (keyDef?.def.type === \"key\" && keyDef.def.valueType === \"category\") {\n        return keys;\n      }\n      const scalePadding = isFiniteNumber(smallestDataInterval) ? smallestDataInterval * 0.5 : 0;\n      const keysExtent = extent(keys) ?? [NaN, NaN];\n      const d0 = keysExtent[0] + -scalePadding;\n      const d1 = keysExtent[1] + scalePadding;\n      return fixNumericExtent([d0, d1], categoryAxis);\n    } else if (this.getValueAxis() instanceof LogAxis) {\n      return fixNumericExtent(yExtent, valueAxis);\n    } else {\n      const fixedYExtent = [Math.min(0, yExtent[0]), Math.max(0, yExtent[1])];\n      return fixNumericExtent(fixedYExtent, valueAxis);\n    }\n  }\n  async createNodeData() {\n    const { dataModel } = this;\n    const xAxis = this.getCategoryAxis();\n    const yAxis = this.getValueAxis();\n    if (!dataModel || !xAxis || !yAxis || !this.properties.isValid())\n      return;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, cornerRadius, legendItemName, label } = this.properties;\n    const yReversed = yAxis.isReversed();\n    const { barWidth, groupIndex } = this.updateGroupScale(xAxis);\n    const barOffset = ContinuousScale.is(xScale) ? barWidth * -0.5 : 0;\n    const xIndex = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yRawIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-raw`);\n    const yFilterIndex = this.crossFilteringEnabled() ? dataModel.resolveProcessedDataIndexById(this, `yFilterValue`) : void 0;\n    const yStartIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-start`);\n    const yEndIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-end`);\n    const yRangeIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-range`);\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const nodeDatum = ({\n      datum,\n      valueIndex,\n      xValue,\n      yValue,\n      cumulativeValue,\n      phantom,\n      currY,\n      prevY,\n      isPositive,\n      yRange,\n      labelText,\n      crossScale = 1\n    }) => {\n      const x = xScale.convert(xValue);\n      const isUpward = isPositive !== yReversed;\n      const barX = x + groupScale.convert(String(groupIndex)) + barOffset;\n      const y = yScale.convert(currY);\n      const bottomY = yScale.convert(prevY);\n      const barAlongX = this.getBarDirection() === \"x\" /* X */;\n      const bboxHeight = yScale.convert(yRange);\n      const bboxBottom = yScale.convert(0);\n      const xOffset = barWidth * 0.5 * (1 - crossScale);\n      const rect = {\n        x: barAlongX ? Math.min(y, bottomY) : barX + xOffset,\n        y: barAlongX ? barX + xOffset : Math.min(y, bottomY),\n        width: barAlongX ? Math.abs(bottomY - y) : barWidth * crossScale,\n        height: barAlongX ? barWidth * crossScale : Math.abs(bottomY - y)\n      };\n      const clipBBox = new BBox(rect.x, rect.y, rect.width, rect.height);\n      const barRect = {\n        x: barAlongX ? Math.min(bboxBottom, bboxHeight) : barX + xOffset,\n        y: barAlongX ? barX + xOffset : Math.min(bboxBottom, bboxHeight),\n        width: barAlongX ? Math.abs(bboxBottom - bboxHeight) : barWidth * crossScale,\n        height: barAlongX ? barWidth * crossScale : Math.abs(bboxBottom - bboxHeight)\n      };\n      const {\n        fontStyle: labelFontStyle,\n        fontWeight: labelFontWeight,\n        fontSize: labelFontSize,\n        fontFamily: labelFontFamily,\n        color: labelColor,\n        placement\n      } = label;\n      const lengthRatioMultiplier = this.shouldFlipXY() ? rect.height : rect.width;\n      return {\n        series: this,\n        itemId: phantom ? createDatumId(yKey, phantom) : yKey,\n        datum,\n        valueIndex,\n        cumulativeValue,\n        phantom,\n        xValue,\n        yValue,\n        yKey,\n        xKey,\n        capDefaults: {\n          lengthRatioMultiplier,\n          lengthMax: lengthRatioMultiplier\n        },\n        x: barRect.x,\n        y: barRect.y,\n        width: barRect.width,\n        height: barRect.height,\n        midPoint: { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 },\n        fill,\n        stroke,\n        opacity: 1,\n        strokeWidth,\n        cornerRadius,\n        topLeftCornerRadius: barAlongX !== isUpward,\n        topRightCornerRadius: isUpward,\n        bottomRightCornerRadius: barAlongX === isUpward,\n        bottomLeftCornerRadius: !isUpward,\n        clipBBox,\n        label: labelText != null ? {\n          text: labelText,\n          fill: labelColor,\n          fontStyle: labelFontStyle,\n          fontWeight: labelFontWeight,\n          fontSize: labelFontSize,\n          fontFamily: labelFontFamily,\n          ...adjustLabelPlacement({\n            isPositive,\n            isVertical: !barAlongX,\n            placement,\n            rect\n          })\n        } : void 0,\n        missing: yValue == null,\n        focusable: !phantom\n      };\n    };\n    const { groupScale, processedData } = this;\n    const phantomNodes = [];\n    const nodes = [];\n    const labels = [];\n    processedData?.data.forEach(({ keys, datum: seriesDatum, values, aggValues }) => {\n      values.forEach((value, valueIndex) => {\n        const xValue = keys[xIndex];\n        const yRawValue = value[yRawIndex];\n        const yStart = Number(value[yStartIndex]);\n        const yFilterValue = yFilterIndex != null ? Number(value[yFilterIndex]) : void 0;\n        const yEnd = Number(value[yEndIndex]);\n        const isPositive = yRawValue >= 0 && !Object.is(yRawValue, -0);\n        const yRange = aggValues?.[yRangeIndex][isPositive ? 1 : 0] ?? 0;\n        if (!Number.isFinite(yEnd))\n          return;\n        if (yFilterValue != null && !Number.isFinite(yFilterValue))\n          return;\n        const labelText = yRawValue != null ? this.getLabelText(\n          this.properties.label,\n          {\n            datum: seriesDatum[valueIndex],\n            value: yFilterValue ?? yRawValue,\n            xKey,\n            yKey,\n            xName,\n            yName,\n            legendItemName\n          },\n          (v) => isFiniteNumber(v) ? v.toFixed(2) : String(v)\n        ) : void 0;\n        const inset = yFilterValue != null && yFilterValue > yRawValue;\n        const nodeData = nodeDatum({\n          datum: seriesDatum[valueIndex],\n          valueIndex,\n          xValue,\n          yValue: yFilterValue ?? yRawValue,\n          cumulativeValue: yFilterValue ?? yEnd,\n          phantom: false,\n          currY: yFilterValue != null ? yStart + yFilterValue : yEnd,\n          prevY: yStart,\n          isPositive,\n          yRange: Math.max(yStart + (yFilterValue ?? -Infinity), yRange),\n          labelText,\n          crossScale: inset ? 0.6 : void 0\n        });\n        nodes.push(nodeData);\n        labels.push(nodeData);\n        if (yFilterValue != null) {\n          const phantomNodeData = nodeDatum({\n            datum: seriesDatum[valueIndex],\n            valueIndex,\n            xValue,\n            yValue: yFilterValue,\n            cumulativeValue: yFilterValue,\n            phantom: true,\n            currY: yEnd,\n            prevY: yStart,\n            isPositive,\n            yRange,\n            labelText: void 0,\n            crossScale: void 0\n          });\n          phantomNodes.push(phantomNodeData);\n        }\n      });\n    });\n    return {\n      itemId: yKey,\n      nodeData: phantomNodes.length > 0 ? [...phantomNodes, ...nodes] : nodes,\n      labelData: labels,\n      scales: this.calculateScaling(),\n      visible: this.visible || animationEnabled\n    };\n  }\n  nodeFactory() {\n    return new Rect();\n  }\n  getHighlightData(nodeData, highlightedItem) {\n    const highlightItem = nodeData.find(\n      (nodeDatum) => nodeDatum.datum === highlightedItem.datum && !nodeDatum.phantom\n    );\n    return highlightItem != null ? [highlightItem] : void 0;\n  }\n  async updateDatumSelection(opts) {\n    return opts.datumSelection.update(\n      opts.nodeData,\n      void 0,\n      (datum) => createDatumId(datum.xValue, datum.valueIndex, datum.phantom)\n    );\n  }\n  async updateDatumNodes(opts) {\n    if (!this.properties.isValid()) {\n      return;\n    }\n    const {\n      yKey,\n      stackGroup,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      itemStyler,\n      shadow,\n      highlightStyle: { item: itemHighlightStyle }\n    } = this.properties;\n    const xAxis = this.axes[\"x\" /* X */];\n    const crisp = this.properties.crisp ?? checkCrisp(xAxis?.scale, xAxis?.visibleRange, this.smallestDataInterval, this.largestDataInterval);\n    const categoryAlongX = this.getCategoryDirection() === \"x\" /* X */;\n    const style = {\n      fill,\n      stroke,\n      lineDash,\n      lineDashOffset,\n      fillShadow: shadow,\n      strokeWidth: this.getStrokeWidth(strokeWidth),\n      fillOpacity: 0,\n      strokeOpacity: 0\n    };\n    const rectParams = {\n      datum: void 0,\n      ctx: this.ctx,\n      seriesId: this.id,\n      isHighlighted: opts.isHighlight,\n      highlightStyle: itemHighlightStyle,\n      yKey,\n      style,\n      itemStyler,\n      stackGroup\n    };\n    opts.datumSelection.each((rect, datum) => {\n      style.fillOpacity = fillOpacity * (datum.phantom ? 0.2 : 1);\n      style.strokeOpacity = strokeOpacity * (datum.phantom ? 0.2 : 1);\n      style.cornerRadius = datum.cornerRadius;\n      style.topLeftCornerRadius = datum.topLeftCornerRadius;\n      style.topRightCornerRadius = datum.topRightCornerRadius;\n      style.bottomRightCornerRadius = datum.bottomRightCornerRadius;\n      style.bottomLeftCornerRadius = datum.bottomLeftCornerRadius;\n      const visible = categoryAlongX ? (datum.clipBBox?.width ?? datum.width) > 0 : (datum.clipBBox?.height ?? datum.height) > 0;\n      rectParams.datum = datum;\n      const config = getRectConfig(rectParams);\n      config.crisp = crisp;\n      config.visible = visible;\n      updateRect(rect, config);\n    });\n  }\n  async updateLabelSelection(opts) {\n    const data = this.isLabelEnabled() ? opts.labelData : [];\n    return opts.labelSelection.update(data, (text) => {\n      text.pointerEvents = 1 /* None */;\n    });\n  }\n  async updateLabelNodes(opts) {\n    opts.labelSelection.each((textNode, datum) => {\n      updateLabelNode(textNode, this.properties.label, datum.label);\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const {\n      id: seriesId,\n      processedData,\n      ctx: { callbackCache }\n    } = this;\n    const xAxis = this.getCategoryAxis();\n    const yAxis = this.getValueAxis();\n    if (!processedData || !this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, tooltip, itemStyler, stackGroup, legendItemName } = this.properties;\n    const { xValue, yValue, datum, itemId } = nodeDatum;\n    const xString = xAxis.formatDatum(xValue);\n    const yString = yAxis.formatDatum(yValue);\n    const title = sanitizeHtml(yName);\n    const content = sanitizeHtml(xString + \": \" + yString);\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        seriesId,\n        datum,\n        xKey,\n        yKey,\n        stackGroup,\n        fill,\n        stroke,\n        strokeWidth: this.getStrokeWidth(strokeWidth),\n        highlighted: false,\n        cornerRadius: this.properties.cornerRadius,\n        fillOpacity: this.properties.fillOpacity,\n        strokeOpacity: this.properties.strokeOpacity,\n        lineDash: this.properties.lineDash ?? [],\n        lineDashOffset: this.properties.lineDashOffset\n      });\n    }\n    const color = format?.fill ?? fill;\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        seriesId,\n        itemId,\n        datum,\n        xKey,\n        yKey,\n        xName,\n        yName,\n        stackGroup,\n        title,\n        color,\n        legendItemName,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { showInLegend } = this.properties;\n    if (legendType !== \"category\" || !this.data?.length || !this.properties.isValid() || !showInLegend) {\n      return [];\n    }\n    const { yKey, yName, fill, stroke, strokeWidth, fillOpacity, strokeOpacity, legendItemName, visible } = this.properties;\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: { text: legendItemName ?? yName ?? yKey },\n        symbols: [{ marker: { fill, fillOpacity, stroke, strokeWidth, strokeOpacity } }],\n        legendItemName\n      }\n    ];\n  }\n  animateEmptyUpdateReady({ datumSelection, labelSelection, annotationSelections }) {\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, \"normal\"));\n    fromToMotion(this.id, \"nodes\", this.ctx.animationManager, [datumSelection], fns);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n    seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n  }\n  animateWaitingUpdateReady(data) {\n    const { datumSelection, labelSelection, annotationSelections, previousContextData } = data;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const dataDiff = this.processedData?.reduced?.diff;\n    const mode = previousContextData == null ? \"fade\" : \"normal\";\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.isVertical(), this.axes, mode));\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      this.ctx.animationManager,\n      [datumSelection],\n      fns,\n      (_, datum) => createDatumId(datum.xValue, datum.valueIndex, datum.phantom),\n      dataDiff\n    );\n    const hasMotion = dataDiff?.changed ?? true;\n    if (hasMotion) {\n      seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n      seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n    }\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  computeFocusBounds({ datumIndex, seriesRect }) {\n    const datumBox = this.contextNodeData?.nodeData[datumIndex].clipBBox;\n    return computeBarFocusBounds(datumBox, this.contentGroup, seriesRect);\n  }\n};\nBarSeries.className = \"BarSeries\";\nBarSeries.type = \"bar\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/barSeriesModule.ts\nvar BarSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"bar\",\n  moduleFactory: (ctx) => new BarSeries(ctx),\n  stackable: true,\n  groupable: true,\n  tooltipDefaults: { range: \"exact\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    },\n    {\n      type: \"category\" /* CATEGORY */,\n      position: \"bottom\" /* BOTTOM */\n    }\n  ],\n  swapDefaultAxesCondition: (series) => series?.direction === \"horizontal\",\n  themeTemplate: {\n    series: {\n      direction: \"vertical\",\n      fillOpacity: 1,\n      strokeWidth: 0,\n      lineDash: [0],\n      lineDashOffset: 0,\n      label: {\n        enabled: false,\n        fontWeight: \"normal\" /* NORMAL */,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n        placement: \"inside\"\n      },\n      shadow: {\n        enabled: false,\n        color: DEFAULT_SHADOW_COLOUR,\n        xOffset: 3,\n        yOffset: 3,\n        blur: 5\n      },\n      errorBar: {\n        cap: {\n          lengthRatio: 0.3\n        }\n      }\n    }\n  },\n  paletteFactory: singleSeriesPaletteFactory\n};\n\n// packages/ag-charts-community/src/scale/colorScale.ts\nvar convertColorStringToOklcha = (v) => {\n  const color = Color.fromString(v);\n  const [l, c, h] = Color.RGBtoOKLCH(color.r, color.g, color.b);\n  return { l, c, h, a: color.a };\n};\nvar delta = 1e-6;\nvar isAchromatic = (x) => x.c < delta || x.l < delta || x.l > 1 - delta;\nvar interpolateOklch = (x, y, d) => {\n  d = clamp(0, d, 1);\n  let h;\n  if (isAchromatic(x)) {\n    h = y.h;\n  } else if (isAchromatic(y)) {\n    h = x.h;\n  } else {\n    const xH = x.h;\n    let yH = y.h;\n    const deltaH = y.h - x.h;\n    if (deltaH > 180) {\n      yH -= 360;\n    } else if (deltaH < -180) {\n      yH += 360;\n    }\n    h = xH * (1 - d) + yH * d;\n  }\n  const c = x.c * (1 - d) + y.c * d;\n  const l = x.l * (1 - d) + y.l * d;\n  const a = x.a * (1 - d) + y.a * d;\n  return Color.fromOKLCH(l, c, h, a);\n};\nvar ColorScale = class {\n  constructor() {\n    this.type = \"color\";\n    this.invalid = true;\n    this.domain = [0, 1];\n    this.range = [\"red\", \"blue\"];\n    this.parsedRange = this.range.map(convertColorStringToOklcha);\n  }\n  update() {\n    const { domain, range: range3 } = this;\n    if (domain.length < 2) {\n      Logger.warnOnce(\"`colorDomain` should have at least 2 values.\");\n      if (domain.length === 0) {\n        domain.push(0, 1);\n      } else if (domain.length === 1) {\n        domain.push(domain[0] + 1);\n      }\n    }\n    for (let i = 1; i < domain.length; i++) {\n      const a = domain[i - 1];\n      const b = domain[i];\n      if (a >= b) {\n        Logger.warnOnce(\"`colorDomain` values should be supplied in ascending order.\");\n        domain.sort((a2, b2) => a2 - b2);\n        break;\n      }\n    }\n    if (range3.length < domain.length) {\n      for (let i = range3.length; i < domain.length; i++) {\n        range3.push(range3.length > 0 ? range3[0] : \"black\");\n      }\n    }\n    this.parsedRange = this.range.map(convertColorStringToOklcha);\n  }\n  convert(x) {\n    this.refresh();\n    const { domain, range: range3, parsedRange } = this;\n    const d0 = domain[0];\n    const d1 = domain.at(-1);\n    const r0 = range3[0];\n    const r1 = range3[range3.length - 1];\n    if (x <= d0) {\n      return r0;\n    }\n    if (x >= d1) {\n      return r1;\n    }\n    let index;\n    let q;\n    if (domain.length === 2) {\n      const t = (x - d0) / (d1 - d0);\n      const step = 1 / (range3.length - 1);\n      index = range3.length <= 2 ? 0 : Math.min(Math.floor(t * (range3.length - 1)), range3.length - 2);\n      q = (t - index * step) / step;\n    } else {\n      for (index = 0; index < domain.length - 2; index++) {\n        if (x < domain[index + 1]) {\n          break;\n        }\n      }\n      const a = domain[index];\n      const b = domain[index + 1];\n      q = (x - a) / (b - a);\n    }\n    const c0 = parsedRange[index];\n    const c1 = parsedRange[index + 1];\n    return interpolateOklch(c0, c1, q).toRgbaString();\n  }\n  refresh() {\n    if (!this.invalid)\n      return;\n    this.invalid = false;\n    this.update();\n    if (this.invalid) {\n      Logger.warnOnce(\"Expected update to not invalidate scale\");\n    }\n  }\n};\n__decorateClass([\n  Invalidating\n], ColorScale.prototype, \"domain\", 2);\n__decorateClass([\n  Invalidating\n], ColorScale.prototype, \"range\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesProperties.ts\nvar BubbleSeriesMarker = class extends SeriesMarker {\n  constructor() {\n    super(...arguments);\n    this.maxSize = 30;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], BubbleSeriesMarker.prototype, \"maxSize\", 2);\n__decorateClass([\n  Validate(NUMBER_ARRAY, { optional: true }),\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], BubbleSeriesMarker.prototype, \"domain\", 2);\nvar BubbleSeriesLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.placement = \"top\";\n  }\n};\n__decorateClass([\n  Validate(LABEL_PLACEMENT)\n], BubbleSeriesLabel.prototype, \"placement\", 2);\nvar BubbleSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.colorRange = [\"#ffff00\", \"#00ff00\", \"#0000ff\"];\n    this.label = new BubbleSeriesLabel();\n    this.tooltip = new SeriesTooltip();\n    // No validation. Not a part of the options contract.\n    this.marker = new BubbleSeriesMarker();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], BubbleSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], BubbleSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], BubbleSeriesProperties.prototype, \"sizeKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"labelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"sizeName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"labelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate(NUMBER_ARRAY, { optional: true })\n], BubbleSeriesProperties.prototype, \"colorDomain\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], BubbleSeriesProperties.prototype, \"colorRange\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], BubbleSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.shape\")\n], BubbleSeriesProperties.prototype, \"shape\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.size\")\n], BubbleSeriesProperties.prototype, \"size\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.maxSize\")\n], BubbleSeriesProperties.prototype, \"maxSize\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.domain\", { optional: true })\n], BubbleSeriesProperties.prototype, \"domain\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fill\", { optional: true })\n], BubbleSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fillOpacity\")\n], BubbleSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.stroke\", { optional: true })\n], BubbleSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeWidth\")\n], BubbleSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeOpacity\")\n], BubbleSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.itemStyler\", { optional: true })\n], BubbleSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BubbleSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], BubbleSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeries.ts\nvar BubbleSeriesNodeEvent = class extends CartesianSeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.sizeKey = series.properties.sizeKey;\n  }\n};\nvar BubbleSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [\n        2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */,\n        3 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      pathsPerSeries: [],\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        label: resetLabelFn,\n        marker: resetMarkerFn\n      }\n    });\n    this.NodeEvent = BubbleSeriesNodeEvent;\n    this.properties = new BubbleSeriesProperties();\n    this.sizeScale = new LinearScale();\n    this.colorScale = new ColorScale();\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || this.data == null || !this.visible)\n      return;\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const colorScaleType = this.colorScale.type;\n    const sizeScaleType = this.sizeScale.type;\n    const { xKey, yKey, sizeKey, labelKey, colorDomain, colorRange, colorKey, marker } = this.properties;\n    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {\n      props: [\n        keyProperty(xKey, xScaleType, { id: \"xKey-raw\" }),\n        keyProperty(yKey, yScaleType, { id: \"yKey-raw\" }),\n        ...labelKey ? [keyProperty(labelKey, \"band\", { id: `labelKey-raw` })] : [],\n        valueProperty(xKey, xScaleType, { id: `xValue` }),\n        valueProperty(yKey, yScaleType, { id: `yValue` }),\n        valueProperty(sizeKey, sizeScaleType, { id: `sizeValue` }),\n        ...colorKey ? [valueProperty(colorKey, colorScaleType, { id: `colorValue` })] : [],\n        ...labelKey ? [valueProperty(labelKey, \"band\", { id: `labelValue` })] : []\n      ]\n    });\n    const sizeKeyIdx = dataModel.resolveProcessedDataIndexById(this, `sizeValue`);\n    const processedSize = processedData.domain.values[sizeKeyIdx] ?? [];\n    this.sizeScale.domain = marker.domain ? marker.domain : processedSize;\n    if (colorKey) {\n      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`);\n      this.colorScale.domain = colorDomain ?? processedData.domain.values[colorKeyIdx] ?? [];\n      this.colorScale.range = colorRange;\n      this.colorScale.update();\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { dataModel, processedData } = this;\n    if (!processedData || !dataModel)\n      return [];\n    const id = direction === \"x\" /* X */ ? `xValue` : `yValue`;\n    const dataDef = dataModel.resolveProcessedDataDefById(this, id);\n    const domain = dataModel.getDomain(this, id, \"value\", processedData);\n    if (dataDef?.def.type === \"value\" && dataDef?.def.valueType === \"category\") {\n      return domain;\n    }\n    const axis = this.axes[direction];\n    return fixNumericExtent(extent(domain), axis);\n  }\n  async createNodeData() {\n    const { axes, dataModel, processedData, colorScale, sizeScale } = this;\n    const { xKey, yKey, sizeKey, labelKey, xName, yName, sizeName, labelName, label, colorKey, marker, visible } = this.properties;\n    const markerShape = getMarker(marker.shape);\n    const { placement } = label;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!(dataModel && processedData && visible && xAxis && yAxis)) {\n      return;\n    }\n    const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`);\n    const sizeDataIdx = sizeKey ? dataModel.resolveProcessedDataIndexById(this, `sizeValue`) : -1;\n    const colorDataIdx = colorKey ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : -1;\n    const labelDataIdx = labelKey ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : -1;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const yOffset = (yScale.bandwidth ?? 0) / 2;\n    const nodeData = [];\n    sizeScale.range = [marker.size, marker.maxSize];\n    const font = label.getFont();\n    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font });\n    for (const { values, datum } of processedData.data ?? []) {\n      const xDatum = values[xDataIdx];\n      const yDatum = values[yDataIdx];\n      const x = xScale.convert(xDatum) + xOffset;\n      const y = yScale.convert(yDatum) + yOffset;\n      const labelText = this.getLabelText(label, {\n        value: labelKey ? values[labelDataIdx] : yDatum,\n        datum,\n        xKey,\n        yKey,\n        sizeKey,\n        labelKey,\n        xName,\n        yName,\n        sizeName,\n        labelName\n      });\n      const size = textMeasurer.measureText(String(labelText));\n      const markerSize = sizeKey ? sizeScale.convert(values[sizeDataIdx]) : marker.size;\n      const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : void 0;\n      nodeData.push({\n        series: this,\n        itemId: yKey,\n        yKey,\n        xKey,\n        datum,\n        xValue: xDatum,\n        yValue: yDatum,\n        sizeValue: values[sizeDataIdx],\n        point: { x, y, size: markerSize },\n        midPoint: { x, y },\n        fill,\n        label: { text: labelText, ...size },\n        marker: markerShape,\n        placement\n      });\n    }\n    return {\n      itemId: yKey,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  getLabelData() {\n    return this.contextNodeData?.labelData ?? [];\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updateMarkerSelection(opts) {\n    const { nodeData, markerSelection } = opts;\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    const data = this.properties.marker.enabled ? nodeData : [];\n    return markerSelection.update(\n      data,\n      void 0,\n      (datum) => createDatumId([datum.xValue, datum.yValue, datum.label.text])\n    );\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, sizeKey, labelKey, marker } = this.properties;\n    const { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = mergeDefaults(\n      highlighted && this.properties.highlightStyle.item,\n      marker.getStyle()\n    );\n    const baseStyle = { size, shape, fill, fillOpacity, stroke, strokeWidth, strokeOpacity };\n    this.sizeScale.range = [marker.size, marker.maxSize];\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, sizeKey, labelKey }, baseStyle);\n    });\n    if (!highlighted) {\n      this.properties.marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    const placedLabels = this.properties.label.enabled ? this.chart?.placeLabels().get(this) ?? [] : [];\n    return opts.labelSelection.update(\n      placedLabels.map((v) => ({\n        ...v.datum,\n        point: {\n          x: v.x,\n          y: v.y,\n          size: v.datum.point.size\n        }\n      }))\n    );\n  }\n  async updateLabelNodes(opts) {\n    const { label } = this.properties;\n    opts.labelSelection.each((text, datum) => {\n      text.text = datum.label.text;\n      text.fill = label.color;\n      text.x = datum.point?.x ?? 0;\n      text.y = datum.point?.y ?? 0;\n      text.fontStyle = label.fontStyle;\n      text.fontWeight = label.fontWeight;\n      text.fontSize = label.fontSize;\n      text.fontFamily = label.fontFamily;\n      text.textAlign = \"left\";\n      text.textBaseline = \"top\";\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, sizeKey, labelKey, xName, yName, sizeName, labelName, marker, tooltip } = this.properties;\n    const title = this.properties.title ?? yName;\n    const baseStyle = mergeDefaults(\n      { fill: nodeDatum.fill, strokeWidth: this.getStrokeWidth(marker.strokeWidth) },\n      marker.getStyle()\n    );\n    const { fill: color = \"gray\" } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, highlighted: false, xKey, yKey, sizeKey, labelKey },\n      baseStyle\n    );\n    const {\n      datum,\n      xValue,\n      yValue,\n      sizeValue,\n      label: { text: labelText },\n      itemId\n    } = nodeDatum;\n    const xString = sanitizeHtml(xAxis.formatDatum(xValue));\n    const yString = sanitizeHtml(yAxis.formatDatum(yValue));\n    let content = `<b>${sanitizeHtml(xName ?? xKey)}</b>: ${xString}<br><b>${sanitizeHtml(yName ?? yKey)}</b>: ${yString}`;\n    if (sizeKey) {\n      content += `<br><b>${sanitizeHtml(sizeName ?? sizeKey)}</b>: ${sanitizeHtml(String(sizeValue))}`;\n    }\n    if (labelKey) {\n      content = `<b>${sanitizeHtml(labelName ?? labelKey)}</b>: ${sanitizeHtml(labelText)}<br>` + content;\n    }\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        sizeKey,\n        sizeName,\n        labelKey,\n        labelName,\n        title,\n        color,\n        seriesId: this.id\n      }\n    );\n  }\n  getLegendData() {\n    if (!this.data?.length || !this.properties.isValid()) {\n      return [];\n    }\n    const { yKey, yName, title, marker, visible } = this.properties;\n    const { shape, fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = marker;\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: title ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape,\n              fill: fill ?? \"rgba(0, 0, 0, 0)\",\n              stroke: stroke ?? \"rgba(0, 0, 0, 0)\",\n              fillOpacity: fillOpacity ?? 1,\n              strokeOpacity: strokeOpacity ?? 1,\n              strokeWidth: strokeWidth ?? 0\n            }\n          }\n        ]\n      }\n    ];\n  }\n  animateEmptyUpdateReady({ markerSelection, labelSelection }) {\n    markerScaleInAnimation(this, this.ctx.animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey, sizeKey, labelKey } = this.properties;\n    return this.getMarkerStyle(this.properties.marker, {\n      datum,\n      xKey,\n      yKey,\n      sizeKey,\n      labelKey,\n      highlighted: false\n    });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nBubbleSeries.className = \"BubbleSeries\";\nBubbleSeries.type = \"bubble\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/bubbleSeriesModule.ts\nvar BubbleSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"bubble\",\n  moduleFactory: (ctx) => new BubbleSeries(ctx),\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"bottom\" /* BOTTOM */\n    },\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      shape: \"circle\",\n      size: 7,\n      maxSize: 30,\n      fillOpacity: 0.8,\n      tooltip: { position: { type: \"node\" } },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      }\n    }\n  },\n  paletteFactory: singleSeriesPaletteFactory\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesProperties.ts\nvar HistogramSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fillOpacity = 1;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.areaPlot = false;\n    this.aggregation = \"sum\";\n    this.shadow = new DropShadow();\n    this.label = new Label();\n    this.tooltip = new SeriesTooltip();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], HistogramSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], HistogramSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(COLOR_STRING, { optional: true })\n], HistogramSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], HistogramSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], HistogramSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], HistogramSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], HistogramSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], HistogramSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], HistogramSeriesProperties.prototype, \"areaPlot\", 2);\n__decorateClass([\n  Validate(ARRAY, { optional: true })\n], HistogramSeriesProperties.prototype, \"bins\", 2);\n__decorateClass([\n  Validate(UNION([\"count\", \"sum\", \"mean\"], \"a histogram aggregation\"))\n], HistogramSeriesProperties.prototype, \"aggregation\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], HistogramSeriesProperties.prototype, \"binCount\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HistogramSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HistogramSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], HistogramSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/histogramSeries.ts\nvar defaultBinCount = 10;\nvar HistogramSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      datumSelectionGarbageCollection: false,\n      animationResetFns: {\n        datum: resetBarSelectionsFn,\n        label: resetLabelFn\n      }\n    });\n    this.properties = new HistogramSeriesProperties();\n    this.calculatedBins = [];\n  }\n  // During processData phase, used to unify different ways of the user specifying\n  // the bins. Returns bins in format[[min1, max1], [min2, max2], ... ].\n  deriveBins(xDomain) {\n    const binStarts = createTicks(xDomain[0], xDomain[1], defaultBinCount);\n    const binSize = tickStep(xDomain[0], xDomain[1], defaultBinCount);\n    const [firstBinEnd] = binStarts;\n    const expandStartToBin = (n) => [n, n + binSize];\n    return [[firstBinEnd - binSize, firstBinEnd], ...binStarts.map(expandStartToBin)];\n  }\n  calculateNiceBins(domain, binCount) {\n    const startGuess = Math.floor(domain[0]);\n    const stop = domain[1];\n    const segments = binCount || 1;\n    const { start, binSize } = this.calculateNiceStart(startGuess, stop, segments);\n    return this.getBins(start, stop, binSize, segments);\n  }\n  getBins(start, stop, step, count) {\n    const bins = [];\n    const precision = this.calculatePrecision(step);\n    for (let i = 0; i < count; i++) {\n      const a = Math.round((start + i * step) * precision) / precision;\n      let b = Math.round((start + (i + 1) * step) * precision) / precision;\n      if (i === count - 1) {\n        b = Math.max(b, stop);\n      }\n      bins[i] = [a, b];\n    }\n    return bins;\n  }\n  calculatePrecision(step) {\n    let precision = 10;\n    if (isFinite(step) && step > 0) {\n      while (step < 1) {\n        precision *= 10;\n        step *= 10;\n      }\n    }\n    return precision;\n  }\n  calculateNiceStart(a, b, segments) {\n    const binSize = Math.abs(b - a) / segments;\n    const order = Math.floor(Math.log10(binSize));\n    const magnitude = Math.pow(10, order);\n    const start = Math.floor(a / magnitude) * magnitude;\n    return {\n      start,\n      binSize\n    };\n  }\n  async processData(dataController) {\n    if (!this.visible) {\n      this.processedData = void 0;\n      this.animationState.transition(\"updateData\");\n    }\n    const { xKey, yKey, areaPlot, aggregation } = this.properties;\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ yScale, xScale });\n    const props = [keyProperty(xKey, xScaleType), SORT_DOMAIN_GROUPS];\n    if (yKey) {\n      let aggProp = groupCount(\"groupAgg\");\n      if (aggregation === \"count\") {\n      } else if (aggregation === \"sum\") {\n        aggProp = groupSum(\"groupAgg\");\n      } else if (aggregation === \"mean\") {\n        aggProp = groupAverage(\"groupAgg\");\n      }\n      if (areaPlot) {\n        aggProp = area(\"groupAgg\", aggProp);\n      }\n      props.push(valueProperty(yKey, yScaleType, { invalidValue: void 0 }), aggProp);\n    } else {\n      let aggProp = groupCount(\"groupAgg\");\n      if (areaPlot) {\n        aggProp = area(\"groupAgg\", aggProp);\n      }\n      props.push(aggProp);\n    }\n    const groupByFn = (dataSet) => {\n      const xExtent = fixNumericExtent(dataSet.domain.keys[0]);\n      if (xExtent.length === 0) {\n        dataSet.domain.groups = [];\n        return () => [];\n      }\n      const bins = isNumber(this.properties.binCount) ? this.calculateNiceBins(xExtent, this.properties.binCount) : this.properties.bins ?? this.deriveBins(xExtent);\n      const binCount = bins.length;\n      this.calculatedBins = [...bins];\n      return (item) => {\n        const xValue = item.keys[0];\n        for (let i = 0; i < binCount; i++) {\n          const nextBin = bins[i];\n          if (xValue >= nextBin[0] && xValue < nextBin[1]) {\n            return nextBin;\n          }\n          if (i === binCount - 1 && xValue <= nextBin[1]) {\n            return nextBin;\n          }\n        }\n        return [];\n      };\n    };\n    if (!this.ctx.animationManager.isSkipped() && this.processedData) {\n      props.push(diff(this.processedData, false));\n    }\n    await this.requestDataModel(dataController, this.data, { props, groupByFn });\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel } = this;\n    if (!processedData || !dataModel || !this.calculatedBins.length)\n      return [];\n    const yDomain = dataModel.getDomain(this, `groupAgg`, \"aggregate\", processedData);\n    const xDomainMin = this.calculatedBins?.[0][0];\n    const xDomainMax = this.calculatedBins?.[(this.calculatedBins?.length ?? 0) - 1][1];\n    if (direction === \"x\" /* X */) {\n      return fixNumericExtent([xDomainMin, xDomainMax]);\n    }\n    return fixNumericExtent(yDomain);\n  }\n  async createNodeData() {\n    const {\n      id: seriesId,\n      axes,\n      processedData,\n      ctx: { callbackCache }\n    } = this;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!xAxis || !yAxis) {\n      return;\n    }\n    const { scale: xScale } = xAxis;\n    const { scale: yScale } = yAxis;\n    const { xKey, yKey, xName, yName, fill, stroke, strokeWidth, cornerRadius } = this.properties;\n    const {\n      formatter: labelFormatter = (params) => String(params.value),\n      fontStyle: labelFontStyle,\n      fontWeight: labelFontWeight,\n      fontSize: labelFontSize,\n      fontFamily: labelFontFamily,\n      color: labelColor\n    } = this.properties.label;\n    const nodeData = [];\n    const context = {\n      itemId: this.properties.yKey ?? this.id,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      animationValid: true,\n      visible: this.visible\n    };\n    if (!this.visible || !processedData || processedData.type !== \"grouped\")\n      return context;\n    processedData.data.forEach((group) => {\n      const {\n        aggValues: [[negativeAgg, positiveAgg]] = [[0, 0]],\n        datum,\n        datum: { length: frequency },\n        keys: domain,\n        keys: [xDomainMin, xDomainMax]\n      } = group;\n      const xMinPx = xScale.convert(xDomainMin);\n      const xMaxPx = xScale.convert(xDomainMax);\n      const total = negativeAgg + positiveAgg;\n      const yZeroPx = yScale.convert(0);\n      const yMaxPx = yScale.convert(total);\n      const w = Math.abs(xMaxPx - xMinPx);\n      const h = Math.abs(yMaxPx - yZeroPx);\n      const x = Math.min(xMinPx, xMaxPx);\n      const y = Math.min(yZeroPx, yMaxPx);\n      let selectionDatumLabel = void 0;\n      if (total !== 0) {\n        selectionDatumLabel = {\n          text: callbackCache.call(labelFormatter, {\n            value: total,\n            datum,\n            seriesId,\n            xKey,\n            yKey,\n            xName,\n            yName\n          }) ?? String(total),\n          fontStyle: labelFontStyle,\n          fontWeight: labelFontWeight,\n          fontSize: labelFontSize,\n          fontFamily: labelFontFamily,\n          fill: labelColor,\n          x: x + w / 2,\n          y: y + h / 2\n        };\n      }\n      const nodeMidPoint = {\n        x: x + w / 2,\n        y: y + h / 2\n      };\n      const yAxisReversed = yAxis.isReversed();\n      nodeData.push({\n        series: this,\n        datum,\n        // required by SeriesNodeDatum, but might not make sense here\n        // since each selection is an aggregation of multiple data.\n        aggregatedValue: total,\n        frequency,\n        domain,\n        yKey,\n        xKey,\n        x,\n        y,\n        xValue: xMinPx,\n        yValue: yMaxPx,\n        width: w,\n        height: h,\n        midPoint: nodeMidPoint,\n        fill,\n        stroke,\n        cornerRadius,\n        topLeftCornerRadius: !yAxisReversed,\n        topRightCornerRadius: !yAxisReversed,\n        bottomRightCornerRadius: yAxisReversed,\n        bottomLeftCornerRadius: yAxisReversed,\n        opacity: 1,\n        strokeWidth,\n        label: selectionDatumLabel\n      });\n    });\n    nodeData.sort((a, b) => a.x - b.x);\n    return context;\n  }\n  nodeFactory() {\n    return new Rect();\n  }\n  async updateDatumSelection(opts) {\n    const { nodeData, datumSelection } = opts;\n    return datumSelection.update(\n      nodeData,\n      (rect) => {\n        rect.tag = 0 /* Bin */;\n        rect.crisp = true;\n      },\n      (datum) => datum.domain.join(\"_\")\n    );\n  }\n  async updateDatumNodes(opts) {\n    const { isHighlight: isDatumHighlighted } = opts;\n    const {\n      fillOpacity: seriesFillOpacity,\n      strokeOpacity,\n      lineDash,\n      lineDashOffset,\n      shadow,\n      highlightStyle: {\n        item: {\n          fill: highlightedFill,\n          fillOpacity: highlightFillOpacity = seriesFillOpacity,\n          stroke: highlightedStroke,\n          strokeWidth: highlightedDatumStrokeWidth\n        }\n      }\n    } = this.properties;\n    opts.datumSelection.each((rect, datum, index) => {\n      const {\n        cornerRadius,\n        topLeftCornerRadius,\n        topRightCornerRadius,\n        bottomRightCornerRadius,\n        bottomLeftCornerRadius\n      } = datum;\n      const strokeWidth = isDatumHighlighted && highlightedDatumStrokeWidth !== void 0 ? highlightedDatumStrokeWidth : datum.strokeWidth;\n      const fillOpacity = isDatumHighlighted ? highlightFillOpacity : seriesFillOpacity;\n      rect.fill = (isDatumHighlighted ? highlightedFill : void 0) ?? datum.fill;\n      rect.stroke = (isDatumHighlighted ? highlightedStroke : void 0) ?? datum.stroke;\n      rect.fillOpacity = fillOpacity;\n      rect.strokeOpacity = strokeOpacity;\n      rect.strokeWidth = strokeWidth;\n      rect.lineDash = lineDash;\n      rect.lineDashOffset = lineDashOffset;\n      rect.topLeftCornerRadius = topLeftCornerRadius ? cornerRadius : 0;\n      rect.topRightCornerRadius = topRightCornerRadius ? cornerRadius : 0;\n      rect.bottomRightCornerRadius = bottomRightCornerRadius ? cornerRadius : 0;\n      rect.bottomLeftCornerRadius = bottomLeftCornerRadius ? cornerRadius : 0;\n      rect.fillShadow = shadow;\n      rect.zIndex = isDatumHighlighted ? Series.highlightedZIndex : index;\n      rect.visible = datum.height > 0;\n    });\n  }\n  async updateLabelSelection(opts) {\n    const { labelData, labelSelection } = opts;\n    return labelSelection.update(labelData, (text) => {\n      text.tag = 1 /* Label */;\n      text.pointerEvents = 1 /* None */;\n      text.textAlign = \"center\";\n      text.textBaseline = \"middle\";\n    });\n  }\n  async updateLabelNodes(opts) {\n    const labelEnabled = this.isLabelEnabled();\n    opts.labelSelection.each((text, datum) => {\n      const label = datum.label;\n      if (label && labelEnabled) {\n        text.text = label.text;\n        text.x = label.x;\n        text.y = label.y;\n        text.fontStyle = label.fontStyle;\n        text.fontWeight = label.fontWeight;\n        text.fontSize = label.fontSize;\n        text.fontFamily = label.fontFamily;\n        text.fill = label.fill;\n        text.visible = true;\n      } else {\n        text.visible = false;\n      }\n    });\n  }\n  initQuadTree(quadtree) {\n    addHitTestersToQuadtree(quadtree, childrenIter(this.contentGroup.children[0]));\n  }\n  pickNodeClosestDatum(point) {\n    return findQuadtreeMatch(this, point);\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, xName, yName, fill: color, aggregation, tooltip } = this.properties;\n    const {\n      aggregatedValue,\n      frequency,\n      domain: [rangeMin, rangeMax],\n      itemId\n    } = nodeDatum;\n    const title = `${sanitizeHtml(xName ?? xKey)}: ${xAxis.formatDatum(rangeMin)} - ${xAxis.formatDatum(rangeMax)}`;\n    let content = yKey ? `<b>${sanitizeHtml(yName ?? yKey)} (${aggregation})</b>: ${yAxis.formatDatum(aggregatedValue)}<br>` : \"\";\n    content += `<b>Frequency</b>: ${frequency}`;\n    const defaults = {\n      title,\n      backgroundColor: color,\n      content\n    };\n    return tooltip.toTooltipHtml(defaults, {\n      datum: {\n        data: nodeDatum.datum,\n        aggregatedValue: nodeDatum.aggregatedValue,\n        domain: nodeDatum.domain,\n        frequency: nodeDatum.frequency\n      },\n      itemId,\n      xKey,\n      xName,\n      yKey,\n      yName,\n      color,\n      title,\n      seriesId: this.id\n    });\n  }\n  getLegendData(legendType) {\n    if (!this.data?.length || legendType !== \"category\") {\n      return [];\n    }\n    const { xKey, yName, fill, fillOpacity, stroke, strokeWidth, strokeOpacity, visible } = this.properties;\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: xKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: yName ?? xKey ?? \"Frequency\"\n        },\n        symbols: [\n          {\n            marker: {\n              fill: fill ?? \"rgba(0, 0, 0, 0)\",\n              stroke: stroke ?? \"rgba(0, 0, 0, 0)\",\n              fillOpacity,\n              strokeOpacity,\n              strokeWidth\n            }\n          }\n        ]\n      }\n    ];\n  }\n  animateEmptyUpdateReady({ datumSelection, labelSelection }) {\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, \"normal\"));\n    fromToMotion(this.id, \"datums\", this.ctx.animationManager, [datumSelection], fns);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n  }\n  animateWaitingUpdateReady(data) {\n    const dataDiff = this.processedData?.reduced?.diff;\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes, \"normal\"));\n    fromToMotion(\n      this.id,\n      \"datums\",\n      this.ctx.animationManager,\n      [data.datumSelection],\n      fns,\n      (_, datum) => createDatumId(datum.domain),\n      dataDiff\n    );\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, data.labelSelection);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  computeFocusBounds({ datumIndex, seriesRect }) {\n    return computeBarFocusBounds(this.contextNodeData?.nodeData[datumIndex], this.contentGroup, seriesRect);\n  }\n};\nHistogramSeries.className = \"HistogramSeries\";\nHistogramSeries.type = \"histogram\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/histogramSeriesModule.ts\nvar HistogramSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"histogram\",\n  moduleFactory: (ctx) => new HistogramSeries(ctx),\n  tooltipDefaults: { range: \"exact\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"bottom\" /* BOTTOM */\n    },\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      strokeWidth: 1,\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      lineDash: [0],\n      lineDashOffset: 0,\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR\n      },\n      shadow: {\n        enabled: false,\n        color: DEFAULT_SHADOW_COLOUR,\n        xOffset: 3,\n        yOffset: 3,\n        blur: 5\n      }\n    }\n  },\n  paletteFactory: ({ takeColors }) => {\n    const {\n      fills: [fill],\n      strokes: [stroke]\n    } = takeColors(1);\n    return { fill, stroke };\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesProperties.ts\nvar LineSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.stroke = \"#874349\";\n    this.strokeWidth = 2;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.interpolation = new InterpolationProperties();\n    this.marker = new SeriesMarker();\n    this.label = new Label();\n    this.tooltip = new SeriesTooltip();\n    this.connectMissingData = false;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], LineSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], LineSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"stackGroup\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], LineSeriesProperties.prototype, \"normalizedTo\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], LineSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate(COLOR_STRING)\n], LineSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LineSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(RATIO)\n], LineSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], LineSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], LineSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"interpolation\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"marker\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], LineSeriesProperties.prototype, \"tooltip\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], LineSeriesProperties.prototype, \"connectMissingData\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineSeries.ts\nvar LineSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      hasMarkers: true,\n      pickModes: [\n        2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */,\n        3 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        path: buildResetPathFn({ getVisible: () => this.visible, getOpacity: () => this.getOpacity() }),\n        label: resetLabelFn,\n        marker: (node, datum) => ({ ...resetMarkerFn(node), ...resetMarkerPositionFn(node, datum) })\n      }\n    });\n    this.properties = new LineSeriesProperties();\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    const { data, visible, seriesGrouping: { groupIndex = this.id, stackCount = 1 } = {} } = this;\n    const { xKey, yKey, connectMissingData, normalizedTo } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { isContinuousX, xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const common = { invalidValue: null };\n    if (connectMissingData && stackCount > 1) {\n      common.invalidValue = 0;\n    }\n    if (!visible) {\n      common.forceValue = 0;\n    }\n    const props = [];\n    if (!isContinuousX) {\n      props.push(keyProperty(xKey, xScaleType, { id: \"xKey\" }));\n    }\n    props.push(\n      valueProperty(xKey, xScaleType, { id: \"xValue\" }),\n      valueProperty(yKey, yScaleType, {\n        id: `yValueRaw`,\n        ...common,\n        invalidValue: void 0\n      })\n    );\n    if (stackCount > 1) {\n      const ids = [\n        `line-stack-${groupIndex}-yValues`,\n        `line-stack-${groupIndex}-yValues-trailing`,\n        `line-stack-${groupIndex}-yValues-marker`\n      ];\n      props.push(\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window\",\n          \"current\",\n          {\n            id: `yValueEnd`,\n            ...common,\n            groupId: ids[0]\n          },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"window-trailing\",\n          \"current\",\n          {\n            id: `yValueStart`,\n            ...common,\n            groupId: ids[1]\n          },\n          yScaleType\n        ),\n        ...groupAccumulativeValueProperty(\n          yKey,\n          \"normal\",\n          \"current\",\n          {\n            id: `yValueCumulative`,\n            ...common,\n            groupId: ids[2]\n          },\n          yScaleType\n        )\n      );\n      if (isDefined(normalizedTo)) {\n        props.push(normaliseGroupTo([ids[0], ids[1], ids[2]], normalizedTo, \"range\"));\n      }\n    }\n    if (animationEnabled) {\n      props.push(animationValidation(isContinuousX ? [\"xValue\"] : void 0));\n      if (this.processedData) {\n        props.push(diff(this.processedData));\n      }\n    }\n    await this.requestDataModel(dataController, data, { props });\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { processedData, dataModel, axes } = this;\n    if (!processedData || !dataModel || processedData.data.length === 0)\n      return [];\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    const xDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    if (direction === \"x\" /* X */) {\n      const domain = dataModel.getDomain(this, `xValue`, \"value\", processedData);\n      if (xDef?.def.type === \"value\" && xDef.def.valueType === \"category\") {\n        return domain;\n      }\n      return fixNumericExtent(extent(domain), xAxis);\n    } else {\n      const stackCount = this.seriesGrouping?.stackCount ?? 1;\n      const domain = stackCount > 1 ? dataModel.getDomain(this, `yValueEnd`, \"value\", processedData) : dataModel.getDomain(this, `yValueRaw`, \"value\", processedData);\n      return fixNumericExtent(domain, yAxis);\n    }\n  }\n  async createNodeData() {\n    const { processedData, dataModel, axes } = this;\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!processedData || !dataModel || !xAxis || !yAxis) {\n      return;\n    }\n    const { xKey, yKey, xName, yName, marker, label, connectMissingData, legendItemName } = this.properties;\n    const stacked = (this.seriesGrouping?.stackCount ?? 1) > 1;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const yOffset = (yScale.bandwidth ?? 0) / 2;\n    const nodeData = [];\n    const size = marker.enabled ? marker.size : 0;\n    const xIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yIdx = dataModel.resolveProcessedDataIndexById(this, `yValueRaw`);\n    const yCumulativeIdx = stacked ? dataModel.resolveProcessedDataIndexById(this, `yValueCumulative`) : yIdx;\n    const yEndIdx = stacked ? dataModel.resolveProcessedDataIndexById(this, `yValueEnd`) : void 0;\n    let moveTo = true;\n    processedData.data?.forEach(({ datum, values }) => {\n      const xDatum = values[xIdx];\n      const yDatum = values[yIdx];\n      const yCumulativeDatum = values[yCumulativeIdx];\n      const yEndDatum = yEndIdx != null ? values[yEndIdx] : void 0;\n      if (yDatum == null) {\n        moveTo || (moveTo = !connectMissingData);\n        return;\n      }\n      const x = xScale.convert(xDatum) + xOffset;\n      if (isNaN(x)) {\n        moveTo || (moveTo = !connectMissingData);\n        return;\n      }\n      const y = yScale.convert(yCumulativeDatum) + yOffset;\n      const labelText = this.getLabelText(\n        label,\n        { value: yDatum, datum, xKey, yKey, xName, yName, legendItemName },\n        (value) => isFiniteNumber(value) ? value.toFixed(2) : String(value)\n      );\n      nodeData.push({\n        series: this,\n        datum,\n        yKey,\n        xKey,\n        point: { x, y, moveTo, size },\n        midPoint: { x, y },\n        cumulativeValue: yEndDatum,\n        yValue: yDatum,\n        xValue: xDatum,\n        capDefaults: {\n          lengthRatioMultiplier: this.properties.marker.getDiameter(),\n          lengthMax: Infinity\n        },\n        label: labelText ? {\n          text: labelText,\n          fontStyle: label.fontStyle,\n          fontWeight: label.fontWeight,\n          fontSize: label.fontSize,\n          fontFamily: label.fontFamily,\n          textAlign: \"center\",\n          textBaseline: \"bottom\",\n          fill: label.color\n        } : void 0\n      });\n      moveTo = false;\n    });\n    return {\n      itemId: yKey,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updatePathNodes(opts) {\n    const {\n      paths: [lineNode],\n      opacity,\n      visible,\n      animationEnabled\n    } = opts;\n    lineNode.setProperties({\n      fill: void 0,\n      lineJoin: \"round\",\n      pointerEvents: 1 /* None */,\n      opacity,\n      stroke: this.properties.stroke,\n      strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),\n      strokeOpacity: this.properties.strokeOpacity,\n      lineDash: this.properties.lineDash,\n      lineDashOffset: this.properties.lineDashOffset\n    });\n    if (!animationEnabled) {\n      lineNode.visible = visible;\n    }\n    updateClipPath(this, lineNode);\n  }\n  async updateMarkerSelection(opts) {\n    let { nodeData } = opts;\n    const { markerSelection } = opts;\n    const { shape, enabled } = this.properties.marker;\n    nodeData = shape && enabled ? nodeData : [];\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    return markerSelection.update(nodeData, void 0, (datum) => createDatumId(datum.xValue));\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, stroke, strokeWidth, strokeOpacity, marker, highlightStyle } = this.properties;\n    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle(), {\n      stroke,\n      strokeWidth,\n      strokeOpacity\n    });\n    const applyTranslation = this.ctx.animationManager.isSkipped();\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey }, baseStyle, { applyTranslation });\n    });\n    if (!highlighted) {\n      marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    return opts.labelSelection.update(this.isLabelEnabled() ? opts.labelData : []);\n  }\n  async updateLabelNodes(opts) {\n    const { enabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.properties.label;\n    opts.labelSelection.each((text, datum) => {\n      const { point, label } = datum;\n      if (datum && label && enabled) {\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.textAlign = label.textAlign;\n        text.textBaseline = label.textBaseline;\n        text.text = label.text;\n        text.x = point.x;\n        text.y = point.y - 10;\n        text.fill = color;\n        text.visible = true;\n      } else {\n        text.visible = false;\n      }\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, xName, yName, strokeWidth, marker, tooltip } = this.properties;\n    const { datum, xValue, yValue, itemId } = nodeDatum;\n    const xString = xAxis.formatDatum(xValue);\n    const yString = yAxis.formatDatum(yValue);\n    const title = sanitizeHtml(this.properties.title ?? yName);\n    const content = sanitizeHtml(xString + \": \" + yString);\n    const baseStyle = mergeDefaults({ fill: marker.stroke }, marker.getStyle(), { strokeWidth });\n    const { fill: color } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, xKey, yKey, highlighted: false },\n      baseStyle\n    );\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        title,\n        color,\n        seriesId: this.id,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  getLegendData(legendType) {\n    if (!(this.data?.length && this.properties.isValid() && legendType === \"category\")) {\n      return [];\n    }\n    const { yKey, yName, stroke, strokeOpacity, strokeWidth, lineDash, title, marker, visible, legendItemName } = this.properties;\n    const color0 = \"rgba(0, 0, 0, 0)\";\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        legendItemName,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: legendItemName ?? title ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape: marker.shape,\n              fill: marker.fill ?? color0,\n              stroke: marker.stroke ?? stroke ?? color0,\n              fillOpacity: marker.fillOpacity ?? 1,\n              strokeOpacity: marker.strokeOpacity ?? strokeOpacity ?? 1,\n              strokeWidth: marker.strokeWidth ?? 0,\n              enabled: marker.enabled\n            },\n            line: {\n              stroke: stroke ?? color0,\n              strokeOpacity,\n              strokeWidth,\n              lineDash\n            }\n          }\n        ]\n      }\n    ];\n  }\n  async updatePaths(opts) {\n    this.updateLinePaths(opts.paths, opts.contextData);\n  }\n  updateLinePaths(paths, contextData) {\n    const { interpolation } = this.properties;\n    const { nodeData } = contextData;\n    const [lineNode] = paths;\n    lineNode.path.clear(true);\n    for (const range3 of pathRanges(nodeData)) {\n      plotPath(pathRangePoints(nodeData, range3), lineNode, interpolation);\n    }\n    lineNode.checkPathDirty();\n  }\n  animateEmptyUpdateReady(animationData) {\n    const { markerSelection, labelSelection, annotationSelections, contextData, paths } = animationData;\n    const { animationManager } = this.ctx;\n    this.updateLinePaths(paths, contextData);\n    pathSwipeInAnimation(this, animationManager, ...paths);\n    resetMotion([markerSelection], resetMarkerPositionFn);\n    markerSwipeScaleInAnimation(this, animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelection);\n    seriesLabelFadeInAnimation(this, \"annotations\", animationManager, ...annotationSelections);\n  }\n  animateReadyResize(animationData) {\n    const { contextData, paths } = animationData;\n    this.updateLinePaths(paths, contextData);\n    super.animateReadyResize(animationData);\n  }\n  animateWaitingUpdateReady(animationData) {\n    const { animationManager } = this.ctx;\n    const {\n      markerSelection: markerSelections,\n      labelSelection: labelSelections,\n      annotationSelections,\n      contextData,\n      paths,\n      previousContextData\n    } = animationData;\n    const [path] = paths;\n    this.resetMarkerAnimation(animationData);\n    this.resetLabelAnimation(animationData);\n    const update = () => {\n      this.resetPathAnimation(animationData);\n      this.updateLinePaths(paths, contextData);\n    };\n    const skip = () => {\n      animationManager.skipCurrentBatch();\n      update();\n    };\n    if (contextData == null || previousContextData == null) {\n      update();\n      markerFadeInAnimation(this, animationManager, \"added\", markerSelections);\n      pathFadeInAnimation(this, \"path_properties\", animationManager, \"add\", path);\n      seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelections);\n      seriesLabelFadeInAnimation(this, \"annotations\", animationManager, ...annotationSelections);\n      return;\n    }\n    const fns = prepareLinePathAnimation(\n      contextData,\n      previousContextData,\n      this.processedData?.reduced?.diff,\n      this.properties.interpolation\n    );\n    if (fns === void 0) {\n      skip();\n      return;\n    } else if (fns.status === \"no-op\") {\n      return;\n    }\n    markerFadeInAnimation(this, animationManager, void 0, markerSelections);\n    fromToMotion(this.id, \"path_properties\", animationManager, [path], fns.pathProperties);\n    pathMotion(this.id, \"path_update\", animationManager, [path], fns.path);\n    if (fns.hasMotion) {\n      seriesLabelFadeInAnimation(this, \"labels\", animationManager, labelSelections);\n      seriesLabelFadeInAnimation(this, \"annotations\", animationManager, ...annotationSelections);\n    }\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  getBandScalePadding() {\n    return { inner: 1, outer: 0.1 };\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey } = this.properties;\n    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, highlighted: true });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nLineSeries.className = \"LineSeries\";\nLineSeries.type = \"line\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/lineSeriesModule.ts\nvar LineSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"line\",\n  moduleFactory: (ctx) => new LineSeries(ctx),\n  stackable: true,\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    },\n    {\n      type: \"category\" /* CATEGORY */,\n      position: \"bottom\" /* BOTTOM */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      tooltip: { position: { type: \"node\" } },\n      strokeWidth: 2,\n      strokeOpacity: 1,\n      lineDash: [0],\n      lineDashOffset: 0,\n      interpolation: {\n        type: \"linear\",\n        // @ts-expect-error - users shouldn't specify all options, but we have to for theming to work\n        tension: 1,\n        position: \"end\"\n      },\n      marker: {\n        shape: \"circle\",\n        size: 7,\n        strokeWidth: 0\n      },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      },\n      errorBar: {\n        cap: {\n          lengthRatio: 1\n        }\n      }\n    }\n  },\n  paletteFactory: (params) => {\n    const { marker } = markerPaletteFactory(params);\n    return { stroke: marker.fill, marker };\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesProperties.ts\nvar ScatterSeriesLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.placement = \"top\";\n  }\n};\n__decorateClass([\n  Validate(LABEL_PLACEMENT)\n], ScatterSeriesLabel.prototype, \"placement\", 2);\nvar ScatterSeriesProperties = class extends CartesianSeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.colorRange = [\"#ffff00\", \"#00ff00\", \"#0000ff\"];\n    this.label = new ScatterSeriesLabel();\n    this.tooltip = new SeriesTooltip();\n    // No validation. Not a part of the options contract.\n    this.marker = new SeriesMarker();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], ScatterSeriesProperties.prototype, \"xKey\", 2);\n__decorateClass([\n  Validate(STRING)\n], ScatterSeriesProperties.prototype, \"yKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"labelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"xName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"yName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"labelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate(NUMBER_ARRAY, { optional: true })\n], ScatterSeriesProperties.prototype, \"colorDomain\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], ScatterSeriesProperties.prototype, \"colorRange\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], ScatterSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.shape\")\n], ScatterSeriesProperties.prototype, \"shape\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.size\")\n], ScatterSeriesProperties.prototype, \"size\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fill\")\n], ScatterSeriesProperties.prototype, \"fill\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.fillOpacity\")\n], ScatterSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.stroke\")\n], ScatterSeriesProperties.prototype, \"stroke\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeWidth\")\n], ScatterSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.strokeOpacity\")\n], ScatterSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  ProxyProperty(\"marker.itemStyler\", { optional: true })\n], ScatterSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ScatterSeriesProperties.prototype, \"label\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], ScatterSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/cartesian/scatterSeries.ts\nvar ScatterSeries = class extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      directionKeys: DEFAULT_CARTESIAN_DIRECTION_KEYS,\n      directionNames: DEFAULT_CARTESIAN_DIRECTION_NAMES,\n      pickModes: [\n        2 /* NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST */,\n        3 /* NEAREST_NODE */,\n        0 /* EXACT_SHAPE_MATCH */\n      ],\n      pathsPerSeries: [],\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        marker: resetMarkerFn,\n        label: resetLabelFn\n      }\n    });\n    this.properties = new ScatterSeriesProperties();\n    this.colorScale = new ColorScale();\n  }\n  async processData(dataController) {\n    if (!this.properties.isValid() || this.data == null || !this.visible)\n      return;\n    const xScale = this.axes[\"x\" /* X */]?.scale;\n    const yScale = this.axes[\"y\" /* Y */]?.scale;\n    const { xScaleType, yScaleType } = this.getScaleInformation({ xScale, yScale });\n    const colorScaleType = this.colorScale.type;\n    const { xKey, yKey, labelKey, colorKey, colorDomain, colorRange } = this.properties;\n    const { dataModel, processedData } = await this.requestDataModel(dataController, this.data, {\n      props: [\n        keyProperty(xKey, xScaleType, { id: \"xKey-raw\" }),\n        keyProperty(yKey, yScaleType, { id: \"yKey-raw\" }),\n        ...labelKey ? [keyProperty(labelKey, \"band\", { id: `labelKey-raw` })] : [],\n        valueProperty(xKey, xScaleType, { id: `xValue` }),\n        valueProperty(yKey, yScaleType, { id: `yValue` }),\n        ...colorKey ? [valueProperty(colorKey, colorScaleType, { id: `colorValue` })] : [],\n        ...labelKey ? [valueProperty(labelKey, \"band\", { id: `labelValue` })] : []\n      ]\n    });\n    if (colorKey) {\n      const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`);\n      this.colorScale.domain = colorDomain ?? processedData.domain.values[colorKeyIdx] ?? [];\n      this.colorScale.range = colorRange;\n      this.colorScale.update();\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  getSeriesDomain(direction) {\n    const { dataModel, processedData } = this;\n    if (!processedData || !dataModel)\n      return [];\n    const id = direction === \"x\" /* X */ ? `xValue` : `yValue`;\n    const dataDef = dataModel.resolveProcessedDataDefById(this, id);\n    const domain = dataModel.getDomain(this, id, \"value\", processedData);\n    if (dataDef?.def.type === \"value\" && dataDef?.def.valueType === \"category\") {\n      return domain;\n    }\n    const axis = this.axes[direction];\n    return fixNumericExtent(extent(domain), axis);\n  }\n  async createNodeData() {\n    const { axes, dataModel, processedData, colorScale } = this;\n    const { xKey, yKey, labelKey, colorKey, xName, yName, labelName, marker, label, visible } = this.properties;\n    const { placement } = label;\n    const markerShape = getMarker(marker.shape);\n    const xAxis = axes[\"x\" /* X */];\n    const yAxis = axes[\"y\" /* Y */];\n    if (!(dataModel && processedData && visible && xAxis && yAxis)) {\n      return;\n    }\n    const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`);\n    const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`);\n    const colorDataIdx = colorKey ? dataModel.resolveProcessedDataIndexById(this, `colorValue`) : -1;\n    const labelDataIdx = labelKey ? dataModel.resolveProcessedDataIndexById(this, `labelValue`) : -1;\n    const xScale = xAxis.scale;\n    const yScale = yAxis.scale;\n    const xOffset = (xScale.bandwidth ?? 0) / 2;\n    const yOffset = (yScale.bandwidth ?? 0) / 2;\n    const nodeData = [];\n    const font = label.getFont();\n    const textMeasurer = CachedTextMeasurerPool.getMeasurer({ font });\n    for (const { values, datum } of processedData.data ?? []) {\n      const xDatum = values[xDataIdx];\n      const yDatum = values[yDataIdx];\n      const x = xScale.convert(xDatum) + xOffset;\n      const y = yScale.convert(yDatum) + yOffset;\n      const labelText = this.getLabelText(label, {\n        value: labelKey ? values[labelDataIdx] : yDatum,\n        datum,\n        xKey,\n        yKey,\n        labelKey,\n        xName,\n        yName,\n        labelName\n      });\n      const size = textMeasurer.measureText(labelText);\n      const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : void 0;\n      nodeData.push({\n        series: this,\n        itemId: yKey,\n        yKey,\n        xKey,\n        datum,\n        xValue: xDatum,\n        yValue: yDatum,\n        capDefaults: { lengthRatioMultiplier: marker.getDiameter(), lengthMax: Infinity },\n        point: { x, y, size: marker.size },\n        midPoint: { x, y },\n        fill,\n        label: { text: labelText, ...size },\n        marker: markerShape,\n        placement\n      });\n    }\n    return {\n      itemId: yKey,\n      nodeData,\n      labelData: nodeData,\n      scales: this.calculateScaling(),\n      visible: this.visible\n    };\n  }\n  isPathOrSelectionDirty() {\n    return this.properties.marker.isDirty();\n  }\n  getLabelData() {\n    return this.contextNodeData?.labelData ?? [];\n  }\n  markerFactory() {\n    const { shape } = this.properties.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  async updateMarkerSelection(opts) {\n    const { nodeData, markerSelection } = opts;\n    if (this.properties.marker.isDirty()) {\n      markerSelection.clear();\n      markerSelection.cleanup();\n    }\n    return markerSelection.update(this.properties.marker.enabled ? nodeData : []);\n  }\n  async updateMarkerNodes(opts) {\n    const { markerSelection, isHighlight: highlighted } = opts;\n    const { xKey, yKey, labelKey, marker, highlightStyle } = this.properties;\n    const baseStyle = mergeDefaults(highlighted && highlightStyle.item, marker.getStyle());\n    markerSelection.each((node, datum) => {\n      this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, labelKey }, baseStyle);\n    });\n    if (!highlighted) {\n      marker.markClean();\n    }\n  }\n  async updateLabelSelection(opts) {\n    const placedLabels = this.isLabelEnabled() ? this.chart?.placeLabels().get(this) ?? [] : [];\n    return opts.labelSelection.update(\n      placedLabels.map(({ datum, x, y }) => ({\n        ...datum,\n        point: { x, y, size: datum.point.size },\n        placement: \"top\"\n      })),\n      (text) => {\n        text.pointerEvents = 1 /* None */;\n      }\n    );\n  }\n  async updateLabelNodes(opts) {\n    const { label } = this.properties;\n    opts.labelSelection.each((text, datum) => {\n      text.text = datum.label.text;\n      text.fill = label.color;\n      text.x = datum.point?.x ?? 0;\n      text.y = datum.point?.y ?? 0;\n      text.fontStyle = label.fontStyle;\n      text.fontWeight = label.fontWeight;\n      text.fontSize = label.fontSize;\n      text.fontFamily = label.fontFamily;\n      text.textAlign = \"left\";\n      text.textBaseline = \"top\";\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const xAxis = this.axes[\"x\" /* X */];\n    const yAxis = this.axes[\"y\" /* Y */];\n    if (!this.properties.isValid() || !xAxis || !yAxis) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const { xKey, yKey, labelKey, xName, yName, labelName, title = yName, marker, tooltip } = this.properties;\n    const { datum, xValue, yValue, label, itemId } = nodeDatum;\n    const baseStyle = mergeDefaults(\n      { fill: nodeDatum.fill, strokeWidth: this.getStrokeWidth(marker.strokeWidth) },\n      marker.getStyle()\n    );\n    const { fill: color = \"gray\" } = this.getMarkerStyle(\n      marker,\n      { datum: nodeDatum, highlighted: false, xKey, yKey, labelKey },\n      baseStyle\n    );\n    const xString = sanitizeHtml(xAxis.formatDatum(xValue));\n    const yString = sanitizeHtml(yAxis.formatDatum(yValue));\n    let content = `<b>${sanitizeHtml(xName ?? xKey)}</b>: ${xString}<br><b>${sanitizeHtml(yName ?? yKey)}</b>: ${yString}`;\n    if (labelKey) {\n      content = `<b>${sanitizeHtml(labelName ?? labelKey)}</b>: ${sanitizeHtml(label.text)}<br>` + content;\n    }\n    return tooltip.toTooltipHtml(\n      { title, content, backgroundColor: color },\n      {\n        datum,\n        itemId,\n        xKey,\n        xName,\n        yKey,\n        yName,\n        labelKey,\n        labelName,\n        title,\n        color,\n        seriesId: this.id,\n        ...this.getModuleTooltipParams()\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { yKey, yName, title, marker, visible } = this.properties;\n    const { fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = marker;\n    if (!this.data?.length || !this.properties.isValid() || legendType !== \"category\") {\n      return [];\n    }\n    return [\n      {\n        legendType: \"category\",\n        id: this.id,\n        itemId: yKey,\n        seriesId: this.id,\n        enabled: visible,\n        label: {\n          text: title ?? yName ?? yKey\n        },\n        symbols: [\n          {\n            marker: {\n              shape: marker.shape,\n              fill: marker.fill ?? fill ?? \"rgba(0, 0, 0, 0)\",\n              stroke: marker.stroke ?? stroke ?? \"rgba(0, 0, 0, 0)\",\n              fillOpacity: fillOpacity ?? 1,\n              strokeOpacity: strokeOpacity ?? 1,\n              strokeWidth: strokeWidth ?? 0\n            }\n          }\n        ]\n      }\n    ];\n  }\n  animateEmptyUpdateReady(data) {\n    const { markerSelection, labelSelection, annotationSelections } = data;\n    markerScaleInAnimation(this, this.ctx.animationManager, markerSelection);\n    seriesLabelFadeInAnimation(this, \"labels\", this.ctx.animationManager, labelSelection);\n    seriesLabelFadeInAnimation(this, \"annotations\", this.ctx.animationManager, ...annotationSelections);\n  }\n  isLabelEnabled() {\n    return this.properties.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n  getFormattedMarkerStyle(datum) {\n    const { xKey, yKey, labelKey } = this.properties;\n    return this.getMarkerStyle(this.properties.marker, { datum, xKey, yKey, labelKey, highlighted: true });\n  }\n  computeFocusBounds(opts) {\n    return computeMarkerFocusBounds(this, opts);\n  }\n};\nScatterSeries.className = \"ScatterSeries\";\nScatterSeries.type = \"scatter\";\n\n// packages/ag-charts-community/src/chart/series/cartesian/scatterSeriesModule.ts\nvar ScatterSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  identifier: \"scatter\",\n  moduleFactory: (ctx) => new ScatterSeries(ctx),\n  tooltipDefaults: { range: \"nearest\" },\n  defaultAxes: [\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"bottom\" /* BOTTOM */\n    },\n    {\n      type: \"number\" /* NUMBER */,\n      position: \"left\" /* LEFT */\n    }\n  ],\n  themeTemplate: {\n    series: {\n      shape: \"circle\",\n      size: 7,\n      fillOpacity: 0.8,\n      tooltip: { position: { type: \"node\" } },\n      label: {\n        enabled: false,\n        fontSize: 12,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      },\n      errorBar: {\n        cap: {\n          lengthRatio: 1\n        }\n      }\n    }\n  },\n  paletteFactory: singleSeriesPaletteFactory\n};\n\n// packages/ag-charts-community/src/scene/sectorBox.ts\nvar SectorBox = class _SectorBox {\n  constructor(startAngle, endAngle, innerRadius, outerRadius) {\n    this.startAngle = startAngle;\n    this.endAngle = endAngle;\n    this.innerRadius = innerRadius;\n    this.outerRadius = outerRadius;\n  }\n  clone() {\n    const { startAngle, endAngle, innerRadius, outerRadius } = this;\n    return new _SectorBox(startAngle, endAngle, innerRadius, outerRadius);\n  }\n  [interpolate](other, d) {\n    return new _SectorBox(\n      this.startAngle * (1 - d) + other.startAngle * d,\n      this.endAngle * (1 - d) + other.endAngle * d,\n      this.innerRadius * (1 - d) + other.innerRadius * d,\n      this.outerRadius * (1 - d) + other.outerRadius * d\n    );\n  }\n};\n\n// packages/ag-charts-community/src/scene/util/sector.ts\nfunction sectorBox({ startAngle, endAngle, innerRadius, outerRadius }) {\n  let x0 = Infinity;\n  let y0 = Infinity;\n  let x1 = -Infinity;\n  let y1 = -Infinity;\n  const addPoint = (x, y) => {\n    x0 = Math.min(x, x0);\n    y0 = Math.min(y, y0);\n    x1 = Math.max(x, x1);\n    y1 = Math.max(y, y1);\n  };\n  addPoint(innerRadius * Math.cos(startAngle), innerRadius * Math.sin(startAngle));\n  addPoint(innerRadius * Math.cos(endAngle), innerRadius * Math.sin(endAngle));\n  addPoint(outerRadius * Math.cos(startAngle), outerRadius * Math.sin(startAngle));\n  addPoint(outerRadius * Math.cos(endAngle), outerRadius * Math.sin(endAngle));\n  if (isBetweenAngles(0, startAngle, endAngle)) {\n    addPoint(outerRadius, 0);\n  }\n  if (isBetweenAngles(Math.PI * 0.5, startAngle, endAngle)) {\n    addPoint(0, outerRadius);\n  }\n  if (isBetweenAngles(Math.PI, startAngle, endAngle)) {\n    addPoint(-outerRadius, 0);\n  }\n  if (isBetweenAngles(Math.PI * 1.5, startAngle, endAngle)) {\n    addPoint(0, -outerRadius);\n  }\n  return new BBox(x0, y0, x1 - x0, y1 - y0);\n}\nfunction isPointInSector(x, y, sector) {\n  const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\n  const { innerRadius, outerRadius } = sector;\n  if (sector.startAngle === sector.endAngle || radius < Math.min(innerRadius, outerRadius) || radius > Math.max(innerRadius, outerRadius)) {\n    return false;\n  }\n  const startAngle = normalizeAngle180(sector.startAngle);\n  const endAngle = normalizeAngle180(sector.endAngle);\n  const angle2 = Math.atan2(y, x);\n  return startAngle < endAngle ? angle2 <= endAngle && angle2 >= startAngle : angle2 <= endAngle && angle2 >= -Math.PI || angle2 >= startAngle && angle2 <= Math.PI;\n}\nfunction lineCollidesSector(line, sector) {\n  const { startAngle, endAngle, innerRadius, outerRadius } = sector;\n  const outerStart = { x: outerRadius * Math.cos(startAngle), y: outerRadius * Math.sin(startAngle) };\n  const outerEnd = { x: outerRadius * Math.cos(endAngle), y: outerRadius * Math.sin(endAngle) };\n  const innerStart = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(startAngle), y: innerRadius * Math.sin(startAngle) };\n  const innerEnd = innerRadius === 0 ? { x: 0, y: 0 } : { x: innerRadius * Math.cos(endAngle), y: innerRadius * Math.sin(endAngle) };\n  return segmentIntersection(\n    line.start.x,\n    line.start.y,\n    line.end.x,\n    line.end.y,\n    outerStart.x,\n    outerStart.y,\n    innerStart.x,\n    innerStart.y\n  ) || segmentIntersection(\n    line.start.x,\n    line.start.y,\n    line.end.x,\n    line.end.y,\n    outerEnd.x,\n    outerEnd.y,\n    innerEnd.x,\n    innerEnd.y\n  ) || arcIntersections(\n    0,\n    0,\n    outerRadius,\n    startAngle,\n    endAngle,\n    true,\n    line.start.x,\n    line.start.y,\n    line.end.x,\n    line.end.y\n  );\n}\nfunction boxCollidesSector(box, sector) {\n  const topLeft = { x: box.x, y: box.y };\n  const topRight = { x: box.x + box.width, y: box.y };\n  const bottomLeft = { x: box.x, y: box.y + box.height };\n  const bottomRight = { x: box.x + box.width, y: box.y + box.height };\n  return lineCollidesSector({ start: topLeft, end: topRight }, sector) || lineCollidesSector({ start: bottomLeft, end: bottomRight }, sector);\n}\nfunction radiiScalingFactor(r, sweep, a, b) {\n  if (a === 0 && b === 0)\n    return 0;\n  const fs1 = Math.asin(Math.abs(1 * a) / (r + 1 * a)) + Math.asin(Math.abs(1 * b) / (r + 1 * b)) - sweep;\n  if (fs1 < 0)\n    return 1;\n  let start = 0;\n  let end = 1;\n  for (let i = 0; i < 8; i += 1) {\n    const s = (start + end) / 2;\n    const fs = Math.asin(Math.abs(s * a) / (r + s * a)) + Math.asin(Math.abs(s * b) / (r + s * b)) - sweep;\n    if (fs < 0) {\n      start = s;\n    } else {\n      end = s;\n    }\n  }\n  return start;\n}\nvar delta2 = 1e-6;\nfunction clockwiseAngle(angle2, relativeToStartAngle) {\n  if (angleBetween(angle2, relativeToStartAngle) < delta2) {\n    return relativeToStartAngle;\n  } else {\n    return normalizeAngle360(angle2 - relativeToStartAngle) + relativeToStartAngle;\n  }\n}\nfunction clockwiseAngles(startAngle, endAngle, relativeToStartAngle = 0) {\n  const fullPie = Math.abs(endAngle - startAngle) >= 2 * Math.PI;\n  const sweepAngle = fullPie ? 2 * Math.PI : normalizeAngle360(endAngle - startAngle);\n  startAngle = clockwiseAngle(startAngle, relativeToStartAngle);\n  endAngle = startAngle + sweepAngle;\n  return { startAngle, endAngle };\n}\nfunction arcRadialLineIntersectionAngle(cx, cy, r, startAngle, endAngle, clipAngle) {\n  const sinA = Math.sin(clipAngle);\n  const cosA = Math.cos(clipAngle);\n  const c = cx ** 2 + cy ** 2 - r ** 2;\n  let p0x = NaN;\n  let p0y = NaN;\n  let p1x = NaN;\n  let p1y = NaN;\n  if (cosA > 0.5) {\n    const tanA = sinA / cosA;\n    const a = 1 + tanA ** 2;\n    const b = -2 * (cx + cy * tanA);\n    const d = b ** 2 - 4 * a * c;\n    if (d < 0)\n      return;\n    const x0 = (-b + Math.sqrt(d)) / (2 * a);\n    const x1 = (-b - Math.sqrt(d)) / (2 * a);\n    p0x = x0;\n    p0y = x0 * tanA;\n    p1x = x1;\n    p1y = x1 * tanA;\n  } else {\n    const cotA = cosA / sinA;\n    const a = 1 + cotA ** 2;\n    const b = -2 * (cy + cx * cotA);\n    const d = b ** 2 - 4 * a * c;\n    if (d < 0)\n      return;\n    const y0 = (-b + Math.sqrt(d)) / (2 * a);\n    const y1 = (-b - Math.sqrt(d)) / (2 * a);\n    p0x = y0 * cotA;\n    p0y = y0;\n    p1x = y1 * cotA;\n    p1y = y1;\n  }\n  const normalisedX = cosA;\n  const normalisedY = sinA;\n  const p0DotNormalized = p0x * normalisedX + p0y * normalisedY;\n  const p1DotNormalized = p1x * normalisedX + p1y * normalisedY;\n  const a0 = p0DotNormalized > 0 ? clockwiseAngle(Math.atan2(p0y - cy, p0x - cx), startAngle) : NaN;\n  const a1 = p1DotNormalized > 0 ? clockwiseAngle(Math.atan2(p1y - cy, p1x - cx), startAngle) : NaN;\n  if (a0 >= startAngle && a0 <= endAngle) {\n    return a0;\n  } else if (a1 >= startAngle && a1 <= endAngle) {\n    return a1;\n  }\n}\nfunction arcCircleIntersectionAngle(cx, cy, r, startAngle, endAngle, circleR) {\n  const d = Math.hypot(cx, cy);\n  const d1 = (d ** 2 - r ** 2 + circleR ** 2) / (2 * d);\n  const d2 = d - d1;\n  const theta = Math.atan2(cy, cx);\n  const deltaTheta = Math.acos(-d2 / r);\n  const a0 = clockwiseAngle(theta + deltaTheta, startAngle);\n  const a1 = clockwiseAngle(theta - deltaTheta, startAngle);\n  if (a0 >= startAngle && a0 <= endAngle) {\n    return a0;\n  } else if (a1 >= startAngle && a1 <= endAngle) {\n    return a1;\n  }\n}\n\n// packages/ag-charts-community/src/scene/shape/sector.ts\nvar Arc = class {\n  constructor(cx, cy, r, a0, a1) {\n    this.cx = cx;\n    this.cy = cy;\n    this.r = r;\n    this.a0 = a0;\n    this.a1 = a1;\n    if (this.a0 >= this.a1) {\n      this.a0 = NaN;\n      this.a1 = NaN;\n    }\n  }\n  isValid() {\n    return Number.isFinite(this.a0) && Number.isFinite(this.a1);\n  }\n  pointAt(a) {\n    return {\n      x: this.cx + this.r * Math.cos(a),\n      y: this.cy + this.r * Math.sin(a)\n    };\n  }\n  clipStart(a) {\n    if (a == null || !this.isValid() || a < this.a0)\n      return;\n    this.a0 = a;\n    if (Number.isNaN(a) || this.a0 >= this.a1) {\n      this.a0 = NaN;\n      this.a1 = NaN;\n    }\n  }\n  clipEnd(a) {\n    if (a == null || !this.isValid() || a > this.a1)\n      return;\n    this.a1 = a;\n    if (Number.isNaN(a) || this.a0 >= this.a1) {\n      this.a0 = NaN;\n      this.a1 = NaN;\n    }\n  }\n};\nvar Sector = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.centerX = 0;\n    this.centerY = 0;\n    this.innerRadius = 10;\n    this.outerRadius = 20;\n    this.startAngle = 0;\n    this.endAngle = Math.PI * 2;\n    this.clipSector = void 0;\n    this.concentricEdgeInset = 0;\n    this.radialEdgeInset = 0;\n    this.startOuterCornerRadius = 0;\n    this.endOuterCornerRadius = 0;\n    this.startInnerCornerRadius = 0;\n    this.endInnerCornerRadius = 0;\n  }\n  set inset(value) {\n    this.concentricEdgeInset = value;\n    this.radialEdgeInset = value;\n  }\n  set cornerRadius(value) {\n    this.startOuterCornerRadius = value;\n    this.endOuterCornerRadius = value;\n    this.startInnerCornerRadius = value;\n    this.endInnerCornerRadius = value;\n  }\n  computeBBox() {\n    return sectorBox(this).translate(this.centerX, this.centerY);\n  }\n  normalizedRadii() {\n    const { concentricEdgeInset } = this;\n    let { innerRadius, outerRadius } = this;\n    innerRadius = innerRadius > 0 ? innerRadius + concentricEdgeInset : 0;\n    outerRadius = Math.max(outerRadius - concentricEdgeInset, 0);\n    return { innerRadius, outerRadius };\n  }\n  normalizedClipSector() {\n    const { clipSector } = this;\n    if (clipSector == null)\n      return;\n    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);\n    const { innerRadius, outerRadius } = this.normalizedRadii();\n    const clipAngles = clockwiseAngles(clipSector.startAngle, clipSector.endAngle, startAngle);\n    return new SectorBox(\n      Math.max(startAngle, clipAngles.startAngle),\n      Math.min(endAngle, clipAngles.endAngle),\n      Math.max(innerRadius, clipSector.innerRadius),\n      Math.min(outerRadius, clipSector.outerRadius)\n    );\n  }\n  getAngleOffset(radius) {\n    return radius > 0 ? this.radialEdgeInset / radius : 0;\n  }\n  arc(r, angleSweep, a0, a1, outerArc, innerArc, start, inner) {\n    if (r <= 0)\n      return;\n    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);\n    const { innerRadius, outerRadius } = this.normalizedRadii();\n    const clipSector = this.normalizedClipSector();\n    if (inner && innerRadius <= 0)\n      return;\n    const innerAngleOffset = this.getAngleOffset(innerRadius);\n    const outerAngleOffset = this.getAngleOffset(outerRadius);\n    const angleOffset = inner ? this.getAngleOffset(innerRadius + r) : this.getAngleOffset(outerRadius - r);\n    const angle2 = start ? startAngle + angleOffset + angleSweep : endAngle - angleOffset - angleSweep;\n    const radius = inner ? innerRadius + r : outerRadius - r;\n    const cx = radius * Math.cos(angle2);\n    const cy = radius * Math.sin(angle2);\n    if (clipSector != null) {\n      const delta3 = 1e-6;\n      if (!start && !(angle2 >= startAngle - delta3 && angle2 <= clipSector.endAngle - delta3))\n        return;\n      if (start && !(angle2 >= clipSector.startAngle + delta3 && angle2 <= endAngle - delta3))\n        return;\n      if (inner && !(radius >= clipSector.innerRadius - delta3))\n        return;\n      if (!inner && !(radius <= clipSector.outerRadius + delta3))\n        return;\n    }\n    const arc = new Arc(cx, cy, r, a0, a1);\n    if (clipSector != null) {\n      if (inner) {\n        arc.clipStart(\n          arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle - innerAngleOffset)\n        );\n        arc.clipEnd(\n          arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle + innerAngleOffset)\n        );\n      } else {\n        arc.clipStart(\n          arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.startAngle + outerAngleOffset)\n        );\n        arc.clipEnd(arcRadialLineIntersectionAngle(cx, cy, r, a0, a1, clipSector.endAngle - outerAngleOffset));\n      }\n      let circleClipStart;\n      let circleClipEnd;\n      if (start) {\n        circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);\n        circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);\n      } else {\n        circleClipStart = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.outerRadius);\n        circleClipEnd = arcCircleIntersectionAngle(cx, cy, r, a0, a1, clipSector.innerRadius);\n      }\n      arc.clipStart(circleClipStart);\n      arc.clipEnd(circleClipEnd);\n      if (circleClipStart != null) {\n        const { x: x2, y: y2 } = arc.pointAt(circleClipStart);\n        const theta2 = clockwiseAngle(Math.atan2(y2, x2), startAngle);\n        if (start) {\n          innerArc?.clipStart(theta2);\n        } else {\n          outerArc.clipEnd(theta2);\n        }\n      }\n      if (circleClipEnd != null) {\n        const { x: x2, y: y2 } = arc.pointAt(circleClipEnd);\n        const theta2 = clockwiseAngle(Math.atan2(y2, x2), startAngle);\n        if (start) {\n          outerArc.clipStart(theta2);\n        } else {\n          innerArc?.clipEnd(theta2);\n        }\n      }\n    }\n    if (clipSector != null) {\n      const { x: x2, y: y2 } = arc.pointAt((arc.a0 + arc.a1) / 2);\n      if (!isPointInSector(x2, y2, clipSector))\n        return;\n    }\n    const { x, y } = arc.pointAt(start === inner ? arc.a0 : arc.a1);\n    const theta = clockwiseAngle(Math.atan2(y, x), startAngle);\n    const radialArc = inner ? innerArc : outerArc;\n    if (start) {\n      radialArc?.clipStart(theta);\n    } else {\n      radialArc?.clipEnd(theta);\n    }\n    return arc;\n  }\n  updatePath() {\n    const delta3 = 1e-6;\n    const { path, centerX, centerY, concentricEdgeInset, radialEdgeInset } = this;\n    let { startOuterCornerRadius, endOuterCornerRadius, startInnerCornerRadius, endInnerCornerRadius } = this;\n    const { startAngle, endAngle } = clockwiseAngles(this.startAngle, this.endAngle);\n    const { innerRadius, outerRadius } = this.normalizedRadii();\n    const clipSector = this.normalizedClipSector();\n    const sweepAngle = endAngle - startAngle;\n    const fullPie = sweepAngle >= 2 * Math.PI - delta3;\n    path.clear();\n    if (innerRadius === 0 && outerRadius === 0 || innerRadius > outerRadius) {\n      return;\n    } else if ((clipSector?.startAngle ?? startAngle) === (clipSector?.endAngle ?? endAngle)) {\n      return;\n    } else if (fullPie && this.clipSector == null && startOuterCornerRadius === 0 && endOuterCornerRadius === 0 && startInnerCornerRadius === 0 && endInnerCornerRadius === 0) {\n      path.moveTo(centerX + outerRadius * Math.cos(startAngle), centerY + outerRadius * Math.sin(startAngle));\n      path.arc(centerX, centerY, outerRadius, startAngle, endAngle);\n      if (innerRadius > concentricEdgeInset) {\n        path.moveTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));\n        path.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);\n      }\n      path.closePath();\n      return;\n    } else if (this.clipSector == null && Math.abs(innerRadius - outerRadius) < 1e-6) {\n      path.arc(centerX, centerY, outerRadius, startAngle, endAngle, false);\n      path.arc(centerX, centerY, outerRadius, endAngle, startAngle, true);\n      path.closePath();\n      return;\n    }\n    const innerAngleOffset = this.getAngleOffset(innerRadius);\n    const outerAngleOffset = this.getAngleOffset(outerRadius);\n    const outerAngleExceeded = sweepAngle < 2 * outerAngleOffset;\n    if (outerAngleExceeded)\n      return;\n    const hasInnerSweep = (clipSector?.innerRadius ?? innerRadius) > concentricEdgeInset;\n    const innerAngleExceeded = innerRadius < concentricEdgeInset || sweepAngle < 2 * innerAngleOffset;\n    const radialLength = outerRadius - innerRadius;\n    const maxRadialLength = Math.max(\n      startOuterCornerRadius,\n      startInnerCornerRadius,\n      endOuterCornerRadius,\n      endInnerCornerRadius\n    );\n    const initialScalingFactor = maxRadialLength > 0 ? Math.min(radialLength / maxRadialLength, 1) : 1;\n    startOuterCornerRadius *= initialScalingFactor;\n    endOuterCornerRadius *= initialScalingFactor;\n    startInnerCornerRadius *= initialScalingFactor;\n    endInnerCornerRadius *= initialScalingFactor;\n    const outerScalingFactor = radiiScalingFactor(\n      outerRadius,\n      sweepAngle - 2 * outerAngleOffset,\n      -startOuterCornerRadius,\n      -endOuterCornerRadius\n    );\n    startOuterCornerRadius *= outerScalingFactor;\n    endOuterCornerRadius *= outerScalingFactor;\n    if (!innerAngleExceeded && hasInnerSweep) {\n      const innerScalingFactor = radiiScalingFactor(\n        innerRadius,\n        sweepAngle - 2 * innerAngleOffset,\n        startInnerCornerRadius,\n        endInnerCornerRadius\n      );\n      startInnerCornerRadius *= innerScalingFactor;\n      endInnerCornerRadius *= innerScalingFactor;\n    } else {\n      startInnerCornerRadius = 0;\n      endInnerCornerRadius = 0;\n    }\n    const maxCombinedRadialLength = Math.max(\n      startOuterCornerRadius + startInnerCornerRadius,\n      endOuterCornerRadius + endInnerCornerRadius\n    );\n    const edgesScalingFactor = maxCombinedRadialLength > 0 ? Math.min(radialLength / maxCombinedRadialLength, 1) : 1;\n    startOuterCornerRadius *= edgesScalingFactor;\n    endOuterCornerRadius *= edgesScalingFactor;\n    startInnerCornerRadius *= edgesScalingFactor;\n    endInnerCornerRadius *= edgesScalingFactor;\n    let startOuterCornerRadiusAngleSweep = 0;\n    let endOuterCornerRadiusAngleSweep = 0;\n    const startOuterCornerRadiusSweep = startOuterCornerRadius / (outerRadius - startOuterCornerRadius);\n    const endOuterCornerRadiusSweep = endOuterCornerRadius / (outerRadius - endOuterCornerRadius);\n    if (startOuterCornerRadiusSweep >= 0 && startOuterCornerRadiusSweep < 1 - delta3) {\n      startOuterCornerRadiusAngleSweep = Math.asin(startOuterCornerRadiusSweep);\n    } else {\n      startOuterCornerRadiusAngleSweep = sweepAngle / 2;\n      const maxStartOuterCornerRadius = outerRadius / (1 / Math.sin(startOuterCornerRadiusAngleSweep) + 1);\n      startOuterCornerRadius = Math.min(maxStartOuterCornerRadius, startOuterCornerRadius);\n    }\n    if (endOuterCornerRadiusSweep >= 0 && endOuterCornerRadiusSweep < 1 - delta3) {\n      endOuterCornerRadiusAngleSweep = Math.asin(endOuterCornerRadiusSweep);\n    } else {\n      endOuterCornerRadiusAngleSweep = sweepAngle / 2;\n      const maxEndOuterCornerRadius = outerRadius / (1 / Math.sin(endOuterCornerRadiusAngleSweep) + 1);\n      endOuterCornerRadius = Math.min(maxEndOuterCornerRadius, endOuterCornerRadius);\n    }\n    const startInnerCornerRadiusAngleSweep = Math.asin(\n      startInnerCornerRadius / (innerRadius + startInnerCornerRadius)\n    );\n    const endInnerCornerRadiusAngleSweep = Math.asin(endInnerCornerRadius / (innerRadius + endInnerCornerRadius));\n    const outerArcRadius = clipSector?.outerRadius ?? outerRadius;\n    const outerArcRadiusOffset = this.getAngleOffset(outerArcRadius);\n    const outerArc = new Arc(\n      0,\n      0,\n      outerArcRadius,\n      startAngle + outerArcRadiusOffset,\n      endAngle - outerArcRadiusOffset\n    );\n    const innerArcRadius = clipSector?.innerRadius ?? innerRadius;\n    const innerArcRadiusOffset = this.getAngleOffset(innerArcRadius);\n    const innerArc = hasInnerSweep ? new Arc(0, 0, innerArcRadius, startAngle + innerArcRadiusOffset, endAngle - innerArcRadiusOffset) : void 0;\n    if (clipSector != null) {\n      outerArc.clipStart(clipSector.startAngle);\n      outerArc.clipEnd(clipSector.endAngle);\n      innerArc?.clipStart(clipSector.startAngle);\n      innerArc?.clipEnd(clipSector.endAngle);\n    }\n    const startOuterArc = this.arc(\n      startOuterCornerRadius,\n      startOuterCornerRadiusAngleSweep,\n      startAngle - Math.PI * 0.5,\n      startAngle + startOuterCornerRadiusAngleSweep,\n      outerArc,\n      innerArc,\n      true,\n      false\n    );\n    const endOuterArc = this.arc(\n      endOuterCornerRadius,\n      endOuterCornerRadiusAngleSweep,\n      endAngle - endOuterCornerRadiusAngleSweep,\n      endAngle + Math.PI * 0.5,\n      outerArc,\n      innerArc,\n      false,\n      false\n    );\n    const endInnerArc = this.arc(\n      endInnerCornerRadius,\n      endInnerCornerRadiusAngleSweep,\n      endAngle + Math.PI * 0.5,\n      endAngle + Math.PI - endInnerCornerRadiusAngleSweep,\n      outerArc,\n      innerArc,\n      false,\n      true\n    );\n    const startInnerArc = this.arc(\n      startInnerCornerRadius,\n      startInnerCornerRadiusAngleSweep,\n      startAngle + Math.PI + startInnerCornerRadiusAngleSweep,\n      startAngle + Math.PI * 1.5,\n      outerArc,\n      innerArc,\n      true,\n      true\n    );\n    if (innerAngleExceeded) {\n      const x = sweepAngle < Math.PI * 0.5 ? radialEdgeInset * (1 + Math.cos(sweepAngle)) / Math.sin(sweepAngle) : NaN;\n      let r;\n      if (x > 0 && x < outerRadius) {\n        r = Math.max(Math.hypot(radialEdgeInset, x), innerRadius);\n      } else {\n        r = radialEdgeInset;\n      }\n      r = Math.max(r, innerRadius);\n      const midAngle = startAngle + sweepAngle * 0.5;\n      path.moveTo(centerX + r * Math.cos(midAngle), centerY + r * Math.sin(midAngle));\n    } else if (startInnerArc?.isValid() === true || innerArc?.isValid() === true) {\n    } else {\n      const midAngle = startAngle + sweepAngle / 2;\n      const cx = innerRadius * Math.cos(midAngle);\n      const cy = innerRadius * Math.sin(midAngle);\n      path.moveTo(centerX + cx, centerY + cy);\n    }\n    if (startOuterArc?.isValid() === true) {\n      const { cx, cy, r, a0, a1 } = startOuterArc;\n      path.arc(centerX + cx, centerY + cy, r, a0, a1);\n    }\n    if (outerArc.isValid()) {\n      const { r, a0, a1 } = outerArc;\n      path.arc(centerX, centerY, r, a0, a1);\n    }\n    if (endOuterArc?.isValid() === true) {\n      const { cx, cy, r, a0, a1 } = endOuterArc;\n      path.arc(centerX + cx, centerY + cy, r, a0, a1);\n    }\n    if (!innerAngleExceeded) {\n      if (endInnerArc?.isValid() === true) {\n        const { cx, cy, r, a0, a1 } = endInnerArc;\n        path.arc(centerX + cx, centerY + cy, r, a0, a1);\n      }\n      if (innerArc?.isValid() === true) {\n        const { r, a0, a1 } = innerArc;\n        path.arc(centerX, centerY, r, a1, a0, true);\n      }\n      if (startInnerArc?.isValid() === true) {\n        const { cx, cy, r, a0, a1 } = startInnerArc;\n        path.arc(centerX + cx, centerY + cy, r, a0, a1);\n      }\n    }\n    path.closePath();\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    const { startAngle, endAngle, innerRadius, outerRadius } = this.clipSector ?? this;\n    return isPointInSector(point.x - this.centerX, point.y - this.centerY, {\n      startAngle,\n      endAngle,\n      innerRadius: Math.min(innerRadius, outerRadius),\n      outerRadius: Math.max(innerRadius, outerRadius)\n    });\n  }\n};\nSector.className = \"Sector\";\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"centerX\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"centerY\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"innerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"outerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"startAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"endAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"clipSector\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"concentricEdgeInset\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"radialEdgeInset\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"startOuterCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"endOuterCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"startInnerCornerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Sector.prototype, \"endInnerCornerRadius\", 2);\n\n// packages/ag-charts-community/src/chart/themes/defaultColors.ts\nvar DEFAULT_FILLS = {\n  BLUE: \"#5090dc\",\n  ORANGE: \"#ffa03a\",\n  GREEN: \"#459d55\",\n  CYAN: \"#34bfe1\",\n  YELLOW: \"#e1cc00\",\n  VIOLET: \"#9669cb\",\n  GRAY: \"#b5b5b5\",\n  MAGENTA: \"#bd5aa7\",\n  BROWN: \"#8a6224\",\n  RED: \"#ef5452\"\n};\nvar DEFAULT_STROKES = {\n  BLUE: \"#2b5c95\",\n  ORANGE: \"#cc6f10\",\n  GREEN: \"#1e652e\",\n  CYAN: \"#18859e\",\n  YELLOW: \"#a69400\",\n  VIOLET: \"#603c88\",\n  GRAY: \"#575757\",\n  MAGENTA: \"#7d2f6d\",\n  BROWN: \"#4f3508\",\n  RED: \"#a82529\"\n};\n\n// packages/ag-charts-community/src/chart/series/polar/donutSeriesProperties.ts\nvar DonutTitle = class extends Caption {\n  constructor() {\n    super(...arguments);\n    this.showInLegend = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], DonutTitle.prototype, \"showInLegend\", 2);\nvar DonutInnerLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.spacing = 2;\n  }\n  set(properties, _reset) {\n    return super.set(properties);\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], DonutInnerLabel.prototype, \"text\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], DonutInnerLabel.prototype, \"spacing\", 2);\nvar DonutInnerCircle = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.fill = \"transparent\";\n    this.fillOpacity = 1;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING)\n], DonutInnerCircle.prototype, \"fill\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutInnerCircle.prototype, \"fillOpacity\", 2);\nvar DonutSeriesCalloutLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.offset = 3;\n    this.minAngle = 0;\n    this.minSpacing = 4;\n    this.maxCollisionOffset = 50;\n    this.avoidCollisions = true;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLabel.prototype, \"offset\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], DonutSeriesCalloutLabel.prototype, \"minAngle\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLabel.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLabel.prototype, \"maxCollisionOffset\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], DonutSeriesCalloutLabel.prototype, \"avoidCollisions\", 2);\nvar DonutSeriesSectorLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.positionOffset = 0;\n    this.positionRatio = 0.5;\n  }\n};\n__decorateClass([\n  Validate(NUMBER)\n], DonutSeriesSectorLabel.prototype, \"positionOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesSectorLabel.prototype, \"positionRatio\", 2);\nvar DonutSeriesCalloutLine = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.length = 10;\n    this.strokeWidth = 1;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY, { optional: true })\n], DonutSeriesCalloutLine.prototype, \"colors\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLine.prototype, \"length\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesCalloutLine.prototype, \"strokeWidth\", 2);\nvar DonutSeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.rotation = 0;\n    this.outerRadiusOffset = 0;\n    this.outerRadiusRatio = 1;\n    this.strokeWidth = 1;\n    this.sectorSpacing = 0;\n    this.innerLabels = new PropertiesArray(DonutInnerLabel);\n    this.title = new DonutTitle();\n    this.innerCircle = new DonutInnerCircle();\n    this.shadow = new DropShadow();\n    this.calloutLabel = new DonutSeriesCalloutLabel();\n    this.sectorLabel = new DonutSeriesSectorLabel();\n    this.calloutLine = new DonutSeriesCalloutLine();\n    this.tooltip = new SeriesTooltip();\n  }\n  isValid() {\n    const superIsValid = super.isValid();\n    if (this.innerRadiusRatio == null && this.innerRadiusOffset == null) {\n      Logger.warnOnce(\n        \"Either an [innerRadiusRatio] or an [innerRadiusOffset] must be set to render a donut series.\"\n      );\n      return false;\n    }\n    return superIsValid;\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], DonutSeriesProperties.prototype, \"angleKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"angleName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"angleFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusName\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusMin\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], DonutSeriesProperties.prototype, \"radiusMax\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"calloutLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"calloutLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"sectorLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"sectorLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], DonutSeriesProperties.prototype, \"legendItemKey\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], DonutSeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], DonutSeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], DonutSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], DonutSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], DonutSeriesProperties.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], DonutSeriesProperties.prototype, \"outerRadiusOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], DonutSeriesProperties.prototype, \"outerRadiusRatio\", 2);\n__decorateClass([\n  Validate(NUMBER, { optional: true })\n], DonutSeriesProperties.prototype, \"innerRadiusOffset\", 2);\n__decorateClass([\n  Validate(RATIO, { optional: true })\n], DonutSeriesProperties.prototype, \"innerRadiusRatio\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], DonutSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], DonutSeriesProperties.prototype, \"sectorSpacing\", 2);\n__decorateClass([\n  Validate(OBJECT_ARRAY)\n], DonutSeriesProperties.prototype, \"innerLabels\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"innerCircle\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"calloutLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"sectorLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"calloutLine\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], DonutSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/polar/pieUtil.ts\nfunction preparePieSeriesAnimationFunctions(initialLoad, rotationDegrees, scaleFn, oldScaleFn) {\n  const scale2 = [scaleFn.convert(0), scaleFn.convert(1)];\n  const oldScale = [oldScaleFn.convert(0), oldScaleFn.convert(1)];\n  const rotation = Math.PI / -2 + toRadians(rotationDegrees);\n  const phase = initialLoad ? \"initial\" : \"update\";\n  const scaleToNewRadius = ({ radius }) => {\n    return { innerRadius: scale2[0], outerRadius: scale2[0] + (scale2[1] - scale2[0]) * radius };\n  };\n  const scaleToOldRadius = ({ radius }) => {\n    return { innerRadius: oldScale[0], outerRadius: oldScale[0] + (oldScale[1] - oldScale[0]) * radius };\n  };\n  const fromFn = (sect, datum, status, { prevFromProps }) => {\n    let { startAngle, endAngle, innerRadius, outerRadius } = sect;\n    let { fill, stroke } = datum.sectorFormat;\n    if (status === \"unknown\" || status === \"added\" && !prevFromProps) {\n      startAngle = rotation;\n      endAngle = rotation;\n      innerRadius = datum.innerRadius;\n      outerRadius = datum.outerRadius;\n    } else if (status === \"added\" && prevFromProps) {\n      startAngle = prevFromProps.endAngle ?? rotation;\n      endAngle = prevFromProps.endAngle ?? rotation;\n      innerRadius = prevFromProps.innerRadius ?? datum.innerRadius;\n      outerRadius = prevFromProps.outerRadius ?? datum.outerRadius;\n    }\n    if (status === \"added\" && !initialLoad) {\n      const radii = scaleToOldRadius(datum);\n      innerRadius = radii.innerRadius;\n      outerRadius = radii.outerRadius;\n    }\n    if (status === \"updated\") {\n      fill = sect.fill ?? fill;\n      stroke = sect.stroke ?? stroke;\n    }\n    return { startAngle, endAngle, innerRadius, outerRadius, fill, stroke, phase };\n  };\n  const toFn = (_sect, datum, status, { prevLive }) => {\n    let { startAngle, endAngle, innerRadius, outerRadius } = datum;\n    const { stroke, fill } = datum.sectorFormat;\n    if (status === \"removed\" && prevLive) {\n      startAngle = prevLive.datum?.endAngle;\n      endAngle = prevLive.datum?.endAngle;\n    } else if (status === \"removed\" && !prevLive) {\n      startAngle = rotation;\n      endAngle = rotation;\n    }\n    if (status === \"removed\") {\n      const radii = scaleToNewRadius(datum);\n      innerRadius = radii.innerRadius;\n      outerRadius = radii.outerRadius;\n    }\n    return { startAngle, endAngle, outerRadius, innerRadius, stroke, fill };\n  };\n  const innerCircleFromFn = (node, _) => {\n    return { size: node.previousDatum?.radius ?? node.size ?? 0, phase };\n  };\n  const innerCircleToFn = (_, datum) => {\n    return { size: datum.radius ?? 0 };\n  };\n  return { nodes: { toFn, fromFn }, innerCircle: { fromFn: innerCircleFromFn, toFn: innerCircleToFn } };\n}\nfunction resetPieSelectionsFn(_node, datum) {\n  return {\n    startAngle: datum.startAngle,\n    endAngle: datum.endAngle,\n    innerRadius: datum.innerRadius,\n    outerRadius: datum.outerRadius,\n    fill: datum.sectorFormat.fill,\n    stroke: datum.sectorFormat.stroke\n  };\n}\nfunction pickByMatchingAngle(series, point) {\n  const dy = point.y - series.centerY;\n  const dx = point.x - series.centerX;\n  const angle2 = Math.atan2(dy, dx);\n  const sectors = series.getItemNodes();\n  for (const sector of sectors) {\n    if (sector.datum.missing === true)\n      continue;\n    if (isBetweenAngles(angle2, sector.startAngle, sector.endAngle)) {\n      const radius = Math.sqrt(dx * dx + dy * dy);\n      let distance3 = 0;\n      if (radius < sector.innerRadius) {\n        distance3 = sector.innerRadius - radius;\n      } else if (radius > sector.outerRadius) {\n        distance3 = radius - sector.outerRadius;\n      }\n      return { datum: sector.datum, distance: distance3 };\n    }\n  }\n  return void 0;\n}\n\n// packages/ag-charts-community/src/chart/series/polar/polarSeries.ts\nvar PolarSeries = class extends DataModelSeries {\n  constructor({\n    useLabelLayer = false,\n    pickModes = [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n    canHaveAxes = false,\n    animationResetFns,\n    ...opts\n  }) {\n    super({\n      ...opts,\n      useLabelLayer,\n      pickModes,\n      contentGroupVirtual: false,\n      directionKeys: {\n        [\"x\" /* X */]: [\"angleKey\"],\n        [\"y\" /* Y */]: [\"radiusKey\"]\n      },\n      directionNames: {\n        [\"x\" /* X */]: [\"angleName\"],\n        [\"y\" /* Y */]: [\"radiusName\"]\n      },\n      canHaveAxes\n    });\n    this.itemGroup = this.contentGroup.appendChild(new Group());\n    this.nodeData = [];\n    this.itemSelection = Selection.select(\n      this.itemGroup,\n      () => this.nodeFactory(),\n      false\n    );\n    this.labelSelection = Selection.select(\n      this.labelGroup,\n      () => this.labelFactory(),\n      false\n    );\n    this.highlightSelection = Selection.select(\n      this.highlightGroup,\n      () => this.nodeFactory()\n    );\n    this.highlightLabelSelection = Selection.select(\n      this.highlightLabel,\n      () => this.labelFactory()\n    );\n    /**\n     * The center of the polar series (for example, the center of a pie).\n     * If the polar chart has multiple series, all of them will have their\n     * center set to the same value as a result of the polar chart layout.\n     * The center coordinates are not supposed to be set by the user.\n     */\n    this.centerX = 0;\n    this.centerY = 0;\n    /**\n     * The maximum radius the series can use.\n     * This value is set automatically as a result of the polar chart layout\n     * and is not supposed to be set by the user.\n     */\n    this.radius = 0;\n    this.itemGroup.zIndexSubOrder = [() => this._declarationOrder, 1];\n    this.animationResetFns = animationResetFns;\n    this.animationState = new StateMachine(\n      \"empty\",\n      {\n        empty: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateEmptyUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        ready: {\n          updateData: \"waiting\",\n          clear: \"clearing\",\n          highlight: (data) => this.animateReadyHighlight(data),\n          highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),\n          resize: (data) => this.animateReadyResize(data),\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        waiting: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateWaitingUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        clearing: {\n          update: {\n            target: \"empty\",\n            action: (data) => this.animateClearingUpdateEmpty(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        }\n      },\n      () => this.checkProcessedDataAnimatable()\n    );\n  }\n  getItemNodes() {\n    return this.itemGroup.children;\n  }\n  getNodeData() {\n    return this.nodeData;\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    } else if (phase === \"ready\") {\n      this.animationState.transition(\"skip\");\n    }\n  }\n  labelFactory() {\n    const text = new Text();\n    text.pointerEvents = 1 /* None */;\n    return text;\n  }\n  getInnerRadius() {\n    return 0;\n  }\n  getLabelData() {\n    return [];\n  }\n  computeLabelsBBox(_options, _seriesRect) {\n    return null;\n  }\n  resetAllAnimation() {\n    const { item, label } = this.animationResetFns ?? {};\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    if (item) {\n      resetMotion([this.itemSelection, this.highlightSelection], item);\n    }\n    if (label) {\n      resetMotion([this.labelSelection, this.highlightLabelSelection], label);\n    }\n    this.itemSelection.cleanup();\n    this.labelSelection.cleanup();\n    this.highlightSelection.cleanup();\n    this.highlightLabelSelection.cleanup();\n  }\n  animateEmptyUpdateReady(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animateWaitingUpdateReady(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animateReadyHighlight(_data) {\n    const { item, label } = this.animationResetFns ?? {};\n    if (item) {\n      resetMotion([this.highlightSelection], item);\n    }\n    if (label) {\n      resetMotion([this.highlightLabelSelection], label);\n    }\n  }\n  animateReadyHighlightMarkers(_data) {\n  }\n  animateReadyResize(_data) {\n    this.resetAllAnimation();\n  }\n  animateClearingUpdateEmpty(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animationTransitionClear() {\n    this.animationState.transition(\"clear\", this.getAnimationData());\n  }\n  getAnimationData(seriesRect) {\n    return { seriesRect };\n  }\n  computeFocusBounds(opts) {\n    const datum = this.getNodeData()?.[opts.datumIndex];\n    if (datum !== void 0) {\n      return this.itemSelection.select((node) => node instanceof Path && node.datum === datum)[0];\n    }\n    return void 0;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/polar/donutSeries.ts\nvar DonutSeriesNodeEvent = class extends SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.angleKey = series.properties.angleKey;\n    this.radiusKey = series.properties.radiusKey;\n    this.calloutLabelKey = series.properties.calloutLabelKey;\n    this.sectorLabelKey = series.properties.sectorLabelKey;\n  }\n};\nvar DonutSeries = class extends PolarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      useLabelLayer: true,\n      animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }\n    });\n    this.properties = new DonutSeriesProperties();\n    this.phantomNodeData = void 0;\n    this.previousRadiusScale = new LinearScale();\n    this.radiusScale = new LinearScale();\n    this.phantomGroup = this.contentGroup.appendChild(new Group());\n    this.phantomSelection = Selection.select(\n      this.phantomGroup,\n      () => this.nodeFactory(),\n      false\n    );\n    this.calloutLabelGroup = this.contentGroup.appendChild(new Group({ name: \"pieCalloutLabels\" }));\n    this.calloutLabelSelection = new Selection(\n      this.calloutLabelGroup,\n      Group\n    );\n    // The group node that contains the background graphics.\n    this.backgroundGroup = this.rootGroup.appendChild(\n      new Group({\n        name: `${this.id}-background`,\n        layer: true,\n        zIndex: 0 /* SERIES_BACKGROUND_ZINDEX */\n      })\n    );\n    // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.\n    this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));\n    this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Circle());\n    this.zerosumInnerRing = this.zerosumRingsGroup.appendChild(new Circle());\n    this.innerLabelsGroup = this.contentGroup.appendChild(new Group({ name: \"innerLabels\" }));\n    this.innerCircleGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-innerCircle` }));\n    this.innerLabelsSelection = Selection.select(this.innerLabelsGroup, Text);\n    this.innerCircleSelection = Selection.select(\n      this.innerCircleGroup,\n      Circle\n    );\n    // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.\n    this.seriesItemEnabled = [];\n    this.surroundingRadius = void 0;\n    this.NodeEvent = DonutSeriesNodeEvent;\n    this.angleScale = new LinearScale();\n    this.angleScale.domain = [0, 1];\n    this.angleScale.range = [-Math.PI, Math.PI].map((angle2) => angle2 + Math.PI / 2);\n    this.phantomGroup.opacity = 0.2;\n    this.phantomGroup.zIndexSubOrder = [() => this._declarationOrder, 0];\n  }\n  get calloutNodeData() {\n    return this.phantomNodeData ?? this.nodeData;\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager?.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event))\n    );\n  }\n  get visible() {\n    return super.visible && (this.seriesItemEnabled.length === 0 || this.seriesItemEnabled.some((visible) => visible));\n  }\n  nodeFactory() {\n    return new Sector();\n  }\n  getSeriesDomain(direction) {\n    if (direction === \"x\" /* X */) {\n      return this.angleScale.domain;\n    } else {\n      return this.radiusScale.domain;\n    }\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    let { data } = this;\n    const { visible, seriesItemEnabled } = this;\n    const { angleKey, angleFilterKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const extraKeyProps = [];\n    const extraProps = [];\n    if (legendItemKey) {\n      extraKeyProps.push(keyProperty(legendItemKey, \"band\", { id: `legendItemKey` }));\n    } else if (calloutLabelKey) {\n      extraKeyProps.push(keyProperty(calloutLabelKey, \"band\", { id: `calloutLabelKey` }));\n    } else if (sectorLabelKey) {\n      extraKeyProps.push(keyProperty(sectorLabelKey, \"band\", { id: `sectorLabelKey` }));\n    }\n    const radiusScaleType = this.radiusScale.type;\n    const angleScaleType = this.radiusScale.type;\n    if (radiusKey) {\n      extraProps.push(\n        rangedValueProperty(radiusKey, {\n          id: \"radiusValue\",\n          min: this.properties.radiusMin ?? 0,\n          max: this.properties.radiusMax\n        }),\n        valueProperty(radiusKey, radiusScaleType, { id: `radiusRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"radiusValue\", [0, 1], 1, this.properties.radiusMin ?? 0, this.properties.radiusMax)\n      );\n    }\n    if (calloutLabelKey) {\n      extraProps.push(valueProperty(calloutLabelKey, \"band\", { id: `calloutLabelValue` }));\n    }\n    if (sectorLabelKey) {\n      extraProps.push(valueProperty(sectorLabelKey, \"band\", { id: `sectorLabelValue` }));\n    }\n    if (legendItemKey) {\n      extraProps.push(valueProperty(legendItemKey, \"band\", { id: `legendItemValue` }));\n    }\n    if (angleFilterKey) {\n      extraProps.push(\n        accumulativeValueProperty(angleFilterKey, angleScaleType, {\n          id: `angleFilterValue`,\n          onlyPositive: true\n        }),\n        valueProperty(angleFilterKey, angleScaleType, { id: `angleFilterRaw` }),\n        normalisePropertyTo(\"angleFilterValue\", [0, 1], 0, 0)\n      );\n    }\n    if (animationEnabled && this.processedData && extraKeyProps.length > 0) {\n      extraProps.push(diff(this.processedData));\n    }\n    extraProps.push(animationValidation());\n    data = data.map((d, idx) => visible && seriesItemEnabled[idx] ? d : { ...d, [angleKey]: 0 });\n    await this.requestDataModel(dataController, data, {\n      props: [\n        ...extraKeyProps,\n        accumulativeValueProperty(angleKey, angleScaleType, { id: `angleValue`, onlyPositive: true }),\n        valueProperty(angleKey, angleScaleType, { id: `angleRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"angleValue\", [0, 1], 0, 0),\n        ...extraProps\n      ]\n    });\n    for (const valueDef of this.processedData?.defs?.values ?? []) {\n      const { id, missing, property } = valueDef;\n      const missCount = getMissCount(this, missing);\n      if (id !== \"angleRaw\" && missCount > 0) {\n        Logger.warnOnce(\n          `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? \"s\" : \"\"}`\n        );\n      }\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  async maybeRefreshNodeData() {\n    if (!this.nodeDataRefresh)\n      return;\n    const { nodeData = [], phantomNodeData } = await this.createNodeData() ?? {};\n    this.nodeData = nodeData;\n    this.phantomNodeData = phantomNodeData;\n    this.nodeDataRefresh = false;\n  }\n  getProcessedDataIndexes(dataModel) {\n    const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`);\n    const angleRawIdx = dataModel.resolveProcessedDataIndexById(this, `angleRaw`);\n    const angleFilterIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterValue`) : void 0;\n    const angleFilterRawIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterRaw`) : void 0;\n    const radiusIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusValue`) : void 0;\n    const radiusRawIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusRaw`) : void 0;\n    const calloutLabelIdx = this.properties.calloutLabelKey ? dataModel.resolveProcessedDataIndexById(this, `calloutLabelValue`) : void 0;\n    const sectorLabelIdx = this.properties.sectorLabelKey ? dataModel.resolveProcessedDataIndexById(this, `sectorLabelValue`) : void 0;\n    const legendItemIdx = this.properties.legendItemKey ? dataModel.resolveProcessedDataIndexById(this, `legendItemValue`) : void 0;\n    return {\n      angleIdx,\n      angleRawIdx,\n      angleFilterIdx,\n      angleFilterRawIdx,\n      radiusIdx,\n      radiusRawIdx,\n      calloutLabelIdx,\n      sectorLabelIdx,\n      legendItemIdx\n    };\n  }\n  async createNodeData() {\n    const { id: seriesId, processedData, dataModel, angleScale } = this;\n    const { rotation, innerRadiusRatio } = this.properties;\n    if (!this.properties.isValid()) {\n      this.zerosumOuterRing.visible = true;\n      this.zerosumInnerRing.visible = true;\n      return { itemId: seriesId, nodeData: [], labelData: [] };\n    }\n    if (!processedData || !dataModel || processedData.type !== \"ungrouped\")\n      return;\n    const {\n      angleIdx,\n      angleRawIdx,\n      angleFilterIdx,\n      angleFilterRawIdx,\n      radiusIdx,\n      radiusRawIdx,\n      calloutLabelIdx,\n      sectorLabelIdx,\n      legendItemIdx\n    } = this.getProcessedDataIndexes(dataModel);\n    const useFilterAngles = angleFilterRawIdx != null && processedData.data.some(({ values }) => {\n      return values[angleFilterRawIdx] > values[angleRawIdx];\n    });\n    let currentStart = 0;\n    let sum2 = 0;\n    const nodes = [];\n    const phantomNodes = angleFilterRawIdx != null ? [] : void 0;\n    processedData.data.forEach((group, index) => {\n      const { datum, values } = group;\n      const currentValue = useFilterAngles ? values[angleFilterIdx] : values[angleIdx];\n      const crossFilterScale = angleFilterRawIdx != null && !useFilterAngles ? Math.sqrt(values[angleFilterRawIdx] / values[angleRawIdx]) : 1;\n      const startAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      currentStart = currentValue;\n      sum2 += currentValue;\n      const endAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      const span = Math.abs(endAngle - startAngle);\n      const midAngle = startAngle + span / 2;\n      const angleValue = values[angleRawIdx];\n      const radiusRaw = radiusIdx != null ? values[radiusIdx] ?? 1 : 1;\n      const radius = radiusRaw * crossFilterScale;\n      const radiusValue = radiusRawIdx != null ? values[radiusRawIdx] : void 0;\n      const legendItemValue = legendItemIdx != null ? values[legendItemIdx] : void 0;\n      const nodeLabels = this.getLabels(\n        datum,\n        midAngle,\n        span,\n        true,\n        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,\n        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,\n        legendItemValue\n      );\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      const node = {\n        itemId: index,\n        series: this,\n        datum,\n        index,\n        angleValue,\n        midAngle,\n        midCos: Math.cos(midAngle),\n        midSin: Math.sin(midAngle),\n        startAngle,\n        endAngle,\n        radius,\n        innerRadius: Math.max(this.radiusScale.convert(0), 0),\n        outerRadius: Math.max(this.radiusScale.convert(radius), 0),\n        sectorFormat,\n        radiusValue,\n        legendItemValue,\n        enabled: this.seriesItemEnabled[index],\n        focusable: true,\n        ...nodeLabels\n      };\n      nodes.push(node);\n      if (phantomNodes != null) {\n        phantomNodes.push({\n          ...node,\n          radius: 1,\n          innerRadius: Math.max(this.radiusScale.convert(0), 0),\n          outerRadius: Math.max(this.radiusScale.convert(1), 0),\n          focusable: false\n        });\n      }\n    });\n    this.zerosumOuterRing.visible = sum2 === 0;\n    this.zerosumInnerRing.visible = sum2 === 0 && innerRadiusRatio != null && innerRadiusRatio !== 1 && innerRadiusRatio > 0;\n    return {\n      itemId: seriesId,\n      nodeData: nodes,\n      labelData: nodes,\n      phantomNodeData: phantomNodes\n    };\n  }\n  getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {\n    const { calloutLabel, sectorLabel, legendItemKey } = this.properties;\n    const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.properties.calloutLabelKey : void 0;\n    const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.properties.sectorLabelKey : void 0;\n    if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {\n      return {};\n    }\n    const labelFormatterParams = {\n      datum,\n      angleKey: this.properties.angleKey,\n      angleName: this.properties.angleName,\n      radiusKey: this.properties.radiusKey,\n      radiusName: this.properties.radiusName,\n      calloutLabelKey: this.properties.calloutLabelKey,\n      calloutLabelName: this.properties.calloutLabelName,\n      sectorLabelKey: this.properties.sectorLabelKey,\n      sectorLabelName: this.properties.sectorLabelName,\n      legendItemKey: this.properties.legendItemKey\n    };\n    const result = {};\n    if (calloutLabelKey && span > toRadians(calloutLabel.minAngle)) {\n      result.calloutLabel = {\n        ...this.getTextAlignment(midAngle),\n        text: this.getLabelText(calloutLabel, {\n          ...labelFormatterParams,\n          value: calloutLabelValue\n        }),\n        hidden: false,\n        collisionTextAlign: void 0,\n        collisionOffsetY: 0,\n        box: void 0\n      };\n    }\n    if (sectorLabelKey) {\n      result.sectorLabel = {\n        text: this.getLabelText(sectorLabel, {\n          ...labelFormatterParams,\n          value: sectorLabelValue\n        })\n      };\n    }\n    if (legendItemKey != null && legendItemValue != null) {\n      result.legendItem = { key: legendItemKey, text: legendItemValue };\n    }\n    return result;\n  }\n  getTextAlignment(midAngle) {\n    const quadrantTextOpts = [\n      { textAlign: \"center\", textBaseline: \"bottom\" },\n      { textAlign: \"left\", textBaseline: \"middle\" },\n      { textAlign: \"center\", textBaseline: \"hanging\" },\n      { textAlign: \"right\", textBaseline: \"middle\" }\n    ];\n    const midAngle180 = normalizeAngle180(midAngle);\n    const quadrantStart = -0.75 * Math.PI;\n    const quadrantOffset = midAngle180 - quadrantStart;\n    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));\n    const quadrantIndex = mod(quadrant, quadrantTextOpts.length);\n    return quadrantTextOpts[quadrantIndex];\n  }\n  getSectorFormat(datum, formatIndex, highlighted) {\n    const { callbackCache } = this.ctx;\n    const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey, fills, strokes, itemStyler } = this.properties;\n    const defaultStroke = strokes[formatIndex % strokes.length];\n    const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = mergeDefaults(\n      highlighted && this.properties.highlightStyle.item,\n      {\n        fill: fills.length > 0 ? fills[formatIndex % fills.length] : void 0,\n        stroke: defaultStroke,\n        strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),\n        strokeOpacity: this.getOpacity()\n      },\n      this.properties\n    );\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        datum,\n        angleKey,\n        radiusKey,\n        calloutLabelKey,\n        sectorLabelKey,\n        legendItemKey,\n        fill,\n        fillOpacity,\n        stroke,\n        strokeWidth,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        cornerRadius,\n        highlighted,\n        seriesId: this.id\n      });\n    }\n    return {\n      fill: format?.fill ?? fill,\n      fillOpacity: format?.fillOpacity ?? fillOpacity,\n      stroke: format?.stroke ?? stroke,\n      strokeWidth: format?.strokeWidth ?? strokeWidth,\n      strokeOpacity: format?.strokeOpacity ?? strokeOpacity,\n      lineDash: format?.lineDash ?? lineDash,\n      lineDashOffset: format?.lineDashOffset ?? lineDashOffset,\n      cornerRadius: format?.cornerRadius ?? cornerRadius\n    };\n  }\n  getInnerRadius() {\n    const { radius } = this;\n    const { innerRadiusRatio = 1, innerRadiusOffset = 0 } = this.properties;\n    const innerRadius = radius * innerRadiusRatio + innerRadiusOffset;\n    if (innerRadius === radius || innerRadius < 0) {\n      return 0;\n    }\n    return innerRadius;\n  }\n  getOuterRadius() {\n    const { outerRadiusRatio, outerRadiusOffset } = this.properties;\n    return Math.max(this.radius * outerRadiusRatio + outerRadiusOffset, 0);\n  }\n  updateRadiusScale(resize) {\n    const newRange = [this.getInnerRadius(), this.getOuterRadius()];\n    this.radiusScale.range = newRange;\n    if (resize) {\n      this.previousRadiusScale.range = newRange;\n    }\n    const setRadii = (d) => ({\n      ...d,\n      innerRadius: Math.max(this.radiusScale.convert(0), 0),\n      outerRadius: Math.max(this.radiusScale.convert(d.radius), 0)\n    });\n    this.nodeData = this.nodeData.map(setRadii);\n    this.phantomNodeData = this.phantomNodeData?.map(setRadii);\n  }\n  getTitleTranslationY() {\n    const outerRadius = Math.max(0, this.radiusScale.range[1]);\n    if (outerRadius === 0) {\n      return NaN;\n    }\n    const spacing = this.properties.title?.spacing ?? 0;\n    const titleOffset = 2 + spacing;\n    const dy = Math.max(0, -outerRadius);\n    return -outerRadius - titleOffset - dy;\n  }\n  async update({ seriesRect }) {\n    const { title } = this.properties;\n    const newNodeDataDependencies = {\n      seriesRectWidth: seriesRect?.width,\n      seriesRectHeight: seriesRect?.height\n    };\n    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n    if (resize) {\n      this._nodeDataDependencies = newNodeDataDependencies;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateTitleNodes();\n    this.updateRadiusScale(resize);\n    this.contentGroup.translationX = this.centerX;\n    this.contentGroup.translationY = this.centerY;\n    this.highlightGroup.translationX = this.centerX;\n    this.highlightGroup.translationY = this.centerY;\n    this.backgroundGroup.translationX = this.centerX;\n    this.backgroundGroup.translationY = this.centerY;\n    if (this.labelGroup) {\n      this.labelGroup.translationX = this.centerX;\n      this.labelGroup.translationY = this.centerY;\n    }\n    if (title) {\n      const dy = this.getTitleTranslationY();\n      const titleBox = title.node.getBBox();\n      title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox, 0, dy);\n      title.node.translationY = isFinite(dy) ? dy : 0;\n    }\n    for (const circle of [this.zerosumInnerRing, this.zerosumOuterRing]) {\n      circle.fillOpacity = 0;\n      circle.stroke = this.properties.calloutLabel.color;\n      circle.strokeWidth = 1;\n      circle.strokeOpacity = 1;\n    }\n    this.updateNodeMidPoint();\n    await this.updateSelections();\n    await this.updateNodes(seriesRect);\n  }\n  updateTitleNodes() {\n    const { oldTitle } = this;\n    const { title } = this.properties;\n    if (oldTitle !== title) {\n      if (oldTitle) {\n        this.labelGroup?.removeChild(oldTitle.node);\n      }\n      if (title) {\n        title.node.textBaseline = \"bottom\";\n        this.labelGroup?.appendChild(title.node);\n      }\n      this.oldTitle = title;\n    }\n  }\n  updateNodeMidPoint() {\n    const setMidPoint = (d) => {\n      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;\n      d.midPoint = {\n        x: d.midCos * Math.max(0, radius),\n        y: d.midSin * Math.max(0, radius)\n      };\n    };\n    this.nodeData.forEach(setMidPoint);\n    this.phantomNodeData?.forEach(setMidPoint);\n  }\n  async updateSelections() {\n    await this.updateGroupSelection();\n    this.updateInnerCircleSelection();\n  }\n  async updateGroupSelection() {\n    const {\n      itemSelection,\n      highlightSelection,\n      phantomSelection,\n      highlightLabelSelection,\n      calloutLabelSelection,\n      labelSelection,\n      innerLabelsSelection\n    } = this;\n    const highlightedNodeData = this.nodeData.map((datum) => ({\n      ...datum,\n      // Allow mutable sectorFormat, so formatted sector styles can be updated and varied\n      // between normal and highlighted cases.\n      sectorFormat: { ...datum.sectorFormat }\n    }));\n    const update = (selection, nodeData) => {\n      selection.update(nodeData, void 0, (datum) => this.getDatumId(datum));\n      if (this.ctx.animationManager.isSkipped()) {\n        selection.cleanup();\n      }\n    };\n    update(itemSelection, this.nodeData);\n    update(highlightSelection, highlightedNodeData);\n    update(phantomSelection, this.phantomNodeData ?? []);\n    calloutLabelSelection.update(this.calloutNodeData, (group) => {\n      const line = new Line();\n      line.tag = 0 /* Callout */;\n      line.pointerEvents = 1 /* None */;\n      group.appendChild(line);\n      const text = new Text();\n      text.tag = 1 /* Label */;\n      text.pointerEvents = 1 /* None */;\n      group.appendChild(text);\n    });\n    labelSelection.update(this.nodeData);\n    highlightLabelSelection.update(highlightedNodeData);\n    innerLabelsSelection.update(this.properties.innerLabels, (node) => {\n      node.pointerEvents = 1 /* None */;\n    });\n  }\n  updateInnerCircleSelection() {\n    const { innerCircle } = this.properties;\n    let radius = 0;\n    const innerRadius = this.getInnerRadius();\n    if (innerRadius > 0) {\n      const circleRadius = Math.min(innerRadius, this.getOuterRadius());\n      const antiAliasingPadding = 1;\n      radius = Math.ceil(circleRadius * 2 + antiAliasingPadding);\n    }\n    const datums = innerCircle ? [{ radius }] : [];\n    this.innerCircleSelection.update(datums);\n  }\n  async updateNodes(seriesRect) {\n    const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();\n    const isVisible = this.visible && this.seriesItemEnabled.indexOf(true) >= 0;\n    this.rootGroup.visible = isVisible;\n    this.backgroundGroup.visible = isVisible;\n    this.contentGroup.visible = isVisible;\n    this.highlightGroup.visible = isVisible && highlightedDatum?.series === this;\n    this.highlightLabel.visible = isVisible && highlightedDatum?.series === this;\n    if (this.labelGroup) {\n      this.labelGroup.visible = isVisible;\n    }\n    this.contentGroup.opacity = this.getOpacity();\n    this.innerCircleSelection.each((node, { radius }) => {\n      node.setProperties({\n        fill: this.properties.innerCircle?.fill,\n        opacity: this.properties.innerCircle?.fillOpacity,\n        size: radius\n      });\n    });\n    const animationDisabled = this.ctx.animationManager.isSkipped();\n    const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {\n      const format = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);\n      datum.sectorFormat.fill = format.fill;\n      datum.sectorFormat.stroke = format.stroke;\n      if (animationDisabled) {\n        sector.startAngle = datum.startAngle;\n        sector.endAngle = datum.endAngle;\n        sector.innerRadius = datum.innerRadius;\n        sector.outerRadius = datum.outerRadius;\n      }\n      if (isDatumHighlighted || animationDisabled) {\n        sector.fill = format.fill;\n        sector.stroke = format.stroke;\n      }\n      sector.strokeWidth = format.strokeWidth;\n      sector.fillOpacity = format.fillOpacity;\n      sector.strokeOpacity = format.strokeOpacity;\n      sector.lineDash = format.lineDash;\n      sector.lineDashOffset = format.lineDashOffset;\n      sector.cornerRadius = format.cornerRadius;\n      sector.fillShadow = this.properties.shadow;\n      const inset = Math.max(\n        (this.properties.sectorSpacing + (format.stroke != null ? format.strokeWidth : 0)) / 2,\n        0\n      );\n      sector.inset = inset;\n      sector.lineJoin = this.properties.sectorSpacing >= 0 || inset > 0 ? \"miter\" : \"round\";\n    };\n    this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.highlightSelection.each((node, datum, index) => {\n      if (datum.itemId === highlightedDatum?.itemId) {\n        node.visible = true;\n        updateSectorFn(node, datum, index, true);\n      } else {\n        node.visible = false;\n      }\n    });\n    this.phantomSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.updateCalloutLineNodes();\n    this.updateCalloutLabelNodes(seriesRect);\n    this.updateSectorLabelNodes();\n    this.updateInnerLabelNodes();\n    this.updateZerosumRings();\n    this.animationState.transition(\"update\");\n  }\n  updateCalloutLineNodes() {\n    const { calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const calloutStrokeWidth = calloutLine.strokeWidth;\n    const calloutColors = calloutLine.colors ?? this.properties.strokes;\n    const { offset: offset4 } = this.properties.calloutLabel;\n    this.calloutLabelSelection.selectByTag(0 /* Callout */).forEach((line, index) => {\n      const datum = line.datum;\n      const { calloutLabel: label, outerRadius } = datum;\n      if (label?.text && !label.hidden && outerRadius !== 0) {\n        line.visible = true;\n        line.strokeWidth = calloutStrokeWidth;\n        line.stroke = calloutColors[index % calloutColors.length];\n        line.fill = void 0;\n        const x1 = datum.midCos * outerRadius;\n        const y1 = datum.midSin * outerRadius;\n        let x2 = datum.midCos * (outerRadius + calloutLength);\n        let y2 = datum.midSin * (outerRadius + calloutLength);\n        const isMoved = label.collisionTextAlign ?? label.collisionOffsetY !== 0;\n        if (isMoved && label.box != null) {\n          const box = label.box;\n          let cx = x2;\n          let cy = y2;\n          if (x2 < box.x) {\n            cx = box.x;\n          } else if (x2 > box.x + box.width) {\n            cx = box.x + box.width;\n          }\n          if (y2 < box.y) {\n            cy = box.y;\n          } else if (y2 > box.y + box.height) {\n            cy = box.y + box.height;\n          }\n          const dx = cx - x2;\n          const dy = cy - y2;\n          const length2 = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n          const paddedLength = length2 - offset4;\n          if (paddedLength > 0) {\n            x2 = x2 + dx * paddedLength / length2;\n            y2 = y2 + dy * paddedLength / length2;\n          }\n        }\n        line.x1 = x1;\n        line.y1 = y1;\n        line.x2 = x2;\n        line.y2 = y2;\n      } else {\n        line.visible = false;\n      }\n    });\n  }\n  getLabelOverflow(text, box, seriesRect) {\n    const seriesLeft = seriesRect.x - this.centerX;\n    const seriesRight = seriesRect.x + seriesRect.width - this.centerX;\n    const seriesTop = seriesRect.y - this.centerY;\n    const seriesBottom = seriesRect.y + seriesRect.height - this.centerY;\n    const errPx = 1;\n    let visibleTextPart = 1;\n    if (box.x + errPx < seriesLeft) {\n      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;\n    } else if (box.x + box.width - errPx > seriesRight) {\n      visibleTextPart = (seriesRight - box.x) / box.width;\n    }\n    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;\n    const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;\n    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);\n    return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };\n  }\n  bboxIntersectsSurroundingSeries(box, dx = 0, dy = 0) {\n    const { surroundingRadius } = this;\n    if (surroundingRadius == null) {\n      return false;\n    }\n    const corners = [\n      { x: box.x + dx, y: box.y + dy },\n      { x: box.x + box.width + dx, y: box.y + dy },\n      { x: box.x + box.width + dx, y: box.y + box.height + dy },\n      { x: box.x + dx, y: box.y + box.height + dy }\n    ];\n    const sur2 = surroundingRadius ** 2;\n    return corners.some((corner) => corner.x ** 2 + corner.y ** 2 > sur2);\n  }\n  computeCalloutLabelCollisionOffsets() {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const { offset: offset4, minSpacing } = calloutLabel;\n    const innerRadius = radiusScale.convert(0);\n    const shouldSkip = (datum) => {\n      const label = datum.calloutLabel;\n      return !label || datum.outerRadius === 0;\n    };\n    const fullData = this.calloutNodeData;\n    const data = fullData.filter((t) => !shouldSkip(t));\n    data.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return;\n      label.hidden = false;\n      label.collisionTextAlign = void 0;\n      label.collisionOffsetY = 0;\n    });\n    if (data.length <= 1) {\n      return;\n    }\n    const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);\n    const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);\n    const topLabels = data.filter((d) => d.midSin < 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const bottomLabels = data.filter((d) => d.midSin >= 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const getTextBBox = (datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return BBox.zero.clone();\n      const labelRadius = datum.outerRadius + calloutLine.length + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const textAlign = label.collisionTextAlign ?? label.textAlign;\n      const textBaseline = label.textBaseline;\n      return Text.computeBBox(label.text, x, y, {\n        font: this.properties.calloutLabel,\n        textAlign,\n        textBaseline\n      });\n    };\n    const avoidNeighbourYCollision = (label, next, direction) => {\n      const box = getTextBBox(label).grow(minSpacing / 2);\n      const other = getTextBBox(next).grow(minSpacing / 2);\n      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === \"to-top\" ? box.y < other.y + other.height : box.y + box.height > other.y);\n      if (collidesOrBehind) {\n        const dy = direction === \"to-top\" ? box.y - other.y - other.height : box.y + box.height - other.y;\n        next.calloutLabel.collisionOffsetY = dy;\n      }\n    };\n    const avoidYCollisions = (labels) => {\n      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];\n      const midIndex = labels.indexOf(midLabel);\n      for (let i = midIndex - 1; i >= 0; i--) {\n        const prev = labels[i + 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-top\");\n      }\n      for (let i = midIndex + 1; i < labels.length; i++) {\n        const prev = labels[i - 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-bottom\");\n      }\n    };\n    const avoidXCollisions = (labels) => {\n      const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);\n      const boxes = labels.map((label) => getTextBBox(label));\n      const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));\n      let labelsCollideLabelsByX = false;\n      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {\n        const box = paddedBoxes[i];\n        for (let j = i + 1; j < labels.length; j++) {\n          const other = paddedBoxes[j];\n          if (box.collidesBBox(other)) {\n            labelsCollideLabelsByX = true;\n            break;\n          }\n        }\n      }\n      const sectors = fullData.map((datum) => {\n        const { startAngle, endAngle, outerRadius } = datum;\n        return { startAngle, endAngle, innerRadius, outerRadius };\n      });\n      const labelsCollideSectors = boxes.some((box) => {\n        return sectors.some((sector) => boxCollidesSector(box, sector));\n      });\n      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {\n        return;\n      }\n      labels.filter((d) => d.calloutLabel.textAlign === \"center\").forEach((d) => {\n        const label = d.calloutLabel;\n        if (d.midCos < 0) {\n          label.collisionTextAlign = \"right\";\n        } else if (d.midCos > 0) {\n          label.collisionTextAlign = \"left\";\n        } else {\n          label.collisionTextAlign = \"center\";\n        }\n      });\n    };\n    avoidYCollisions(leftLabels);\n    avoidYCollisions(rightLabels);\n    avoidXCollisions(topLabels);\n    avoidXCollisions(bottomLabels);\n  }\n  updateCalloutLabelNodes(seriesRect) {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, color } = calloutLabel;\n    const tempTextNode = new Text();\n    this.calloutLabelSelection.selectByTag(1 /* Label */).forEach((text) => {\n      const { datum } = text;\n      const label = datum.calloutLabel;\n      const radius = radiusScale.convert(datum.radius);\n      const outerRadius = Math.max(0, radius);\n      if (!label?.text || outerRadius === 0 || label.hidden) {\n        text.visible = false;\n        return;\n      }\n      const labelRadius = outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const align = {\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      };\n      tempTextNode.text = label.text;\n      tempTextNode.x = x;\n      tempTextNode.y = y;\n      tempTextNode.setFont(this.properties.calloutLabel);\n      tempTextNode.setAlign(align);\n      const box = tempTextNode.getBBox();\n      let displayText = label.text;\n      let visible = true;\n      if (calloutLabel.avoidCollisions) {\n        const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);\n        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\\u2026`;\n        visible = !hasVerticalOverflow;\n      }\n      text.text = displayText;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign(align);\n      text.fill = color;\n      text.visible = visible;\n    });\n  }\n  async computeLabelsBBox(options, seriesRect) {\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, maxCollisionOffset, minSpacing } = calloutLabel;\n    if (!calloutLabel.avoidCollisions) {\n      return null;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateRadiusScale(false);\n    this.computeCalloutLabelCollisionOffsets();\n    const textBoxes = [];\n    const text = new Text();\n    let titleBox;\n    const { title } = this.properties;\n    if (title?.text && title.enabled) {\n      const dy = this.getTitleTranslationY();\n      if (isFinite(dy)) {\n        text.text = title.text;\n        text.x = 0;\n        text.y = dy;\n        text.setFont(title);\n        text.setAlign({\n          textBaseline: \"bottom\",\n          textAlign: \"center\"\n        });\n        titleBox = text.getBBox();\n        textBoxes.push(titleBox);\n      }\n    }\n    this.calloutNodeData.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (!label || datum.outerRadius === 0) {\n        return null;\n      }\n      const labelRadius = datum.outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      text.text = label.text;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign({\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      });\n      const box = text.getBBox();\n      label.box = box;\n      if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {\n        label.hidden = true;\n        return;\n      }\n      if (titleBox) {\n        const seriesTop = seriesRect.y - this.centerY;\n        const titleCleanArea = new BBox(\n          titleBox.x - minSpacing,\n          seriesTop,\n          titleBox.width + 2 * minSpacing,\n          titleBox.y + titleBox.height + minSpacing - seriesTop\n        );\n        if (box.collidesBBox(titleCleanArea)) {\n          label.hidden = true;\n          return;\n        }\n      }\n      if (options.hideWhenNecessary) {\n        const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(\n          label.text,\n          box,\n          seriesRect\n        );\n        const isTooShort = label.text.length > 2 && textLength < 2;\n        if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {\n          label.hidden = true;\n          return;\n        }\n      }\n      label.hidden = false;\n      textBoxes.push(box);\n    });\n    if (textBoxes.length === 0) {\n      return null;\n    }\n    return BBox.merge(textBoxes);\n  }\n  updateSectorLabelNodes() {\n    const { radiusScale } = this;\n    const innerRadius = radiusScale.convert(0);\n    const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color } = this.properties.sectorLabel;\n    const updateSectorLabel = (text, datum) => {\n      const { sectorLabel, outerRadius } = datum;\n      let isTextVisible = false;\n      if (sectorLabel && outerRadius !== 0) {\n        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;\n        text.fill = color;\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.text = sectorLabel.text;\n        text.x = datum.midCos * labelRadius;\n        text.y = datum.midSin * labelRadius;\n        text.textAlign = \"center\";\n        text.textBaseline = \"middle\";\n        const bbox = text.getBBox();\n        const corners = [\n          [bbox.x, bbox.y],\n          [bbox.x + bbox.width, bbox.y],\n          [bbox.x + bbox.width, bbox.y + bbox.height],\n          [bbox.x, bbox.y + bbox.height]\n        ];\n        const { startAngle, endAngle } = datum;\n        const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };\n        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {\n          isTextVisible = true;\n        }\n      }\n      text.visible = isTextVisible;\n    };\n    this.labelSelection.each(updateSectorLabel);\n    this.highlightLabelSelection.each(updateSectorLabel);\n  }\n  updateInnerLabelNodes() {\n    const textBBoxes = [];\n    const margins = [];\n    this.innerLabelsSelection.each((text, datum) => {\n      const { fontStyle, fontWeight, fontSize, fontFamily, color } = datum;\n      text.fontStyle = fontStyle;\n      text.fontWeight = fontWeight;\n      text.fontSize = fontSize;\n      text.fontFamily = fontFamily;\n      text.text = datum.text;\n      text.x = 0;\n      text.y = 0;\n      text.fill = color;\n      text.textAlign = \"center\";\n      text.textBaseline = \"alphabetic\";\n      textBBoxes.push(text.getBBox());\n      margins.push(datum.spacing);\n    });\n    const getMarginTop = (index) => index === 0 ? 0 : margins[index];\n    const getMarginBottom = (index) => index === margins.length - 1 ? 0 : margins[index];\n    const totalHeight = textBBoxes.reduce((sum2, bbox, i) => {\n      return sum2 + bbox.height + getMarginTop(i) + getMarginBottom(i);\n    }, 0);\n    const totalWidth = Math.max(...textBBoxes.map((bbox) => bbox.width));\n    const innerRadius = this.getInnerRadius();\n    const labelRadius = Math.sqrt(Math.pow(totalWidth / 2, 2) + Math.pow(totalHeight / 2, 2));\n    const labelsVisible = labelRadius <= (innerRadius > 0 ? innerRadius : this.getOuterRadius());\n    const textBottoms = [];\n    for (let i = 0, prev = -totalHeight / 2; i < textBBoxes.length; i++) {\n      const bbox = textBBoxes[i];\n      const bottom = bbox.height + prev + getMarginTop(i);\n      textBottoms.push(bottom);\n      prev = bottom + getMarginBottom(i);\n    }\n    this.innerLabelsSelection.each((text, _datum, index) => {\n      text.y = textBottoms[index];\n      text.visible = labelsVisible;\n    });\n  }\n  updateZerosumRings() {\n    this.zerosumOuterRing.size = this.getOuterRadius() * 2;\n    this.zerosumInnerRing.size = this.getInnerRadius() * 2;\n  }\n  getDatumLegendName(nodeDatum) {\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const { sectorLabel, calloutLabel, legendItem } = nodeDatum;\n    if (legendItemKey && legendItem !== void 0) {\n      return legendItem.text;\n    } else if (calloutLabelKey && calloutLabelKey !== angleKey && calloutLabel?.text !== void 0) {\n      return calloutLabel.text;\n    } else if (sectorLabelKey && sectorLabelKey !== angleKey && sectorLabel?.text !== void 0) {\n      return sectorLabel.text;\n    }\n  }\n  pickNodeClosestDatum(point) {\n    return pickByMatchingAngle(this, point);\n  }\n  getTooltipHtml(nodeDatum) {\n    if (!this.properties.isValid()) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const {\n      datum,\n      angleValue,\n      sectorFormat: { fill: color },\n      itemId\n    } = nodeDatum;\n    const title = sanitizeHtml(this.properties.title?.text);\n    const content = isFiniteNumber(angleValue) ? toFixed(angleValue) : String(angleValue);\n    const labelText = this.getDatumLegendName(nodeDatum);\n    return this.properties.tooltip.toTooltipHtml(\n      {\n        title: title ?? labelText,\n        content: title && labelText ? `${labelText}: ${content}` : content,\n        backgroundColor: color\n      },\n      {\n        datum,\n        itemId,\n        title,\n        color,\n        seriesId: this.id,\n        angleKey: this.properties.angleKey,\n        angleName: this.properties.angleName,\n        radiusKey: this.properties.radiusKey,\n        radiusName: this.properties.radiusName,\n        calloutLabelKey: this.properties.calloutLabelKey,\n        calloutLabelName: this.properties.calloutLabelName,\n        sectorLabelKey: this.properties.sectorLabelKey,\n        sectorLabelName: this.properties.sectorLabelName,\n        legendItemKey: this.properties.legendItemKey\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { visible, processedData, dataModel } = this;\n    if (!dataModel || !processedData?.data.length || !this.properties.isValid() || legendType !== \"category\") {\n      return [];\n    }\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey))\n      return [];\n    const { calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);\n    const titleText = this.properties.title?.showInLegend && this.properties.title.text;\n    const legendData = [];\n    for (let index = 0; index < processedData.data.length; index++) {\n      const { datum, values } = processedData.data[index];\n      const labelParts = [];\n      if (titleText) {\n        labelParts.push(titleText);\n      }\n      const labels = this.getLabels(\n        datum,\n        2 * Math.PI,\n        2 * Math.PI,\n        false,\n        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,\n        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,\n        legendItemIdx != null ? values[legendItemIdx] : void 0\n      );\n      if (legendItemKey && labels.legendItem !== void 0) {\n        labelParts.push(labels.legendItem.text);\n      } else if (calloutLabelKey && calloutLabelKey !== angleKey && labels.calloutLabel?.text !== void 0) {\n        labelParts.push(labels.calloutLabel?.text);\n      } else if (sectorLabelKey && sectorLabelKey !== angleKey && labels.sectorLabel?.text !== void 0) {\n        labelParts.push(labels.sectorLabel?.text);\n      }\n      if (labelParts.length === 0)\n        continue;\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      legendData.push({\n        legendType: \"category\",\n        id: this.id,\n        itemId: index,\n        seriesId: this.id,\n        enabled: visible && this.seriesItemEnabled[index],\n        label: {\n          text: labelParts.join(\" - \")\n        },\n        symbols: [\n          {\n            marker: {\n              fill: sectorFormat.fill,\n              stroke: sectorFormat.stroke,\n              fillOpacity: this.properties.fillOpacity,\n              strokeOpacity: this.properties.strokeOpacity,\n              strokeWidth: this.properties.strokeWidth\n            }\n          }\n        ],\n        legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0\n      });\n    }\n    return legendData;\n  }\n  onLegendItemClick(event) {\n    const { enabled, itemId, series, legendItemName } = event;\n    if (series.id === this.id) {\n      this.toggleSeriesItem(itemId, enabled);\n    } else if (legendItemName != null) {\n      this.toggleOtherSeriesItems(legendItemName, enabled);\n    }\n  }\n  toggleSeriesItem(itemId, enabled) {\n    this.seriesItemEnabled[itemId] = enabled;\n    if (this.nodeData[itemId]) {\n      this.nodeData[itemId].enabled = enabled;\n    }\n    this.nodeDataRefresh = true;\n  }\n  toggleOtherSeriesItems(legendItemName, enabled) {\n    if (!this.properties.legendItemKey || !this.dataModel) {\n      return;\n    }\n    const legendItemIdx = this.dataModel.resolveProcessedDataIndexById(this, `legendItemValue`);\n    this.processedData?.data.forEach(({ values }, datumItemId) => {\n      if (values[legendItemIdx] === legendItemName) {\n        this.toggleSeriesItem(datumItemId, enabled);\n      }\n    });\n  }\n  animateEmptyUpdateReady(_data) {\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      true,\n      this.properties.rotation,\n      this.radiusScale,\n      this.previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [this.itemSelection, this.highlightSelection, this.phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum)\n    );\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeInAnimation(this, \"callout\", animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", animationManager, this.highlightLabelSelection);\n    seriesLabelFadeInAnimation(this, \"inner\", animationManager, this.innerLabelsSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateWaitingUpdateReady() {\n    const { itemSelection, highlightSelection, phantomSelection, processedData, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const dataDiff = processedData?.reduced?.diff;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const supportedDiff = (dataDiff?.moved.size ?? 0) === 0;\n    const hasKeys = (processedData?.defs.keys.length ?? 0) > 0;\n    const hasUniqueKeys = processedData?.reduced?.animationValidation?.uniqueKeys ?? true;\n    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum),\n      dataDiff\n    );\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeInAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    seriesLabelFadeInAnimation(this, \"inner\", this.ctx.animationManager, this.innerLabelsSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateClearingUpdateEmpty() {\n    const { itemSelection, highlightSelection, phantomSelection, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum)\n    );\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeOutAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeOutAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeOutAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    seriesLabelFadeOutAnimation(this, \"inner\", this.ctx.animationManager, this.innerLabelsSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  getDatumIdFromData(datum) {\n    const { calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!this.processedData?.reduced?.animationValidation?.uniqueKeys) {\n      return;\n    }\n    if (legendItemKey) {\n      return datum[legendItemKey];\n    } else if (calloutLabelKey) {\n      return datum[calloutLabelKey];\n    } else if (sectorLabelKey) {\n      return datum[sectorLabelKey];\n    }\n  }\n  getDatumId(datum) {\n    const { index } = datum;\n    const datumId = this.getDatumIdFromData(datum.datum);\n    return datumId != null ? String(datumId) : `${index}`;\n  }\n  onDataChange() {\n    const { data, seriesItemEnabled } = this;\n    this.seriesItemEnabled = data?.map((_, index) => seriesItemEnabled[index] ?? true) ?? [];\n  }\n};\nDonutSeries.className = \"DonutSeries\";\nDonutSeries.type = \"donut\";\n\n// packages/ag-charts-community/src/chart/series/polar/donutTheme.ts\nvar donutTheme = {\n  series: {\n    title: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 14,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_MUTED_LABEL_COLOUR,\n      spacing: 5\n    },\n    calloutLabel: {\n      enabled: true,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR,\n      offset: 3,\n      minAngle: 0\n    },\n    sectorLabel: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n      positionOffset: 0,\n      positionRatio: 0.5\n    },\n    calloutLine: {\n      length: 10,\n      strokeWidth: 2\n    },\n    fillOpacity: 1,\n    strokeOpacity: 1,\n    strokeWidth: 0,\n    lineDash: [0],\n    lineDashOffset: 0,\n    rotation: 0,\n    sectorSpacing: 1,\n    shadow: {\n      enabled: false,\n      color: DEFAULT_SHADOW_COLOUR,\n      xOffset: 3,\n      yOffset: 3,\n      blur: 5\n    },\n    innerLabels: {\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR,\n      spacing: 2\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/polar/pieTheme.ts\nvar pieTheme = {\n  series: {\n    title: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 14,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_MUTED_LABEL_COLOUR,\n      spacing: 5\n    },\n    calloutLabel: {\n      enabled: true,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR,\n      offset: 3,\n      minAngle: 0\n    },\n    sectorLabel: {\n      enabled: true,\n      fontWeight: \"normal\" /* NORMAL */,\n      fontSize: 12 /* SMALL */,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n      positionOffset: 0,\n      positionRatio: 0.5\n    },\n    calloutLine: {\n      length: 10,\n      strokeWidth: 2\n    },\n    fillOpacity: 1,\n    strokeOpacity: 1,\n    strokeWidth: 0,\n    lineDash: [0],\n    lineDashOffset: 0,\n    rotation: 0,\n    sectorSpacing: 1,\n    shadow: {\n      enabled: false,\n      color: DEFAULT_SHADOW_COLOUR,\n      xOffset: 3,\n      yOffset: 3,\n      blur: 5\n    }\n  }\n};\nvar piePaletteFactory = ({ takeColors, colorsCount }) => {\n  const { fills, strokes } = takeColors(colorsCount);\n  return { fills, strokes, calloutLine: { colors: strokes } };\n};\n\n// packages/ag-charts-community/src/chart/series/polar/donutSeriesModule.ts\nvar DonutSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"polar\"],\n  identifier: \"donut\",\n  moduleFactory: (ctx) => new DonutSeries(ctx),\n  tooltipDefaults: { range: \"exact\" },\n  themeTemplate: donutTheme,\n  paletteFactory: piePaletteFactory\n};\n\n// packages/ag-charts-community/src/chart/series/polar/pieSeriesProperties.ts\nvar PieTitle = class extends Caption {\n  constructor() {\n    super(...arguments);\n    this.showInLegend = false;\n  }\n};\n__decorateClass([\n  Validate(BOOLEAN)\n], PieTitle.prototype, \"showInLegend\", 2);\nvar PieSeriesCalloutLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.offset = 3;\n    this.minAngle = 0;\n    this.minSpacing = 4;\n    this.maxCollisionOffset = 50;\n    this.avoidCollisions = true;\n  }\n};\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLabel.prototype, \"offset\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], PieSeriesCalloutLabel.prototype, \"minAngle\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLabel.prototype, \"minSpacing\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLabel.prototype, \"maxCollisionOffset\", 2);\n__decorateClass([\n  Validate(BOOLEAN)\n], PieSeriesCalloutLabel.prototype, \"avoidCollisions\", 2);\nvar PieSeriesSectorLabel = class extends Label {\n  constructor() {\n    super(...arguments);\n    this.positionOffset = 0;\n    this.positionRatio = 0.5;\n  }\n};\n__decorateClass([\n  Validate(NUMBER)\n], PieSeriesSectorLabel.prototype, \"positionOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesSectorLabel.prototype, \"positionRatio\", 2);\nvar PieSeriesCalloutLine = class extends BaseProperties {\n  constructor() {\n    super(...arguments);\n    this.length = 10;\n    this.strokeWidth = 1;\n  }\n};\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY, { optional: true })\n], PieSeriesCalloutLine.prototype, \"colors\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLine.prototype, \"length\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesCalloutLine.prototype, \"strokeWidth\", 2);\nvar PieSeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.cornerRadius = 0;\n    this.rotation = 0;\n    this.outerRadiusOffset = 0;\n    this.outerRadiusRatio = 1;\n    this.strokeWidth = 1;\n    this.sectorSpacing = 0;\n    this.title = new PieTitle();\n    this.shadow = new DropShadow();\n    this.calloutLabel = new PieSeriesCalloutLabel();\n    this.sectorLabel = new PieSeriesSectorLabel();\n    this.calloutLine = new PieSeriesCalloutLine();\n    this.tooltip = new SeriesTooltip();\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], PieSeriesProperties.prototype, \"angleKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"angleName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"angleFilterKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"radiusKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"radiusName\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], PieSeriesProperties.prototype, \"radiusMin\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER, { optional: true })\n], PieSeriesProperties.prototype, \"radiusMax\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"calloutLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"calloutLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"sectorLabelKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"sectorLabelName\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], PieSeriesProperties.prototype, \"legendItemKey\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], PieSeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], PieSeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesProperties.prototype, \"fillOpacity\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesProperties.prototype, \"strokeOpacity\", 2);\n__decorateClass([\n  Validate(LINE_DASH)\n], PieSeriesProperties.prototype, \"lineDash\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesProperties.prototype, \"lineDashOffset\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesProperties.prototype, \"cornerRadius\", 2);\n__decorateClass([\n  Validate(FUNCTION, { optional: true })\n], PieSeriesProperties.prototype, \"itemStyler\", 2);\n__decorateClass([\n  Validate(DEGREE)\n], PieSeriesProperties.prototype, \"rotation\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], PieSeriesProperties.prototype, \"outerRadiusOffset\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PieSeriesProperties.prototype, \"outerRadiusRatio\", 2);\n__decorateClass([\n  Validate(POSITIVE_NUMBER)\n], PieSeriesProperties.prototype, \"strokeWidth\", 2);\n__decorateClass([\n  Validate(NUMBER)\n], PieSeriesProperties.prototype, \"sectorSpacing\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"title\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"shadow\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"calloutLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"sectorLabel\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"calloutLine\", 2);\n__decorateClass([\n  Validate(OBJECT)\n], PieSeriesProperties.prototype, \"tooltip\", 2);\n\n// packages/ag-charts-community/src/chart/series/polar/pieSeries.ts\nvar PieSeriesNodeEvent = class extends SeriesNodeEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.angleKey = series.properties.angleKey;\n    this.radiusKey = series.properties.radiusKey;\n    this.calloutLabelKey = series.properties.calloutLabelKey;\n    this.sectorLabelKey = series.properties.sectorLabelKey;\n  }\n};\nvar PieSeries = class extends PolarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      useLabelLayer: true,\n      animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn }\n    });\n    this.properties = new PieSeriesProperties();\n    this.phantomNodeData = void 0;\n    this.previousRadiusScale = new LinearScale();\n    this.radiusScale = new LinearScale();\n    this.phantomGroup = this.contentGroup.appendChild(new Group());\n    this.phantomSelection = Selection.select(\n      this.phantomGroup,\n      () => this.nodeFactory(),\n      false\n    );\n    this.calloutLabelGroup = this.contentGroup.appendChild(new Group({ name: \"pieCalloutLabels\" }));\n    this.calloutLabelSelection = new Selection(\n      this.calloutLabelGroup,\n      Group\n    );\n    // The group node that contains the background graphics.\n    this.backgroundGroup = this.rootGroup.appendChild(\n      new Group({\n        name: `${this.id}-background`,\n        layer: true,\n        zIndex: 0 /* SERIES_BACKGROUND_ZINDEX */\n      })\n    );\n    // AG-6193 If the sum of all datums is 0, then we'll draw 1 or 2 rings to represent the empty series.\n    this.zerosumRingsGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-zerosumRings` }));\n    this.zerosumOuterRing = this.zerosumRingsGroup.appendChild(new Circle());\n    // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.\n    this.seriesItemEnabled = [];\n    this.surroundingRadius = void 0;\n    this.NodeEvent = PieSeriesNodeEvent;\n    this.angleScale = new LinearScale();\n    this.angleScale.domain = [0, 1];\n    this.angleScale.range = [-Math.PI, Math.PI].map((angle2) => angle2 + Math.PI / 2);\n    this.phantomGroup.opacity = 0.2;\n    this.phantomGroup.zIndexSubOrder = [() => this._declarationOrder, 0];\n  }\n  get calloutNodeData() {\n    return this.phantomNodeData ?? this.nodeData;\n  }\n  addChartEventListeners() {\n    this.destroyFns.push(\n      this.ctx.chartEventManager?.addListener(\"legend-item-click\", (event) => this.onLegendItemClick(event))\n    );\n  }\n  get visible() {\n    return super.visible && (this.seriesItemEnabled.length === 0 || this.seriesItemEnabled.some((visible) => visible));\n  }\n  nodeFactory() {\n    const sector = new Sector();\n    sector.miterLimit = 1e9;\n    return sector;\n  }\n  getSeriesDomain(direction) {\n    if (direction === \"x\" /* X */) {\n      return this.angleScale.domain;\n    } else {\n      return this.radiusScale.domain;\n    }\n  }\n  async processData(dataController) {\n    if (this.data == null || !this.properties.isValid()) {\n      return;\n    }\n    let { data } = this;\n    const { visible, seriesItemEnabled } = this;\n    const { angleKey, angleFilterKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const animationEnabled = !this.ctx.animationManager.isSkipped();\n    const extraKeyProps = [];\n    const extraProps = [];\n    if (legendItemKey) {\n      extraKeyProps.push(keyProperty(legendItemKey, \"band\", { id: `legendItemKey` }));\n    } else if (calloutLabelKey) {\n      extraKeyProps.push(keyProperty(calloutLabelKey, \"band\", { id: `calloutLabelKey` }));\n    } else if (sectorLabelKey) {\n      extraKeyProps.push(keyProperty(sectorLabelKey, \"band\", { id: `sectorLabelKey` }));\n    }\n    const radiusScaleType = this.radiusScale.type;\n    const angleScaleType = this.radiusScale.type;\n    if (radiusKey) {\n      extraProps.push(\n        rangedValueProperty(radiusKey, {\n          id: \"radiusValue\",\n          min: this.properties.radiusMin ?? 0,\n          max: this.properties.radiusMax\n        }),\n        valueProperty(radiusKey, radiusScaleType, { id: `radiusRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"radiusValue\", [0, 1], 1, this.properties.radiusMin ?? 0, this.properties.radiusMax)\n      );\n    }\n    if (calloutLabelKey) {\n      extraProps.push(valueProperty(calloutLabelKey, \"band\", { id: `calloutLabelValue` }));\n    }\n    if (sectorLabelKey) {\n      extraProps.push(valueProperty(sectorLabelKey, \"band\", { id: `sectorLabelValue` }));\n    }\n    if (legendItemKey) {\n      extraProps.push(valueProperty(legendItemKey, \"band\", { id: `legendItemValue` }));\n    }\n    if (angleFilterKey) {\n      extraProps.push(\n        accumulativeValueProperty(angleFilterKey, angleScaleType, {\n          id: `angleFilterValue`,\n          onlyPositive: true\n        }),\n        valueProperty(angleFilterKey, angleScaleType, { id: `angleFilterRaw` }),\n        normalisePropertyTo(\"angleFilterValue\", [0, 1], 0, 0)\n      );\n    }\n    if (animationEnabled && this.processedData?.reduced?.animationValidation?.uniqueKeys && extraKeyProps.length > 0) {\n      extraProps.push(diff(this.processedData));\n    }\n    extraProps.push(animationValidation());\n    data = data.map((d, idx) => visible && seriesItemEnabled[idx] ? d : { ...d, [angleKey]: 0 });\n    await this.requestDataModel(dataController, data, {\n      props: [\n        ...extraKeyProps,\n        accumulativeValueProperty(angleKey, angleScaleType, { id: `angleValue`, onlyPositive: true }),\n        valueProperty(angleKey, angleScaleType, { id: `angleRaw` }),\n        // Raw value pass-through.\n        normalisePropertyTo(\"angleValue\", [0, 1], 0, 0),\n        ...extraProps\n      ]\n    });\n    for (const valueDef of this.processedData?.defs?.values ?? []) {\n      const { id, missing, property } = valueDef;\n      const missCount = getMissCount(this, missing);\n      if (id !== \"angleRaw\" && missCount > 0) {\n        Logger.warnOnce(\n          `no value was found for the key '${String(property)}' on ${missCount} data element${missCount > 1 ? \"s\" : \"\"}`\n        );\n      }\n    }\n    this.animationState.transition(\"updateData\");\n  }\n  async maybeRefreshNodeData() {\n    if (!this.nodeDataRefresh)\n      return;\n    const { nodeData = [], phantomNodeData } = await this.createNodeData() ?? {};\n    this.nodeData = nodeData;\n    this.phantomNodeData = phantomNodeData;\n    this.nodeDataRefresh = false;\n  }\n  getProcessedDataIndexes(dataModel) {\n    const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`);\n    const angleRawIdx = dataModel.resolveProcessedDataIndexById(this, `angleRaw`);\n    const angleFilterIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterValue`) : void 0;\n    const angleFilterRawIdx = this.properties.angleFilterKey != null ? dataModel.resolveProcessedDataIndexById(this, `angleFilterRaw`) : void 0;\n    const radiusIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusValue`) : void 0;\n    const radiusRawIdx = this.properties.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusRaw`) : void 0;\n    const calloutLabelIdx = this.properties.calloutLabelKey ? dataModel.resolveProcessedDataIndexById(this, `calloutLabelValue`) : void 0;\n    const sectorLabelIdx = this.properties.sectorLabelKey ? dataModel.resolveProcessedDataIndexById(this, `sectorLabelValue`) : void 0;\n    const legendItemIdx = this.properties.legendItemKey ? dataModel.resolveProcessedDataIndexById(this, `legendItemValue`) : void 0;\n    return {\n      angleIdx,\n      angleRawIdx,\n      angleFilterIdx,\n      angleFilterRawIdx,\n      radiusIdx,\n      radiusRawIdx,\n      calloutLabelIdx,\n      sectorLabelIdx,\n      legendItemIdx\n    };\n  }\n  async createNodeData() {\n    const { id: seriesId, processedData, dataModel, angleScale } = this;\n    const { rotation } = this.properties;\n    if (!processedData || !dataModel || processedData.type !== \"ungrouped\")\n      return;\n    const {\n      angleIdx,\n      angleRawIdx,\n      angleFilterIdx,\n      angleFilterRawIdx,\n      radiusIdx,\n      radiusRawIdx,\n      calloutLabelIdx,\n      sectorLabelIdx,\n      legendItemIdx\n    } = this.getProcessedDataIndexes(dataModel);\n    const useFilterAngles = angleFilterRawIdx != null && processedData.data.some(({ values }) => {\n      return values[angleFilterRawIdx] > values[angleRawIdx];\n    });\n    let currentStart = 0;\n    let sum2 = 0;\n    const nodes = [];\n    const phantomNodes = angleFilterRawIdx != null ? [] : void 0;\n    processedData.data.forEach((group, index) => {\n      const { datum, values } = group;\n      const currentValue = useFilterAngles ? values[angleFilterIdx] : values[angleIdx];\n      const crossFilterScale = angleFilterRawIdx != null && !useFilterAngles ? Math.sqrt(values[angleFilterRawIdx] / values[angleRawIdx]) : 1;\n      const startAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      currentStart = currentValue;\n      sum2 += currentValue;\n      const endAngle = angleScale.convert(currentStart) + toRadians(rotation);\n      const span = Math.abs(endAngle - startAngle);\n      const midAngle = startAngle + span / 2;\n      const angleValue = values[angleRawIdx];\n      const radiusRaw = radiusIdx != null ? values[radiusIdx] ?? 1 : 1;\n      const radius = radiusRaw * crossFilterScale;\n      const radiusValue = radiusRawIdx != null ? values[radiusRawIdx] : void 0;\n      const legendItemValue = legendItemIdx != null ? values[legendItemIdx] : void 0;\n      const nodeLabels = this.getLabels(\n        datum,\n        midAngle,\n        span,\n        true,\n        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,\n        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,\n        legendItemValue\n      );\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      const node = {\n        itemId: index,\n        series: this,\n        datum,\n        index,\n        angleValue,\n        midAngle,\n        midCos: Math.cos(midAngle),\n        midSin: Math.sin(midAngle),\n        startAngle,\n        endAngle,\n        radius,\n        innerRadius: Math.max(this.radiusScale.convert(0), 0),\n        outerRadius: Math.max(this.radiusScale.convert(radius), 0),\n        sectorFormat,\n        radiusValue,\n        legendItemValue,\n        enabled: this.seriesItemEnabled[index],\n        ...nodeLabels\n      };\n      nodes.push(node);\n      if (phantomNodes != null) {\n        phantomNodes.push({\n          ...node,\n          radius: 1,\n          innerRadius: Math.max(this.radiusScale.convert(0), 0),\n          outerRadius: Math.max(this.radiusScale.convert(1), 0)\n        });\n      }\n    });\n    this.zerosumOuterRing.visible = sum2 === 0;\n    return {\n      itemId: seriesId,\n      nodeData: nodes,\n      labelData: nodes,\n      phantomNodeData: phantomNodes\n    };\n  }\n  getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {\n    const { calloutLabel, sectorLabel, legendItemKey } = this.properties;\n    const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.properties.calloutLabelKey : void 0;\n    const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.properties.sectorLabelKey : void 0;\n    if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {\n      return {};\n    }\n    const labelFormatterParams = {\n      datum,\n      angleKey: this.properties.angleKey,\n      angleName: this.properties.angleName,\n      radiusKey: this.properties.radiusKey,\n      radiusName: this.properties.radiusName,\n      calloutLabelKey: this.properties.calloutLabelKey,\n      calloutLabelName: this.properties.calloutLabelName,\n      sectorLabelKey: this.properties.sectorLabelKey,\n      sectorLabelName: this.properties.sectorLabelName,\n      legendItemKey: this.properties.legendItemKey\n    };\n    const result = {};\n    if (calloutLabelKey && span > toRadians(calloutLabel.minAngle)) {\n      result.calloutLabel = {\n        ...this.getTextAlignment(midAngle),\n        text: this.getLabelText(calloutLabel, {\n          ...labelFormatterParams,\n          value: calloutLabelValue\n        }),\n        hidden: false,\n        collisionTextAlign: void 0,\n        collisionOffsetY: 0,\n        box: void 0\n      };\n    }\n    if (sectorLabelKey) {\n      result.sectorLabel = {\n        text: this.getLabelText(sectorLabel, {\n          ...labelFormatterParams,\n          value: sectorLabelValue\n        })\n      };\n    }\n    if (legendItemKey != null && legendItemValue != null) {\n      result.legendItem = { key: legendItemKey, text: legendItemValue };\n    }\n    return result;\n  }\n  getTextAlignment(midAngle) {\n    const quadrantTextOpts = [\n      { textAlign: \"center\", textBaseline: \"bottom\" },\n      { textAlign: \"left\", textBaseline: \"middle\" },\n      { textAlign: \"center\", textBaseline: \"hanging\" },\n      { textAlign: \"right\", textBaseline: \"middle\" }\n    ];\n    const midAngle180 = normalizeAngle180(midAngle);\n    const quadrantStart = -0.75 * Math.PI;\n    const quadrantOffset = midAngle180 - quadrantStart;\n    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));\n    const quadrantIndex = mod(quadrant, quadrantTextOpts.length);\n    return quadrantTextOpts[quadrantIndex];\n  }\n  getSectorFormat(datum, formatIndex, highlighted) {\n    const { callbackCache } = this.ctx;\n    const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey, fills, strokes, itemStyler } = this.properties;\n    const defaultStroke = strokes[formatIndex % strokes.length];\n    const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity, lineDash, lineDashOffset, cornerRadius } = mergeDefaults(\n      highlighted && this.properties.highlightStyle.item,\n      {\n        fill: fills.length > 0 ? fills[formatIndex % fills.length] : void 0,\n        stroke: defaultStroke,\n        strokeWidth: this.getStrokeWidth(this.properties.strokeWidth),\n        strokeOpacity: this.getOpacity()\n      },\n      this.properties\n    );\n    let format;\n    if (itemStyler) {\n      format = callbackCache.call(itemStyler, {\n        datum,\n        angleKey,\n        radiusKey,\n        calloutLabelKey,\n        sectorLabelKey,\n        legendItemKey,\n        fill,\n        strokeOpacity,\n        stroke,\n        strokeWidth,\n        fillOpacity,\n        lineDash,\n        lineDashOffset,\n        cornerRadius,\n        highlighted,\n        seriesId: this.id\n      });\n    }\n    return {\n      fill: format?.fill ?? fill,\n      fillOpacity: format?.fillOpacity ?? fillOpacity,\n      stroke: format?.stroke ?? stroke,\n      strokeWidth: format?.strokeWidth ?? strokeWidth,\n      strokeOpacity: format?.strokeOpacity ?? strokeOpacity,\n      lineDash: format?.lineDash ?? lineDash,\n      lineDashOffset: format?.lineDashOffset ?? lineDashOffset,\n      cornerRadius: format?.cornerRadius ?? cornerRadius\n    };\n  }\n  getOuterRadius() {\n    return Math.max(this.radius * this.properties.outerRadiusRatio + this.properties.outerRadiusOffset, 0);\n  }\n  updateRadiusScale(resize) {\n    const newRange = [0, this.getOuterRadius()];\n    this.radiusScale.range = newRange;\n    if (resize) {\n      this.previousRadiusScale.range = newRange;\n    }\n    const setRadii = (d) => ({\n      ...d,\n      innerRadius: Math.max(this.radiusScale.convert(0), 0),\n      outerRadius: Math.max(this.radiusScale.convert(d.radius), 0)\n    });\n    this.nodeData = this.nodeData.map(setRadii);\n    this.phantomNodeData = this.phantomNodeData?.map(setRadii);\n  }\n  getTitleTranslationY() {\n    const outerRadius = Math.max(0, this.radiusScale.range[1]);\n    if (outerRadius === 0) {\n      return NaN;\n    }\n    const spacing = this.properties.title?.spacing ?? 0;\n    const titleOffset = 2 + spacing;\n    const dy = Math.max(0, -outerRadius);\n    return -outerRadius - titleOffset - dy;\n  }\n  async update({ seriesRect }) {\n    const { title } = this.properties;\n    const newNodeDataDependencies = {\n      seriesRectWidth: seriesRect?.width,\n      seriesRectHeight: seriesRect?.height\n    };\n    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n    if (resize) {\n      this._nodeDataDependencies = newNodeDataDependencies;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateTitleNodes();\n    this.updateRadiusScale(resize);\n    this.contentGroup.translationX = this.centerX;\n    this.contentGroup.translationY = this.centerY;\n    this.highlightGroup.translationX = this.centerX;\n    this.highlightGroup.translationY = this.centerY;\n    this.backgroundGroup.translationX = this.centerX;\n    this.backgroundGroup.translationY = this.centerY;\n    if (this.labelGroup) {\n      this.labelGroup.translationX = this.centerX;\n      this.labelGroup.translationY = this.centerY;\n    }\n    if (title) {\n      const dy = this.getTitleTranslationY();\n      const titleBox = title.node.getBBox();\n      title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox, 0, dy);\n      title.node.translationY = isFinite(dy) ? dy : 0;\n    }\n    this.zerosumOuterRing.fillOpacity = 0;\n    this.zerosumOuterRing.stroke = this.properties.calloutLabel.color;\n    this.zerosumOuterRing.strokeWidth = 1;\n    this.zerosumOuterRing.strokeOpacity = 1;\n    this.updateNodeMidPoint();\n    await this.updateSelections();\n    await this.updateNodes(seriesRect);\n  }\n  updateTitleNodes() {\n    const { oldTitle } = this;\n    const { title } = this.properties;\n    if (oldTitle !== title) {\n      if (oldTitle) {\n        this.labelGroup?.removeChild(oldTitle.node);\n      }\n      if (title) {\n        title.node.textBaseline = \"bottom\";\n        this.labelGroup?.appendChild(title.node);\n      }\n      this.oldTitle = title;\n    }\n  }\n  updateNodeMidPoint() {\n    const setMidPoint = (d) => {\n      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;\n      d.midPoint = {\n        x: d.midCos * Math.max(0, radius),\n        y: d.midSin * Math.max(0, radius)\n      };\n    };\n    this.nodeData.forEach(setMidPoint);\n    this.phantomNodeData?.forEach(setMidPoint);\n  }\n  async updateSelections() {\n    await this.updateGroupSelection();\n  }\n  async updateGroupSelection() {\n    const {\n      itemSelection,\n      highlightSelection,\n      phantomSelection,\n      highlightLabelSelection,\n      calloutLabelSelection,\n      labelSelection\n    } = this;\n    const highlightedNodeData = this.nodeData.map((datum) => ({\n      ...datum,\n      // Allow mutable sectorFormat, so formatted sector styles can be updated and varied\n      // between normal and highlighted cases.\n      sectorFormat: { ...datum.sectorFormat }\n    }));\n    const update = (selection, nodeData) => {\n      selection.update(nodeData, void 0, (datum) => this.getDatumId(datum));\n      if (this.ctx.animationManager.isSkipped()) {\n        selection.cleanup();\n      }\n    };\n    update(itemSelection, this.nodeData);\n    update(highlightSelection, highlightedNodeData);\n    update(phantomSelection, this.phantomNodeData ?? []);\n    calloutLabelSelection.update(this.calloutNodeData, (group) => {\n      const line = new Line();\n      line.tag = 0 /* Callout */;\n      line.pointerEvents = 1 /* None */;\n      group.appendChild(line);\n      const text = new Text();\n      text.tag = 1 /* Label */;\n      text.pointerEvents = 1 /* None */;\n      group.appendChild(text);\n    });\n    labelSelection.update(this.nodeData);\n    highlightLabelSelection.update(highlightedNodeData);\n  }\n  async updateNodes(seriesRect) {\n    const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();\n    const isVisible = this.visible && this.seriesItemEnabled.indexOf(true) >= 0;\n    this.rootGroup.visible = isVisible;\n    this.backgroundGroup.visible = isVisible;\n    this.contentGroup.visible = isVisible;\n    this.highlightGroup.visible = isVisible && highlightedDatum?.series === this;\n    this.highlightLabel.visible = isVisible && highlightedDatum?.series === this;\n    if (this.labelGroup) {\n      this.labelGroup.visible = isVisible;\n    }\n    this.contentGroup.opacity = this.getOpacity();\n    const animationDisabled = this.ctx.animationManager.isSkipped();\n    const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {\n      const format = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);\n      datum.sectorFormat.fill = format.fill;\n      datum.sectorFormat.stroke = format.stroke;\n      if (animationDisabled) {\n        sector.startAngle = datum.startAngle;\n        sector.endAngle = datum.endAngle;\n        sector.innerRadius = datum.innerRadius;\n        sector.outerRadius = datum.outerRadius;\n      }\n      if (isDatumHighlighted || animationDisabled) {\n        sector.fill = format.fill;\n        sector.stroke = format.stroke;\n      }\n      sector.strokeWidth = format.strokeWidth;\n      sector.fillOpacity = format.fillOpacity;\n      sector.strokeOpacity = format.strokeOpacity;\n      sector.lineDash = format.lineDash;\n      sector.lineDashOffset = format.lineDashOffset;\n      sector.cornerRadius = format.cornerRadius;\n      sector.fillShadow = this.properties.shadow;\n      const inset = Math.max(\n        (this.properties.sectorSpacing + (format.stroke != null ? format.strokeWidth : 0)) / 2,\n        0\n      );\n      sector.inset = inset;\n      sector.lineJoin = this.properties.sectorSpacing >= 0 || inset > 0 ? \"miter\" : \"round\";\n    };\n    this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.highlightSelection.each((node, datum, index) => {\n      updateSectorFn(node, datum, index, true);\n      if (datum.itemId === highlightedDatum?.itemId) {\n        node.visible = true;\n        updateSectorFn(node, datum, index, true);\n      } else {\n        node.visible = false;\n      }\n    });\n    this.phantomSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n    this.updateCalloutLineNodes();\n    this.updateCalloutLabelNodes(seriesRect);\n    this.updateSectorLabelNodes();\n    this.updateZerosumRings();\n    this.animationState.transition(\"update\");\n  }\n  updateCalloutLineNodes() {\n    const { calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const calloutStrokeWidth = calloutLine.strokeWidth;\n    const calloutColors = calloutLine.colors ?? this.properties.strokes;\n    const { offset: offset4 } = this.properties.calloutLabel;\n    this.calloutLabelSelection.selectByTag(0 /* Callout */).forEach((line, index) => {\n      const datum = line.datum;\n      const { calloutLabel: label, outerRadius } = datum;\n      if (label?.text && !label.hidden && outerRadius !== 0) {\n        line.visible = true;\n        line.strokeWidth = calloutStrokeWidth;\n        line.stroke = calloutColors[index % calloutColors.length];\n        line.fill = void 0;\n        const x1 = datum.midCos * outerRadius;\n        const y1 = datum.midSin * outerRadius;\n        let x2 = datum.midCos * (outerRadius + calloutLength);\n        let y2 = datum.midSin * (outerRadius + calloutLength);\n        const isMoved = label.collisionTextAlign ?? label.collisionOffsetY !== 0;\n        if (isMoved && label.box != null) {\n          const box = label.box;\n          let cx = x2;\n          let cy = y2;\n          if (x2 < box.x) {\n            cx = box.x;\n          } else if (x2 > box.x + box.width) {\n            cx = box.x + box.width;\n          }\n          if (y2 < box.y) {\n            cy = box.y;\n          } else if (y2 > box.y + box.height) {\n            cy = box.y + box.height;\n          }\n          const dx = cx - x2;\n          const dy = cy - y2;\n          const length2 = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n          const paddedLength = length2 - offset4;\n          if (paddedLength > 0) {\n            x2 = x2 + dx * paddedLength / length2;\n            y2 = y2 + dy * paddedLength / length2;\n          }\n        }\n        line.x1 = x1;\n        line.y1 = y1;\n        line.x2 = x2;\n        line.y2 = y2;\n      } else {\n        line.visible = false;\n      }\n    });\n  }\n  getLabelOverflow(text, box, seriesRect) {\n    const seriesLeft = seriesRect.x - this.centerX;\n    const seriesRight = seriesRect.x + seriesRect.width - this.centerX;\n    const seriesTop = seriesRect.y - this.centerY;\n    const seriesBottom = seriesRect.y + seriesRect.height - this.centerY;\n    const errPx = 1;\n    let visibleTextPart = 1;\n    if (box.x + errPx < seriesLeft) {\n      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;\n    } else if (box.x + box.width - errPx > seriesRight) {\n      visibleTextPart = (seriesRight - box.x) / box.width;\n    }\n    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;\n    const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;\n    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);\n    return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };\n  }\n  bboxIntersectsSurroundingSeries(box, dx = 0, dy = 0) {\n    const { surroundingRadius } = this;\n    if (surroundingRadius == null) {\n      return false;\n    }\n    const corners = [\n      { x: box.x + dx, y: box.y + dy },\n      { x: box.x + box.width + dx, y: box.y + dy },\n      { x: box.x + box.width + dx, y: box.y + box.height + dy },\n      { x: box.x + dx, y: box.y + box.height + dy }\n    ];\n    const sur2 = surroundingRadius ** 2;\n    return corners.some((corner) => corner.x ** 2 + corner.y ** 2 > sur2);\n  }\n  computeCalloutLabelCollisionOffsets() {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const { offset: offset4, minSpacing } = calloutLabel;\n    const innerRadius = radiusScale.convert(0);\n    const shouldSkip = (datum) => {\n      const label = datum.calloutLabel;\n      return !label || datum.outerRadius === 0;\n    };\n    const fullData = this.calloutNodeData;\n    const data = fullData.filter((t) => !shouldSkip(t));\n    data.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return;\n      label.hidden = false;\n      label.collisionTextAlign = void 0;\n      label.collisionOffsetY = 0;\n    });\n    if (data.length <= 1) {\n      return;\n    }\n    const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);\n    const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);\n    const topLabels = data.filter((d) => d.midSin < 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const bottomLabels = data.filter((d) => d.midSin >= 0 && d.calloutLabel?.textAlign === \"center\").sort((a, b) => a.midCos - b.midCos);\n    const getTextBBox = (datum) => {\n      const label = datum.calloutLabel;\n      if (label == null)\n        return BBox.zero.clone();\n      const labelRadius = datum.outerRadius + calloutLine.length + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const textAlign = label.collisionTextAlign ?? label.textAlign;\n      const textBaseline = label.textBaseline;\n      return Text.computeBBox(label.text, x, y, {\n        font: this.properties.calloutLabel,\n        textAlign,\n        textBaseline\n      });\n    };\n    const avoidNeighbourYCollision = (label, next, direction) => {\n      const box = getTextBBox(label).grow(minSpacing / 2);\n      const other = getTextBBox(next).grow(minSpacing / 2);\n      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === \"to-top\" ? box.y < other.y + other.height : box.y + box.height > other.y);\n      if (collidesOrBehind) {\n        const dy = direction === \"to-top\" ? box.y - other.y - other.height : box.y + box.height - other.y;\n        next.calloutLabel.collisionOffsetY = dy;\n      }\n    };\n    const avoidYCollisions = (labels) => {\n      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];\n      const midIndex = labels.indexOf(midLabel);\n      for (let i = midIndex - 1; i >= 0; i--) {\n        const prev = labels[i + 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-top\");\n      }\n      for (let i = midIndex + 1; i < labels.length; i++) {\n        const prev = labels[i - 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, \"to-bottom\");\n      }\n    };\n    const avoidXCollisions = (labels) => {\n      const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);\n      const boxes = labels.map((label) => getTextBBox(label));\n      const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));\n      let labelsCollideLabelsByX = false;\n      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {\n        const box = paddedBoxes[i];\n        for (let j = i + 1; j < labels.length; j++) {\n          const other = paddedBoxes[j];\n          if (box.collidesBBox(other)) {\n            labelsCollideLabelsByX = true;\n            break;\n          }\n        }\n      }\n      const sectors = fullData.map((datum) => {\n        const { startAngle, endAngle, outerRadius } = datum;\n        return { startAngle, endAngle, innerRadius, outerRadius };\n      });\n      const labelsCollideSectors = boxes.some((box) => {\n        return sectors.some((sector) => boxCollidesSector(box, sector));\n      });\n      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {\n        return;\n      }\n      labels.filter((d) => d.calloutLabel.textAlign === \"center\").forEach((d) => {\n        const label = d.calloutLabel;\n        if (d.midCos < 0) {\n          label.collisionTextAlign = \"right\";\n        } else if (d.midCos > 0) {\n          label.collisionTextAlign = \"left\";\n        } else {\n          label.collisionTextAlign = \"center\";\n        }\n      });\n    };\n    avoidYCollisions(leftLabels);\n    avoidYCollisions(rightLabels);\n    avoidXCollisions(topLabels);\n    avoidXCollisions(bottomLabels);\n  }\n  updateCalloutLabelNodes(seriesRect) {\n    const { radiusScale } = this;\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, color } = calloutLabel;\n    const tempTextNode = new Text();\n    this.calloutLabelSelection.selectByTag(1 /* Label */).forEach((text) => {\n      const { datum } = text;\n      const label = datum.calloutLabel;\n      const radius = radiusScale.convert(datum.radius);\n      const outerRadius = Math.max(0, radius);\n      if (!label?.text || outerRadius === 0 || label.hidden) {\n        text.visible = false;\n        return;\n      }\n      const labelRadius = outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      const align = {\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      };\n      tempTextNode.text = label.text;\n      tempTextNode.x = x;\n      tempTextNode.y = y;\n      tempTextNode.setFont(this.properties.calloutLabel);\n      tempTextNode.setAlign(align);\n      const box = tempTextNode.getBBox();\n      let displayText = label.text;\n      let visible = true;\n      if (calloutLabel.avoidCollisions) {\n        const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);\n        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}\\u2026`;\n        visible = !hasVerticalOverflow;\n      }\n      text.text = displayText;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign(align);\n      text.fill = color;\n      text.visible = visible;\n    });\n  }\n  async computeLabelsBBox(options, seriesRect) {\n    const { calloutLabel, calloutLine } = this.properties;\n    const calloutLength = calloutLine.length;\n    const { offset: offset4, maxCollisionOffset, minSpacing } = calloutLabel;\n    if (!calloutLabel.avoidCollisions) {\n      return null;\n    }\n    await this.maybeRefreshNodeData();\n    this.updateRadiusScale(false);\n    this.computeCalloutLabelCollisionOffsets();\n    const textBoxes = [];\n    const text = new Text();\n    let titleBox;\n    const { title } = this.properties;\n    if (title?.text && title.enabled) {\n      const dy = this.getTitleTranslationY();\n      if (isFinite(dy)) {\n        text.text = title.text;\n        text.x = 0;\n        text.y = dy;\n        text.setFont(title);\n        text.setAlign({\n          textBaseline: \"bottom\",\n          textAlign: \"center\"\n        });\n        titleBox = text.getBBox();\n        textBoxes.push(titleBox);\n      }\n    }\n    this.calloutNodeData.forEach((datum) => {\n      const label = datum.calloutLabel;\n      if (!label || datum.outerRadius === 0) {\n        return null;\n      }\n      const labelRadius = datum.outerRadius + calloutLength + offset4;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      text.text = label.text;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.properties.calloutLabel);\n      text.setAlign({\n        textAlign: label.collisionTextAlign ?? label.textAlign,\n        textBaseline: label.textBaseline\n      });\n      const box = text.getBBox();\n      label.box = box;\n      if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {\n        label.hidden = true;\n        return;\n      }\n      if (titleBox) {\n        const seriesTop = seriesRect.y - this.centerY;\n        const titleCleanArea = new BBox(\n          titleBox.x - minSpacing,\n          seriesTop,\n          titleBox.width + 2 * minSpacing,\n          titleBox.y + titleBox.height + minSpacing - seriesTop\n        );\n        if (box.collidesBBox(titleCleanArea)) {\n          label.hidden = true;\n          return;\n        }\n      }\n      if (options.hideWhenNecessary) {\n        const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(\n          label.text,\n          box,\n          seriesRect\n        );\n        const isTooShort = label.text.length > 2 && textLength < 2;\n        if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {\n          label.hidden = true;\n          return;\n        }\n      }\n      label.hidden = false;\n      textBoxes.push(box);\n    });\n    if (textBoxes.length === 0) {\n      return null;\n    }\n    return BBox.merge(textBoxes);\n  }\n  updateSectorLabelNodes() {\n    const { radiusScale } = this;\n    const innerRadius = radiusScale.convert(0);\n    const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color } = this.properties.sectorLabel;\n    const isDonut = innerRadius > 0;\n    const singleVisibleSector = this.seriesItemEnabled.filter(Boolean).length === 1;\n    const updateSectorLabel = (text, datum) => {\n      const { sectorLabel, outerRadius, startAngle, endAngle } = datum;\n      let isTextVisible = false;\n      if (sectorLabel && outerRadius !== 0) {\n        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;\n        text.fill = color;\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.text = sectorLabel.text;\n        const shouldPutTextInCenter = !isDonut && singleVisibleSector;\n        if (shouldPutTextInCenter) {\n          text.x = 0;\n          text.y = 0;\n        } else {\n          text.x = datum.midCos * labelRadius;\n          text.y = datum.midSin * labelRadius;\n        }\n        text.textAlign = \"center\";\n        text.textBaseline = \"middle\";\n        const bbox = text.getBBox();\n        const corners = [\n          [bbox.x, bbox.y],\n          [bbox.x + bbox.width, bbox.y],\n          [bbox.x + bbox.width, bbox.y + bbox.height],\n          [bbox.x, bbox.y + bbox.height]\n        ];\n        const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };\n        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {\n          isTextVisible = true;\n        }\n      }\n      text.visible = isTextVisible;\n    };\n    this.labelSelection.each(updateSectorLabel);\n    this.highlightLabelSelection.each(updateSectorLabel);\n  }\n  updateZerosumRings() {\n    this.zerosumOuterRing.size = this.getOuterRadius() * 2;\n  }\n  getDatumLegendName(nodeDatum) {\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    const { sectorLabel, calloutLabel, legendItem } = nodeDatum;\n    if (legendItemKey && legendItem !== void 0) {\n      return legendItem.text;\n    } else if (calloutLabelKey && calloutLabelKey !== angleKey && calloutLabel?.text !== void 0) {\n      return calloutLabel.text;\n    } else if (sectorLabelKey && sectorLabelKey !== angleKey && sectorLabel?.text !== void 0) {\n      return sectorLabel.text;\n    }\n  }\n  pickNodeClosestDatum(point) {\n    return pickByMatchingAngle(this, point);\n  }\n  getTooltipHtml(nodeDatum) {\n    if (!this.properties.isValid()) {\n      return EMPTY_TOOLTIP_CONTENT;\n    }\n    const {\n      datum,\n      angleValue,\n      sectorFormat: { fill: color },\n      itemId\n    } = nodeDatum;\n    const title = sanitizeHtml(this.properties.title?.text);\n    const content = isFiniteNumber(angleValue) ? toFixed(angleValue) : String(angleValue);\n    const labelText = this.getDatumLegendName(nodeDatum);\n    return this.properties.tooltip.toTooltipHtml(\n      {\n        title: title ?? labelText,\n        content: title && labelText ? `${labelText}: ${content}` : content,\n        backgroundColor: color\n      },\n      {\n        datum,\n        itemId,\n        title,\n        color,\n        seriesId: this.id,\n        angleKey: this.properties.angleKey,\n        angleName: this.properties.angleName,\n        radiusKey: this.properties.radiusKey,\n        radiusName: this.properties.radiusName,\n        calloutLabelKey: this.properties.calloutLabelKey,\n        calloutLabelName: this.properties.calloutLabelName,\n        sectorLabelKey: this.properties.sectorLabelKey,\n        sectorLabelName: this.properties.sectorLabelName,\n        legendItemKey: this.properties.legendItemKey\n      }\n    );\n  }\n  getLegendData(legendType) {\n    const { visible, processedData, dataModel } = this;\n    if (!dataModel || !processedData?.data.length || legendType !== \"category\") {\n      return [];\n    }\n    const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey)) {\n      return [];\n    }\n    const { calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);\n    const titleText = this.properties.title?.showInLegend && this.properties.title.text;\n    const legendData = [];\n    for (let index = 0; index < processedData.data.length; index++) {\n      const { datum, values } = processedData.data[index];\n      const labelParts = [];\n      if (titleText) {\n        labelParts.push(titleText);\n      }\n      const labels = this.getLabels(\n        datum,\n        2 * Math.PI,\n        2 * Math.PI,\n        false,\n        calloutLabelIdx != null ? values[calloutLabelIdx] : void 0,\n        sectorLabelIdx != null ? values[sectorLabelIdx] : void 0,\n        legendItemIdx != null ? values[legendItemIdx] : void 0\n      );\n      if (legendItemKey && labels.legendItem !== void 0) {\n        labelParts.push(labels.legendItem.text);\n      } else if (calloutLabelKey && calloutLabelKey !== angleKey && labels.calloutLabel?.text !== void 0) {\n        labelParts.push(labels.calloutLabel?.text);\n      } else if (sectorLabelKey && sectorLabelKey !== angleKey && labels.sectorLabel?.text !== void 0) {\n        labelParts.push(labels.sectorLabel?.text);\n      }\n      if (labelParts.length === 0)\n        continue;\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      legendData.push({\n        legendType: \"category\",\n        id: this.id,\n        itemId: index,\n        seriesId: this.id,\n        enabled: visible && this.seriesItemEnabled[index],\n        label: {\n          text: labelParts.join(\" - \")\n        },\n        symbols: [\n          {\n            marker: {\n              fill: sectorFormat.fill,\n              stroke: sectorFormat.stroke,\n              fillOpacity: this.properties.fillOpacity,\n              strokeOpacity: this.properties.strokeOpacity,\n              strokeWidth: this.properties.strokeWidth\n            }\n          }\n        ],\n        legendItemName: legendItemKey != null ? datum[legendItemKey] : void 0\n      });\n    }\n    return legendData;\n  }\n  onLegendItemClick(event) {\n    const { enabled, itemId, series, legendItemName } = event;\n    if (series.id === this.id) {\n      this.toggleSeriesItem(itemId, enabled);\n    } else if (legendItemName != null) {\n      this.toggleOtherSeriesItems(legendItemName, enabled);\n    }\n  }\n  toggleSeriesItem(itemId, enabled) {\n    this.seriesItemEnabled[itemId] = enabled;\n    if (this.nodeData[itemId]) {\n      this.nodeData[itemId].enabled = enabled;\n    }\n    this.nodeDataRefresh = true;\n  }\n  toggleOtherSeriesItems(legendItemName, enabled) {\n    if (!this.properties.legendItemKey || !this.dataModel) {\n      return;\n    }\n    const legendItemIdx = this.dataModel.resolveProcessedDataIndexById(this, `legendItemValue`);\n    this.processedData?.data.forEach(({ values }, datumItemId) => {\n      if (values[legendItemIdx] === legendItemName) {\n        this.toggleSeriesItem(datumItemId, enabled);\n      }\n    });\n  }\n  animateEmptyUpdateReady(_data) {\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      true,\n      this.properties.rotation,\n      this.radiusScale,\n      this.previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [this.itemSelection, this.highlightSelection, this.phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum)\n    );\n    seriesLabelFadeInAnimation(this, \"callout\", animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", animationManager, this.highlightLabelSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateWaitingUpdateReady() {\n    const { itemSelection, highlightSelection, phantomSelection, processedData, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const dataDiff = processedData?.reduced?.diff;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const supportedDiff = (dataDiff?.moved.size ?? 0) === 0;\n    const hasKeys = (processedData?.defs.keys.length ?? 0) > 0;\n    const hasUniqueKeys = processedData?.reduced?.animationValidation?.uniqueKeys ?? true;\n    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum),\n      dataDiff\n    );\n    seriesLabelFadeInAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeInAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeInAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateClearingUpdateEmpty() {\n    const { itemSelection, highlightSelection, phantomSelection, radiusScale, previousRadiusScale } = this;\n    const { animationManager } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(\n      false,\n      this.properties.rotation,\n      radiusScale,\n      previousRadiusScale\n    );\n    fromToMotion(\n      this.id,\n      \"nodes\",\n      animationManager,\n      [itemSelection, highlightSelection, phantomSelection],\n      fns.nodes,\n      (_, datum) => this.getDatumId(datum)\n    );\n    seriesLabelFadeOutAnimation(this, \"callout\", this.ctx.animationManager, this.calloutLabelSelection);\n    seriesLabelFadeOutAnimation(this, \"sector\", this.ctx.animationManager, this.labelSelection);\n    seriesLabelFadeOutAnimation(this, \"highlight\", this.ctx.animationManager, this.highlightLabelSelection);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  getDatumIdFromData(datum) {\n    const { calloutLabelKey, sectorLabelKey, legendItemKey } = this.properties;\n    if (!this.processedData?.reduced?.animationValidation?.uniqueKeys) {\n      return;\n    }\n    if (legendItemKey) {\n      return datum[legendItemKey];\n    } else if (calloutLabelKey) {\n      return datum[calloutLabelKey];\n    } else if (sectorLabelKey) {\n      return datum[sectorLabelKey];\n    }\n  }\n  getDatumId(datum) {\n    const { index } = datum;\n    const datumId = this.getDatumIdFromData(datum.datum);\n    return datumId != null ? String(datumId) : `${index}`;\n  }\n  onDataChange() {\n    const { data, seriesItemEnabled } = this;\n    this.seriesItemEnabled = data?.map((_, index) => seriesItemEnabled[index] ?? true) ?? [];\n  }\n};\nPieSeries.className = \"PieSeries\";\nPieSeries.type = \"pie\";\n\n// packages/ag-charts-community/src/chart/series/polar/pieSeriesModule.ts\nvar PieSeriesModule = {\n  type: \"series\",\n  optionsKey: \"series[]\",\n  packageType: \"community\",\n  chartTypes: [\"polar\"],\n  identifier: \"pie\",\n  moduleFactory: (ctx) => new PieSeries(ctx),\n  tooltipDefaults: { range: \"exact\" },\n  themeTemplate: pieTheme,\n  paletteFactory: piePaletteFactory\n};\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarProperties.ts\nvar ToolbarGroupProperties = class extends BaseProperties {\n  constructor(onChange, onButtonsChange) {\n    super();\n    this.onChange = onChange;\n    this.onButtonsChange = onButtonsChange;\n    this.align = \"start\";\n    this.position = \"top\" /* Top */;\n    this.size = \"normal\";\n    this.buttonOverrides = /* @__PURE__ */ new Map();\n  }\n  buttonConfigurations() {\n    return this.buttons?.map((button) => {\n      const id = button.id ?? button.value;\n      const overrides = this.buttonOverrides.get(id);\n      return overrides != null ? { ...button, ...overrides } : button;\n    }) ?? [];\n  }\n  buttonsChanged(configurationOnly) {\n    this.onButtonsChange(this.buttonConfigurations(), configurationOnly);\n  }\n  overrideButtonConfiguration(id, options) {\n    let overrides = this.buttonOverrides.get(id);\n    if (overrides == null) {\n      overrides = /* @__PURE__ */ Object.create(null);\n      this.buttonOverrides.set(id, overrides);\n    }\n    for (const key in options) {\n      const value = options[key];\n      if (value == null) {\n        delete overrides[key];\n      } else {\n        overrides[key] = value;\n      }\n    }\n    this.buttonsChanged(true);\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(BOOLEAN)\n], ToolbarGroupProperties.prototype, \"enabled\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(UNION([...TOOLBAR_ALIGNMENTS]), { optional: true })\n], ToolbarGroupProperties.prototype, \"align\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(UNION(TOOLBAR_POSITIONS), { optional: true })\n], ToolbarGroupProperties.prototype, \"position\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    target.onChange(target.enabled);\n  }),\n  Validate(UNION([\"small\", \"normal\"]), { optional: true })\n], ToolbarGroupProperties.prototype, \"size\", 2);\n__decorateClass([\n  ObserveChanges((target) => {\n    for (const button of target.buttons ?? []) {\n      if (button.icon != null && ICONS_LEGACY.includes(button.icon)) {\n        Logger.warnOnce(`Icon '${button.icon}' is deprecated, use another icon instead.`);\n      }\n      if (button.ariaLabel === \"toolbarAnnotationsColor\") {\n        Logger.warnOnce(\n          `Aria label '${button.ariaLabel}' is deprecated, use 'toolbarAnnotationsLineColor' instead.`\n        );\n      }\n    }\n    target.buttonsChanged(false);\n  }),\n  Validate(ARRAY, { optional: true })\n], ToolbarGroupProperties.prototype, \"buttons\", 2);\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarStyles.ts\nvar block2 = \"ag-charts-toolbar\";\nvar elements2 = {\n  align: \"ag-charts-toolbar__align\",\n  section: \"ag-charts-toolbar__section\",\n  button: \"ag-charts-toolbar__button\",\n  icon: \"ag-charts-toolbar__icon\",\n  label: \"ag-charts-toolbar__label\"\n};\nvar modifiers2 = {\n  [\"top\" /* Top */]: \"ag-charts-toolbar--top\",\n  [\"right\" /* Right */]: \"ag-charts-toolbar--right\",\n  [\"bottom\" /* Bottom */]: \"ag-charts-toolbar--bottom\",\n  [\"left\" /* Left */]: \"ag-charts-toolbar--left\",\n  [\"floating\" /* Floating */]: \"ag-charts-toolbar--floating\",\n  [\"floating-top\" /* FloatingTop */]: \"ag-charts-toolbar--floating-top\",\n  [\"floating-bottom\" /* FloatingBottom */]: \"ag-charts-toolbar--floating-bottom\",\n  small: \"ag-charts-toolbar--small\",\n  normal: \"ag-charts-toolbar--normal\",\n  hidden: \"ag-charts-toolbar--hidden\",\n  preventFlash: \"ag-charts-toolbar--prevent-flash\",\n  floatingHidden: \"ag-charts-toolbar--floating-hidden\",\n  align: {\n    start: \"ag-charts-toolbar__align--start\",\n    center: \"ag-charts-toolbar__align--center\",\n    end: \"ag-charts-toolbar__align--end\"\n  },\n  button: {\n    active: `ag-charts-toolbar__button--active`,\n    hiddenValue: `ag-charts-toolbar__button--hidden-value`,\n    hiddenToggled: `ag-charts-toolbar__button--hidden-toggled`,\n    fillVisible: `ag-charts-toolbar__button--fill-visible`\n  }\n};\n\n// packages/ag-charts-community/src/chart/toolbar/toolbar.ts\nvar Toolbar = class extends BaseModuleInstance {\n  constructor(ctx) {\n    super();\n    this.ctx = ctx;\n    this.enabled = true;\n    this.seriesType = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"seriesType\"),\n      this.onGroupButtonsChanged.bind(this, \"seriesType\")\n    );\n    this.annotations = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"annotations\"),\n      this.onGroupButtonsChanged.bind(this, \"annotations\")\n    );\n    this.annotationOptions = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"annotationOptions\"),\n      this.onGroupButtonsChanged.bind(this, \"annotationOptions\")\n    );\n    this.ranges = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"ranges\"),\n      this.onGroupButtonsChanged.bind(this, \"ranges\")\n    );\n    this.zoom = new ToolbarGroupProperties(\n      this.onGroupChanged.bind(this, \"zoom\"),\n      this.onGroupButtonsChanged.bind(this, \"zoom\")\n    );\n    this.horizontalSpacing = 10;\n    this.verticalSpacing = 10;\n    this.floatingDetectionRange = 38;\n    this.positions = {\n      [\"top\" /* Top */]: /* @__PURE__ */ new Set(),\n      [\"right\" /* Right */]: /* @__PURE__ */ new Set(),\n      [\"bottom\" /* Bottom */]: /* @__PURE__ */ new Set(),\n      [\"left\" /* Left */]: /* @__PURE__ */ new Set(),\n      [\"floating\" /* Floating */]: /* @__PURE__ */ new Set(),\n      [\"floating-top\" /* FloatingTop */]: /* @__PURE__ */ new Set(),\n      [\"floating-bottom\" /* FloatingBottom */]: /* @__PURE__ */ new Set()\n    };\n    this.positionAlignments = {\n      [\"top\" /* Top */]: {},\n      [\"right\" /* Right */]: {},\n      [\"bottom\" /* Bottom */]: {},\n      [\"left\" /* Left */]: {},\n      [\"floating\" /* Floating */]: {},\n      [\"floating-top\" /* FloatingTop */]: {},\n      [\"floating-bottom\" /* FloatingBottom */]: {}\n    };\n    this.groupCallers = {\n      seriesType: /* @__PURE__ */ new Set(),\n      annotations: /* @__PURE__ */ new Set(),\n      annotationOptions: /* @__PURE__ */ new Set(),\n      ranges: /* @__PURE__ */ new Set(),\n      zoom: /* @__PURE__ */ new Set()\n    };\n    this.groupButtons = {\n      seriesType: [],\n      annotations: [],\n      annotationOptions: [],\n      ranges: [],\n      zoom: []\n    };\n    this.ariaToolbars = [\n      { groups: [\"seriesType\", \"annotations\"], destroyFns: [] },\n      { groups: [\"annotationOptions\"], destroyFns: [] },\n      { groups: [\"ranges\"], destroyFns: [] },\n      { groups: [\"zoom\"], destroyFns: [] }\n    ];\n    this.pendingButtonToggledEvents = [];\n    this.groupProxied = /* @__PURE__ */ new Map();\n    this.hasNewLocale = true;\n    this.elements = {};\n    for (const position of TOOLBAR_POSITIONS) {\n      this.elements[position] = ctx.domManager.addChild(\"canvas-overlay\", `toolbar-${position}`);\n      this.elements[position].role = \"presentation\";\n      this.renderToolbar(position);\n    }\n    this.toggleVisibilities();\n    this.destroyFns.push(\n      ctx.interactionManager.addListener(\"hover\", this.onHover.bind(this), 31 /* All */),\n      ctx.interactionManager.addListener(\"leave\", this.onLeave.bind(this), 31 /* All */),\n      ctx.toolbarManager.addListener(\"button-toggled\", this.onButtonToggled.bind(this)),\n      ctx.toolbarManager.addListener(\"button-updated\", this.onButtonUpdated.bind(this)),\n      ctx.toolbarManager.addListener(\"group-toggled\", this.onGroupToggled.bind(this)),\n      ctx.toolbarManager.addListener(\"floating-anchor-changed\", this.onFloatingAnchorChanged.bind(this)),\n      ctx.toolbarManager.addListener(\"proxy-group-options\", this.onProxyGroupOptions.bind(this)),\n      ctx.layoutService.addListener(\"layout-complete\", this.onLayoutComplete.bind(this)),\n      ctx.localeManager.addListener(\"locale-changed\", () => {\n        this.hasNewLocale = true;\n      }),\n      () => this.destroyElements()\n    );\n  }\n  destroyElements() {\n    this.ctx.domManager.removeStyles(block2);\n    for (const element2 of Object.keys(this.elements)) {\n      this.ctx.domManager.removeChild(\"canvas-overlay\", `toolbar-${element2}`);\n    }\n  }\n  onHover(event) {\n    const {\n      enabled,\n      elements: elements3,\n      floatingDetectionRange,\n      ctx: { scene }\n    } = this;\n    const {\n      offsetY,\n      sourceEvent: { target }\n    } = event;\n    const { FloatingBottom, FloatingTop } = ToolbarPosition;\n    if (!enabled)\n      return;\n    const bottom = elements3[FloatingBottom];\n    const top = elements3[FloatingTop];\n    const bottomDetectionY = bottom.offsetTop - floatingDetectionRange;\n    const bottomVisible = offsetY > bottomDetectionY && offsetY < scene.canvas.element.offsetHeight || target === bottom;\n    const topDetectionY = top.offsetTop + top.offsetHeight + floatingDetectionRange;\n    const topVisible = offsetY > 0 && offsetY < topDetectionY || target === top;\n    this.translateFloatingElements(FloatingBottom, bottomVisible);\n    this.translateFloatingElements(FloatingTop, topVisible);\n  }\n  onLeave(event) {\n    const {\n      enabled,\n      ctx: { scene }\n    } = this;\n    const { relatedElement, targetElement } = event;\n    const { FloatingBottom, FloatingTop } = ToolbarPosition;\n    if (!enabled || targetElement !== scene.canvas.element)\n      return;\n    const isTargetButton = TOOLBAR_GROUPS.some(\n      (group) => this.groupButtons[group].some((button) => button === relatedElement)\n    );\n    if (isTargetButton)\n      return;\n    this.translateFloatingElements(FloatingBottom, false);\n    this.translateFloatingElements(FloatingTop, false);\n  }\n  onGroupChanged(group) {\n    if (this[group] == null || this.groupProxied.has(group))\n      return;\n    this.createGroup(group);\n    this.toggleVisibilities();\n  }\n  onGroupButtonsChanged(group, buttons, configurationOnly) {\n    if (!this.enabled || this.groupProxied.has(group))\n      return;\n    if (configurationOnly) {\n      for (const buttonOptions of this[group].buttonConfigurations()) {\n        this.refreshButtonContent(group, buttonOptions);\n      }\n    } else {\n      this.createGroupButtons(group, buttons);\n    }\n    this.toggleVisibilities();\n  }\n  onLayoutComplete() {\n    for (const position of TOOLBAR_POSITIONS) {\n      this.elements[position].classList.remove(modifiers2.preventFlash);\n    }\n  }\n  onButtonUpdated(event) {\n    const { type: _type, group, id, ...params } = event;\n    this[group].overrideButtonConfiguration(id, { ...params });\n  }\n  setButtonActive(button, active) {\n    button.classList.toggle(modifiers2.button.active, active);\n  }\n  onButtonToggled(event) {\n    const { group, id, active, enabled, visible } = event;\n    if (this.groupButtons[group].length === 0) {\n      this.pendingButtonToggledEvents.push(event);\n      return;\n    }\n    for (const button of this.groupButtons[group]) {\n      if (button.dataset.toolbarId !== `${id}`)\n        continue;\n      button.ariaDisabled = `${!enabled}`;\n      setVisibility(button, modifiers2.button.hiddenToggled, !visible);\n      this.setButtonActive(button, active);\n    }\n  }\n  onGroupToggled(event) {\n    const { caller, group, active, visible } = event;\n    this.toggleGroup(caller, group, active, visible);\n    this.toggleVisibilities();\n  }\n  onFloatingAnchorChanged(event) {\n    const {\n      elements: elements3,\n      groupButtons,\n      positions,\n      horizontalSpacing,\n      verticalSpacing,\n      ctx: { domManager, toolbarManager }\n    } = this;\n    const { group, anchor } = event;\n    if (!positions[\"floating\" /* Floating */].has(group))\n      return;\n    const element2 = elements3[\"floating\" /* Floating */];\n    if (element2.classList.contains(modifiers2.hidden))\n      return;\n    const position = anchor.position ?? \"above\";\n    const { offsetWidth: width, offsetHeight: height } = element2;\n    let top = anchor.y - height - verticalSpacing;\n    let left = anchor.x - width / 2;\n    if (position === \"right\") {\n      top = anchor.y - height / 2;\n      left = anchor.x + horizontalSpacing;\n    } else if (position === \"above-left\") {\n      left = anchor.x;\n    }\n    const canvasRect = domManager.getBoundingClientRect();\n    top = clamp(0, top, canvasRect.height - height);\n    left = clamp(0, left, canvasRect.width - width);\n    element2.style.top = `${top}px`;\n    element2.style.left = `${left}px`;\n    const groupBBox = new BBox(left, top, width, height);\n    for (const button of groupButtons[group]) {\n      if (button.classList.contains(modifiers2.button.hiddenToggled))\n        continue;\n      const parent = button.offsetParent;\n      toolbarManager.buttonMoved(\n        group,\n        button.dataset.toolbarId,\n        new BBox(\n          button.offsetLeft + (parent?.offsetLeft ?? 0),\n          button.offsetTop + (parent?.offsetTop ?? 0),\n          button.offsetWidth,\n          button.offsetHeight\n        ),\n        groupBBox\n      );\n    }\n  }\n  buttonRect(button, canvasRect = this.ctx.domManager.getBoundingClientRect()) {\n    const buttonRect = button.getBoundingClientRect();\n    return new BBox(\n      buttonRect.left - canvasRect.left,\n      buttonRect.top - canvasRect.top,\n      buttonRect.width,\n      buttonRect.height\n    );\n  }\n  onProxyGroupOptions(event) {\n    if (!this.enabled)\n      return;\n    const { caller, group, options } = event;\n    this.groupProxied.set(group, options);\n    this[group].set(options);\n    this.toggleGroup(caller, group, void 0, options.enabled);\n    this.createGroup(group, options.enabled, options.position);\n    if (options.enabled) {\n      this.createGroupButtons(group, options.buttons);\n    }\n  }\n  createGroup(group, enabled, position) {\n    enabled ?? (enabled = this[group].enabled);\n    position ?? (position = this[group].position);\n    for (const pos of TOOLBAR_POSITIONS) {\n      if (enabled && position === pos) {\n        this.positions[pos].add(group);\n      } else {\n        this.positions[pos].delete(group);\n      }\n    }\n  }\n  createGroupButtons(group, buttons = []) {\n    for (const button of this.groupButtons[group]) {\n      button.remove();\n    }\n    const ariaToolbar = this.getAriaToolbar(group);\n    this.groupButtons[group] = [];\n    ariaToolbar.destroyFns.forEach((d) => d());\n    ariaToolbar.destroyFns = [];\n    if (buttons.length === 0)\n      return;\n    const { align, position } = this[group];\n    const alignElement = this.positionAlignments[position][align];\n    if (!alignElement)\n      return;\n    const nextSection = (section2) => {\n      const alignElementChildren = Array.from(alignElement.children);\n      const dataGroup = \"data-group\";\n      const dataSection = \"data-section\";\n      let sectionElement = alignElementChildren.find((prevSection2) => {\n        return prevSection2.getAttribute(dataGroup) === group && prevSection2.getAttribute(dataSection) === (section2 ?? \"\");\n      });\n      if (!sectionElement) {\n        sectionElement = createElement(\"div\");\n        sectionElement.role = \"presentation\";\n        sectionElement.setAttribute(dataGroup, group);\n        sectionElement.setAttribute(dataSection, section2 ?? \"\");\n        const groupIndex = TOOLBAR_GROUP_ORDERING[group];\n        const insertBeforeElement = alignElementChildren.find((prevSection2) => {\n          const prevGroup = prevSection2.getAttribute(dataGroup);\n          const prevGroupIndex = TOOLBAR_GROUP_ORDERING[prevGroup];\n          return prevGroupIndex > groupIndex;\n        });\n        if (insertBeforeElement != null) {\n          alignElement.insertBefore(sectionElement, insertBeforeElement);\n        } else {\n          alignElement.appendChild(sectionElement);\n        }\n        this.destroyFns.push(() => sectionElement.remove());\n      }\n      sectionElement.classList.add(elements2.section, modifiers2[this[group].size]);\n      return sectionElement;\n    };\n    let prevSection = buttons.at(0)?.section;\n    let section = nextSection(prevSection);\n    for (const options of buttons) {\n      if (prevSection !== options.section) {\n        section = nextSection(options.section);\n      }\n      prevSection = options.section;\n      const button = this.createButtonElement(group, options);\n      section.appendChild(button);\n      this.groupButtons[group].push(button);\n    }\n    const onEscape = () => {\n      this.ctx.toolbarManager.cancel(group);\n    };\n    let onFocus;\n    let onBlur;\n    if (isAnimatingFloatingPosition(position)) {\n      onFocus = () => this.translateFloatingElements(position, true);\n      onBlur = () => this.translateFloatingElements(position, false);\n    }\n    const orientation = this.computeAriaOrientation(this[group].position);\n    const ariaToolbarButtons = ariaToolbar.groups.map((g) => this.groupButtons[g]).flat();\n    ariaToolbar.destroyFns = initToolbarKeyNav({\n      orientation,\n      toolbar: alignElement,\n      buttons: ariaToolbarButtons,\n      onEscape,\n      onFocus,\n      onBlur\n    });\n    this.updateToolbarAriaLabel(group, alignElement);\n  }\n  computeAriaOrientation(position) {\n    return {\n      top: \"horizontal\",\n      right: \"vertical\",\n      bottom: \"horizontal\",\n      left: \"vertical\",\n      floating: \"horizontal\",\n      \"floating-top\": \"horizontal\",\n      \"floating-bottom\": \"horizontal\"\n    }[position];\n  }\n  toggleGroup(caller, group, active, enabled) {\n    if (enabled === true) {\n      this.groupCallers[group].add(caller);\n    } else if (enabled === false) {\n      this.groupCallers[group].delete(caller);\n    }\n    if (active != null) {\n      for (const button of this.groupButtons[group]) {\n        this.setButtonActive(button, active);\n      }\n    }\n  }\n  processPendingEvents() {\n    const pendingButtonToggledEvents = (this.pendingButtonToggledEvents ?? []).slice();\n    for (const event of pendingButtonToggledEvents) {\n      this.onButtonToggled(event);\n    }\n    this.pendingButtonToggledEvents = [];\n  }\n  async performLayout(ctx) {\n    if (!this.enabled)\n      return ctx;\n    this.refreshOuterLayout(ctx.shrinkRect);\n    this.refreshLocale();\n    return ctx;\n  }\n  async performCartesianLayout(opts) {\n    if (!this.enabled)\n      return;\n    this.refreshInnerLayout(opts.seriesRect);\n  }\n  refreshOuterLayout(shrinkRect) {\n    const { elements: elements3, horizontalSpacing, verticalSpacing } = this;\n    if (!elements3.top.classList.contains(modifiers2.hidden)) {\n      shrinkRect.shrink(elements3.top.offsetHeight + verticalSpacing, \"top\");\n    }\n    if (!elements3.right.classList.contains(modifiers2.hidden)) {\n      shrinkRect.shrink(elements3.right.offsetWidth + horizontalSpacing, \"right\");\n    }\n    if (!elements3.bottom.classList.contains(modifiers2.hidden)) {\n      shrinkRect.shrink(elements3.bottom.offsetHeight + verticalSpacing, \"bottom\");\n      elements3.bottom.style.top = `${shrinkRect.y + shrinkRect.height + verticalSpacing}px`;\n    }\n    if (!elements3.left.classList.contains(modifiers2.hidden)) {\n      shrinkRect.shrink(elements3.left.offsetWidth + horizontalSpacing, \"left\");\n    }\n  }\n  refreshLocale() {\n    const { hasNewLocale } = this;\n    if (!hasNewLocale)\n      return;\n    for (const group of TOOLBAR_GROUPS) {\n      const buttons = this[group].buttonConfigurations();\n      for (const buttonOptions of buttons) {\n        this.refreshButtonContent(group, buttonOptions);\n      }\n      this.updateToolbarAriaLabel(group);\n    }\n    this.hasNewLocale = false;\n  }\n  refreshInnerLayout(rect) {\n    const { elements: elements3, verticalSpacing } = this;\n    const { FloatingBottom, FloatingTop } = ToolbarPosition;\n    elements3.top.style.top = `${rect.y - elements3.top.offsetHeight - verticalSpacing}px`;\n    elements3.top.style.left = `${rect.x}px`;\n    elements3.top.style.width = `${rect.width}px`;\n    elements3.bottom.style.left = `${rect.x}px`;\n    elements3.bottom.style.width = `${rect.width}px`;\n    elements3.right.style.top = `${rect.y}px`;\n    elements3.right.style.right = `0px`;\n    elements3.right.style.height = `${rect.height}px`;\n    elements3.left.style.top = `${rect.y}px`;\n    elements3.left.style.left = `0px`;\n    elements3.left.style.height = `${rect.height}px`;\n    elements3[FloatingTop].style.top = `${rect.y}px`;\n    elements3[FloatingBottom].style.top = `${rect.y + rect.height - elements3[FloatingBottom].offsetHeight}px`;\n  }\n  refreshButtonContent(group, buttonOptions) {\n    const id = this.buttonId(buttonOptions);\n    const button = this.groupProxied.get(group)?.buttons?.find((b) => this.buttonId(b) === id) ?? buttonOptions;\n    const element2 = this.groupButtons[group].find((b) => b.getAttribute(\"data-toolbar-id\") === id);\n    if (element2 == null)\n      return;\n    this.updateButton(element2, button);\n  }\n  toggleVisibilities() {\n    if (this.elements == null)\n      return;\n    const isGroupVisible = (group) => this[group].enabled && this.groupCallers[group].size > 0;\n    const isButtonVisible = (element2) => (button) => {\n      const id = this.buttonId(button);\n      return id == null || id === element2.dataset.toolbarId;\n    };\n    for (const position of TOOLBAR_POSITIONS) {\n      const visible = this.enabled && Array.from(this.positions[position].values()).some(isGroupVisible);\n      setVisibility(this.elements[position], modifiers2.hidden, !visible);\n    }\n    for (const group of TOOLBAR_GROUPS) {\n      if (this[group] == null)\n        continue;\n      const groupVisible = isGroupVisible(group);\n      for (const button of this.groupButtons[group]) {\n        const buttonVisible = groupVisible && this[group].buttonConfigurations().some(isButtonVisible(button));\n        setVisibility(button, modifiers2.button.hiddenValue, !buttonVisible);\n      }\n    }\n  }\n  translateFloatingElements(position, visible) {\n    const { elements: elements3, verticalSpacing: verticalMargin, positionAlignments } = this;\n    const element2 = elements3[position];\n    const alignments = Object.values(positionAlignments[position]);\n    setVisibility(element2, modifiers2.floatingHidden, !visible);\n    const dir = position === \"floating-bottom\" /* FloatingBottom */ ? 1 : -1;\n    for (const align of alignments) {\n      align.style.transform = visible && align.style.transform !== \"\" ? \"translateY(0)\" : `translateY(${(element2.offsetHeight + verticalMargin) * dir}px)`;\n    }\n  }\n  renderToolbar(position = \"top\" /* Top */) {\n    const element2 = this.elements[position];\n    element2.classList.add(block2, modifiers2[position], modifiers2.preventFlash);\n    if (isAnimatingFloatingPosition(position)) {\n      element2.classList.add(modifiers2.floatingHidden);\n    }\n    for (const align of TOOLBAR_ALIGNMENTS) {\n      const alignmentElement = createElement(\"div\");\n      alignmentElement.role = \"presentation\";\n      alignmentElement.classList.add(elements2.align, modifiers2.align[align]);\n      alignmentElement.dataset.pointerCapture = \"exclusive\";\n      element2.appendChild(alignmentElement);\n      this.positionAlignments[position][align] = alignmentElement;\n    }\n  }\n  createButtonElement(group, options) {\n    const button = createElement(\"button\");\n    button.classList.add(elements2.button);\n    button.dataset.toolbarGroup = group;\n    button.tabIndex = -1;\n    button.dataset.toolbarId = this.buttonId(options);\n    button.onclick = makeAccessibleClickListener(\n      button,\n      this.onButtonPress.bind(this, button, group, options.id, options.value)\n    );\n    this.updateButton(button, options);\n    this.destroyFns.push(() => button.remove());\n    return button;\n  }\n  getAriaToolbar(group) {\n    for (const ariaToolbar of this.ariaToolbars) {\n      if (ariaToolbar.groups.includes(group)) {\n        return ariaToolbar;\n      }\n    }\n    throw new Error(`AG Charts - cannot find aria-toolbar of '${group}'`);\n  }\n  updateToolbarAriaLabel(group, alignElement) {\n    if (!alignElement) {\n      const { align, position } = this[group];\n      alignElement = this.positionAlignments[position][align];\n      if (!alignElement)\n        return;\n    }\n    const map = {\n      seriesType: \"ariaLabelFinancialCharts\",\n      annotations: \"ariaLabelFinancialCharts\",\n      annotationOptions: \"ariaLabelAnnotationOptionsToolbar\",\n      ranges: \"ariaLabelRangesToolbar\",\n      zoom: \"ariaLabelZoomToolbar\"\n    };\n    alignElement.ariaLabel = this.ctx.localeManager.t(map[group]);\n  }\n  updateButton(button, options) {\n    const {\n      ctx: { domManager, localeManager }\n    } = this;\n    if (options.tooltip) {\n      const tooltip = localeManager.t(options.tooltip);\n      button.title = tooltip;\n    }\n    let inner = \"\";\n    if (options.icon != null) {\n      inner = `<span class=\"${domManager.getIconClassNames(options.icon)} ${elements2.icon}\"></span>`;\n    }\n    if (options.label != null) {\n      const label = localeManager.t(options.label);\n      inner = `${inner}<span class=\"${elements2.label}\">${label}</span>`;\n    }\n    button.innerHTML = inner;\n    button.classList.toggle(modifiers2.button.fillVisible, options.fill != null);\n    button.style.setProperty(\"--fill\", options.fill ?? null);\n    const ariaLabel = options.ariaLabel ? this.ctx.localeManager.t(options.ariaLabel) : void 0;\n    setAttribute(button, \"aria-label\", ariaLabel);\n  }\n  onButtonPress(button, group, id, value) {\n    this.ctx.toolbarManager.pressButton(group, this.buttonId({ id, value }), value, this.buttonRect(button));\n  }\n  buttonId(button) {\n    const { id, value, label } = button;\n    if (id != null)\n      return id;\n    if (value != null && typeof value !== \"object\")\n      return String(value);\n    return label ?? \"\";\n  }\n};\n__decorateClass([\n  ObserveChanges((target) => {\n    target.processPendingEvents();\n    target.toggleVisibilities();\n  }),\n  Validate(BOOLEAN)\n], Toolbar.prototype, \"enabled\", 2);\n\n// packages/ag-charts-community/src/chart/toolbar/toolbarModule.ts\nvar DAY = 1e3 * 60 * 60 * 24;\nvar MONTH = DAY * 30;\nvar YEAR = DAY * 365;\nvar seriesType = {\n  enabled: false,\n  position: \"left\",\n  align: \"start\",\n  buttons: [\n    {\n      tooltip: \"toolbarSeriesTypeDropdown\",\n      value: \"type\"\n    }\n  ]\n};\nvar annotations = {\n  enabled: true,\n  position: \"left\",\n  align: \"start\",\n  buttons: [\n    {\n      icon: \"trend-line-drawing\",\n      tooltip: \"toolbarAnnotationsLineAnnotations\",\n      value: \"line-menu\",\n      section: \"line-annotations\"\n    },\n    {\n      icon: \"text-annotation\",\n      tooltip: \"toolbarAnnotationsTextAnnotations\",\n      value: \"text-menu\",\n      section: \"text-annotations\"\n    },\n    {\n      icon: \"delete\",\n      tooltip: \"toolbarAnnotationsClearAll\",\n      value: \"clear\",\n      section: \"tools\"\n    }\n  ]\n};\nvar annotationOptions = {\n  enabled: true,\n  position: \"floating\",\n  align: \"start\",\n  buttons: [\n    {\n      icon: \"text-annotation\",\n      tooltip: \"toolbarAnnotationsTextColor\",\n      value: \"text-color\"\n    },\n    {\n      icon: \"line-color\",\n      tooltip: \"toolbarAnnotationsLineColor\",\n      value: \"line-color\"\n    },\n    {\n      icon: \"fill-color\",\n      tooltip: \"toolbarAnnotationsFillColor\",\n      value: \"fill-color\"\n    },\n    {\n      tooltip: \"toolbarAnnotationsTextSize\",\n      value: \"text-size\"\n    },\n    {\n      icon: \"unlocked\",\n      tooltip: \"toolbarAnnotationsLock\",\n      value: \"lock\"\n    },\n    {\n      icon: \"locked\",\n      tooltip: \"toolbarAnnotationsUnlock\",\n      value: \"unlock\"\n    },\n    {\n      icon: \"delete\",\n      tooltip: \"toolbarAnnotationsDelete\",\n      value: \"delete\"\n    }\n  ]\n};\nvar ranges = {\n  enabled: false,\n  position: DEFAULT_TOOLBAR_POSITION,\n  align: \"start\",\n  buttons: [\n    {\n      label: \"toolbarRange1Month\",\n      ariaLabel: \"toolbarRange1MonthAria\",\n      value: MONTH\n    },\n    {\n      label: \"toolbarRange3Months\",\n      ariaLabel: \"toolbarRange3MonthsAria\",\n      value: 3 * MONTH\n    },\n    {\n      label: \"toolbarRange6Months\",\n      ariaLabel: \"toolbarRange6MonthsAria\",\n      value: 6 * MONTH\n    },\n    {\n      label: \"toolbarRangeYearToDate\",\n      ariaLabel: \"toolbarRangeYearToDateAria\",\n      value: (_start, end) => [(/* @__PURE__ */ new Date(`${new Date(end).getFullYear()}-01-01`)).getTime(), end],\n      id: \"year-to-date\"\n    },\n    {\n      label: \"toolbarRange1Year\",\n      ariaLabel: \"toolbarRange1YearAria\",\n      value: YEAR\n    },\n    {\n      label: \"toolbarRangeAll\",\n      ariaLabel: \"toolbarRangeAllAria\",\n      value: (start, end) => [start, end],\n      id: \"all\"\n    }\n  ]\n};\nvar zoom = {\n  enabled: true,\n  position: \"top\",\n  align: \"end\",\n  buttons: [\n    {\n      icon: \"zoom-out\",\n      tooltip: \"toolbarZoomZoomOut\",\n      value: \"zoom-out\"\n    },\n    {\n      icon: \"zoom-in\",\n      tooltip: \"toolbarZoomZoomIn\",\n      value: \"zoom-in\"\n    },\n    {\n      icon: \"pan-left\",\n      tooltip: \"toolbarZoomPanLeft\",\n      value: \"pan-left\"\n    },\n    {\n      icon: \"pan-right\",\n      tooltip: \"toolbarZoomPanRight\",\n      value: \"pan-right\"\n    },\n    {\n      icon: \"pan-start\",\n      tooltip: \"toolbarZoomPanStart\",\n      value: \"pan-start\"\n    },\n    {\n      icon: \"pan-end\",\n      tooltip: \"toolbarZoomPanEnd\",\n      value: \"pan-end\"\n    },\n    {\n      icon: \"reset\",\n      tooltip: \"toolbarZoomReset\",\n      value: \"reset\"\n    }\n  ]\n};\nvar ToolbarModule = {\n  type: \"root\",\n  optionsKey: \"toolbar\",\n  packageType: \"community\",\n  chartTypes: [\"cartesian\"],\n  moduleFactory: (ctx) => new Toolbar(ctx),\n  themeTemplate: {\n    toolbar: {\n      enabled: true,\n      seriesType,\n      annotations,\n      annotationOptions,\n      ranges,\n      zoom\n    }\n  }\n};\n\n// packages/ag-charts-community/src/chart/factory/registerInbuiltModules.ts\nfunction registerInbuiltModules() {\n  moduleRegistry.register(\n    BackgroundModule,\n    CommunityLegendModule,\n    LocaleModule,\n    NavigatorModule,\n    ToolbarModule,\n    AreaSeriesModule,\n    BarSeriesModule,\n    BubbleSeriesModule,\n    LineSeriesModule,\n    ScatterSeriesModule,\n    DonutSeriesModule,\n    PieSeriesModule,\n    HistogramSeriesModule\n  );\n  for (const AxisConstructor of [NumberAxis, CategoryAxis, TimeAxis, GroupedCategoryAxis, LogAxis]) {\n    axisRegistry.register(AxisConstructor.type, {\n      moduleFactory: (ctx) => new AxisConstructor(ctx),\n      hidden: AxisConstructor === GroupedCategoryAxis\n    });\n  }\n}\n\n// packages/ag-charts-community/src/chart/factory/setupModules.ts\nfunction setupModules() {\n  for (const m of moduleRegistry.modules) {\n    if (m.packageType === \"enterprise\" && !verifyIfModuleExpected(m)) {\n      Logger.errorOnce(\"Unexpected enterprise module registered: \" + m.identifier);\n    }\n    if (m.type === \"root\" && m.themeTemplate) {\n      for (const chartType2 of m.chartTypes) {\n        chartDefaults.set(chartType2, m.themeTemplate);\n      }\n    }\n    if (m.type === \"series\") {\n      if (m.chartTypes.length > 1) {\n        throw new Error(`AG Charts - Module definition error: ${m.identifier}`);\n      }\n      seriesRegistry.register(m.identifier, m);\n    }\n    if (m.type === \"series-option\" && m.themeTemplate) {\n      for (const seriesType2 of m.seriesTypes) {\n        seriesRegistry.setThemeTemplate(seriesType2, m.themeTemplate);\n      }\n    }\n    if (m.type === \"axis-option\" && m.themeTemplate) {\n      for (const axisType of m.axisTypes) {\n        const axisTypeTheme = axisRegistry.getThemeTemplate(axisType);\n        const theme = mergeDefaults(m.themeTemplate, axisTypeTheme);\n        axisRegistry.setThemeTemplate(axisType, theme);\n      }\n    }\n    if (m.type === \"axis\") {\n      axisRegistry.register(m.identifier, m);\n    }\n    if (m.type === \"legend\") {\n      legendRegistry.register(m.identifier, m);\n    }\n  }\n  if (moduleRegistry.hasEnterpriseModules()) {\n    const expectedButUnused = getUnusedExpectedModules();\n    if (expectedButUnused.length > 0) {\n      Logger.errorOnce(\"Enterprise modules expected but not registered: \", expectedButUnused);\n    }\n  }\n}\n\n// packages/ag-charts-community/src/chart/flowProportionChart.ts\nfunction isFlowProportion(series) {\n  return series.type === \"sankey\" || series.type === \"chord\";\n}\nvar FlowProportionChart = class extends Chart {\n  getChartType() {\n    return \"flow-proportion\";\n  }\n  async updateData() {\n    await super.updateData();\n    const { nodes } = this.getOptions();\n    this.series.forEach((series) => {\n      if (isFlowProportion(series)) {\n        series.setChartNodes(nodes);\n      }\n    });\n  }\n  async performLayout() {\n    const shrinkRect = await super.performLayout();\n    const {\n      seriesArea: { padding },\n      seriesRoot,\n      annotationRoot,\n      highlightRoot\n    } = this;\n    const fullSeriesRect = shrinkRect.clone();\n    shrinkRect.shrink(padding.left, \"left\");\n    shrinkRect.shrink(padding.top, \"top\");\n    shrinkRect.shrink(padding.right, \"right\");\n    shrinkRect.shrink(padding.bottom, \"bottom\");\n    this.seriesRect = shrinkRect;\n    this.animationRect = shrinkRect;\n    const seriesVisible = this.series.some((s) => s.visible);\n    seriesRoot.visible = seriesVisible;\n    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n      group.translationX = Math.floor(shrinkRect.x);\n      group.translationY = Math.floor(shrinkRect.y);\n      group.setClipRectInGroupCoordinateSpace(\n        new BBox(fullSeriesRect.x, fullSeriesRect.y, fullSeriesRect.width, fullSeriesRect.height)\n      );\n    }\n    this.ctx.layoutService.dispatchLayoutComplete({\n      type: \"layout-complete\",\n      chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },\n      clipSeries: false,\n      series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: seriesVisible },\n      axes: []\n    });\n    return shrinkRect;\n  }\n};\nFlowProportionChart.className = \"FlowProportionChart\";\nFlowProportionChart.type = \"flow-proportion\";\n\n// packages/ag-charts-community/src/chart/hierarchyChart.ts\nvar HierarchyChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n  }\n  getChartType() {\n    return \"hierarchy\";\n  }\n  async performLayout() {\n    const shrinkRect = await super.performLayout();\n    const {\n      seriesArea: { padding },\n      seriesRoot,\n      annotationRoot,\n      highlightRoot\n    } = this;\n    const fullSeriesRect = shrinkRect.clone();\n    shrinkRect.shrink(padding.left, \"left\");\n    shrinkRect.shrink(padding.top, \"top\");\n    shrinkRect.shrink(padding.right, \"right\");\n    shrinkRect.shrink(padding.bottom, \"bottom\");\n    this.seriesRect = shrinkRect;\n    this.animationRect = shrinkRect;\n    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n      group.translationX = Math.floor(shrinkRect.x);\n      group.translationY = Math.floor(shrinkRect.y);\n    }\n    await Promise.all(\n      this.series.map(async (series) => {\n        await series.update({ seriesRect: shrinkRect });\n      })\n    );\n    seriesRoot.visible = this.series[0].visible;\n    seriesRoot.setClipRectInGroupCoordinateSpace(\n      new BBox(shrinkRect.x, shrinkRect.y, shrinkRect.width, shrinkRect.height)\n    );\n    this.ctx.layoutService.dispatchLayoutComplete({\n      type: \"layout-complete\",\n      chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },\n      clipSeries: false,\n      series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: true },\n      axes: []\n    });\n    return shrinkRect;\n  }\n  getAriaLabel() {\n    const captionText = this.getCaptionText();\n    return `hierarchical chart, ${captionText}`;\n  }\n};\nHierarchyChart.className = \"HierarchyChart\";\nHierarchyChart.type = \"hierarchy\";\n\n// packages/ag-charts-community/src/chart/axis/polarAxis.ts\nvar PolarAxis = class extends Axis {\n  constructor() {\n    super(...arguments);\n    this.shape = \"polygon\";\n    this.innerRadiusRatio = 0;\n    this.defaultTickMinSpacing = 20;\n  }\n  computeLabelsBBox(_options, _seriesRect) {\n    return null;\n  }\n};\n__decorateClass([\n  Validate(UNION([\"polygon\", \"circle\"], \"a polar axis shape\"))\n], PolarAxis.prototype, \"shape\", 2);\n__decorateClass([\n  Validate(RATIO)\n], PolarAxis.prototype, \"innerRadiusRatio\", 2);\n\n// packages/ag-charts-community/src/chart/polarChart.ts\nvar PolarChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n    this.padding = new Padding(40);\n    this.ctx.axisManager.axisGroup.zIndex = 6 /* AXIS_FOREGROUND_ZINDEX */;\n  }\n  getChartType() {\n    return \"polar\";\n  }\n  async performLayout() {\n    const shrinkRect = await super.performLayout();\n    const fullSeriesRect = shrinkRect.clone();\n    this.computeSeriesRect(shrinkRect);\n    await this.computeCircle(shrinkRect);\n    this.axes.forEach((axis) => axis.update());\n    this.ctx.layoutService.dispatchLayoutComplete({\n      type: \"layout-complete\",\n      chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },\n      clipSeries: false,\n      series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: true },\n      axes: []\n    });\n    return shrinkRect;\n  }\n  updateAxes(cx, cy, radius) {\n    const angleAxis = this.axes.find((axis) => axis.direction === \"x\" /* X */);\n    const radiusAxis = this.axes.find((axis) => axis.direction === \"y\" /* Y */);\n    if (!(angleAxis instanceof PolarAxis) || !(radiusAxis instanceof PolarAxis)) {\n      return;\n    }\n    const angleScale = angleAxis.scale;\n    const angles = angleScale.ticks?.().map((value) => angleScale.convert(value));\n    const innerRadiusRatio = radiusAxis.innerRadiusRatio;\n    angleAxis.innerRadiusRatio = innerRadiusRatio;\n    angleAxis.computeRange?.();\n    angleAxis.gridLength = radius;\n    radiusAxis.gridAngles = angles;\n    radiusAxis.gridRange = angleAxis.range;\n    radiusAxis.range = [radius, radius * innerRadiusRatio];\n    [angleAxis, radiusAxis].forEach((axis) => {\n      axis.translation.x = cx;\n      axis.translation.y = cy;\n      axis.calculateLayout();\n    });\n  }\n  computeSeriesRect(shrinkRect) {\n    const {\n      seriesArea: { padding }\n    } = this;\n    shrinkRect.shrink(padding.left, \"left\");\n    shrinkRect.shrink(padding.top, \"top\");\n    shrinkRect.shrink(padding.right, \"right\");\n    shrinkRect.shrink(padding.bottom, \"bottom\");\n    this.seriesRect = shrinkRect;\n    this.animationRect = shrinkRect;\n  }\n  async computeCircle(seriesBox) {\n    const polarSeries = this.series.filter((series) => {\n      return series instanceof PolarSeries;\n    });\n    const polarAxes = this.axes.filter((axis) => {\n      return axis instanceof PolarAxis;\n    });\n    const setSeriesCircle = (cx, cy, r) => {\n      this.updateAxes(cx, cy, r);\n      polarSeries.forEach((series) => {\n        series.centerX = cx;\n        series.centerY = cy;\n        series.radius = r;\n      });\n      const pieSeries = polarSeries.filter((s) => s.type === \"donut\" || s.type === \"pie\");\n      if (pieSeries.length > 1) {\n        const innerRadii = pieSeries.map((series) => {\n          const innerRadius = series.getInnerRadius();\n          return { series, innerRadius };\n        }).sort((a, b) => a.innerRadius - b.innerRadius);\n        innerRadii.at(-1).series.surroundingRadius = void 0;\n        for (let i = 0; i < innerRadii.length - 1; i++) {\n          innerRadii[i].series.surroundingRadius = innerRadii[i + 1].innerRadius;\n        }\n      }\n    };\n    const centerX = seriesBox.x + seriesBox.width / 2;\n    const centerY = seriesBox.y + seriesBox.height / 2;\n    const initialRadius = Math.max(0, Math.min(seriesBox.width, seriesBox.height) / 2);\n    let radius = initialRadius;\n    setSeriesCircle(centerX, centerY, radius);\n    const shake = async ({ hideWhenNecessary = false } = {}) => {\n      const labelBoxes = [];\n      for (const series of [...polarAxes, ...polarSeries]) {\n        const box = await series.computeLabelsBBox({ hideWhenNecessary }, seriesBox);\n        if (box) {\n          labelBoxes.push(box);\n        }\n      }\n      if (labelBoxes.length === 0) {\n        setSeriesCircle(centerX, centerY, initialRadius);\n        return;\n      }\n      const labelBox = BBox.merge(labelBoxes);\n      const refined = this.refineCircle(labelBox, radius, seriesBox);\n      setSeriesCircle(refined.centerX, refined.centerY, refined.radius);\n      if (refined.radius === radius) {\n        return;\n      }\n      radius = refined.radius;\n    };\n    await shake();\n    await shake();\n    await shake();\n    await shake({ hideWhenNecessary: true });\n    await shake({ hideWhenNecessary: true });\n    return { radius, centerX, centerY };\n  }\n  refineCircle(labelsBox, radius, seriesBox) {\n    const minCircleRatio = 0.5;\n    const circleLeft = -radius;\n    const circleTop = -radius;\n    const circleRight = radius;\n    const circleBottom = radius;\n    let padLeft = Math.max(0, circleLeft - labelsBox.x);\n    let padTop = Math.max(0, circleTop - labelsBox.y);\n    let padRight = Math.max(0, labelsBox.x + labelsBox.width - circleRight);\n    let padBottom = Math.max(0, labelsBox.y + labelsBox.height - circleBottom);\n    padLeft = padRight = Math.max(padLeft, padRight);\n    padTop = padBottom = Math.max(padTop, padBottom);\n    const availCircleWidth = seriesBox.width - padLeft - padRight;\n    const availCircleHeight = seriesBox.height - padTop - padBottom;\n    let newRadius = Math.min(availCircleWidth, availCircleHeight) / 2;\n    const minHorizontalRadius = minCircleRatio * seriesBox.width / 2;\n    const minVerticalRadius = minCircleRatio * seriesBox.height / 2;\n    const minRadius = Math.min(minHorizontalRadius, minVerticalRadius);\n    if (newRadius < minRadius) {\n      newRadius = minRadius;\n      const horizontalPadding = padLeft + padRight;\n      const verticalPadding = padTop + padBottom;\n      if (2 * newRadius + verticalPadding > seriesBox.height) {\n        const padHeight = seriesBox.height - 2 * newRadius;\n        if (Math.min(padTop, padBottom) * 2 > padHeight) {\n          padTop = padHeight / 2;\n          padBottom = padHeight / 2;\n        } else if (padTop > padBottom) {\n          padTop = padHeight - padBottom;\n        } else {\n          padBottom = padHeight - padTop;\n        }\n      }\n      if (2 * newRadius + horizontalPadding > seriesBox.width) {\n        const padWidth = seriesBox.width - 2 * newRadius;\n        if (Math.min(padLeft, padRight) * 2 > padWidth) {\n          padLeft = padWidth / 2;\n          padRight = padWidth / 2;\n        } else if (padLeft > padRight) {\n          padLeft = padWidth - padRight;\n        } else {\n          padRight = padWidth - padLeft;\n        }\n      }\n    }\n    const newWidth = padLeft + 2 * newRadius + padRight;\n    const newHeight = padTop + 2 * newRadius + padBottom;\n    return {\n      centerX: seriesBox.x + (seriesBox.width - newWidth) / 2 + padLeft + newRadius,\n      centerY: seriesBox.y + (seriesBox.height - newHeight) / 2 + padTop + newRadius,\n      radius: newRadius\n    };\n  }\n};\nPolarChart.className = \"PolarChart\";\nPolarChart.type = \"polar\";\n\n// packages/ag-charts-community/src/chart/series/topology/mercatorScale.ts\nvar radsInDeg = Math.PI / 180;\nvar lonX = (lon) => lon * radsInDeg;\nvar latY = (lat) => -Math.log(Math.tan(Math.PI * 0.25 + lat * radsInDeg * 0.5));\nvar xLon = (x) => x / radsInDeg;\nvar yLat = (y) => (Math.atan(Math.exp(-y)) - Math.PI * 0.25) / (radsInDeg * 0.5);\nvar MercatorScale = class _MercatorScale {\n  constructor(domain, range3) {\n    this.domain = domain;\n    this.range = range3;\n    this.type = \"mercator\";\n    this.bounds = _MercatorScale.bounds(domain);\n  }\n  static bounds(domain) {\n    const [[lon0, lat0], [lon1, lat1]] = domain;\n    const x0 = lonX(lon0);\n    const y0 = latY(lat0);\n    const x1 = lonX(lon1);\n    const y1 = latY(lat1);\n    return new BBox(Math.min(x0, x1), Math.min(y0, y1), Math.abs(x1 - x0), Math.abs(y1 - y0));\n  }\n  static fixedScale() {\n    return new _MercatorScale(\n      [\n        [xLon(0), yLat(0)],\n        [xLon(1), yLat(1)]\n      ],\n      [\n        [0, 0],\n        [1, 1]\n      ]\n    );\n  }\n  convert([lon, lat]) {\n    const [[x0, y0], [x1, y1]] = this.range;\n    const xScale = (x1 - x0) / this.bounds.width;\n    const yScale = (y1 - y0) / this.bounds.height;\n    return [(lonX(lon) - this.bounds.x) * xScale + x0, (latY(lat) - this.bounds.y) * yScale + y0];\n  }\n  invert([x, y]) {\n    const [[x0, y0], [x1, y1]] = this.range;\n    const xScale = (x1 - x0) / this.bounds.width;\n    const yScale = (y1 - y0) / this.bounds.height;\n    return [xLon((x - x0) / xScale + this.bounds.x), yLat((y - y0) / yScale + this.bounds.y)];\n  }\n};\n\n// packages/ag-charts-community/src/chart/topologyChart.ts\nfunction isTopologySeries(series) {\n  return series.type === \"map-shape\" || series.type === \"map-line\" || series.type === \"map-marker\" || series.type === \"map-shape-background\" || series.type === \"map-line-background\";\n}\nvar TopologyChart = class extends Chart {\n  constructor(options, resources) {\n    super(options, resources);\n    this.xAxis = new NumberAxis(this.getModuleContext());\n    this.xAxis.position = \"bottom\";\n    this.yAxis = new NumberAxis(this.getModuleContext());\n    this.yAxis.position = \"left\";\n    this.ctx.zoomManager.updateAxes([this.xAxis, this.yAxis]);\n  }\n  getChartType() {\n    return \"topology\";\n  }\n  async updateData() {\n    await super.updateData();\n    const { topology } = this.getOptions();\n    this.series.forEach((series) => {\n      if (isTopologySeries(series)) {\n        series.setChartTopology(topology);\n      }\n    });\n  }\n  async performLayout() {\n    const shrinkRect = await super.performLayout();\n    const {\n      seriesArea: { padding },\n      seriesRoot,\n      annotationRoot,\n      highlightRoot\n    } = this;\n    const fullSeriesRect = shrinkRect.clone();\n    shrinkRect.shrink(padding.left, \"left\");\n    shrinkRect.shrink(padding.top, \"top\");\n    shrinkRect.shrink(padding.right, \"right\");\n    shrinkRect.shrink(padding.bottom, \"bottom\");\n    this.seriesRect = shrinkRect;\n    this.animationRect = shrinkRect;\n    const mapSeries = this.series.filter(isTopologySeries);\n    const combinedBbox = mapSeries.reduce((combined, series) => {\n      if (!series.visible)\n        return combined;\n      const bbox = series.topologyBounds;\n      if (bbox == null)\n        return combined;\n      if (combined == null)\n        return bbox;\n      combined.merge(bbox);\n      return combined;\n    }, void 0);\n    let scale2;\n    if (combinedBbox != null) {\n      const { lon0, lat0, lon1, lat1 } = combinedBbox;\n      const domain = [\n        [lon0, lat0],\n        [lon1, lat1]\n      ];\n      const bounds = MercatorScale.bounds(domain);\n      const { width, height } = shrinkRect;\n      const viewBoxScale = Math.min(width / bounds.width, height / bounds.height);\n      const viewBoxWidth = bounds.width * viewBoxScale;\n      const viewBoxHeight = bounds.height * viewBoxScale;\n      const viewBoxOriginX = (width - viewBoxWidth) / 2;\n      const viewBoxOriginY = (height - viewBoxHeight) / 2;\n      const x0 = viewBoxOriginX;\n      const y0 = viewBoxOriginY;\n      const x1 = viewBoxOriginX + viewBoxWidth;\n      const y1 = viewBoxOriginY + viewBoxHeight;\n      const xZoom = this.ctx.zoomManager.getAxisZoom(this.xAxis.id);\n      const yZoom = this.ctx.zoomManager.getAxisZoom(this.yAxis.id);\n      const xSpan = (x1 - x0) / (xZoom.max - xZoom.min);\n      const xStart = x0 - xSpan * xZoom.min;\n      const ySpan = (y1 - y0) / (1 - yZoom.min - (1 - yZoom.max));\n      const yStart = y0 - ySpan * (1 - yZoom.max);\n      scale2 = new MercatorScale(domain, [\n        [xStart, yStart],\n        [xStart + xSpan, yStart + ySpan]\n      ]);\n    }\n    mapSeries.forEach((series) => {\n      series.scale = scale2;\n    });\n    const seriesVisible = this.series.some((s) => s.visible);\n    seriesRoot.visible = seriesVisible;\n    for (const group of [seriesRoot, annotationRoot, highlightRoot]) {\n      group.translationX = Math.floor(shrinkRect.x);\n      group.translationY = Math.floor(shrinkRect.y);\n      group.setClipRectInGroupCoordinateSpace(\n        new BBox(shrinkRect.x, shrinkRect.y, shrinkRect.width, shrinkRect.height)\n      );\n    }\n    this.ctx.layoutService.dispatchLayoutComplete({\n      type: \"layout-complete\",\n      chart: { width: this.ctx.scene.width, height: this.ctx.scene.height },\n      clipSeries: false,\n      series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: seriesVisible },\n      axes: []\n    });\n    return shrinkRect;\n  }\n};\nTopologyChart.className = \"TopologyChart\";\nTopologyChart.type = \"topology\";\n\n// packages/ag-charts-community/src/module/enterpriseModule.ts\nvar enterpriseModule = {\n  isEnterprise: false\n};\n\n// packages/ag-charts-community/src/api/preset/priceVolumePreset.ts\nfunction fromTheme(theme, cb) {\n  if (isObject(theme)) {\n    return cb(theme);\n  }\n}\nvar chartTypes2 = [\"ohlc\", \"line\", \"step-line\", \"hlc\", \"high-low\", \"candlestick\", \"hollow-candlestick\"];\nfunction priceVolume(opts, getTheme) {\n  const {\n    xKey,\n    dateKey = xKey ?? \"date\",\n    highKey = \"high\",\n    openKey = \"open\",\n    lowKey = \"low\",\n    closeKey = \"close\",\n    volumeKey = \"volume\",\n    chartType: chartType2 = \"candlestick\",\n    navigator: navigator2 = false,\n    volume = true,\n    rangeToolbar,\n    rangeButtons = rangeToolbar ?? true,\n    statusBar = true,\n    annotations: annotations2,\n    toolbar = annotations2 ?? true,\n    zoom: zoom2 = true,\n    theme,\n    data,\n    ...unusedOpts\n  } = opts;\n  if (xKey != null) {\n    Logger.warnOnce(\"Property [xKey] is deprecated, use [dateKey] instead.\");\n  }\n  if (rangeToolbar != null) {\n    Logger.warnOnce(\"Property [rangeToolbar] is deprecated, use [rangeButtons] instead.\");\n  }\n  if (annotations2 != null) {\n    Logger.warnOnce(\"Property [annotations] is deprecated, use [toolbar] instead.\");\n  }\n  const priceSeries = createPriceSeries(theme, chartType2, dateKey, highKey, lowKey, openKey, closeKey);\n  const volumeSeries = createVolumeSeries(theme, getTheme, openKey, closeKey, volume, volumeKey);\n  const miniChart = volume ? {\n    miniChart: {\n      enabled: navigator2,\n      series: [\n        {\n          type: \"line\",\n          xKey: dateKey,\n          yKey: volumeKey,\n          marker: { enabled: false }\n        }\n      ]\n    }\n  } : null;\n  const navigatorOpts = {\n    navigator: {\n      enabled: navigator2,\n      ...miniChart\n    }\n  };\n  const statusBarOpts = statusBar ? {\n    statusBar: {\n      enabled: true,\n      data,\n      highKey,\n      openKey,\n      lowKey,\n      closeKey,\n      volumeKey: volume ? volumeKey : void 0\n    }\n  } : null;\n  const zoomOpts = {\n    zoom: {\n      enabled: zoom2,\n      // @ts-expect-error\n      enableIndependentAxes: true\n    }\n  };\n  const toolbarOpts = {\n    chartToolbar: { enabled: true },\n    toolbar: {\n      seriesType: {\n        enabled: toolbar\n      },\n      annotationOptions: {\n        enabled: toolbar\n      },\n      annotations: {\n        enabled: toolbar\n      },\n      ranges: {\n        enabled: rangeButtons\n      }\n    }\n  };\n  const volumeAxis = volume ? [\n    {\n      type: \"number\",\n      position: \"left\",\n      keys: [volumeKey],\n      label: { enabled: false },\n      crosshair: { enabled: false },\n      gridLine: { enabled: false },\n      nice: false,\n      // @ts-expect-error\n      layoutConstraints: {\n        stacked: false,\n        width: 20,\n        unit: \"percentage\",\n        align: \"end\"\n      }\n    }\n  ] : [];\n  return {\n    theme: typeof theme === \"string\" ? theme : {\n      baseTheme: \"ag-financial\",\n      ...theme ?? {}\n    },\n    animation: { enabled: false },\n    legend: { enabled: false },\n    series: [...volumeSeries, ...priceSeries],\n    padding: {\n      top: 6,\n      right: 8,\n      bottom: 5\n    },\n    axes: [\n      {\n        type: \"number\",\n        position: \"right\",\n        keys: [openKey, closeKey, highKey, lowKey],\n        interval: {\n          maxSpacing: fromTheme(theme, (t) => t.overrides?.common?.axes?.number?.interval?.maxSpacing) ?? 45\n        },\n        label: {\n          format: fromTheme(theme, (t) => t.overrides?.common?.axes?.number?.label?.format) ?? \".2f\"\n        },\n        crosshair: {\n          enabled: true,\n          snap: false\n        },\n        // @ts-expect-error\n        layoutConstraints: {\n          stacked: false,\n          width: 100,\n          unit: \"percentage\",\n          align: \"start\"\n        }\n      },\n      ...volumeAxis,\n      {\n        type: \"ordinal-time\",\n        position: \"bottom\",\n        line: {\n          enabled: false\n        },\n        label: {\n          enabled: true\n        },\n        crosshair: {\n          enabled: true\n        }\n      }\n    ],\n    annotations: {\n      enabled: toolbar\n    },\n    tooltip: { enabled: false },\n    data,\n    // @ts-expect-error\n    titlePadding: 4,\n    ...navigatorOpts,\n    ...statusBarOpts,\n    ...zoomOpts,\n    ...toolbarOpts,\n    ...unusedOpts\n  };\n}\nfunction createVolumeSeries(theme, getTheme, openKey, closeKey, volume, volumeKey) {\n  if (!volume)\n    return [];\n  const barSeriesFill = fromTheme(theme, (t) => t.overrides?.bar?.series?.fill);\n  const itemStyler = barSeriesFill ? { fill: barSeriesFill } : {\n    itemStyler({ datum }) {\n      const { up, down } = getTheme().palette;\n      return { fill: datum[openKey] < datum[closeKey] ? up?.fill : down?.fill };\n    }\n  };\n  return [\n    {\n      type: \"bar\",\n      xKey: \"date\",\n      yKey: volumeKey,\n      tooltip: { enabled: false },\n      // @ts-expect-error\n      highlight: { enabled: false },\n      fillOpacity: fromTheme(theme, (t) => t.overrides?.bar?.series?.fillOpacity) ?? 0.5,\n      ...itemStyler\n    }\n  ];\n}\nvar RANGE_AREA_TYPE = \"range-area\";\nfunction createPriceSeries(theme, chartType2, xKey, highKey, lowKey, openKey, closeKey) {\n  if (chartType2 === RANGE_AREA_TYPE) {\n    Logger.warnOnce(`type '${chartType2}' is deprecated, use 'hlc' chart type instead`);\n    chartType2 = \"hlc\";\n  }\n  const keys = {\n    xKey,\n    openKey,\n    closeKey,\n    highKey,\n    lowKey\n  };\n  const singleKeys = {\n    xKey,\n    yKey: closeKey\n  };\n  const common = {\n    pickOutsideVisibleMinorAxis: true\n  };\n  switch (chartType2 ?? \"candlestick\") {\n    case \"ohlc\":\n      return [\n        {\n          type: \"ohlc\",\n          ...common,\n          ...keys\n        }\n      ];\n    case \"line\":\n      return [\n        {\n          type: \"line\",\n          ...common,\n          ...singleKeys,\n          stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_NEUTRAL_STROKE,\n          marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }\n        }\n      ];\n    case \"step-line\":\n      return [\n        {\n          type: \"line\",\n          ...common,\n          ...singleKeys,\n          stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_NEUTRAL_STROKE,\n          interpolation: fromTheme(theme, (t) => t.overrides?.line?.series?.interpolation) ?? {\n            type: \"step\"\n          },\n          marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }\n        }\n      ];\n    case \"hlc\":\n      const rangeAreaColors = getThemeColors(RANGE_AREA_TYPE, theme);\n      return [\n        {\n          type: RANGE_AREA_TYPE,\n          ...common,\n          xKey,\n          yHighKey: highKey,\n          yLowKey: closeKey,\n          fill: rangeAreaColors.fill ?? PALETTE_UP_FILL,\n          stroke: rangeAreaColors.stroke ?? PALETTE_UP_STROKE,\n          fillOpacity: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.fillOpacity) ?? 0.3,\n          strokeWidth: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.strokeWidth) ?? 2\n        },\n        {\n          type: RANGE_AREA_TYPE,\n          ...common,\n          xKey,\n          yHighKey: closeKey,\n          yLowKey: lowKey,\n          fill: rangeAreaColors.fill ?? PALETTE_DOWN_FILL,\n          stroke: rangeAreaColors.stroke ?? PALETTE_DOWN_STROKE,\n          fillOpacity: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.fillOpacity) ?? 0.3,\n          strokeWidth: fromTheme(theme, (t) => t.overrides?.[\"range-area\"]?.series?.strokeWidth) ?? 2\n        },\n        {\n          type: \"line\",\n          ...common,\n          ...singleKeys,\n          stroke: fromTheme(theme, (t) => t.overrides?.line?.series?.stroke) ?? PALETTE_ALT_NEUTRAL_STROKE,\n          strokeWidth: fromTheme(theme, (t) => t.overrides?.line?.series?.strokeWidth) ?? 2,\n          marker: fromTheme(theme, (t) => t.overrides?.line?.series?.marker) ?? { enabled: false }\n        }\n      ];\n    case \"high-low\":\n      const rangeBarColors = getThemeColors(\"range-bar\", theme);\n      return [\n        {\n          type: \"range-bar\",\n          ...common,\n          xKey,\n          yHighKey: highKey,\n          yLowKey: lowKey,\n          fill: rangeBarColors.fill ?? PALETTE_NEUTRAL_FILL,\n          stroke: rangeBarColors.stroke ?? PALETTE_NEUTRAL_STROKE,\n          tooltip: {\n            range: \"nearest\"\n          }\n        }\n      ];\n    case \"candlestick\":\n      return [\n        {\n          type: \"candlestick\",\n          ...common,\n          ...keys\n        }\n      ];\n    case \"hollow-candlestick\":\n      const item = fromTheme(theme, (t) => t.overrides?.candlestick?.series?.item);\n      return [\n        {\n          type: \"candlestick\",\n          ...common,\n          ...keys,\n          item: {\n            up: {\n              fill: item?.up?.fill ?? \"transparent\"\n            }\n          }\n        }\n      ];\n    default:\n      Logger.warnOnce(`unknown chart type: ${chartType2}; expected one of: ${chartTypes2.join(\", \")}`);\n      return [\n        {\n          type: \"candlestick\",\n          ...common,\n          ...keys\n        }\n      ];\n  }\n}\nfunction getThemeColors(seriesType2, theme) {\n  const fill = fromTheme(theme, (t) => t.overrides?.[seriesType2]?.series?.fill);\n  const stroke = fromTheme(theme, (t) => t.overrides?.[seriesType2]?.series?.stroke);\n  return { fill, stroke };\n}\n\n// packages/ag-charts-community/src/api/preset/presets.ts\nvar PRESETS = {\n  \"price-volume\": priceVolume\n};\n\n// packages/ag-charts-community/src/chart/factory/processEnterpriseOptions.ts\nfunction removeUsedEnterpriseOptions(options, silent) {\n  const usedOptions = [];\n  const optionsChartType = chartTypes.get(optionsType(options));\n  for (const {\n    type,\n    chartTypes: moduleChartTypes,\n    optionsKey,\n    optionsInnerKey,\n    identifier\n  } of EXPECTED_ENTERPRISE_MODULES) {\n    if (optionsChartType !== \"unknown\" && !moduleChartTypes.includes(optionsChartType))\n      continue;\n    if (type === \"root\" || type === \"legend\") {\n      const optionValue = options[optionsKey];\n      if (optionValue == null)\n        continue;\n      if (!optionsInnerKey) {\n        usedOptions.push(optionsKey);\n        delete options[optionsKey];\n      } else if (optionValue[optionsInnerKey]) {\n        usedOptions.push(`${optionsKey}.${optionsInnerKey}`);\n        delete optionValue[optionsInnerKey];\n      }\n    } else if (type === \"axis\") {\n      if (!(\"axes\" in options) || !options.axes?.some((axis) => axis.type === identifier))\n        continue;\n      usedOptions.push(`axis[type=${identifier}]`);\n      options.axes = options.axes.filter((axis) => axis.type !== identifier);\n    } else if (type === \"axis-option\") {\n      if (!(\"axes\" in options) || !options.axes?.some((axis) => axis[optionsKey]))\n        continue;\n      usedOptions.push(`axis.${optionsKey}`);\n      options.axes.forEach((axis) => {\n        if (axis[optionsKey]) {\n          delete axis[optionsKey];\n        }\n      });\n    } else if (type === \"series\") {\n      if (!options.series?.some((series) => series.type === identifier))\n        continue;\n      usedOptions.push(`series[type=${identifier}]`);\n      options.series = options.series.filter((series) => series.type !== identifier);\n    } else if (type === \"series-option\") {\n      if (!options.series?.some((series) => series[optionsKey]))\n        continue;\n      usedOptions.push(`series.${optionsKey}`);\n      options.series.forEach((series) => {\n        if (series[optionsKey]) {\n          delete series[optionsKey];\n        }\n      });\n    }\n  }\n  if (usedOptions.length && !silent) {\n    let enterprisePackageName = \"ag-charts-enterprise\";\n    let enterpriseReferenceUrl = \"https://charts.ag-grid.com/javascript/installation/\";\n    if (options.mode === \"integrated\") {\n      enterprisePackageName = \"ag-grid-charts-enterprise' or 'ag-grid-enterprise/charts-enterprise\";\n      enterpriseReferenceUrl = \"https://www.ag-grid.com/javascript-data-grid/integrated-charts-installation/\";\n    }\n    Logger.warnOnce(\n      [\n        `unable to use these enterprise features as '${enterprisePackageName}' has not been loaded:`,\n        \"\",\n        ...usedOptions,\n        \"\",\n        `See: ${enterpriseReferenceUrl}`\n      ].join(\"\\n\")\n    );\n  }\n}\n\n// packages/ag-charts-community/src/util/string.util.ts\nfunction stringifyValue(value, maxLength = Infinity) {\n  switch (typeof value) {\n    case \"undefined\":\n      return \"undefined\";\n    case \"number\":\n      if (isNaN(value)) {\n        return \"NaN\";\n      } else if (value === Infinity) {\n        return \"Infinity\";\n      } else if (value === -Infinity) {\n        return \"-Infinity\";\n      }\n    default:\n      value = JSON.stringify(value);\n      if (value.length > maxLength) {\n        return `${value.slice(0, maxLength)}... (+${value.length - maxLength} characters)`;\n      }\n      return value;\n  }\n}\n\n// packages/ag-charts-community/src/util/validate.ts\nvar descriptionSymbol = Symbol(\"description\");\nvar requiredSymbol = Symbol(\"required\");\nfunction isValid(options, optionsDefs, path) {\n  const { errors } = validate(options, optionsDefs, path);\n  for (const { message } of errors) {\n    Logger.warn(message);\n  }\n  return errors.length === 0;\n}\nfunction validateMessage(path, value, validatorOrDefs) {\n  const description = isString(validatorOrDefs) ? validatorOrDefs : validatorOrDefs[descriptionSymbol];\n  const expecting = description ? `; expecting ${description}` : \"\";\n  const prefix = path ? `Option \\`${path}\\`` : \"Value\";\n  return `${prefix} cannot be set to \\`${stringifyValue(value)}\\`${expecting}, ignoring.`;\n}\nfunction validate(options, optionsDefs, path = \"\") {\n  if (!isObject(options)) {\n    return {\n      valid: null,\n      errors: [{ path, value: options, message: validateMessage(path, options, \"an object\") }]\n    };\n  }\n  const optionsKeys = new Set(Object.keys(options));\n  const errors = [];\n  const valid = {};\n  function extendPath(key) {\n    if (isArray(optionsDefs)) {\n      return `${path}[${key}]`;\n    }\n    return path ? `${path}.${key}` : key;\n  }\n  for (const [key, validatorOrDefs] of Object.entries(optionsDefs)) {\n    optionsKeys.delete(key);\n    const value = options[key];\n    if (!validatorOrDefs[requiredSymbol] && typeof value === \"undefined\")\n      continue;\n    if (isFunction(validatorOrDefs)) {\n      if (validatorOrDefs(value)) {\n        valid[key] = value;\n      } else {\n        errors.push({ key, path, value, message: validateMessage(extendPath(key), value, validatorOrDefs) });\n      }\n    } else {\n      const nestedResult = validate(value, validatorOrDefs, extendPath(key));\n      valid[key] = nestedResult.valid;\n      errors.push(...nestedResult.errors);\n    }\n  }\n  for (const key of optionsKeys) {\n    errors.push({\n      key,\n      path,\n      unknown: true,\n      message: `Unknown option \\`${extendPath(key)}\\`, ignoring.`\n    });\n  }\n  return { valid, errors };\n}\nfunction attachDescription(validator, description) {\n  return Object.assign((value) => validator(value), { [descriptionSymbol]: description });\n}\nvar or = (...validators) => attachDescription(\n  (value) => validators.some((validator) => validator(value)),\n  validators.map((v) => v[descriptionSymbol]).filter(Boolean).join(\" or \")\n);\nvar array = attachDescription(isArray, \"an array\");\nvar boolean = attachDescription(isBoolean, \"a boolean\");\nvar callback = attachDescription(isFunction, \"a function\");\nvar number = attachDescription(isFiniteNumber, \"a number\");\nvar object = attachDescription(isObject, \"an object\");\nvar string = attachDescription(isString, \"a string\");\nvar numberMin = (min, inclusive = true) => attachDescription(\n  (value) => isFiniteNumber(value) && (value > min || inclusive && value === min),\n  `a number greater than ${inclusive ? \"or equal to \" : \"\"}${min}`\n);\nvar numberRange = (min, max) => attachDescription(\n  (value) => isFiniteNumber(value) && value >= min && value <= max,\n  `a number between ${min} and ${max} inclusive`\n);\nvar positiveNumber = numberMin(0);\nvar minOneNumber = numberMin(1);\nvar ratio = numberRange(0, 1);\nvar degree = numberRange(0, 360);\nvar arrayOf = (validator, description) => attachDescription(\n  (value) => isArray(value) && value.every(validator),\n  description ?? `${validator[descriptionSymbol]} array`\n);\n\n// packages/ag-charts-community/src/module/coreModulesTypes.ts\nfunction paletteType(partial) {\n  if (partial?.up || partial?.down || partial?.neutral) {\n    return \"user-full\";\n  } else if (partial?.fills || partial?.strokes) {\n    return \"user-indexed\";\n  }\n  return \"inbuilt\";\n}\n\n// packages/ag-charts-community/src/chart/themes/chartTheme.ts\nvar DEFAULT_BACKGROUND_FILL = \"white\";\nvar CHART_TYPE_CONFIG = {\n  get cartesian() {\n    return { seriesTypes: chartTypes.cartesianTypes, commonOptions: [\"zoom\", \"navigator\"] };\n  },\n  get polar() {\n    return { seriesTypes: chartTypes.polarTypes, commonOptions: [] };\n  },\n  get hierarchy() {\n    return { seriesTypes: chartTypes.hierarchyTypes, commonOptions: [] };\n  },\n  get topology() {\n    return { seriesTypes: chartTypes.topologyTypes, commonOptions: [] };\n  },\n  get \"flow-proportion\"() {\n    return { seriesTypes: chartTypes.flowProportionTypes, commonOptions: [] };\n  }\n};\nvar CHART_TYPE_SPECIFIC_COMMON_OPTIONS = Object.values(CHART_TYPE_CONFIG).reduce((r, { commonOptions }) => r.concat(commonOptions), []);\nvar _ChartTheme = class _ChartTheme {\n  static getAxisDefaults(overrideDefaults) {\n    return mergeDefaults(overrideDefaults, {\n      title: {\n        enabled: false,\n        text: \"Axis Title\",\n        spacing: 25,\n        fontWeight: \"normal\" /* NORMAL */,\n        fontSize: 13 /* MEDIUM */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      },\n      label: {\n        fontSize: 12 /* SMALL */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        padding: 5,\n        color: DEFAULT_LABEL_COLOUR,\n        avoidCollisions: true\n      },\n      line: {\n        enabled: true,\n        width: 1,\n        stroke: DEFAULT_AXIS_LINE_COLOUR\n      },\n      tick: {\n        enabled: false,\n        width: 1,\n        stroke: DEFAULT_AXIS_LINE_COLOUR\n      },\n      gridLine: {\n        enabled: true,\n        style: [{ stroke: DEFAULT_AXIS_GRID_COLOUR, lineDash: [] }]\n      },\n      crossLines: {\n        enabled: false,\n        fill: DEFAULT_CROSS_LINES_COLOUR,\n        stroke: DEFAULT_CROSS_LINES_COLOUR,\n        fillOpacity: 0.1,\n        strokeWidth: 1,\n        label: {\n          enabled: false,\n          fontSize: 12 /* SMALL */,\n          fontFamily: DEFAULT_FONT_FAMILY,\n          padding: 5,\n          color: DEFAULT_LABEL_COLOUR\n        }\n      },\n      crosshair: {\n        enabled: true\n      }\n    });\n  }\n  getChartDefaults() {\n    return {\n      minHeight: 300,\n      minWidth: 300,\n      background: { visible: true, fill: DEFAULT_BACKGROUND_COLOUR },\n      padding: { top: DEFAULT_PADDING, right: DEFAULT_PADDING, bottom: DEFAULT_PADDING, left: DEFAULT_PADDING },\n      keyboard: { enabled: true },\n      title: {\n        enabled: false,\n        text: \"Title\",\n        fontWeight: \"normal\" /* NORMAL */,\n        fontSize: 17 /* LARGE */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR,\n        wrapping: \"hyphenate\",\n        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,\n        textAlign: DEFAULT_CAPTION_ALIGNMENT\n      },\n      subtitle: {\n        enabled: false,\n        text: \"Subtitle\",\n        spacing: 20,\n        fontSize: 13 /* MEDIUM */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_MUTED_LABEL_COLOUR,\n        wrapping: \"hyphenate\",\n        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,\n        textAlign: DEFAULT_CAPTION_ALIGNMENT\n      },\n      footnote: {\n        enabled: false,\n        text: \"Footnote\",\n        spacing: 20,\n        fontSize: 13 /* MEDIUM */,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: \"rgb(140, 140, 140)\",\n        wrapping: \"hyphenate\",\n        layoutStyle: DEFAULT_CAPTION_LAYOUT_STYLE,\n        textAlign: DEFAULT_CAPTION_ALIGNMENT\n      },\n      legend: {\n        position: \"bottom\" /* BOTTOM */,\n        spacing: 30,\n        listeners: {},\n        toggleSeries: true,\n        item: {\n          paddingX: 16,\n          paddingY: 8,\n          marker: { size: 15, padding: 8 },\n          showSeriesStroke: true,\n          label: {\n            color: DEFAULT_LABEL_COLOUR,\n            fontSize: 12 /* SMALL */,\n            fontFamily: DEFAULT_FONT_FAMILY\n          }\n        },\n        reverseOrder: false,\n        pagination: {\n          marker: { size: 12 },\n          activeStyle: { fill: DEFAULT_LABEL_COLOUR },\n          inactiveStyle: { fill: DEFAULT_MUTED_LABEL_COLOUR },\n          highlightStyle: { fill: DEFAULT_LABEL_COLOUR },\n          label: { color: DEFAULT_LABEL_COLOUR }\n        }\n      },\n      tooltip: {\n        enabled: true,\n        darkTheme: IS_DARK_THEME,\n        delay: 0\n      },\n      overlays: { darkTheme: IS_DARK_THEME },\n      listeners: {}\n    };\n  }\n  constructor(options = {}) {\n    const { overrides, palette } = deepClone(options);\n    const defaults = this.createChartConfigPerChartType(this.getDefaults());\n    if (overrides) {\n      this.mergeOverrides(defaults, overrides);\n    }\n    const { fills, strokes, ...otherColors } = this.getDefaultColors();\n    this.palette = mergeDefaults(palette, {\n      fills: Object.values(fills),\n      strokes: Object.values(strokes),\n      ...otherColors\n    });\n    this.paletteType = paletteType(palette);\n    this.config = Object.freeze(this.templateTheme(defaults));\n  }\n  mergeOverrides(defaults, overrides) {\n    for (const { seriesTypes, commonOptions } of Object.values(CHART_TYPE_CONFIG)) {\n      const cleanedCommon = { ...overrides.common };\n      for (const commonKey of CHART_TYPE_SPECIFIC_COMMON_OPTIONS) {\n        if (!commonOptions.includes(commonKey)) {\n          delete cleanedCommon[commonKey];\n        }\n      }\n      if (!cleanedCommon)\n        continue;\n      for (const s of seriesTypes) {\n        const seriesType2 = s;\n        defaults[seriesType2] = mergeDefaults(cleanedCommon, defaults[seriesType2]);\n      }\n    }\n    chartTypes.seriesTypes.forEach((s) => {\n      const seriesType2 = s;\n      if (overrides[seriesType2]) {\n        defaults[seriesType2] = mergeDefaults(overrides[seriesType2], defaults[seriesType2]);\n      }\n    });\n  }\n  createChartConfigPerChartType(config) {\n    for (const [nextType, { seriesTypes }] of Object.entries(CHART_TYPE_CONFIG)) {\n      const typeDefaults = chartDefaults.get(nextType);\n      for (const seriesType2 of seriesTypes) {\n        config[seriesType2] || (config[seriesType2] = deepClone(typeDefaults));\n      }\n    }\n    return config;\n  }\n  getDefaults() {\n    const getOverridesByType = (chartType2, seriesTypes) => {\n      const result = {};\n      const chartTypeDefaults = {\n        axes: {},\n        ...legendRegistry.getThemeTemplates(),\n        ...this.getChartDefaults(),\n        ...chartDefaults.get(chartType2)\n      };\n      for (const seriesType2 of seriesTypes) {\n        result[seriesType2] = mergeDefaults(\n          seriesRegistry.getThemeTemplate(seriesType2),\n          result[seriesType2] ?? deepClone(chartTypeDefaults)\n        );\n        const { axes } = result[seriesType2];\n        for (const axisType of axisRegistry.keys()) {\n          axes[axisType] = mergeDefaults(\n            axes[axisType],\n            axisRegistry.getThemeTemplate(axisType),\n            _ChartTheme.cartesianAxisDefault[axisType]\n          );\n        }\n      }\n      return result;\n    };\n    return mergeDefaults(\n      getOverridesByType(\"cartesian\", chartTypes.cartesianTypes),\n      getOverridesByType(\"polar\", chartTypes.polarTypes),\n      getOverridesByType(\"hierarchy\", chartTypes.hierarchyTypes),\n      getOverridesByType(\"topology\", chartTypes.topologyTypes),\n      getOverridesByType(\"flow-proportion\", chartTypes.flowProportionTypes)\n    );\n  }\n  templateTheme(themeTemplate) {\n    const themeInstance = deepClone(themeTemplate);\n    const params = this.getTemplateParameters();\n    jsonWalk(themeInstance, (node) => {\n      if (isArray(node)) {\n        for (let i = 0; i < node.length; i++) {\n          const symbol = node[i];\n          if (params.has(symbol)) {\n            node[i] = params.get(symbol);\n          }\n        }\n      } else {\n        for (const [name, value] of Object.entries(node)) {\n          if (params.has(value)) {\n            node[name] = params.get(value);\n          }\n        }\n      }\n    });\n    return deepClone(themeInstance);\n  }\n  getDefaultColors() {\n    return {\n      fills: DEFAULT_FILLS,\n      strokes: DEFAULT_STROKES,\n      up: { fill: DEFAULT_FILLS.GREEN, stroke: DEFAULT_STROKES.GREEN },\n      down: { fill: DEFAULT_FILLS.RED, stroke: DEFAULT_STROKES.RED },\n      neutral: { fill: DEFAULT_FILLS.GRAY, stroke: DEFAULT_STROKES.GRAY },\n      altUp: { fill: DEFAULT_FILLS.BLUE, stroke: DEFAULT_STROKES.BLUE },\n      altDown: { fill: DEFAULT_FILLS.ORANGE, stroke: DEFAULT_STROKES.ORANGE },\n      altNeutral: { fill: DEFAULT_FILLS.GRAY, stroke: DEFAULT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = /* @__PURE__ */ new Map();\n    params.set(IS_DARK_THEME, false);\n    params.set(DEFAULT_FONT_FAMILY, \"Verdana, sans-serif\");\n    params.set(DEFAULT_LABEL_COLOUR, \"rgb(70, 70, 70)\");\n    params.set(DEFAULT_INVERTED_LABEL_COLOUR, \"white\");\n    params.set(DEFAULT_MUTED_LABEL_COLOUR, \"rgb(140, 140, 140)\");\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"rgb(224,234,241)\");\n    params.set(DEFAULT_AXIS_LINE_COLOUR, \"rgb(195, 195, 195)\");\n    params.set(DEFAULT_CROSS_LINES_COLOUR, \"rgb(70, 70, 70)\");\n    params.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_SHADOW_COLOUR, \"rgba(0, 0, 0, 0.5)\");\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      DEFAULT_FILLS.ORANGE,\n      DEFAULT_FILLS.YELLOW,\n      DEFAULT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_PADDING, 20);\n    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, \"block\");\n    params.set(DEFAULT_CAPTION_ALIGNMENT, \"center\");\n    params.set(DEFAULT_HIERARCHY_FILLS, [\"#ffffff\", \"#e0e5ea\", \"#c1ccd5\", \"#a3b4c1\", \"#859cad\"]);\n    params.set(DEFAULT_HIERARCHY_STROKES, [\"#ffffff\", \"#c5cbd1\", \"#a4b1bd\", \"#8498a9\", \"#648096\"]);\n    params.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_ANNOTATION_COLOR, DEFAULT_FILLS.BLUE);\n    params.set(DEFAULT_TEXT_ANNOTATION_COLOR, DEFAULT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, DEFAULT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_HANDLE_FILL, DEFAULT_BACKGROUND_FILL);\n    params.set(DEFAULT_TEXTBOX_FILL, \"#fafafa\");\n    params.set(DEFAULT_TEXTBOX_STROKE, \"#dddddd\");\n    params.set(DEFAULT_TEXTBOX_COLOR, \"#000000\");\n    params.set(DEFAULT_TOOLBAR_POSITION, \"top\");\n    params.set(DEFAULT_GRIDLINE_ENABLED, false);\n    const defaultColors = this.getDefaultColors();\n    params.set(PALETTE_UP_STROKE, this.palette.up?.stroke ?? defaultColors.up.stroke);\n    params.set(PALETTE_UP_FILL, this.palette.up?.fill ?? defaultColors.up.fill);\n    params.set(PALETTE_DOWN_STROKE, this.palette.down?.stroke ?? defaultColors.down.stroke);\n    params.set(PALETTE_DOWN_FILL, this.palette.down?.fill ?? defaultColors.down.fill);\n    params.set(PALETTE_NEUTRAL_STROKE, this.palette.neutral?.stroke ?? defaultColors.neutral.stroke);\n    params.set(PALETTE_NEUTRAL_FILL, this.palette.neutral?.fill ?? defaultColors.neutral.fill);\n    params.set(PALETTE_ALT_UP_STROKE, this.palette.altUp?.stroke ?? defaultColors.up.stroke);\n    params.set(PALETTE_ALT_UP_FILL, this.palette.altUp?.fill ?? defaultColors.up.fill);\n    params.set(PALETTE_ALT_DOWN_STROKE, this.palette.altDown?.stroke ?? defaultColors.down.stroke);\n    params.set(PALETTE_ALT_DOWN_FILL, this.palette.altDown?.fill ?? defaultColors.down.fill);\n    params.set(PALETTE_ALT_NEUTRAL_FILL, this.palette.altNeutral?.fill ?? defaultColors.altNeutral.fill);\n    params.set(PALETTE_ALT_NEUTRAL_STROKE, this.palette.altNeutral?.stroke ?? defaultColors.altNeutral.stroke);\n    return params;\n  }\n};\n_ChartTheme.cartesianAxisDefault = {\n  [\"number\" /* NUMBER */]: _ChartTheme.getAxisDefaults({\n    line: { enabled: false }\n  }),\n  [\"log\" /* LOG */]: _ChartTheme.getAxisDefaults({\n    base: 10,\n    line: { enabled: false }\n  }),\n  [\"category\" /* CATEGORY */]: _ChartTheme.getAxisDefaults({\n    groupPaddingInner: 0.1,\n    label: { autoRotate: true },\n    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED },\n    crosshair: { enabled: false }\n  }),\n  [\"time\" /* TIME */]: _ChartTheme.getAxisDefaults({ gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED } }),\n  [\"ordinal-time\" /* ORDINAL_TIME */]: _ChartTheme.getAxisDefaults({\n    groupPaddingInner: 0,\n    label: { autoRotate: false },\n    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED }\n  }),\n  [\"angle-category\" /* ANGLE_CATEGORY */]: _ChartTheme.getAxisDefaults({\n    gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED }\n  }),\n  [\"angle-number\" /* ANGLE_NUMBER */]: _ChartTheme.getAxisDefaults({ gridLine: { enabled: DEFAULT_GRIDLINE_ENABLED } }),\n  [\"radius-category\" /* RADIUS_CATEGORY */]: _ChartTheme.getAxisDefaults({\n    line: { enabled: false }\n  }),\n  [\"radius-number\" /* RADIUS_NUMBER */]: _ChartTheme.getAxisDefaults({\n    line: { enabled: false }\n  }),\n  \"grouped-category\": _ChartTheme.getAxisDefaults({\n    tick: { enabled: true }\n  })\n};\nvar ChartTheme = _ChartTheme;\n\n// packages/ag-charts-community/src/chart/themes/darkTheme.ts\nvar DEFAULT_DARK_BACKGROUND_FILL = \"#192232\";\nvar DEFAULT_DARK_FILLS = {\n  BLUE: \"#5090dc\",\n  ORANGE: \"#ffa03a\",\n  GREEN: \"#459d55\",\n  CYAN: \"#34bfe1\",\n  YELLOW: \"#e1cc00\",\n  VIOLET: \"#9669cb\",\n  GRAY: \"#b5b5b5\",\n  MAGENTA: \"#bd5aa7\",\n  BROWN: \"#8a6224\",\n  RED: \"#ef5452\"\n};\nvar DEFAULT_DARK_STROKES = {\n  BLUE: \"#74a8e6\",\n  ORANGE: \"#ffbe70\",\n  GREEN: \"#6cb176\",\n  CYAN: \"#75d4ef\",\n  YELLOW: \"#f6e559\",\n  VIOLET: \"#aa86d8\",\n  GRAY: \"#a1a1a1\",\n  MAGENTA: \"#ce7ab9\",\n  BROWN: \"#997b52\",\n  RED: \"#ff7872\"\n};\nvar DarkTheme = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: DEFAULT_DARK_FILLS,\n      strokes: DEFAULT_DARK_STROKES,\n      up: { fill: DEFAULT_DARK_FILLS.GREEN, stroke: DEFAULT_DARK_STROKES.GREEN },\n      down: { fill: DEFAULT_DARK_FILLS.RED, stroke: DEFAULT_DARK_STROKES.RED },\n      neutral: { fill: DEFAULT_DARK_FILLS.GRAY, stroke: DEFAULT_DARK_STROKES.GRAY },\n      altUp: { fill: DEFAULT_DARK_FILLS.BLUE, stroke: DEFAULT_DARK_STROKES.BLUE },\n      altDown: { fill: DEFAULT_DARK_FILLS.ORANGE, stroke: DEFAULT_DARK_STROKES.ORANGE },\n      altNeutral: { fill: DEFAULT_DARK_FILLS.GRAY, stroke: DEFAULT_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(IS_DARK_THEME, true);\n    params.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_LABEL_COLOUR, \"white\");\n    params.set(DEFAULT_MUTED_LABEL_COLOUR, \"#7D91A0\");\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"#545A6E\");\n    params.set(DEFAULT_CROSS_LINES_COLOUR, \"white\");\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      DEFAULT_DARK_FILLS.ORANGE,\n      DEFAULT_DARK_FILLS.YELLOW,\n      DEFAULT_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_HIERARCHY_FILLS, [\"#192834\", \"#253746\", \"#324859\", \"#3f596c\", \"#4d6a80\"]);\n    params.set(DEFAULT_HIERARCHY_STROKES, [\"#192834\", \"#3b5164\", \"#496275\", \"#577287\", \"#668399\"]);\n    params.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_ANNOTATION_COLOR, DEFAULT_DARK_FILLS.BLUE);\n    params.set(DEFAULT_TEXT_ANNOTATION_COLOR, \"white\");\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, DEFAULT_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_HANDLE_FILL, DEFAULT_DARK_BACKGROUND_FILL);\n    params.set(DEFAULT_TEXTBOX_FILL, \"#28313e\");\n    params.set(DEFAULT_TEXTBOX_STROKE, \"#4b525d\");\n    params.set(DEFAULT_TEXTBOX_COLOR, \"#ffffff\");\n    return params;\n  }\n  constructor(options) {\n    super(options);\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/financialDark.ts\nvar FINANCIAL_DARK_FILLS = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#A9A9A9\"\n};\nvar FINANCIAL_DARK_STROKES = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#909090\"\n};\nvar FinancialDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...FINANCIAL_DARK_FILLS },\n      strokes: { ...FINANCIAL_DARK_STROKES },\n      up: { fill: FINANCIAL_DARK_FILLS.GREEN, stroke: FINANCIAL_DARK_STROKES.GREEN },\n      down: { fill: FINANCIAL_DARK_FILLS.RED, stroke: FINANCIAL_DARK_STROKES.RED },\n      neutral: { fill: FINANCIAL_DARK_FILLS.BLUE, stroke: FINANCIAL_DARK_STROKES.BLUE },\n      altUp: { fill: FINANCIAL_DARK_FILLS.GREEN, stroke: FINANCIAL_DARK_STROKES.GREEN },\n      altDown: { fill: FINANCIAL_DARK_FILLS.RED, stroke: FINANCIAL_DARK_STROKES.RED },\n      altNeutral: { fill: FINANCIAL_DARK_FILLS.GRAY, stroke: FINANCIAL_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      FINANCIAL_DARK_FILLS.GREEN,\n      FINANCIAL_DARK_FILLS.BLUE,\n      FINANCIAL_DARK_FILLS.RED\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, FINANCIAL_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, FINANCIAL_DARK_FILLS.BLUE);\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"#343A4E\");\n    params.set(DEFAULT_PADDING, 0);\n    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, \"overlay\");\n    params.set(DEFAULT_CAPTION_ALIGNMENT, \"left\");\n    params.set(DEFAULT_TOOLBAR_POSITION, \"bottom\");\n    params.set(DEFAULT_GRIDLINE_ENABLED, true);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/financialLight.ts\nvar FINANCIAL_LIGHT_FILLS = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#A9A9A9\"\n};\nvar FINANCIAL_LIGHT_STROKES = {\n  GREEN: \"#089981\",\n  RED: \"#F23645\",\n  BLUE: \"#5090dc\",\n  GRAY: \"#909090\"\n};\nvar FinancialLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...FINANCIAL_LIGHT_FILLS },\n      strokes: { ...FINANCIAL_LIGHT_STROKES },\n      up: { fill: FINANCIAL_LIGHT_FILLS.GREEN, stroke: FINANCIAL_LIGHT_STROKES.GREEN },\n      down: { fill: FINANCIAL_LIGHT_FILLS.RED, stroke: FINANCIAL_LIGHT_STROKES.RED },\n      neutral: { fill: FINANCIAL_LIGHT_FILLS.BLUE, stroke: FINANCIAL_LIGHT_STROKES.BLUE },\n      altUp: { fill: FINANCIAL_LIGHT_FILLS.GREEN, stroke: FINANCIAL_LIGHT_STROKES.GREEN },\n      altDown: { fill: FINANCIAL_LIGHT_FILLS.RED, stroke: FINANCIAL_LIGHT_STROKES.RED },\n      altNeutral: { fill: FINANCIAL_LIGHT_FILLS.GRAY, stroke: FINANCIAL_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      FINANCIAL_LIGHT_FILLS.GREEN,\n      FINANCIAL_LIGHT_FILLS.BLUE,\n      FINANCIAL_LIGHT_FILLS.RED\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, FINANCIAL_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, FINANCIAL_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_AXIS_GRID_COLOUR, \"#F2F3F3\");\n    params.set(DEFAULT_PADDING, 0);\n    params.set(DEFAULT_CAPTION_LAYOUT_STYLE, \"overlay\");\n    params.set(DEFAULT_CAPTION_ALIGNMENT, \"left\");\n    params.set(DEFAULT_TOOLBAR_POSITION, \"bottom\");\n    params.set(DEFAULT_GRIDLINE_ENABLED, true);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/materialDark.ts\nvar MATERIAL_DARK_FILLS = {\n  BLUE: \"#2196F3\",\n  ORANGE: \"#FF9800\",\n  GREEN: \"#4CAF50\",\n  CYAN: \"#00BCD4\",\n  YELLOW: \"#FFEB3B\",\n  VIOLET: \"#7E57C2\",\n  GRAY: \"#9E9E9E\",\n  MAGENTA: \"#F06292\",\n  BROWN: \"#795548\",\n  RED: \"#F44336\"\n};\nvar MATERIAL_DARK_STROKES = {\n  BLUE: \"#90CAF9\",\n  ORANGE: \"#FFCC80\",\n  GREEN: \"#A5D6A7\",\n  CYAN: \"#80DEEA\",\n  YELLOW: \"#FFF9C4\",\n  VIOLET: \"#B39DDB\",\n  GRAY: \"#E0E0E0\",\n  MAGENTA: \"#F48FB1\",\n  BROWN: \"#A1887F\",\n  RED: \"#EF9A9A\"\n};\nvar MaterialDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: MATERIAL_DARK_FILLS,\n      strokes: MATERIAL_DARK_STROKES,\n      up: { fill: MATERIAL_DARK_FILLS.GREEN, stroke: MATERIAL_DARK_STROKES.GREEN },\n      down: { fill: MATERIAL_DARK_FILLS.RED, stroke: MATERIAL_DARK_STROKES.RED },\n      neutral: { fill: MATERIAL_DARK_FILLS.GRAY, stroke: MATERIAL_DARK_STROKES.GRAY },\n      altUp: { fill: MATERIAL_DARK_FILLS.BLUE, stroke: MATERIAL_DARK_STROKES.BLUE },\n      altDown: { fill: MATERIAL_DARK_FILLS.RED, stroke: MATERIAL_DARK_STROKES.RED },\n      altNeutral: { fill: MATERIAL_DARK_FILLS.GRAY, stroke: MATERIAL_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      MATERIAL_DARK_FILLS.ORANGE,\n      MATERIAL_DARK_FILLS.YELLOW,\n      MATERIAL_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, MATERIAL_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, MATERIAL_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/materialLight.ts\nvar MATERIAL_LIGHT_FILLS = {\n  BLUE: \"#2196F3\",\n  ORANGE: \"#FF9800\",\n  GREEN: \"#4CAF50\",\n  CYAN: \"#00BCD4\",\n  YELLOW: \"#FFEB3B\",\n  VIOLET: \"#7E57C2\",\n  GRAY: \"#9E9E9E\",\n  MAGENTA: \"#F06292\",\n  BROWN: \"#795548\",\n  RED: \"#F44336\"\n};\nvar MATERIAL_LIGHT_STROKES = {\n  BLUE: \"#1565C0\",\n  ORANGE: \"#E65100\",\n  GREEN: \"#2E7D32\",\n  CYAN: \"#00838F\",\n  YELLOW: \"#F9A825\",\n  VIOLET: \"#4527A0\",\n  GRAY: \"#616161\",\n  MAGENTA: \"#C2185B\",\n  BROWN: \"#4E342E\",\n  RED: \"#B71C1C\"\n};\nvar MaterialLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: MATERIAL_LIGHT_FILLS,\n      strokes: MATERIAL_LIGHT_STROKES,\n      up: { fill: MATERIAL_LIGHT_FILLS.GREEN, stroke: MATERIAL_LIGHT_STROKES.GREEN },\n      down: { fill: MATERIAL_LIGHT_FILLS.RED, stroke: MATERIAL_LIGHT_STROKES.RED },\n      neutral: { fill: MATERIAL_LIGHT_FILLS.GRAY, stroke: MATERIAL_LIGHT_STROKES.GRAY },\n      altUp: { fill: MATERIAL_LIGHT_FILLS.BLUE, stroke: MATERIAL_LIGHT_STROKES.BLUE },\n      altDown: { fill: MATERIAL_LIGHT_FILLS.RED, stroke: MATERIAL_LIGHT_STROKES.RED },\n      altNeutral: { fill: MATERIAL_LIGHT_FILLS.GRAY, stroke: MATERIAL_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      MATERIAL_LIGHT_FILLS.ORANGE,\n      MATERIAL_LIGHT_FILLS.YELLOW,\n      MATERIAL_LIGHT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, MATERIAL_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, MATERIAL_LIGHT_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/polychromaDark.ts\nvar POLYCHROMA_DARK_FILLS = {\n  BLUE: \"#436ff4\",\n  PURPLE: \"#9a7bff\",\n  MAGENTA: \"#d165d2\",\n  PINK: \"#f0598b\",\n  RED: \"#f47348\",\n  ORANGE: \"#f2a602\",\n  YELLOW: \"#e9e201\",\n  GREEN: \"#21b448\",\n  CYAN: \"#00b9a2\",\n  MODERATE_BLUE: \"#00aee4\",\n  GRAY: \"#bbbbbb\"\n};\nvar POLYCHROMA_DARK_STROKES = {\n  BLUE: \"#6698ff\",\n  PURPLE: \"#c0a3ff\",\n  MAGENTA: \"#fc8dfc\",\n  PINK: \"#ff82b1\",\n  RED: \"#ff9b70\",\n  ORANGE: \"#ffcf4e\",\n  YELLOW: \"#ffff58\",\n  GREEN: \"#58dd70\",\n  CYAN: \"#51e2c9\",\n  MODERATE_BLUE: \"#4fd7ff\",\n  GRAY: \"#eeeeee\"\n};\nvar PolychromaDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: POLYCHROMA_DARK_FILLS,\n      strokes: POLYCHROMA_DARK_STROKES,\n      up: { fill: POLYCHROMA_DARK_FILLS.GREEN, stroke: POLYCHROMA_DARK_STROKES.GREEN },\n      down: { fill: POLYCHROMA_DARK_FILLS.RED, stroke: POLYCHROMA_DARK_STROKES.RED },\n      neutral: { fill: POLYCHROMA_DARK_FILLS.GRAY, stroke: POLYCHROMA_DARK_STROKES.GRAY },\n      altUp: { fill: POLYCHROMA_DARK_FILLS.BLUE, stroke: POLYCHROMA_DARK_STROKES.BLUE },\n      altDown: { fill: POLYCHROMA_DARK_FILLS.RED, stroke: POLYCHROMA_DARK_STROKES.RED },\n      altNeutral: { fill: POLYCHROMA_DARK_FILLS.GRAY, stroke: POLYCHROMA_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [POLYCHROMA_DARK_FILLS.BLUE, POLYCHROMA_DARK_FILLS.RED]);\n    params.set(DEFAULT_ANNOTATION_COLOR, POLYCHROMA_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, POLYCHROMA_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/polychromaLight.ts\nvar POLYCHROMA_LIGHT_FILLS = {\n  BLUE: \"#436ff4\",\n  PURPLE: \"#9a7bff\",\n  MAGENTA: \"#d165d2\",\n  PINK: \"#f0598b\",\n  RED: \"#f47348\",\n  ORANGE: \"#f2a602\",\n  YELLOW: \"#e9e201\",\n  GREEN: \"#21b448\",\n  CYAN: \"#00b9a2\",\n  MODERATE_BLUE: \"#00aee4\",\n  GRAY: \"#bbbbbb\"\n};\nvar POLYCHROMA_LIGHT_STROKES = {\n  BLUE: \"#2346c9\",\n  PURPLE: \"#7653d4\",\n  MAGENTA: \"#a73da9\",\n  PINK: \"#c32d66\",\n  RED: \"#c84b1c\",\n  ORANGE: \"#c87f00\",\n  YELLOW: \"#c1b900\",\n  GREEN: \"#008c1c\",\n  CYAN: \"#00927c\",\n  MODERATE_BLUE: \"#0087bb\",\n  GRAY: \"#888888\"\n};\nvar PolychromaLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: POLYCHROMA_LIGHT_FILLS,\n      strokes: POLYCHROMA_LIGHT_STROKES,\n      up: { fill: POLYCHROMA_LIGHT_FILLS.GREEN, stroke: POLYCHROMA_LIGHT_STROKES.GREEN },\n      down: { fill: POLYCHROMA_LIGHT_FILLS.RED, stroke: POLYCHROMA_LIGHT_STROKES.RED },\n      neutral: { fill: POLYCHROMA_LIGHT_FILLS.GRAY, stroke: POLYCHROMA_LIGHT_STROKES.GRAY },\n      altUp: { fill: POLYCHROMA_LIGHT_FILLS.BLUE, stroke: POLYCHROMA_LIGHT_STROKES.BLUE },\n      altDown: { fill: POLYCHROMA_LIGHT_FILLS.RED, stroke: POLYCHROMA_LIGHT_STROKES.RED },\n      altNeutral: { fill: POLYCHROMA_LIGHT_FILLS.GRAY, stroke: POLYCHROMA_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [POLYCHROMA_LIGHT_FILLS.BLUE, POLYCHROMA_LIGHT_FILLS.RED]);\n    params.set(DEFAULT_ANNOTATION_COLOR, POLYCHROMA_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, POLYCHROMA_LIGHT_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/sheetsDark.ts\nvar SHEETS_DARK_FILLS = {\n  BLUE: \"#4472C4\",\n  ORANGE: \"#ED7D31\",\n  GRAY: \"#A5A5A5\",\n  YELLOW: \"#FFC000\",\n  MODERATE_BLUE: \"#5B9BD5\",\n  GREEN: \"#70AD47\",\n  DARK_GRAY: \"#7B7B7B\",\n  DARK_BLUE: \"#264478\",\n  VERY_DARK_GRAY: \"#636363\",\n  DARK_YELLOW: \"#997300\"\n};\nvar SHEETS_DARK_STROKES = {\n  BLUE: \"#6899ee\",\n  ORANGE: \"#ffa55d\",\n  GRAY: \"#cdcdcd\",\n  YELLOW: \"#ffea53\",\n  MODERATE_BLUE: \"#82c3ff\",\n  GREEN: \"#96d56f\",\n  DARK_GRAY: \"#a1a1a1\",\n  DARK_BLUE: \"#47689f\",\n  VERY_DARK_GRAY: \"#878787\",\n  DARK_YELLOW: \"#c0993d\"\n};\nvar SheetsDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...SHEETS_DARK_FILLS, RED: SHEETS_DARK_FILLS.ORANGE },\n      strokes: { ...SHEETS_DARK_STROKES, RED: SHEETS_DARK_STROKES.ORANGE },\n      up: { fill: SHEETS_DARK_FILLS.GREEN, stroke: SHEETS_DARK_STROKES.GREEN },\n      down: { fill: SHEETS_DARK_FILLS.ORANGE, stroke: SHEETS_DARK_STROKES.ORANGE },\n      neutral: { fill: SHEETS_DARK_FILLS.GRAY, stroke: SHEETS_DARK_STROKES.GRAY },\n      altUp: { fill: SHEETS_DARK_FILLS.BLUE, stroke: SHEETS_DARK_STROKES.BLUE },\n      altDown: { fill: SHEETS_DARK_FILLS.ORANGE, stroke: SHEETS_DARK_STROKES.ORANGE },\n      altNeutral: { fill: SHEETS_DARK_FILLS.GRAY, stroke: SHEETS_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      SHEETS_DARK_FILLS.ORANGE,\n      SHEETS_DARK_FILLS.YELLOW,\n      SHEETS_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, SHEETS_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, SHEETS_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/sheetsLight.ts\nvar SHEETS_LIGHT_FILLS = {\n  BLUE: \"#5281d5\",\n  ORANGE: \"#ff8d44\",\n  GRAY: \"#b5b5b5\",\n  YELLOW: \"#ffd02f\",\n  MODERATE_BLUE: \"#6aabe6\",\n  GREEN: \"#7fbd57\",\n  DARK_GRAY: \"#8a8a8a\",\n  DARK_BLUE: \"#335287\",\n  VERY_DARK_GRAY: \"#717171\",\n  DARK_YELLOW: \"#a98220\"\n};\nvar SHEETS_LIGHT_STROKES = {\n  BLUE: \"#214d9b\",\n  ORANGE: \"#c25600\",\n  GRAY: \"#7f7f7f\",\n  YELLOW: \"#d59800\",\n  MODERATE_BLUE: \"#3575ac\",\n  GREEN: \"#4b861a\",\n  DARK_GRAY: \"#575757\",\n  DARK_BLUE: \"#062253\",\n  VERY_DARK_GRAY: \"#414141\",\n  DARK_YELLOW: \"#734f00\"\n};\nvar SheetsLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: { ...SHEETS_LIGHT_FILLS, RED: SHEETS_LIGHT_FILLS.ORANGE },\n      strokes: { ...SHEETS_LIGHT_STROKES, RED: SHEETS_LIGHT_STROKES.ORANGE },\n      up: { fill: SHEETS_LIGHT_FILLS.GREEN, stroke: SHEETS_LIGHT_STROKES.GREEN },\n      down: { fill: SHEETS_LIGHT_FILLS.ORANGE, stroke: SHEETS_LIGHT_STROKES.ORANGE },\n      neutral: { fill: SHEETS_LIGHT_STROKES.GRAY, stroke: SHEETS_LIGHT_STROKES.GRAY },\n      altUp: { fill: SHEETS_LIGHT_FILLS.BLUE, stroke: SHEETS_LIGHT_STROKES.BLUE },\n      altDown: { fill: SHEETS_LIGHT_FILLS.ORANGE, stroke: SHEETS_LIGHT_STROKES.ORANGE },\n      altNeutral: { fill: SHEETS_LIGHT_FILLS.GRAY, stroke: SHEETS_LIGHT_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      SHEETS_LIGHT_FILLS.ORANGE,\n      SHEETS_LIGHT_FILLS.YELLOW,\n      SHEETS_LIGHT_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, SHEETS_LIGHT_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, SHEETS_LIGHT_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/vividDark.ts\nvar VIVID_DARK_FILLS = {\n  BLUE: \"#0083ff\",\n  ORANGE: \"#ff6600\",\n  GREEN: \"#00af00\",\n  CYAN: \"#00ccff\",\n  YELLOW: \"#f7c700\",\n  VIOLET: \"#ac26ff\",\n  GRAY: \"#a7a7b7\",\n  MAGENTA: \"#e800c5\",\n  BROWN: \"#b54300\",\n  RED: \"#ff0000\"\n};\nvar VIVID_DARK_STROKES = {\n  BLUE: \"#67b7ff\",\n  ORANGE: \"#ffc24d\",\n  GREEN: \"#5cc86f\",\n  CYAN: \"#54ebff\",\n  VIOLET: \"#fff653\",\n  YELLOW: \"#c18aff\",\n  GRAY: \"#aeaeae\",\n  MAGENTA: \"#f078d4\",\n  BROWN: \"#ba8438\",\n  RED: \"#ff726e\"\n};\nvar VividDark = class extends DarkTheme {\n  getDefaultColors() {\n    return {\n      fills: VIVID_DARK_FILLS,\n      strokes: VIVID_DARK_STROKES,\n      up: { fill: VIVID_DARK_FILLS.GREEN, stroke: VIVID_DARK_STROKES.GREEN },\n      down: { fill: VIVID_DARK_FILLS.RED, stroke: VIVID_DARK_STROKES.RED },\n      neutral: { fill: VIVID_DARK_FILLS.GRAY, stroke: VIVID_DARK_STROKES.GRAY },\n      altUp: { fill: VIVID_DARK_FILLS.BLUE, stroke: VIVID_DARK_STROKES.BLUE },\n      altDown: { fill: VIVID_DARK_FILLS.ORANGE, stroke: VIVID_DARK_STROKES.ORANGE },\n      altNeutral: { fill: VIVID_DARK_FILLS.GRAY, stroke: VIVID_DARK_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\n      VIVID_DARK_FILLS.ORANGE,\n      VIVID_DARK_FILLS.YELLOW,\n      VIVID_DARK_FILLS.GREEN\n    ]);\n    params.set(DEFAULT_ANNOTATION_COLOR, VIVID_DARK_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, VIVID_DARK_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/themes/vividLight.ts\nvar VIVID_FILLS = {\n  BLUE: \"#0083ff\",\n  ORANGE: \"#ff6600\",\n  GREEN: \"#00af00\",\n  CYAN: \"#00ccff\",\n  YELLOW: \"#f7c700\",\n  VIOLET: \"#ac26ff\",\n  GRAY: \"#a7a7b7\",\n  MAGENTA: \"#e800c5\",\n  BROWN: \"#b54300\",\n  RED: \"#ff0000\"\n};\nvar VIVID_STROKES = {\n  BLUE: \"#0f68c0\",\n  ORANGE: \"#d47100\",\n  GREEN: \"#007922\",\n  CYAN: \"#009ac2\",\n  VIOLET: \"#bca400\",\n  YELLOW: \"#753cac\",\n  GRAY: \"#646464\",\n  MAGENTA: \"#9b2685\",\n  BROWN: \"#6c3b00\",\n  RED: \"#cb0021\"\n};\nvar VividLight = class extends ChartTheme {\n  getDefaultColors() {\n    return {\n      fills: VIVID_FILLS,\n      strokes: VIVID_STROKES,\n      up: { fill: VIVID_FILLS.GREEN, stroke: VIVID_STROKES.GREEN },\n      down: { fill: VIVID_FILLS.RED, stroke: VIVID_STROKES.RED },\n      neutral: { fill: VIVID_FILLS.GRAY, stroke: VIVID_STROKES.GRAY },\n      altUp: { fill: VIVID_FILLS.BLUE, stroke: VIVID_STROKES.BLUE },\n      altDown: { fill: VIVID_FILLS.ORANGE, stroke: VIVID_STROKES.ORANGE },\n      altNeutral: { fill: VIVID_FILLS.GRAY, stroke: VIVID_STROKES.GRAY }\n    };\n  }\n  getTemplateParameters() {\n    const params = super.getTemplateParameters();\n    params.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [VIVID_FILLS.ORANGE, VIVID_FILLS.YELLOW, VIVID_FILLS.GREEN]);\n    params.set(DEFAULT_ANNOTATION_COLOR, VIVID_FILLS.BLUE);\n    params.set(DEFAULT_ANNOTATION_BACKGROUND_FILL, VIVID_FILLS.BLUE);\n    return params;\n  }\n};\n\n// packages/ag-charts-community/src/chart/mapping/themes.ts\nvar lightTheme = () => new ChartTheme();\nvar darkTheme = () => new DarkTheme();\nvar themes = {\n  // darkThemes,\n  \"ag-default-dark\": darkTheme,\n  \"ag-sheets-dark\": () => new SheetsDark(),\n  \"ag-polychroma-dark\": () => new PolychromaDark(),\n  \"ag-vivid-dark\": () => new VividDark(),\n  \"ag-material-dark\": () => new MaterialDark(),\n  \"ag-financial-dark\": () => new FinancialDark(),\n  // lightThemes,\n  null: lightTheme,\n  undefined: lightTheme,\n  \"ag-default\": lightTheme,\n  \"ag-sheets\": () => new SheetsLight(),\n  \"ag-polychroma\": () => new PolychromaLight(),\n  \"ag-vivid\": () => new VividLight(),\n  \"ag-material\": () => new MaterialLight(),\n  \"ag-financial\": () => new FinancialLight()\n};\nfunction getChartTheme(value) {\n  if (value instanceof ChartTheme) {\n    return value;\n  }\n  if (value == null || typeof value === \"string\") {\n    const stockTheme = themes[value];\n    if (stockTheme) {\n      return stockTheme();\n    }\n    Logger.warnOnce(`the theme [${value}] is invalid, using [ag-default] instead.`);\n    return lightTheme();\n  }\n  if (isValid(value, themeOptionsDef, \"theme\")) {\n    const flattenedTheme = reduceThemeOptions(value);\n    const baseTheme = flattenedTheme.baseTheme ? getChartTheme(flattenedTheme.baseTheme) : lightTheme();\n    return new baseTheme.constructor(flattenedTheme);\n  }\n  return lightTheme();\n}\nfunction reduceThemeOptions(options) {\n  let maybeNested = options;\n  let palette;\n  const overrides = [];\n  while (typeof maybeNested === \"object\") {\n    palette ?? (palette = maybeNested.palette);\n    if (maybeNested.overrides) {\n      overrides.push(maybeNested.overrides);\n    }\n    maybeNested = maybeNested.baseTheme;\n  }\n  return {\n    baseTheme: maybeNested,\n    overrides: mergeDefaults(...overrides),\n    palette\n  };\n}\nvar themeOptionsDef = {\n  baseTheme: or(string, object),\n  overrides: object,\n  palette: {\n    fills: arrayOf(string),\n    strokes: arrayOf(string),\n    up: { fill: string, stroke: string },\n    down: { fill: string, stroke: string },\n    neutral: { fill: string, stroke: string }\n  }\n};\n\n// packages/ag-charts-community/src/module/optionsModule.ts\nvar unthemedSeries = /* @__PURE__ */ new Set([\"map-shape-background\", \"map-line-background\"]);\nvar ChartOptions = class {\n  constructor(userOptions, specialOverrides) {\n    this.debug = Debug.create(true, \"opts\");\n    var _a;\n    const cloneOptions = { shallow: [\"data\"] };\n    userOptions = deepClone(userOptions, cloneOptions);\n    const chartType2 = this.optionsType(userOptions);\n    if (!enterpriseModule.isEnterprise) {\n      removeUsedEnterpriseOptions(userOptions);\n    }\n    let options = deepClone(userOptions, cloneOptions);\n    this.type = specialOverrides?.type;\n    if (this.type != null) {\n      const presetOptions = PRESETS[this.type]?.(options, () => this.activeTheme) ?? options;\n      this.debug(\">>> AgCharts.createOrUpdate() - applying preset\", options, presetOptions);\n      options = presetOptions;\n    }\n    this.activeTheme = getChartTheme(options.theme);\n    if (this.type) {\n      options = this.activeTheme.templateTheme(options);\n    }\n    this.sanityCheckAndCleanup(options);\n    this.defaultAxes = this.getDefaultAxes(options);\n    this.specialOverrides = this.specialOverridesDefaults({ ...specialOverrides });\n    const {\n      axes: axesThemes = {},\n      annotations: { axesButtons = null, ...annotationsThemes } = {},\n      series: _,\n      ...themeDefaults\n    } = this.getSeriesThemeConfig(chartType2);\n    this.userOptions = userOptions;\n    this.processedOptions = deepClone(\n      mergeDefaults(\n        options,\n        axesButtons != null ? { annotations: { axesButtons } } : {},\n        themeDefaults,\n        this.defaultAxes\n      ),\n      cloneOptions\n    );\n    this.processAxesOptions(this.processedOptions, axesThemes);\n    this.processSeriesOptions(this.processedOptions);\n    this.processMiniChartSeriesOptions(this.processedOptions);\n    this.annotationThemes = annotationsThemes;\n    if ((isAgCartesianChartOptions(this.processedOptions) || isAgPolarChartOptionsWithSeriesBasedLegend(this.processedOptions)) && this.processedOptions.legend?.enabled == null) {\n      (_a = this.processedOptions).legend ?? (_a.legend = {});\n      this.processedOptions.legend.enabled = this.processedOptions.series.length > 1;\n    }\n    this.enableConfiguredOptions(this.processedOptions);\n    if (!enterpriseModule.isEnterprise) {\n      removeUsedEnterpriseOptions(this.processedOptions, true);\n    }\n  }\n  getOptions() {\n    return this.processedOptions ?? {};\n  }\n  diffOptions(options) {\n    return jsonDiff(options, this.processedOptions);\n  }\n  getSeriesThemeConfig(seriesType2) {\n    const themeConfig = deepClone(this.activeTheme?.config[seriesType2] ?? {});\n    this.removeLeftoverSymbols(themeConfig);\n    return themeConfig;\n  }\n  getDefaultAxes(options) {\n    const optionsType2 = this.optionsType(options);\n    const axesDefaults = seriesRegistry.cloneDefaultAxes(optionsType2);\n    if (seriesRegistry.isDefaultAxisSwapNeeded(options)) {\n      this.swapAxesPosition(axesDefaults);\n    }\n    return axesDefaults;\n  }\n  optionsType(options) {\n    return options.series?.[0]?.type ?? \"line\";\n  }\n  sanityCheckAndCleanup(options) {\n    this.deprecationWarnings(options);\n    this.axesTypeIntegrity(options);\n    this.seriesTypeIntegrity(options);\n    this.soloSeriesIntegrity(options);\n    this.removeDisabledOptions(options);\n    this.removeLeftoverSymbols(options);\n    if (options.series?.some((s) => s.type === \"bullet\") && options.sync != null && options.sync.enabled !== false) {\n      Logger.warnOnce(\"bullet series cannot be synced, disabling synchronization.\");\n      delete options.sync;\n    }\n  }\n  swapAxesPosition(options) {\n    if (isAgCartesianChartOptions(options)) {\n      const [axis0, axis1] = options.axes ?? [];\n      options.axes = [\n        { ...axis0, position: axis1.position },\n        { ...axis1, position: axis0.position }\n      ];\n    }\n  }\n  processAxesOptions(options, axesThemes) {\n    if (!(\"axes\" in options))\n      return;\n    options.axes = options.axes.map((axis) => {\n      const { crossLines: crossLinesTheme, ...axisTheme } = mergeDefaults(\n        axesThemes[axis.type]?.[axis.position],\n        axesThemes[axis.type]\n      );\n      if (axis.crossLines) {\n        axis.crossLines = mergeArrayDefaults(axis.crossLines, crossLinesTheme);\n      }\n      const gridLineStyle = axisTheme.gridLine?.style;\n      if (axis.gridLine?.style && gridLineStyle?.length) {\n        axis.gridLine.style = axis.gridLine.style.map(\n          (style, index) => style.stroke != null || style.lineDash != null ? mergeDefaults(style, gridLineStyle.at(index % gridLineStyle.length)) : style\n        );\n      }\n      const { top: _1, right: _2, bottom: _3, left: _4, ...axisOptions } = mergeDefaults(axis, axisTheme);\n      return axisOptions;\n    });\n  }\n  processSeriesOptions(options) {\n    const defaultSeriesType = this.getDefaultSeriesType(options);\n    const defaultTooltipPosition = this.getTooltipPositionDefaults(options);\n    const userPalette = isObject(options.theme) ? paletteType(options.theme?.palette) : \"inbuilt\";\n    const paletteOptions = {\n      colourIndex: 0,\n      userPalette\n    };\n    const processedSeries = options.series?.map((series) => {\n      series.type ?? (series.type = defaultSeriesType);\n      const { innerLabels: innerLabelsTheme, ...seriesTheme } = this.getSeriesThemeConfig(series.type).series ?? {};\n      const seriesPaletteOptions = unthemedSeries.has(series.type) ? { colourIndex: 0, userPalette } : paletteOptions;\n      const palette = this.getSeriesPalette(series.type, seriesPaletteOptions);\n      const defaultTooltipRange = this.getTooltipRangeDefaults(options, series.type);\n      const seriesOptions = mergeDefaults(\n        this.getSeriesGroupingOptions(series),\n        series,\n        defaultTooltipPosition,\n        defaultTooltipRange,\n        seriesTheme,\n        palette,\n        { visible: true }\n      );\n      if (seriesOptions.innerLabels) {\n        seriesOptions.innerLabels = mergeArrayDefaults(seriesOptions.innerLabels, innerLabelsTheme);\n      }\n      return this.activeTheme.templateTheme(seriesOptions);\n    });\n    options.series = this.setSeriesGroupingOptions(processedSeries ?? []);\n  }\n  processMiniChartSeriesOptions(options) {\n    let miniChartSeries = options.navigator?.miniChart?.series;\n    if (miniChartSeries == null)\n      return;\n    const paletteOptions = {\n      colourIndex: 0,\n      userPalette: isObject(options.theme) ? paletteType(options.theme.palette) : \"inbuilt\"\n    };\n    miniChartSeries = miniChartSeries.map((series) => {\n      series.type ?? (series.type = \"line\");\n      const { innerLabels: _, ...seriesTheme } = this.getSeriesThemeConfig(series.type).series ?? {};\n      const seriesOptions = mergeDefaults(\n        this.getSeriesGroupingOptions(series),\n        series,\n        seriesTheme,\n        this.getSeriesPalette(series.type, paletteOptions)\n      );\n      return this.activeTheme.templateTheme(seriesOptions);\n    });\n    options.navigator.miniChart.series = this.setSeriesGroupingOptions(miniChartSeries);\n  }\n  getSeriesPalette(seriesType2, options) {\n    const paletteFactory = seriesRegistry.getPaletteFactory(seriesType2);\n    const { colourIndex: colourOffset, userPalette } = options;\n    const { fills = [], strokes = [] } = this.activeTheme.palette;\n    return paletteFactory?.({\n      userPalette,\n      colorsCount: Math.max(fills.length, strokes.length),\n      themeTemplateParameters: this.activeTheme.getTemplateParameters(),\n      palette: this.activeTheme.palette,\n      takeColors(count) {\n        options.colourIndex += count;\n        return {\n          fills: circularSliceArray(fills, count, colourOffset),\n          strokes: circularSliceArray(strokes, count, colourOffset)\n        };\n      }\n    });\n  }\n  getSeriesGroupingOptions(series) {\n    const groupable = seriesRegistry.isGroupable(series.type);\n    const stackable = seriesRegistry.isStackable(series.type);\n    const stackedByDefault = seriesRegistry.isStackedByDefault(series.type);\n    if (series.grouped && !groupable) {\n      Logger.warnOnce(`unsupported grouping of series type \"${series.type}\".`);\n    }\n    if ((series.stacked || series.stackGroup) && !stackable) {\n      Logger.warnOnce(`unsupported stacking of series type \"${series.type}\".`);\n    }\n    let { grouped, stacked } = series;\n    stacked ?? (stacked = (stackedByDefault || series.stackGroup != null) && !(groupable && grouped));\n    grouped ?? (grouped = true);\n    return {\n      stacked: stackable && stacked,\n      grouped: groupable && grouped && !(stackable && stacked)\n    };\n  }\n  setSeriesGroupingOptions(allSeries) {\n    const seriesGroups = this.getSeriesGrouping(allSeries);\n    this.debug(\"setSeriesGroupingOptions() - series grouping: \", seriesGroups);\n    const groupIdx = {};\n    const groupCount2 = seriesGroups.reduce((countMap, seriesGroup) => {\n      var _a;\n      if (seriesGroup.groupType === \"default\" /* DEFAULT */) {\n        return countMap;\n      }\n      countMap[_a = seriesGroup.seriesType] ?? (countMap[_a] = 0);\n      countMap[seriesGroup.seriesType] += seriesGroup.groupType === \"stack\" /* STACK */ ? 1 : seriesGroup.series.length;\n      return countMap;\n    }, {});\n    return seriesGroups.flatMap((seriesGroup) => {\n      var _a;\n      groupIdx[_a = seriesGroup.seriesType] ?? (groupIdx[_a] = 0);\n      switch (seriesGroup.groupType) {\n        case \"stack\" /* STACK */:\n          const groupIndex = groupIdx[seriesGroup.seriesType]++;\n          return seriesGroup.series.map(\n            (series, stackIndex) => Object.assign(series, {\n              seriesGrouping: {\n                groupId: seriesGroup.groupId,\n                groupIndex,\n                groupCount: groupCount2[seriesGroup.seriesType],\n                stackIndex,\n                stackCount: seriesGroup.series.length\n              }\n            })\n          );\n        case \"group\" /* GROUP */:\n          return seriesGroup.series.map(\n            (series) => Object.assign(series, {\n              seriesGrouping: {\n                groupId: seriesGroup.groupId,\n                groupIndex: groupIdx[seriesGroup.seriesType]++,\n                groupCount: groupCount2[seriesGroup.seriesType],\n                stackIndex: 0,\n                stackCount: 0\n              }\n            })\n          );\n      }\n      return seriesGroup.series;\n    }).map(({ stacked: _, grouped: __, ...seriesOptions }) => seriesOptions);\n  }\n  getSeriesGroupId(series) {\n    return [series.type, series.xKey, series.stacked ? series.stackGroup ?? \"stacked\" : \"grouped\"].filter(Boolean).join(\"-\");\n  }\n  getSeriesGrouping(allSeries) {\n    const groupMap = /* @__PURE__ */ new Map();\n    return allSeries.reduce((result, series) => {\n      const seriesType2 = series.type;\n      if (!series.stacked && !series.grouped) {\n        result.push({ groupType: \"default\" /* DEFAULT */, seriesType: seriesType2, series: [series], groupId: \"__default__\" });\n      } else {\n        const groupId = this.getSeriesGroupId(series);\n        if (!groupMap.has(groupId)) {\n          const groupType = series.stacked ? \"stack\" /* STACK */ : \"group\" /* GROUP */;\n          const record = { groupType, seriesType: seriesType2, series: [], groupId };\n          groupMap.set(groupId, record);\n          result.push(record);\n        }\n        groupMap.get(groupId).series.push(series);\n      }\n      return result;\n    }, []);\n  }\n  getDefaultSeriesType(options) {\n    if (isAgCartesianChartOptions(options)) {\n      return \"line\";\n    } else if (isAgPolarChartOptions(options)) {\n      return \"pie\";\n    } else if (isAgHierarchyChartOptions(options)) {\n      return \"treemap\";\n    } else if (isAgTopologyChartOptions(options)) {\n      return \"map-shape\";\n    } else if (isAgFlowProportionChartOptions(options)) {\n      return \"sankey\";\n    }\n    throw new Error(\"Invalid chart options type detected.\");\n  }\n  getTooltipPositionDefaults(options) {\n    const position = options.tooltip?.position;\n    if (!isPlainObject(position)) {\n      return;\n    }\n    const { type, xOffset, yOffset } = position;\n    const result = {};\n    if (isString(type) && isEnumValue(AgTooltipPositionType, type)) {\n      result.type = type;\n    }\n    if (isFiniteNumber(xOffset)) {\n      result.xOffset = xOffset;\n    }\n    if (isFiniteNumber(yOffset)) {\n      result.yOffset = yOffset;\n    }\n    return { tooltip: { position: result } };\n  }\n  // AG-11591 Support for new series-specific & legacy chart-global 'tooltip.range' options\n  //\n  // The `chart.series[].tooltip.range` option is a bit different for legacy reason. This use to be\n  // global option (`chart.tooltip.range`) that could override the theme. But now, the tooltip range\n  // option is series-specific.\n  //\n  // To preserve backward compatiblity, the `chart.tooltip.range` theme default has been changed from\n  // 'nearest' to undefined.\n  getTooltipRangeDefaults(options, seriesType2) {\n    return {\n      tooltip: {\n        range: options.tooltip?.range ?? seriesRegistry.getTooltipDefauls(seriesType2)?.range\n      }\n    };\n  }\n  deprecationWarnings(options) {\n    const deprecatedArrayProps = { yKeys: \"yKey\", yNames: \"yName\" };\n    Object.entries(deprecatedArrayProps).forEach(([oldProp, newProp]) => {\n      if (options.series?.some((s) => s[oldProp] != null)) {\n        Logger.warnOnce(\n          `Property [series.${oldProp}] is deprecated, please use [series.${newProp}] and multiple series instead.`\n        );\n      }\n    });\n  }\n  axesTypeIntegrity(options) {\n    if (\"axes\" in options) {\n      const axes = options.axes ?? [];\n      for (const { type } of axes) {\n        if (!isAxisOptionType(type)) {\n          delete options.axes;\n          const expectedTypes = axisRegistry.publicKeys().join(\", \");\n          Logger.warnOnce(`unknown axis type: ${type}; expected one of: ${expectedTypes}`);\n        }\n      }\n    }\n  }\n  seriesTypeIntegrity(options) {\n    options.series = options.series?.filter(({ type }) => {\n      if (type == null || isSeriesOptionType(type) || isEnterpriseSeriesType(type)) {\n        return true;\n      }\n      Logger.warnOnce(\n        `unknown series type: ${type}; expected one of: ${publicChartTypes.seriesTypes.join(\", \")}`\n      );\n    });\n  }\n  soloSeriesIntegrity(options) {\n    const allSeries = options.series;\n    if (allSeries && allSeries.length > 1 && allSeries.some((series) => seriesRegistry.isSolo(series.type))) {\n      const mainSeriesType = this.optionsType(options);\n      if (seriesRegistry.isSolo(mainSeriesType)) {\n        Logger.warn(\n          `series[0] of type '${mainSeriesType}' is incompatible with other series types. Only processing series[0]`\n        );\n        options.series = allSeries.slice(0, 1);\n      } else {\n        const { solo, nonSolo } = groupBy(\n          allSeries,\n          (s) => seriesRegistry.isSolo(s.type) ? \"solo\" : \"nonSolo\"\n        );\n        const rejects = unique(solo.map((s) => s.type)).join(\", \");\n        Logger.warn(`Unable to mix these series types with the lead series type: ${rejects}`);\n        options.series = nonSolo;\n      }\n    }\n  }\n  enableConfiguredOptions(options) {\n    jsonWalk(\n      this.userOptions,\n      (visitingUserOpts, visitingMergedOpts) => {\n        if (visitingMergedOpts && \"enabled\" in visitingMergedOpts && !visitingMergedOpts._enabledFromTheme && visitingUserOpts.enabled == null) {\n          visitingMergedOpts.enabled = true;\n        }\n      },\n      { skip: [\"data\", \"theme\"] },\n      options\n    );\n    jsonWalk(\n      options,\n      (visitingMergedOpts) => {\n        if (visitingMergedOpts._enabledFromTheme != null) {\n          delete visitingMergedOpts._enabledFromTheme;\n        }\n      },\n      { skip: [\"data\", \"theme\"] }\n    );\n  }\n  removeDisabledOptions(options) {\n    jsonWalk(\n      options,\n      (optionsNode) => {\n        if (\"enabled\" in optionsNode && optionsNode.enabled === false) {\n          Object.keys(optionsNode).forEach((key) => {\n            if (key === \"enabled\")\n              return;\n            delete optionsNode[key];\n          });\n        }\n      },\n      { skip: [\"data\", \"theme\"] }\n    );\n  }\n  removeLeftoverSymbols(options) {\n    jsonWalk(\n      options,\n      (optionsNode) => {\n        if (!optionsNode || !isObject(optionsNode))\n          return;\n        for (const [key, value] of Object.entries(optionsNode)) {\n          if (isSymbol(value)) {\n            delete optionsNode[key];\n          }\n        }\n      },\n      { skip: [\"data\"] }\n    );\n  }\n  specialOverridesDefaults(options) {\n    if (options.window != null) {\n      setWindow(options.window);\n    } else if (typeof window !== \"undefined\") {\n      options.window = window;\n    } else if (typeof global !== \"undefined\") {\n      options.window = global.window;\n    }\n    if (options.document != null) {\n      setDocument(options.document);\n    } else if (typeof document !== \"undefined\") {\n      options.document = document;\n    } else if (typeof global !== \"undefined\") {\n      options.document = global.document;\n    }\n    if (options.window == null) {\n      throw new Error(\"AG Charts - unable to resolve global window\");\n    }\n    if (options.document == null) {\n      throw new Error(\"AG Charts - unable to resolve global document\");\n    }\n    return options;\n  }\n};\n\n// packages/ag-charts-community/src/api/agCharts.ts\nvar debug2 = Debug.create(true, \"opts\");\nfunction chartType(options) {\n  if (isAgCartesianChartOptions(options)) {\n    return \"cartesian\";\n  } else if (isAgPolarChartOptions(options)) {\n    return \"polar\";\n  } else if (isAgHierarchyChartOptions(options)) {\n    return \"hierarchy\";\n  } else if (isAgTopologyChartOptions(options)) {\n    return \"topology\";\n  } else if (isAgFlowProportionChartOptions(options)) {\n    return \"flow-proportion\";\n  }\n  throw new Error(`AG Chart - unknown type of chart for options with type: ${options.type}`);\n}\nvar AgCharts = class {\n  static licenseCheck(options) {\n    if (this.licenseChecked)\n      return;\n    this.licenseManager = enterpriseModule.licenseManager?.(options);\n    this.licenseManager?.setLicenseKey(this.licenseKey, this.gridContext);\n    this.licenseManager?.validateLicense();\n    this.licenseChecked = true;\n  }\n  static setLicenseKey(licenseKey) {\n    this.licenseKey = licenseKey;\n  }\n  static setGridContext(gridContext) {\n    this.gridContext = gridContext;\n  }\n  static getLicenseDetails(licenseKey) {\n    return enterpriseModule.licenseManager?.({}).getLicenseDetails(licenseKey);\n  }\n  /**\n   * Returns the `AgChartInstance` for a DOM node, if there is one.\n   */\n  static getInstance(element2) {\n    return AgChartsInternal.getInstance(element2);\n  }\n  /**\n   * Create a new `AgChartInstance` based upon the given configuration options.\n   */\n  static create(options) {\n    this.licenseCheck(options);\n    const chart = AgChartsInternal.createOrUpdate(options, void 0, this.licenseManager);\n    if (enterpriseModule.styles != null) {\n      chart.chart.ctx.domManager.addStyles(\"ag-charts-enterprise\", enterpriseModule.styles);\n    }\n    if (this.licenseManager?.isDisplayWatermark() && this.licenseManager) {\n      enterpriseModule.injectWatermark?.(chart.chart.ctx.domManager, this.licenseManager.getWatermarkMessage());\n    }\n    return chart;\n  }\n  static createFinancialChart(options) {\n    return this.create({\n      _type: \"price-volume\",\n      ...options\n    });\n  }\n};\nAgCharts.licenseChecked = false;\nAgCharts.gridContext = false;\nvar _AgChartsInternal = class _AgChartsInternal {\n  static getInstance(element2) {\n    const chart = Chart.getInstance(element2);\n    return chart ? AgChartInstanceProxy.chartInstances.get(chart) : void 0;\n  }\n  static initialiseModules() {\n    if (_AgChartsInternal.initialised)\n      return;\n    registerInbuiltModules();\n    setupModules();\n    _AgChartsInternal.initialised = true;\n  }\n  static createOrUpdate(options, proxy, licenseManager) {\n    _AgChartsInternal.initialiseModules();\n    debug2(\">>> AgCharts.createOrUpdate() user options\", options);\n    const defaultType = proxy?.chart.chartOptions.type;\n    const { _type = defaultType, ...otherOptions } = options;\n    let mutableOptions = otherOptions;\n    if (AgCharts.optionsMutationFn) {\n      mutableOptions = AgCharts.optionsMutationFn(mutableOptions, _type);\n      debug2(\">>> AgCharts.createOrUpdate() MUTATED user options\", options);\n    }\n    const { overrideDevicePixelRatio, document: document2, window: userWindow, ...userOptions } = mutableOptions;\n    const chartOptions = new ChartOptions(userOptions, {\n      overrideDevicePixelRatio,\n      document: document2,\n      window: userWindow,\n      type: _type\n    });\n    let chart = proxy?.chart;\n    if (chart == null || chartType(userOptions) !== chartType(chart?.chartOptions.processedOptions)) {\n      chart = _AgChartsInternal.createChartInstance(chartOptions, chart);\n    }\n    if (proxy == null) {\n      proxy = new AgChartInstanceProxy(chart, _AgChartsInternal.callbackApi, licenseManager);\n    } else {\n      proxy.chart = chart;\n    }\n    if (debug2.check() && typeof window !== \"undefined\") {\n      window.agChartInstances ?? (window.agChartInstances = {});\n      window.agChartInstances[chart.id] = chart;\n    }\n    chart.queuedUserOptions.push(userOptions);\n    chart.requestFactoryUpdate((chartRef) => {\n      chartRef.applyOptions(chartOptions);\n      const queueIdx = chartRef.queuedUserOptions.indexOf(userOptions) + 1;\n      chartRef.queuedUserOptions.splice(0, queueIdx);\n    });\n    return proxy;\n  }\n  static updateUserDelta(proxy, deltaOptions) {\n    deltaOptions = deepClone(deltaOptions, { shallow: [\"data\"] });\n    jsonWalk(\n      deltaOptions,\n      (node) => {\n        if (typeof node !== \"object\")\n          return;\n        for (const [key, value] of Object.entries(node)) {\n          if (typeof value === \"undefined\") {\n            Object.assign(node, { [key]: Symbol(\"UNSET\") });\n          }\n        }\n      },\n      { skip: [\"data\"] }\n    );\n    const { chart } = proxy;\n    const lastUpdateOptions = chart.getOptions();\n    const userOptions = mergeDefaults(deltaOptions, lastUpdateOptions);\n    debug2(\">>> AgCharts.updateUserDelta() user delta\", deltaOptions);\n    debug2(\"AgCharts.updateUserDelta() - base options\", lastUpdateOptions);\n    _AgChartsInternal.createOrUpdate(userOptions, proxy);\n  }\n  static createChartInstance(options, oldChart) {\n    const transferableResource = oldChart?.destroy({ keepTransferableResources: true });\n    const ChartConstructor = _AgChartsInternal.getChartByOptions(options.processedOptions);\n    return new ChartConstructor(options, transferableResource);\n  }\n  static getChartByOptions(options) {\n    if (isAgCartesianChartOptions(options)) {\n      return CartesianChart;\n    } else if (isAgHierarchyChartOptions(options)) {\n      return HierarchyChart;\n    } else if (isAgPolarChartOptions(options)) {\n      return PolarChart;\n    } else if (isAgTopologyChartOptions(options)) {\n      return TopologyChart;\n    } else if (isAgFlowProportionChartOptions(options)) {\n      return FlowProportionChart;\n    }\n    throw new Error(\n      `AG Charts - couldn't apply configuration, check options are correctly structured and series types are specified`\n    );\n  }\n};\n_AgChartsInternal.caretaker = new MementoCaretaker(VERSION);\n_AgChartsInternal.initialised = false;\n_AgChartsInternal.callbackApi = {\n  caretaker: _AgChartsInternal.caretaker,\n  createOrUpdate(opts, chart) {\n    return _AgChartsInternal.createOrUpdate(opts, chart);\n  },\n  updateUserDelta(chart, deltaOptions) {\n    return _AgChartsInternal.updateUserDelta(chart, deltaOptions);\n  }\n};\nvar AgChartsInternal = _AgChartsInternal;\n\n// packages/ag-charts-community/src/integrated-charts-scene.ts\nvar integrated_charts_scene_exports = {};\n__export(integrated_charts_scene_exports, {\n  Arc: () => Arc2,\n  BBox: () => BBox,\n  BandScale: () => BandScale,\n  Caption: () => Caption,\n  ChangeDetectableProperties: () => ChangeDetectableProperties,\n  Circle: () => Circle,\n  ContinuousScale: () => ContinuousScale,\n  Diamond: () => Diamond,\n  DropShadow: () => DropShadow,\n  ExtendedPath2D: () => ExtendedPath2D,\n  Group: () => Group,\n  HdpiCanvas: () => HdpiCanvas,\n  Image: () => Image,\n  Label: () => Label,\n  Line: () => Line,\n  LinearGradientFill: () => LinearGradientFill,\n  LinearScale: () => LinearScale,\n  Marker: () => Marker,\n  Node: () => Node,\n  OrdinalTimeScale: () => OrdinalTimeScale,\n  Path: () => Path,\n  PointerEvents: () => PointerEvents,\n  RadialColumnShape: () => RadialColumnShape,\n  Rect: () => Rect,\n  RedrawType: () => RedrawType,\n  Scene: () => Scene,\n  SceneChangeDetection: () => SceneChangeDetection,\n  ScenePathChangeDetection: () => ScenePathChangeDetection,\n  Sector: () => Sector,\n  SectorBox: () => SectorBox,\n  Selection: () => Selection,\n  Shape: () => Shape,\n  Square: () => Square,\n  SvgPath: () => SvgPath,\n  Text: () => Text,\n  Tooltip: () => Tooltip,\n  Triangle: () => Triangle,\n  drawCorner: () => drawCorner,\n  easing: () => easing_exports,\n  evaluateBezier: () => evaluateBezier,\n  getFont: () => getFont,\n  getMarker: () => getMarker,\n  getRadialColumnWidth: () => getRadialColumnWidth,\n  motion: () => motion,\n  sectorBox: () => sectorBox,\n  solveBezier: () => solveBezier,\n  splitBezier: () => splitBezier,\n  toRadians: () => toRadians,\n  toTooltipHtml: () => toTooltipHtml\n});\n\n// packages/ag-charts-community/src/scene/shape/arc.ts\nvar Arc2 = class extends Path {\n  constructor() {\n    super();\n    this.centerX = 0;\n    this.centerY = 0;\n    this.radius = 10;\n    this.startAngle = 0;\n    this.endAngle = Math.PI * 2;\n    this.counterClockwise = false;\n    this.type = 0 /* Open */;\n    this.restoreOwnStyles();\n  }\n  get fullPie() {\n    return isEqual(normalizeAngle360(this.startAngle), normalizeAngle360(this.endAngle));\n  }\n  updatePath() {\n    const path = this.path;\n    path.clear();\n    path.arc(this.centerX, this.centerY, this.radius, this.startAngle, this.endAngle, this.counterClockwise);\n    if (this.type === 1 /* Chord */) {\n      path.closePath();\n    } else if (this.type === 2 /* Round */ && !this.fullPie) {\n      path.lineTo(this.centerX, this.centerY);\n      path.closePath();\n    }\n  }\n  computeBBox() {\n    return new BBox(this.centerX - this.radius, this.centerY - this.radius, this.radius * 2, this.radius * 2);\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    const bbox = this.getBBox();\n    return this.type !== 0 /* Open */ && bbox.containsPoint(point.x, point.y) && this.path.isPointInPath(point.x, point.y);\n  }\n};\nArc2.className = \"Arc\";\nArc2.defaultStyles = Object.assign({}, Shape.defaultStyles, {\n  lineWidth: 1,\n  fillStyle: null\n});\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"centerX\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"centerY\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"radius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"startAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"endAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"counterClockwise\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], Arc2.prototype, \"type\", 2);\n\n// packages/ag-charts-community/src/scene/shape/linearGradientFill.ts\nvar LinearGradientFill = class extends Shape {\n  constructor() {\n    super(...arguments);\n    this.direction = \"to-right\";\n    this.stops = void 0;\n    this._mask = void 0;\n  }\n  get mask() {\n    return this._mask;\n  }\n  set mask(newMask) {\n    if (this._mask != null) {\n      this.removeChild(this._mask);\n    }\n    if (newMask != null) {\n      this.appendChild(newMask);\n    }\n    this._mask = newMask;\n  }\n  isPointInPath(x, y) {\n    return this.mask?.isPointInPath(x, y) ?? false;\n  }\n  computeBBox() {\n    return this.mask?.getBBox();\n  }\n  render(renderCtx) {\n    const { mask, stops } = this;\n    const { ctx, devicePixelRatio } = renderCtx;\n    const pixelLength = 1 / devicePixelRatio;\n    const maskBbox = mask?.computeTransformedBBox();\n    if (mask == null || stops == null || maskBbox == null)\n      return;\n    if (mask.dirtyPath) {\n      mask.updatePath();\n      mask.dirtyPath = false;\n    }\n    ctx.save();\n    ctx.clip(mask.path.getPath2D());\n    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);\n    const x0 = Math.floor(maskBbox.x);\n    const x1 = Math.ceil(maskBbox.x + maskBbox.width);\n    const y0 = Math.floor(maskBbox.y);\n    const y1 = Math.ceil(maskBbox.y + maskBbox.height);\n    const horizontal = this.direction === \"to-right\" || this.direction === \"to-left\";\n    const reversed = this.direction === \"to-top\" || this.direction === \"to-left\";\n    const colorScale = new ColorScale();\n    const [i0, i1] = horizontal ? [x0, x1] : [y0, y1];\n    colorScale.domain = stops.map((_, index) => {\n      return i0 + (i1 - i0) * index / (stops.length - 1);\n    });\n    colorScale.range = reversed ? stops.slice().reverse() : stops;\n    colorScale.update();\n    const height = y1 - y0;\n    const width = x1 - x0;\n    switch (this.direction) {\n      case \"to-right\":\n      case \"to-left\":\n        for (let x = x0; x <= x1; x += pixelLength) {\n          ctx.fillStyle = colorScale.convert(x);\n          ctx.fillRect(x, y0, pixelLength, height);\n        }\n        break;\n      case \"to-bottom\":\n      case \"to-top\":\n        for (let y = y0; y <= y1; y += pixelLength) {\n          ctx.fillStyle = colorScale.convert(y);\n          ctx.fillRect(x0, y, width, pixelLength);\n        }\n        break;\n    }\n    ctx.restore();\n  }\n};\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], LinearGradientFill.prototype, \"direction\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], LinearGradientFill.prototype, \"stops\", 2);\n__decorateClass([\n  SceneChangeDetection({ redraw: 3 /* MAJOR */ })\n], LinearGradientFill.prototype, \"_mask\", 2);\n\n// packages/ag-charts-community/src/scene/shape/radialColumnShape.ts\nfunction rotatePoint(x, y, rotation) {\n  const radius = Math.sqrt(x ** 2 + y ** 2);\n  const angle2 = Math.atan2(y, x);\n  const rotated = angle2 + rotation;\n  return {\n    x: Math.cos(rotated) * radius,\n    y: Math.sin(rotated) * radius\n  };\n}\nvar RadialColumnShape = class extends Path {\n  constructor() {\n    super(...arguments);\n    this.isBeveled = true;\n    this.columnWidth = 0;\n    this.startAngle = 0;\n    this.endAngle = 0;\n    this.outerRadius = 0;\n    this.innerRadius = 0;\n    this.axisInnerRadius = 0;\n    this.axisOuterRadius = 0;\n    this.isRadiusAxisReversed = false;\n  }\n  set cornerRadius(_value) {\n  }\n  computeBBox() {\n    const { innerRadius, outerRadius, columnWidth } = this;\n    const rotation = this.getRotation();\n    const left = -columnWidth / 2;\n    const right = columnWidth / 2;\n    const top = -outerRadius;\n    const bottom = -innerRadius;\n    let x0 = Infinity;\n    let y0 = Infinity;\n    let x1 = -Infinity;\n    let y1 = -Infinity;\n    for (let i = 0; i < 4; i += 1) {\n      const { x, y } = rotatePoint(i % 2 === 0 ? left : right, i < 2 ? top : bottom, rotation);\n      x0 = Math.min(x, x0);\n      y0 = Math.min(y, y0);\n      x1 = Math.max(x, x1);\n      y1 = Math.max(y, y1);\n    }\n    return new BBox(x0, y0, x1 - x0, y1 - y0);\n  }\n  getRotation() {\n    const { startAngle, endAngle } = this;\n    const midAngle = angleBetween(startAngle, endAngle);\n    return normalizeAngle360(startAngle + midAngle / 2 + Math.PI / 2);\n  }\n  updatePath() {\n    const { isBeveled } = this;\n    if (isBeveled) {\n      this.updateBeveledPath();\n    } else {\n      this.updateRectangularPath();\n    }\n    this.checkPathDirty();\n  }\n  updateRectangularPath() {\n    const { columnWidth, innerRadius, outerRadius, path } = this;\n    const left = -columnWidth / 2;\n    const right = columnWidth / 2;\n    const top = -outerRadius;\n    const bottom = -innerRadius;\n    const rotation = this.getRotation();\n    const points = [\n      [left, bottom],\n      [left, top],\n      [right, top],\n      [right, bottom]\n    ].map(([x, y]) => rotatePoint(x, y, rotation));\n    path.clear(true);\n    path.moveTo(points[0].x, points[0].y);\n    path.lineTo(points[1].x, points[1].y);\n    path.lineTo(points[2].x, points[2].y);\n    path.lineTo(points[3].x, points[3].y);\n    path.closePath();\n  }\n  updateBeveledPath() {\n    const { columnWidth, path, outerRadius, innerRadius, axisInnerRadius, axisOuterRadius, isRadiusAxisReversed } = this;\n    const isStackBottom = isEqual(innerRadius, axisInnerRadius);\n    const sideRotation = Math.asin(columnWidth / 2 / innerRadius);\n    const pointRotation = this.getRotation();\n    const rotate2 = (x, y) => rotatePoint(x, y, pointRotation);\n    const getTriangleHypotenuse = (leg, otherLeg) => Math.sqrt(leg ** 2 + otherLeg ** 2);\n    const getTriangleLeg = (hypotenuse, otherLeg) => {\n      if (otherLeg > hypotenuse) {\n        return 0;\n      }\n      return Math.sqrt(hypotenuse ** 2 - otherLeg ** 2);\n    };\n    const compare = (value, otherValue, lessThan) => lessThan ? value < otherValue : value > otherValue;\n    const shouldConnectBottomCircle = isStackBottom && !isNaN(sideRotation) && sideRotation < Math.PI / 6;\n    let left = -columnWidth / 2;\n    let right = columnWidth / 2;\n    const top = -outerRadius;\n    const bottom = -innerRadius * (shouldConnectBottomCircle ? Math.cos(sideRotation) : 1);\n    const hasBottomIntersection = compare(\n      axisOuterRadius,\n      getTriangleHypotenuse(innerRadius, columnWidth / 2),\n      !isRadiusAxisReversed\n    );\n    if (hasBottomIntersection) {\n      const bottomIntersectionX = getTriangleLeg(axisOuterRadius, innerRadius);\n      left = -bottomIntersectionX;\n      right = bottomIntersectionX;\n    }\n    path.clear(true);\n    const bottomLeftPt = rotate2(left, bottom);\n    path.moveTo(bottomLeftPt.x, bottomLeftPt.y);\n    const isEmpty = isEqual(innerRadius, outerRadius);\n    const hasSideIntersection = compare(\n      axisOuterRadius,\n      getTriangleHypotenuse(outerRadius, columnWidth / 2),\n      !isRadiusAxisReversed\n    );\n    if (isEmpty && shouldConnectBottomCircle) {\n      path.arc(\n        0,\n        0,\n        innerRadius,\n        normalizeAngle360(-sideRotation - Math.PI / 2) + pointRotation,\n        normalizeAngle360(sideRotation - Math.PI / 2) + pointRotation,\n        false\n      );\n    } else if (hasSideIntersection) {\n      const sideIntersectionY = -getTriangleLeg(axisOuterRadius, columnWidth / 2);\n      const topIntersectionX = getTriangleLeg(axisOuterRadius, outerRadius);\n      if (!hasBottomIntersection) {\n        const topLeftPt = rotate2(left, sideIntersectionY);\n        path.lineTo(topLeftPt.x, topLeftPt.y);\n      }\n      path.arc(\n        0,\n        0,\n        axisOuterRadius,\n        Math.atan2(sideIntersectionY, left) + pointRotation,\n        Math.atan2(top, -topIntersectionX) + pointRotation,\n        false\n      );\n      if (!isEqual(topIntersectionX, 0)) {\n        const topRightBevelPt = rotate2(topIntersectionX, top);\n        path.lineTo(topRightBevelPt.x, topRightBevelPt.y);\n      }\n      path.arc(\n        0,\n        0,\n        axisOuterRadius,\n        Math.atan2(top, topIntersectionX) + pointRotation,\n        Math.atan2(sideIntersectionY, right) + pointRotation,\n        false\n      );\n    } else {\n      const topLeftPt = rotate2(left, top);\n      const topRightPt = rotate2(right, top);\n      path.lineTo(topLeftPt.x, topLeftPt.y);\n      path.lineTo(topRightPt.x, topRightPt.y);\n    }\n    const bottomRightPt = rotate2(right, bottom);\n    path.lineTo(bottomRightPt.x, bottomRightPt.y);\n    if (shouldConnectBottomCircle) {\n      path.arc(\n        0,\n        0,\n        innerRadius,\n        normalizeAngle360(sideRotation - Math.PI / 2) + pointRotation,\n        normalizeAngle360(-sideRotation - Math.PI / 2) + pointRotation,\n        true\n      );\n    } else {\n      const rotatedBottomLeftPt = rotate2(left, bottom);\n      path.lineTo(rotatedBottomLeftPt.x, rotatedBottomLeftPt.y);\n    }\n    path.closePath();\n  }\n};\nRadialColumnShape.className = \"RadialColumnShape\";\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"isBeveled\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"columnWidth\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"startAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"endAngle\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"outerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"innerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"axisInnerRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"axisOuterRadius\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], RadialColumnShape.prototype, \"isRadiusAxisReversed\", 2);\nfunction getRadialColumnWidth(startAngle, endAngle, axisOuterRadius, columnWidthRatio, maxColumnWidthRatio) {\n  const rotation = angleBetween(startAngle, endAngle);\n  const pad2 = rotation * (1 - columnWidthRatio) / 2;\n  startAngle += pad2;\n  endAngle -= pad2;\n  if (rotation < 1e-3) {\n    return 2 * axisOuterRadius * maxColumnWidthRatio;\n  }\n  if (rotation >= 2 * Math.PI) {\n    const midAngle = startAngle + rotation / 2;\n    startAngle = midAngle - Math.PI;\n    endAngle = midAngle + Math.PI;\n  }\n  const startX = axisOuterRadius * Math.cos(startAngle);\n  const startY = axisOuterRadius * Math.sin(startAngle);\n  const endX = axisOuterRadius * Math.cos(endAngle);\n  const endY = axisOuterRadius * Math.sin(endAngle);\n  const colWidth = Math.floor(Math.sqrt((startX - endX) ** 2 + (startY - endY) ** 2));\n  const maxWidth = 2 * axisOuterRadius * maxColumnWidthRatio;\n  return Math.max(1, Math.min(maxWidth, colWidth));\n}\n\n// packages/ag-charts-community/src/scene/shape/svgPath.ts\nvar SvgPath = class extends Path {\n  constructor(d) {\n    super();\n    this.x = 0;\n    this.y = 0;\n    this.commands = [];\n    for (const [_, command, paramsString] of d.matchAll(/([A-Z])([0-9. ]+)/g)) {\n      const params = paramsString.split(\" \").map(Number);\n      this.commands.push([command, params]);\n    }\n  }\n  updatePath() {\n    const { path, x, y } = this;\n    path.clear();\n    let lastX = x;\n    let lastY = y;\n    for (const [command, params] of this.commands) {\n      switch (command) {\n        case \"M\":\n          path.moveTo(x + params[0], y + params[1]);\n          lastX = x + params[0];\n          break;\n        case \"C\":\n          path.cubicCurveTo(\n            x + params[0],\n            y + params[1],\n            x + params[2],\n            y + params[3],\n            x + params[4],\n            y + params[5]\n          );\n          lastX = x + params[4];\n          lastY = y + params[5];\n          break;\n        case \"H\":\n          path.lineTo(x + params[0], lastY);\n          lastX = y + params[0];\n          break;\n        case \"L\":\n          path.lineTo(x + params[0], y + params[1]);\n          lastX = x + params[0];\n          lastY = y + params[1];\n          break;\n        case \"V\":\n          path.lineTo(lastX, y + params[0]);\n          lastY = y + params[0];\n          break;\n        default:\n          throw new Error(`Could not translate command '${command}' with '${params.join(\" \")}'`);\n      }\n    }\n    path.closePath();\n  }\n};\n__decorateClass([\n  ScenePathChangeDetection()\n], SvgPath.prototype, \"x\", 2);\n__decorateClass([\n  ScenePathChangeDetection()\n], SvgPath.prototype, \"y\", 2);\n\n// packages/ag-charts-community/src/integrated-charts-scene.ts\nvar motion = { ...fromToMotion_exports, ...resetMotion_exports };\nvar getFont = TextUtils.toFontString;\n\n// packages/ag-charts-community/src/integrated-charts-theme.ts\nvar integrated_charts_theme_exports = {};\n__export(integrated_charts_theme_exports, {\n  CARTESIAN_AXIS_TYPE: () => CARTESIAN_AXIS_TYPE,\n  ChartTheme: () => ChartTheme,\n  DEFAULT_ANNOTATION_BACKGROUND_FILL: () => DEFAULT_ANNOTATION_BACKGROUND_FILL,\n  DEFAULT_ANNOTATION_COLOR: () => DEFAULT_ANNOTATION_COLOR,\n  DEFAULT_ANNOTATION_HANDLE_FILL: () => DEFAULT_ANNOTATION_HANDLE_FILL,\n  DEFAULT_AXIS_GRID_COLOUR: () => DEFAULT_AXIS_GRID_COLOUR,\n  DEFAULT_AXIS_LINE_COLOUR: () => DEFAULT_AXIS_LINE_COLOUR,\n  DEFAULT_BACKGROUND_COLOUR: () => DEFAULT_BACKGROUND_COLOUR,\n  DEFAULT_CAPTION_ALIGNMENT: () => DEFAULT_CAPTION_ALIGNMENT,\n  DEFAULT_CAPTION_LAYOUT_STYLE: () => DEFAULT_CAPTION_LAYOUT_STYLE,\n  DEFAULT_COLOURS: () => DEFAULT_COLOURS,\n  DEFAULT_CROSS_LINES_COLOUR: () => DEFAULT_CROSS_LINES_COLOUR,\n  DEFAULT_DIVERGING_SERIES_COLOUR_RANGE: () => DEFAULT_DIVERGING_SERIES_COLOUR_RANGE,\n  DEFAULT_FONT_FAMILY: () => DEFAULT_FONT_FAMILY,\n  DEFAULT_GRIDLINE_ENABLED: () => DEFAULT_GRIDLINE_ENABLED,\n  DEFAULT_HIERARCHY_FILLS: () => DEFAULT_HIERARCHY_FILLS,\n  DEFAULT_HIERARCHY_STROKES: () => DEFAULT_HIERARCHY_STROKES,\n  DEFAULT_INSIDE_SERIES_LABEL_COLOUR: () => DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n  DEFAULT_INVERTED_LABEL_COLOUR: () => DEFAULT_INVERTED_LABEL_COLOUR,\n  DEFAULT_LABEL_COLOUR: () => DEFAULT_LABEL_COLOUR,\n  DEFAULT_MUTED_LABEL_COLOUR: () => DEFAULT_MUTED_LABEL_COLOUR,\n  DEFAULT_PADDING: () => DEFAULT_PADDING,\n  DEFAULT_POLAR_SERIES_STROKE: () => DEFAULT_POLAR_SERIES_STROKE,\n  DEFAULT_SHADOW_COLOUR: () => DEFAULT_SHADOW_COLOUR,\n  DEFAULT_TEXTBOX_COLOR: () => DEFAULT_TEXTBOX_COLOR,\n  DEFAULT_TEXTBOX_FILL: () => DEFAULT_TEXTBOX_FILL,\n  DEFAULT_TEXTBOX_STROKE: () => DEFAULT_TEXTBOX_STROKE,\n  DEFAULT_TEXT_ANNOTATION_COLOR: () => DEFAULT_TEXT_ANNOTATION_COLOR,\n  DEFAULT_TOOLBAR_POSITION: () => DEFAULT_TOOLBAR_POSITION,\n  FONT_SIZE: () => FONT_SIZE,\n  FONT_WEIGHT: () => FONT_WEIGHT2,\n  IS_DARK_THEME: () => IS_DARK_THEME,\n  PALETTE_ALT_DOWN_FILL: () => PALETTE_ALT_DOWN_FILL,\n  PALETTE_ALT_DOWN_STROKE: () => PALETTE_ALT_DOWN_STROKE,\n  PALETTE_ALT_NEUTRAL_FILL: () => PALETTE_ALT_NEUTRAL_FILL,\n  PALETTE_ALT_NEUTRAL_STROKE: () => PALETTE_ALT_NEUTRAL_STROKE,\n  PALETTE_ALT_UP_FILL: () => PALETTE_ALT_UP_FILL,\n  PALETTE_ALT_UP_STROKE: () => PALETTE_ALT_UP_STROKE,\n  PALETTE_DOWN_FILL: () => PALETTE_DOWN_FILL,\n  PALETTE_DOWN_STROKE: () => PALETTE_DOWN_STROKE,\n  PALETTE_NEUTRAL_FILL: () => PALETTE_NEUTRAL_FILL,\n  PALETTE_NEUTRAL_STROKE: () => PALETTE_NEUTRAL_STROKE,\n  PALETTE_UP_FILL: () => PALETTE_UP_FILL,\n  PALETTE_UP_STROKE: () => PALETTE_UP_STROKE,\n  POLAR_AXIS_SHAPE: () => POLAR_AXIS_SHAPE,\n  POLAR_AXIS_TYPE: () => POLAR_AXIS_TYPE,\n  POSITION: () => POSITION2,\n  getChartTheme: () => getChartTheme,\n  markerPaletteFactory: () => markerPaletteFactory,\n  singleSeriesPaletteFactory: () => singleSeriesPaletteFactory,\n  themes: () => themes2\n});\nvar themes2 = mapValues(\n  themes,\n  (themeFactory) => themeFactory?.()\n);\n\n// packages/ag-charts-community/src/sparklines-scale.ts\nvar sparklines_scale_exports = {};\n__export(sparklines_scale_exports, {\n  BandScale: () => BandScale,\n  ColorScale: () => ColorScale,\n  ContinuousScale: () => ContinuousScale,\n  Invalidating: () => Invalidating,\n  LinearScale: () => LinearScale,\n  OrdinalTimeScale: () => OrdinalTimeScale,\n  TimeScale: () => TimeScale\n});\n\n// packages/ag-charts-community/src/sparklines-util.ts\nvar sparklines_util_exports = {};\n__export(sparklines_util_exports, {\n  Color: () => Color,\n  Debug: () => Debug,\n  Logger: () => Logger,\n  Padding: () => Padding,\n  TimeInterval: () => TimeInterval,\n  Vec2: () => Vec2,\n  angleBetween: () => angleBetween,\n  angleDiff: () => angleDiff,\n  areArrayNumbersEqual: () => areArrayNumbersEqual,\n  bifurcate: () => bifurcate,\n  checkDatum: () => checkDatum,\n  clamp: () => clamp,\n  clampArray: () => clampArray,\n  countFractionDigits: () => countFractionDigits,\n  createId: () => createId,\n  day: () => day,\n  deepClone: () => deepClone,\n  displacePointFromVector: () => displacePointFromVector,\n  extent: () => extent,\n  findMinMax: () => findMinMax,\n  findRangeExtent: () => findRangeExtent,\n  formatNormalizedPercentage: () => formatNormalizedPercentage,\n  formatPercentage: () => formatPercentage,\n  friday: () => friday,\n  hour: () => hour,\n  interpolateColor: () => interpolateColor,\n  interpolateNumber: () => interpolateNumber,\n  isBetweenAngles: () => isBetweenAngles,\n  isContinuous: () => isContinuous,\n  isDate: () => isValidDate,\n  isDenseInterval: () => isDenseInterval,\n  isEqual: () => isEqual,\n  isNegative: () => isNegative,\n  isNumber: () => isFiniteNumber,\n  isNumberEqual: () => isEqual,\n  isNumberObject: () => isNumberObject,\n  isString: () => isString,\n  isStringObject: () => isStringObject,\n  jsonApply: () => jsonApply,\n  jsonDiff: () => jsonDiff,\n  jsonWalk: () => jsonWalk,\n  millisecond: () => millisecond,\n  minute: () => minute,\n  mod: () => mod,\n  monday: () => monday,\n  month: () => month,\n  normalisedExtent: () => normalisedExtent,\n  normalisedExtentWithMetadata: () => normalisedExtentWithMetadata,\n  normalizeAngle180: () => normalizeAngle180,\n  normalizeAngle360: () => normalizeAngle360,\n  normalizeAngle360Inclusive: () => normalizeAngle360Inclusive,\n  range: () => range,\n  resetIds: () => resetIds,\n  round: () => round,\n  sanitizeHtml: () => sanitizeHtml,\n  saturday: () => saturday,\n  second: () => second,\n  setAttribute: () => setAttribute,\n  setVisibility: () => setVisibility,\n  shallowClone: () => shallowClone,\n  sunday: () => sunday,\n  thursday: () => thursday,\n  tickFormat: () => tickFormat,\n  tickStep: () => tickStep,\n  ticks: () => createTicks,\n  toDegrees: () => toDegrees,\n  toFixed: () => toFixed,\n  toRadians: () => toRadians,\n  transformIntegratedCategoryValue: () => transformIntegratedCategoryValue,\n  tuesday: () => tuesday,\n  utcDay: () => utcDay,\n  utcHour: () => utcHour,\n  utcMinute: () => utcMinute,\n  utcMonth: () => utcMonth,\n  utcYear: () => utcYear,\n  uuid: () => uuid,\n  wednesday: () => wednesday,\n  year: () => year,\n  zipObject: () => zipObject\n});\n\n// packages/ag-charts-community/src/util/vector.ts\nvar Vec2 = {\n  add,\n  angle,\n  apply,\n  equal,\n  distance: distance2,\n  distanceSquared: distanceSquared2,\n  from,\n  fromOffset,\n  length,\n  lengthSquared,\n  required,\n  rotate,\n  sub\n};\nfunction add(a, b) {\n  return { x: a.x + b.x, y: a.y + b.y };\n}\nfunction sub(a, b) {\n  return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction length(a) {\n  return Math.sqrt(a.x * a.x + a.y * a.y);\n}\nfunction lengthSquared(a) {\n  return a.x * a.x + a.y * a.y;\n}\nfunction distance2(a, b) {\n  const d = sub(a, b);\n  return Math.sqrt(d.x * d.x + d.y * d.y);\n}\nfunction distanceSquared2(a, b) {\n  const d = sub(a, b);\n  return d.x * d.x + d.y * d.y;\n}\nfunction angle(a, b) {\n  return Math.atan2(a.y, a.x) - Math.atan2(b.y, b.x);\n}\nfunction rotate(a, theta, b = required()) {\n  const l = Vec2.length(a);\n  return { x: b.x + l * Math.cos(theta), y: b.y + l * Math.sin(theta) };\n}\nfunction equal(a, b) {\n  return a.x === b.x && a.y === b.y;\n}\nfunction from(x, y) {\n  return { x, y };\n}\nfunction fromOffset(a) {\n  return { x: a.offsetX, y: a.offsetY };\n}\nfunction apply(a, b) {\n  a.x = b.x;\n  a.y = b.y;\n  return a;\n}\nfunction required(a) {\n  return { x: a?.x ?? 0, y: a?.y ?? 0 };\n}\n\n// packages/ag-charts-community/src/util/zip.ts\nfunction zipObject(keys, values) {\n  const zipped = {};\n  if (Array.isArray(values)) {\n    for (let i = 0; i < keys.length; i++) {\n      zipped[`${keys[i]}`] = values[i];\n    }\n  } else {\n    for (let i = 0; i < keys.length; i++) {\n      zipped[`${keys[i]}`] = values;\n    }\n  }\n  return zipped;\n}\n\n// packages/ag-charts-community/src/module-support.ts\nvar module_support_exports = {};\n__export(module_support_exports, {\n  AND: () => AND,\n  ARRAY: () => ARRAY,\n  ARRAY_OF: () => ARRAY_OF,\n  AbstractBarSeries: () => AbstractBarSeries,\n  AbstractBarSeriesProperties: () => AbstractBarSeriesProperties,\n  ActionOnSet: () => ActionOnSet,\n  Animation: () => Animation,\n  AnimationManager: () => AnimationManager,\n  AreaSeriesTag: () => AreaSeriesTag,\n  Axis: () => Axis,\n  AxisInterval: () => AxisInterval,\n  AxisLabel: () => AxisLabel,\n  AxisTick: () => AxisTick,\n  AxisTicks: () => AxisTicks,\n  BOOLEAN: () => BOOLEAN,\n  BOOLEAN_ARRAY: () => BOOLEAN_ARRAY,\n  Background: () => Background,\n  BackgroundModule: () => BackgroundModule,\n  BaseModuleInstance: () => BaseModuleInstance,\n  BaseProperties: () => BaseProperties,\n  COLOR_STRING: () => COLOR_STRING,\n  COLOR_STRING_ARRAY: () => COLOR_STRING_ARRAY,\n  CachedTextMeasurer: () => CachedTextMeasurer,\n  CachedTextMeasurerPool: () => CachedTextMeasurerPool,\n  CartesianAxis: () => CartesianAxis,\n  CartesianSeries: () => CartesianSeries,\n  CartesianSeriesNodeEvent: () => CartesianSeriesNodeEvent,\n  CartesianSeriesProperties: () => CartesianSeriesProperties,\n  CategoryAxis: () => CategoryAxis,\n  ChartAxisDirection: () => ChartAxisDirection,\n  ChartEventManager: () => ChartEventManager,\n  ChartOptions: () => ChartOptions,\n  ChartUpdateType: () => ChartUpdateType,\n  ContextMenuRegistry: () => ContextMenuRegistry,\n  Cursor: () => Cursor,\n  CursorManager: () => CursorManager,\n  DATE: () => DATE,\n  DATE_ARRAY: () => DATE_ARRAY,\n  DATE_OR_DATETIME_MS: () => DATE_OR_DATETIME_MS,\n  DEFAULT_CARTESIAN_DIRECTION_KEYS: () => DEFAULT_CARTESIAN_DIRECTION_KEYS,\n  DEFAULT_CARTESIAN_DIRECTION_NAMES: () => DEFAULT_CARTESIAN_DIRECTION_NAMES,\n  DEFAULT_TOOLTIP_CLASS: () => DEFAULT_TOOLTIP_CLASS,\n  DEFAULT_TOOLTIP_DARK_CLASS: () => DEFAULT_TOOLTIP_DARK_CLASS,\n  DEGREE: () => DEGREE,\n  DIRECTION: () => DIRECTION,\n  DOMManager: () => DOMManager,\n  DataController: () => DataController,\n  DataModel: () => DataModel,\n  DataModelSeries: () => DataModelSeries,\n  DataService: () => DataService,\n  Default: () => Default,\n  Deprecated: () => Deprecated,\n  DeprecatedAndRenamedTo: () => DeprecatedAndRenamedTo,\n  EMPTY_TOOLTIP_CONTENT: () => EMPTY_TOOLTIP_CONTENT,\n  FONT_STYLE: () => FONT_STYLE,\n  FONT_WEIGHT: () => FONT_WEIGHT,\n  FUNCTION: () => FUNCTION,\n  GREATER_THAN: () => GREATER_THAN,\n  GestureDetector: () => GestureDetector,\n  GroupedCategoryAxis: () => GroupedCategoryAxis,\n  HierarchyNode: () => HierarchyNode,\n  HierarchySeries: () => HierarchySeries,\n  HierarchySeriesProperties: () => HierarchySeriesProperties,\n  HighlightManager: () => HighlightManager,\n  HighlightProperties: () => HighlightProperties,\n  HighlightStyle: () => HighlightStyle,\n  INTERACTION_RANGE: () => INTERACTION_RANGE,\n  INTERPOLATION_STEP_POSITION: () => INTERPOLATION_STEP_POSITION,\n  INTERPOLATION_TYPE: () => INTERPOLATION_TYPE,\n  InteractionManager: () => InteractionManager,\n  InteractionState: () => InteractionState,\n  InterpolationProperties: () => InterpolationProperties,\n  KeyNavManager: () => KeyNavManager,\n  LABEL_PLACEMENT: () => LABEL_PLACEMENT,\n  LARGEST_KEY_INTERVAL: () => LARGEST_KEY_INTERVAL,\n  LESS_THAN: () => LESS_THAN,\n  LINE_CAP: () => LINE_CAP,\n  LINE_DASH: () => LINE_DASH,\n  LINE_JOIN: () => LINE_JOIN,\n  Layers: () => Layers,\n  LayoutService: () => LayoutService,\n  LonLatBBox: () => LonLatBBox,\n  MARKER_SHAPE: () => MARKER_SHAPE,\n  MATCHING_CROSSLINE_TYPE: () => MATCHING_CROSSLINE_TYPE,\n  MAX_SPACING: () => MAX_SPACING,\n  MIN_SPACING: () => MIN_SPACING,\n  MercatorScale: () => MercatorScale,\n  ModuleRegistry: () => ModuleRegistry,\n  Motion: () => easing_exports,\n  NAN: () => NAN,\n  NODE_UPDATE_STATE_TO_PHASE_MAPPING: () => NODE_UPDATE_STATE_TO_PHASE_MAPPING,\n  NUMBER: () => NUMBER,\n  NUMBER_ARRAY: () => NUMBER_ARRAY,\n  NUMBER_OR_NAN: () => NUMBER_OR_NAN,\n  Navigator: () => Navigator,\n  NavigatorModule: () => NavigatorModule,\n  OBJECT: () => OBJECT,\n  OBJECT_ARRAY: () => OBJECT_ARRAY,\n  OR: () => OR,\n  OVERFLOW_STRATEGY: () => OVERFLOW_STRATEGY,\n  ObserveChanges: () => ObserveChanges,\n  PHASE_METADATA: () => PHASE_METADATA,\n  PHASE_ORDER: () => PHASE_ORDER,\n  PLACEMENT: () => PLACEMENT,\n  PLAIN_OBJECT: () => PLAIN_OBJECT,\n  POINTER_INTERACTION_TYPES: () => POINTER_INTERACTION_TYPES,\n  POSITION: () => POSITION,\n  POSITION_TOP_COORDINATES: () => POSITION_TOP_COORDINATES,\n  POSITIVE_NUMBER: () => POSITIVE_NUMBER,\n  PolarAxis: () => PolarAxis,\n  PolarSeries: () => PolarSeries,\n  PropertiesArray: () => PropertiesArray,\n  ProxyOnWrite: () => ProxyOnWrite,\n  ProxyProperty: () => ProxyProperty,\n  ProxyPropertyOnWrite: () => ProxyPropertyOnWrite,\n  QUICK_TRANSITION: () => QUICK_TRANSITION,\n  RATIO: () => RATIO,\n  REGIONS: () => REGIONS,\n  RegionManager: () => RegionManager,\n  RepeatType: () => RepeatType,\n  SKIP_JS_BUILTINS: () => SKIP_JS_BUILTINS,\n  SMALLEST_KEY_INTERVAL: () => SMALLEST_KEY_INTERVAL,\n  SORT_DOMAIN_GROUPS: () => SORT_DOMAIN_GROUPS,\n  STRING: () => STRING,\n  STRING_ARRAY: () => STRING_ARRAY,\n  Series: () => Series,\n  SeriesGroupingChangedEvent: () => SeriesGroupingChangedEvent,\n  SeriesItemHighlightStyle: () => SeriesItemHighlightStyle,\n  SeriesMarker: () => SeriesMarker,\n  SeriesNodeEvent: () => SeriesNodeEvent,\n  SeriesNodePickMode: () => SeriesNodePickMode,\n  SeriesProperties: () => SeriesProperties,\n  SeriesTooltip: () => SeriesTooltip,\n  SimpleTextMeasurer: () => SimpleTextMeasurer,\n  StateMachine: () => StateMachine,\n  TEXT_ALIGN: () => TEXT_ALIGN,\n  TEXT_WRAP: () => TEXT_WRAP,\n  TICK_INTERVAL: () => TICK_INTERVAL,\n  TextUtils: () => TextUtils,\n  TextWrapper: () => TextWrapper,\n  ToolbarManager: () => ToolbarManager,\n  Tooltip: () => Tooltip,\n  TooltipManager: () => TooltipManager,\n  TooltipPosition: () => TooltipPosition,\n  UNION: () => UNION,\n  UpdateService: () => UpdateService,\n  VERTICAL_ALIGN: () => VERTICAL_ALIGN,\n  Validate: () => Validate,\n  ZoomManager: () => ZoomManager,\n  __FORCE_MODULE_DETECTION: () => __FORCE_MODULE_DETECTION,\n  accumulateGroup: () => accumulateGroup,\n  accumulateStack: () => accumulateStack,\n  accumulatedValue: () => accumulatedValue,\n  accumulativeValueProperty: () => accumulativeValueProperty,\n  addHitTestersToQuadtree: () => addHitTestersToQuadtree,\n  adjustLabelPlacement: () => adjustLabelPlacement,\n  allInStringUnion: () => allInStringUnion,\n  animationValidation: () => animationValidation,\n  area: () => area,\n  arraysEqual: () => arraysEqual,\n  backfillPathPointData: () => backfillPathPointData,\n  basicContinuousCheckDatumValidation: () => basicContinuousCheckDatumValidation,\n  bifurcate: () => bifurcate,\n  buildFormatter: () => buildFormatter,\n  buildResetPathFn: () => buildResetPathFn,\n  calculateDefaultTimeTickFormat: () => calculateDefaultTimeTickFormat,\n  calculateLabelChartPadding: () => calculateLabelChartPadding,\n  calculateLabelTranslation: () => calculateLabelTranslation,\n  calculatePlacement: () => calculatePlacement,\n  checkCrisp: () => checkCrisp,\n  childrenIter: () => childrenIter,\n  circularSliceArray: () => circularSliceArray,\n  clamp: () => clamp,\n  clampArray: () => clampArray,\n  collapsedStartingBarPosition: () => collapsedStartingBarPosition,\n  computeBarFocusBounds: () => computeBarFocusBounds,\n  computeMarkerFocusBounds: () => computeMarkerFocusBounds,\n  convertValuesToScaleByDefs: () => convertValuesToScaleByDefs,\n  countFractionDigits: () => countFractionDigits,\n  createDatumId: () => createDatumId,\n  createDeprecationWarning: () => createDeprecationWarning,\n  createElement: () => createElement,\n  createElementNS: () => createElementNS,\n  dateToNumber: () => dateToNumber,\n  deconstructSelectionsOrNodes: () => deconstructSelectionsOrNodes,\n  deepClone: () => deepClone,\n  deepMerge: () => deepMerge,\n  defaultTimeTickFormat: () => defaultTimeTickFormat,\n  determinePathStatus: () => determinePathStatus,\n  diff: () => diff,\n  downloadUrl: () => downloadUrl,\n  enterpriseModule: () => enterpriseModule,\n  extent: () => extent,\n  extractDecoratedProperties: () => extractDecoratedProperties,\n  findMaxValue: () => findMaxValue,\n  findMinMax: () => findMinMax,\n  findQuadtreeMatch: () => findQuadtreeMatch,\n  findRangeExtent: () => findRangeExtent,\n  fixNumericExtent: () => fixNumericExtent,\n  formatNormalizedPercentage: () => formatNormalizedPercentage,\n  formatPercentage: () => formatPercentage,\n  fromToMotion: () => fromToMotion,\n  getDocument: () => getDocument,\n  getMissCount: () => getMissCount,\n  getPath: () => getPath,\n  getPathComponents: () => getPathComponents,\n  getRectConfig: () => getRectConfig,\n  getWindow: () => getWindow,\n  groupAccumulativeValueProperty: () => groupAccumulativeValueProperty,\n  groupAverage: () => groupAverage,\n  groupBy: () => groupBy,\n  groupCount: () => groupCount,\n  groupStackValueProperty: () => groupStackValueProperty,\n  groupSum: () => groupSum,\n  initMenuKeyNav: () => initMenuKeyNav,\n  initToolbarKeyNav: () => initToolbarKeyNav,\n  isArray: () => isArray,\n  isBoolean: () => isBoolean,\n  isDate: () => isDate,\n  isDecoratedObject: () => isDecoratedObject,\n  isDefined: () => isDefined,\n  isEnumKey: () => isEnumKey,\n  isEnumValue: () => isEnumValue,\n  isEqual: () => isEqual,\n  isFiniteNumber: () => isFiniteNumber,\n  isFunction: () => isFunction,\n  isHtmlElement: () => isHtmlElement,\n  isNegative: () => isNegative,\n  isNumber: () => isNumber,\n  isObject: () => isObject,\n  isObjectLike: () => isObjectLike,\n  isPlainObject: () => isPlainObject,\n  isProperties: () => isProperties,\n  isRegExp: () => isRegExp,\n  isString: () => isString,\n  isSymbol: () => isSymbol,\n  isValidDate: () => isValidDate,\n  jsonApply: () => jsonApply,\n  jsonDiff: () => jsonDiff,\n  jsonWalk: () => jsonWalk,\n  keyProperty: () => keyProperty,\n  labelDirectionHandling: () => labelDirectionHandling,\n  listDecoratedProperties: () => listDecoratedProperties,\n  makeAccessibleClickListener: () => makeAccessibleClickListener,\n  mapIterable: () => mapIterable,\n  mapValues: () => mapValues,\n  markerFadeInAnimation: () => markerFadeInAnimation,\n  markerPaletteFactory: () => markerPaletteFactory,\n  markerScaleInAnimation: () => markerScaleInAnimation,\n  markerSwipeScaleInAnimation: () => markerSwipeScaleInAnimation,\n  mergeArrayDefaults: () => mergeArrayDefaults,\n  mergeDefaults: () => mergeDefaults,\n  midpointStartingBarPosition: () => midpointStartingBarPosition,\n  minMax: () => minMax,\n  mod: () => mod,\n  moduleRegistry: () => moduleRegistry,\n  nearestSquared: () => nearestSquared,\n  nearestSquaredInContainer: () => nearestSquaredInContainer,\n  normaliseGroupTo: () => normaliseGroupTo,\n  normalisePropertyTo: () => normalisePropertyTo,\n  normalisedExtent: () => normalisedExtent,\n  normalisedExtentWithMetadata: () => normalisedExtentWithMetadata,\n  pairCategoryData: () => pairCategoryData,\n  pairContinuousData: () => pairContinuousData,\n  partialAssign: () => partialAssign,\n  pathFadeInAnimation: () => pathFadeInAnimation,\n  pathFadeOutAnimation: () => pathFadeOutAnimation,\n  pathRangePoints: () => pathRangePoints,\n  pathRangePointsReverse: () => pathRangePointsReverse,\n  pathRanges: () => pathRanges,\n  pathSwipeInAnimation: () => pathSwipeInAnimation,\n  pickByMatchingAngle: () => pickByMatchingAngle,\n  pickNode: () => pickNode,\n  plotPath: () => plotPath,\n  predicateWithMessage: () => predicateWithMessage,\n  prepareAreaPathAnimation: () => prepareAreaPathAnimation,\n  prepareAxisAnimationContext: () => prepareAxisAnimationContext,\n  prepareAxisAnimationFunctions: () => prepareAxisAnimationFunctions,\n  prepareBarAnimationFunctions: () => prepareBarAnimationFunctions,\n  prepareLinePathAnimation: () => prepareLinePathAnimation,\n  prepareLinePathAnimationFns: () => prepareLinePathAnimationFns,\n  prepareLinePathPropertyAnimation: () => prepareLinePathPropertyAnimation,\n  prepareMarkerAnimation: () => prepareMarkerAnimation,\n  preparePieSeriesAnimationFunctions: () => preparePieSeriesAnimationFunctions,\n  range: () => range2,\n  rangedValueProperty: () => rangedValueProperty,\n  renderPartialPath: () => renderPartialPath,\n  resetAxisGroupFn: () => resetAxisGroupFn,\n  resetAxisLabelSelectionFn: () => resetAxisLabelSelectionFn,\n  resetAxisLineSelectionFn: () => resetAxisLineSelectionFn,\n  resetAxisSelectionFn: () => resetAxisSelectionFn,\n  resetBarSelectionsFn: () => resetBarSelectionsFn,\n  resetIds: () => resetIds,\n  resetLabelFn: () => resetLabelFn,\n  resetMarkerFn: () => resetMarkerFn,\n  resetMarkerPositionFn: () => resetMarkerPositionFn,\n  resetMotion: () => resetMotion,\n  resetPieSelectionsFn: () => resetPieSelectionsFn,\n  round: () => round,\n  scale: () => scale,\n  seriesLabelFadeInAnimation: () => seriesLabelFadeInAnimation,\n  seriesLabelFadeOutAnimation: () => seriesLabelFadeOutAnimation,\n  setDocument: () => setDocument,\n  setElementBBox: () => setElementBBox,\n  setPath: () => setPath,\n  setWindow: () => setWindow,\n  shallowClone: () => shallowClone,\n  singleSeriesPaletteFactory: () => singleSeriesPaletteFactory,\n  splitPairData: () => splitPairData,\n  staticFromToMotion: () => staticFromToMotion,\n  stringify: () => stringify,\n  sum: () => sum,\n  sumValues: () => sumValues,\n  times: () => times,\n  toArray: () => toArray,\n  toFixed: () => toFixed,\n  toTooltipHtml: () => toTooltipHtml,\n  trailingAccumulatedValue: () => trailingAccumulatedValue,\n  trailingAccumulatedValueProperty: () => trailingAccumulatedValueProperty,\n  unique: () => unique,\n  updateClipPath: () => updateClipPath,\n  updateLabelNode: () => updateLabelNode,\n  updateRect: () => updateRect,\n  validateCrossLineValues: () => validateCrossLineValues,\n  valueProperty: () => valueProperty,\n  without: () => without\n});\n\n// packages/ag-charts-community/src/util/deprecation.ts\nfunction createDeprecationWarning() {\n  return (key, message) => {\n    const msg = [`Property [${key}] is deprecated.`, message].filter(Boolean).join(\" \");\n    Logger.warnOnce(msg);\n  };\n}\nfunction Deprecated(message, opts) {\n  const warnDeprecated = createDeprecationWarning();\n  const def = opts?.default;\n  return addTransformToInstanceProperty((_, key, value) => {\n    if (value !== def) {\n      warnDeprecated(key.toString(), message);\n    }\n    return value;\n  });\n}\nfunction DeprecatedAndRenamedTo(newPropName, mapValue) {\n  const warnDeprecated = createDeprecationWarning();\n  return addTransformToInstanceProperty(\n    (target, key, value) => {\n      if (value !== target[newPropName]) {\n        warnDeprecated(key.toString(), `Use [${newPropName}] instead.`);\n        setPath(target, newPropName, mapValue ? mapValue(value) : value);\n      }\n      return BREAK_TRANSFORM_CHAIN;\n    },\n    (target, key) => {\n      warnDeprecated(key.toString(), `Use [${newPropName}] instead.`);\n      return getPath(target, newPropName);\n    }\n  );\n}\n\n// packages/ag-charts-community/src/util/search.util.ts\nfunction findMaxValue(min, max, iteratee) {\n  if (min > max)\n    return;\n  let found;\n  while (max >= min) {\n    const index = Math.floor((max + min) / 2);\n    const value = iteratee(index);\n    if (value == null) {\n      max = index - 1;\n    } else {\n      found = value;\n      min = index + 1;\n    }\n  }\n  return found;\n}\n\n// packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeries.ts\nvar _HierarchyNode = class _HierarchyNode {\n  constructor(series, index, datum, size, colorValue, fill, stroke, sumSize, depth, parent, children) {\n    this.series = series;\n    this.index = index;\n    this.datum = datum;\n    this.size = size;\n    this.colorValue = colorValue;\n    this.fill = fill;\n    this.stroke = stroke;\n    this.sumSize = sumSize;\n    this.depth = depth;\n    this.parent = parent;\n    this.children = children;\n    this.midPoint = { x: 0, y: 0 };\n  }\n  contains(other) {\n    let current = other;\n    while (current != null && current.index >= this.index) {\n      if (current === this) {\n        return true;\n      }\n      current = current.parent;\n    }\n    return false;\n  }\n  walk(callback2, order = _HierarchyNode.Walk.PreOrder) {\n    if (order === _HierarchyNode.Walk.PreOrder) {\n      callback2(this);\n    }\n    this.children.forEach((child) => {\n      child.walk(callback2, order);\n    });\n    if (order === _HierarchyNode.Walk.PostOrder) {\n      callback2(this);\n    }\n  }\n  *[Symbol.iterator]() {\n    yield this;\n    for (const child of this.children) {\n      yield* child;\n    }\n  }\n};\n_HierarchyNode.Walk = {\n  PreOrder: 0,\n  PostOrder: 1\n};\nvar HierarchyNode = _HierarchyNode;\nvar HierarchySeries = class extends Series {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [3 /* NEAREST_NODE */, 0 /* EXACT_SHAPE_MATCH */],\n      contentGroupVirtual: false\n    });\n    this.rootNode = new HierarchyNode(\n      this,\n      0,\n      void 0,\n      0,\n      void 0,\n      void 0,\n      void 0,\n      0,\n      void 0,\n      void 0,\n      []\n    );\n    this.colorDomain = [0, 0];\n    this.maxDepth = 0;\n    this.focusPath = [];\n    this.animationState = new StateMachine(\n      \"empty\",\n      {\n        empty: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateEmptyUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        ready: {\n          updateData: \"waiting\",\n          clear: \"clearing\",\n          highlight: (data) => this.animateReadyHighlight(data),\n          resize: (data) => this.animateReadyResize(data),\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        waiting: {\n          update: {\n            target: \"ready\",\n            action: (data) => this.animateWaitingUpdateReady(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        },\n        clearing: {\n          update: {\n            target: \"empty\",\n            action: (data) => this.animateClearingUpdateEmpty(data)\n          },\n          reset: \"empty\",\n          skip: \"ready\"\n        }\n      },\n      () => this.checkProcessedDataAnimatable()\n    );\n  }\n  resetAnimation(phase) {\n    if (phase === \"initial\") {\n      this.animationState.transition(\"reset\");\n    } else if (phase === \"ready\") {\n      this.animationState.transition(\"skip\");\n    }\n  }\n  async processData() {\n    const { childrenKey, sizeKey, colorKey, fills, strokes, colorRange } = this.properties;\n    let index = 0;\n    const getIndex = () => {\n      index += 1;\n      return index;\n    };\n    let maxDepth = 0;\n    let minColor = Infinity;\n    let maxColor = -Infinity;\n    const colors = new Array((this.data?.length ?? 0) + 1).fill(void 0);\n    const createNode = (datum, parent) => {\n      const nodeIndex = getIndex();\n      const depth = parent.depth != null ? parent.depth + 1 : 0;\n      const children = childrenKey != null ? datum[childrenKey] : void 0;\n      const isLeaf = children == null || children.length === 0;\n      let size = sizeKey != null ? datum[sizeKey] : void 0;\n      if (Number.isFinite(size)) {\n        size = Math.max(size, 0);\n      } else {\n        size = isLeaf ? 1 : 0;\n      }\n      const sumSize = size;\n      maxDepth = Math.max(maxDepth, depth);\n      const color = colorKey != null ? datum[colorKey] : void 0;\n      if (typeof color === \"number\") {\n        colors[nodeIndex] = color;\n        minColor = Math.min(minColor, color);\n        maxColor = Math.max(maxColor, color);\n      }\n      return appendChildren(\n        new HierarchyNode(\n          this,\n          nodeIndex,\n          datum,\n          size,\n          color,\n          void 0,\n          void 0,\n          sumSize,\n          depth,\n          parent,\n          []\n        ),\n        children\n      );\n    };\n    const appendChildren = (node, data) => {\n      data?.forEach((datum) => {\n        const child = createNode(datum, node);\n        node.children.push(child);\n        node.sumSize += child.sumSize;\n      });\n      return node;\n    };\n    const rootNode = appendChildren(\n      new HierarchyNode(\n        this,\n        0,\n        void 0,\n        0,\n        void 0,\n        void 0,\n        void 0,\n        0,\n        void 0,\n        void 0,\n        []\n      ),\n      this.data\n    );\n    const colorDomain = [minColor, maxColor];\n    let colorScale;\n    if (colorRange != null && Number.isFinite(minColor) && Number.isFinite(maxColor)) {\n      colorScale = new ColorScale();\n      colorScale.domain = colorDomain;\n      colorScale.range = colorRange;\n      colorScale.update();\n    }\n    rootNode.children.forEach((child, childIndex) => {\n      child.walk((node) => {\n        let fill;\n        const color = colors[node.index];\n        if (color != null) {\n          fill = colorScale?.convert(color);\n        }\n        fill ?? (fill = fills?.[childIndex % fills.length]);\n        node.fill = fill;\n        node.stroke = colorScale == null ? strokes?.[childIndex % strokes.length] : \"rgba(0, 0, 0, 0.2)\";\n      });\n    });\n    this.rootNode = rootNode;\n    this.maxDepth = maxDepth;\n    this.colorDomain = colorDomain;\n    this.focusPath = [{ nodeDatum: this.rootNode, childIndex: 0 }];\n  }\n  async update({ seriesRect }) {\n    await this.updateSelections();\n    await this.updateNodes();\n    const animationData = this.getAnimationData();\n    const resize = this.checkResize(seriesRect);\n    if (resize) {\n      this.animationState.transition(\"resize\", animationData);\n    }\n    this.animationState.transition(\"update\", animationData);\n  }\n  resetAllAnimation(data) {\n    const datum = this.animationResetFns?.datum;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    if (datum != null) {\n      resetMotion(data.datumSelections, datum);\n    }\n  }\n  animateEmptyUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateWaitingUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateReadyHighlight(data) {\n    const datum = this.animationResetFns?.datum;\n    if (datum != null) {\n      resetMotion([data], datum);\n    }\n  }\n  animateReadyResize(data) {\n    this.resetAllAnimation(data);\n  }\n  animateClearingUpdateEmpty(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animationTransitionClear() {\n    this.animationState.transition(\"clear\", this.getAnimationData());\n  }\n  getAnimationData() {\n    const animationData = {\n      datumSelections: [this.groupSelection]\n    };\n    return animationData;\n  }\n  isProcessedDataAnimatable() {\n    return true;\n  }\n  checkProcessedDataAnimatable() {\n    if (!this.isProcessedDataAnimatable()) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  getLabelData() {\n    return [];\n  }\n  getSeriesDomain() {\n    return [NaN, NaN];\n  }\n  getLegendData(legendType) {\n    const { colorKey, colorName, colorRange, visible } = this.properties;\n    return legendType === \"gradient\" && colorKey != null && colorRange != null ? [\n      {\n        legendType: \"gradient\",\n        enabled: visible,\n        seriesId: this.id,\n        colorName,\n        colorRange,\n        colorDomain: this.colorDomain\n      }\n    ] : [];\n  }\n  getDatumIdFromData(node) {\n    return `${node.index}`;\n  }\n  getDatumId(node) {\n    return this.getDatumIdFromData(node);\n  }\n  pickFocus(opts) {\n    if (this.rootNode.children.length === 0)\n      return void 0;\n    if (this.focusPath.length === 0) {\n      Logger.error(\"this.focusPath should not be empty\");\n    }\n    const { datumIndexDelta: childDelta, otherIndexDelta: depthDelta } = opts;\n    const { focusPath: path } = this;\n    const depth = path.length - 2;\n    if (depthDelta !== 0 || path.length === 1) {\n      const targetDepth = Math.max(0, depth + depthDelta);\n      if (path[targetDepth + 1] !== void 0) {\n        path.length = targetDepth + 2;\n        return this.computeFocusOutputs(path[targetDepth + 1]);\n      } else {\n        let deepest = path[path.length - 1];\n        while (deepest.nodeDatum.children.length > 0 && (deepest.nodeDatum.depth ?? -1) < targetDepth) {\n          const nextDeepest = { nodeDatum: deepest.nodeDatum.children[0], childIndex: 0 };\n          path.push(nextDeepest);\n          deepest = nextDeepest;\n        }\n        return this.computeFocusOutputs(deepest);\n      }\n    } else if (childDelta !== 0) {\n      const targetChild = path[depth + 1].childIndex + childDelta;\n      const currentParent = path[depth].nodeDatum;\n      const childCount = currentParent?.children?.length;\n      if (childCount !== void 0) {\n        const newChild = clamp(0, targetChild, childCount - 1);\n        const newFocus = { nodeDatum: currentParent.children[newChild], childIndex: newChild };\n        path[depth + 1] = newFocus;\n        path.length = depth + 2;\n        return this.computeFocusOutputs(newFocus);\n      }\n    } else {\n      return this.computeFocusOutputs(path[path.length - 1]);\n    }\n  }\n  getDatumAriaText(datum, description) {\n    if (!(datum instanceof HierarchyNode)) {\n      Logger.error(`datum is not HierarchyNode: ${datum}`);\n      return;\n    }\n    return this.ctx.localeManager.t(\"ariaAnnounceHierarchyDatum\", {\n      level: (datum.depth ?? -1) + 1,\n      count: datum.children.length,\n      description\n    });\n  }\n  computeFocusOutputs({ nodeDatum, childIndex }) {\n    const bounds = this.computeFocusBounds(nodeDatum);\n    if (bounds) {\n      return {\n        datum: nodeDatum,\n        datumIndex: childIndex,\n        otherIndex: nodeDatum.depth,\n        bounds,\n        showFocusBox: true\n      };\n    }\n    return void 0;\n  }\n};\n\n// packages/ag-charts-community/src/chart/series/hierarchy/hierarchySeriesProperties.ts\nvar HierarchySeriesProperties = class extends SeriesProperties {\n  constructor() {\n    super(...arguments);\n    this.childrenKey = \"children\";\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n  }\n};\n__decorateClass([\n  Validate(STRING)\n], HierarchySeriesProperties.prototype, \"childrenKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HierarchySeriesProperties.prototype, \"sizeKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HierarchySeriesProperties.prototype, \"colorKey\", 2);\n__decorateClass([\n  Validate(STRING, { optional: true })\n], HierarchySeriesProperties.prototype, \"colorName\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], HierarchySeriesProperties.prototype, \"fills\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY)\n], HierarchySeriesProperties.prototype, \"strokes\", 2);\n__decorateClass([\n  Validate(COLOR_STRING_ARRAY, { optional: true })\n], HierarchySeriesProperties.prototype, \"colorRange\", 2);\n\n// packages/ag-charts-community/src/chart/series/topology/lonLatBbox.ts\nvar LonLatBBox = class {\n  constructor(lon0, lat0, lon1, lat1) {\n    this.lon0 = lon0;\n    this.lat0 = lat0;\n    this.lon1 = lon1;\n    this.lat1 = lat1;\n  }\n  merge(other) {\n    this.lon0 = Math.min(this.lon0, other.lon0);\n    this.lat0 = Math.min(this.lat0, other.lat0);\n    this.lon1 = Math.max(this.lon1, other.lon1);\n    this.lat1 = Math.max(this.lat1, other.lat1);\n  }\n};\n\n// packages/ag-charts-community/src/util/tempUtils.ts\nfunction createIdsGenerator() {\n  const idsCounter = /* @__PURE__ */ new Map();\n  return (name) => {\n    const counter = idsCounter.get(name);\n    if (counter) {\n      idsCounter.set(name, counter + 1);\n      return `${name}${counter}`;\n    }\n    idsCounter.set(name, 1);\n    return name;\n  };\n}\n\n// packages/ag-charts-community/src/chart/axis/axisTicks.ts\nvar _AxisTicks = class _AxisTicks {\n  constructor() {\n    this.id = createId(this);\n    this.axisGroup = new Group({ name: `${this.id}-AxisTicks`, zIndex: 2 /* AXIS_ZINDEX */ });\n    this.labelSelection = Selection.select(this.axisGroup, Text, false);\n    this.interval = new AxisInterval();\n    this.label = new AxisLabel();\n    this.scale = new LinearScale();\n    this.position = \"bottom\";\n    this.translationX = 0;\n    this.translationY = 0;\n    this.padding = 0;\n  }\n  attachAxis(axisNode) {\n    axisNode.appendChild(this.axisGroup);\n  }\n  calculateLayout() {\n    this.scale.interval = this.interval.step;\n    const boxes = [];\n    const tickData = this.generateTicks();\n    const { translationX, translationY } = this;\n    this.labelSelection.update(\n      tickData.ticks.map((d) => this.createLabelDatum(d)),\n      (group) => group.appendChild(new Text()),\n      (datum) => datum.tickId\n    );\n    this.labelSelection.each((node, datum) => {\n      node.setProperties(datum);\n      if (datum.visible) {\n        boxes.push(node.getBBox());\n      }\n    });\n    this.axisGroup.setProperties({ translationX, translationY });\n    return BBox.merge(boxes);\n  }\n  getLabelParams(datum) {\n    const { padding } = this;\n    const { translate } = datum;\n    switch (this.position) {\n      case \"top\":\n      case \"bottom\":\n        return {\n          x: translate,\n          y: padding,\n          textAlign: \"center\",\n          textBaseline: \"top\"\n        };\n      case \"left\":\n      case \"right\":\n        return {\n          x: padding,\n          y: translate,\n          textAlign: \"start\",\n          textBaseline: \"middle\"\n        };\n    }\n  }\n  inRange(x, tolerance = 1e-3) {\n    const [min, max] = findMinMax(this.scale.range);\n    return x >= min - tolerance && x <= max + tolerance;\n  }\n  createLabelDatum(datum) {\n    const { x, y, textBaseline, textAlign } = this.getLabelParams(datum);\n    return {\n      visible: Boolean(datum.tickLabel),\n      tickId: datum.tickId,\n      fill: this.label.color,\n      fontFamily: this.label.fontFamily,\n      fontSize: this.label.fontSize,\n      fontStyle: this.label.fontStyle,\n      fontWeight: this.label.fontWeight,\n      rotation: 0,\n      rotationCenterX: 0,\n      text: datum.tickLabel,\n      textAlign,\n      textBaseline,\n      x,\n      y\n    };\n  }\n  generateTicks() {\n    const { minSpacing, maxSpacing } = this.interval;\n    const extentWithBleed = round(findRangeExtent(this.scale.range), 2);\n    const { maxTickCount, minTickCount, tickCount } = estimateTickCount(\n      extentWithBleed,\n      minSpacing,\n      maxSpacing,\n      _AxisTicks.DefaultTickCount,\n      _AxisTicks.DefaultMinSpacing\n    );\n    if (tickCount) {\n      this.scale.tickCount = tickCount;\n      this.scale.minTickCount = minTickCount;\n      this.scale.maxTickCount = maxTickCount;\n    }\n    const tickData = this.getTicksData();\n    if (this.position === \"bottom\" || this.position === \"top\") {\n      const measurer = CachedTextMeasurerPool.getMeasurer({ font: this.label });\n      let lastTickPosition = -Infinity;\n      tickData.ticks = tickData.ticks.filter((data) => {\n        if (lastTickPosition < data.translate) {\n          lastTickPosition = data.translate + measurer.textWidth(data.tickLabel, true);\n          return true;\n        }\n      });\n    }\n    return tickData;\n  }\n  getTicksData() {\n    const ticks = [];\n    const rawTicks = this.scale.ticks();\n    const fractionDigits = rawTicks.reduce((max, tick) => Math.max(max, countFractionDigits(tick)), 0);\n    const idGenerator = createIdsGenerator();\n    const labelFormatter = this.label.format ? this.scale.tickFormat({ ticks: rawTicks, specifier: this.label.format }) : (x) => isNumber(x) ? x.toFixed(fractionDigits) : String(x);\n    for (let index = 0; index < rawTicks.length; index++) {\n      const tick = rawTicks[index];\n      const translate = this.scale.convert(tick);\n      if (!this.inRange(translate))\n        continue;\n      const tickLabel = this.label.formatter?.({ value: tick, index, fractionDigits }) ?? labelFormatter(tick);\n      const tickId = idGenerator(tickLabel);\n      ticks.push({ tick, tickId, tickLabel, translate });\n    }\n    return { rawTicks, fractionDigits, ticks };\n  }\n};\n_AxisTicks.DefaultTickCount = 5;\n_AxisTicks.DefaultMinSpacing = 50;\nvar AxisTicks = _AxisTicks;\n\n// packages/ag-charts-community/src/chart/legendDatum.ts\nvar __FORCE_MODULE_DETECTION = 0;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWctY2hhcnRzLWNvbW11bml0eS9kaXN0L3BhY2thZ2UvbWFpbi5lc20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFFBQVE7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQztBQUNBLHVDQUF1QyxNQUFNLFlBQVksTUFBTSxxQkFBcUIsWUFBWTtBQUNoRztBQUNBLDBDQUEwQyxPQUFPLEtBQUssTUFBTSxTQUFTLE1BQU0sS0FBSyxHQUFHLElBQUksVUFBVSxFQUFFLEtBQUs7QUFDeEc7QUFDQSwwQ0FBMEMsT0FBTyxLQUFLLE1BQU0sSUFBSSxZQUFZO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixNQUFNLGdCQUFnQixNQUFNLGNBQWMsTUFBTTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsSUFBSSxlQUFlLElBQUk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDZCQUE2Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQ0FBa0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUNBQW1DLFFBQVE7QUFDM0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHNFQUFzRSxRQUFRO0FBQzlFLEdBQUc7QUFDSDtBQUNBLHdFQUF3RSxRQUFRO0FBQ2hGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsV0FBVyxnQkFBZ0IsS0FBSztBQUMzRTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVLEdBQUcsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGVBQWU7QUFDekIsbUJBQW1CO0FBQ25CO0FBQ0EsWUFBWSw2Q0FBNkM7QUFDekQ7QUFDQSxlQUFlO0FBQ2YsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0JBQWtCO0FBQ25CO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUseUJBQXlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUNBQXFDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsMkJBQTJCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDJCQUEyQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyQkFBMkI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHFCQUFxQjtBQUN0QjtBQUNBLGdCQUFnQiwrQkFBK0IsSUFBSTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLE1BQU0scUNBQXFDLFlBQVk7QUFDbEY7QUFDQTtBQUNBLDJCQUEyQixNQUFNLDhCQUE4QixrQkFBa0I7QUFDakY7QUFDQTtBQUNBLHFDQUFxQyx1QkFBdUIsUUFBUSxLQUFLO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxr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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxXQUFXO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQkFBa0I7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsMkNBQTJDLElBQUk7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTiwwQkFBMEIsZUFBZSxFQUFFLHdCQUF3QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsY0FBYztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUE4QjtBQUN4QyxZQUFZLDZDQUE2QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFVBQVUsb0JBQW9CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxxQkFBcUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBLHNCQUFzQixVQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3REFBd0Q7QUFDcEU7QUFDQTtBQUNBLDhDQUE4Qyw2REFBNkQsa0NBQWtDLG9EQUFvRDtBQUNqTSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLHdDQUF3QyxvREFBb0Q7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwrQkFBK0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDhDQUE4QyxzREFBc0Q7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLCtCQUErQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLFlBQVks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TUFBTTtBQUNOO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGdCQUFnQjtBQUMzRDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDRCQUE0QjtBQUMxRSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDBEQUEwRDtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZDQUE2QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLHdEQUF3RDtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25ELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksd0RBQXdEO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLFFBQVE7QUFDUjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBLCtCQUErQixXQUFXO0FBQzFDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBDQUEwQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBeUQ7QUFDckUsNEJBQTRCO0FBQzVCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsaUVBQWlFLHVCQUF1QjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsWUFBWTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdDQUFnQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsbUVBQW1FO0FBQ3hHLGlDQUFpQyx3REFBd0Q7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsR0FBRztBQUNqRSxxQ0FBcUMseUJBQXlCO0FBQzlELE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxHQUFHO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDBCQUEwQixPQUFPLEdBQUc7QUFDakYsTUFBTTtBQUNOLG1EQUFtRCxHQUFHO0FBQ3RELDBEQUEwRCxNQUFNO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELEdBQUc7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsNE5BQTROLHNCQUFzQixhQUFhLG1CQUFtQixrQkFBa0IseUJBQXlCLFdBQVcsWUFBWSxrQkFBa0Isa0JBQWtCLGFBQWEsbUNBQW1DLHlDQUF5Qyw4Q0FBOEMsa0JBQWtCLGtEQUFrRCxjQUFjLHdCQUF3QixrQkFBa0IsTUFBTSxPQUFPLFVBQVUsb0JBQW9CLHFCQUFxQixRQUFRLFNBQVMsVUFBVSwwQkFBMEIsb0JBQW9CLGtCQUFrQixRQUFRLDRCQUE0QixrQkFBa0Isb0JBQW9CLHVEQUF1RCwwREFBMEQsK0RBQStELGtFQUFrRSwwREFBMEQsK0NBQStDLGlEQUFpRCwyQ0FBMkMsK0VBQStFLG1FQUFtRSxnQ0FBZ0MsNkJBQTZCLDZCQUE2QiwrQkFBK0IsaUNBQWlDLDBCQUEwQiw0QkFBNEIsaURBQWlELHNDQUFzQywyR0FBMkcsdUtBQXVLLCtCQUErQixxQ0FBcUMsc0dBQXNHLDRIQUE0SCwrREFBK0Qsa0ZBQWtGLGdFQUFnRSxxS0FBcUssNkpBQTZKLCtDQUErQyxvQ0FBb0MsMENBQTBDLHdDQUF3Qyw4Q0FBOEMsZ0ZBQWdGLGdGQUFnRiw0REFBNEQsd0VBQXdFLHNFQUFzRSw4RkFBOEYsOEVBQThFLHdEQUF3RCxrR0FBa0csd0VBQXdFLHNMQUFzTCxnREFBZ0QscUNBQXFDLHFHQUFxRyw0QkFBNEIsa0RBQWtELDhCQUE4QixnR0FBZ0csK0RBQStELDJFQUEyRSx5SEFBeUgsaURBQWlELHNDQUFzQywrR0FBK0csNEhBQTRILHNMQUFzTCxrREFBa0QsZ0JBQWdCLGNBQWMsaUNBQWlDLGtDQUFrQyxXQUFXLFlBQVksNENBQTRDLDhCQUE4Qiw2Q0FBNkMsbUNBQW1DLCtCQUErQiw2cUJBQTZxQixtQ0FBbUMsK0JBQStCLHlVQUF5VSxtQ0FBbUMsK0JBQStCLGl4QkFBaXhCLG1DQUFtQywrQkFBK0IseVRBQXlULHVCQUF1QiwrQkFBK0IsNjVCQUE2NUIsMEVBQTBFLCtCQUErQixpMkJBQWkyQiwwQ0FBMEMsK0JBQStCLHFaQUFxWix3RUFBd0UsK0JBQStCLGlZQUFpWSwyQkFBMkIsK0JBQStCLDZ3QkFBNndCLDRCQUE0QiwrQkFBK0IseVVBQXlVLHlDQUF5QywrQkFBK0IsaW5CQUFpbkIsNENBQTRDLCtCQUErQiw2bkJBQTZuQixnQ0FBZ0MsK0JBQStCLHF4QkFBcXhCLDRCQUE0QiwrQkFBK0IsaVBBQWlQLDJCQUEyQiwrQkFBK0IsNmxDQUE2bEMsd0JBQXdCLCtCQUErQiw2YkFBNmIseUJBQXlCLCtCQUErQixpU0FBaVMsMEJBQTBCLCtCQUErQixxU0FBcVMsMEJBQTBCLCtCQUErQix5UEFBeVAsMEVBQTBFLCtCQUErQixxeUJBQXF5Qix1Q0FBdUMsK0JBQStCLHErQkFBcStCLHNCQUFzQiwrQkFBK0IsNmtCQUE2a0IsaUNBQWlDLCtCQUErQixxUUFBcVEsZ0NBQWdDLCtCQUErQiw2U0FBNlMsOERBQThELCtCQUErQixxYkFBcWIsZ0RBQWdELCtCQUErQix5bkJBQXluQixvRUFBb0UsK0JBQStCLGlZQUFpWSx3QkFBd0IsK0JBQStCLHlUQUF5VCx5QkFBeUIsK0JBQStCLDZSQUE2UixnQ0FBZ0MsK0JBQStCLHlSQUF5UiwyQkFBMkIsK0JBQStCLHFxQkFBcXFCLCtCQUErQiwrQkFBK0IsaVhBQWlYLGdDQUFnQywrQkFBK0IsNlNBQTZTLCtEQUErRCwrQkFBK0IscWZBQXFmLGlFQUFpRSwrQkFBK0IscWNBQXFjLDZCQUE2QiwrQkFBK0IscWVBQXFlLGdDQUFnQywrQkFBK0IsNldBQTZXLGlDQUFpQywrQkFBK0IsNldBQTZXLGlDQUFpQywrQkFBK0IsaVhBQWlYLCtCQUErQiwrQkFBK0IsNldBQTZXLGtDQUFrQywrQkFBK0IsNldBQTZXLHVDQUF1QywrQkFBK0IsaWFBQWlhLHFDQUFxQywrQkFBK0IsNlpBQTZaLHdDQUF3QywrQkFBK0IsNnVCQUE2dUIsd0NBQXdDLCtCQUErQixpdUJBQWl1QixrQ0FBa0MsK0JBQStCLDYrQkFBNitCLDhCQUE4QiwrQkFBK0IsaXFDQUFpcUMsNEJBQTRCLCtCQUErQiw2dkJBQTZ2Qiw4QkFBOEIsK0JBQStCLGkzQkFBaTNCLDRCQUE0QiwrQkFBK0IsNlZBQTZWLDBDQUEwQywrQkFBK0IsNldBQTZXLDRDQUE0QyxrQkFBa0IsY0FBYyxvQkFBb0IsaUJBQWlCLFdBQVcsWUFBWSxnREFBZ0Qsa0JBQWtCLHNDQUFzQyxrQkFBa0IsZ0RBQWdELGdEQUFnRCxXQUFXLFlBQVksVUFBVSwyQ0FBMkMsaUJBQWlCLHlCQUF5QixrQkFBa0IsbUJBQW1CLG1CQUFtQixnQkFBZ0IsWUFBWSxhQUFhLGlCQUFpQixVQUFVLGtCQUFrQix3QkFBd0IsNkRBQTZELDZEQUE2RCxrQkFBa0Isb0NBQW9DLFVBQVUsbUNBQW1DLDBCQUEwQiw4REFBOEQsd0VBQXdFLGtGQUFrRixtREFBbUQsbUJBQW1CLFdBQVcsbURBQW1ELHNCQUFzQixrR0FBa0csZ0JBQWdCLFlBQVksbUJBQW1CLG9CQUFvQixXQUFXLDZCQUE2QixVQUFVLFdBQVcsdUNBQXVDLGlDQUFpQyxrREFBa0QsaUJBQWlCLG9DQUFvQyxrREFBa0Qsb0JBQW9CLGdCQUFnQiwwQkFBMEIsYUFBYSx1QkFBdUIsa0JBQWtCLGlDQUFpQyxlQUFlLFdBQVcsaUNBQWlDLHNCQUFzQixrQ0FBa0MsdUJBQXVCLCtCQUErQixvQkFBb0IsaUVBQWlFLGlCQUFpQix3T0FBd08sY0FBYyxnQkFBZ0IseUhBQXlILHFDQUFxQyxXQUFXLDRCQUE0QixnQkFBZ0IsdUJBQXVCLGtCQUFrQix3QkFBd0Isa0JBQWtCLGNBQWMsMkJBQTJCLHVHQUF1RyxtQkFBbUIscURBQXFELHVDQUF1QyxnREFBZ0QsYUFBYSxxRUFBcUUsdUJBQXVCLGtCQUFrQix5Q0FBeUMsd0NBQXdDLGdEQUFnRCxtQkFBbUIsa0JBQWtCLDZCQUE2QixtQkFBbUIsc0RBQXNELG9HQUFvRyxxSkFBcUosMkZBQTJGLHlEQUF5RCxzREFBc0QsU0FBUyxnR0FBZ0csMERBQTBELHdEQUF3RCxtREFBbUQsMkJBQTJCLGdCQUFnQixnQkFBZ0IsZUFBZSwyRkFBMkYsc0RBQXNELHVEQUF1RCxTQUFTLGdHQUFnRyx5REFBeUQsMkRBQTJELG9GQUFvRixhQUFhLGlDQUFpQyxnREFBZ0QsVUFBVSx5Q0FBeUMsa0RBQWtELGdEQUFnRCxVQUFVLDZEQUE2RCw0REFBNEQsbURBQW1ELDRDQUE0QyxVQUFVLCtDQUErQyw4REFBOEQseURBQXlELHFEQUFxRCxlQUFlLCtDQUErQyxXQUFXLGNBQWMsa0JBQWtCLFdBQVcsU0FBUyxVQUFVLFdBQVcsbUJBQW1CLGdHQUFnRyx1QkFBdUIsbUVBQW1FLG9CQUFvQixXQUFXLG1EQUFtRCx5Q0FBeUMsbURBQW1ELG9CQUFvQixrQkFBa0IsY0FBYyxvQkFBb0Isd0NBQXdDLFdBQVcsMkJBQTJCLGNBQWMsc0NBQXNDLGdCQUFnQixvQkFBb0IsOEVBQThFLG1CQUFtQixrQkFBa0IsOEJBQThCLGtCQUFrQixjQUFjLDZCQUE2QixjQUFjLCtCQUErQiw4QkFBOEIseUJBQXlCLHNCQUFzQixhQUFhLGlDQUFpQyx5QkFBeUIsc0JBQXNCLGFBQWEsZ0NBQWdDLHFCQUFxQixrQkFBa0IsNkJBQTZCLGdCQUFnQix1QkFBdUIsaUNBQWlDLG9CQUFvQixpQkFBaUIsK0JBQStCLDBCQUEwQix5QkFBeUIsa0JBQWtCLHdCQUF3QixnQkFBZ0Isa0JBQWtCLGlCQUFpQiwyQkFBMkIsNEJBQTRCLFdBQVcsc0JBQXNCLFVBQVUsc0JBQXNCLG1DQUFtQyw4QkFBOEIsK0JBQStCLDBCQUEwQixnQkFBZ0IsaUJBQWlCLGtCQUFrQixnQkFBZ0IsOEJBQThCLCtCQUErQixpQ0FBaUMsc0JBQXNCLCtCQUErQixXQUFXLGtCQUFrQixTQUFTLFNBQVMsMEJBQTBCLHlCQUF5Qiw4QkFBOEIsK0JBQStCLGdDQUFnQyxRQUFRLFNBQVMsY0FBYyw4QkFBOEIsV0FBVyxrQkFBa0IscUJBQXFCLFNBQVMsMEJBQTBCLHVCQUF1Qiw4QkFBOEIsK0JBQStCLGdDQUFnQyxRQUFRLFNBQVMsY0FBYzs7QUFFbmkyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzRUFBc0U7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjtBQUMxQyxlQUFlLDJEQUEyRDtBQUMxRSxxQkFBcUIseUJBQXlCO0FBQzlDLHVCQUF1Qix5QkFBeUI7QUFDaEQsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEVBQUU7QUFDeEMsNkdBQTZHLFNBQVM7QUFDdEg7QUFDQSxvRUFBb0UsU0FBUztBQUM3RSxpQkFBaUI7QUFDakI7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxnQkFBZ0I7QUFDNUQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIscUJBQXFCLHlCQUF5QjtBQUM5QyxzQkFBc0IsMkJBQTJCO0FBQ2pEO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQywyQkFBMkIsK0JBQStCO0FBQzFELDRCQUE0QixnQ0FBZ0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGdCQUFnQjtBQUMxRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsMkJBQTJCO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0JBQW9CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlDQUF5QztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEtBQUs7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlFQUFpRTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQSwyQ0FBMkMsa0RBQWtEO0FBQzdGLE1BQU07QUFDTjtBQUNBLDJDQUEyQyxrREFBa0Q7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLHdCQUF3QjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsY0FBYyxpQ0FBaUM7QUFDL0MsZUFBZTtBQUNmLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0EsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQ0FBZ0M7QUFDNUMsVUFBVSxpQ0FBaUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2Y7QUFDQSxnQkFBZ0IsaUNBQWlDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0EsNENBQTRDLE9BQU8sa0JBQWtCLEdBQUc7QUFDeEU7QUFDQTtBQUNBLCtDQUErQyxVQUFVLGtCQUFrQixHQUFHO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsMEJBQTBCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxhQUFhO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFFQUFxRTtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsNkJBQTZCLHVFQUF1RTtBQUNwRztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUNBQXVDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw0Q0FBNEM7QUFDbEY7QUFDQTtBQUNBLHlDQUF5QywrQ0FBK0M7QUFDeEY7QUFDQTtBQUNBLCtCQUErQixxQ0FBcUM7QUFDcEU7QUFDQTtBQUNBLGlDQUFpQyx1Q0FBdUM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsU0FBUyxJQUFJLFNBQVM7QUFDaEc7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx3QkFBd0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsTUFBTTtBQUNqRSx3Q0FBd0MsYUFBYSxxQ0FBcUMsVUFBVTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2REFBNkQsc0JBQXNCLGNBQWM7QUFDakc7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQTBEO0FBQ3RFO0FBQ0EsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTLDJCQUEyQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG1DQUFtQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUNBQW1DO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSx3Q0FBd0MsYUFBYSxTQUFTLFlBQVksSUFBSSxPQUFPO0FBQ3JGLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLEtBQUs7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxJQUFJO0FBQzdDO0FBQ0EsaUJBQWlCLHFDQUFxQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQseUJBQXlCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsYUFBYTtBQUMxRDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQSxpRkFBaUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQ0FBbUMsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLG9CQUFvQjtBQUM1RDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxTQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxJQUFJLG9FQUFvRTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsSUFBSSw0RkFBNEY7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsSUFBSSw2REFBNkQ7QUFDakUsSUFBSSx5RUFBeUU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxJQUFJLGdHQUFnRztBQUNwRyxJQUFJLHlGQUF5RjtBQUM3RixJQUFJLHVGQUF1RjtBQUMzRixJQUFJLDBGQUEwRjtBQUM5RixJQUFJLHdGQUF3RjtBQUM1RixJQUFJLDJGQUEyRjtBQUMvRixJQUFJLHlFQUF5RTtBQUM3RSxJQUFJLDJGQUEyRjtBQUMvRixJQUFJLDhGQUE4RjtBQUNsRyxJQUFJLHVGQUF1RjtBQUMzRixJQUFJLHlGQUF5RjtBQUM3RixJQUFJLDBGQUEwRjtBQUM5RixJQUFJLDZGQUE2RjtBQUNqRyxJQUFJLDRGQUE0RjtBQUNoRyxJQUFJLDRGQUE0RjtBQUNoRyxJQUFJLDBGQUEwRjtBQUM5RixJQUFJLHlGQUF5RjtBQUM3RixJQUFJLHlGQUF5RjtBQUM3RixJQUFJLHlGQUF5RjtBQUM3RixJQUFJLDRGQUE0RjtBQUNoRyxJQUFJLDJGQUEyRjtBQUMvRixJQUFJLDBGQUEwRjtBQUM5RixJQUFJLDJGQUEyRjtBQUMvRixJQUFJLDBGQUEwRjtBQUM5RixJQUFJLDRGQUE0RjtBQUNoRyxJQUFJLHNHQUFzRztBQUMxRyxJQUFJLHFHQUFxRztBQUN6RyxJQUFJLDhGQUE4RjtBQUNsRyxJQUFJLCtGQUErRjtBQUNuRyxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBDQUEwQztBQUNuRSxxQ0FBcUMsMkJBQTJCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFdBQVc7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFlBQVk7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLCtCQUErQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsa0NBQWtDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsd0RBQXdEO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0EsVUFBVSw0QkFBNEI7QUFDdEMsVUFBVSwwREFBMEQ7QUFDcEUsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsNERBQTREO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCw4RkFBOEYsWUFBWTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsTUFBTTtBQUNOO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxnQ0FBZ0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQyxjQUFjLDJDQUEyQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQ0FBMkM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0JBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0RBQW9EO0FBQ2hFLFVBQVUsYUFBYTtBQUN2QixZQUFZLCtCQUErQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQixZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxpRkFBaUY7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGlDQUFpQyw0QkFBNEI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQ0FBa0M7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsV0FBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksMkJBQTJCO0FBQ3ZDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkIsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sb0RBQW9ELGVBQWU7QUFDbkUsb0RBQW9ELGdDQUFnQztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCO0FBQzVFOztBQUVBO0FBQ0EsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSxtREFBbUQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0NBQWdDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnREFB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMkJBQTJCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixlQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q3ZELFVBQVUsa0NBQWtDO0FBQzVDO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUNBQXFDO0FBQy9DLFVBQVUsaUNBQWlDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsNERBQTREO0FBQzVELFVBQVUsc0RBQXNEO0FBQ2hFO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxN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QUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQSw4QkFBOEIsZ0JBQWdCO0FBQzlDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDLGFBQWE7QUFDYjtBQUNBLDhCQUE4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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3RkFBd0Y7QUFDcEcsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlEQUFpRDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0Esa0RBQWtELE1BQU07QUFDeEQ7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztB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Q1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0IsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFD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QUE2QixLQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsNEJBQTRCO0FBQ3hGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGFBQWE7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNw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Q1AsUUFBUTtBQUNSO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGlDQUFpQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3Q0FBd0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0IsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhDQUE4QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0dBQXNHO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsUUFBUSxVQUFVLGlCQUFpQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckMsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSxJQUFJO0FBQ0osb0JBQW9CLGlCQUFpQjtBQUNyQyxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsSUFBSTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxZQUFZO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkRBQTZEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5Q0FBeUM7QUFDakU7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkNBQTJDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkRBQTJEO0FBQ3ZFLFlBQVksa0JBQWtCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE1BQU07QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUssRUFBRSxRQUFRO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsU0FBUyxRQUFRLDBDQUEwQztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG1DQUFtQyw0QkFBNEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdDQUFnQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBLFlBQVksd0NBQXdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGtCQUFrQjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSwrQ0FBK0M7QUFDdEgsd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxvQ0FBb0M7QUFDckY7QUFDQSxtQkFBbUIsb0NBQW9DO0FBQ3ZEO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQWVFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hZy1jaGFydHMtY29tbXVuaXR5L2Rpc3QvcGFja2FnZS9tYWluLmVzbS5tanM/N2I4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xudmFyIF9fZGVjb3JhdGVDbGFzcyA9IChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwga2luZCkgPT4ge1xuICB2YXIgcmVzdWx0ID0ga2luZCA+IDEgPyB2b2lkIDAgOiBraW5kID8gX19nZXRPd25Qcm9wRGVzYyh0YXJnZXQsIGtleSkgOiB0YXJnZXQ7XG4gIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDEsIGRlY29yYXRvcjsgaSA+PSAwOyBpLS0pXG4gICAgaWYgKGRlY29yYXRvciA9IGRlY29yYXRvcnNbaV0pXG4gICAgICByZXN1bHQgPSAoa2luZCA/IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcmVzdWx0KSA6IGRlY29yYXRvcihyZXN1bHQpKSB8fCByZXN1bHQ7XG4gIGlmIChraW5kICYmIHJlc3VsdClcbiAgICBfX2RlZlByb3AodGFyZ2V0LCBrZXksIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtbG9jYWxlL3NyYy9lbi1VUy50c1xudmFyIEFHX0NIQVJUU19MT0NBTEVfRU5fVVMgPSB7XG4gIC8vIFNjcmVlbiByZWFkZXIgYW5ub3VuY2VtZW50IHdoZW4gdGhlIGZvY3VzZWQgaXRlbSBiZWNvbWVzIHZpc2libGVcbiAgYXJpYUFubm91bmNlVmlzaWJsZTogXCJ2aXNpYmxlXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgYW5ub3VuY2VtZW50IHdoZW4gdGhlIGZvY3VzZWQgaXRlbSBiZWNvbWVzIGhpZGRlblxuICBhcmlhQW5ub3VuY2VIaWRkZW46IFwiaGlkZGVuXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgYW5ub3VuY2VtZW50IHdoZW4gZm9jdXNpbmcgYW4gaXRlbSBpbiB0aGUgY2hhcnRcbiAgYXJpYUFubm91bmNlSG92ZXJEYXR1bTogXCIke2RhdHVtfVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIGFubm91bmNlbWVudCB3aGVuIGZvY3VzaW5nIGEgY2hhcnRcbiAgYXJpYUFubm91bmNlQ2hhcnQ6IFwiY2hhcnQsICR7c2VyaWVzQ291bnR9W251bWJlcl0gc2VyaWVzXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgYW5ub3VuY2VtZW50IHdoZW4gZm9jdXNpbmcgYW4gaXRlbSBpbiBhIHRyZWVtYXAgb3Igc3VuYnVyc3QgY2hhcnRcbiAgYXJpYUFubm91bmNlSGllcmFyY2h5RGF0dW06IFwibGV2ZWwgJHtsZXZlbH1bbnVtYmVyXSwgJHtjb3VudH1bbnVtYmVyXSBjaGlsZHJlbiwgJHtkZXNjcmlwdGlvbn1cIixcbiAgLy8gU2NyZWVuIHJlYWRlciBhbm5vdW5jZW1lbnQgd2hlbiBmb2N1c2luZyBhIGxpbmsgaW4gYSBTYW5rZXkgb3IgY2hvcmQgY2hhcnRcbiAgYXJpYUFubm91bmNlRmxvd1Byb3BvcnRpb25MaW5rOiBcImxpbmsgJHtpbmRleH0gb2YgJHtjb3VudH0sIGZyb20gJHtmcm9tfSB0byAke3RvfSwgJHtzaXplTmFtZX0gJHtzaXplfVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIGFubm91bmNlbWVudCB3aGVuIGZvY3VzaW5nIGEgbm9kZSBpbiBhIFNhbmtleSBvciBjaG9yZCBjaGFydFxuICBhcmlhQW5ub3VuY2VGbG93UHJvcG9ydGlvbk5vZGU6IFwibm9kZSAke2luZGV4fSBvZiAke2NvdW50fSwgJHtkZXNjcmlwdGlvbn1cIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciBhbm5vdGF0aW9uLW9wdGlvbnMgdG9vbGJhclxuICBhcmlhTGFiZWxBbm5vdGF0aW9uT3B0aW9uc1Rvb2xiYXI6IFwiQW5ub3RhdGlvbiBPcHRpb25zXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIGNvbG9yIHBpY2tlciBkaWFsb2dcbiAgYXJpYUxhYmVsQ29sb3JQaWNrZXI6IFwiQ29sb3IgcGlja2VyXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIGZpbmFuY2lhbCBjaGFydHMgdG9vbGJhclxuICBhcmlhTGFiZWxGaW5hbmNpYWxDaGFydHM6IFwiRmluYW5jaWFsIENoYXJ0c1wiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHRoZSBsZWdlbmQgdG9vbGJhclxuICBhcmlhTGFiZWxMZWdlbmQ6IFwiTGVnZW5kXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIGxlZ2VuZCBwYWdpbmF0aW9uIGJ1dHRvblxuICBhcmlhTGFiZWxMZWdlbmRQYWdpbmF0aW9uOiBcIkxlZ2VuZCBQYWdpbmF0aW9uXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgdGhlIHByZXZpb3VzIGxlZ2VuZCBwYWdlIGJ1dHRvblxuICBhcmlhTGFiZWxMZWdlbmRQYWdlUHJldmlvdXM6IFwiUHJldmlvdXMgTGVnZW5kIFBhZ2VcIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgbmV4dCBsZWdlbmQgcGFnZSBidXR0b25cbiAgYXJpYUxhYmVsTGVnZW5kUGFnZU5leHQ6IFwiTmV4dCBMZWdlbmQgUGFnZVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHRoZSBhbiBpdGVtIGluIHRoZSBsZWdlbmRcbiAgYXJpYUxhYmVsTGVnZW5kSXRlbTogXCIke2xhYmVsfSwgTGVnZW5kIGl0ZW0gJHtpbmRleH1bbnVtYmVyXSBvZiAke2NvdW50fVtudW1iZXJdLCBcIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB0aGUgYW4gdW5rbm93biBpdGVtIGluIHRoZSBsZWdlbmRcbiAgYXJpYUxhYmVsTGVnZW5kSXRlbVVua25vd246IFwiVW5rbm93biBsZWdlbmQgaXRlbVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHRoZSBuYXZpZ2F0b3IgZWxlbWVudFxuICBhcmlhTGFiZWxOYXZpZ2F0b3I6IFwiTmF2aWdhdG9yXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgYW4gYWNjZXNzaWJpbGl0eSBjb250cm9sIHRoYXQgY2hhbmdlcyB0aGUgcG9zaXRpb24gb2YgdGhlIG5hdmlnYXRvcidzIHJhbmdlXG4gIGFyaWFMYWJlbE5hdmlnYXRvclJhbmdlOiBcIlJhbmdlXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgYW4gYWNjZXNzaWJpbGl0eSBjb250cm9sIHRoYXQgY2hhbmdlcyB0aGUgc3RhcnQgb2YgdGhlIG5hdmlnYXRvcidzIHJhbmdlXG4gIGFyaWFMYWJlbE5hdmlnYXRvck1pbmltdW06IFwiTWluaW11bVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIGFuIGFjY2Vzc2liaWxpdHkgY29udHJvbCB0aGF0IGNoYW5nZXMgdGhlIGVuZCBvZiB0aGUgbmF2aWdhdG9yJ3MgcmFuZ2VcbiAgYXJpYUxhYmVsTmF2aWdhdG9yTWF4aW11bTogXCJNYXhpbXVtXCIsXG4gIC8vIFNjcmVlbiByZWFkZXIgdGV4dCBmb3IgcmFuZ2VzIHRvb2xiYXJcbiAgYXJpYUxhYmVsUmFuZ2VzVG9vbGJhcjogXCJSYW5nZXNcIixcbiAgLy8gU2NyZWVuIHJlYWRlciB0ZXh0IGZvciB6b29tIHRvb2xiYXJcbiAgYXJpYUxhYmVsWm9vbVRvb2xiYXI6IFwiWm9vbVwiLFxuICAvLyBTY3JlZW4gcmVhZGVyIHRleHQgZm9yIHRoZSB2YWx1ZSBvZiB0aGUgbmF2aWdhdG9yJ3MgcmFuZ2VcbiAgYXJpYVZhbHVlUGFuUmFuZ2U6IFwiJHttaW59W3BlcmNlbnRdIHRvICR7bWF4fVtwZXJjZW50XVwiLFxuICAvLyBEZWZhdWx0IHRleHQgZm9yIHRoZSAnbG9hZGluZyBkYXRhJyBvdmVybGF5XG4gIG92ZXJsYXlMb2FkaW5nRGF0YTogXCJMb2FkaW5nIGRhdGEuLi5cIixcbiAgLy8gRGVmYXVsdCB0ZXh0IGZvciB0aGUgJ25vIGRhdGEnIG92ZXJsYXlcbiAgb3ZlcmxheU5vRGF0YTogXCJObyBkYXRhIHRvIGRpc3BsYXlcIixcbiAgLy8gRGVmYXVsdCB0ZXh0IGZvciB0aGUgJ25vIHZpc2libGUgc2VyaWVzJyBvdmVybGF5XG4gIG92ZXJsYXlOb1Zpc2libGVTZXJpZXM6IFwiTm8gdmlzaWJsZSBzZXJpZXNcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHNlcmllcyB0eXBlIHRvb2xiYXIncyBjaGFydCB0eXBlIGJ1dHRvblxuICB0b29sYmFyU2VyaWVzVHlwZURyb3Bkb3duOiBcIkNoYXJ0IFR5cGVcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHNlcmllcyB0eXBlIHRvb2xiYXIncyBPSExDIGNoYXJ0IHR5cGUgYnV0dG9uXG4gIHRvb2xiYXJTZXJpZXNUeXBlT0hMQzogXCJPSExDXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBzZXJpZXMgdHlwZSB0b29sYmFyJ3MgSExDIGNoYXJ0IHR5cGUgYnV0dG9uXG4gIHRvb2xiYXJTZXJpZXNUeXBlSExDOiBcIkhMQ1wiLFxuICAvLyBUZXh0IGZvciB0aGUgc2VyaWVzIHR5cGUgdG9vbGJhcidzIGhpZ2ggbG93IGNoYXJ0IHR5cGUgYnV0dG9uXG4gIHRvb2xiYXJTZXJpZXNUeXBlSGlnaExvdzogXCJIaWdoIExvd1wiLFxuICAvLyBUZXh0IGZvciB0aGUgc2VyaWVzIHR5cGUgdG9vbGJhcidzIGNhbmRsZXMgY2hhcnQgdHlwZSBidXR0b25cbiAgdG9vbGJhclNlcmllc1R5cGVDYW5kbGVzOiBcIkNhbmRsZXNcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHNlcmllcyB0eXBlIHRvb2xiYXIncyBob2xsb3cgY2FuZGxlcyBjaGFydCB0eXBlIGJ1dHRvblxuICB0b29sYmFyU2VyaWVzVHlwZUhvbGxvd0NhbmRsZXM6IFwiSG9sbG93IENhbmRsZXNcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHNlcmllcyB0eXBlIHRvb2xiYXIncyBsaW5lIGNoYXJ0IHR5cGUgYnV0dG9uXG4gIHRvb2xiYXJTZXJpZXNUeXBlTGluZTogXCJMaW5lXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBzZXJpZXMgdHlwZSB0b29sYmFyJ3MgbGluZSB3aXRoIG1hcmtlcnMgY2hhcnQgdHlwZSBidXR0b25cbiAgdG9vbGJhclNlcmllc1R5cGVMaW5lV2l0aE1hcmtlcnM6IFwiTGluZSB3aXRoIE1hcmtlcnNcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHNlcmllcyB0eXBlIHRvb2xiYXIncyBsaW5lIHdpdGggc3RlcCBsaW5lIGNoYXJ0IHR5cGUgYnV0dG9uXG4gIHRvb2xiYXJTZXJpZXNUeXBlU3RlcExpbmU6IFwiU3RlcCBMaW5lXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyB0cmVuZCBsaW5lIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNUcmVuZExpbmU6IFwiVHJlbmQgTGluZVwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgaG9yaXpvbnRhbCBsaW5lIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNIb3Jpem9udGFsTGluZTogXCJIb3Jpem9udGFsIExpbmVcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIHZlcnRpY2FsIGxpbmUgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc1ZlcnRpY2FsTGluZTogXCJWZXJ0aWNhbCBMaW5lXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBwYXJhbGxlbCBjaGFubmVsIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNQYXJhbGxlbENoYW5uZWw6IFwiUGFyYWxsZWwgQ2hhbm5lbFwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgZGlzam9pbnQgY2hhbm5lbCBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zRGlzam9pbnRDaGFubmVsOiBcIkRpc2pvaW50IENoYW5uZWxcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGNsZWFyIGFsbCBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zQ2xlYXJBbGw6IFwiQ2xlYXIgQWxsXCIsXG4gIC8qKlxuICAgKiBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgY29sb3IgcGlja2VyIGFubm90YXRpb24gYnV0dG9uXG4gICAqIEBkZXByZWNhdGVkIHYxMC4xLjAgdXNlIGB0b29sYmFyQW5ub3RhdGlvbnNMaW5lQ29sb3JgIGluc3RlYWQuXG4gICAqL1xuICB0b29sYmFyQW5ub3RhdGlvbnNDb2xvcjogXCJDb2xvclwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgZmlsbCBjb2xvciBwaWNrZXIgYW5ub3RhdGlvbiBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zRmlsbENvbG9yOiBcIkZpbGwgQ29sb3JcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGxpbmUgY29sb3IgcGlja2VyIGFubm90YXRpb24gYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0xpbmVDb2xvcjogXCJMaW5lIENvbG9yXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyB0ZXh0IGNvbG9yIHBpY2tlciBhbm5vdGF0aW9uIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNUZXh0Q29sb3I6IFwiVGV4dCBDb2xvclwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgdGV4dCBzaXplIHBpY2tlciBhbm5vdGF0aW9uIGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNUZXh0U2l6ZTogXCJUZXh0IFNpemVcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGxvY2sgYW5ub3RhdGlvbiBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zTG9jazogXCJMb2NrXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyB1bmxvY2sgYW5ub3RhdGlvbiBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zVW5sb2NrOiBcIlVubG9ja1wiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3MgZGVsZXRlIGFubm90YXRpb24gYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0RlbGV0ZTogXCJEZWxldGVcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGxpbmUgYW5ub3RhdGlvbnMgbWVudSBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zTGluZUFubm90YXRpb25zOiBcIlRyZW5kIExpbmVzXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyB0ZXh0IGFubm90YXRpb25zIG1lbnUgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc1RleHRBbm5vdGF0aW9uczogXCJUZXh0IEFubm90YXRpb25zXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyBjYWxsb3V0IGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNDYWxsb3V0OiBcIkNhbGxvdXRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGFubm90YXRpb24gdG9vbGJhcidzIGNvbW1lbnQgYnV0dG9uXG4gIHRvb2xiYXJBbm5vdGF0aW9uc0NvbW1lbnQ6IFwiQ29tbWVudFwiLFxuICAvLyBUZXh0IGZvciB0aGUgYW5ub3RhdGlvbiB0b29sYmFyJ3Mgbm90ZSBidXR0b25cbiAgdG9vbGJhckFubm90YXRpb25zTm90ZTogXCJOb3RlXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBhbm5vdGF0aW9uIHRvb2xiYXIncyB0ZXh0IGJ1dHRvblxuICB0b29sYmFyQW5ub3RhdGlvbnNUZXh0OiBcIlRleHRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyAxIG1vbnRoIGJ1dHRvblxuICB0b29sYmFyUmFuZ2UxTW9udGg6IFwiMU1cIixcbiAgLy8gQXJpYSBsYWJlbCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyAxIG1vbnRoIGJ1dHRvblxuICB0b29sYmFyUmFuZ2UxTW9udGhBcmlhOiBcIjEgbW9udGhcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyAzIG1vbnRoIGJ1dHRvblxuICB0b29sYmFyUmFuZ2UzTW9udGhzOiBcIjNNXCIsXG4gIC8vIEFyaWEgbGFiZWwgZm9yIHRoZSByYW5nZSB0b29sYmFyJ3MgMyBtb250aCBidXR0b25cbiAgdG9vbGJhclJhbmdlM01vbnRoc0FyaWE6IFwiMyBtb250aHNcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyA2IG1vbnRoIGJ1dHRvblxuICB0b29sYmFyUmFuZ2U2TW9udGhzOiBcIjZNXCIsXG4gIC8vIEFyaWEgbGFiZWwgZm9yIHRoZSByYW5nZSB0b29sYmFyJ3MgNiBtb250aCBidXR0b25cbiAgdG9vbGJhclJhbmdlNk1vbnRoc0FyaWE6IFwiNiBtb250aHNcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyB5ZWFyIHRvIGRhdGUgYnV0dG9uXG4gIHRvb2xiYXJSYW5nZVllYXJUb0RhdGU6IFwiWVREXCIsXG4gIC8vIEFyaWEgbGFiZWwgZm9yIHRoZSByYW5nZSB0b29sYmFyJ3MgeWVhciB0byBkYXRlIG1vbnRoIGJ1dHRvblxuICB0b29sYmFyUmFuZ2VZZWFyVG9EYXRlQXJpYTogXCJZZWFyIHRvIGRhdGVcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHJhbmdlIHRvb2xiYXIncyAxIHllYXIgYnV0dG9uXG4gIHRvb2xiYXJSYW5nZTFZZWFyOiBcIjFZXCIsXG4gIC8vIEFyaWEgbGFiZWwgZm9yIHRoZSByYW5nZSB0b29sYmFyJ3MgMSB5ZWFyIGJ1dHRvblxuICB0b29sYmFyUmFuZ2UxWWVhckFyaWE6IFwiMSB5ZWFyXCIsXG4gIC8vIFRleHQgZm9yIHRoZSByYW5nZSB0b29sYmFyJ3MgZnVsbCByYW5nZSBidXR0b25cbiAgdG9vbGJhclJhbmdlQWxsOiBcIkFsbFwiLFxuICAvLyBBcmlhIGxhYmVsIGZvciB0aGUgcmFuZ2UgdG9vbGJhcidzIGZ1bGwgcmFuZ2UgYnV0dG9uXG4gIHRvb2xiYXJSYW5nZUFsbEFyaWE6IFwiQWxsXCIsXG4gIC8vIFRleHQgZm9yIHRoZSB6b29tIHRvb2xiYXIncyB6b29tIG91dCBidXR0b25cbiAgdG9vbGJhclpvb21ab29tT3V0OiBcIlpvb20gb3V0XCIsXG4gIC8vIFRleHQgZm9yIHRoZSB6b29tIHRvb2xiYXIncyB6b29tIGluIGJ1dHRvblxuICB0b29sYmFyWm9vbVpvb21JbjogXCJab29tIGluXCIsXG4gIC8vIFRleHQgZm9yIHRoZSB6b29tIHRvb2xiYXIncyBwYW4gbGVmdCBidXR0b25cbiAgdG9vbGJhclpvb21QYW5MZWZ0OiBcIlBhbiBsZWZ0XCIsXG4gIC8vIFRleHQgZm9yIHRoZSB6b29tIHRvb2xiYXIncyBwYW4gcmlnaHQgYnV0dG9uXG4gIHRvb2xiYXJab29tUGFuUmlnaHQ6IFwiUGFuIHJpZ2h0XCIsXG4gIC8vIFRleHQgZm9yIHRoZSB6b29tIHRvb2xiYXIncyBwYW4gdG8gdGhlIHN0YXJ0IGJ1dHRvblxuICB0b29sYmFyWm9vbVBhblN0YXJ0OiBcIlBhbiB0byB0aGUgc3RhcnRcIixcbiAgLy8gVGV4dCBmb3IgdGhlIHpvb20gdG9vbGJhcidzIHBhbiB0byB0aGUgZW5kIGJ1dHRvblxuICB0b29sYmFyWm9vbVBhbkVuZDogXCJQYW4gdG8gdGhlIGVuZFwiLFxuICAvLyBUZXh0IGZvciB0aGUgem9vbSB0b29sYmFyJ3MgcGFuIHJlc2V0IGJ1dHRvblxuICB0b29sYmFyWm9vbVJlc2V0OiBcIlJlc2V0IHRoZSB6b29tXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBjb250ZXh0IG1lbnUncyBkb3dubG9hZCBidXR0b25cbiAgY29udGV4dE1lbnVEb3dubG9hZDogXCJEb3dubG9hZFwiLFxuICAvLyBUZXh0IGZvciB0aGUgY29udGV4dCBtZW51J3MgdG9nZ2xlIHNlcmllcyB2aXNpYmlsaXR5IGJ1dHRvblxuICBjb250ZXh0TWVudVRvZ2dsZVNlcmllc1Zpc2liaWxpdHk6IFwiVG9nZ2xlIFZpc2liaWxpdHlcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGNvbnRleHQgbWVudSdzIHRvZ2dsZSBvdGhlciBzZXJpZXMgdmlzaWJpbGl0eSBidXR0b25cbiAgY29udGV4dE1lbnVUb2dnbGVPdGhlclNlcmllczogXCJUb2dnbGUgT3RoZXIgU2VyaWVzXCIsXG4gIC8vIFRleHQgZm9yIHRoZSBjb250ZXh0IG1lbnUncyB6b29tIHRvIHBvaW50IGJ1dHRvblxuICBjb250ZXh0TWVudVpvb21Ub0N1cnNvcjogXCJab29tIHRvIGhlcmVcIixcbiAgLy8gVGV4dCBmb3IgdGhlIGNvbnRleHQgbWVudSdzIHBhbiB0byBwb2ludCBidXR0b25cbiAgY29udGV4dE1lbnVQYW5Ub0N1cnNvcjogXCJQYW4gdG8gaGVyZVwiXG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtdHlwZXMvc3JjL2NoYXJ0L2Vycm9yQmFyT3B0aW9ucy50c1xudmFyIEFnRXJyb3JCYXJTdXBwb3J0ZWRTZXJpZXNUeXBlcyA9IFtcImJhclwiLCBcImxpbmVcIiwgXCJzY2F0dGVyXCJdO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtdHlwZXMvc3JjL2NoYXJ0L25hdmlnYXRvck9wdGlvbnMudHNcbnZhciBfX01JTklfQ0hBUlRfU0VSSUVTX09QVElPTlMgPSB7fTtcbnZhciBfX1ZFUklGWV9NSU5JX0NIQVJUX1NFUklFU19PUFRJT05TID0gdm9pZCAwO1xuX19WRVJJRllfTUlOSV9DSEFSVF9TRVJJRVNfT1BUSU9OUyA9IF9fTUlOSV9DSEFSVF9TRVJJRVNfT1BUSU9OUztcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLXR5cGVzL3NyYy9jaGFydC90b29sYmFyT3B0aW9ucy50c1xudmFyIElDT05TX0xFR0FDWSA9IFtcbiAgXCJkZWxldGUtbGVnYWN5XCIsXG4gIFwiZGlzam9pbnQtY2hhbm5lbFwiLFxuICBcImRpc2pvaW50LWNoYW5uZWwtbGVnYWN5XCIsXG4gIFwiaG9yaXpvbnRhbC1saW5lLWxlZ2FjeVwiLFxuICBcImxpbmUtY29sb3ItbGVnYWN5XCIsXG4gIFwibG9ja1wiLFxuICBcImxvY2stbGVnYWN5XCIsXG4gIFwicGFuLWVuZC1sZWdhY3lcIixcbiAgXCJwYW4tbGVmdC1sZWdhY3lcIixcbiAgXCJwYW4tcmlnaHQtbGVnYWN5XCIsXG4gIFwicGFuLXN0YXJ0LWxlZ2FjeVwiLFxuICBcInBhcmFsbGVsLWNoYW5uZWxcIixcbiAgXCJwYXJhbGxlbC1jaGFubmVsLWxlZ2FjeVwiLFxuICBcInJlc2V0LWxlZ2FjeVwiLFxuICBcInRyZW5kLWxpbmVcIixcbiAgXCJ0cmVuZC1saW5lLWxlZ2FjeVwiLFxuICBcInVubG9ja1wiLFxuICBcInVubG9jay1sZWdhY3lcIixcbiAgXCJ2ZXJ0aWNhbC1saW5lXCIsXG4gIFwidmVydGljYWwtbGluZS1sZWdhY3lcIixcbiAgXCJ6b29tLWluLWxlZ2FjeVwiLFxuICBcInpvb20taW4tYWx0XCIsXG4gIFwiem9vbS1pbi1hbHQtbGVnYWN5XCIsXG4gIFwiem9vbS1vdXQtbGVnYWN5XCIsXG4gIFwiem9vbS1vdXQtYWx0XCIsXG4gIFwiem9vbS1vdXQtYWx0LWxlZ2FjeVwiXG5dO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtdHlwZXMvc3JjL2NoYXJ0L3Rvb2x0aXBPcHRpb25zLnRzXG52YXIgQWdUb29sdGlwUG9zaXRpb25UeXBlID0gLyogQF9fUFVSRV9fICovICgoQWdUb29sdGlwUG9zaXRpb25UeXBlMikgPT4ge1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiUE9JTlRFUlwiXSA9IFwicG9pbnRlclwiO1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiTk9ERVwiXSA9IFwibm9kZVwiO1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiVE9QXCJdID0gXCJ0b3BcIjtcbiAgQWdUb29sdGlwUG9zaXRpb25UeXBlMltcIlJJR0hUXCJdID0gXCJyaWdodFwiO1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiQk9UVE9NXCJdID0gXCJib3R0b21cIjtcbiAgQWdUb29sdGlwUG9zaXRpb25UeXBlMltcIkxFRlRcIl0gPSBcImxlZnRcIjtcbiAgQWdUb29sdGlwUG9zaXRpb25UeXBlMltcIlRPUF9MRUZUXCJdID0gXCJ0b3AtbGVmdFwiO1xuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUyW1wiVE9QX1JJR0hUXCJdID0gXCJ0b3AtcmlnaHRcIjtcbiAgQWdUb29sdGlwUG9zaXRpb25UeXBlMltcIkJPVFRPTV9SSUdIVFwiXSA9IFwiYm90dG9tLXJpZ2h0XCI7XG4gIEFnVG9vbHRpcFBvc2l0aW9uVHlwZTJbXCJCT1RUT01fTEVGVFwiXSA9IFwiYm90dG9tLWxlZnRcIjtcbiAgcmV0dXJuIEFnVG9vbHRpcFBvc2l0aW9uVHlwZTI7XG59KShBZ1Rvb2x0aXBQb3NpdGlvblR5cGUgfHwge30pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtdHlwZXMvc3JjL2NoYXJ0L3RoZW1lT3B0aW9ucy50c1xudmFyIF9fVEhFTUVfT1ZFUlJJREVTID0ge307XG52YXIgX19WRVJJRllfVEhFTUVfT1ZFUlJJREVTID0gdm9pZCAwO1xuX19WRVJJRllfVEhFTUVfT1ZFUlJJREVTID0gX19USEVNRV9PVkVSUklERVM7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS9pbmRleC50c1xudmFyIHRpbWVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQodGltZV9leHBvcnRzLCB7XG4gIFRpbWVJbnRlcnZhbDogKCkgPT4gVGltZUludGVydmFsLFxuICBkYXk6ICgpID0+IGRheSxcbiAgZnJpZGF5OiAoKSA9PiBmcmlkYXksXG4gIGhvdXI6ICgpID0+IGhvdXIsXG4gIG1pbGxpc2Vjb25kOiAoKSA9PiBtaWxsaXNlY29uZCxcbiAgbWludXRlOiAoKSA9PiBtaW51dGUsXG4gIG1vbmRheTogKCkgPT4gbW9uZGF5LFxuICBtb250aDogKCkgPT4gbW9udGgsXG4gIHNhdHVyZGF5OiAoKSA9PiBzYXR1cmRheSxcbiAgc2Vjb25kOiAoKSA9PiBzZWNvbmQsXG4gIHN1bmRheTogKCkgPT4gc3VuZGF5LFxuICB0aHVyc2RheTogKCkgPT4gdGh1cnNkYXksXG4gIHR1ZXNkYXk6ICgpID0+IHR1ZXNkYXksXG4gIHV0Y0RheTogKCkgPT4gdXRjRGF5LFxuICB1dGNIb3VyOiAoKSA9PiB1dGNIb3VyLFxuICB1dGNNaW51dGU6ICgpID0+IHV0Y01pbnV0ZSxcbiAgdXRjTW9udGg6ICgpID0+IHV0Y01vbnRoLFxuICB1dGNZZWFyOiAoKSA9PiB1dGNZZWFyLFxuICB3ZWRuZXNkYXk6ICgpID0+IHdlZG5lc2RheSxcbiAgeWVhcjogKCkgPT4geWVhclxufSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvZnVuY3Rpb24udHNcbnZhciBkb09uY2VTdGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBkb09uY2UoZnVuYywga2V5KSB7XG4gIGlmIChkb09uY2VTdGF0ZS5oYXMoa2V5KSlcbiAgICByZXR1cm47XG4gIGRvT25jZVN0YXRlLnNldChrZXksIHRydWUpO1xuICBmdW5jKCk7XG59XG5kb09uY2UuY2xlYXIgPSAoKSA9PiBkb09uY2VTdGF0ZS5jbGVhcigpO1xuZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uKiBpdGVyYXRlKC4uLml0ZXJhdG9ycykge1xuICBmb3IgKGNvbnN0IGl0ZXJhdG9yIG9mIGl0ZXJhdG9ycykge1xuICAgIHlpZWxkKiBpdGVyYXRvcjtcbiAgfVxufVxuZnVuY3Rpb24gdGhyb3R0bGUoY2FsbGJhY2syLCB3YWl0TXMgPSAwLCBvcHRpb25zKSB7XG4gIGNvbnN0IHsgbGVhZGluZyA9IHRydWUsIHRyYWlsaW5nID0gdHJ1ZSB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgbGV0IHRpbWVySWQ7XG4gIGxldCBsYXN0QXJncztcbiAgbGV0IHNob3VsZFdhaXQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gdGltZW91dEhhbmRsZXIoKSB7XG4gICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lb3V0SGFuZGxlciwgd2FpdE1zKTtcbiAgICAgIGNhbGxiYWNrMiguLi5sYXN0QXJncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFdhaXQgPSBmYWxzZTtcbiAgICB9XG4gICAgbGFzdEFyZ3MgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIHRocm90dGxlQ2FsbGJhY2soLi4uYXJncykge1xuICAgIGlmIChzaG91bGRXYWl0KSB7XG4gICAgICBsYXN0QXJncyA9IGFyZ3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFdhaXQgPSB0cnVlO1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZW91dEhhbmRsZXIsIHdhaXRNcyk7XG4gICAgICBpZiAobGVhZGluZykge1xuICAgICAgICBjYWxsYmFjazIoLi4uYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0QXJncyA9IGFyZ3M7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHRocm90dGxlQ2FsbGJhY2ssIHtcbiAgICBjYW5jZWwoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICBzaG91bGRXYWl0ID0gZmFsc2U7XG4gICAgICBsYXN0QXJncyA9IG51bGw7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGpvaW5GdW5jdGlvbnMoLi4uZm5zKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgZm9yIChjb25zdCBmbiBvZiBmbnMpIHtcbiAgICAgIGZuKCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2xvZ2dlci50c1xudmFyIExvZ2dlciA9IHtcbiAgbG9nKC4uLmxvZ0NvbnRlbnQpIHtcbiAgICBjb25zb2xlLmxvZyguLi5sb2dDb250ZW50KTtcbiAgfSxcbiAgd2FybihtZXNzYWdlLCAuLi5sb2dDb250ZW50KSB7XG4gICAgY29uc29sZS53YXJuKGBBRyBDaGFydHMgLSAke21lc3NhZ2V9YCwgLi4ubG9nQ29udGVudCk7XG4gIH0sXG4gIGVycm9yKG1lc3NhZ2UsIC4uLmxvZ0NvbnRlbnQpIHtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEFHIENoYXJ0cyBlcnJvcmAsIG1lc3NhZ2UsIC4uLmxvZ0NvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBBRyBDaGFydHMgLSAke21lc3NhZ2V9YCwgLi4ubG9nQ29udGVudCk7XG4gICAgfVxuICB9LFxuICB0YWJsZSguLi5sb2dDb250ZW50KSB7XG4gICAgY29uc29sZS50YWJsZSguLi5sb2dDb250ZW50KTtcbiAgfSxcbiAgd2Fybk9uY2UobWVzc2FnZSwgLi4ubG9nQ29udGVudCkge1xuICAgIGRvT25jZSgoKSA9PiBMb2dnZXIud2FybihtZXNzYWdlLCAuLi5sb2dDb250ZW50KSwgYExvZ2dlci53YXJuOiAke21lc3NhZ2V9YCk7XG4gIH0sXG4gIGVycm9yT25jZShtZXNzYWdlLCAuLi5sb2dDb250ZW50KSB7XG4gICAgZG9PbmNlKCgpID0+IExvZ2dlci5lcnJvcihtZXNzYWdlLCAuLi5sb2dDb250ZW50KSwgYExvZ2dlci5lcnJvcjogJHttZXNzYWdlfWApO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvaW50ZXJ2YWwudHNcbnZhciBUaW1lSW50ZXJ2YWwgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKF9lbmNvZGUsIF9kZWNvZGUsIF9yYW5nZUNhbGxiYWNrKSB7XG4gICAgdGhpcy5fZW5jb2RlID0gX2VuY29kZTtcbiAgICB0aGlzLl9kZWNvZGUgPSBfZGVjb2RlO1xuICAgIHRoaXMuX3JhbmdlQ2FsbGJhY2sgPSBfcmFuZ2VDYWxsYmFjaztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIG5ldyBkYXRlIHJlcHJlc2VudGluZyB0aGUgbGF0ZXN0IGludGVydmFsIGJvdW5kYXJ5IGRhdGUgYmVmb3JlIG9yIGVxdWFsIHRvIGRhdGUuXG4gICAqIEZvciBleGFtcGxlLCBgZGF5LmZsb29yKGRhdGUpYCB0eXBpY2FsbHkgcmV0dXJucyAxMjowMCBBTSBsb2NhbCB0aW1lIG9uIHRoZSBnaXZlbiBkYXRlLlxuICAgKiBAcGFyYW0gZGF0ZVxuICAgKi9cbiAgZmxvb3IoZGF0ZSkge1xuICAgIGNvbnN0IGQgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICBjb25zdCBlID0gdGhpcy5fZW5jb2RlKGQpO1xuICAgIHJldHVybiB0aGlzLl9kZWNvZGUoZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgZGF0ZSByZXByZXNlbnRpbmcgdGhlIGVhcmxpZXN0IGludGVydmFsIGJvdW5kYXJ5IGRhdGUgYWZ0ZXIgb3IgZXF1YWwgdG8gZGF0ZS5cbiAgICogQHBhcmFtIGRhdGVcbiAgICovXG4gIGNlaWwoZGF0ZSkge1xuICAgIGNvbnN0IGQgPSBuZXcgRGF0ZShOdW1iZXIoZGF0ZSkgLSAxKTtcbiAgICBjb25zdCBlID0gdGhpcy5fZW5jb2RlKGQpO1xuICAgIHJldHVybiB0aGlzLl9kZWNvZGUoZSArIDEpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGRhdGVzIHJlcHJlc2VudGluZyBldmVyeSBpbnRlcnZhbCBib3VuZGFyeSBhZnRlciBvciBlcXVhbCB0byBzdGFydCAoaW5jbHVzaXZlKSBhbmQgYmVmb3JlIHN0b3AgKGV4Y2x1c2l2ZSkuXG4gICAqIEBwYXJhbSBzdGFydCBSYW5nZSBzdGFydC5cbiAgICogQHBhcmFtIHN0b3AgUmFuZ2UgZW5kLlxuICAgKiBAcGFyYW0gZXh0ZW5kIElmIHNwZWNpZmllZCwgdGhlIHJlcXVlc3RlZCByYW5nZSB3aWxsIGJlIGV4dGVuZGVkIHRvIHRoZSBjbG9zZXN0IFwibmljZVwiIHZhbHVlcy5cbiAgICovXG4gIHJhbmdlKHN0YXJ0LCBzdG9wLCBleHRlbmQpIHtcbiAgICBjb25zdCByYW5nZUNhbGxiYWNrID0gdGhpcy5fcmFuZ2VDYWxsYmFjaz8uKHN0YXJ0LCBzdG9wKTtcbiAgICBjb25zdCBlMCA9IHRoaXMuX2VuY29kZShleHRlbmQgPyB0aGlzLmZsb29yKHN0YXJ0KSA6IHRoaXMuY2VpbChzdGFydCkpO1xuICAgIGNvbnN0IGUxID0gdGhpcy5fZW5jb2RlKGV4dGVuZCA/IHRoaXMuY2VpbChzdG9wKSA6IHRoaXMuZmxvb3Ioc3RvcCkpO1xuICAgIGlmIChlMSA8IGUwKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHJhbmdlMyA9IFtdO1xuICAgIGZvciAobGV0IGUgPSBlMDsgZSA8PSBlMTsgZSsrKSB7XG4gICAgICBjb25zdCBkID0gdGhpcy5fZGVjb2RlKGUpO1xuICAgICAgcmFuZ2UzLnB1c2goZCk7XG4gICAgfVxuICAgIHJhbmdlQ2FsbGJhY2s/LigpO1xuICAgIHJldHVybiByYW5nZTM7XG4gIH1cbn07XG52YXIgQ291bnRhYmxlVGltZUludGVydmFsID0gY2xhc3MgZXh0ZW5kcyBUaW1lSW50ZXJ2YWwge1xuICBnZXRPZmZzZXQoc25hcFRvLCBzdGVwKSB7XG4gICAgY29uc3QgcyA9IHR5cGVvZiBzbmFwVG8gPT09IFwibnVtYmVyXCIgfHwgc25hcFRvIGluc3RhbmNlb2YgRGF0ZSA/IHRoaXMuX2VuY29kZShuZXcgRGF0ZShzbmFwVG8pKSA6IDA7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IocykgJSBzdGVwO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZmlsdGVyZWQgdmlldyBvZiB0aGlzIGludGVydmFsIHJlcHJlc2VudGluZyBldmVyeSBzdGVwJ3RoIGRhdGUuXG4gICAqIEl0IGNhbiBiZSBhIG51bWJlciBvZiBtaW51dGVzLCBob3VycywgZGF5cyBldGMuXG4gICAqIE11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLlxuICAgKiBAcGFyYW0gc3RlcFxuICAgKi9cbiAgZXZlcnkoc3RlcCwgb3B0aW9ucykge1xuICAgIGxldCBvZmZzZXQ0ID0gMDtcbiAgICBsZXQgcmFuZ2VDYWxsYmFjaztcbiAgICBjb25zdCB1bnNhZmVTdGVwID0gc3RlcDtcbiAgICBzdGVwID0gTWF0aC5tYXgoMSwgTWF0aC5yb3VuZChzdGVwKSk7XG4gICAgaWYgKHVuc2FmZVN0ZXAgIT09IHN0ZXApIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShgaW50ZXJ2YWwgc3RlcCBvZiBbJHt1bnNhZmVTdGVwfV0gcm91bmRlZCB0byBbJHtzdGVwfV0uYCk7XG4gICAgfVxuICAgIGNvbnN0IHsgc25hcFRvID0gXCJzdGFydFwiIH0gPSBvcHRpb25zID8/IHt9O1xuICAgIGlmICh0eXBlb2Ygc25hcFRvID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBpbml0aWFsT2Zmc2V0ID0gb2Zmc2V0NDtcbiAgICAgIHJhbmdlQ2FsbGJhY2sgPSAoc3RhcnQsIHN0b3ApID0+IHtcbiAgICAgICAgY29uc3QgcyA9IHNuYXBUbyA9PT0gXCJzdGFydFwiID8gc3RhcnQgOiBzdG9wO1xuICAgICAgICBvZmZzZXQ0ID0gdGhpcy5nZXRPZmZzZXQocywgc3RlcCk7XG4gICAgICAgIHJldHVybiAoKSA9PiBvZmZzZXQ0ID0gaW5pdGlhbE9mZnNldDtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlb2Ygc25hcFRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICBvZmZzZXQ0ID0gdGhpcy5nZXRPZmZzZXQobmV3IERhdGUoc25hcFRvKSwgc3RlcCk7XG4gICAgfSBlbHNlIGlmIChzbmFwVG8gaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICBvZmZzZXQ0ID0gdGhpcy5nZXRPZmZzZXQoc25hcFRvLCBzdGVwKTtcbiAgICB9XG4gICAgY29uc3QgZW5jb2RlMTMgPSAoZGF0ZSkgPT4ge1xuICAgICAgY29uc3QgZSA9IHRoaXMuX2VuY29kZShkYXRlKTtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKChlIC0gb2Zmc2V0NCkgLyBzdGVwKTtcbiAgICB9O1xuICAgIGNvbnN0IGRlY29kZTEzID0gKGVuY29kZWQpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWNvZGUoZW5jb2RlZCAqIHN0ZXAgKyBvZmZzZXQ0KTtcbiAgICB9O1xuICAgIHJldHVybiBuZXcgVGltZUludGVydmFsKGVuY29kZTEzLCBkZWNvZGUxMywgcmFuZ2VDYWxsYmFjayk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS9taWxsaXNlY29uZC50c1xuZnVuY3Rpb24gZW5jb2RlKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VGltZSgpO1xufVxuZnVuY3Rpb24gZGVjb2RlKGVuY29kZWQpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKGVuY29kZWQpO1xufVxudmFyIG1pbGxpc2Vjb25kID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUsIGRlY29kZSk7XG52YXIgbWlsbGlzZWNvbmRfZGVmYXVsdCA9IG1pbGxpc2Vjb25kO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvZHVyYXRpb24udHNcbnZhciBlcG9jaFllYXIgPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKDApKS5nZXRGdWxsWWVhcigpO1xudmFyIGR1cmF0aW9uU2Vjb25kID0gMWUzO1xudmFyIGR1cmF0aW9uTWludXRlID0gZHVyYXRpb25TZWNvbmQgKiA2MDtcbnZhciBkdXJhdGlvbkhvdXIgPSBkdXJhdGlvbk1pbnV0ZSAqIDYwO1xudmFyIGR1cmF0aW9uRGF5ID0gZHVyYXRpb25Ib3VyICogMjQ7XG52YXIgZHVyYXRpb25XZWVrID0gZHVyYXRpb25EYXkgKiA3O1xudmFyIGR1cmF0aW9uTW9udGggPSBkdXJhdGlvbkRheSAqIDMwO1xudmFyIGR1cmF0aW9uWWVhciA9IGR1cmF0aW9uRGF5ICogMzY1O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvc2Vjb25kLnRzXG52YXIgb2Zmc2V0ID0gKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lem9uZU9mZnNldCgpICogZHVyYXRpb25NaW51dGU7XG5mdW5jdGlvbiBlbmNvZGUyKGRhdGUpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoKGRhdGUuZ2V0VGltZSgpIC0gb2Zmc2V0KSAvIGR1cmF0aW9uU2Vjb25kKTtcbn1cbmZ1bmN0aW9uIGRlY29kZTIoZW5jb2RlZCkge1xuICByZXR1cm4gbmV3IERhdGUob2Zmc2V0ICsgZW5jb2RlZCAqIGR1cmF0aW9uU2Vjb25kKTtcbn1cbnZhciBzZWNvbmQgPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZTIsIGRlY29kZTIpO1xudmFyIHNlY29uZF9kZWZhdWx0ID0gc2Vjb25kO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvbWludXRlLnRzXG52YXIgb2Zmc2V0MiA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIGR1cmF0aW9uTWludXRlO1xuZnVuY3Rpb24gZW5jb2RlMyhkYXRlKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKChkYXRlLmdldFRpbWUoKSAtIG9mZnNldDIpIC8gZHVyYXRpb25NaW51dGUpO1xufVxuZnVuY3Rpb24gZGVjb2RlMyhlbmNvZGVkKSB7XG4gIHJldHVybiBuZXcgRGF0ZShvZmZzZXQyICsgZW5jb2RlZCAqIGR1cmF0aW9uTWludXRlKTtcbn1cbnZhciBtaW51dGUgPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZTMsIGRlY29kZTMpO1xudmFyIG1pbnV0ZV9kZWZhdWx0ID0gbWludXRlO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvaG91ci50c1xudmFyIG9mZnNldDMgPSAoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWV6b25lT2Zmc2V0KCkgKiBkdXJhdGlvbk1pbnV0ZTtcbmZ1bmN0aW9uIGVuY29kZTQoZGF0ZSkge1xuICByZXR1cm4gTWF0aC5mbG9vcigoZGF0ZS5nZXRUaW1lKCkgLSBvZmZzZXQzKSAvIGR1cmF0aW9uSG91cik7XG59XG5mdW5jdGlvbiBkZWNvZGU0KGVuY29kZWQpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKG9mZnNldDMgKyBlbmNvZGVkICogZHVyYXRpb25Ib3VyKTtcbn1cbnZhciBob3VyID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGU0LCBkZWNvZGU0KTtcbnZhciBob3VyX2RlZmF1bHQgPSBob3VyO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvZGF5LnRzXG5mdW5jdGlvbiBlbmNvZGU1KGRhdGUpIHtcbiAgY29uc3QgdHpPZmZzZXRNcyA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIGR1cmF0aW9uTWludXRlO1xuICByZXR1cm4gTWF0aC5mbG9vcigoZGF0ZS5nZXRUaW1lKCkgLSB0ek9mZnNldE1zKSAvIGR1cmF0aW9uRGF5KTtcbn1cbmZ1bmN0aW9uIGRlY29kZTUoZW5jb2RlZCkge1xuICBjb25zdCBkID0gbmV3IERhdGUoMTk3MCwgMCwgMSk7XG4gIGQuc2V0RGF0ZShkLmdldERhdGUoKSArIGVuY29kZWQpO1xuICByZXR1cm4gZDtcbn1cbnZhciBkYXkgPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZTUsIGRlY29kZTUpO1xudmFyIGRheV9kZWZhdWx0ID0gZGF5O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvd2Vlay50c1xuZnVuY3Rpb24gd2Vla2RheSh3ZWVrU3RhcnQpIHtcbiAgY29uc3QgdGh1cnNkYXkyID0gNDtcbiAgY29uc3QgZGF5U2hpZnQgPSAoNyArIHdlZWtTdGFydCAtIHRodXJzZGF5MikgJSA3O1xuICBmdW5jdGlvbiBlbmNvZGUxMyhkYXRlKSB7XG4gICAgY29uc3QgdHpPZmZzZXRNcyA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIGR1cmF0aW9uTWludXRlO1xuICAgIHJldHVybiBNYXRoLmZsb29yKChkYXRlLmdldFRpbWUoKSAtIHR6T2Zmc2V0TXMpIC8gZHVyYXRpb25XZWVrIC0gZGF5U2hpZnQgLyA3KTtcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUxMyhlbmNvZGVkKSB7XG4gICAgY29uc3QgZCA9IG5ldyBEYXRlKDE5NzAsIDAsIDEpO1xuICAgIGQuc2V0RGF0ZShkLmdldERhdGUoKSArIGVuY29kZWQgKiA3ICsgZGF5U2hpZnQpO1xuICAgIHJldHVybiBkO1xuICB9XG4gIHJldHVybiBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZTEzLCBkZWNvZGUxMyk7XG59XG52YXIgc3VuZGF5ID0gd2Vla2RheSgwKTtcbnZhciBtb25kYXkgPSB3ZWVrZGF5KDEpO1xudmFyIHR1ZXNkYXkgPSB3ZWVrZGF5KDIpO1xudmFyIHdlZG5lc2RheSA9IHdlZWtkYXkoMyk7XG52YXIgdGh1cnNkYXkgPSB3ZWVrZGF5KDQpO1xudmFyIGZyaWRheSA9IHdlZWtkYXkoNSk7XG52YXIgc2F0dXJkYXkgPSB3ZWVrZGF5KDYpO1xudmFyIHdlZWtfZGVmYXVsdCA9IHN1bmRheTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL21vbnRoLnRzXG5mdW5jdGlvbiBlbmNvZGU2KGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKSAqIDEyICsgZGF0ZS5nZXRNb250aCgpO1xufVxuZnVuY3Rpb24gZGVjb2RlNihlbmNvZGVkKSB7XG4gIGNvbnN0IHllYXIyID0gTWF0aC5mbG9vcihlbmNvZGVkIC8gMTIpO1xuICBjb25zdCBtb250aDIgPSBlbmNvZGVkIC0geWVhcjIgKiAxMjtcbiAgcmV0dXJuIG5ldyBEYXRlKHllYXIyLCBtb250aDIsIDEpO1xufVxudmFyIG1vbnRoID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGU2LCBkZWNvZGU2KTtcbnZhciBtb250aF9kZWZhdWx0ID0gbW9udGg7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS95ZWFyLnRzXG5mdW5jdGlvbiBlbmNvZGU3KGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0RnVsbFllYXIoKTtcbn1cbmZ1bmN0aW9uIGRlY29kZTcoZW5jb2RlZCkge1xuICBjb25zdCBkID0gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCk7XG4gIGQuc2V0RnVsbFllYXIoZW5jb2RlZCk7XG4gIGQuc2V0TW9udGgoMCwgMSk7XG4gIGQuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIHJldHVybiBkO1xufVxudmFyIHllYXIgPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZTcsIGRlY29kZTcpO1xudmFyIHllYXJfZGVmYXVsdCA9IHllYXI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS91dGNNaW51dGUudHNcbmZ1bmN0aW9uIGVuY29kZTgoZGF0ZSkge1xuICByZXR1cm4gTWF0aC5mbG9vcihkYXRlLmdldFRpbWUoKSAvIGR1cmF0aW9uTWludXRlKTtcbn1cbmZ1bmN0aW9uIGRlY29kZTgoZW5jb2RlZCkge1xuICByZXR1cm4gbmV3IERhdGUoZW5jb2RlZCAqIGR1cmF0aW9uTWludXRlKTtcbn1cbnZhciB1dGNNaW51dGUgPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZTgsIGRlY29kZTgpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RpbWUvdXRjSG91ci50c1xuZnVuY3Rpb24gZW5jb2RlOShkYXRlKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKGRhdGUuZ2V0VGltZSgpIC8gZHVyYXRpb25Ib3VyKTtcbn1cbmZ1bmN0aW9uIGRlY29kZTkoZW5jb2RlZCkge1xuICByZXR1cm4gbmV3IERhdGUoZW5jb2RlZCAqIGR1cmF0aW9uSG91cik7XG59XG52YXIgdXRjSG91ciA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlOSwgZGVjb2RlOSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS91dGNEYXkudHNcbmZ1bmN0aW9uIGVuY29kZTEwKGRhdGUpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoZGF0ZS5nZXRUaW1lKCkgLyBkdXJhdGlvbkRheSk7XG59XG5mdW5jdGlvbiBkZWNvZGUxMChlbmNvZGVkKSB7XG4gIGNvbnN0IGQgPSAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoMCk7XG4gIGQuc2V0VVRDRGF0ZShkLmdldFVUQ0RhdGUoKSArIGVuY29kZWQpO1xuICBkLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICByZXR1cm4gZDtcbn1cbnZhciB1dGNEYXkgPSBuZXcgQ291bnRhYmxlVGltZUludGVydmFsKGVuY29kZTEwLCBkZWNvZGUxMCk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGltZS91dGNNb250aC50c1xuZnVuY3Rpb24gZW5jb2RlMTEoZGF0ZSkge1xuICByZXR1cm4gZGF0ZS5nZXRVVENGdWxsWWVhcigpICogMTIgKyBkYXRlLmdldFVUQ01vbnRoKCk7XG59XG5mdW5jdGlvbiBkZWNvZGUxMShlbmNvZGVkKSB7XG4gIGNvbnN0IHllYXIyID0gTWF0aC5mbG9vcihlbmNvZGVkIC8gMTIpO1xuICBjb25zdCBtb250aDIgPSBlbmNvZGVkIC0geWVhcjIgKiAxMjtcbiAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIyLCBtb250aDIsIDEpKTtcbn1cbnZhciB1dGNNb250aCA9IG5ldyBDb3VudGFibGVUaW1lSW50ZXJ2YWwoZW5jb2RlMTEsIGRlY29kZTExKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lL3V0Y1llYXIudHNcbmZ1bmN0aW9uIGVuY29kZTEyKGRhdGUpIHtcbiAgcmV0dXJuIGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbn1cbmZ1bmN0aW9uIGRlY29kZTEyKGVuY29kZWQpIHtcbiAgY29uc3QgZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpO1xuICBkLnNldFVUQ0Z1bGxZZWFyKGVuY29kZWQpO1xuICBkLnNldFVUQ01vbnRoKDAsIDEpO1xuICBkLnNldFVUQ0hvdXJzKDAsIDAsIDAsIDApO1xuICByZXR1cm4gZDtcbn1cbnZhciB1dGNZZWFyID0gbmV3IENvdW50YWJsZVRpbWVJbnRlcnZhbChlbmNvZGUxMiwgZGVjb2RlMTIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb3Rpb24vZnJvbVRvTW90aW9uLnRzXG52YXIgZnJvbVRvTW90aW9uX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KGZyb21Ub01vdGlvbl9leHBvcnRzLCB7XG4gIE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkc6ICgpID0+IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkcsXG4gIGZyb21Ub01vdGlvbjogKCkgPT4gZnJvbVRvTW90aW9uLFxuICBzdGF0aWNGcm9tVG9Nb3Rpb246ICgpID0+IHN0YXRpY0Zyb21Ub01vdGlvblxufSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvaWQudHNcbnZhciBJRF9NQVAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuZnVuY3Rpb24gcmVzZXRJZHMoKSB7XG4gIElEX01BUC5jbGVhcigpO1xufVxuZnVuY3Rpb24gY3JlYXRlSWQoaW5zdGFuY2UpIHtcbiAgY29uc3QgY29uc3RydWN0b3IgPSBpbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgY29uc3QgY2xhc3NOYW1lID0gT2JqZWN0Lmhhc093bihjb25zdHJ1Y3RvciwgXCJjbGFzc05hbWVcIikgPyBjb25zdHJ1Y3Rvci5jbGFzc05hbWUgOiBjb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAoIWNsYXNzTmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlICR7Y29uc3RydWN0b3J9IGlzIG1pc3NpbmcgdGhlICdjbGFzc05hbWUnIHByb3BlcnR5LmApO1xuICB9XG4gIGNvbnN0IG5leHRJZCA9IChJRF9NQVAuZ2V0KGNsYXNzTmFtZSkgPz8gMCkgKyAxO1xuICBJRF9NQVAuc2V0KGNsYXNzTmFtZSwgbmV4dElkKTtcbiAgcmV0dXJuIGAke2NsYXNzTmFtZX0tJHtuZXh0SWR9YDtcbn1cbmZ1bmN0aW9uIHV1aWQoKSB7XG4gIGNvbnN0IHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoKSk7XG4gIHJldHVybiB1cmwuc3BsaXQoXCIvXCIpLmF0KC0xKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9pdGVyYXRvci50c1xuZnVuY3Rpb24gdG9JdGVyYWJsZSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09IG51bGwgfHwgIShTeW1ib2wuaXRlcmF0b3IgaW4gdmFsdWUpKSB7XG4gICAgcmV0dXJuIGFyZ3NJdGVyYWJsZSh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24qIGFycmF5c0l0ZXJhYmxlKC4uLmFycmF5cykge1xuICBmb3IgKGNvbnN0IGFycmF5MiBvZiBhcnJheXMpIHtcbiAgICBmb3IgKGNvbnN0IGUgb2YgYXJyYXkyKSB7XG4gICAgICB5aWVsZCBlO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24qIGFyZ3NJdGVyYWJsZSguLi5hcmdzKSB7XG4gIGZvciAoY29uc3QgYXJnIG9mIGFyZ3MpIHtcbiAgICB5aWVsZCBhcmc7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9pbnRlcnBvbGF0aW5nLnRzXG52YXIgaW50ZXJwb2xhdGUgPSBcIiRpbnRlcnBvbGF0ZVwiO1xudmFyIGlzSW50ZXJwb2xhdGluZyA9ICh4KSA9PiB4W2ludGVycG9sYXRlXSAhPSBudWxsO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL25lYXJlc3QudHNcbmZ1bmN0aW9uIG5lYXJlc3RTcXVhcmVkKHgsIHksIG9iamVjdHMsIG1heERpc3RhbmNlU3F1YXJlZCA9IEluZmluaXR5KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHsgbmVhcmVzdDogdm9pZCAwLCBkaXN0YW5jZVNxdWFyZWQ6IG1heERpc3RhbmNlU3F1YXJlZCB9O1xuICBmb3IgKGNvbnN0IG9iaiBvZiBvYmplY3RzKSB7XG4gICAgY29uc3QgdGhpc0Rpc3RhbmNlID0gb2JqLmRpc3RhbmNlU3F1YXJlZCh4LCB5KTtcbiAgICBpZiAodGhpc0Rpc3RhbmNlID09PSAwKSB7XG4gICAgICByZXR1cm4geyBuZWFyZXN0OiBvYmosIGRpc3RhbmNlU3F1YXJlZDogMCB9O1xuICAgIH0gZWxzZSBpZiAodGhpc0Rpc3RhbmNlIDwgcmVzdWx0LmRpc3RhbmNlU3F1YXJlZCkge1xuICAgICAgcmVzdWx0Lm5lYXJlc3QgPSBvYmo7XG4gICAgICByZXN1bHQuZGlzdGFuY2VTcXVhcmVkID0gdGhpc0Rpc3RhbmNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbmVhcmVzdFNxdWFyZWRJbkNvbnRhaW5lcih4LCB5LCBjb250YWluZXIsIG1heERpc3RhbmNlU3F1YXJlZCA9IEluZmluaXR5KSB7XG4gIGNvbnN0IHsgeDogdHgsIHk6IHR5IH0gPSBjb250YWluZXIudHJhbnNmb3JtUG9pbnQoeCwgeSk7XG4gIGNvbnN0IHJlc3VsdCA9IHsgbmVhcmVzdDogdm9pZCAwLCBkaXN0YW5jZVNxdWFyZWQ6IG1heERpc3RhbmNlU3F1YXJlZCB9O1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNvbnRhaW5lci5jaGlsZHJlbikge1xuICAgIGNvbnN0IHsgbmVhcmVzdCwgZGlzdGFuY2VTcXVhcmVkOiBkaXN0YW5jZVNxdWFyZWQzIH0gPSBjaGlsZC5uZWFyZXN0U3F1YXJlZCh0eCwgdHksIHJlc3VsdC5kaXN0YW5jZVNxdWFyZWQpO1xuICAgIGlmIChkaXN0YW5jZVNxdWFyZWQzID09PSAwKSB7XG4gICAgICByZXR1cm4geyBuZWFyZXN0LCBkaXN0YW5jZVNxdWFyZWQ6IGRpc3RhbmNlU3F1YXJlZDMgfTtcbiAgICB9IGVsc2UgaWYgKGRpc3RhbmNlU3F1YXJlZDMgPCByZXN1bHQuZGlzdGFuY2VTcXVhcmVkKSB7XG4gICAgICByZXN1bHQubmVhcmVzdCA9IG5lYXJlc3Q7XG4gICAgICByZXN1bHQuZGlzdGFuY2VTcXVhcmVkID0gZGlzdGFuY2VTcXVhcmVkMztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9udW1iZXIudHNcbmZ1bmN0aW9uIGNsYW1wKG1pbiwgdmFsdWUsIG1heCkge1xuICByZXR1cm4gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZhbHVlKSk7XG59XG5mdW5jdGlvbiBjbGFtcEFycmF5KHZhbHVlLCBhcnJheTIpIHtcbiAgY29uc3QgW21pbiwgbWF4XSA9IGZpbmRNaW5NYXgoYXJyYXkyKTtcbiAgcmV0dXJuIGNsYW1wKG1pbiwgdmFsdWUsIG1heCk7XG59XG5mdW5jdGlvbiBmaW5kTWluTWF4KGFycmF5Mikge1xuICBpZiAoYXJyYXkyLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IHJlc3VsdCA9IFtJbmZpbml0eSwgLUluZmluaXR5XTtcbiAgZm9yIChjb25zdCB2YWwgb2YgYXJyYXkyKSB7XG4gICAgaWYgKHZhbCA8IHJlc3VsdFswXSlcbiAgICAgIHJlc3VsdFswXSA9IHZhbDtcbiAgICBpZiAodmFsID4gcmVzdWx0WzFdKVxuICAgICAgcmVzdWx0WzFdID0gdmFsO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmaW5kUmFuZ2VFeHRlbnQoYXJyYXkyKSB7XG4gIGNvbnN0IFttaW4sIG1heF0gPSBmaW5kTWluTWF4KGFycmF5Mik7XG4gIHJldHVybiBtYXggLSBtaW47XG59XG5mdW5jdGlvbiBpc0VxdWFsKGEsIGIsIGVwc2lsb24yID0gMWUtMTApIHtcbiAgcmV0dXJuIE1hdGguYWJzKGEgLSBiKSA8IGVwc2lsb24yO1xufVxuZnVuY3Rpb24gaXNOZWdhdGl2ZSh2YWx1ZSkge1xuICByZXR1cm4gTWF0aC5zaWduKHZhbHVlKSA9PT0gLTEgfHwgT2JqZWN0LmlzKHZhbHVlLCAtMCk7XG59XG5mdW5jdGlvbiByb3VuZCh2YWx1ZSwgZGVjaW1hbHMgPSAyKSB7XG4gIGNvbnN0IGJhc2UgPSAxMCAqKiBkZWNpbWFscztcbiAgcmV0dXJuIE1hdGgucm91bmQodmFsdWUgKiBiYXNlKSAvIGJhc2U7XG59XG5mdW5jdGlvbiB0b0ZpeGVkKHZhbHVlLCBmcmFjdGlvbk9yU2lnbmlmaWNhbnREaWdpdHMgPSAyKSB7XG4gIGNvbnN0IHBvd2VyID0gTWF0aC5mbG9vcihNYXRoLmxvZyhNYXRoLmFicyh2YWx1ZSkpIC8gTWF0aC5MTjEwKTtcbiAgaWYgKHBvd2VyID49IDAgfHwgIWlzRmluaXRlKHBvd2VyKSkge1xuICAgIHJldHVybiB2YWx1ZS50b0ZpeGVkKGZyYWN0aW9uT3JTaWduaWZpY2FudERpZ2l0cyk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlLnRvRml4ZWQoTWF0aC5hYnMocG93ZXIpIC0gMSArIGZyYWN0aW9uT3JTaWduaWZpY2FudERpZ2l0cyk7XG59XG5mdW5jdGlvbiBtb2QobiwgbSkge1xuICByZXR1cm4gTWF0aC5mbG9vcihuICUgbSArIChuIDwgMCA/IG0gOiAwKSk7XG59XG5mdW5jdGlvbiBjb3VudEZyYWN0aW9uRGlnaXRzKHZhbHVlKSB7XG4gIGlmIChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUpXG4gICAgcmV0dXJuIDA7XG4gIHJldHVybiBTdHJpbmcodmFsdWUpLnNwbGl0KFwiLlwiKVsxXT8ubGVuZ3RoID8/IDA7XG59XG5mdW5jdGlvbiBmb3JtYXROb3JtYWxpemVkUGVyY2VudGFnZShyYXRpbzIsIGxvY2FsZSkge1xuICBsb2NhbGUgPSBsb2NhbGUgPz8gbmF2aWdhdG9yLmxhbmd1YWdlO1xuICByZXR1cm4gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZSwgeyBzdHlsZTogXCJwZXJjZW50XCIgfSkuZm9ybWF0KHJhdGlvMik7XG59XG5mdW5jdGlvbiBmb3JtYXRQZXJjZW50YWdlKHBlcmNlbnQsIGxvY2FsZSkge1xuICByZXR1cm4gZm9ybWF0Tm9ybWFsaXplZFBlcmNlbnRhZ2UocGVyY2VudCAvIDEwMCwgbG9jYWxlKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvYmJveC50c1xudmFyIF9CQm94ID0gY2xhc3MgX0JCb3gge1xuICBjb25zdHJ1Y3Rvcih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuICBzdGF0aWMgZnJvbURPTVJlY3QoeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0pIHtcbiAgICByZXR1cm4gbmV3IF9CQm94KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIHRvRE9NUmVjdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdGhpcy54LFxuICAgICAgeTogdGhpcy55LFxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgdG9wOiB0aGlzLnksXG4gICAgICBsZWZ0OiB0aGlzLngsXG4gICAgICByaWdodDogdGhpcy54ICsgdGhpcy53aWR0aCxcbiAgICAgIGJvdHRvbTogdGhpcy55ICsgdGhpcy5oZWlnaHQsXG4gICAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gdGhpcztcbiAgICByZXR1cm4gbmV3IF9CQm94KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLnggPT09IG90aGVyLnggJiYgdGhpcy55ID09PSBvdGhlci55ICYmIHRoaXMud2lkdGggPT09IG90aGVyLndpZHRoICYmIHRoaXMuaGVpZ2h0ID09PSBvdGhlci5oZWlnaHQ7XG4gIH1cbiAgY29udGFpbnNQb2ludCh4LCB5KSB7XG4gICAgcmV0dXJuIHggPj0gdGhpcy54ICYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aCAmJiB5ID49IHRoaXMueSAmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuICB9XG4gIGludGVyc2VjdGlvbihvdGhlcikge1xuICAgIGlmICghdGhpcy5jb2xsaWRlc0JCb3gob3RoZXIpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG5ld1gxID0gY2xhbXAob3RoZXIueCwgdGhpcy54LCBvdGhlci54ICsgb3RoZXIud2lkdGgpO1xuICAgIGNvbnN0IG5ld1kxID0gY2xhbXAob3RoZXIueSwgdGhpcy55LCBvdGhlci55ICsgb3RoZXIuaGVpZ2h0KTtcbiAgICBjb25zdCBuZXdYMiA9IGNsYW1wKG90aGVyLngsIHRoaXMueCArIHRoaXMud2lkdGgsIG90aGVyLnggKyBvdGhlci53aWR0aCk7XG4gICAgY29uc3QgbmV3WTIgPSBjbGFtcChvdGhlci55LCB0aGlzLnkgKyB0aGlzLmhlaWdodCwgb3RoZXIueSArIG90aGVyLmhlaWdodCk7XG4gICAgcmV0dXJuIG5ldyBfQkJveChuZXdYMSwgbmV3WTEsIG5ld1gyIC0gbmV3WDEsIG5ld1kyIC0gbmV3WTEpO1xuICB9XG4gIGNvbGxpZGVzQkJveChvdGhlcikge1xuICAgIHJldHVybiB0aGlzLnggPCBvdGhlci54ICsgb3RoZXIud2lkdGggJiYgdGhpcy54ICsgdGhpcy53aWR0aCA+IG90aGVyLnggJiYgdGhpcy55IDwgb3RoZXIueSArIG90aGVyLmhlaWdodCAmJiB0aGlzLnkgKyB0aGlzLmhlaWdodCA+IG90aGVyLnk7XG4gIH1cbiAgY29tcHV0ZUNlbnRlcigpIHtcbiAgICByZXR1cm4geyB4OiB0aGlzLnggKyB0aGlzLndpZHRoIC8gMiwgeTogdGhpcy55ICsgdGhpcy5oZWlnaHQgLyAyIH07XG4gIH1cbiAgaXNGaW5pdGUoKSB7XG4gICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZSh0aGlzLngpICYmIE51bWJlci5pc0Zpbml0ZSh0aGlzLnkpICYmIE51bWJlci5pc0Zpbml0ZSh0aGlzLndpZHRoKSAmJiBOdW1iZXIuaXNGaW5pdGUodGhpcy5oZWlnaHQpO1xuICB9XG4gIGRpc3RhbmNlU3F1YXJlZCh4LCB5KSB7XG4gICAgaWYgKHRoaXMuY29udGFpbnNQb2ludCh4LCB5KSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGNvbnN0IGR4ID0geCAtIGNsYW1wKHRoaXMueCwgeCwgdGhpcy54ICsgdGhpcy53aWR0aCk7XG4gICAgY29uc3QgZHkgPSB5IC0gY2xhbXAodGhpcy55LCB5LCB0aGlzLnkgKyB0aGlzLmhlaWdodCk7XG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuICB9XG4gIHN0YXRpYyBuZWFyZXN0Qm94KHgsIHksIGJveGVzKSB7XG4gICAgcmV0dXJuIG5lYXJlc3RTcXVhcmVkKHgsIHksIGJveGVzKTtcbiAgfVxuICBjbGlwKGNsaXBSZWN0KSB7XG4gICAgaWYgKGNsaXBSZWN0ID09PSB2b2lkIDApXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBjb25zdCB4MSA9IE1hdGgubWF4KHRoaXMueCwgY2xpcFJlY3QueCk7XG4gICAgY29uc3QgeTEgPSBNYXRoLm1heCh0aGlzLnksIGNsaXBSZWN0LnkpO1xuICAgIGNvbnN0IHgyID0gTWF0aC5taW4odGhpcy54ICsgdGhpcy53aWR0aCwgY2xpcFJlY3QueCArIGNsaXBSZWN0LndpZHRoKTtcbiAgICBjb25zdCB5MiA9IE1hdGgubWluKHRoaXMueSArIHRoaXMuaGVpZ2h0LCBjbGlwUmVjdC55ICsgY2xpcFJlY3QuaGVpZ2h0KTtcbiAgICB0aGlzLnggPSB4MTtcbiAgICB0aGlzLnkgPSB5MTtcbiAgICB0aGlzLndpZHRoID0gTWF0aC5tYXgoMCwgeDIgLSB4MSk7XG4gICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1heCgwLCB5MiAtIHkxKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzaHJpbmsoYW1vdW50LCBwb3NpdGlvbikge1xuICAgIGNvbnN0IGFwcGx5MiA9IChwb3MsIGFtdCkgPT4ge1xuICAgICAgc3dpdGNoIChwb3MpIHtcbiAgICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICAgIHRoaXMueSArPSBhbXQ7XG4gICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICB0aGlzLmhlaWdodCAtPSBhbXQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgdGhpcy54ICs9IGFtdDtcbiAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgdGhpcy53aWR0aCAtPSBhbXQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ2ZXJ0aWNhbFwiOlxuICAgICAgICAgIHRoaXMueSArPSBhbXQ7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgLT0gYW10ICogMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImhvcml6b250YWxcIjpcbiAgICAgICAgICB0aGlzLnggKz0gYW10O1xuICAgICAgICAgIHRoaXMud2lkdGggLT0gYW10ICogMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSB2b2lkIDA6XG4gICAgICAgICAgdGhpcy54ICs9IGFtdDtcbiAgICAgICAgICB0aGlzLndpZHRoIC09IGFtdCAqIDI7XG4gICAgICAgICAgdGhpcy55ICs9IGFtdDtcbiAgICAgICAgICB0aGlzLmhlaWdodCAtPSBhbXQgKiAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBhbW91bnQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGFwcGx5Mihwb3NpdGlvbiwgYW1vdW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhbW91bnQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKGFtb3VudCkuZm9yRWFjaCgoW3BvcywgYW10XSkgPT4gYXBwbHkyKHBvcywgYW10KSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGdyb3coYW1vdW50LCBwb3NpdGlvbikge1xuICAgIGlmICh0eXBlb2YgYW1vdW50ID09PSBcIm51bWJlclwiKSB7XG4gICAgICB0aGlzLnNocmluaygtYW1vdW50LCBwb3NpdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBhZGRpbmdDb3B5ID0geyAuLi5hbW91bnQgfTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHBhZGRpbmdDb3B5KSB7XG4gICAgICAgIHBhZGRpbmdDb3B5W2tleV0gKj0gLTE7XG4gICAgICB9XG4gICAgICB0aGlzLnNocmluayhwYWRkaW5nQ29weSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgdGhpcy54ICs9IHg7XG4gICAgdGhpcy55ICs9IHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY29tYmluZShvdGhlcikge1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9ID0gdGhpcztcbiAgICB0aGlzLnggPSBNYXRoLm1pbih4LCBvdGhlci54KTtcbiAgICB0aGlzLnkgPSBNYXRoLm1pbih5LCBvdGhlci55KTtcbiAgICB0aGlzLndpZHRoID0gTWF0aC5tYXgoeCArIHdpZHRoLCBvdGhlci54ICsgb3RoZXIud2lkdGgpIC0gdGhpcy54O1xuICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5tYXgoeSArIGhlaWdodCwgb3RoZXIueSArIG90aGVyLmhlaWdodCkgLSB0aGlzLnk7XG4gIH1cbiAgc3RhdGljIG1lcmdlKGJveGVzKSB7XG4gICAgbGV0IGxlZnQgPSBJbmZpbml0eTtcbiAgICBsZXQgdG9wID0gSW5maW5pdHk7XG4gICAgbGV0IHJpZ2h0ID0gLUluZmluaXR5O1xuICAgIGxldCBib3R0b20gPSAtSW5maW5pdHk7XG4gICAgZm9yIChjb25zdCBib3ggb2YgYm94ZXMpIHtcbiAgICAgIGlmIChib3gueCA8IGxlZnQpIHtcbiAgICAgICAgbGVmdCA9IGJveC54O1xuICAgICAgfVxuICAgICAgaWYgKGJveC55IDwgdG9wKSB7XG4gICAgICAgIHRvcCA9IGJveC55O1xuICAgICAgfVxuICAgICAgaWYgKGJveC54ICsgYm94LndpZHRoID4gcmlnaHQpIHtcbiAgICAgICAgcmlnaHQgPSBib3gueCArIGJveC53aWR0aDtcbiAgICAgIH1cbiAgICAgIGlmIChib3gueSArIGJveC5oZWlnaHQgPiBib3R0b20pIHtcbiAgICAgICAgYm90dG9tID0gYm94LnkgKyBib3guaGVpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IF9CQm94KGxlZnQsIHRvcCwgcmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3ApO1xuICB9XG4gIFtpbnRlcnBvbGF0ZV0ob3RoZXIsIGQpIHtcbiAgICByZXR1cm4gbmV3IF9CQm94KFxuICAgICAgdGhpcy54ICogKDEgLSBkKSArIG90aGVyLnggKiBkLFxuICAgICAgdGhpcy55ICogKDEgLSBkKSArIG90aGVyLnkgKiBkLFxuICAgICAgdGhpcy53aWR0aCAqICgxIC0gZCkgKyBvdGhlci53aWR0aCAqIGQsXG4gICAgICB0aGlzLmhlaWdodCAqICgxIC0gZCkgKyBvdGhlci5oZWlnaHQgKiBkXG4gICAgKTtcbiAgfVxufTtcbl9CQm94Lnplcm8gPSBPYmplY3QuZnJlZXplKG5ldyBfQkJveCgwLCAwLCAwLCAwKSk7XG5fQkJveC5OYU4gPSBPYmplY3QuZnJlZXplKG5ldyBfQkJveChOYU4sIE5hTiwgTmFOLCBOYU4pKTtcbnZhciBCQm94ID0gX0JCb3g7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2NoYW5nZURldGVjdGFibGUudHNcbnZhciBSZWRyYXdUeXBlID0gLyogQF9fUFVSRV9fICovICgoUmVkcmF3VHlwZTIpID0+IHtcbiAgUmVkcmF3VHlwZTJbUmVkcmF3VHlwZTJbXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgUmVkcmF3VHlwZTJbUmVkcmF3VHlwZTJbXCJUUklWSUFMXCJdID0gMV0gPSBcIlRSSVZJQUxcIjtcbiAgUmVkcmF3VHlwZTJbUmVkcmF3VHlwZTJbXCJNSU5PUlwiXSA9IDJdID0gXCJNSU5PUlwiO1xuICBSZWRyYXdUeXBlMltSZWRyYXdUeXBlMltcIk1BSk9SXCJdID0gM10gPSBcIk1BSk9SXCI7XG4gIHJldHVybiBSZWRyYXdUeXBlMjtcbn0pKFJlZHJhd1R5cGUgfHwge30pO1xuZnVuY3Rpb24gU2NlbmVDaGFuZ2VEZXRlY3Rpb24ob3B0cykge1xuICByZXR1cm4gZnVuY3Rpb24odGFyZ2V0LCBrZXkpIHtcbiAgICBjb25zdCBwcml2YXRlS2V5ID0gYF9fJHtrZXl9YDtcbiAgICBpZiAodGFyZ2V0W2tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcHJlcGFyZUdldFNldCh0YXJnZXQsIGtleSwgcHJpdmF0ZUtleSwgb3B0cyk7XG4gIH07XG59XG5mdW5jdGlvbiBwcmVwYXJlR2V0U2V0KHRhcmdldCwga2V5LCBwcml2YXRlS2V5LCBvcHRzKSB7XG4gIGNvbnN0IHtcbiAgICByZWRyYXcgPSAxIC8qIFRSSVZJQUwgKi8sXG4gICAgdHlwZSA9IFwibm9ybWFsXCIsXG4gICAgY2hhbmdlQ2IsXG4gICAgY29udmVydG9yLFxuICAgIGNoZWNrRGlydHlPbkFzc2lnbm1lbnQgPSBmYWxzZVxuICB9ID0gb3B0cyA/PyB7fTtcbiAgY29uc3QgcmVxdWlyZWRPcHRzID0geyByZWRyYXcsIHR5cGUsIGNoYW5nZUNiLCBjaGVja0RpcnR5T25Bc3NpZ25tZW50LCBjb252ZXJ0b3IgfTtcbiAgbGV0IHNldHRlcjtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcIm5vcm1hbFwiOlxuICAgICAgc2V0dGVyID0gYnVpbGROb3JtYWxTZXR0ZXIocHJpdmF0ZUtleSwgcmVxdWlyZWRPcHRzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0cmFuc2Zvcm1cIjpcbiAgICAgIHNldHRlciA9IGJ1aWxkVHJhbnNmb3JtU2V0dGVyKHByaXZhdGVLZXksIHJlcXVpcmVkT3B0cyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwicGF0aFwiOlxuICAgICAgc2V0dGVyID0gYnVpbGRQYXRoU2V0dGVyKHByaXZhdGVLZXksIHJlcXVpcmVkT3B0cyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZm9udFwiOlxuICAgICAgc2V0dGVyID0gYnVpbGRGb250U2V0dGVyKHByaXZhdGVLZXksIHJlcXVpcmVkT3B0cyk7XG4gICAgICBicmVhaztcbiAgfVxuICBzZXR0ZXIgPSBidWlsZENoZWNrRGlydHlDaGFpbihcbiAgICBidWlsZENoYW5nZUNhbGxiYWNrQ2hhaW4oYnVpbGRDb252ZXJ0b3JDaGFpbihzZXR0ZXIsIHJlcXVpcmVkT3B0cyksIHJlcXVpcmVkT3B0cyksXG4gICAgcmVxdWlyZWRPcHRzXG4gICk7XG4gIGNvbnN0IGdldHRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzW3ByaXZhdGVLZXldO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcbiAgICBzZXQ6IHNldHRlcixcbiAgICBnZXQ6IGdldHRlcixcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQ29udmVydG9yQ2hhaW4oc2V0dGVyRm4sIG9wdHMpIHtcbiAgY29uc3QgeyBjb252ZXJ0b3IgfSA9IG9wdHM7XG4gIGlmIChjb252ZXJ0b3IpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHNldHRlckZuLmNhbGwodGhpcywgY29udmVydG9yKHZhbHVlKSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gc2V0dGVyRm47XG59XG52YXIgTk9fQ0hBTkdFID0gU3ltYm9sKFwibm8tY2hhbmdlXCIpO1xuZnVuY3Rpb24gYnVpbGRDaGFuZ2VDYWxsYmFja0NoYWluKHNldHRlckZuLCBvcHRzKSB7XG4gIGNvbnN0IHsgY2hhbmdlQ2IgfSA9IG9wdHM7XG4gIGlmIChjaGFuZ2VDYikge1xuICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgY29uc3QgY2hhbmdlID0gc2V0dGVyRm4uY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICBpZiAoY2hhbmdlICE9PSBOT19DSEFOR0UpIHtcbiAgICAgICAgY2hhbmdlQ2IuY2FsbCh0aGlzLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gc2V0dGVyRm47XG59XG5mdW5jdGlvbiBidWlsZENoZWNrRGlydHlDaGFpbihzZXR0ZXJGbiwgb3B0cykge1xuICBjb25zdCB7IGNoZWNrRGlydHlPbkFzc2lnbm1lbnQgfSA9IG9wdHM7XG4gIGlmIChjaGVja0RpcnR5T25Bc3NpZ25tZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBjb25zdCBjaGFuZ2UgPSBzZXR0ZXJGbi5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgIGlmIChjaGFuZ2UgIT09IE5PX0NIQU5HRSAmJiB2YWx1ZSAhPSBudWxsICYmIHZhbHVlLl9kaXJ0eSA+IDAgLyogTk9ORSAqLykge1xuICAgICAgICB0aGlzLm1hcmtEaXJ0eSh2YWx1ZSwgdmFsdWUuX2RpcnR5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFuZ2U7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gc2V0dGVyRm47XG59XG5mdW5jdGlvbiBidWlsZE5vcm1hbFNldHRlcihwcml2YXRlS2V5LCBvcHRzKSB7XG4gIGNvbnN0IHsgcmVkcmF3ID0gMSAvKiBUUklWSUFMICovLCBjaGFuZ2VDYiB9ID0gb3B0cztcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzW3ByaXZhdGVLZXldO1xuICAgIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgIHRoaXNbcHJpdmF0ZUtleV0gPSB2YWx1ZTtcbiAgICAgIHRoaXMubWFya0RpcnR5KHRoaXMsIHJlZHJhdyk7XG4gICAgICBjaGFuZ2VDYj8uKHRoaXMpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gTk9fQ0hBTkdFO1xuICB9O1xufVxuZnVuY3Rpb24gYnVpbGRUcmFuc2Zvcm1TZXR0ZXIocHJpdmF0ZUtleSwgb3B0cykge1xuICBjb25zdCB7IHJlZHJhdyA9IDEgLyogVFJJVklBTCAqLyB9ID0gb3B0cztcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzW3ByaXZhdGVLZXldO1xuICAgIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgIHRoaXNbcHJpdmF0ZUtleV0gPSB2YWx1ZTtcbiAgICAgIHRoaXMubWFya0RpcnR5VHJhbnNmb3JtKHJlZHJhdyk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBOT19DSEFOR0U7XG4gIH07XG59XG5mdW5jdGlvbiBidWlsZFBhdGhTZXR0ZXIocHJpdmF0ZUtleSwgb3B0cykge1xuICBjb25zdCB7IHJlZHJhdyA9IDEgLyogVFJJVklBTCAqLyB9ID0gb3B0cztcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzW3ByaXZhdGVLZXldO1xuICAgIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgIHRoaXNbcHJpdmF0ZUtleV0gPSB2YWx1ZTtcbiAgICAgIGlmICghdGhpcy5fZGlydHlQYXRoKSB7XG4gICAgICAgIHRoaXMuX2RpcnR5UGF0aCA9IHRydWU7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KHRoaXMsIHJlZHJhdyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBOT19DSEFOR0U7XG4gIH07XG59XG5mdW5jdGlvbiBidWlsZEZvbnRTZXR0ZXIocHJpdmF0ZUtleSwgb3B0cykge1xuICBjb25zdCB7IHJlZHJhdyA9IDEgLyogVFJJVklBTCAqLyB9ID0gb3B0cztcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzW3ByaXZhdGVLZXldO1xuICAgIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgIHRoaXNbcHJpdmF0ZUtleV0gPSB2YWx1ZTtcbiAgICAgIGlmICghdGhpcy5fZGlydHlGb250KSB7XG4gICAgICAgIHRoaXMuX2RpcnR5Rm9udCA9IHRydWU7XG4gICAgICAgIHRoaXMubWFya0RpcnR5KHRoaXMsIHJlZHJhdyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBOT19DSEFOR0U7XG4gIH07XG59XG52YXIgQ2hhbmdlRGV0ZWN0YWJsZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5fZGlydHkgPSAzIC8qIE1BSk9SICovO1xuICB9XG4gIG1hcmtEaXJ0eShfc291cmNlLCB0eXBlID0gMSAvKiBUUklWSUFMICovKSB7XG4gICAgaWYgKHRoaXMuX2RpcnR5IDwgdHlwZSkge1xuICAgICAgdGhpcy5fZGlydHkgPSB0eXBlO1xuICAgIH1cbiAgfVxuICBtYXJrQ2xlYW4oX29wdHMpIHtcbiAgICB0aGlzLl9kaXJ0eSA9IDAgLyogTk9ORSAqLztcbiAgfVxuICBpc0RpcnR5KCkge1xuICAgIHJldHVybiB0aGlzLl9kaXJ0eSA+IDAgLyogTk9ORSAqLztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvbWF0cml4LnRzXG52YXIgX01hdHJpeCA9IGNsYXNzIF9NYXRyaXgge1xuICBnZXQgZSgpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuZWxlbWVudHNdO1xuICB9XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnRzMyA9IFsxLCAwLCAwLCAxLCAwLCAwXSkge1xuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50czM7XG4gIH1cbiAgc2V0RWxlbWVudHMoZWxlbWVudHMzKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgZVswXSA9IGVsZW1lbnRzM1swXTtcbiAgICBlWzFdID0gZWxlbWVudHMzWzFdO1xuICAgIGVbMl0gPSBlbGVtZW50czNbMl07XG4gICAgZVszXSA9IGVsZW1lbnRzM1szXTtcbiAgICBlWzRdID0gZWxlbWVudHMzWzRdO1xuICAgIGVbNV0gPSBlbGVtZW50czNbNV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0IGlkZW50aXR5KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmVsZW1lbnRzO1xuICAgIHJldHVybiBlWzBdID09PSAxICYmIGVbMV0gPT09IDAgJiYgZVsyXSA9PT0gMCAmJiBlWzNdID09PSAxICYmIGVbNF0gPT09IDAgJiYgZVs1XSA9PT0gMDtcbiAgfVxuICAvKipcbiAgICogUGVyZm9ybXMgdGhlIEF4QiBtYXRyaXggbXVsdGlwbGljYXRpb24gYW5kIHNhdmVzIHRoZSByZXN1bHRcbiAgICogdG8gYENgLCBpZiBnaXZlbiwgb3IgdG8gYEFgIG90aGVyd2lzZS5cbiAgICovXG4gIEF4QihBLCBCLCBDKSB7XG4gICAgY29uc3QgYSA9IEFbMF0gKiBCWzBdICsgQVsyXSAqIEJbMV0sIGIgPSBBWzFdICogQlswXSArIEFbM10gKiBCWzFdLCBjID0gQVswXSAqIEJbMl0gKyBBWzJdICogQlszXSwgZCA9IEFbMV0gKiBCWzJdICsgQVszXSAqIEJbM10sIGUgPSBBWzBdICogQls0XSArIEFbMl0gKiBCWzVdICsgQVs0XSwgZiA9IEFbMV0gKiBCWzRdICsgQVszXSAqIEJbNV0gKyBBWzVdO1xuICAgIEMgPSBDID8/IEE7XG4gICAgQ1swXSA9IGE7XG4gICAgQ1sxXSA9IGI7XG4gICAgQ1syXSA9IGM7XG4gICAgQ1szXSA9IGQ7XG4gICAgQ1s0XSA9IGU7XG4gICAgQ1s1XSA9IGY7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBgb3RoZXJgIG1hdHJpeCBnZXRzIHBvc3QtbXVsdGlwbGllZCB0byB0aGUgY3VycmVudCBtYXRyaXguXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbWF0cml4LlxuICAgKiBAcGFyYW0gb3RoZXJcbiAgICovXG4gIG11bHRpcGx5U2VsZihvdGhlcikge1xuICAgIHRoaXMuQXhCKHRoaXMuZWxlbWVudHMsIG90aGVyLmVsZW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogVGhlIGBvdGhlcmAgbWF0cml4IGdldHMgcG9zdC1tdWx0aXBsaWVkIHRvIHRoZSBjdXJyZW50IG1hdHJpeC5cbiAgICogUmV0dXJucyBhIG5ldyBtYXRyaXguXG4gICAqIEBwYXJhbSBvdGhlclxuICAgKi9cbiAgbXVsdGlwbHkob3RoZXIpIHtcbiAgICBjb25zdCBlbGVtZW50czMgPSBuZXcgQXJyYXkoNik7XG4gICAgdGhpcy5BeEIodGhpcy5lbGVtZW50cywgb3RoZXIuZWxlbWVudHMsIGVsZW1lbnRzMyk7XG4gICAgcmV0dXJuIG5ldyBfTWF0cml4KGVsZW1lbnRzMyk7XG4gIH1cbiAgcHJlTXVsdGlwbHlTZWxmKG90aGVyKSB7XG4gICAgdGhpcy5BeEIob3RoZXIuZWxlbWVudHMsIHRoaXMuZWxlbWVudHMsIHRoaXMuZWxlbWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoaXMgbWF0cml4IGFzIGEgbmV3IG1hdHJpeC5cbiAgICovXG4gIGludmVyc2UoKSB7XG4gICAgY29uc3QgZWwgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGxldCBhID0gZWxbMF0sIGIgPSBlbFsxXSwgYyA9IGVsWzJdLCBkID0gZWxbM107XG4gICAgY29uc3QgZSA9IGVsWzRdLCBmID0gZWxbNV07XG4gICAgY29uc3QgckQgPSAxIC8gKGEgKiBkIC0gYiAqIGMpO1xuICAgIGEgKj0gckQ7XG4gICAgYiAqPSByRDtcbiAgICBjICo9IHJEO1xuICAgIGQgKj0gckQ7XG4gICAgcmV0dXJuIG5ldyBfTWF0cml4KFtkLCAtYiwgLWMsIGEsIGMgKiBmIC0gZCAqIGUsIGIgKiBlIC0gYSAqIGZdKTtcbiAgfVxuICAvKipcbiAgICogU2F2ZSB0aGUgaW52ZXJzZSBvZiB0aGlzIG1hdHJpeCB0byB0aGUgZ2l2ZW4gbWF0cml4LlxuICAgKi9cbiAgaW52ZXJzZVRvKG90aGVyKSB7XG4gICAgY29uc3QgZWwgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGxldCBhID0gZWxbMF0sIGIgPSBlbFsxXSwgYyA9IGVsWzJdLCBkID0gZWxbM107XG4gICAgY29uc3QgZSA9IGVsWzRdLCBmID0gZWxbNV07XG4gICAgY29uc3QgckQgPSAxIC8gKGEgKiBkIC0gYiAqIGMpO1xuICAgIGEgKj0gckQ7XG4gICAgYiAqPSByRDtcbiAgICBjICo9IHJEO1xuICAgIGQgKj0gckQ7XG4gICAgb3RoZXIuc2V0RWxlbWVudHMoW2QsIC1iLCAtYywgYSwgYyAqIGYgLSBkICogZSwgYiAqIGUgLSBhICogZl0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGludmVydFNlbGYoKSB7XG4gICAgY29uc3QgZWwgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGxldCBhID0gZWxbMF0sIGIgPSBlbFsxXSwgYyA9IGVsWzJdLCBkID0gZWxbM107XG4gICAgY29uc3QgZSA9IGVsWzRdLCBmID0gZWxbNV07XG4gICAgY29uc3QgckQgPSAxIC8gKGEgKiBkIC0gYiAqIGMpO1xuICAgIGEgKj0gckQ7XG4gICAgYiAqPSByRDtcbiAgICBjICo9IHJEO1xuICAgIGQgKj0gckQ7XG4gICAgZWxbMF0gPSBkO1xuICAgIGVsWzFdID0gLWI7XG4gICAgZWxbMl0gPSAtYztcbiAgICBlbFszXSA9IGE7XG4gICAgZWxbNF0gPSBjICogZiAtIGQgKiBlO1xuICAgIGVsWzVdID0gYiAqIGUgLSBhICogZjtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0cmFuc2Zvcm1Qb2ludCh4LCB5KSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZWxlbWVudHM7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHggKiBlWzBdICsgeSAqIGVbMl0gKyBlWzRdLFxuICAgICAgeTogeCAqIGVbMV0gKyB5ICogZVszXSArIGVbNV1cbiAgICB9O1xuICB9XG4gIHRyYW5zZm9ybUJCb3goYmJveCwgdGFyZ2V0KSB7XG4gICAgY29uc3QgZWwgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGNvbnN0IHh4ID0gZWxbMF07XG4gICAgY29uc3QgeHkgPSBlbFsxXTtcbiAgICBjb25zdCB5eCA9IGVsWzJdO1xuICAgIGNvbnN0IHl5ID0gZWxbM107XG4gICAgY29uc3QgaF93ID0gYmJveC53aWR0aCAqIDAuNTtcbiAgICBjb25zdCBoX2ggPSBiYm94LmhlaWdodCAqIDAuNTtcbiAgICBjb25zdCBjeCA9IGJib3gueCArIGhfdztcbiAgICBjb25zdCBjeSA9IGJib3gueSArIGhfaDtcbiAgICBjb25zdCB3ID0gTWF0aC5hYnMoaF93ICogeHgpICsgTWF0aC5hYnMoaF9oICogeXgpO1xuICAgIGNvbnN0IGggPSBNYXRoLmFicyhoX3cgKiB4eSkgKyBNYXRoLmFicyhoX2ggKiB5eSk7XG4gICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBuZXcgQkJveCgwLCAwLCAwLCAwKSk7XG4gICAgdGFyZ2V0LnggPSBjeCAqIHh4ICsgY3kgKiB5eCArIGVsWzRdIC0gdztcbiAgICB0YXJnZXQueSA9IGN4ICogeHkgKyBjeSAqIHl5ICsgZWxbNV0gLSBoO1xuICAgIHRhcmdldC53aWR0aCA9IHcgKyB3O1xuICAgIHRhcmdldC5oZWlnaHQgPSBoICsgaDtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHRvQ29udGV4dChjdHgpIHtcbiAgICBpZiAodGhpcy5pZGVudGl0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlID0gdGhpcy5lbGVtZW50cztcbiAgICBjdHgudHJhbnNmb3JtKGVbMF0sIGVbMV0sIGVbMl0sIGVbM10sIGVbNF0sIGVbNV0pO1xuICB9XG4gIHN0YXRpYyBmbHl3ZWlnaHQoc291cmNlTWF0cml4KSB7XG4gICAgcmV0dXJuIF9NYXRyaXguaW5zdGFuY2Uuc2V0RWxlbWVudHMoc291cmNlTWF0cml4LmVsZW1lbnRzKTtcbiAgfVxuICBzdGF0aWMgdXBkYXRlVHJhbnNmb3JtTWF0cml4KG1hdHJpeCwgc2NhbGluZ1gsIHNjYWxpbmdZLCByb3RhdGlvbiwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblksIG9wdHMpIHtcbiAgICBjb25zdCBzeCA9IHNjYWxpbmdYO1xuICAgIGNvbnN0IHN5ID0gc2NhbGluZ1k7XG4gICAgbGV0IHNjeDtcbiAgICBsZXQgc2N5O1xuICAgIGlmIChzeCA9PT0gMSAmJiBzeSA9PT0gMSkge1xuICAgICAgc2N4ID0gMDtcbiAgICAgIHNjeSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjeCA9IG9wdHM/LnNjYWxpbmdDZW50ZXJYID8/IDA7XG4gICAgICBzY3kgPSBvcHRzPy5zY2FsaW5nQ2VudGVyWSA/PyAwO1xuICAgIH1cbiAgICBjb25zdCByID0gcm90YXRpb247XG4gICAgY29uc3QgY29zID0gTWF0aC5jb3Mocik7XG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4ocik7XG4gICAgbGV0IHJjeDtcbiAgICBsZXQgcmN5O1xuICAgIGlmIChyID09PSAwKSB7XG4gICAgICByY3ggPSAwO1xuICAgICAgcmN5ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmN4ID0gb3B0cz8ucm90YXRpb25DZW50ZXJYID8/IDA7XG4gICAgICByY3kgPSBvcHRzPy5yb3RhdGlvbkNlbnRlclkgPz8gMDtcbiAgICB9XG4gICAgY29uc3QgdHggPSB0cmFuc2xhdGlvblg7XG4gICAgY29uc3QgdHkgPSB0cmFuc2xhdGlvblk7XG4gICAgY29uc3QgdHg0ID0gc2N4ICogKDEgLSBzeCkgLSByY3g7XG4gICAgY29uc3QgdHk0ID0gc2N5ICogKDEgLSBzeSkgLSByY3k7XG4gICAgbWF0cml4LnNldEVsZW1lbnRzKFtcbiAgICAgIGNvcyAqIHN4LFxuICAgICAgc2luICogc3gsXG4gICAgICAtc2luICogc3ksXG4gICAgICBjb3MgKiBzeSxcbiAgICAgIGNvcyAqIHR4NCAtIHNpbiAqIHR5NCArIHJjeCArIHR4LFxuICAgICAgc2luICogdHg0ICsgY29zICogdHk0ICsgcmN5ICsgdHlcbiAgICBdKTtcbiAgICByZXR1cm4gbWF0cml4O1xuICB9XG4gIHN0YXRpYyBmcm9tQ29udGV4dChjdHgpIHtcbiAgICBjb25zdCBkb21NYXRyaXggPSBjdHguZ2V0VHJhbnNmb3JtKCk7XG4gICAgcmV0dXJuIG5ldyBfTWF0cml4KFtkb21NYXRyaXguYSwgZG9tTWF0cml4LmIsIGRvbU1hdHJpeC5jLCBkb21NYXRyaXguZCwgZG9tTWF0cml4LmUsIGRvbU1hdHJpeC5mXSk7XG4gIH1cbn07XG5fTWF0cml4Lmluc3RhbmNlID0gbmV3IF9NYXRyaXgoKTtcbnZhciBNYXRyaXggPSBfTWF0cml4O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9ub2RlLnRzXG52YXIgUG9pbnRlckV2ZW50cyA9IC8qIEBfX1BVUkVfXyAqLyAoKFBvaW50ZXJFdmVudHMyKSA9PiB7XG4gIFBvaW50ZXJFdmVudHMyW1BvaW50ZXJFdmVudHMyW1wiQWxsXCJdID0gMF0gPSBcIkFsbFwiO1xuICBQb2ludGVyRXZlbnRzMltQb2ludGVyRXZlbnRzMltcIk5vbmVcIl0gPSAxXSA9IFwiTm9uZVwiO1xuICByZXR1cm4gUG9pbnRlckV2ZW50czI7XG59KShQb2ludGVyRXZlbnRzIHx8IHt9KTtcbnZhciBfTm9kZSA9IGNsYXNzIF9Ob2RlIGV4dGVuZHMgQ2hhbmdlRGV0ZWN0YWJsZSB7XG4gIGNvbnN0cnVjdG9yKHsgaXNWaXJ0dWFsLCB0YWcsIHpJbmRleCwgbmFtZSB9ID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiBVbmlxdWUgbnVtYmVyIHRvIGFsbG93IGNyZWF0aW9uIG9yZGVyIHRvIGJlIGVhc2lseSBkZXRlcm1pbmVkLiAqL1xuICAgIHRoaXMuc2VyaWFsTnVtYmVyID0gX05vZGUuX25leHRTZXJpYWxOdW1iZXIrKztcbiAgICAvKipcbiAgICAgKiBVbmlxdWUgbm9kZSBJRCBpbiB0aGUgZm9ybSBgQ2xhc3NOYW1lLU5hdHVyYWxOdW1iZXJgLlxuICAgICAqL1xuICAgIHRoaXMuaWQgPSBjcmVhdGVJZCh0aGlzKTtcbiAgICAvKipcbiAgICAgKiBUbyBzaW1wbGlmeSB0aGUgdHlwZSBzeXN0ZW0gKGVzcGVjaWFsbHkgaW4gU2VsZWN0aW9ucykgd2UgZG9uJ3QgaGF2ZSB0aGUgYFBhcmVudGAgbm9kZVxuICAgICAqIChvbmUgdGhhdCBoYXMgY2hpbGRyZW4pLiBJbnN0ZWFkLCB3ZSBtaW1pYyBIVE1MIERPTSwgd2hlcmUgYW55IG5vZGUgY2FuIGhhdmUgY2hpbGRyZW4uXG4gICAgICogQnV0IHdlIHN0aWxsIG5lZWQgdG8gZGlzdGluZ3Vpc2ggcmVndWxhciBsZWFmIG5vZGVzIGZyb20gY29udGFpbmVyIGxlYWZzIHNvbWVob3cuXG4gICAgICovXG4gICAgdGhpcy5pc0NvbnRhaW5lck5vZGUgPSBmYWxzZTtcbiAgICB0aGlzLl92aXJ0dWFsQ2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuICAgIC8vIFVzZWQgdG8gY2hlY2sgZm9yIGR1cGxpY2F0ZSBub2Rlcy5cbiAgICB0aGlzLmNoaWxkU2V0ID0ge307XG4gICAgLy8gVGhlc2UgbWF0cmljZXMgbWF5IG5lZWQgdG8gaGF2ZSBwYWNrYWdlIGxldmVsIHZpc2liaWxpdHlcbiAgICAvLyBmb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHB1cnBvc2VzLlxuICAgIHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIHRoaXMuZGlydHlUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICB0aGlzLnNjYWxpbmdYID0gMTtcbiAgICB0aGlzLnNjYWxpbmdZID0gMTtcbiAgICB0aGlzLnNjYWxpbmdDZW50ZXJYID0gbnVsbDtcbiAgICB0aGlzLnNjYWxpbmdDZW50ZXJZID0gbnVsbDtcbiAgICB0aGlzLnJvdGF0aW9uQ2VudGVyWCA9IG51bGw7XG4gICAgdGhpcy5yb3RhdGlvbkNlbnRlclkgPSBudWxsO1xuICAgIHRoaXMucm90YXRpb24gPSAwO1xuICAgIHRoaXMudHJhbnNsYXRpb25YID0gMDtcbiAgICB0aGlzLnRyYW5zbGF0aW9uWSA9IDA7XG4gICAgdGhpcy5fY2hpbGROb2RlQ291bnRzID0ge1xuICAgICAgZ3JvdXBzOiAwLFxuICAgICAgbm9uR3JvdXBzOiAwXG4gICAgfTtcbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMuZGlydHlaSW5kZXggPSBmYWxzZTtcbiAgICB0aGlzLnpJbmRleCA9IDA7XG4gICAgLyoqIERpc2NyaW1pbmF0b3JzIGZvciByZW5kZXIgb3JkZXIgd2l0aGluIGEgekluZGV4LiAqL1xuICAgIHRoaXMuekluZGV4U3ViT3JkZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5wb2ludGVyRXZlbnRzID0gMCAvKiBBbGwgKi87XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmlzVmlydHVhbCA9IGlzVmlydHVhbCA/PyBmYWxzZTtcbiAgICB0aGlzLnRhZyA9IHRhZyA/PyBOYU47XG4gICAgdGhpcy56SW5kZXggPSB6SW5kZXggPz8gMDtcbiAgfVxuICAvKipcbiAgICogU29tZSBhcmJpdHJhcnkgZGF0YSBib3VuZCB0byB0aGUgbm9kZS5cbiAgICovXG4gIGdldCBkYXR1bSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0dW0gPz8gdGhpcy5fcGFyZW50Py5kYXR1bTtcbiAgfVxuICBnZXQgcHJldmlvdXNEYXR1bSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNEYXR1bTtcbiAgfVxuICBzZXQgZGF0dW0oZGF0dW0pIHtcbiAgICBpZiAodGhpcy5fZGF0dW0gIT09IGRhdHVtKSB7XG4gICAgICB0aGlzLl9wcmV2aW91c0RhdHVtID0gdGhpcy5fZGF0dW07XG4gICAgfVxuICAgIHRoaXMuX2RhdHVtID0gZGF0dW07XG4gIH1cbiAgX3NldExheWVyTWFuYWdlcih2YWx1ZSkge1xuICAgIHRoaXMuX2xheWVyTWFuYWdlciA9IHZhbHVlO1xuICAgIHRoaXMuX2RlYnVnID0gdmFsdWU/LmRlYnVnO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5fY2hpbGRyZW4pIHtcbiAgICAgIGNoaWxkLl9zZXRMYXllck1hbmFnZXIodmFsdWUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuX3ZpcnR1YWxDaGlsZHJlbikge1xuICAgICAgY2hpbGQuX3NldExheWVyTWFuYWdlcih2YWx1ZSk7XG4gICAgfVxuICB9XG4gIGdldCBsYXllck1hbmFnZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xheWVyTWFuYWdlcjtcbiAgfVxuICAqYW5jZXN0b3JzKCkge1xuICAgIGxldCBub2RlID0gdGhpcztcbiAgICB3aGlsZSAobm9kZSA9IG5vZGUucGFyZW50KSB7XG4gICAgICB5aWVsZCBub2RlO1xuICAgIH1cbiAgfVxuICAqdHJhdmVyc2VVcCgpIHtcbiAgICB5aWVsZCB0aGlzO1xuICAgIHlpZWxkKiB0aGlzLmFuY2VzdG9ycygpO1xuICB9XG4gIGdldCBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgfVxuICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpcnR1YWxDaGlsZHJlbi5sZW5ndGggPyB0aGlzLl9jaGlsZHJlbi5jb25jYXQodGhpcy5fdmlydHVhbENoaWxkcmVuLmZsYXRNYXAoKG5leHQpID0+IG5leHQuY2hpbGRyZW4pKSA6IHRoaXMuX2NoaWxkcmVuO1xuICB9XG4gIGdldCB2aXJ0dWFsQ2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpcnR1YWxDaGlsZHJlbjtcbiAgfVxuICBoYXNWaXJ0dWFsQ2hpbGRyZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpcnR1YWxDaGlsZHJlbi5sZW5ndGggPiAwO1xuICB9XG4gIC8vIG5ldyBTZXQ8Tm9kZT4oKVxuICBzZXRQcm9wZXJ0aWVzKHN0eWxlcywgcGlja0tleXMpIHtcbiAgICBpZiAocGlja0tleXMpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIHBpY2tLZXlzKSB7XG4gICAgICAgIHRoaXNba2V5XSA9IHN0eWxlc1trZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHN0eWxlcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBcHBlbmRzIG9uZSBvciBtb3JlIG5ldyBub2RlIGluc3RhbmNlcyB0byB0aGlzIHBhcmVudC5cbiAgICogSWYgb25lIG5lZWRzIHRvOlxuICAgKiAtIG1vdmUgYSBjaGlsZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0IG9mIGNoaWxkcmVuXG4gICAqIC0gbW92ZSBhIGNoaWxkIGZyb20gb25lIHBhcmVudCB0byBhbm90aGVyIChpbmNsdWRpbmcgcGFyZW50cyBpbiBvdGhlciBzY2VuZXMpXG4gICAqIG9uZSBzaG91bGQgdXNlIHRoZSB7QGxpbmsgaW5zZXJ0QmVmb3JlfSBtZXRob2QgaW5zdGVhZC5cbiAgICogQHBhcmFtIG5vZGVzIEEgbm9kZSBvciBub2RlcyB0byBhcHBlbmQuXG4gICAqL1xuICBhcHBlbmQobm9kZXMpIHtcbiAgICBub2RlcyA9IHRvSXRlcmFibGUobm9kZXMpO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgaWYgKG5vZGUucGFyZW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtub2RlfSBhbHJlYWR5IGJlbG9uZ3MgdG8gYW5vdGhlciBwYXJlbnQ6ICR7bm9kZS5wYXJlbnR9LmApO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUubGF5ZXJNYW5hZ2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtub2RlfSBhbHJlYWR5IGJlbG9uZ3MgdG8gYSBzY2VuZTogJHtub2RlLmxheWVyTWFuYWdlcn0uYCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jaGlsZFNldFtub2RlLmlkXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSAke25vZGUuY29uc3RydWN0b3IubmFtZX0gbm9kZTogJHtub2RlfWApO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuaXNWaXJ0dWFsKSB7XG4gICAgICAgIHRoaXMuX3ZpcnR1YWxDaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hpbGRTZXRbbm9kZS5pZF0gPSB0cnVlO1xuICAgICAgbm9kZS5fcGFyZW50ID0gdGhpcztcbiAgICAgIG5vZGUuX3NldExheWVyTWFuYWdlcih0aGlzLmxheWVyTWFuYWdlcik7XG4gICAgfVxuICAgIHRoaXMuZGlydHlaSW5kZXggPSB0cnVlO1xuICAgIHRoaXMubWFya0RpcnR5KHRoaXMsIDMgLyogTUFKT1IgKi8pO1xuICB9XG4gIGFwcGVuZENoaWxkKG5vZGUpIHtcbiAgICB0aGlzLmFwcGVuZChub2RlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICByZW1vdmVDaGlsZChub2RlKSB7XG4gICAgY29uc3QgZXJyb3IgPSAoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBub2RlIHRvIGJlIHJlbW92ZWQgaXMgbm90IGEgY2hpbGQgb2YgdGhpcyBub2RlLmApO1xuICAgIH07XG4gICAgaWYgKG5vZGUucGFyZW50ICE9PSB0aGlzKSB7XG4gICAgICBlcnJvcigpO1xuICAgIH1cbiAgICBpZiAobm9kZS5pc1ZpcnR1YWwpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLl92aXJ0dWFsQ2hpbGRyZW4uaW5kZXhPZihub2RlKTtcbiAgICAgIGlmIChpIDwgMClcbiAgICAgICAgZXJyb3IoKTtcbiAgICAgIHRoaXMuX3ZpcnR1YWxDaGlsZHJlbi5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLl9jaGlsZHJlbi5pbmRleE9mKG5vZGUpO1xuICAgICAgaWYgKGkgPCAwKVxuICAgICAgICBlcnJvcigpO1xuICAgICAgdGhpcy5fY2hpbGRyZW4uc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5jaGlsZFNldFtub2RlLmlkXTtcbiAgICBub2RlLl9wYXJlbnQgPSB2b2lkIDA7XG4gICAgbm9kZS5fc2V0TGF5ZXJNYW5hZ2VyKCk7XG4gICAgdGhpcy5kaXJ0eVpJbmRleCA9IHRydWU7XG4gICAgdGhpcy5tYXJrRGlydHkobm9kZSwgMyAvKiBNQUpPUiAqLyk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBhcnJheXNJdGVyYWJsZSh0aGlzLl92aXJ0dWFsQ2hpbGRyZW4sIHRoaXMuX2NoaWxkcmVuKSkge1xuICAgICAgY2hpbGQuX3BhcmVudCA9IHZvaWQgMDtcbiAgICAgIGNoaWxkLl9zZXRMYXllck1hbmFnZXIoKTtcbiAgICB9XG4gICAgdGhpcy5fdmlydHVhbENoaWxkcmVuLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoID0gMDtcbiAgICB0aGlzLmNoaWxkU2V0ID0ge307XG4gIH1cbiAgY2FsY3VsYXRlQ3VtdWxhdGl2ZU1hdHJpeCgpIHtcbiAgICB0aGlzLmNvbXB1dGVUcmFuc2Zvcm1NYXRyaXgoKTtcbiAgICBjb25zdCBtYXRyaXggPSBNYXRyaXguZmx5d2VpZ2h0KHRoaXMubWF0cml4KTtcbiAgICBmb3IgKGNvbnN0IHBhcmVudCBvZiB0aGlzLmFuY2VzdG9ycygpKSB7XG4gICAgICBwYXJlbnQuY29tcHV0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgbWF0cml4LnByZU11bHRpcGx5U2VsZihwYXJlbnQubWF0cml4KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfVxuICB0cmFuc2Zvcm1Qb2ludCh4LCB5KSB7XG4gICAgY29uc3QgbWF0cml4ID0gdGhpcy5jYWxjdWxhdGVDdW11bGF0aXZlTWF0cml4KCk7XG4gICAgcmV0dXJuIG1hdHJpeC5pbnZlcnRTZWxmKCkudHJhbnNmb3JtUG9pbnQoeCwgeSk7XG4gIH1cbiAgaW52ZXJzZVRyYW5zZm9ybVBvaW50KHgsIHkpIHtcbiAgICBjb25zdCBtYXRyaXggPSB0aGlzLmNhbGN1bGF0ZUN1bXVsYXRpdmVNYXRyaXgoKTtcbiAgICByZXR1cm4gbWF0cml4LnRyYW5zZm9ybVBvaW50KHgsIHkpO1xuICB9XG4gIHRyYW5zZm9ybUJCb3goYmJveCkge1xuICAgIGNvbnN0IG1hdHJpeCA9IHRoaXMuY2FsY3VsYXRlQ3VtdWxhdGl2ZU1hdHJpeCgpO1xuICAgIHJldHVybiBtYXRyaXguaW52ZXJ0U2VsZigpLnRyYW5zZm9ybUJCb3goYmJveCk7XG4gIH1cbiAgaW52ZXJzZVRyYW5zZm9ybUJCb3goYmJveCkge1xuICAgIGNvbnN0IG1hdHJpeCA9IHRoaXMuY2FsY3VsYXRlQ3VtdWxhdGl2ZU1hdHJpeCgpO1xuICAgIHJldHVybiBtYXRyaXgudHJhbnNmb3JtQkJveChiYm94KTtcbiAgfVxuICBtYXJrRGlydHlUcmFuc2Zvcm0oKSB7XG4gICAgdGhpcy5kaXJ0eVRyYW5zZm9ybSA9IHRydWU7XG4gICAgdGhpcy5tYXJrRGlydHkodGhpcywgMyAvKiBNQUpPUiAqLyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnBhcmVudD8ucmVtb3ZlQ2hpbGQodGhpcyk7XG4gIH1cbiAgY29udGFpbnNQb2ludChfeCwgX3kpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEhpdCB0ZXN0aW5nIG1ldGhvZC5cbiAgICogUmVjdXJzaXZlbHkgY2hlY2tzIGlmIHRoZSBnaXZlbiBwb2ludCBpcyBpbnNpZGUgdGhpcyBub2RlIG9yIGFueSBvZiBpdHMgY2hpbGRyZW4uXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IG1hdGNoaW5nIG5vZGUgb3IgYHVuZGVmaW5lZGAuXG4gICAqIE5vZGVzIHRoYXQgcmVuZGVyIGxhdGVyIChzaG93IG9uIHRvcCkgYXJlIGhpdCB0ZXN0ZWQgZmlyc3QuXG4gICAqL1xuICBwaWNrTm9kZSh4LCB5KSB7XG4gICAgaWYgKCF0aGlzLnZpc2libGUgfHwgdGhpcy5wb2ludGVyRXZlbnRzID09PSAxIC8qIE5vbmUgKi8gfHwgIXRoaXMuY29udGFpbnNQb2ludCh4LCB5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSB0aGlzO1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGggPiAxZTMpIHtcbiAgICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBjb25zdCBjb250YWluc1BvaW50ID0gY2hpbGQuY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpPy5jb250YWluc1BvaW50KHgsIHkpO1xuICAgICAgICBjb25zdCBoaXQgPSBjb250YWluc1BvaW50ID8gY2hpbGQucGlja05vZGUoeCwgeSkgOiB2b2lkIDA7XG4gICAgICAgIGlmIChoaXQpIHtcbiAgICAgICAgICByZXR1cm4gaGl0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBoaXQgPSBjaGlsZHJlbltpXS5waWNrTm9kZSh4LCB5KTtcbiAgICAgICAgaWYgKGhpdCkge1xuICAgICAgICAgIHJldHVybiBoaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCF0aGlzLmlzQ29udGFpbmVyTm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG4gIGdldEJCb3goZm9yY2VSZWNhbGN1bGF0aW9uID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy5jYWNoZWRCQm94ID09IG51bGwgfHwgZm9yY2VSZWNhbGN1bGF0aW9uKSB7XG4gICAgICB0aGlzLmNhY2hlZEJCb3ggPSBPYmplY3QuZnJlZXplKHRoaXMuY29tcHV0ZUJCb3goKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNhY2hlZEJCb3g7XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKSB7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuZ2V0QkJveCgpPy5jbG9uZSgpO1xuICAgIGlmICghYmJveCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNvbXB1dGVUcmFuc2Zvcm1NYXRyaXgoKTtcbiAgICBjb25zdCBtYXRyaXggPSBNYXRyaXguZmx5d2VpZ2h0KHRoaXMubWF0cml4KTtcbiAgICBmb3IgKGNvbnN0IHBhcmVudCBvZiB0aGlzLmFuY2VzdG9ycygpKSB7XG4gICAgICBwYXJlbnQuY29tcHV0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgICAgbWF0cml4LnByZU11bHRpcGx5U2VsZihwYXJlbnQubWF0cml4KTtcbiAgICB9XG4gICAgbWF0cml4LnRyYW5zZm9ybUJCb3goYmJveCwgYmJveCk7XG4gICAgcmV0dXJuIGJib3g7XG4gIH1cbiAgY29tcHV0ZVRyYW5zZm9ybU1hdHJpeCgpIHtcbiAgICBpZiAoIXRoaXMuZGlydHlUcmFuc2Zvcm0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbWF0cml4LFxuICAgICAgc2NhbGluZ1gsXG4gICAgICBzY2FsaW5nWSxcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgdHJhbnNsYXRpb25YLFxuICAgICAgdHJhbnNsYXRpb25ZLFxuICAgICAgc2NhbGluZ0NlbnRlclgsXG4gICAgICBzY2FsaW5nQ2VudGVyWSxcbiAgICAgIHJvdGF0aW9uQ2VudGVyWCxcbiAgICAgIHJvdGF0aW9uQ2VudGVyWVxuICAgIH0gPSB0aGlzO1xuICAgIE1hdHJpeC51cGRhdGVUcmFuc2Zvcm1NYXRyaXgobWF0cml4LCBzY2FsaW5nWCwgc2NhbGluZ1ksIHJvdGF0aW9uLCB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSwge1xuICAgICAgc2NhbGluZ0NlbnRlclgsXG4gICAgICBzY2FsaW5nQ2VudGVyWSxcbiAgICAgIHJvdGF0aW9uQ2VudGVyWCxcbiAgICAgIHJvdGF0aW9uQ2VudGVyWVxuICAgIH0pO1xuICAgIHRoaXMuZGlydHlUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgfVxuICB0cmFuc2Zvcm1SZW5kZXJDb250ZXh0KHJlbmRlckN0eCwgbGF5ZXJDdHgpIHtcbiAgICB0aGlzLmNvbXB1dGVUcmFuc2Zvcm1NYXRyaXgoKTtcbiAgICB0aGlzLm1hdHJpeC50b0NvbnRleHQobGF5ZXJDdHggPz8gcmVuZGVyQ3R4LmN0eCk7XG4gICAgcmV0dXJuIHRoaXMubWF0cml4O1xuICB9XG4gIC8qKiBQZXJmb3JtIGFueSBwcmUtcmVuZGVyaW5nIGluaXRpYWxpemF0aW9uLiAqL1xuICBwcmVSZW5kZXIoKSB7XG4gICAgdGhpcy5fY2hpbGROb2RlQ291bnRzLmdyb3VwcyA9IDA7XG4gICAgdGhpcy5fY2hpbGROb2RlQ291bnRzLm5vbkdyb3VwcyA9IDE7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICBjb25zdCBjaGlsZENvdW50cyA9IGNoaWxkLnByZVJlbmRlcigpO1xuICAgICAgdGhpcy5fY2hpbGROb2RlQ291bnRzLmdyb3VwcyArPSBjaGlsZENvdW50cy5ncm91cHM7XG4gICAgICB0aGlzLl9jaGlsZE5vZGVDb3VudHMubm9uR3JvdXBzICs9IGNoaWxkQ291bnRzLm5vbkdyb3VwcztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkTm9kZUNvdW50cztcbiAgfVxuICByZW5kZXIocmVuZGVyQ3R4KSB7XG4gICAgY29uc3QgeyBzdGF0cyB9ID0gcmVuZGVyQ3R4O1xuICAgIHRoaXMuX2RpcnR5ID0gMCAvKiBOT05FICovO1xuICAgIHRoaXMuY2FjaGVkQkJveCA9IHRoaXMuY29tcHV0ZUJCb3goKTtcbiAgICBpZiAoc3RhdHMpIHtcbiAgICAgIHN0YXRzLm5vZGVzUmVuZGVyZWQrKztcbiAgICB9XG4gIH1cbiAgbWFya0RpcnR5KF9zb3VyY2UsIHR5cGUgPSAxIC8qIFRSSVZJQUwgKi8sIHBhcmVudFR5cGUgPSB0eXBlKSB7XG4gICAgdGhpcy5jYWNoZWRCQm94ID0gdm9pZCAwO1xuICAgIGlmICh0aGlzLl9kaXJ0eSA+IHR5cGUgfHwgdGhpcy5fZGlydHkgPT09IHR5cGUgJiYgdHlwZSA9PT0gcGFyZW50VHlwZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kaXJ0eSA9IHR5cGU7XG4gICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICB0aGlzLnBhcmVudC5tYXJrRGlydHkodGhpcywgcGFyZW50VHlwZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxheWVyTWFuYWdlcikge1xuICAgICAgdGhpcy5sYXllck1hbmFnZXIubWFya0RpcnR5KCk7XG4gICAgfVxuICB9XG4gIGdldCBkaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGlydHk7XG4gIH1cbiAgbWFya0NsZWFuKG9wdHMpIHtcbiAgICBjb25zdCB7IGZvcmNlID0gZmFsc2UsIHJlY3Vyc2l2ZSA9IHRydWUgfSA9IG9wdHMgPz8ge307XG4gICAgaWYgKHRoaXMuX2RpcnR5ID09PSAwIC8qIE5PTkUgKi8gJiYgIWZvcmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RpcnR5ID0gMCAvKiBOT05FICovO1xuICAgIGlmIChyZWN1cnNpdmUgIT09IGZhbHNlKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuX3ZpcnR1YWxDaGlsZHJlbikge1xuICAgICAgICBjaGlsZC5tYXJrQ2xlYW4oeyBmb3JjZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlY3Vyc2l2ZSA9PT0gdHJ1ZSkge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLl9jaGlsZHJlbikge1xuICAgICAgICBjaGlsZC5tYXJrQ2xlYW4oeyBmb3JjZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25WaXNpYmxlQ2hhbmdlKCkge1xuICB9XG4gIGdldCBub2RlQ291bnQoKSB7XG4gICAgbGV0IGNvdW50ID0gMTtcbiAgICBsZXQgZGlydHlDb3VudCA9IHRoaXMuX2RpcnR5ID49IDAgLyogTk9ORSAqLyB8fCB0aGlzLmRpcnR5VHJhbnNmb3JtID8gMSA6IDA7XG4gICAgbGV0IHZpc2libGVDb3VudCA9IHRoaXMudmlzaWJsZSA/IDEgOiAwO1xuICAgIGNvbnN0IGNvdW50Q2hpbGQgPSAoY2hpbGQpID0+IHtcbiAgICAgIGNvbnN0IHsgY291bnQ6IGNoaWxkQ291bnQsIHZpc2libGVDb3VudDogY2hpbGRWaXNpYmxlQ291bnQsIGRpcnR5Q291bnQ6IGNoaWxkRGlydHlDb3VudCB9ID0gY2hpbGQubm9kZUNvdW50O1xuICAgICAgY291bnQgKz0gY2hpbGRDb3VudDtcbiAgICAgIHZpc2libGVDb3VudCArPSBjaGlsZFZpc2libGVDb3VudDtcbiAgICAgIGRpcnR5Q291bnQgKz0gY2hpbGREaXJ0eUNvdW50O1xuICAgIH07XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLl9jaGlsZHJlbikge1xuICAgICAgY291bnRDaGlsZChjaGlsZCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5fdmlydHVhbENoaWxkcmVuKSB7XG4gICAgICBjb3VudENoaWxkKGNoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY291bnQsIHZpc2libGVDb3VudCwgZGlydHlDb3VudCB9O1xuICB9XG4gIG9uWkluZGV4Q2hhbmdlKCkge1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQuZGlydHlaSW5kZXggPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcbl9Ob2RlLl9uZXh0U2VyaWFsTnVtYmVyID0gMDtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiB9KVxuXSwgX05vZGUucHJvdG90eXBlLCBcInNjYWxpbmdYXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiBcInRyYW5zZm9ybVwiIH0pXG5dLCBfTm9kZS5wcm90b3R5cGUsIFwic2NhbGluZ1lcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHR5cGU6IFwidHJhbnNmb3JtXCIgfSlcbl0sIF9Ob2RlLnByb3RvdHlwZSwgXCJzY2FsaW5nQ2VudGVyWFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiB9KVxuXSwgX05vZGUucHJvdG90eXBlLCBcInNjYWxpbmdDZW50ZXJZXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiBcInRyYW5zZm9ybVwiIH0pXG5dLCBfTm9kZS5wcm90b3R5cGUsIFwicm90YXRpb25DZW50ZXJYXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiBcInRyYW5zZm9ybVwiIH0pXG5dLCBfTm9kZS5wcm90b3R5cGUsIFwicm90YXRpb25DZW50ZXJZXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyB0eXBlOiBcInRyYW5zZm9ybVwiIH0pXG5dLCBfTm9kZS5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHR5cGU6IFwidHJhbnNmb3JtXCIgfSlcbl0sIF9Ob2RlLnByb3RvdHlwZSwgXCJ0cmFuc2xhdGlvblhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHR5cGU6IFwidHJhbnNmb3JtXCIgfSlcbl0sIF9Ob2RlLnByb3RvdHlwZSwgXCJ0cmFuc2xhdGlvbllcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7XG4gICAgcmVkcmF3OiAzIC8qIE1BSk9SICovLFxuICAgIGNoYW5nZUNiOiAodGFyZ2V0KSA9PiB0YXJnZXQub25WaXNpYmxlQ2hhbmdlKClcbiAgfSlcbl0sIF9Ob2RlLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oe1xuICAgIHJlZHJhdzogMSAvKiBUUklWSUFMICovLFxuICAgIGNoYW5nZUNiOiAodGFyZ2V0KSA9PiB0YXJnZXQub25aSW5kZXhDaGFuZ2UoKVxuICB9KVxuXSwgX05vZGUucHJvdG90eXBlLCBcInpJbmRleFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHtcbiAgICByZWRyYXc6IDEgLyogVFJJVklBTCAqLyxcbiAgICBjaGFuZ2VDYjogKHRhcmdldCkgPT4gdGFyZ2V0Lm9uWkluZGV4Q2hhbmdlKClcbiAgfSlcbl0sIF9Ob2RlLnByb3RvdHlwZSwgXCJ6SW5kZXhTdWJPcmRlclwiLCAyKTtcbnZhciBOb2RlID0gX05vZGU7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvY29sb3IudHNcbnZhciBsZXJwID0gKHgsIHksIHQpID0+IHggKiAoMSAtIHQpICsgeSAqIHQ7XG52YXIgc3JnYlRvTGluZWFyID0gKHZhbHVlKSA9PiB7XG4gIGNvbnN0IHNpZ24gPSB2YWx1ZSA8IDAgPyAtMSA6IDE7XG4gIGNvbnN0IGFicyA9IE1hdGguYWJzKHZhbHVlKTtcbiAgaWYgKGFicyA8PSAwLjA0MDQ1KVxuICAgIHJldHVybiB2YWx1ZSAvIDEyLjkyO1xuICByZXR1cm4gc2lnbiAqICgoYWJzICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNDtcbn07XG52YXIgc3JnYkZyb21MaW5lYXIgPSAodmFsdWUpID0+IHtcbiAgY29uc3Qgc2lnbiA9IHZhbHVlIDwgMCA/IC0xIDogMTtcbiAgY29uc3QgYWJzID0gTWF0aC5hYnModmFsdWUpO1xuICBpZiAoYWJzID4gMzEzMDhlLTcpIHtcbiAgICByZXR1cm4gc2lnbiAqICgxLjA1NSAqIGFicyAqKiAoMSAvIDIuNCkgLSAwLjA1NSk7XG4gIH1cbiAgcmV0dXJuIDEyLjkyICogdmFsdWU7XG59O1xudmFyIF9Db2xvciA9IGNsYXNzIF9Db2xvciB7XG4gIC8qKlxuICAgKiBFdmVyeSBjb2xvciBjb21wb25lbnQgc2hvdWxkIGJlIGluIHRoZSBbMCwgMV0gcmFuZ2UuXG4gICAqIFNvbWUgZWFzaW5nIGZ1bmN0aW9ucyAoc3VjaCBhcyBlbGFzdGljIGVhc2luZykgY2FuIG92ZXJzaG9vdCB0aGUgdGFyZ2V0IHZhbHVlIGJ5IHNvbWUgYW1vdW50LlxuICAgKiBTbywgd2hlbiBhbmltYXRpbmcgY29sb3JzLCBpZiB0aGUgc291cmNlIG9yIHRhcmdldCBjb2xvciBjb21wb25lbnRzIGFyZSBhbHJlYWR5IG5lYXJcbiAgICogb3IgYXQgdGhlIGVkZ2Ugb2YgdGhlIGFsbG93ZWQgWzAsIDFdIHJhbmdlLCBpdCBpcyBwb3NzaWJsZSBmb3IgdGhlIGludGVybWVkaWF0ZSBjb2xvclxuICAgKiBjb21wb25lbnQgdmFsdWUgdG8gZW5kIHVwIG91dHNpZGUgb2YgdGhhdCByYW5nZSBtaWQtYW5pbWF0aW9uLiBGb3IgdGhpcyByZWFzb24gdGhlIGNvbnN0cnVjdG9yXG4gICAqIHBlcmZvcm1zIHJhbmdlIGNoZWNraW5nL2NvbnN0cmFpbmluZy5cbiAgICogQHBhcmFtIHIgUmVkIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIGcgR3JlZW4gY29tcG9uZW50LlxuICAgKiBAcGFyYW0gYiBCbHVlIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIGEgQWxwaGEgKG9wYWNpdHkpIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHIsIGcsIGIsIGEgPSAxKSB7XG4gICAgdGhpcy5yID0gY2xhbXAoMCwgciB8fCAwLCAxKTtcbiAgICB0aGlzLmcgPSBjbGFtcCgwLCBnIHx8IDAsIDEpO1xuICAgIHRoaXMuYiA9IGNsYW1wKDAsIGIgfHwgMCwgMSk7XG4gICAgdGhpcy5hID0gY2xhbXAoMCwgYSB8fCAwLCAxKTtcbiAgfVxuICAvKipcbiAgICogQSBjb2xvciBzdHJpbmcgY2FuIGJlIGluIG9uZSBvZiB0aGUgZm9sbG93aW5nIGZvcm1hdHMgdG8gYmUgdmFsaWQ6XG4gICAqIC0gI3JnYlxuICAgKiAtICNycmdnYmJcbiAgICogLSByZ2IociwgZywgYilcbiAgICogLSByZ2JhKHIsIGcsIGIsIGEpXG4gICAqIC0gQ1NTIGNvbG9yIG5hbWUgc3VjaCBhcyAnd2hpdGUnLCAnb3JhbmdlJywgJ2N5YW4nLCBldGMuXG4gICAqL1xuICBzdGF0aWMgdmFsaWRDb2xvclN0cmluZyhzdHIpIHtcbiAgICBpZiAoc3RyLmluZGV4T2YoXCIjXCIpID49IDApIHtcbiAgICAgIHJldHVybiAhIV9Db2xvci5wYXJzZUhleChzdHIpO1xuICAgIH1cbiAgICBpZiAoc3RyLmluZGV4T2YoXCJyZ2JcIikgPj0gMCkge1xuICAgICAgcmV0dXJuICEhX0NvbG9yLnN0cmluZ1RvUmdiYShzdHIpO1xuICAgIH1cbiAgICByZXR1cm4gISFfQ29sb3IubmFtZVRvSGV4W3N0ci50b0xvd2VyQ2FzZSgpXTtcbiAgfVxuICAvKipcbiAgICogVGhlIGdpdmVuIHN0cmluZyBjYW4gYmUgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybWF0czpcbiAgICogLSAjcmdiXG4gICAqIC0gI3JyZ2diYlxuICAgKiAtIHJnYihyLCBnLCBiKVxuICAgKiAtIHJnYmEociwgZywgYiwgYSlcbiAgICogLSBDU1MgY29sb3IgbmFtZSBzdWNoIGFzICd3aGl0ZScsICdvcmFuZ2UnLCAnY3lhbicsIGV0Yy5cbiAgICogQHBhcmFtIHN0clxuICAgKi9cbiAgc3RhdGljIGZyb21TdHJpbmcoc3RyKSB7XG4gICAgaWYgKHN0ci5pbmRleE9mKFwiI1wiKSA+PSAwKSB7XG4gICAgICByZXR1cm4gX0NvbG9yLmZyb21IZXhTdHJpbmcoc3RyKTtcbiAgICB9XG4gICAgY29uc3QgaGV4ID0gX0NvbG9yLm5hbWVUb0hleFtzdHIudG9Mb3dlckNhc2UoKV07XG4gICAgaWYgKGhleCkge1xuICAgICAgcmV0dXJuIF9Db2xvci5mcm9tSGV4U3RyaW5nKGhleCk7XG4gICAgfVxuICAgIGlmIChzdHIuaW5kZXhPZihcInJnYlwiKSA+PSAwKSB7XG4gICAgICByZXR1cm4gX0NvbG9yLmZyb21SZ2JhU3RyaW5nKHN0cik7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb2xvciBzdHJpbmc6ICcke3N0cn0nYCk7XG4gIH1cbiAgLy8gU2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3MtY29sb3IvI2hleC1ub3RhdGlvblxuICBzdGF0aWMgcGFyc2VIZXgoaW5wdXQpIHtcbiAgICBpbnB1dCA9IGlucHV0LnJlcGxhY2UoLyAvZywgXCJcIikuc2xpY2UoMSk7XG4gICAgbGV0IHBhcnRzO1xuICAgIHN3aXRjaCAoaW5wdXQubGVuZ3RoKSB7XG4gICAgICBjYXNlIDY6XG4gICAgICBjYXNlIDg6XG4gICAgICAgIHBhcnRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHBhcnNlSW50KGAke2lucHV0W2ldfSR7aW5wdXRbaSArIDFdfWAsIDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHBhcnRzID0gaW5wdXQuc3BsaXQoXCJcIikubWFwKChwKSA9PiBwYXJzZUludChwLCAxNikpLm1hcCgocCkgPT4gcCArIHAgKiAxNik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAocGFydHM/Lmxlbmd0aCA+PSAzICYmIHBhcnRzLmV2ZXJ5KChwKSA9PiBwID49IDApKSB7XG4gICAgICBpZiAocGFydHMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHBhcnRzLnB1c2goMjU1KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG4gIH1cbiAgc3RhdGljIGZyb21IZXhTdHJpbmcoc3RyKSB7XG4gICAgY29uc3QgdmFsdWVzID0gX0NvbG9yLnBhcnNlSGV4KHN0cik7XG4gICAgaWYgKHZhbHVlcykge1xuICAgICAgY29uc3QgW3IsIGcsIGIsIGFdID0gdmFsdWVzO1xuICAgICAgcmV0dXJuIG5ldyBfQ29sb3IociAvIDI1NSwgZyAvIDI1NSwgYiAvIDI1NSwgYSAvIDI1NSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgTWFsZm9ybWVkIGhleGFkZWNpbWFsIGNvbG9yIHN0cmluZzogJyR7c3RyfSdgKTtcbiAgfVxuICBzdGF0aWMgc3RyaW5nVG9SZ2JhKHN0cikge1xuICAgIGxldCBwbyA9IC0xO1xuICAgIGxldCBwYyA9IC0xO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjID0gc3RyW2ldO1xuICAgICAgaWYgKHBvID09PSAtMSAmJiBjID09PSBcIihcIikge1xuICAgICAgICBwbyA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGMgPT09IFwiKVwiKSB7XG4gICAgICAgIHBjID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwbyA9PT0gLTEgfHwgcGMgPT09IC0xKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNvbnRlbnRzID0gc3RyLnN1YnN0cmluZyhwbyArIDEsIHBjKTtcbiAgICBjb25zdCBwYXJ0cyA9IGNvbnRlbnRzLnNwbGl0KFwiLFwiKTtcbiAgICBjb25zdCByZ2JhID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgbGV0IHZhbHVlID0gcGFyc2VGbG9hdChwYXJ0KTtcbiAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocGFydC5pbmRleE9mKFwiJVwiKSA+PSAwKSB7XG4gICAgICAgIHZhbHVlID0gY2xhbXAoMCwgdmFsdWUsIDEwMCk7XG4gICAgICAgIHZhbHVlIC89IDEwMDtcbiAgICAgIH0gZWxzZSBpZiAoaSA9PT0gMykge1xuICAgICAgICB2YWx1ZSA9IGNsYW1wKDAsIHZhbHVlLCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gY2xhbXAoMCwgdmFsdWUsIDI1NSk7XG4gICAgICAgIHZhbHVlIC89IDI1NTtcbiAgICAgIH1cbiAgICAgIHJnYmEucHVzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZ2JhO1xuICB9XG4gIHN0YXRpYyBmcm9tUmdiYVN0cmluZyhzdHIpIHtcbiAgICBjb25zdCByZ2JhID0gX0NvbG9yLnN0cmluZ1RvUmdiYShzdHIpO1xuICAgIGlmIChyZ2JhKSB7XG4gICAgICBpZiAocmdiYS5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfQ29sb3IocmdiYVswXSwgcmdiYVsxXSwgcmdiYVsyXSk7XG4gICAgICB9IGVsc2UgaWYgKHJnYmEubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHJldHVybiBuZXcgX0NvbG9yKHJnYmFbMF0sIHJnYmFbMV0sIHJnYmFbMl0sIHJnYmFbM10pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYE1hbGZvcm1lZCByZ2IvcmdiYSBjb2xvciBzdHJpbmc6ICcke3N0cn0nYCk7XG4gIH1cbiAgc3RhdGljIGZyb21BcnJheShhcnIpIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gNCkge1xuICAgICAgcmV0dXJuIG5ldyBfQ29sb3IoYXJyWzBdLCBhcnJbMV0sIGFyclsyXSwgYXJyWzNdKTtcbiAgICB9XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDMpIHtcbiAgICAgIHJldHVybiBuZXcgX0NvbG9yKGFyclswXSwgYXJyWzFdLCBhcnJbMl0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZ2l2ZW4gYXJyYXkgc2hvdWxkIGNvbnRhaW4gMyBvciA0IGNvbG9yIGNvbXBvbmVudHMgKG51bWJlcnMpLlwiKTtcbiAgfVxuICBzdGF0aWMgZnJvbUhTQihoLCBzLCBiLCBhbHBoYSA9IDEpIHtcbiAgICBjb25zdCByZ2IgPSBfQ29sb3IuSFNCdG9SR0IoaCwgcywgYik7XG4gICAgcmV0dXJuIG5ldyBfQ29sb3IocmdiWzBdLCByZ2JbMV0sIHJnYlsyXSwgYWxwaGEpO1xuICB9XG4gIHN0YXRpYyBmcm9tSFNMKGgsIHMsIGwsIGFscGhhID0gMSkge1xuICAgIGNvbnN0IHJnYiA9IF9Db2xvci5IU0x0b1JHQihoLCBzLCBsKTtcbiAgICByZXR1cm4gbmV3IF9Db2xvcihyZ2JbMF0sIHJnYlsxXSwgcmdiWzJdLCBhbHBoYSk7XG4gIH1cbiAgc3RhdGljIGZyb21PS0xDSChsLCBjLCBoLCBhbHBoYSA9IDEpIHtcbiAgICBjb25zdCByZ2IgPSBfQ29sb3IuT0tMQ0h0b1JHQihsLCBjLCBoKTtcbiAgICByZXR1cm4gbmV3IF9Db2xvcihyZ2JbMF0sIHJnYlsxXSwgcmdiWzJdLCBhbHBoYSk7XG4gIH1cbiAgc3RhdGljIHBhZEhleChzdHIpIHtcbiAgICByZXR1cm4gc3RyLmxlbmd0aCA9PT0gMSA/IFwiMFwiICsgc3RyIDogc3RyO1xuICB9XG4gIHRvSGV4U3RyaW5nKCkge1xuICAgIGxldCBoZXggPSBcIiNcIiArIF9Db2xvci5wYWRIZXgoTWF0aC5yb3VuZCh0aGlzLnIgKiAyNTUpLnRvU3RyaW5nKDE2KSkgKyBfQ29sb3IucGFkSGV4KE1hdGgucm91bmQodGhpcy5nICogMjU1KS50b1N0cmluZygxNikpICsgX0NvbG9yLnBhZEhleChNYXRoLnJvdW5kKHRoaXMuYiAqIDI1NSkudG9TdHJpbmcoMTYpKTtcbiAgICBpZiAodGhpcy5hIDwgMSkge1xuICAgICAgaGV4ICs9IF9Db2xvci5wYWRIZXgoTWF0aC5yb3VuZCh0aGlzLmEgKiAyNTUpLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG4gIH1cbiAgdG9SZ2JhU3RyaW5nKGZyYWN0aW9uRGlnaXRzID0gMykge1xuICAgIGNvbnN0IGNvbXBvbmVudHMgPSBbTWF0aC5yb3VuZCh0aGlzLnIgKiAyNTUpLCBNYXRoLnJvdW5kKHRoaXMuZyAqIDI1NSksIE1hdGgucm91bmQodGhpcy5iICogMjU1KV07XG4gICAgY29uc3QgayA9IE1hdGgucG93KDEwLCBmcmFjdGlvbkRpZ2l0cyk7XG4gICAgaWYgKHRoaXMuYSAhPT0gMSkge1xuICAgICAgY29tcG9uZW50cy5wdXNoKE1hdGgucm91bmQodGhpcy5hICogaykgLyBrKTtcbiAgICAgIHJldHVybiBgcmdiYSgke2NvbXBvbmVudHMuam9pbihcIiwgXCIpfSlgO1xuICAgIH1cbiAgICByZXR1cm4gYHJnYigke2NvbXBvbmVudHMuam9pbihcIiwgXCIpfSlgO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGlmICh0aGlzLmEgPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRvUmdiYVN0cmluZygpO1xuICB9XG4gIHRvSFNCKCkge1xuICAgIHJldHVybiBfQ29sb3IuUkdCdG9IU0IodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG4gIH1cbiAgc3RhdGljIFJHQnRvT0tMQ0gociwgZywgYikge1xuICAgIGNvbnN0IExTUkdCMCA9IHNyZ2JUb0xpbmVhcihyKTtcbiAgICBjb25zdCBMU1JHQjEgPSBzcmdiVG9MaW5lYXIoZyk7XG4gICAgY29uc3QgTFNSR0IyID0gc3JnYlRvTGluZWFyKGIpO1xuICAgIGNvbnN0IExNUzAgPSBNYXRoLmNicnQoMC40MTIyMjE0NzA4ICogTFNSR0IwICsgMC41MzYzMzI1MzYzICogTFNSR0IxICsgMC4wNTE0NDU5OTI5ICogTFNSR0IyKTtcbiAgICBjb25zdCBMTVMxID0gTWF0aC5jYnJ0KDAuMjExOTAzNDk4MiAqIExTUkdCMCArIDAuNjgwNjk5NTQ1MSAqIExTUkdCMSArIDAuMTA3Mzk2OTU2NiAqIExTUkdCMik7XG4gICAgY29uc3QgTE1TMiA9IE1hdGguY2JydCgwLjA4ODMwMjQ2MTkgKiBMU1JHQjAgKyAwLjI4MTcxODgzNzYgKiBMU1JHQjEgKyAwLjYyOTk3ODcwMDUgKiBMU1JHQjIpO1xuICAgIGNvbnN0IE9LTEFCMCA9IDAuMjEwNDU0MjU1MyAqIExNUzAgKyAwLjc5MzYxNzc4NSAqIExNUzEgLSAwLjAwNDA3MjA0NjggKiBMTVMyO1xuICAgIGNvbnN0IE9LTEFCMSA9IDEuOTc3OTk4NDk1MSAqIExNUzAgLSAyLjQyODU5MjIwNSAqIExNUzEgKyAwLjQ1MDU5MzcwOTkgKiBMTVMyO1xuICAgIGNvbnN0IE9LTEFCMiA9IDAuMDI1OTA0MDM3MSAqIExNUzAgKyAwLjc4Mjc3MTc2NjIgKiBMTVMxIC0gMC44MDg2NzU3NjYgKiBMTVMyO1xuICAgIGNvbnN0IGh1ZSA9IE1hdGguYXRhbjIoT0tMQUIyLCBPS0xBQjEpICogMTgwIC8gTWF0aC5QSTtcbiAgICBjb25zdCBPS0xDSDAgPSBPS0xBQjA7XG4gICAgY29uc3QgT0tMQ0gxID0gTWF0aC5oeXBvdChPS0xBQjEsIE9LTEFCMik7XG4gICAgY29uc3QgT0tMQ0gyID0gaHVlID49IDAgPyBodWUgOiBodWUgKyAzNjA7XG4gICAgcmV0dXJuIFtPS0xDSDAsIE9LTENIMSwgT0tMQ0gyXTtcbiAgfVxuICBzdGF0aWMgT0tMQ0h0b1JHQihsLCBjLCBoKSB7XG4gICAgY29uc3QgT0tMQUIwID0gbDtcbiAgICBjb25zdCBPS0xBQjEgPSBjICogTWF0aC5jb3MoaCAqIE1hdGguUEkgLyAxODApO1xuICAgIGNvbnN0IE9LTEFCMiA9IGMgKiBNYXRoLnNpbihoICogTWF0aC5QSSAvIDE4MCk7XG4gICAgY29uc3QgTE1TMCA9IChPS0xBQjAgKyAwLjM5NjMzNzc3NzQgKiBPS0xBQjEgKyAwLjIxNTgwMzc1NzMgKiBPS0xBQjIpICoqIDM7XG4gICAgY29uc3QgTE1TMSA9IChPS0xBQjAgLSAwLjEwNTU2MTM0NTggKiBPS0xBQjEgLSAwLjA2Mzg1NDE3MjggKiBPS0xBQjIpICoqIDM7XG4gICAgY29uc3QgTE1TMiA9IChPS0xBQjAgLSAwLjA4OTQ4NDE3NzUgKiBPS0xBQjEgLSAxLjI5MTQ4NTU0OCAqIE9LTEFCMikgKiogMztcbiAgICBjb25zdCBMU1JHQjAgPSA0LjA3Njc0MTY2MjEgKiBMTVMwIC0gMy4zMDc3MTE1OTEzICogTE1TMSArIDAuMjMwOTY5OTI5MiAqIExNUzI7XG4gICAgY29uc3QgTFNSR0IxID0gLTEuMjY4NDM4MDA0NiAqIExNUzAgKyAyLjYwOTc1NzQwMTEgKiBMTVMxIC0gMC4zNDEzMTkzOTY1ICogTE1TMjtcbiAgICBjb25zdCBMU1JHQjIgPSAtMC4wMDQxOTYwODYzICogTE1TMCAtIDAuNzAzNDE4NjE0NyAqIExNUzEgKyAxLjcwNzYxNDcwMSAqIExNUzI7XG4gICAgY29uc3QgU1JHQjAgPSBzcmdiRnJvbUxpbmVhcihMU1JHQjApO1xuICAgIGNvbnN0IFNSR0IxID0gc3JnYkZyb21MaW5lYXIoTFNSR0IxKTtcbiAgICBjb25zdCBTUkdCMiA9IHNyZ2JGcm9tTGluZWFyKExTUkdCMik7XG4gICAgcmV0dXJuIFtTUkdCMCwgU1JHQjEsIFNSR0IyXTtcbiAgfVxuICBzdGF0aWMgUkdCdG9IU0wociwgZywgYikge1xuICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIGNvbnN0IGwgPSAobWF4ICsgbWluKSAvIDI7XG4gICAgbGV0IGg7XG4gICAgbGV0IHM7XG4gICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICBoID0gMDtcbiAgICAgIHMgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkZWx0YTMgPSBtYXggLSBtaW47XG4gICAgICBzID0gbCA+IDAuNSA/IGRlbHRhMyAvICgyIC0gbWF4IC0gbWluKSA6IGRlbHRhMyAvIChtYXggKyBtaW4pO1xuICAgICAgaWYgKG1heCA9PT0gcikge1xuICAgICAgICBoID0gKGcgLSBiKSAvIGRlbHRhMyArIChnIDwgYiA/IDYgOiAwKTtcbiAgICAgIH0gZWxzZSBpZiAobWF4ID09PSBnKSB7XG4gICAgICAgIGggPSAoYiAtIHIpIC8gZGVsdGEzICsgMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGggPSAociAtIGcpIC8gZGVsdGEzICsgNDtcbiAgICAgIH1cbiAgICAgIGggKj0gMzYwIC8gNjtcbiAgICB9XG4gICAgcmV0dXJuIFtoLCBzLCBsXTtcbiAgfVxuICBzdGF0aWMgSFNMdG9SR0IoaCwgcywgbCkge1xuICAgIGggPSAoaCAlIDM2MCArIDM2MCkgJSAzNjA7XG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIHJldHVybiBbbCwgbCwgbF07XG4gICAgfVxuICAgIGNvbnN0IHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICAgIGNvbnN0IHAgPSAyICogbCAtIHE7XG4gICAgZnVuY3Rpb24gaHVlVG9SZ2IodCkge1xuICAgICAgaWYgKHQgPCAwKVxuICAgICAgICB0ICs9IDE7XG4gICAgICBpZiAodCA+IDEpXG4gICAgICAgIHQgLT0gMTtcbiAgICAgIGlmICh0IDwgMSAvIDYpXG4gICAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgICAgaWYgKHQgPCAxIC8gMilcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgICBpZiAodCA8IDIgLyAzKVxuICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgY29uc3QgciA9IGh1ZVRvUmdiKGggLyAzNjAgKyAxIC8gMyk7XG4gICAgY29uc3QgZyA9IGh1ZVRvUmdiKGggLyAzNjApO1xuICAgIGNvbnN0IGIgPSBodWVUb1JnYihoIC8gMzYwIC0gMSAvIDMpO1xuICAgIHJldHVybiBbciwgZywgYl07XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBnaXZlbiBSR0IgdHJpcGxlIHRvIGFuIGFycmF5IG9mIEhTQiAoSFNWKSBjb21wb25lbnRzLlxuICAgKi9cbiAgc3RhdGljIFJHQnRvSFNCKHIsIGcsIGIpIHtcbiAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICBjb25zdCBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICBjb25zdCBTID0gbWF4ID09PSAwID8gMCA6IChtYXggLSBtaW4pIC8gbWF4O1xuICAgIGxldCBIID0gMDtcbiAgICBpZiAobWluICE9PSBtYXgpIHtcbiAgICAgIGNvbnN0IGRlbHRhMyA9IG1heCAtIG1pbjtcbiAgICAgIGNvbnN0IHJjID0gKG1heCAtIHIpIC8gZGVsdGEzO1xuICAgICAgY29uc3QgZ2MgPSAobWF4IC0gZykgLyBkZWx0YTM7XG4gICAgICBjb25zdCBiYyA9IChtYXggLSBiKSAvIGRlbHRhMztcbiAgICAgIGlmIChyID09PSBtYXgpIHtcbiAgICAgICAgSCA9IGJjIC0gZ2M7XG4gICAgICB9IGVsc2UgaWYgKGcgPT09IG1heCkge1xuICAgICAgICBIID0gMiArIHJjIC0gYmM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBIID0gNCArIGdjIC0gcmM7XG4gICAgICB9XG4gICAgICBIIC89IDY7XG4gICAgICBpZiAoSCA8IDApIHtcbiAgICAgICAgSCA9IEggKyAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW0ggKiAzNjAsIFMsIG1heF07XG4gIH1cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBnaXZlbiBIU0IgKEhTVikgdHJpcGxlIHRvIGFuIGFycmF5IG9mIFJHQiBjb21wb25lbnRzLlxuICAgKi9cbiAgc3RhdGljIEhTQnRvUkdCKEgsIFMsIEIpIHtcbiAgICBIID0gKEggJSAzNjAgKyAzNjApICUgMzYwIC8gMzYwO1xuICAgIGxldCByID0gMDtcbiAgICBsZXQgZyA9IDA7XG4gICAgbGV0IGIgPSAwO1xuICAgIGlmIChTID09PSAwKSB7XG4gICAgICByID0gZyA9IGIgPSBCO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoID0gKEggLSBNYXRoLmZsb29yKEgpKSAqIDY7XG4gICAgICBjb25zdCBmID0gaCAtIE1hdGguZmxvb3IoaCk7XG4gICAgICBjb25zdCBwID0gQiAqICgxIC0gUyk7XG4gICAgICBjb25zdCBxID0gQiAqICgxIC0gUyAqIGYpO1xuICAgICAgY29uc3QgdCA9IEIgKiAoMSAtIFMgKiAoMSAtIGYpKTtcbiAgICAgIHN3aXRjaCAoaCA+PiAwKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByID0gQjtcbiAgICAgICAgICBnID0gdDtcbiAgICAgICAgICBiID0gcDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHIgPSBxO1xuICAgICAgICAgIGcgPSBCO1xuICAgICAgICAgIGIgPSBwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgciA9IHA7XG4gICAgICAgICAgZyA9IEI7XG4gICAgICAgICAgYiA9IHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByID0gcDtcbiAgICAgICAgICBnID0gcTtcbiAgICAgICAgICBiID0gQjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHIgPSB0O1xuICAgICAgICAgIGcgPSBwO1xuICAgICAgICAgIGIgPSBCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgciA9IEI7XG4gICAgICAgICAgZyA9IHA7XG4gICAgICAgICAgYiA9IHE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbciwgZywgYl07XG4gIH1cbiAgc3RhdGljIG1peChjMCwgYzEsIHQpIHtcbiAgICByZXR1cm4gbmV3IF9Db2xvcihsZXJwKGMwLnIsIGMxLnIsIHQpLCBsZXJwKGMwLmcsIGMxLmcsIHQpLCBsZXJwKGMwLmIsIGMxLmIsIHQpLCBsZXJwKGMwLmEsIGMxLmEsIHQpKTtcbiAgfVxufTtcbi8qKlxuICogQ1NTIENvbG9yIE1vZHVsZSBMZXZlbCA0OlxuICogaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy1jb2xvci8jbmFtZWQtY29sb3JzXG4gKi9cbl9Db2xvci5uYW1lVG9IZXggPSB7XG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgX19wcm90b19fOiBudWxsLFxuICBhbGljZWJsdWU6IFwiI0YwRjhGRlwiLFxuICBhbnRpcXVld2hpdGU6IFwiI0ZBRUJEN1wiLFxuICBhcXVhOiBcIiMwMEZGRkZcIixcbiAgYXF1YW1hcmluZTogXCIjN0ZGRkQ0XCIsXG4gIGF6dXJlOiBcIiNGMEZGRkZcIixcbiAgYmVpZ2U6IFwiI0Y1RjVEQ1wiLFxuICBiaXNxdWU6IFwiI0ZGRTRDNFwiLFxuICBibGFjazogXCIjMDAwMDAwXCIsXG4gIGJsYW5jaGVkYWxtb25kOiBcIiNGRkVCQ0RcIixcbiAgYmx1ZTogXCIjMDAwMEZGXCIsXG4gIGJsdWV2aW9sZXQ6IFwiIzhBMkJFMlwiLFxuICBicm93bjogXCIjQTUyQTJBXCIsXG4gIGJ1cmx5d29vZDogXCIjREVCODg3XCIsXG4gIGNhZGV0Ymx1ZTogXCIjNUY5RUEwXCIsXG4gIGNoYXJ0cmV1c2U6IFwiIzdGRkYwMFwiLFxuICBjaG9jb2xhdGU6IFwiI0QyNjkxRVwiLFxuICBjb3JhbDogXCIjRkY3RjUwXCIsXG4gIGNvcm5mbG93ZXJibHVlOiBcIiM2NDk1RURcIixcbiAgY29ybnNpbGs6IFwiI0ZGRjhEQ1wiLFxuICBjcmltc29uOiBcIiNEQzE0M0NcIixcbiAgY3lhbjogXCIjMDBGRkZGXCIsXG4gIGRhcmtibHVlOiBcIiMwMDAwOEJcIixcbiAgZGFya2N5YW46IFwiIzAwOEI4QlwiLFxuICBkYXJrZ29sZGVucm9kOiBcIiNCODg2MEJcIixcbiAgZGFya2dyYXk6IFwiI0E5QTlBOVwiLFxuICBkYXJrZ3JlZW46IFwiIzAwNjQwMFwiLFxuICBkYXJrZ3JleTogXCIjQTlBOUE5XCIsXG4gIGRhcmtraGFraTogXCIjQkRCNzZCXCIsXG4gIGRhcmttYWdlbnRhOiBcIiM4QjAwOEJcIixcbiAgZGFya29saXZlZ3JlZW46IFwiIzU1NkIyRlwiLFxuICBkYXJrb3JhbmdlOiBcIiNGRjhDMDBcIixcbiAgZGFya29yY2hpZDogXCIjOTkzMkNDXCIsXG4gIGRhcmtyZWQ6IFwiIzhCMDAwMFwiLFxuICBkYXJrc2FsbW9uOiBcIiNFOTk2N0FcIixcbiAgZGFya3NlYWdyZWVuOiBcIiM4RkJDOEZcIixcbiAgZGFya3NsYXRlYmx1ZTogXCIjNDgzRDhCXCIsXG4gIGRhcmtzbGF0ZWdyYXk6IFwiIzJGNEY0RlwiLFxuICBkYXJrc2xhdGVncmV5OiBcIiMyRjRGNEZcIixcbiAgZGFya3R1cnF1b2lzZTogXCIjMDBDRUQxXCIsXG4gIGRhcmt2aW9sZXQ6IFwiIzk0MDBEM1wiLFxuICBkZWVwcGluazogXCIjRkYxNDkzXCIsXG4gIGRlZXBza3libHVlOiBcIiMwMEJGRkZcIixcbiAgZGltZ3JheTogXCIjNjk2OTY5XCIsXG4gIGRpbWdyZXk6IFwiIzY5Njk2OVwiLFxuICBkb2RnZXJibHVlOiBcIiMxRTkwRkZcIixcbiAgZmlyZWJyaWNrOiBcIiNCMjIyMjJcIixcbiAgZmxvcmFsd2hpdGU6IFwiI0ZGRkFGMFwiLFxuICBmb3Jlc3RncmVlbjogXCIjMjI4QjIyXCIsXG4gIGZ1Y2hzaWE6IFwiI0ZGMDBGRlwiLFxuICBnYWluc2Jvcm86IFwiI0RDRENEQ1wiLFxuICBnaG9zdHdoaXRlOiBcIiNGOEY4RkZcIixcbiAgZ29sZDogXCIjRkZENzAwXCIsXG4gIGdvbGRlbnJvZDogXCIjREFBNTIwXCIsXG4gIGdyYXk6IFwiIzgwODA4MFwiLFxuICBncmVlbjogXCIjMDA4MDAwXCIsXG4gIGdyZWVueWVsbG93OiBcIiNBREZGMkZcIixcbiAgZ3JleTogXCIjODA4MDgwXCIsXG4gIGhvbmV5ZGV3OiBcIiNGMEZGRjBcIixcbiAgaG90cGluazogXCIjRkY2OUI0XCIsXG4gIGluZGlhbnJlZDogXCIjQ0Q1QzVDXCIsXG4gIGluZGlnbzogXCIjNEIwMDgyXCIsXG4gIGl2b3J5OiBcIiNGRkZGRjBcIixcbiAga2hha2k6IFwiI0YwRTY4Q1wiLFxuICBsYXZlbmRlcjogXCIjRTZFNkZBXCIsXG4gIGxhdmVuZGVyYmx1c2g6IFwiI0ZGRjBGNVwiLFxuICBsYXduZ3JlZW46IFwiIzdDRkMwMFwiLFxuICBsZW1vbmNoaWZmb246IFwiI0ZGRkFDRFwiLFxuICBsaWdodGJsdWU6IFwiI0FERDhFNlwiLFxuICBsaWdodGNvcmFsOiBcIiNGMDgwODBcIixcbiAgbGlnaHRjeWFuOiBcIiNFMEZGRkZcIixcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFwiI0ZBRkFEMlwiLFxuICBsaWdodGdyYXk6IFwiI0QzRDNEM1wiLFxuICBsaWdodGdyZWVuOiBcIiM5MEVFOTBcIixcbiAgbGlnaHRncmV5OiBcIiNEM0QzRDNcIixcbiAgbGlnaHRwaW5rOiBcIiNGRkI2QzFcIixcbiAgbGlnaHRzYWxtb246IFwiI0ZGQTA3QVwiLFxuICBsaWdodHNlYWdyZWVuOiBcIiMyMEIyQUFcIixcbiAgbGlnaHRza3libHVlOiBcIiM4N0NFRkFcIixcbiAgbGlnaHRzbGF0ZWdyYXk6IFwiIzc3ODg5OVwiLFxuICBsaWdodHNsYXRlZ3JleTogXCIjNzc4ODk5XCIsXG4gIGxpZ2h0c3RlZWxibHVlOiBcIiNCMEM0REVcIixcbiAgbGlnaHR5ZWxsb3c6IFwiI0ZGRkZFMFwiLFxuICBsaW1lOiBcIiMwMEZGMDBcIixcbiAgbGltZWdyZWVuOiBcIiMzMkNEMzJcIixcbiAgbGluZW46IFwiI0ZBRjBFNlwiLFxuICBtYWdlbnRhOiBcIiNGRjAwRkZcIixcbiAgbWFyb29uOiBcIiM4MDAwMDBcIixcbiAgbWVkaXVtYXF1YW1hcmluZTogXCIjNjZDREFBXCIsXG4gIG1lZGl1bWJsdWU6IFwiIzAwMDBDRFwiLFxuICBtZWRpdW1vcmNoaWQ6IFwiI0JBNTVEM1wiLFxuICBtZWRpdW1wdXJwbGU6IFwiIzkzNzBEQlwiLFxuICBtZWRpdW1zZWFncmVlbjogXCIjM0NCMzcxXCIsXG4gIG1lZGl1bXNsYXRlYmx1ZTogXCIjN0I2OEVFXCIsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiBcIiMwMEZBOUFcIixcbiAgbWVkaXVtdHVycXVvaXNlOiBcIiM0OEQxQ0NcIixcbiAgbWVkaXVtdmlvbGV0cmVkOiBcIiNDNzE1ODVcIixcbiAgbWlkbmlnaHRibHVlOiBcIiMxOTE5NzBcIixcbiAgbWludGNyZWFtOiBcIiNGNUZGRkFcIixcbiAgbWlzdHlyb3NlOiBcIiNGRkU0RTFcIixcbiAgbW9jY2FzaW46IFwiI0ZGRTRCNVwiLFxuICBuYXZham93aGl0ZTogXCIjRkZERUFEXCIsXG4gIG5hdnk6IFwiIzAwMDA4MFwiLFxuICBvbGRsYWNlOiBcIiNGREY1RTZcIixcbiAgb2xpdmU6IFwiIzgwODAwMFwiLFxuICBvbGl2ZWRyYWI6IFwiIzZCOEUyM1wiLFxuICBvcmFuZ2U6IFwiI0ZGQTUwMFwiLFxuICBvcmFuZ2VyZWQ6IFwiI0ZGNDUwMFwiLFxuICBvcmNoaWQ6IFwiI0RBNzBENlwiLFxuICBwYWxlZ29sZGVucm9kOiBcIiNFRUU4QUFcIixcbiAgcGFsZWdyZWVuOiBcIiM5OEZCOThcIixcbiAgcGFsZXR1cnF1b2lzZTogXCIjQUZFRUVFXCIsXG4gIHBhbGV2aW9sZXRyZWQ6IFwiI0RCNzA5M1wiLFxuICBwYXBheWF3aGlwOiBcIiNGRkVGRDVcIixcbiAgcGVhY2hwdWZmOiBcIiNGRkRBQjlcIixcbiAgcGVydTogXCIjQ0Q4NTNGXCIsXG4gIHBpbms6IFwiI0ZGQzBDQlwiLFxuICBwbHVtOiBcIiNEREEwRERcIixcbiAgcG93ZGVyYmx1ZTogXCIjQjBFMEU2XCIsXG4gIHB1cnBsZTogXCIjODAwMDgwXCIsXG4gIHJlYmVjY2FwdXJwbGU6IFwiIzY2MzM5OVwiLFxuICByZWQ6IFwiI0ZGMDAwMFwiLFxuICByb3N5YnJvd246IFwiI0JDOEY4RlwiLFxuICByb3lhbGJsdWU6IFwiIzQxNjlFMVwiLFxuICBzYWRkbGVicm93bjogXCIjOEI0NTEzXCIsXG4gIHNhbG1vbjogXCIjRkE4MDcyXCIsXG4gIHNhbmR5YnJvd246IFwiI0Y0QTQ2MFwiLFxuICBzZWFncmVlbjogXCIjMkU4QjU3XCIsXG4gIHNlYXNoZWxsOiBcIiNGRkY1RUVcIixcbiAgc2llbm5hOiBcIiNBMDUyMkRcIixcbiAgc2lsdmVyOiBcIiNDMEMwQzBcIixcbiAgc2t5Ymx1ZTogXCIjODdDRUVCXCIsXG4gIHNsYXRlYmx1ZTogXCIjNkE1QUNEXCIsXG4gIHNsYXRlZ3JheTogXCIjNzA4MDkwXCIsXG4gIHNsYXRlZ3JleTogXCIjNzA4MDkwXCIsXG4gIHNub3c6IFwiI0ZGRkFGQVwiLFxuICBzcHJpbmdncmVlbjogXCIjMDBGRjdGXCIsXG4gIHN0ZWVsYmx1ZTogXCIjNDY4MkI0XCIsXG4gIHRhbjogXCIjRDJCNDhDXCIsXG4gIHRlYWw6IFwiIzAwODA4MFwiLFxuICB0aGlzdGxlOiBcIiNEOEJGRDhcIixcbiAgdG9tYXRvOiBcIiNGRjYzNDdcIixcbiAgdHJhbnNwYXJlbnQ6IFwiIzAwMDAwMDAwXCIsXG4gIHR1cnF1b2lzZTogXCIjNDBFMEQwXCIsXG4gIHZpb2xldDogXCIjRUU4MkVFXCIsXG4gIHdoZWF0OiBcIiNGNURFQjNcIixcbiAgd2hpdGU6IFwiI0ZGRkZGRlwiLFxuICB3aGl0ZXNtb2tlOiBcIiNGNUY1RjVcIixcbiAgeWVsbG93OiBcIiNGRkZGMDBcIixcbiAgeWVsbG93Z3JlZW46IFwiIzlBQ0QzMlwiXG59O1xudmFyIENvbG9yID0gX0NvbG9yO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2ludGVycG9sYXRlLnRzXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZU51bWJlcihhLCBiKSB7XG4gIHJldHVybiAoZCkgPT4gTnVtYmVyKGEpICogKDEgLSBkKSArIE51bWJlcihiKSAqIGQ7XG59XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUNvbG9yKGEsIGIpIHtcbiAgaWYgKHR5cGVvZiBhID09PSBcInN0cmluZ1wiKSB7XG4gICAgdHJ5IHtcbiAgICAgIGEgPSBDb2xvci5mcm9tU3RyaW5nKGEpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGEgPSBDb2xvci5mcm9tQXJyYXkoWzAsIDAsIDBdKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBiID09PSBcInN0cmluZ1wiKSB7XG4gICAgdHJ5IHtcbiAgICAgIGIgPSBDb2xvci5mcm9tU3RyaW5nKGIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGIgPSBDb2xvci5mcm9tQXJyYXkoWzAsIDAsIDBdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChkKSA9PiBDb2xvci5taXgoYSwgYiwgZCkudG9SZ2JhU3RyaW5nKCk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvZGVjb3JhdG9yLnRzXG52YXIgQlJFQUtfVFJBTlNGT1JNX0NIQUlOID0gU3ltYm9sKFwiQlJFQUtcIik7XG52YXIgQ09ORklHX0tFWSA9IFwiX19kZWNvcmF0b3JfY29uZmlnXCI7XG5mdW5jdGlvbiBpbml0aWFsaXNlQ29uZmlnKHRhcmdldCwgcHJvcGVydHlLZXlPclN5bWJvbCkge1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIENPTkZJR19LRVkpID09IG51bGwpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBDT05GSUdfS0VZLCB7IHZhbHVlOiB7fSB9KTtcbiAgfVxuICBjb25zdCBjb25maWcgPSB0YXJnZXRbQ09ORklHX0tFWV07XG4gIGNvbnN0IHByb3BlcnR5S2V5ID0gcHJvcGVydHlLZXlPclN5bWJvbC50b1N0cmluZygpO1xuICBpZiAodHlwZW9mIGNvbmZpZ1twcm9wZXJ0eUtleV0gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gY29uZmlnW3Byb3BlcnR5S2V5XTtcbiAgfVxuICBjb25zdCB2YWx1ZXNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgY29uZmlnW3Byb3BlcnR5S2V5XSA9IHsgc2V0dGVyczogW10sIGdldHRlcnM6IFtdLCBvYnNlcnZlcnM6IFtdLCB2YWx1ZXNNYXAgfTtcbiAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wZXJ0eUtleU9yU3ltYm9sKTtcbiAgY29uc3QgcHJldlNldCA9IGRlc2NyaXB0b3I/LnNldDtcbiAgY29uc3QgcHJldkdldCA9IGRlc2NyaXB0b3I/LmdldDtcbiAgY29uc3QgZ2V0dGVyID0gZnVuY3Rpb24oKSB7XG4gICAgbGV0IHZhbHVlID0gcHJldkdldCA/IHByZXZHZXQuY2FsbCh0aGlzKSA6IHZhbHVlc01hcC5nZXQodGhpcyk7XG4gICAgZm9yIChjb25zdCB0cmFuc2Zvcm1GbiBvZiBjb25maWdbcHJvcGVydHlLZXldLmdldHRlcnMpIHtcbiAgICAgIHZhbHVlID0gdHJhbnNmb3JtRm4odGhpcywgcHJvcGVydHlLZXlPclN5bWJvbCwgdmFsdWUpO1xuICAgICAgaWYgKHZhbHVlID09PSBCUkVBS19UUkFOU0ZPUk1fQ0hBSU4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG4gIGNvbnN0IHNldHRlciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgY29uc3QgeyBzZXR0ZXJzLCBvYnNlcnZlcnMgfSA9IGNvbmZpZ1twcm9wZXJ0eUtleV07XG4gICAgbGV0IG9sZFZhbHVlO1xuICAgIGlmIChzZXR0ZXJzLnNvbWUoKGYpID0+IGYubGVuZ3RoID4gMikpIHtcbiAgICAgIG9sZFZhbHVlID0gcHJldkdldCA/IHByZXZHZXQuY2FsbCh0aGlzKSA6IHZhbHVlc01hcC5nZXQodGhpcyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdHJhbnNmb3JtRm4gb2Ygc2V0dGVycykge1xuICAgICAgdmFsdWUgPSB0cmFuc2Zvcm1Gbih0aGlzLCBwcm9wZXJ0eUtleU9yU3ltYm9sLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgaWYgKHZhbHVlID09PSBCUkVBS19UUkFOU0ZPUk1fQ0hBSU4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJldlNldCkge1xuICAgICAgcHJldlNldC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzTWFwLnNldCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXJGbiBvZiBvYnNlcnZlcnMpIHtcbiAgICAgIG9ic2VydmVyRm4odGhpcywgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICB9XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3BlcnR5S2V5T3JTeW1ib2wsIHtcbiAgICBzZXQ6IHNldHRlcixcbiAgICBnZXQ6IGdldHRlcixcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBjb25maWdbcHJvcGVydHlLZXldO1xufVxuZnVuY3Rpb24gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KHNldFRyYW5zZm9ybSwgZ2V0VHJhbnNmb3JtLCBjb25maWdNZXRhZGF0YSkge1xuICByZXR1cm4gKHRhcmdldCwgcHJvcGVydHlLZXlPclN5bWJvbCkgPT4ge1xuICAgIGNvbnN0IGNvbmZpZyA9IGluaXRpYWxpc2VDb25maWcodGFyZ2V0LCBwcm9wZXJ0eUtleU9yU3ltYm9sKTtcbiAgICBjb25maWcuc2V0dGVycy5wdXNoKHNldFRyYW5zZm9ybSk7XG4gICAgaWYgKGdldFRyYW5zZm9ybSkge1xuICAgICAgY29uZmlnLmdldHRlcnMudW5zaGlmdChnZXRUcmFuc2Zvcm0pO1xuICAgIH1cbiAgICBpZiAoY29uZmlnTWV0YWRhdGEpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBjb25maWdNZXRhZGF0YSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gYWRkT2JzZXJ2ZXJUb0luc3RhbmNlUHJvcGVydHkoc2V0T2JzZXJ2ZXIpIHtcbiAgcmV0dXJuICh0YXJnZXQsIHByb3BlcnR5S2V5T3JTeW1ib2wpID0+IHtcbiAgICBpbml0aWFsaXNlQ29uZmlnKHRhcmdldCwgcHJvcGVydHlLZXlPclN5bWJvbCkub2JzZXJ2ZXJzLnB1c2goc2V0T2JzZXJ2ZXIpO1xuICB9O1xufVxuZnVuY3Rpb24gaXNEZWNvcmF0ZWRPYmplY3QodGFyZ2V0KSB7XG4gIHJldHVybiB0eXBlb2YgdGFyZ2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIENPTkZJR19LRVkgaW4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gbGlzdERlY29yYXRlZFByb3BlcnRpZXModGFyZ2V0KSB7XG4gIGNvbnN0IHRhcmdldHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICB3aGlsZSAoaXNEZWNvcmF0ZWRPYmplY3QodGFyZ2V0KSkge1xuICAgIHRhcmdldHMuYWRkKHRhcmdldD8uW0NPTkZJR19LRVldKTtcbiAgICB0YXJnZXQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGFyZ2V0KTtcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbSh0YXJnZXRzKS5mbGF0TWFwKChjb25maWdNYXApID0+IE9iamVjdC5rZXlzKGNvbmZpZ01hcCkpO1xufVxuZnVuY3Rpb24gZXh0cmFjdERlY29yYXRlZFByb3BlcnRpZXModGFyZ2V0KSB7XG4gIHJldHVybiBsaXN0RGVjb3JhdGVkUHJvcGVydGllcyh0YXJnZXQpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICByZXN1bHRba2V5XSA9IHRhcmdldFtrZXldID8/IG51bGw7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gZXh0cmFjdERlY29yYXRlZFByb3BlcnR5TWV0YWRhdGEodGFyZ2V0LCBwcm9wZXJ0eUtleU9yU3ltYm9sKSB7XG4gIGNvbnN0IHByb3BlcnR5S2V5ID0gcHJvcGVydHlLZXlPclN5bWJvbC50b1N0cmluZygpO1xuICB3aGlsZSAoaXNEZWNvcmF0ZWRPYmplY3QodGFyZ2V0KSkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHRhcmdldFtDT05GSUdfS0VZXTtcbiAgICBpZiAoT2JqZWN0Lmhhc093bihjb25maWcsIHByb3BlcnR5S2V5KSkge1xuICAgICAgcmV0dXJuIGNvbmZpZ1twcm9wZXJ0eUtleV07XG4gICAgfVxuICAgIHRhcmdldCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0YXJnZXQpO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdHlwZS1ndWFyZHMudHNcbmZ1bmN0aW9uIGlzRGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPSBudWxsO1xufVxuZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJib29sZWFuXCI7XG59XG5mdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWREYXRlKHZhbHVlKSB7XG4gIHJldHVybiBpc0RhdGUodmFsdWUpICYmICFpc05hTihOdW1iZXIodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cDtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiO1xufVxuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhaXNBcnJheSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59XG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xufVxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIjtcbn1cbmZ1bmN0aW9uIGlzRmluaXRlTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiBOdW1iZXIuaXNGaW5pdGUodmFsdWUpO1xufVxuZnVuY3Rpb24gaXNIdG1sRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuZnVuY3Rpb24gaXNFbnVtS2V5KGVudW1PYmplY3QsIGVudW1LZXkpIHtcbiAgcmV0dXJuIGlzU3RyaW5nKGVudW1LZXkpICYmIE9iamVjdC5rZXlzKGVudW1PYmplY3QpLmluY2x1ZGVzKGVudW1LZXkpO1xufVxuZnVuY3Rpb24gaXNFbnVtVmFsdWUoZW51bU9iamVjdCwgZW51bVZhbHVlKSB7XG4gIHJldHVybiBPYmplY3QudmFsdWVzKGVudW1PYmplY3QpLmluY2x1ZGVzKGVudW1WYWx1ZSk7XG59XG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN5bWJvbFwiO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL29iamVjdC50c1xuZnVuY3Rpb24gZGVlcE1lcmdlKC4uLnNvdXJjZXMpIHtcbiAgcmV0dXJuIG1lcmdlRGVmYXVsdHMoLi4uc291cmNlcy5yZXZlcnNlKCkpO1xufVxuZnVuY3Rpb24gbWVyZ2VEZWZhdWx0cyguLi5zb3VyY2VzKSB7XG4gIGNvbnN0IHRhcmdldCA9IHt9O1xuICBmb3IgKGNvbnN0IHNvdXJjZSBvZiBzb3VyY2VzKSB7XG4gICAgaWYgKCFpc09iamVjdChzb3VyY2UpKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3Qga2V5cyA9IGlzRGVjb3JhdGVkT2JqZWN0KHNvdXJjZSkgPyBsaXN0RGVjb3JhdGVkUHJvcGVydGllcyhzb3VyY2UpIDogT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAoaXNQbGFpbk9iamVjdCh0YXJnZXRba2V5XSkgJiYgaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBtZXJnZURlZmF1bHRzKHRhcmdldFtrZXldLCBzb3VyY2Vba2V5XSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRba2V5XSA/PyAodGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBtZXJnZUFycmF5RGVmYXVsdHMoZGF0YUFycmF5LCAuLi5pdGVtRGVmYXVsdHMpIHtcbiAgaWYgKGl0ZW1EZWZhdWx0cyAmJiBpc0FycmF5KGRhdGFBcnJheSkpIHtcbiAgICByZXR1cm4gZGF0YUFycmF5Lm1hcCgoaXRlbSkgPT4gbWVyZ2VEZWZhdWx0cyhpdGVtLCAuLi5pdGVtRGVmYXVsdHMpKTtcbiAgfVxuICByZXR1cm4gZGF0YUFycmF5O1xufVxuZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdDIsIG1hcHBlcikge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqZWN0MikucmVkdWNlKFxuICAgIChyZXN1bHQsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgcmVzdWx0W2tleV0gPSBtYXBwZXIodmFsdWUsIGtleSwgb2JqZWN0Mik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAge31cbiAgKTtcbn1cbmZ1bmN0aW9uIHdpdGhvdXQob2JqZWN0Miwga2V5cykge1xuICBjb25zdCBjbG9uZSA9IHsgLi4ub2JqZWN0MiB9O1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgZGVsZXRlIGNsb25lW2tleV07XG4gIH1cbiAgcmV0dXJuIGNsb25lO1xufVxuZnVuY3Rpb24gZ2V0UGF0aChvYmplY3QyLCBwYXRoKSB7XG4gIGNvbnN0IHBhdGhBcnJheSA9IGlzQXJyYXkocGF0aCkgPyBwYXRoIDogcGF0aC5zcGxpdChcIi5cIik7XG4gIHJldHVybiBwYXRoQXJyYXkucmVkdWNlKCh2YWx1ZSwgcGF0aEtleSkgPT4gdmFsdWVbcGF0aEtleV0sIG9iamVjdDIpO1xufVxudmFyIFNLSVBfSlNfQlVJTFRJTlMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJfX3Byb3RvX19cIiwgXCJjb25zdHJ1Y3RvclwiLCBcInByb3RvdHlwZVwiXSk7XG5mdW5jdGlvbiBzZXRQYXRoKG9iamVjdDIsIHBhdGgsIG5ld1ZhbHVlKSB7XG4gIGNvbnN0IHBhdGhBcnJheSA9IGlzQXJyYXkocGF0aCkgPyBwYXRoLnNsaWNlKCkgOiBwYXRoLnNwbGl0KFwiLlwiKTtcbiAgY29uc3QgbGFzdEtleSA9IHBhdGhBcnJheS5wb3AoKTtcbiAgaWYgKHBhdGhBcnJheS5zb21lKChwKSA9PiBTS0lQX0pTX0JVSUxUSU5TLmhhcyhwKSkpXG4gICAgcmV0dXJuO1xuICBjb25zdCBsYXN0T2JqZWN0ID0gcGF0aEFycmF5LnJlZHVjZSgodmFsdWUsIHBhdGhLZXkpID0+IHZhbHVlW3BhdGhLZXldLCBvYmplY3QyKTtcbiAgbGFzdE9iamVjdFtsYXN0S2V5XSA9IG5ld1ZhbHVlO1xuICByZXR1cm4gbGFzdE9iamVjdFtsYXN0S2V5XTtcbn1cbmZ1bmN0aW9uIHBhcnRpYWxBc3NpZ24oa2V5c1RvQ29weSwgdGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKHNvdXJjZSA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfVxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzVG9Db3B5KSB7XG4gICAgY29uc3QgdmFsdWUgPSBzb3VyY2Vba2V5XTtcbiAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9wcm9wZXJ0aWVzLnRzXG52YXIgQmFzZVByb3BlcnRpZXMgPSBjbGFzcyB7XG4gIHNldChwcm9wZXJ0aWVzKSB7XG4gICAgY29uc3QgeyBjbGFzc05hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgfSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgaWYgKHR5cGVvZiBwcm9wZXJ0aWVzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICBMb2dnZXIud2FybihgdW5hYmxlIHRvIHNldCAke2NsYXNzTmFtZX0gLSBleHBlY3RpbmcgYSBwcm9wZXJ0aWVzIG9iamVjdGApO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHByb3BlcnRpZXMpKTtcbiAgICBmb3IgKGNvbnN0IHByb3BlcnR5S2V5IG9mIGxpc3REZWNvcmF0ZWRQcm9wZXJ0aWVzKHRoaXMpKSB7XG4gICAgICBpZiAoa2V5cy5oYXMocHJvcGVydHlLZXkpKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gcHJvcGVydGllc1twcm9wZXJ0eUtleV07XG4gICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoaXNQcm9wZXJ0aWVzKHNlbGZbcHJvcGVydHlLZXldKSkge1xuICAgICAgICAgIHNlbGZbcHJvcGVydHlLZXldID0gc2VsZltwcm9wZXJ0eUtleV0gaW5zdGFuY2VvZiBQcm9wZXJ0aWVzQXJyYXkgPyBzZWxmW3Byb3BlcnR5S2V5XS5yZXNldCh2YWx1ZSkgOiBzZWxmW3Byb3BlcnR5S2V5XS5zZXQodmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGZbcHJvcGVydHlLZXldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAga2V5cy5kZWxldGUocHJvcGVydHlLZXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHVua25vd25LZXkgb2Yga2V5cykge1xuICAgICAgTG9nZ2VyLndhcm4oYHVuYWJsZSB0byBzZXQgWyR7dW5rbm93bktleX1dIGluICR7Y2xhc3NOYW1lfSAtIHByb3BlcnR5IGlzIHVua25vd25gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgaXNWYWxpZCh3YXJuaW5nUHJlZml4KSB7XG4gICAgcmV0dXJuIGxpc3REZWNvcmF0ZWRQcm9wZXJ0aWVzKHRoaXMpLmV2ZXJ5KChwcm9wZXJ0eUtleSkgPT4ge1xuICAgICAgY29uc3QgeyBvcHRpb25hbCB9ID0gZXh0cmFjdERlY29yYXRlZFByb3BlcnR5TWV0YWRhdGEodGhpcywgcHJvcGVydHlLZXkpO1xuICAgICAgY29uc3QgdmFsaWQgPSBvcHRpb25hbCA9PT0gdHJ1ZSB8fCB0eXBlb2YgdGhpc1twcm9wZXJ0eUtleV0gIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIExvZ2dlci53YXJuT25jZShgJHt3YXJuaW5nUHJlZml4ID8/IFwiXCJ9WyR7cHJvcGVydHlLZXl9XSBpcyByZXF1aXJlZC5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWxpZDtcbiAgICB9KTtcbiAgfVxuICB0b0pzb24oKSB7XG4gICAgcmV0dXJuIGxpc3REZWNvcmF0ZWRQcm9wZXJ0aWVzKHRoaXMpLnJlZHVjZSgob2JqZWN0MiwgcHJvcGVydHlLZXkpID0+IHtcbiAgICAgIGNvbnN0IHByb3BlcnR5VmFsdWUgPSB0aGlzW3Byb3BlcnR5S2V5XTtcbiAgICAgIG9iamVjdDJbcHJvcGVydHlLZXldID0gaXNQcm9wZXJ0aWVzKHByb3BlcnR5VmFsdWUpID8gcHJvcGVydHlWYWx1ZS50b0pzb24oKSA6IHByb3BlcnR5VmFsdWU7XG4gICAgICByZXR1cm4gb2JqZWN0MjtcbiAgICB9LCB7fSk7XG4gIH1cbn07XG52YXIgUHJvcGVydGllc0FycmF5ID0gY2xhc3MgX1Byb3BlcnRpZXNBcnJheSBleHRlbmRzIEFycmF5IHtcbiAgY29uc3RydWN0b3IoaXRlbUZhY3RvcnksIC4uLnByb3BlcnRpZXMpIHtcbiAgICBzdXBlcihwcm9wZXJ0aWVzLmxlbmd0aCk7XG4gICAgY29uc3QgaXNDb25zdHJ1Y3RvciA9ICh2YWx1ZTIpID0+IEJvb2xlYW4odmFsdWUyPy5wcm90b3R5cGU/LmNvbnN0cnVjdG9yPy5uYW1lKTtcbiAgICBjb25zdCB2YWx1ZSA9IGlzQ29uc3RydWN0b3IoaXRlbUZhY3RvcnkpID8gKHBhcmFtcykgPT4gbmV3IGl0ZW1GYWN0b3J5KCkuc2V0KHBhcmFtcykgOiBpdGVtRmFjdG9yeTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJpdGVtRmFjdG9yeVwiLCB7IHZhbHVlLCBlbnVtZXJhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiBmYWxzZSB9KTtcbiAgICB0aGlzLnNldChwcm9wZXJ0aWVzKTtcbiAgfVxuICBzZXQocHJvcGVydGllcykge1xuICAgIGlmIChpc0FycmF5KHByb3BlcnRpZXMpKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IHByb3BlcnRpZXMubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXNbaV0gPSB0aGlzLml0ZW1GYWN0b3J5KHByb3BlcnRpZXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZXNldChwcm9wZXJ0aWVzKSB7XG4gICAgcmV0dXJuIG5ldyBfUHJvcGVydGllc0FycmF5KHRoaXMuaXRlbUZhY3RvcnksIC4uLnByb3BlcnRpZXMpO1xuICB9XG4gIHRvSnNvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoKHZhbHVlKSA9PiB2YWx1ZT8udG9Kc29uPy4oKSA/PyB2YWx1ZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBpc1Byb3BlcnRpZXModmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQmFzZVByb3BlcnRpZXMgfHwgdmFsdWUgaW5zdGFuY2VvZiBQcm9wZXJ0aWVzQXJyYXk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvanNvbi50c1xudmFyIENMQVNTX0lOU1RBTkNFX1RZUEUgPSBcImNsYXNzLWluc3RhbmNlXCI7XG5mdW5jdGlvbiBqc29uRGlmZihzb3VyY2UsIHRhcmdldCwgc2tpcCkge1xuICBpZiAoaXNBcnJheSh0YXJnZXQpKSB7XG4gICAgaWYgKCFpc0FycmF5KHNvdXJjZSkgfHwgc291cmNlLmxlbmd0aCAhPT0gdGFyZ2V0Lmxlbmd0aCB8fCB0YXJnZXQuc29tZSgodiwgaSkgPT4ganNvbkRpZmYoc291cmNlW2ldLCB2KSAhPSBudWxsKSkge1xuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh0YXJnZXQpKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGNvbnN0IGFsbEtleXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gICAgICAuLi5PYmplY3Qua2V5cyhzb3VyY2UpLFxuICAgICAgLi4uT2JqZWN0LmtleXModGFyZ2V0KVxuICAgIF0pO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGFsbEtleXMpIHtcbiAgICAgIGlmIChzb3VyY2Vba2V5XSA9PT0gdGFyZ2V0W2tleV0gfHwgc2tpcD8uaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygc291cmNlW2tleV0gPT09IHR5cGVvZiB0YXJnZXRba2V5XSkge1xuICAgICAgICBjb25zdCBkaWZmMiA9IGpzb25EaWZmKHNvdXJjZVtrZXldLCB0YXJnZXRba2V5XSk7XG4gICAgICAgIGlmIChkaWZmMiAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gZGlmZjI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdGFyZ2V0W2tleV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyhyZXN1bHQpLmxlbmd0aCA/IHJlc3VsdCA6IG51bGw7XG4gIH0gZWxzZSBpZiAoc291cmNlICE9PSB0YXJnZXQpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGVlcENsb25lKHNvdXJjZSwgb3B0aW9ucykge1xuICBpZiAoaXNBcnJheShzb3VyY2UpKSB7XG4gICAgcmV0dXJuIHNvdXJjZS5tYXAoKGl0ZW0pID0+IGRlZXBDbG9uZShpdGVtLCBvcHRpb25zKSk7XG4gIH1cbiAgaWYgKGlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgIHJldHVybiBtYXBWYWx1ZXMoXG4gICAgICBzb3VyY2UsXG4gICAgICAodmFsdWUsIGtleSkgPT4gb3B0aW9ucz8uc2hhbGxvdz8uaW5jbHVkZXMoa2V5KSA/IHNoYWxsb3dDbG9uZSh2YWx1ZSkgOiBkZWVwQ2xvbmUodmFsdWUsIG9wdGlvbnMpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gc2hhbGxvd0Nsb25lKHNvdXJjZSk7XG59XG5mdW5jdGlvbiBzaGFsbG93Q2xvbmUoc291cmNlKSB7XG4gIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcbiAgICByZXR1cm4gWy4uLnNvdXJjZV07XG4gIH1cbiAgaWYgKGlzUGxhaW5PYmplY3Qoc291cmNlKSkge1xuICAgIHJldHVybiB7IC4uLnNvdXJjZSB9O1xuICB9XG4gIGlmIChpc0RhdGUoc291cmNlKSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShzb3VyY2UpO1xuICB9XG4gIGlmIChpc1JlZ0V4cChzb3VyY2UpKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoc291cmNlLnNvdXJjZSwgc291cmNlLmZsYWdzKTtcbiAgfVxuICByZXR1cm4gc291cmNlO1xufVxuZnVuY3Rpb24ganNvbldhbGsoanNvbiwgdmlzaXQsIG9wdHMsIC4uLmpzb25zKSB7XG4gIGlmIChpc0FycmF5KGpzb24pKSB7XG4gICAgdmlzaXQoanNvbiwgLi4uanNvbnMpO1xuICAgIGpzb24uZm9yRWFjaCgobm9kZSwgaW5kZXgpID0+IHtcbiAgICAgIGpzb25XYWxrKG5vZGUsIHZpc2l0LCBvcHRzLCAuLi5rZXlNYXBwZXIoanNvbnMsIGluZGV4KSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChqc29uKSkge1xuICAgIHZpc2l0KGpzb24sIC4uLmpzb25zKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhqc29uKSkge1xuICAgICAgaWYgKG9wdHM/LnNraXA/LmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IGpzb25ba2V5XTtcbiAgICAgIGlmIChpc0FycmF5KHZhbHVlKSB8fCBpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBqc29uV2Fsayh2YWx1ZSwgdmlzaXQsIG9wdHMsIC4uLmtleU1hcHBlcihqc29ucywga2V5KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBqc29uQXBwbHkodGFyZ2V0LCBzb3VyY2UsIHBhcmFtcyA9IHt9KSB7XG4gIGNvbnN0IHsgcGF0aCwgbWF0Y2hlclBhdGggPSBwYXRoPy5yZXBsYWNlKC8oXFxbWzAtOStdK10pL2ksIFwiW11cIiksIHNraXAgPSBbXSB9ID0gcGFyYW1zO1xuICBpZiAodGFyZ2V0ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIHRhcmdldCBpcyB1bmluaXRpYWxpc2VkOiAke3BhdGggPz8gXCI8cm9vdD5cIn1gKTtcbiAgfVxuICBpZiAoc291cmNlID09IG51bGwpIHtcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIGlmIChpc1Byb3BlcnRpZXModGFyZ2V0KSkge1xuICAgIHJldHVybiB0YXJnZXQuc2V0KHNvdXJjZSk7XG4gIH1cbiAgY29uc3QgdGFyZ2V0QW55ID0gdGFyZ2V0O1xuICBjb25zdCB0YXJnZXRUeXBlID0gY2xhc3NpZnkodGFyZ2V0KTtcbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoU0tJUF9KU19CVUlMVElOUy5oYXMocHJvcGVydHkpKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgcHJvcGVydHlNYXRjaGVyUGF0aCA9IGAke21hdGNoZXJQYXRoID8gbWF0Y2hlclBhdGggKyBcIi5cIiA6IFwiXCJ9JHtwcm9wZXJ0eX1gO1xuICAgIGlmIChza2lwLmluY2x1ZGVzKHByb3BlcnR5TWF0Y2hlclBhdGgpKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgbmV3VmFsdWUgPSBzb3VyY2VbcHJvcGVydHldO1xuICAgIGNvbnN0IHByb3BlcnR5UGF0aCA9IGAke3BhdGggPyBwYXRoICsgXCIuXCIgOiBcIlwifSR7cHJvcGVydHl9YDtcbiAgICBjb25zdCB0YXJnZXRDbGFzcyA9IHRhcmdldEFueS5jb25zdHJ1Y3RvcjtcbiAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0YXJnZXRBbnlbcHJvcGVydHldO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjdXJyZW50VmFsdWVUeXBlID0gY2xhc3NpZnkoY3VycmVudFZhbHVlKTtcbiAgICAgIGNvbnN0IG5ld1ZhbHVlVHlwZSA9IGNsYXNzaWZ5KG5ld1ZhbHVlKTtcbiAgICAgIGlmICh0YXJnZXRUeXBlID09PSBDTEFTU19JTlNUQU5DRV9UWVBFICYmICEocHJvcGVydHkgaW4gdGFyZ2V0KSkge1xuICAgICAgICBMb2dnZXIud2FybihgdW5hYmxlIHRvIHNldCBbJHtwcm9wZXJ0eVBhdGh9XSBpbiAke3RhcmdldENsYXNzPy5uYW1lfSAtIHByb3BlcnR5IGlzIHVua25vd25gKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudFZhbHVlVHlwZSAhPSBudWxsICYmIG5ld1ZhbHVlVHlwZSAhPSBudWxsICYmIG5ld1ZhbHVlVHlwZSAhPT0gY3VycmVudFZhbHVlVHlwZSAmJiAoY3VycmVudFZhbHVlVHlwZSAhPT0gQ0xBU1NfSU5TVEFOQ0VfVFlQRSB8fCBuZXdWYWx1ZVR5cGUgIT09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgIExvZ2dlci53YXJuKFxuICAgICAgICAgIGB1bmFibGUgdG8gc2V0IFske3Byb3BlcnR5UGF0aH1dIGluICR7dGFyZ2V0Q2xhc3M/Lm5hbWV9IC0gY2FuJ3QgYXBwbHkgdHlwZSBvZiBbJHtuZXdWYWx1ZVR5cGV9XSwgYWxsb3dlZCB0eXBlcyBhcmU6IFske2N1cnJlbnRWYWx1ZVR5cGV9XWBcbiAgICAgICAgKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNQcm9wZXJ0aWVzKGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgdGFyZ2V0QW55W3Byb3BlcnR5XS5zZXQobmV3VmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChuZXdWYWx1ZVR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgdGFyZ2V0QW55W3Byb3BlcnR5XSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGpzb25BcHBseShjdXJyZW50VmFsdWUgPz8gdGFyZ2V0QW55W3Byb3BlcnR5XSwgbmV3VmFsdWUsIHtcbiAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgcGF0aDogcHJvcGVydHlQYXRoLFxuICAgICAgICAgIG1hdGNoZXJQYXRoOiBwcm9wZXJ0eU1hdGNoZXJQYXRoXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0QW55W3Byb3BlcnR5XSA9IG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBMb2dnZXIud2FybihgdW5hYmxlIHRvIHNldCBbJHtwcm9wZXJ0eVBhdGh9XSBpbiBbJHt0YXJnZXRDbGFzcz8ubmFtZX1dOyBuZXN0ZWQgZXJyb3IgaXM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIGtleU1hcHBlcihkYXRhLCBrZXkpIHtcbiAgcmV0dXJuIGRhdGEubWFwKChkYXRhT2JqZWN0KSA9PiBkYXRhT2JqZWN0Py5ba2V5XSk7XG59XG5mdW5jdGlvbiBjbGFzc2lmeSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChpc0h0bWxFbGVtZW50KHZhbHVlKSB8fCBpc0RhdGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIFwicHJpbWl0aXZlXCI7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpID8gXCJvYmplY3RcIiA6IENMQVNTX0lOU1RBTkNFX1RZUEU7XG4gIH1cbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgcmV0dXJuIFwiZnVuY3Rpb25cIjtcbiAgfVxuICByZXR1cm4gXCJwcmltaXRpdmVcIjtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW90aW9uL2Vhc2luZy50c1xudmFyIGVhc2luZ19leHBvcnRzID0ge307XG5fX2V4cG9ydChlYXNpbmdfZXhwb3J0cywge1xuICBlYXNlSW46ICgpID0+IGVhc2VJbixcbiAgZWFzZUluT3V0OiAoKSA9PiBlYXNlSW5PdXQsXG4gIGVhc2VJbk91dFF1YWQ6ICgpID0+IGVhc2VJbk91dFF1YWQsXG4gIGVhc2VJblF1YWQ6ICgpID0+IGVhc2VJblF1YWQsXG4gIGVhc2VPdXQ6ICgpID0+IGVhc2VPdXQsXG4gIGVhc2VPdXRRdWFkOiAoKSA9PiBlYXNlT3V0UXVhZCxcbiAgaW52ZXJzZUVhc2VPdXQ6ICgpID0+IGludmVyc2VFYXNlT3V0LFxuICBsaW5lYXI6ICgpID0+IGxpbmVhclxufSk7XG52YXIgbGluZWFyID0gKG4pID0+IG47XG52YXIgZWFzZUluID0gKG4pID0+IDEgLSBNYXRoLmNvcyhuICogTWF0aC5QSSAvIDIpO1xudmFyIGVhc2VPdXQgPSAobikgPT4gTWF0aC5zaW4obiAqIE1hdGguUEkgLyAyKTtcbnZhciBlYXNlSW5PdXQgPSAobikgPT4gLShNYXRoLmNvcyhuICogTWF0aC5QSSkgLSAxKSAvIDI7XG52YXIgZWFzZUluUXVhZCA9IChuKSA9PiBuICogbjtcbnZhciBlYXNlT3V0UXVhZCA9IChuKSA9PiAxIC0gKDEgLSBuKSAqKiAyO1xudmFyIGVhc2VJbk91dFF1YWQgPSAobikgPT4gbiA8IDAuNSA/IDIgKiBuICogbiA6IDEgLSAoLTIgKiBuICsgMikgKiogMiAvIDI7XG52YXIgaW52ZXJzZUVhc2VPdXQgPSAoeCkgPT4gMiAqIE1hdGguYXNpbih4KSAvIE1hdGguUEk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vdGlvbi9hbmltYXRpb24udHNcbnZhciBRVUlDS19UUkFOU0lUSU9OID0gMC4yO1xudmFyIFBIQVNFX09SREVSID0gW1wiaW5pdGlhbFwiLCBcInJlbW92ZVwiLCBcInVwZGF0ZVwiLCBcImFkZFwiLCBcInRyYWlsaW5nXCIsIFwiZW5kXCIsIFwibm9uZVwiXTtcbnZhciBQSEFTRV9NRVRBREFUQSA9IHtcbiAgaW5pdGlhbDoge1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAxLFxuICAgIGFuaW1hdGlvbkRlbGF5OiAwXG4gIH0sXG4gIGFkZDoge1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAwLjI1LFxuICAgIGFuaW1hdGlvbkRlbGF5OiAwLjc1XG4gIH0sXG4gIHJlbW92ZToge1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAwLjI1LFxuICAgIGFuaW1hdGlvbkRlbGF5OiAwXG4gIH0sXG4gIHVwZGF0ZToge1xuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAwLjUsXG4gICAgYW5pbWF0aW9uRGVsYXk6IDAuMjVcbiAgfSxcbiAgdHJhaWxpbmc6IHtcbiAgICBhbmltYXRpb25EdXJhdGlvbjogUVVJQ0tfVFJBTlNJVElPTixcbiAgICBhbmltYXRpb25EZWxheTogMSxcbiAgICBza2lwSWZOb0VhcmxpZXJBbmltYXRpb25zOiB0cnVlXG4gIH0sXG4gIGVuZDoge1xuICAgIGFuaW1hdGlvbkRlbGF5OiAxICsgUVVJQ0tfVFJBTlNJVElPTixcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMCxcbiAgICBza2lwSWZOb0VhcmxpZXJBbmltYXRpb25zOiB0cnVlXG4gIH0sXG4gIG5vbmU6IHtcbiAgICBhbmltYXRpb25EdXJhdGlvbjogMCxcbiAgICBhbmltYXRpb25EZWxheTogMFxuICB9XG59O1xudmFyIFJlcGVhdFR5cGUgPSAvKiBAX19QVVJFX18gKi8gKChSZXBlYXRUeXBlMikgPT4ge1xuICBSZXBlYXRUeXBlMltcIkxvb3BcIl0gPSBcImxvb3BcIjtcbiAgUmVwZWF0VHlwZTJbXCJSZXZlcnNlXCJdID0gXCJyZXZlcnNlXCI7XG4gIHJldHVybiBSZXBlYXRUeXBlMjtcbn0pKFJlcGVhdFR5cGUgfHwge30pO1xuZnVuY3Rpb24gaXNOb2RlQXJyYXkoYXJyYXkyKSB7XG4gIHJldHVybiBhcnJheTIuZXZlcnkoKG4pID0+IG4gaW5zdGFuY2VvZiBOb2RlKTtcbn1cbmZ1bmN0aW9uIGRlY29uc3RydWN0U2VsZWN0aW9uc09yTm9kZXMoc2VsZWN0aW9uc09yTm9kZXMpIHtcbiAgcmV0dXJuIGlzTm9kZUFycmF5KHNlbGVjdGlvbnNPck5vZGVzKSA/IHsgbm9kZXM6IHNlbGVjdGlvbnNPck5vZGVzLCBzZWxlY3Rpb25zOiBbXSB9IDogeyBub2RlczogW10sIHNlbGVjdGlvbnM6IHNlbGVjdGlvbnNPck5vZGVzIH07XG59XG52YXIgQW5pbWF0aW9uID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgdGhpcy5pc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgdGhpcy5lbGFwc2VkID0gMDtcbiAgICB0aGlzLml0ZXJhdGlvbiA9IDA7XG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmlzUmV2ZXJzZSA9IGZhbHNlO1xuICAgIHRoaXMuaWQgPSBvcHRzLmlkO1xuICAgIHRoaXMuZ3JvdXBJZCA9IG9wdHMuZ3JvdXBJZDtcbiAgICB0aGlzLmF1dG9wbGF5ID0gb3B0cy5hdXRvcGxheSA/PyB0cnVlO1xuICAgIHRoaXMuZWFzZSA9IG9wdHMuZWFzZSA/PyBsaW5lYXI7XG4gICAgdGhpcy5waGFzZSA9IG9wdHMucGhhc2U7XG4gICAgY29uc3QgZHVyYXRpb25Qcm9wb3J0aW9uID0gb3B0cy5kdXJhdGlvbiA/PyBQSEFTRV9NRVRBREFUQVt0aGlzLnBoYXNlXS5hbmltYXRpb25EdXJhdGlvbjtcbiAgICB0aGlzLmR1cmF0aW9uID0gZHVyYXRpb25Qcm9wb3J0aW9uICogb3B0cy5kZWZhdWx0RHVyYXRpb247XG4gICAgdGhpcy5kZWxheSA9IChvcHRzLmRlbGF5ID8/IDApICogb3B0cy5kZWZhdWx0RHVyYXRpb247XG4gICAgdGhpcy5vbkNvbXBsZXRlID0gb3B0cy5vbkNvbXBsZXRlO1xuICAgIHRoaXMub25QbGF5ID0gb3B0cy5vblBsYXk7XG4gICAgdGhpcy5vblN0b3AgPSBvcHRzLm9uU3RvcDtcbiAgICB0aGlzLm9uVXBkYXRlID0gb3B0cy5vblVwZGF0ZTtcbiAgICB0aGlzLmludGVycG9sYXRlID0gdGhpcy5jcmVhdGVJbnRlcnBvbGF0b3Iob3B0cy5mcm9tLCBvcHRzLnRvKTtcbiAgICB0aGlzLmZyb20gPSBvcHRzLmZyb207XG4gICAgaWYgKG9wdHMuc2tpcCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5vblVwZGF0ZT8uKG9wdHMudG8sIGZhbHNlLCB0aGlzKTtcbiAgICAgIHRoaXMub25TdG9wPy4odGhpcyk7XG4gICAgICB0aGlzLm9uQ29tcGxldGU/Lih0aGlzKTtcbiAgICAgIHRoaXMuaXNDb21wbGV0ZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRzLmNvbGxhcHNhYmxlICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5kdXJhdGlvbiA9IHRoaXMuY2hlY2tDb2xsYXBzZShvcHRzLCB0aGlzLmR1cmF0aW9uKTtcbiAgICB9XG4gIH1cbiAgY2hlY2tDb2xsYXBzZShvcHRzLCBjYWxjdWxhdGVkRHVyYXRpb24pIHtcbiAgICBpZiAob3B0cy5mcm9tID09PSBvcHRzLnRvKVxuICAgICAgcmV0dXJuIDA7XG4gICAgY29uc3QgZGlmZjIgPSB0eXBlb2Ygb3B0cy5mcm9tID09PSBcIm9iamVjdFwiID8ganNvbkRpZmYob3B0cy5mcm9tLCBvcHRzLnRvKSA6IG51bGw7XG4gICAgaWYgKGRpZmYyKSB7XG4gICAgICByZXR1cm4gY2FsY3VsYXRlZER1cmF0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBwbGF5KGluaXRpYWxVcGRhdGUgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLmlzUGxheWluZyB8fCB0aGlzLmlzQ29tcGxldGUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5pc1BsYXlpbmcgPSB0cnVlO1xuICAgIHRoaXMub25QbGF5Py4odGhpcyk7XG4gICAgaWYgKCF0aGlzLmF1dG9wbGF5KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuYXV0b3BsYXkgPSBmYWxzZTtcbiAgICBpZiAoIWluaXRpYWxVcGRhdGUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5vblVwZGF0ZT8uKHRoaXMuZnJvbSwgdHJ1ZSwgdGhpcyk7XG4gIH1cbiAgcGF1c2UoKSB7XG4gICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgfVxuICBzdG9wKCkge1xuICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLmlzQ29tcGxldGUpIHtcbiAgICAgIHRoaXMuaXNDb21wbGV0ZSA9IHRydWU7XG4gICAgICB0aGlzLm9uU3RvcD8uKHRoaXMpO1xuICAgIH1cbiAgfVxuICB1cGRhdGUodGltZTIpIHtcbiAgICBpZiAodGhpcy5pc0NvbXBsZXRlKVxuICAgICAgcmV0dXJuIHRpbWUyO1xuICAgIGlmICghdGhpcy5pc1BsYXlpbmcgJiYgdGhpcy5hdXRvcGxheSkge1xuICAgICAgdGhpcy5wbGF5KHRydWUpO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c0VsYXBzZWQgPSB0aGlzLmVsYXBzZWQ7XG4gICAgdGhpcy5lbGFwc2VkICs9IHRpbWUyO1xuICAgIGlmICh0aGlzLmRlbGF5ID4gdGhpcy5lbGFwc2VkKVxuICAgICAgcmV0dXJuIDA7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmludGVycG9sYXRlKHRoaXMuaXNSZXZlcnNlID8gMSAtIHRoaXMuZGVsdGEgOiB0aGlzLmRlbHRhKTtcbiAgICB0aGlzLm9uVXBkYXRlPy4odmFsdWUsIGZhbHNlLCB0aGlzKTtcbiAgICBjb25zdCB0b3RhbER1cmF0aW9uID0gdGhpcy5kZWxheSArIHRoaXMuZHVyYXRpb247XG4gICAgaWYgKHRoaXMuZWxhcHNlZCA+PSB0b3RhbER1cmF0aW9uKSB7XG4gICAgICB0aGlzLnN0b3AoKTtcbiAgICAgIHRoaXMuaXNDb21wbGV0ZSA9IHRydWU7XG4gICAgICB0aGlzLm9uQ29tcGxldGU/Lih0aGlzKTtcbiAgICAgIHJldHVybiB0aW1lMiAtICh0b3RhbER1cmF0aW9uIC0gcHJldmlvdXNFbGFwc2VkKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgZ2V0IGRlbHRhKCkge1xuICAgIHJldHVybiB0aGlzLmVhc2UoY2xhbXAoMCwgKHRoaXMuZWxhcHNlZCAtIHRoaXMuZGVsYXkpIC8gdGhpcy5kdXJhdGlvbiwgMSkpO1xuICB9XG4gIGNyZWF0ZUludGVycG9sYXRvcihmcm9tMiwgdG8pIHtcbiAgICBpZiAodHlwZW9mIHRvICE9PSBcIm9iamVjdFwiIHx8IGlzSW50ZXJwb2xhdGluZyh0bykpIHtcbiAgICAgIHJldHVybiB0aGlzLmludGVycG9sYXRlVmFsdWUoZnJvbTIsIHRvKTtcbiAgICB9XG4gICAgY29uc3QgaW50ZXJwb2xhdG9yRW50cmllcyA9IFtdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHRvKSB7XG4gICAgICBjb25zdCBpbnRlcnBvbGF0b3IgPSB0aGlzLmludGVycG9sYXRlVmFsdWUoZnJvbTJba2V5XSwgdG9ba2V5XSk7XG4gICAgICBpZiAoaW50ZXJwb2xhdG9yICE9IG51bGwpIHtcbiAgICAgICAgaW50ZXJwb2xhdG9yRW50cmllcy5wdXNoKFtrZXksIGludGVycG9sYXRvcl0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKGQpID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBba2V5LCBpbnRlcnBvbGF0b3JdIG9mIGludGVycG9sYXRvckVudHJpZXMpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSBpbnRlcnBvbGF0b3IoZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH1cbiAgaW50ZXJwb2xhdGVWYWx1ZShhLCBiKSB7XG4gICAgaWYgKGEgPT09IHZvaWQgMCB8fCBiID09PSB2b2lkIDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGlzSW50ZXJwb2xhdGluZyhhKSkge1xuICAgICAgcmV0dXJuIChkKSA9PiBhW2ludGVycG9sYXRlXShiLCBkKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAodHlwZW9mIGEpIHtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZU51bWJlcihhLCBiKTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZUNvbG9yKGEsIGIpO1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgIGlmIChhID09PSBiKVxuICAgICAgICAgICAgcmV0dXJuICgpID0+IGE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBpbnRlcnBvbGF0ZSB2YWx1ZXM6ICR7YX0sICR7Yn1gKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW90aW9uL2Zyb21Ub01vdGlvbi50c1xudmFyIE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkcgPSB7XG4gIGFkZGVkOiBcImFkZFwiLFxuICB1cGRhdGVkOiBcInVwZGF0ZVwiLFxuICByZW1vdmVkOiBcInJlbW92ZVwiLFxuICB1bmtub3duOiBcImluaXRpYWxcIixcbiAgXCJuby1vcFwiOiBcIm5vbmVcIlxufTtcbmZ1bmN0aW9uIGZyb21Ub01vdGlvbihncm91cElkLCBzdWJJZCwgYW5pbWF0aW9uTWFuYWdlciwgc2VsZWN0aW9uc09yTm9kZXMsIGZucywgZ2V0RGF0dW1JZCwgZGlmZjIpIHtcbiAgY29uc3QgeyBmcm9tRm4sIHRvRm4sIGludGVybWVkaWF0ZUZuIH0gPSBmbnM7XG4gIGNvbnN0IHsgbm9kZXMsIHNlbGVjdGlvbnMgfSA9IGRlY29uc3RydWN0U2VsZWN0aW9uc09yTm9kZXMoc2VsZWN0aW9uc09yTm9kZXMpO1xuICBjb25zdCBwcm9jZXNzTm9kZXMgPSAobGl2ZU5vZGVzLCBzdWJOb2RlcykgPT4ge1xuICAgIGxldCBwcmV2RnJvbVByb3BzO1xuICAgIGxldCBsaXZlTm9kZUluZGV4ID0gMDtcbiAgICBsZXQgbm9kZUluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygc3ViTm9kZXMpIHtcbiAgICAgIGNvbnN0IGlzTGl2ZSA9IGxpdmVOb2Rlc1tsaXZlTm9kZUluZGV4XSA9PT0gbm9kZTtcbiAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgbGFzdDogbm9kZUluZGV4ID49IHN1Yk5vZGVzLmxlbmd0aCAtIDEsXG4gICAgICAgIGxhc3RMaXZlOiBsaXZlTm9kZUluZGV4ID49IGxpdmVOb2Rlcy5sZW5ndGggLSAxLFxuICAgICAgICBwcmV2OiBzdWJOb2Rlc1tub2RlSW5kZXggLSAxXSxcbiAgICAgICAgcHJldkZyb21Qcm9wcyxcbiAgICAgICAgcHJldkxpdmU6IGxpdmVOb2Rlc1tsaXZlTm9kZUluZGV4IC0gMV0sXG4gICAgICAgIG5leHQ6IHN1Yk5vZGVzW25vZGVJbmRleCArIDFdLFxuICAgICAgICBuZXh0TGl2ZTogbGl2ZU5vZGVzW2xpdmVOb2RlSW5kZXggKyAoaXNMaXZlID8gMSA6IDApXVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGFuaW1hdGlvbklkID0gYCR7Z3JvdXBJZH1fJHtzdWJJZH1fJHtub2RlLmlkfWA7XG4gICAgICBhbmltYXRpb25NYW5hZ2VyLnN0b3BCeUFuaW1hdGlvbklkKGFuaW1hdGlvbklkKTtcbiAgICAgIGxldCBzdGF0dXMgPSBcInVua25vd25cIjtcbiAgICAgIGlmICghaXNMaXZlKSB7XG4gICAgICAgIHN0YXR1cyA9IFwicmVtb3ZlZFwiO1xuICAgICAgfSBlbHNlIGlmIChnZXREYXR1bUlkICYmIGRpZmYyKSB7XG4gICAgICAgIHN0YXR1cyA9IGNhbGN1bGF0ZVN0YXR1cyhub2RlLCBub2RlLmRhdHVtLCBnZXREYXR1bUlkLCBkaWZmMik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHBoYXNlLCBzdGFydCwgZmluaXNoLCBkZWxheSwgZHVyYXRpb24sIC4uLmZyb20yIH0gPSBmcm9tRm4obm9kZSwgbm9kZS5kYXR1bSwgc3RhdHVzLCBjdHgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwaGFzZTogdG9QaGFzZSxcbiAgICAgICAgc3RhcnQ6IHRvU3RhcnQsXG4gICAgICAgIGZpbmlzaDogdG9GaW5pc2gsXG4gICAgICAgIGRlbGF5OiB0b0RlbGF5LFxuICAgICAgICBkdXJhdGlvbjogdG9EdXJhdGlvbixcbiAgICAgICAgLi4udG9cbiAgICAgIH0gPSB0b0ZuKG5vZGUsIG5vZGUuZGF0dW0sIHN0YXR1cywgY3R4KTtcbiAgICAgIGNvbnN0IGNvbGxhcHNhYmxlID0gZmluaXNoID09IG51bGwgJiYgdG9GaW5pc2ggPT0gbnVsbDtcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIuYW5pbWF0ZSh7XG4gICAgICAgIGlkOiBhbmltYXRpb25JZCxcbiAgICAgICAgZ3JvdXBJZCxcbiAgICAgICAgcGhhc2U6IHBoYXNlID8/IHRvUGhhc2UgPz8gXCJ1cGRhdGVcIixcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uID8/IHRvRHVyYXRpb24sXG4gICAgICAgIGRlbGF5OiBkZWxheSA/PyB0b0RlbGF5LFxuICAgICAgICBmcm9tOiBmcm9tMixcbiAgICAgICAgdG8sXG4gICAgICAgIGVhc2U6IGVhc2VPdXQsXG4gICAgICAgIGNvbGxhcHNhYmxlLFxuICAgICAgICBvblBsYXk6ICgpID0+IHtcbiAgICAgICAgICBub2RlLnNldFByb3BlcnRpZXMoeyAuLi5zdGFydCwgLi4udG9TdGFydCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25VcGRhdGUocHJvcHMpIHtcbiAgICAgICAgICBub2RlLnNldFByb3BlcnRpZXMocHJvcHMpO1xuICAgICAgICAgIGlmIChpbnRlcm1lZGlhdGVGbikge1xuICAgICAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKGludGVybWVkaWF0ZUZuKG5vZGUsIG5vZGUuZGF0dW0sIHN0YXR1cywgY3R4KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblN0b3A6ICgpID0+IHtcbiAgICAgICAgICBub2RlLnNldFByb3BlcnRpZXMoe1xuICAgICAgICAgICAgLi4uc3RhcnQsXG4gICAgICAgICAgICAuLi50b1N0YXJ0LFxuICAgICAgICAgICAgLi4uZnJvbTIsXG4gICAgICAgICAgICAuLi50byxcbiAgICAgICAgICAgIC4uLmZpbmlzaCxcbiAgICAgICAgICAgIC4uLnRvRmluaXNoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGlzTGl2ZSkge1xuICAgICAgICBsaXZlTm9kZUluZGV4Kys7XG4gICAgICB9XG4gICAgICBub2RlSW5kZXgrKztcbiAgICAgIHByZXZGcm9tUHJvcHMgPSBmcm9tMjtcbiAgICB9XG4gIH07XG4gIGxldCBzZWxlY3Rpb25JbmRleCA9IDA7XG4gIGZvciAoY29uc3Qgc2VsZWN0aW9uIG9mIHNlbGVjdGlvbnMpIHtcbiAgICBjb25zdCBzZWxlY3Rpb25Ob2RlcyA9IHNlbGVjdGlvbi5ub2RlcygpO1xuICAgIGNvbnN0IGxpdmVOb2RlcyA9IHNlbGVjdGlvbk5vZGVzLmZpbHRlcigobikgPT4gIXNlbGVjdGlvbi5pc0dhcmJhZ2UobikpO1xuICAgIHByb2Nlc3NOb2RlcyhsaXZlTm9kZXMsIHNlbGVjdGlvbk5vZGVzKTtcbiAgICBhbmltYXRpb25NYW5hZ2VyLmFuaW1hdGUoe1xuICAgICAgaWQ6IGAke2dyb3VwSWR9XyR7c3ViSWR9X3NlbGVjdGlvbl8ke3NlbGVjdGlvbkluZGV4fWAsXG4gICAgICBncm91cElkLFxuICAgICAgcGhhc2U6IFwiZW5kXCIsXG4gICAgICBmcm9tOiAwLFxuICAgICAgdG86IDEsXG4gICAgICBlYXNlOiBlYXNlT3V0LFxuICAgICAgb25TdG9wKCkge1xuICAgICAgICBzZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNlbGVjdGlvbkluZGV4Kys7XG4gIH1cbiAgcHJvY2Vzc05vZGVzKG5vZGVzLCBub2Rlcyk7XG59XG5mdW5jdGlvbiBzdGF0aWNGcm9tVG9Nb3Rpb24oZ3JvdXBJZCwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIHNlbGVjdGlvbnNPck5vZGVzLCBmcm9tMiwgdG8sIGV4dHJhT3B0cykge1xuICBjb25zdCB7IG5vZGVzLCBzZWxlY3Rpb25zIH0gPSBkZWNvbnN0cnVjdFNlbGVjdGlvbnNPck5vZGVzKHNlbGVjdGlvbnNPck5vZGVzKTtcbiAgY29uc3QgeyBzdGFydCwgZmluaXNoLCBwaGFzZSB9ID0gZXh0cmFPcHRzO1xuICBjb25zdCBjb2xsYXBzYWJsZSA9IGZpbmlzaCA9PSBudWxsO1xuICBhbmltYXRpb25NYW5hZ2VyLmFuaW1hdGUoe1xuICAgIGlkOiBgJHtncm91cElkfV8ke3N1YklkfWAsXG4gICAgZ3JvdXBJZCxcbiAgICBwaGFzZTogcGhhc2UgPz8gXCJ1cGRhdGVcIixcbiAgICBmcm9tOiBmcm9tMixcbiAgICB0byxcbiAgICBlYXNlOiBlYXNlT3V0LFxuICAgIGNvbGxhcHNhYmxlLFxuICAgIG9uUGxheTogKCkgPT4ge1xuICAgICAgaWYgKCFzdGFydClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhzdGFydCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZWxlY3Rpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBzZWxlY3Rpb24ubm9kZXMoKSkge1xuICAgICAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhzdGFydCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG9uVXBkYXRlKHByb3BzKSB7XG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKHByb3BzKTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgc2VsZWN0aW9uIG9mIHNlbGVjdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHNlbGVjdGlvbi5ub2RlcygpKSB7XG4gICAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgb25TdG9wOiAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKHsgLi4udG8sIC4uLmZpbmlzaCB9KTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgc2VsZWN0aW9uIG9mIHNlbGVjdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHNlbGVjdGlvbi5ub2RlcygpKSB7XG4gICAgICAgICAgbm9kZS5zZXRQcm9wZXJ0aWVzKHsgLi4udG8sIC4uLmZpbmlzaCB9KTtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVTdGF0dXMobm9kZSwgZGF0dW0sIGdldERhdHVtSWQsIGRpZmYyKSB7XG4gIGNvbnN0IGlkID0gZ2V0RGF0dW1JZChub2RlLCBkYXR1bSk7XG4gIGlmIChkaWZmMi5hZGRlZC5oYXMoaWQpKSB7XG4gICAgcmV0dXJuIFwiYWRkZWRcIjtcbiAgfVxuICBpZiAoZGlmZjIucmVtb3ZlZC5oYXMoaWQpKSB7XG4gICAgcmV0dXJuIFwicmVtb3ZlZFwiO1xuICB9XG4gIHJldHVybiBcInVwZGF0ZWRcIjtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lRm9ybWF0LnRzXG52YXIgQ09OU1RBTlRTID0ge1xuICBwZXJpb2RzOiBbXCJBTVwiLCBcIlBNXCJdLFxuICBkYXlzOiBbXCJTdW5kYXlcIiwgXCJNb25kYXlcIiwgXCJUdWVzZGF5XCIsIFwiV2VkbmVzZGF5XCIsIFwiVGh1cnNkYXlcIiwgXCJGcmlkYXlcIiwgXCJTYXR1cmRheVwiXSxcbiAgc2hvcnREYXlzOiBbXCJTdW5cIiwgXCJNb25cIiwgXCJUdWVcIiwgXCJXZWRcIiwgXCJUaHVcIiwgXCJGcmlcIiwgXCJTYXRcIl0sXG4gIG1vbnRoczogW1xuICAgIFwiSmFudWFyeVwiLFxuICAgIFwiRmVicnVhcnlcIixcbiAgICBcIk1hcmNoXCIsXG4gICAgXCJBcHJpbFwiLFxuICAgIFwiTWF5XCIsXG4gICAgXCJKdW5lXCIsXG4gICAgXCJKdWx5XCIsXG4gICAgXCJBdWd1c3RcIixcbiAgICBcIlNlcHRlbWJlclwiLFxuICAgIFwiT2N0b2JlclwiLFxuICAgIFwiTm92ZW1iZXJcIixcbiAgICBcIkRlY2VtYmVyXCJcbiAgXSxcbiAgc2hvcnRNb250aHM6IFtcIkphblwiLCBcIkZlYlwiLCBcIk1hclwiLCBcIkFwclwiLCBcIk1heVwiLCBcIkp1blwiLCBcIkp1bFwiLCBcIkF1Z1wiLCBcIlNlcFwiLCBcIk9jdFwiLCBcIk5vdlwiLCBcIkRlY1wiXVxufTtcbmZ1bmN0aW9uIGRheU9mWWVhcihkYXRlLCBzdGFydE9mWWVhciA9IG5ldyBEYXRlKGRhdGUuZ2V0RnVsbFllYXIoKSwgMCwgMSkpIHtcbiAgY29uc3Qgc3RhcnRPZmZzZXQgPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgLSBzdGFydE9mWWVhci5nZXRUaW1lem9uZU9mZnNldCgpO1xuICBjb25zdCB0aW1lRGlmZiA9IGRhdGUuZ2V0VGltZSgpIC0gc3RhcnRPZlllYXIuZ2V0VGltZSgpICsgc3RhcnRPZmZzZXQgKiA2ZTQ7XG4gIGNvbnN0IHRpbWVPbmVEYXkgPSAzNmU1ICogMjQ7XG4gIHJldHVybiBNYXRoLmZsb29yKHRpbWVEaWZmIC8gdGltZU9uZURheSk7XG59XG5mdW5jdGlvbiB3ZWVrT2ZZZWFyKGRhdGUsIHN0YXJ0RGF5KSB7XG4gIGNvbnN0IHN0YXJ0T2ZZZWFyID0gbmV3IERhdGUoZGF0ZS5nZXRGdWxsWWVhcigpLCAwLCAxKTtcbiAgY29uc3Qgc3RhcnRPZlllYXJEYXkgPSBzdGFydE9mWWVhci5nZXREYXkoKTtcbiAgY29uc3QgZmlyc3RXZWVrU3RhcnRPZmZzZXQgPSAoc3RhcnREYXkgLSBzdGFydE9mWWVhckRheSArIDcpICUgNztcbiAgY29uc3Qgc3RhcnRPZmZzZXQgPSBuZXcgRGF0ZShkYXRlLmdldEZ1bGxZZWFyKCksIDAsIGZpcnN0V2Vla1N0YXJ0T2Zmc2V0ICsgMSk7XG4gIGlmIChzdGFydE9mZnNldCA8PSBkYXRlKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoZGF5T2ZZZWFyKGRhdGUsIHN0YXJ0T2Zmc2V0KSAvIDcpICsgMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbnZhciBTVU5EQVkgPSAwO1xudmFyIE1PTkRBWSA9IDE7XG52YXIgVEhVUlNEQVkgPSA0O1xuZnVuY3Rpb24gaXNvV2Vla09mWWVhcihkYXRlLCB5ZWFyMiA9IGRhdGUuZ2V0RnVsbFllYXIoKSkge1xuICBjb25zdCBmaXJzdE9mWWVhciA9IG5ldyBEYXRlKHllYXIyLCAwLCAxKTtcbiAgY29uc3QgZmlyc3RPZlllYXJEYXkgPSBmaXJzdE9mWWVhci5nZXREYXkoKTtcbiAgY29uc3QgZmlyc3RUaHVyc2RheU9mZnNldCA9IChUSFVSU0RBWSAtIGZpcnN0T2ZZZWFyRGF5ICsgNykgJSA3O1xuICBjb25zdCBzdGFydE9mZnNldCA9IG5ldyBEYXRlKHllYXIyLCAwLCBmaXJzdFRodXJzZGF5T2Zmc2V0IC0gKFRIVVJTREFZIC0gTU9OREFZKSArIDEpO1xuICBpZiAoc3RhcnRPZmZzZXQgPD0gZGF0ZSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKGRheU9mWWVhcihkYXRlLCBzdGFydE9mZnNldCkgLyA3KSArIDE7XG4gIH1cbiAgcmV0dXJuIGlzb1dlZWtPZlllYXIoZGF0ZSwgeWVhcjIgLSAxKTtcbn1cbmZ1bmN0aW9uIHRpbWV6b25lKGRhdGUpIHtcbiAgY29uc3Qgb2Zmc2V0NCA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcbiAgY29uc3QgdW5zaWduZWRPZmZzZXQgPSBNYXRoLmFicyhvZmZzZXQ0KTtcbiAgY29uc3Qgc2lnbiA9IG9mZnNldDQgPiAwID8gXCItXCIgOiBcIitcIjtcbiAgcmV0dXJuIGAke3NpZ259JHtwYWQoTWF0aC5mbG9vcih1bnNpZ25lZE9mZnNldCAvIDYwKSwgMiwgXCIwXCIpfSR7cGFkKE1hdGguZmxvb3IodW5zaWduZWRPZmZzZXQgJSA2MCksIDIsIFwiMFwiKX1gO1xufVxudmFyIEZPUk1BVFRFUlMgPSB7XG4gIGE6IChkKSA9PiBDT05TVEFOVFMuc2hvcnREYXlzW2QuZ2V0RGF5KCldLFxuICBBOiAoZCkgPT4gQ09OU1RBTlRTLmRheXNbZC5nZXREYXkoKV0sXG4gIGI6IChkKSA9PiBDT05TVEFOVFMuc2hvcnRNb250aHNbZC5nZXRNb250aCgpXSxcbiAgQjogKGQpID0+IENPTlNUQU5UUy5tb250aHNbZC5nZXRNb250aCgpXSxcbiAgYzogXCIleCwgJVhcIixcbiAgZDogKGQsIHApID0+IHBhZChkLmdldERhdGUoKSwgMiwgcCA/PyBcIjBcIiksXG4gIGU6IFwiJV9kXCIsXG4gIGY6IChkLCBwKSA9PiBwYWQoZC5nZXRNaWxsaXNlY29uZHMoKSAqIDFlMywgNiwgcCA/PyBcIjBcIiksXG4gIEg6IChkLCBwKSA9PiBwYWQoZC5nZXRIb3VycygpLCAyLCBwID8/IFwiMFwiKSxcbiAgSTogKGQsIHApID0+IHtcbiAgICBjb25zdCBob3VycyA9IGQuZ2V0SG91cnMoKSAlIDEyO1xuICAgIHJldHVybiBob3VycyA9PT0gMCA/IFwiMTJcIiA6IHBhZChob3VycywgMiwgcCA/PyBcIjBcIik7XG4gIH0sXG4gIGo6IChkLCBwKSA9PiBwYWQoZGF5T2ZZZWFyKGQpICsgMSwgMywgcCA/PyBcIjBcIiksXG4gIG06IChkLCBwKSA9PiBwYWQoZC5nZXRNb250aCgpICsgMSwgMiwgcCA/PyBcIjBcIiksXG4gIE06IChkLCBwKSA9PiBwYWQoZC5nZXRNaW51dGVzKCksIDIsIHAgPz8gXCIwXCIpLFxuICBMOiAoZCwgcCkgPT4gcGFkKGQuZ2V0TWlsbGlzZWNvbmRzKCksIDMsIHAgPz8gXCIwXCIpLFxuICBwOiAoZCkgPT4gZC5nZXRIb3VycygpIDwgMTIgPyBcIkFNXCIgOiBcIlBNXCIsXG4gIFE6IChkKSA9PiBTdHJpbmcoZC5nZXRUaW1lKCkpLFxuICBzOiAoZCkgPT4gU3RyaW5nKE1hdGguZmxvb3IoZC5nZXRUaW1lKCkgLyAxZTMpKSxcbiAgUzogKGQsIHApID0+IHBhZChkLmdldFNlY29uZHMoKSwgMiwgcCA/PyBcIjBcIiksXG4gIHU6IChkKSA9PiB7XG4gICAgbGV0IGRheTIgPSBkLmdldERheSgpO1xuICAgIGlmIChkYXkyIDwgMSlcbiAgICAgIGRheTIgKz0gNztcbiAgICByZXR1cm4gU3RyaW5nKGRheTIgJSA3KTtcbiAgfSxcbiAgVTogKGQsIHApID0+IHBhZCh3ZWVrT2ZZZWFyKGQsIFNVTkRBWSksIDIsIHAgPz8gXCIwXCIpLFxuICBWOiAoZCwgcCkgPT4gcGFkKGlzb1dlZWtPZlllYXIoZCksIDIsIHAgPz8gXCIwXCIpLFxuICB3OiAoZCwgcCkgPT4gcGFkKGQuZ2V0RGF5KCksIDIsIHAgPz8gXCIwXCIpLFxuICBXOiAoZCwgcCkgPT4gcGFkKHdlZWtPZlllYXIoZCwgTU9OREFZKSwgMiwgcCA/PyBcIjBcIiksXG4gIHg6IFwiJS1tLyUtZC8lWVwiLFxuICBYOiBcIiUtSTolTTolUyAlcFwiLFxuICB5OiAoZCwgcCkgPT4gcGFkKGQuZ2V0RnVsbFllYXIoKSAlIDEwMCwgMiwgcCA/PyBcIjBcIiksXG4gIFk6IChkLCBwKSA9PiBwYWQoZC5nZXRGdWxsWWVhcigpLCA0LCBwID8/IFwiMFwiKSxcbiAgWjogKGQpID0+IHRpbWV6b25lKGQpLFxuICBcIiVcIjogKCkgPT4gXCIlXCJcbn07XG52YXIgUEFEUyA9IHtcbiAgXzogXCIgXCIsXG4gIFwiMFwiOiBcIjBcIixcbiAgXCItXCI6IFwiXCJcbn07XG5mdW5jdGlvbiBwYWQodmFsdWUsIHNpemUsIHBhZENoYXIpIHtcbiAgY29uc3Qgb3V0cHV0ID0gU3RyaW5nKE1hdGguZmxvb3IodmFsdWUpKTtcbiAgaWYgKG91dHB1dC5sZW5ndGggPj0gc2l6ZSkge1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cbiAgcmV0dXJuIGAke3BhZENoYXIucmVwZWF0KHNpemUgLSBvdXRwdXQubGVuZ3RoKX0ke291dHB1dH1gO1xufVxuZnVuY3Rpb24gYnVpbGRGb3JtYXR0ZXIoZm9ybWF0U3RyaW5nKSB7XG4gIGNvbnN0IGZvcm1hdFBhcnRzID0gW107XG4gIHdoaWxlIChmb3JtYXRTdHJpbmcubGVuZ3RoID4gMCkge1xuICAgIGxldCBuZXh0RXNjYXBlSWR4ID0gZm9ybWF0U3RyaW5nLmluZGV4T2YoXCIlXCIpO1xuICAgIGlmIChuZXh0RXNjYXBlSWR4ICE9PSAwKSB7XG4gICAgICBjb25zdCBsaXRlcmFsUGFydCA9IG5leHRFc2NhcGVJZHggPiAwID8gZm9ybWF0U3RyaW5nLnN1YnN0cmluZygwLCBuZXh0RXNjYXBlSWR4KSA6IGZvcm1hdFN0cmluZztcbiAgICAgIGZvcm1hdFBhcnRzLnB1c2gobGl0ZXJhbFBhcnQpO1xuICAgIH1cbiAgICBpZiAobmV4dEVzY2FwZUlkeCA8IDApXG4gICAgICBicmVhaztcbiAgICBjb25zdCBtYXliZVBhZFNwZWNpZmllciA9IGZvcm1hdFN0cmluZ1tuZXh0RXNjYXBlSWR4ICsgMV07XG4gICAgY29uc3QgbWF5YmVQYWQgPSBQQURTW21heWJlUGFkU3BlY2lmaWVyXTtcbiAgICBpZiAobWF5YmVQYWQgIT0gbnVsbCkge1xuICAgICAgbmV4dEVzY2FwZUlkeCsrO1xuICAgIH1cbiAgICBjb25zdCBtYXliZUZvcm1hdHRlclNwZWNpZmllciA9IGZvcm1hdFN0cmluZ1tuZXh0RXNjYXBlSWR4ICsgMV07XG4gICAgY29uc3QgbWF5YmVGb3JtYXR0ZXIgPSBGT1JNQVRURVJTW21heWJlRm9ybWF0dGVyU3BlY2lmaWVyXTtcbiAgICBpZiAodHlwZW9mIG1heWJlRm9ybWF0dGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZvcm1hdFBhcnRzLnB1c2goW21heWJlRm9ybWF0dGVyLCBtYXliZVBhZF0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1heWJlRm9ybWF0dGVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBmb3JtYXR0ZXIgPSBidWlsZEZvcm1hdHRlcihtYXliZUZvcm1hdHRlcik7XG4gICAgICBmb3JtYXRQYXJ0cy5wdXNoKFtmb3JtYXR0ZXIsIG1heWJlUGFkXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcm1hdFBhcnRzLnB1c2goYCR7bWF5YmVQYWQgPz8gXCJcIn0ke21heWJlRm9ybWF0dGVyU3BlY2lmaWVyfWApO1xuICAgIH1cbiAgICBmb3JtYXRTdHJpbmcgPSBmb3JtYXRTdHJpbmcuc3Vic3RyaW5nKG5leHRFc2NhcGVJZHggKyAyKTtcbiAgfVxuICByZXR1cm4gKGRhdGVUaW1lKSA9PiB7XG4gICAgY29uc3QgZGF0ZVRpbWVBc0RhdGUgPSB0eXBlb2YgZGF0ZVRpbWUgPT09IFwibnVtYmVyXCIgPyBuZXcgRGF0ZShkYXRlVGltZSkgOiBkYXRlVGltZTtcbiAgICByZXR1cm4gZm9ybWF0UGFydHMubWFwKChjKSA9PiB0eXBlb2YgYyA9PT0gXCJzdHJpbmdcIiA/IGMgOiBjWzBdKGRhdGVUaW1lQXNEYXRlLCBjWzFdKSkuam9pbihcIlwiKTtcbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC90aW1lRm9ybWF0RGVmYXVsdHMudHNcbmZ1bmN0aW9uIGRhdGVUb051bWJlcih4KSB7XG4gIHJldHVybiB4IGluc3RhbmNlb2YgRGF0ZSA/IHguZ2V0VGltZSgpIDogeDtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRUaW1lVGlja0Zvcm1hdCh0aWNrcywgZG9tYWluLCBmb3JtYXRPZmZzZXQpIHtcbiAgY29uc3QgZm9ybWF0U3RyaW5nID0gY2FsY3VsYXRlRGVmYXVsdFRpbWVUaWNrRm9ybWF0KHRpY2tzLCBkb21haW4sIGZvcm1hdE9mZnNldCk7XG4gIGNvbnN0IGZvcm1hdHRlciA9IGJ1aWxkRm9ybWF0dGVyKGZvcm1hdFN0cmluZyk7XG4gIHJldHVybiAoZGF0ZSkgPT4gZm9ybWF0dGVyKGRhdGUpO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlRGVmYXVsdFRpbWVUaWNrRm9ybWF0KHRpY2tzID0gW10sIGRvbWFpbiA9IHRpY2tzLCBmb3JtYXRPZmZzZXQgPSAwKSB7XG4gIGxldCBtaW5JbnRlcnZhbCA9IEluZmluaXR5O1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgbWluSW50ZXJ2YWwgPSBNYXRoLm1pbihtaW5JbnRlcnZhbCwgTWF0aC5hYnModGlja3NbaV0gLSB0aWNrc1tpIC0gMV0pKTtcbiAgfVxuICBjb25zdCBzdGFydFllYXIgPSBuZXcgRGF0ZShkb21haW5bMF0pLmdldEZ1bGxZZWFyKCk7XG4gIGNvbnN0IHN0b3BZZWFyID0gbmV3IERhdGUoZG9tYWluLmF0KC0xKSkuZ2V0RnVsbFllYXIoKTtcbiAgY29uc3QgeWVhckNoYW5nZSA9IHN0b3BZZWFyIC0gc3RhcnRZZWFyID4gMDtcbiAgY29uc3QgdGltZUZvcm1hdCA9IGlzRmluaXRlKG1pbkludGVydmFsKSA/IGdldEludGVydmFsTG93ZXN0R3JhbnVsYXJpdHlGb3JtYXQobWluSW50ZXJ2YWwsIHRpY2tzKSA6IGdldExvd2VzdEdyYW51bGFyaXR5Rm9ybWF0KHRpY2tzWzBdKTtcbiAgcmV0dXJuIGZvcm1hdFN0cmluZ0J1aWxkZXIoTWF0aC5tYXgodGltZUZvcm1hdCAtIGZvcm1hdE9mZnNldCwgMCksIHllYXJDaGFuZ2UsIHRpY2tzKTtcbn1cbmZ1bmN0aW9uIGdldEludGVydmFsTG93ZXN0R3JhbnVsYXJpdHlGb3JtYXQodmFsdWUsIHRpY2tzKSB7XG4gIGlmICh2YWx1ZSA8IGR1cmF0aW9uU2Vjb25kKSB7XG4gICAgcmV0dXJuIDAgLyogTUlMTElTRUNPTkQgKi87XG4gIH0gZWxzZSBpZiAodmFsdWUgPCBkdXJhdGlvbk1pbnV0ZSkge1xuICAgIHJldHVybiAxIC8qIFNFQ09ORCAqLztcbiAgfSBlbHNlIGlmICh2YWx1ZSA8IGR1cmF0aW9uSG91cikge1xuICAgIHJldHVybiAyIC8qIE1JTlVURSAqLztcbiAgfSBlbHNlIGlmICh2YWx1ZSA8IGR1cmF0aW9uRGF5KSB7XG4gICAgcmV0dXJuIDMgLyogSE9VUiAqLztcbiAgfSBlbHNlIGlmICh2YWx1ZSA8IGR1cmF0aW9uV2Vlaykge1xuICAgIHJldHVybiA0IC8qIFdFRUtfREFZICovO1xuICB9IGVsc2UgaWYgKHZhbHVlIDwgZHVyYXRpb25EYXkgKiAyOCB8fCB2YWx1ZSA8IGR1cmF0aW9uRGF5ICogMzEgJiYgaGFzRHVwbGljYXRlTW9udGgodGlja3MpKSB7XG4gICAgcmV0dXJuIDUgLyogU0hPUlRfTU9OVEggKi87XG4gIH0gZWxzZSBpZiAodmFsdWUgPCBkdXJhdGlvblllYXIpIHtcbiAgICByZXR1cm4gNiAvKiBNT05USCAqLztcbiAgfVxuICByZXR1cm4gNyAvKiBZRUFSICovO1xufVxuZnVuY3Rpb24gZ2V0TG93ZXN0R3JhbnVsYXJpdHlGb3JtYXQodmFsdWUpIHtcbiAgaWYgKHNlY29uZF9kZWZhdWx0LmZsb29yKHZhbHVlKSA8IHZhbHVlKSB7XG4gICAgcmV0dXJuIDAgLyogTUlMTElTRUNPTkQgKi87XG4gIH0gZWxzZSBpZiAobWludXRlX2RlZmF1bHQuZmxvb3IodmFsdWUpIDwgdmFsdWUpIHtcbiAgICByZXR1cm4gMSAvKiBTRUNPTkQgKi87XG4gIH0gZWxzZSBpZiAoaG91cl9kZWZhdWx0LmZsb29yKHZhbHVlKSA8IHZhbHVlKSB7XG4gICAgcmV0dXJuIDIgLyogTUlOVVRFICovO1xuICB9IGVsc2UgaWYgKGRheV9kZWZhdWx0LmZsb29yKHZhbHVlKSA8IHZhbHVlKSB7XG4gICAgcmV0dXJuIDMgLyogSE9VUiAqLztcbiAgfSBlbHNlIGlmIChtb250aF9kZWZhdWx0LmZsb29yKHZhbHVlKSA8IHZhbHVlKSB7XG4gICAgaWYgKHdlZWtfZGVmYXVsdC5mbG9vcih2YWx1ZSkgPCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIDQgLyogV0VFS19EQVkgKi87XG4gICAgfVxuICAgIHJldHVybiA1IC8qIFNIT1JUX01PTlRIICovO1xuICB9IGVsc2UgaWYgKHllYXJfZGVmYXVsdC5mbG9vcih2YWx1ZSkgPCB2YWx1ZSkge1xuICAgIHJldHVybiA2IC8qIE1PTlRIICovO1xuICB9XG4gIHJldHVybiA3IC8qIFlFQVIgKi87XG59XG5mdW5jdGlvbiBoYXNEdXBsaWNhdGVNb250aCh0aWNrcykge1xuICBsZXQgcHJldk1vbnRoID0gbmV3IERhdGUodGlja3NbMF0pLmdldE1vbnRoKCk7XG4gIGZvciAobGV0IGkgPSAxOyBpIDwgdGlja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0aWNrTW9udGggPSBuZXcgRGF0ZSh0aWNrc1tpXSkuZ2V0TW9udGgoKTtcbiAgICBpZiAocHJldk1vbnRoID09PSB0aWNrTW9udGgpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBwcmV2TW9udGggPSB0aWNrTW9udGg7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZm9ybWF0U3RyaW5nQnVpbGRlcihkZWZhdWx0VGltZUZvcm1hdCwgeWVhckNoYW5nZSwgdGlja3MpIHtcbiAgY29uc3QgZmlyc3RUaWNrID0gZGF0ZVRvTnVtYmVyKHRpY2tzWzBdKTtcbiAgY29uc3QgbGFzdFRpY2sgPSBkYXRlVG9OdW1iZXIodGlja3MuYXQoLTEpKTtcbiAgY29uc3QgZXh0ZW50MiA9IE1hdGguYWJzKGxhc3RUaWNrIC0gZmlyc3RUaWNrKTtcbiAgY29uc3QgYWN0aXZlWWVhciA9IHllYXJDaGFuZ2UgfHwgZGVmYXVsdFRpbWVGb3JtYXQgPT09IDcgLyogWUVBUiAqLztcbiAgY29uc3QgYWN0aXZlRGF0ZSA9IGV4dGVudDIgPT09IDA7XG4gIGNvbnN0IHBhcnRzID0gW1xuICAgIFtcImhvdXJcIiwgNiAqIGR1cmF0aW9uSG91ciwgMTQgKiBkdXJhdGlvbkRheSwgMyAvKiBIT1VSICovLCBcIiVJICVwXCJdLFxuICAgIFtcImhvdXJcIiwgZHVyYXRpb25NaW51dGUsIDYgKiBkdXJhdGlvbkhvdXIsIDMgLyogSE9VUiAqLywgXCIlSTolTVwiXSxcbiAgICBbXCJzZWNvbmRcIiwgMWUzLCA2ICogZHVyYXRpb25Ib3VyLCAxIC8qIFNFQ09ORCAqLywgXCI6JVNcIl0sXG4gICAgW1wibXNcIiwgMCwgNiAqIGR1cmF0aW9uSG91ciwgMCAvKiBNSUxMSVNFQ09ORCAqLywgXCIuJUxcIl0sXG4gICAgW1wiYW0vcG1cIiwgZHVyYXRpb25NaW51dGUsIDYgKiBkdXJhdGlvbkhvdXIsIDMgLyogSE9VUiAqLywgXCIlcFwiXSxcbiAgICBcIiBcIixcbiAgICBbXCJkYXlcIiwgZHVyYXRpb25EYXksIGR1cmF0aW9uV2VlaywgNCAvKiBXRUVLX0RBWSAqLywgXCIlYVwiXSxcbiAgICBbXCJtb250aFwiLCBhY3RpdmVEYXRlID8gMCA6IGR1cmF0aW9uV2VlaywgNTIgKiBkdXJhdGlvbldlZWssIDUgLyogU0hPUlRfTU9OVEggKi8sIFwiJWIgJWRcIl0sXG4gICAgW1wibW9udGhcIiwgNSAqIGR1cmF0aW9uV2VlaywgMTAgKiBkdXJhdGlvblllYXIsIDYgLyogTU9OVEggKi8sIFwiJUJcIl0sXG4gICAgXCIgXCIsXG4gICAgW1wieWVhclwiLCBhY3RpdmVZZWFyID8gMCA6IGR1cmF0aW9uWWVhciwgSW5maW5pdHksIDcgLyogWUVBUiAqLywgXCIlWVwiXVxuICBdO1xuICBjb25zdCBmb3JtYXRQYXJ0cyA9IHBhcnRzLmZpbHRlcigodikgPT4ge1xuICAgIGlmICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IFtfLCBtaW4sIG1heCwgZm9ybWF0XSA9IHY7XG4gICAgcmV0dXJuIGZvcm1hdCA+PSBkZWZhdWx0VGltZUZvcm1hdCAmJiBtaW4gPD0gZXh0ZW50MiAmJiBleHRlbnQyIDwgbWF4O1xuICB9KS5yZWR1Y2UoXG4gICAgKHIsIG5leHQpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgbmV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByLnJlc3VsdC5wdXNoKG5leHQpO1xuICAgICAgfSBlbHNlIGlmICghci51c2VkLmhhcyhuZXh0WzBdKSkge1xuICAgICAgICByLnJlc3VsdC5wdXNoKG5leHQpO1xuICAgICAgICByLnVzZWQuYWRkKG5leHRbMF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfSxcbiAgICB7IHJlc3VsdDogW10sIHVzZWQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkgfVxuICApLnJlc3VsdDtcbiAgY29uc3QgZmlyc3RGb3JtYXQgPSBmb3JtYXRQYXJ0cy5maW5kSW5kZXgoKHYpID0+IHR5cGVvZiB2ICE9PSBcInN0cmluZ1wiKTtcbiAgY29uc3QgbGFzdEZvcm1hdCA9IGZvcm1hdFBhcnRzLmxlbmd0aCAtIFsuLi5mb3JtYXRQYXJ0c10ucmV2ZXJzZSgpLmZpbmRJbmRleCgodikgPT4gdHlwZW9mIHYgIT09IFwic3RyaW5nXCIpO1xuICByZXR1cm4gZm9ybWF0UGFydHMuc2xpY2UoZmlyc3RGb3JtYXQsIGxhc3RGb3JtYXQpLm1hcCgodikgPT4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCIgPyB2IDogdls0XSkuam9pbihcIlwiKS5yZXBsYWNlQWxsKC9cXHMrL2csIFwiIFwiKS50cmltKCk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjYWxlL2ludmFsaWRhdGluZy50c1xudmFyIEludmFsaWRhdGluZyA9ICh0YXJnZXQsIHByb3BlcnR5S2V5KSA9PiB7XG4gIGNvbnN0IG1hcHBlZFByb3BlcnR5ID0gU3ltYm9sKFN0cmluZyhwcm9wZXJ0eUtleSkpO1xuICB0YXJnZXRbbWFwcGVkUHJvcGVydHldID0gdm9pZCAwO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSwge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzW21hcHBlZFByb3BlcnR5XTtcbiAgICB9LFxuICAgIHNldChuZXdWYWx1ZSkge1xuICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzW21hcHBlZFByb3BlcnR5XTtcbiAgICAgIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgdGhpc1ttYXBwZWRQcm9wZXJ0eV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgdGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICB9KTtcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjYWxlL2JhbmRTY2FsZS50c1xudmFyIF9CYW5kU2NhbGUgPSBjbGFzcyBfQmFuZFNjYWxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy50eXBlID0gXCJiYW5kXCI7XG4gICAgdGhpcy5pbnZhbGlkID0gdHJ1ZTtcbiAgICB0aGlzLnJhbmdlID0gWzAsIDFdO1xuICAgIHRoaXMucm91bmQgPSBmYWxzZTtcbiAgICB0aGlzLmludGVydmFsID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIE1hcHMgZGF0dW0gdG8gaXRzIGluZGV4IGluIHRoZSB7QGxpbmsgZG9tYWlufSBhcnJheS5cbiAgICAgKiBVc2VkIHRvIGNoZWNrIGZvciBkdXBsaWNhdGUgZGF0YSAobm90IGFsbG93ZWQpLlxuICAgICAqL1xuICAgIHRoaXMuaW5kZXggPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIC8qKlxuICAgICAqIFRoZSBvdXRwdXQgcmFuZ2UgdmFsdWVzIGZvciBkYXR1bSBhdCBlYWNoIGluZGV4LlxuICAgICAqL1xuICAgIHRoaXMub3JkaW5hbFJhbmdlID0gW107XG4gICAgLyoqXG4gICAgICogQ29udGFpbnMgdW5pcXVlIGRhdGEgb25seS5cbiAgICAgKi9cbiAgICB0aGlzLl9kb21haW4gPSBbXTtcbiAgICB0aGlzLl9iYW5kd2lkdGggPSAxO1xuICAgIHRoaXMuX3N0ZXAgPSAxO1xuICAgIHRoaXMuX2luc2V0ID0gMTtcbiAgICB0aGlzLl9yYXdCYW5kd2lkdGggPSAxO1xuICAgIC8qKlxuICAgICAqIFRoZSByYXRpbyBvZiB0aGUgcmFuZ2UgdGhhdCBpcyByZXNlcnZlZCBmb3Igc3BhY2UgYmV0d2VlbiBiYW5kcy5cbiAgICAgKi9cbiAgICB0aGlzLl9wYWRkaW5nSW5uZXIgPSAwO1xuICAgIC8qKlxuICAgICAqIFRoZSByYXRpbyBvZiB0aGUgcmFuZ2UgdGhhdCBpcyByZXNlcnZlZCBmb3Igc3BhY2UgYmVmb3JlIHRoZSBmaXJzdFxuICAgICAqIGFuZCBhZnRlciB0aGUgbGFzdCBiYW5kLlxuICAgICAqL1xuICAgIHRoaXMuX3BhZGRpbmdPdXRlciA9IDA7XG4gIH1cbiAgc3RhdGljIGlzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgX0JhbmRTY2FsZTtcbiAgfVxuICByZWZyZXNoKCkge1xuICAgIGlmICghdGhpcy5pbnZhbGlkKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuaW52YWxpZCA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlKCk7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKFwiRXhwZWN0ZWQgdXBkYXRlIHRvIG5vdCBpbnZhbGlkYXRlIHNjYWxlXCIpO1xuICAgIH1cbiAgfVxuICBzZXQgZG9tYWluKHZhbHVlcykge1xuICAgIHRoaXMuaW5kZXggPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuaW52YWxpZCA9IHRydWU7XG4gICAgdGhpcy5fZG9tYWluID0gW107XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGNvbnN0IGtleSA9IGRhdGVUb051bWJlcih2YWx1ZSk7XG4gICAgICBpZiAodGhpcy5nZXRJbmRleChrZXkpID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5pbmRleC5zZXQoa2V5LCB0aGlzLl9kb21haW4ucHVzaCh2YWx1ZSkgLSAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0IGRvbWFpbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZG9tYWluO1xuICB9XG4gIGdldERvbWFpbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZG9tYWluO1xuICB9XG4gIHRpY2tzKCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIHJldHVybiB0aGlzLl9kb21haW47XG4gIH1cbiAgY29udmVydChkKSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgY29uc3QgaSA9IHRoaXMuZ2V0SW5kZXgoZCk7XG4gICAgaWYgKGkgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMub3JkaW5hbFJhbmdlW2ldID8/IE5hTjtcbiAgfVxuICBpbnZlcnQocG9zaXRpb24pIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMub3JkaW5hbFJhbmdlLmZpbmRJbmRleCgocCkgPT4gcCA9PT0gcG9zaXRpb24pO1xuICAgIHJldHVybiB0aGlzLmRvbWFpbltpbmRleF07XG4gIH1cbiAgaW52ZXJ0TmVhcmVzdChwb3NpdGlvbikge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIGxldCBuZWFyZXN0ID0gLTE7XG4gICAgbGV0IG1pbkRpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLm9yZGluYWxSYW5nZS5maW5kSW5kZXgoKHAsIGkpID0+IHtcbiAgICAgIGlmIChwID09PSBwb3NpdGlvbilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjb25zdCBkaXN0YW5jZTMgPSBNYXRoLmFicyhwb3NpdGlvbiAtIHApO1xuICAgICAgaWYgKGRpc3RhbmNlMyA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2UzO1xuICAgICAgICBuZWFyZXN0ID0gaTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcy5kb21haW5baW5kZXhdID8/IHRoaXMuZG9tYWluW25lYXJlc3RdO1xuICB9XG4gIGdldCBiYW5kd2lkdGgoKSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgcmV0dXJuIHRoaXMuX2JhbmR3aWR0aDtcbiAgfVxuICBnZXQgc3RlcCgpIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICByZXR1cm4gdGhpcy5fc3RlcDtcbiAgfVxuICBnZXQgaW5zZXQoKSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgcmV0dXJuIHRoaXMuX2luc2V0O1xuICB9XG4gIGdldCByYXdCYW5kd2lkdGgoKSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgcmV0dXJuIHRoaXMuX3Jhd0JhbmR3aWR0aDtcbiAgfVxuICBzZXQgcGFkZGluZyh2YWx1ZSkge1xuICAgIHZhbHVlID0gY2xhbXAoMCwgdmFsdWUsIDEpO1xuICAgIHRoaXMuX3BhZGRpbmdJbm5lciA9IHZhbHVlO1xuICAgIHRoaXMuX3BhZGRpbmdPdXRlciA9IHZhbHVlO1xuICB9XG4gIGdldCBwYWRkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWRkaW5nSW5uZXI7XG4gIH1cbiAgc2V0IHBhZGRpbmdJbm5lcih2YWx1ZSkge1xuICAgIHRoaXMuX3BhZGRpbmdJbm5lciA9IGNsYW1wKDAsIHZhbHVlLCAxKTtcbiAgfVxuICBnZXQgcGFkZGluZ0lubmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWRkaW5nSW5uZXI7XG4gIH1cbiAgc2V0IHBhZGRpbmdPdXRlcih2YWx1ZSkge1xuICAgIHRoaXMuX3BhZGRpbmdPdXRlciA9IGNsYW1wKDAsIHZhbHVlLCAxKTtcbiAgfVxuICBnZXQgcGFkZGluZ091dGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWRkaW5nT3V0ZXI7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fZG9tYWluLmxlbmd0aDtcbiAgICBpZiAoY291bnQgPT09IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgW3IwLCByMV0gPSB0aGlzLnJhbmdlO1xuICAgIGxldCB7IF9wYWRkaW5nSW5uZXI6IHBhZGRpbmdJbm5lciB9ID0gdGhpcztcbiAgICBjb25zdCB7IF9wYWRkaW5nT3V0ZXI6IHBhZGRpbmdPdXRlciwgcm91bmQ6IHJvdW5kMyB9ID0gdGhpcztcbiAgICBjb25zdCByYW5nZURpc3RhbmNlID0gcjEgLSByMDtcbiAgICBsZXQgcmF3U3RlcCwgc3RlcCwgaW5zZXQ7XG4gICAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICBwYWRkaW5nSW5uZXIgPSAwO1xuICAgICAgcmF3U3RlcCA9IHJhbmdlRGlzdGFuY2UgKiAoMSAtIHBhZGRpbmdPdXRlciAqIDIpO1xuICAgICAgc3RlcCA9IHJvdW5kMyA/IE1hdGgucm91bmQocmF3U3RlcCkgOiByYXdTdGVwO1xuICAgICAgaW5zZXQgPSByYW5nZURpc3RhbmNlICogcGFkZGluZ091dGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICByYXdTdGVwID0gcmFuZ2VEaXN0YW5jZSAvIE1hdGgubWF4KDEsIGNvdW50IC0gcGFkZGluZ0lubmVyICsgcGFkZGluZ091dGVyICogMik7XG4gICAgICBzdGVwID0gcm91bmQzID8gTWF0aC5mbG9vcihyYXdTdGVwKSA6IHJhd1N0ZXA7XG4gICAgICBpbnNldCA9IHIwICsgKHJhbmdlRGlzdGFuY2UgLSBzdGVwICogKGNvdW50IC0gcGFkZGluZ0lubmVyKSkgLyAyO1xuICAgIH1cbiAgICBsZXQgYmFuZHdpZHRoID0gc3RlcCAqICgxIC0gcGFkZGluZ0lubmVyKTtcbiAgICBpZiAocm91bmQzKSB7XG4gICAgICBpbnNldCA9IE1hdGgucm91bmQoaW5zZXQpO1xuICAgICAgYmFuZHdpZHRoID0gTWF0aC5yb3VuZChiYW5kd2lkdGgpO1xuICAgIH1cbiAgICB0aGlzLl9zdGVwID0gc3RlcDtcbiAgICB0aGlzLl9pbnNldCA9IGluc2V0O1xuICAgIHRoaXMuX2JhbmR3aWR0aCA9IGJhbmR3aWR0aDtcbiAgICB0aGlzLl9yYXdCYW5kd2lkdGggPSByYXdTdGVwICogKDEgLSBwYWRkaW5nSW5uZXIpO1xuICAgIHRoaXMub3JkaW5hbFJhbmdlID0gdGhpcy5fZG9tYWluLm1hcCgoXywgaSkgPT4gaW5zZXQgKyBzdGVwICogaSk7XG4gIH1cbiAgZ2V0SW5kZXgodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleC5nZXQodmFsdWUgaW5zdGFuY2VvZiBEYXRlID8gdmFsdWUuZ2V0VGltZSgpIDogdmFsdWUpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfQmFuZFNjYWxlLnByb3RvdHlwZSwgXCJyYW5nZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX0JhbmRTY2FsZS5wcm90b3R5cGUsIFwicm91bmRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9CYW5kU2NhbGUucHJvdG90eXBlLCBcImludGVydmFsXCIsIDIpO1xudmFyIEJhbmRTY2FsZSA9IF9CYW5kU2NhbGU7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdmFsaWRhdGlvbi50c1xuZnVuY3Rpb24gVmFsaWRhdGUocHJlZGljYXRlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgeyBvcHRpb25hbCA9IGZhbHNlLCBwcm9wZXJ0eTogb3ZlcnJpZGVQcm9wZXJ0eSB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIGFkZFRyYW5zZm9ybVRvSW5zdGFuY2VQcm9wZXJ0eShcbiAgICAodGFyZ2V0LCBwcm9wZXJ0eSwgdmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGNvbnRleHQgPSB7IC4uLm9wdGlvbnMsIHRhcmdldCwgcHJvcGVydHkgfTtcbiAgICAgIGlmIChvcHRpb25hbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgfHwgcHJlZGljYXRlKHZhbHVlLCBjb250ZXh0KSkge1xuICAgICAgICBpZiAoaXNQcm9wZXJ0aWVzKHRhcmdldFtwcm9wZXJ0eV0pICYmICFpc1Byb3BlcnRpZXModmFsdWUpKSB7XG4gICAgICAgICAgdGFyZ2V0W3Byb3BlcnR5XS5zZXQodmFsdWUpO1xuICAgICAgICAgIHJldHVybiB0YXJnZXRbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNsZWFuS2V5ID0gb3ZlcnJpZGVQcm9wZXJ0eSA/PyBTdHJpbmcocHJvcGVydHkpLnJlcGxhY2UoL15fKi8sIFwiXCIpO1xuICAgICAgY29uc3QgdGFyZ2V0TmFtZSA9IHRhcmdldC5jb25zdHJ1Y3Rvci5jbGFzc05hbWUgPz8gdGFyZ2V0LmNvbnN0cnVjdG9yLm5hbWUucmVwbGFjZSgvUHJvcGVydGllcyQvLCBcIlwiKTtcbiAgICAgIGxldCB2YWx1ZVN0cmluZyA9IHN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICBjb25zdCBtYXhMZW5ndGggPSA1MDtcbiAgICAgIGlmICh2YWx1ZVN0cmluZyAhPSBudWxsICYmIHZhbHVlU3RyaW5nLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICBjb25zdCBleGNlc3NDaGFyYWN0ZXJzID0gdmFsdWVTdHJpbmcubGVuZ3RoIC0gbWF4TGVuZ3RoO1xuICAgICAgICB2YWx1ZVN0cmluZyA9IHZhbHVlU3RyaW5nLnNsaWNlKDAsIG1heExlbmd0aCkgKyBgLi4uICgrJHtleGNlc3NDaGFyYWN0ZXJzfSBjaGFyYWN0ZXJzKWA7XG4gICAgICB9XG4gICAgICBMb2dnZXIud2FybihcbiAgICAgICAgYFByb3BlcnR5IFske2NsZWFuS2V5fV0gb2YgWyR7dGFyZ2V0TmFtZX1dIGNhbm5vdCBiZSBzZXQgdG8gWyR7dmFsdWVTdHJpbmd9XSR7cHJlZGljYXRlLm1lc3NhZ2UgPyBgOyBleHBlY3RpbmcgJHtnZXRQcmVkaWNhdGVNZXNzYWdlKHByZWRpY2F0ZSwgY29udGV4dCl9YCA6IFwiXCJ9LCBpZ25vcmluZy5gXG4gICAgICApO1xuICAgICAgcmV0dXJuIEJSRUFLX1RSQU5TRk9STV9DSEFJTjtcbiAgICB9LFxuICAgIHZvaWQgMCxcbiAgICB7IG9wdGlvbmFsIH1cbiAgKTtcbn1cbnZhciBBTkQgPSAoLi4ucHJlZGljYXRlcykgPT4ge1xuICBjb25zdCBtZXNzYWdlcyA9IFtdO1xuICByZXR1cm4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICAgKHZhbHVlLCBjdHgpID0+IHtcbiAgICAgIG1lc3NhZ2VzLmxlbmd0aCA9IDA7XG4gICAgICByZXR1cm4gcHJlZGljYXRlcy5ldmVyeSgocHJlZGljYXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IGlzVmFsaWQyID0gcHJlZGljYXRlKHZhbHVlLCBjdHgpO1xuICAgICAgICBpZiAoIWlzVmFsaWQyKSB7XG4gICAgICAgICAgbWVzc2FnZXMucHVzaChnZXRQcmVkaWNhdGVNZXNzYWdlKHByZWRpY2F0ZSwgY3R4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVmFsaWQyO1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAoKSA9PiBtZXNzYWdlcy5maWx0ZXIoQm9vbGVhbikuam9pbihcIiBBTkQgXCIpXG4gICk7XG59O1xudmFyIE9SID0gKC4uLnByZWRpY2F0ZXMpID0+IHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAodmFsdWUsIGN0eCkgPT4gcHJlZGljYXRlcy5zb21lKChwcmVkaWNhdGUpID0+IHByZWRpY2F0ZSh2YWx1ZSwgY3R4KSksXG4gIChjdHgpID0+IHByZWRpY2F0ZXMubWFwKGdldFByZWRpY2F0ZU1lc3NhZ2VNYXBwZXIoY3R4KSkuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgT1IgXCIpXG4pO1xudmFyIE9CSkVDVCA9IGF0dGFjaE9iamVjdFJlc3RyaWN0aW9ucyhcbiAgcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICAgKHZhbHVlLCBjdHgpID0+IGlzUHJvcGVydGllcyh2YWx1ZSkgfHwgaXNPYmplY3QodmFsdWUpICYmIGlzUHJvcGVydGllcyhjdHgudGFyZ2V0W2N0eC5wcm9wZXJ0eV0pLFxuICAgIFwiYSBwcm9wZXJ0aWVzIG9iamVjdFwiXG4gIClcbik7XG52YXIgUExBSU5fT0JKRUNUID0gYXR0YWNoT2JqZWN0UmVzdHJpY3Rpb25zKHByZWRpY2F0ZVdpdGhNZXNzYWdlKCh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpLCBcImFuIG9iamVjdFwiKSk7XG52YXIgQk9PTEVBTiA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKGlzQm9vbGVhbiwgXCJhIGJvb2xlYW5cIik7XG52YXIgRlVOQ1RJT04gPSBwcmVkaWNhdGVXaXRoTWVzc2FnZShpc0Z1bmN0aW9uLCBcImEgZnVuY3Rpb25cIik7XG52YXIgU1RSSU5HID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoaXNTdHJpbmcsIFwiYSBzdHJpbmdcIik7XG52YXIgTlVNQkVSID0gYXR0YWNoTnVtYmVyUmVzdHJpY3Rpb25zKHByZWRpY2F0ZVdpdGhNZXNzYWdlKGlzRmluaXRlTnVtYmVyLCBcImEgbnVtYmVyXCIpKTtcbnZhciBOQU4gPSBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodmFsdWUpID0+IGlzTnVtYmVyKHZhbHVlKSAmJiBpc05hTih2YWx1ZSksIFwiTmFOXCIpO1xudmFyIFBPU0lUSVZFX05VTUJFUiA9IE5VTUJFUi5yZXN0cmljdCh7IG1pbjogMCB9KTtcbnZhciBSQVRJTyA9IE5VTUJFUi5yZXN0cmljdCh7IG1pbjogMCwgbWF4OiAxIH0pO1xudmFyIERFR1JFRSA9IE5VTUJFUi5yZXN0cmljdCh7IG1pbjogLTM2MCwgbWF4OiAzNjAgfSk7XG52YXIgTlVNQkVSX09SX05BTiA9IE9SKE5VTUJFUiwgTkFOKTtcbnZhciBBUlJBWSA9IGF0dGFjaEFycmF5UmVzdHJpY3Rpb25zKHByZWRpY2F0ZVdpdGhNZXNzYWdlKGlzQXJyYXksIFwiYW4gYXJyYXlcIikpO1xudmFyIEFSUkFZX09GID0gKHByZWRpY2F0ZSwgbWVzc2FnZSkgPT4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICh2YWx1ZSwgY3R4KSA9PiBpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5ldmVyeSgoaXRlbSkgPT4gcHJlZGljYXRlKGl0ZW0sIGN0eCkpLFxuICAoY3R4KSA9PiB7XG4gICAgY29uc3QgYXJyYXlNZXNzYWdlID0gZ2V0UHJlZGljYXRlTWVzc2FnZShBUlJBWSwgY3R4KSA/PyBcIlwiO1xuICAgIHJldHVybiBtZXNzYWdlID8gYCR7YXJyYXlNZXNzYWdlfSBvZiAke21lc3NhZ2V9YCA6IGFycmF5TWVzc2FnZTtcbiAgfVxuKTtcbnZhciBpc0NvbXBhcmFibGUgPSAodmFsdWUpID0+IGlzRmluaXRlTnVtYmVyKHZhbHVlKSB8fCBpc1ZhbGlkRGF0ZSh2YWx1ZSk7XG52YXIgTEVTU19USEFOID0gKG90aGVyRmllbGQpID0+IHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAodiwgY3R4KSA9PiAhaXNDb21wYXJhYmxlKHYpIHx8ICFpc0NvbXBhcmFibGUoY3R4LnRhcmdldFtvdGhlckZpZWxkXSkgfHwgdiA8IGN0eC50YXJnZXRbb3RoZXJGaWVsZF0sXG4gIGB0byBiZSBsZXNzIHRoYW4gJHtvdGhlckZpZWxkfWBcbik7XG52YXIgR1JFQVRFUl9USEFOID0gKG90aGVyRmllbGQpID0+IHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAodiwgY3R4KSA9PiAhaXNDb21wYXJhYmxlKHYpIHx8ICFpc0NvbXBhcmFibGUoY3R4LnRhcmdldFtvdGhlckZpZWxkXSkgfHwgdiA+IGN0eC50YXJnZXRbb3RoZXJGaWVsZF0sXG4gIGB0byBiZSBncmVhdGVyIHRoYW4gJHtvdGhlckZpZWxkfWBcbik7XG52YXIgREFURSA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKGlzVmFsaWREYXRlLCBcIkRhdGUgb2JqZWN0XCIpO1xudmFyIERBVEVfT1JfREFURVRJTUVfTVMgPSBPUihEQVRFLCBQT1NJVElWRV9OVU1CRVIpO1xudmFyIGNvbG9yTWVzc2FnZSA9IGBBIGNvbG9yIHN0cmluZyBjYW4gYmUgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybWF0cyB0byBiZSB2YWxpZDogI3JnYiwgI3JyZ2diYiwgcmdiKHIsIGcsIGIpLCByZ2JhKHIsIGcsIGIsIGEpIG9yIGEgQ1NTIGNvbG9yIG5hbWUgc3VjaCBhcyAnd2hpdGUnLCAnb3JhbmdlJywgJ2N5YW4nLCBldGNgO1xudmFyIENPTE9SX1NUUklORyA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKFxuICAodikgPT4gaXNTdHJpbmcodikgJiYgQ29sb3IudmFsaWRDb2xvclN0cmluZyh2KSxcbiAgYGNvbG9yIFN0cmluZy4gJHtjb2xvck1lc3NhZ2V9YFxuKTtcbnZhciBDT0xPUl9TVFJJTkdfQVJSQVkgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZShBUlJBWV9PRihDT0xPUl9TVFJJTkcpLCBgY29sb3Igc3RyaW5ncy4gJHtjb2xvck1lc3NhZ2V9YCk7XG52YXIgQk9PTEVBTl9BUlJBWSA9IEFSUkFZX09GKEJPT0xFQU4sIFwiYm9vbGVhbiB2YWx1ZXNcIik7XG52YXIgTlVNQkVSX0FSUkFZID0gQVJSQVlfT0YoTlVNQkVSLCBcIm51bWJlcnNcIik7XG52YXIgU1RSSU5HX0FSUkFZID0gQVJSQVlfT0YoU1RSSU5HLCBcInN0cmluZ3NcIik7XG52YXIgREFURV9BUlJBWSA9IHByZWRpY2F0ZVdpdGhNZXNzYWdlKEFSUkFZX09GKERBVEUpLCBcIkRhdGUgb2JqZWN0c1wiKTtcbnZhciBPQkpFQ1RfQVJSQVkgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZShBUlJBWV9PRihPQkpFQ1QpLCBcIm9iamVjdHNcIik7XG52YXIgTElORV9DQVAgPSBVTklPTihbXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIl0sIFwiYSBsaW5lIGNhcFwiKTtcbnZhciBMSU5FX0pPSU4gPSBVTklPTihbXCJyb3VuZFwiLCBcImJldmVsXCIsIFwibWl0ZXJcIl0sIFwiYSBsaW5lIGpvaW5cIik7XG52YXIgTElORV9EQVNIID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gIEFSUkFZX09GKFBPU0lUSVZFX05VTUJFUiksXG4gIFwibnVtYmVycyBzcGVjaWZ5aW5nIHRoZSBsZW5ndGggaW4gcGl4ZWxzIG9mIGFsdGVybmF0aW5nIGRhc2hlcyBhbmQgZ2FwcywgZm9yIGV4YW1wbGUsIFs2LCAzXSBtZWFucyBkYXNoZXMgd2l0aCBhIGxlbmd0aCBvZiA2IHBpeGVscyB3aXRoIGdhcHMgYmV0d2VlbiBvZiAzIHBpeGVscy5cIlxuKTtcbnZhciBQT1NJVElPTiA9IFVOSU9OKFtcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXSwgXCJhIHBvc2l0aW9uXCIpO1xudmFyIEZPTlRfU1RZTEUgPSBVTklPTihbXCJub3JtYWxcIiwgXCJpdGFsaWNcIiwgXCJvYmxpcXVlXCJdLCBcImEgZm9udCBzdHlsZVwiKTtcbnZhciBGT05UX1dFSUdIVCA9IE9SKFxuICBVTklPTihbXCJub3JtYWxcIiwgXCJib2xkXCIsIFwiYm9sZGVyXCIsIFwibGlnaHRlclwiXSwgXCJhIGZvbnQgd2VpZ2h0XCIpLFxuICBOVU1CRVIucmVzdHJpY3QoeyBtaW46IDEsIG1heDogMWUzIH0pXG4pO1xudmFyIFRFWFRfV1JBUCA9IFVOSU9OKFtcIm5ldmVyXCIsIFwiYWx3YXlzXCIsIFwiaHlwaGVuYXRlXCIsIFwib24tc3BhY2VcIl0sIFwiYSB0ZXh0IHdyYXAgc3RyYXRlZ3lcIik7XG52YXIgVEVYVF9BTElHTiA9IFVOSU9OKFtcImxlZnRcIiwgXCJjZW50ZXJcIiwgXCJyaWdodFwiXSwgXCJhIHRleHQgYWxpZ25cIik7XG52YXIgVkVSVElDQUxfQUxJR04gPSBVTklPTihbXCJ0b3BcIiwgXCJtaWRkbGVcIiwgXCJib3R0b21cIl0sIFwiYSB2ZXJ0aWNhbCBhbGlnblwiKTtcbnZhciBPVkVSRkxPV19TVFJBVEVHWSA9IFVOSU9OKFtcImVsbGlwc2lzXCIsIFwiaGlkZVwiXSwgXCJhbiBvdmVyZmxvdyBzdHJhdGVneVwiKTtcbnZhciBESVJFQ1RJT04gPSBVTklPTihbXCJob3Jpem9udGFsXCIsIFwidmVydGljYWxcIl0sIFwiYSBkaXJlY3Rpb25cIik7XG52YXIgUExBQ0VNRU5UID0gVU5JT04oW1wiaW5zaWRlXCIsIFwib3V0c2lkZVwiXSwgXCJhIHBsYWNlbWVudFwiKTtcbnZhciBJTlRFUkFDVElPTl9SQU5HRSA9IE9SKFVOSU9OKFtcImV4YWN0XCIsIFwibmVhcmVzdFwiXSwgXCJpbnRlcmFjdGlvbiByYW5nZVwiKSwgTlVNQkVSKTtcbnZhciBMQUJFTF9QTEFDRU1FTlQgPSBVTklPTihbXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJsZWZ0XCIsIFwicmlnaHRcIl0pO1xuZnVuY3Rpb24gVU5JT04ob3B0aW9ucywgbWVzc2FnZSA9IFwiYVwiKSB7XG4gIHJldHVybiBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgICAodikgPT4gb3B0aW9ucy5pbmNsdWRlcyh2KSxcbiAgICBgJHttZXNzYWdlfSBrZXl3b3JkIHN1Y2ggYXMgJHtqb2luVW5pb25PcHRpb25zKG9wdGlvbnMpfWBcbiAgKTtcbn1cbnZhciBNSU5fU1BBQ0lORyA9IE9SKEFORChOVU1CRVIucmVzdHJpY3QoeyBtaW46IDEgfSksIExFU1NfVEhBTihcIm1heFNwYWNpbmdcIikpLCBOQU4pO1xudmFyIE1BWF9TUEFDSU5HID0gT1IoQU5EKE5VTUJFUi5yZXN0cmljdCh7IG1pbjogMSB9KSwgR1JFQVRFUl9USEFOKFwibWluU3BhY2luZ1wiKSksIE5BTik7XG5mdW5jdGlvbiBwcmVkaWNhdGVXaXRoTWVzc2FnZShwcmVkaWNhdGUsIG1lc3NhZ2UpIHtcbiAgcHJlZGljYXRlLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICByZXR1cm4gcHJlZGljYXRlO1xufVxuZnVuY3Rpb24gam9pblVuaW9uT3B0aW9ucyhvcHRpb25zKSB7XG4gIGNvbnN0IHZhbHVlcyA9IG9wdGlvbnMubWFwKChvcHRpb24pID0+IGAnJHtvcHRpb259J2ApO1xuICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB2YWx1ZXNbMF07XG4gIH1cbiAgY29uc3QgbGFzdFZhbHVlID0gdmFsdWVzLnBvcCgpO1xuICByZXR1cm4gYCR7dmFsdWVzLmpvaW4oXCIsIFwiKX0gb3IgJHtsYXN0VmFsdWV9YDtcbn1cbmZ1bmN0aW9uIGdldFByZWRpY2F0ZU1lc3NhZ2UocHJlZGljYXRlLCBjdHgpIHtcbiAgcmV0dXJuIGlzRnVuY3Rpb24ocHJlZGljYXRlLm1lc3NhZ2UpID8gcHJlZGljYXRlLm1lc3NhZ2UoY3R4KSA6IHByZWRpY2F0ZS5tZXNzYWdlO1xufVxuZnVuY3Rpb24gZ2V0UHJlZGljYXRlTWVzc2FnZU1hcHBlcihjdHgpIHtcbiAgcmV0dXJuIChwcmVkaWNhdGUpID0+IGdldFByZWRpY2F0ZU1lc3NhZ2UocHJlZGljYXRlLCBjdHgpO1xufVxuZnVuY3Rpb24gYXR0YWNoQXJyYXlSZXN0cmljdGlvbnMocHJlZGljYXRlKSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHByZWRpY2F0ZSwge1xuICAgIHJlc3RyaWN0KHsgbGVuZ3RoOiBsZW5ndGgyLCBtaW5MZW5ndGggfSA9IHt9KSB7XG4gICAgICBsZXQgbWVzc2FnZSA9IFwiYW4gYXJyYXlcIjtcbiAgICAgIGlmIChpc051bWJlcihtaW5MZW5ndGgpICYmIG1pbkxlbmd0aCA+IDApIHtcbiAgICAgICAgbWVzc2FnZSA9IFwiYSBub24tZW1wdHkgYXJyYXlcIjtcbiAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIobGVuZ3RoMikpIHtcbiAgICAgICAgbWVzc2FnZSA9IGBhbiBhcnJheSBvZiBsZW5ndGggJHtsZW5ndGgyfWA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICAgICAgICh2YWx1ZSkgPT4gaXNBcnJheSh2YWx1ZSkgJiYgKGlzTnVtYmVyKGxlbmd0aDIpID8gdmFsdWUubGVuZ3RoID09PSBsZW5ndGgyIDogdHJ1ZSkgJiYgKGlzTnVtYmVyKG1pbkxlbmd0aCkgPyB2YWx1ZS5sZW5ndGggPj0gbWluTGVuZ3RoIDogdHJ1ZSksXG4gICAgICAgIG1lc3NhZ2VcbiAgICAgICk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGF0dGFjaE51bWJlclJlc3RyaWN0aW9ucyhwcmVkaWNhdGUpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJlZGljYXRlLCB7XG4gICAgcmVzdHJpY3QoeyBtaW4sIG1heCB9ID0ge30pIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBbXCJhIG51bWJlclwiXTtcbiAgICAgIGNvbnN0IGhhc01pbiA9IGlzTnVtYmVyKG1pbik7XG4gICAgICBjb25zdCBoYXNNYXggPSBpc051bWJlcihtYXgpO1xuICAgICAgaWYgKGhhc01pbiAmJiBoYXNNYXgpIHtcbiAgICAgICAgbWVzc2FnZS5wdXNoKGBiZXR3ZWVuICR7bWlufSBhbmQgJHttYXh9IGluY2x1c2l2ZWApO1xuICAgICAgfSBlbHNlIGlmIChoYXNNaW4pIHtcbiAgICAgICAgbWVzc2FnZS5wdXNoKGBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHttaW59YCk7XG4gICAgICB9IGVsc2UgaWYgKGhhc01heCkge1xuICAgICAgICBtZXNzYWdlLnB1c2goYGxlc3MgdGhhbiBvciBlcXVhbCB0byAke21heH1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgICAgICAgKHZhbHVlKSA9PiBpc0Zpbml0ZU51bWJlcih2YWx1ZSkgJiYgKGhhc01pbiA/IHZhbHVlID49IG1pbiA6IHRydWUpICYmIChoYXNNYXggPyB2YWx1ZSA8PSBtYXggOiB0cnVlKSxcbiAgICAgICAgbWVzc2FnZS5qb2luKFwiIFwiKVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gYXR0YWNoT2JqZWN0UmVzdHJpY3Rpb25zKHByZWRpY2F0ZSkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihwcmVkaWNhdGUsIHtcbiAgICByZXN0cmljdChvYmplY3RUeXBlKSB7XG4gICAgICByZXR1cm4gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICAgICAgICh2YWx1ZSkgPT4gdmFsdWUgaW5zdGFuY2VvZiBvYmplY3RUeXBlLFxuICAgICAgICAoY3R4KSA9PiBnZXRQcmVkaWNhdGVNZXNzYWdlKHByZWRpY2F0ZSwgY3R4KSA/PyBgYW4gaW5zdGFuY2Ugb2YgJHtvYmplY3RUeXBlLm5hbWV9YFxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoaXNOYU4odmFsdWUpKVxuICAgICAgcmV0dXJuIFwiTmFOXCI7XG4gICAgaWYgKHZhbHVlID09PSBJbmZpbml0eSlcbiAgICAgIHJldHVybiBcIkluZmluaXR5XCI7XG4gICAgaWYgKHZhbHVlID09PSAtSW5maW5pdHkpXG4gICAgICByZXR1cm4gXCItSW5maW5pdHlcIjtcbiAgfVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jaGFydEF4aXNEaXJlY3Rpb24udHNcbnZhciBDaGFydEF4aXNEaXJlY3Rpb24gPSAvKiBAX19QVVJFX18gKi8gKChDaGFydEF4aXNEaXJlY3Rpb24yKSA9PiB7XG4gIENoYXJ0QXhpc0RpcmVjdGlvbjJbXCJYXCJdID0gXCJ4XCI7XG4gIENoYXJ0QXhpc0RpcmVjdGlvbjJbXCJZXCJdID0gXCJ5XCI7XG4gIHJldHVybiBDaGFydEF4aXNEaXJlY3Rpb24yO1xufSkoQ2hhcnRBeGlzRGlyZWN0aW9uIHx8IHt9KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW9kdWxlL21vZHVsZU1hcC50c1xudmFyIE1vZHVsZU1hcCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5tb2R1bGVNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gICptb2R1bGVzKCkge1xuICAgIGNvbnN0IHNlcXVlbmNlZE1vZHVsZXMgPSBbXCJ0b29sYmFyXCIsIFwibmF2aWdhdG9yXCJdO1xuICAgIGZvciAoY29uc3QgbSBvZiB0aGlzLm1vZHVsZU1hcC52YWx1ZXMoKSkge1xuICAgICAgaWYgKHNlcXVlbmNlZE1vZHVsZXMuaW5jbHVkZXMobS5tb2R1bGUub3B0aW9uc0tleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB5aWVsZCBtLm1vZHVsZUluc3RhbmNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBzZXF1ZW5jZWRNb2R1bGVzKSB7XG4gICAgICBjb25zdCBtb2R1bGUgPSB0aGlzLm1vZHVsZU1hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChtb2R1bGUpIHtcbiAgICAgICAgeWllbGQgbW9kdWxlLm1vZHVsZUluc3RhbmNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhZGRNb2R1bGUobW9kdWxlLCBtb2R1bGVGYWN0b3J5KSB7XG4gICAgaWYgKHRoaXMubW9kdWxlTWFwLmhhcyhtb2R1bGUub3B0aW9uc0tleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gbW9kdWxlIGFscmVhZHkgaW5pdGlhbGlzZWQ6ICR7bW9kdWxlLm9wdGlvbnNLZXl9YCk7XG4gICAgfVxuICAgIHRoaXMubW9kdWxlTWFwLnNldChtb2R1bGUub3B0aW9uc0tleSwgeyBtb2R1bGUsIG1vZHVsZUluc3RhbmNlOiBtb2R1bGVGYWN0b3J5KG1vZHVsZSkgfSk7XG4gIH1cbiAgcmVtb3ZlTW9kdWxlKG1vZHVsZSkge1xuICAgIGNvbnN0IG1vZHVsZUtleSA9IGlzU3RyaW5nKG1vZHVsZSkgPyBtb2R1bGUgOiBtb2R1bGUub3B0aW9uc0tleTtcbiAgICB0aGlzLm1vZHVsZU1hcC5nZXQobW9kdWxlS2V5KT8ubW9kdWxlSW5zdGFuY2UuZGVzdHJveSgpO1xuICAgIHRoaXMubW9kdWxlTWFwLmRlbGV0ZShtb2R1bGVLZXkpO1xuICB9XG4gIGdldE1vZHVsZShtb2R1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGVNYXAuZ2V0KGlzU3RyaW5nKG1vZHVsZSkgPyBtb2R1bGUgOiBtb2R1bGUub3B0aW9uc0tleSk/Lm1vZHVsZUluc3RhbmNlO1xuICB9XG4gIGlzRW5hYmxlZChtb2R1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGVNYXAuaGFzKGlzU3RyaW5nKG1vZHVsZSkgPyBtb2R1bGUgOiBtb2R1bGUub3B0aW9uc0tleSk7XG4gIH1cbiAgbWFwTW9kdWxlcyhjYWxsYmFjazIpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLm1vZHVsZU1hcC52YWx1ZXMoKSwgKG0sIGkpID0+IGNhbGxiYWNrMihtLm1vZHVsZUluc3RhbmNlLCBpKSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IG1vZHVsZUtleSBvZiB0aGlzLm1vZHVsZU1hcC5rZXlzKCkpIHtcbiAgICAgIHRoaXMubW9kdWxlTWFwLmdldChtb2R1bGVLZXkpPy5tb2R1bGVJbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMubW9kdWxlTWFwLmNsZWFyKCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vdGlvbi9yZXNldE1vdGlvbi50c1xudmFyIHJlc2V0TW90aW9uX2V4cG9ydHMgPSB7fTtcbl9fZXhwb3J0KHJlc2V0TW90aW9uX2V4cG9ydHMsIHtcbiAgcmVzZXRNb3Rpb246ICgpID0+IHJlc2V0TW90aW9uXG59KTtcbmZ1bmN0aW9uIHJlc2V0TW90aW9uKHNlbGVjdGlvbnNPck5vZGVzLCBwcm9wc0ZuKSB7XG4gIGNvbnN0IHsgbm9kZXMsIHNlbGVjdGlvbnMgfSA9IGRlY29uc3RydWN0U2VsZWN0aW9uc09yTm9kZXMoc2VsZWN0aW9uc09yTm9kZXMpO1xuICBmb3IgKGNvbnN0IHNlbGVjdGlvbiBvZiBzZWxlY3Rpb25zKSB7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIHNlbGVjdGlvbi5ub2RlcygpKSB7XG4gICAgICBjb25zdCBmcm9tMiA9IHByb3BzRm4obm9kZSwgbm9kZS5kYXR1bSk7XG4gICAgICBub2RlLnNldFByb3BlcnRpZXMoZnJvbTIpO1xuICAgIH1cbiAgICBzZWxlY3Rpb24uY2xlYW51cCgpO1xuICB9XG4gIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgIGNvbnN0IGZyb20yID0gcHJvcHNGbihub2RlLCBub2RlLmRhdHVtKTtcbiAgICBub2RlLnNldFByb3BlcnRpZXMoZnJvbTIpO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjYWxlL2NvbnRpbnVvdXNTY2FsZS50c1xudmFyIF9Db250aW51b3VzU2NhbGUgPSBjbGFzcyBfQ29udGludW91c1NjYWxlIHtcbiAgY29uc3RydWN0b3IoZG9tYWluLCByYW5nZTMpIHtcbiAgICB0aGlzLmludmFsaWQgPSB0cnVlO1xuICAgIHRoaXMubmljZSA9IGZhbHNlO1xuICAgIHRoaXMuaW50ZXJ2YWwgPSB2b2lkIDA7XG4gICAgdGhpcy50aWNrQ291bnQgPSBfQ29udGludW91c1NjYWxlLmRlZmF1bHRUaWNrQ291bnQ7XG4gICAgdGhpcy5taW5UaWNrQ291bnQgPSAwO1xuICAgIHRoaXMubWF4VGlja0NvdW50ID0gSW5maW5pdHk7XG4gICAgLy8gVE9ETyhvbGVnYXQpIHNob3VsZCBiZSBvZiB0eXBlIERbXVxuICAgIHRoaXMubmljZURvbWFpbiA9IFtdO1xuICAgIHRoaXMuZGVmYXVsdENsYW1wTW9kZSA9IFwicmF3XCI7XG4gICAgdGhpcy5kb21haW4gPSBkb21haW47XG4gICAgdGhpcy5yYW5nZSA9IHJhbmdlMztcbiAgfVxuICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBfQ29udGludW91c1NjYWxlO1xuICB9XG4gIHRyYW5zZm9ybSh4KSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cbiAgdHJhbnNmb3JtSW52ZXJ0KHgpIHtcbiAgICByZXR1cm4geDtcbiAgfVxuICBjYWxjQmFuZHdpZHRoKHNtYWxsZXN0SW50ZXJ2YWwgPSAxKSB7XG4gICAgY29uc3QgZG9tYWluID0gdGhpcy5nZXREb21haW4oKTtcbiAgICBjb25zdCByYW5nZURpc3RhbmNlID0gdGhpcy5nZXRQaXhlbFJhbmdlKCk7XG4gICAgY29uc3QgaW50ZXJ2YWxzID0gTWF0aC5hYnMoZG9tYWluWzFdIC0gZG9tYWluWzBdKSAvIHNtYWxsZXN0SW50ZXJ2YWwgKyAxO1xuICAgIGNvbnN0IG1heEJhbmRzID0gTWF0aC5mbG9vcihyYW5nZURpc3RhbmNlKTtcbiAgICBjb25zdCBiYW5kcyA9IE1hdGgubWluKGludGVydmFscywgbWF4QmFuZHMpO1xuICAgIHJldHVybiByYW5nZURpc3RhbmNlIC8gTWF0aC5tYXgoMSwgYmFuZHMpO1xuICB9XG4gIGdldERvbWFpbigpIHtcbiAgICBpZiAodGhpcy5uaWNlKSB7XG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgIGlmICh0aGlzLm5pY2VEb21haW4ubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5pY2VEb21haW47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRvbWFpbjtcbiAgfVxuICBjb252ZXJ0KHgsIG9wdHMpIHtcbiAgICBjb25zdCBjbGFtcE1vZGUgPSBvcHRzPy5jbGFtcE1vZGUgPz8gdGhpcy5kZWZhdWx0Q2xhbXBNb2RlO1xuICAgIGlmICghdGhpcy5kb21haW4gfHwgdGhpcy5kb21haW4ubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgY29uc3QgZG9tYWluID0gdGhpcy5nZXREb21haW4oKS5tYXAoKGQpID0+IHRoaXMudHJhbnNmb3JtKGQpKTtcbiAgICBjb25zdCBbZDAsIGQxXSA9IGRvbWFpbjtcbiAgICBjb25zdCB7IHJhbmdlOiByYW5nZTMgfSA9IHRoaXM7XG4gICAgY29uc3QgW3IwLCByMV0gPSByYW5nZTM7XG4gICAgeCA9IHRoaXMudHJhbnNmb3JtKHgpO1xuICAgIGlmIChjbGFtcE1vZGUgPT09IFwiY2xhbXBlZFwiKSB7XG4gICAgICBjb25zdCBbc3RhcnQsIHN0b3BdID0gZmluZE1pbk1heChkb21haW4ubWFwKE51bWJlcikpO1xuICAgICAgaWYgKE51bWJlcih4KSA8IHN0YXJ0KSB7XG4gICAgICAgIHJldHVybiByMDtcbiAgICAgIH0gZWxzZSBpZiAoTnVtYmVyKHgpID4gc3RvcCkge1xuICAgICAgICByZXR1cm4gcjE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkMCA9PT0gZDEpIHtcbiAgICAgIHJldHVybiAocjAgKyByMSkgLyAyO1xuICAgIH0gZWxzZSBpZiAoeCA9PT0gZDApIHtcbiAgICAgIHJldHVybiByMDtcbiAgICB9IGVsc2UgaWYgKHggPT09IGQxKSB7XG4gICAgICByZXR1cm4gcjE7XG4gICAgfVxuICAgIHJldHVybiByMCArIChOdW1iZXIoeCkgLSBOdW1iZXIoZDApKSAvIChOdW1iZXIoZDEpIC0gTnVtYmVyKGQwKSkgKiAocjEgLSByMCk7XG4gIH1cbiAgaW52ZXJ0KHgpIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICBjb25zdCBkb21haW4gPSB0aGlzLmdldERvbWFpbigpLm1hcCgoZDIpID0+IHRoaXMudHJhbnNmb3JtKGQyKSk7XG4gICAgY29uc3QgW2QwLCBkMV0gPSBkb21haW47XG4gICAgY29uc3QgeyByYW5nZTogcmFuZ2UzIH0gPSB0aGlzO1xuICAgIGNvbnN0IFtyMCwgcjFdID0gcmFuZ2UzO1xuICAgIGNvbnN0IGlzUmV2ZXJzZWQgPSByMCA+IHIxO1xuICAgIGNvbnN0IHJNaW4gPSBpc1JldmVyc2VkID8gcjEgOiByMDtcbiAgICBjb25zdCByTWF4ID0gaXNSZXZlcnNlZCA/IHIwIDogcjE7XG4gICAgbGV0IGQ7XG4gICAgaWYgKHggPCByTWluKSB7XG4gICAgICByZXR1cm4gaXNSZXZlcnNlZCA/IGQxIDogZDA7XG4gICAgfSBlbHNlIGlmICh4ID4gck1heCkge1xuICAgICAgcmV0dXJuIGlzUmV2ZXJzZWQgPyBkMCA6IGQxO1xuICAgIH0gZWxzZSBpZiAocjAgPT09IHIxKSB7XG4gICAgICBkID0gdGhpcy50b0RvbWFpbigoTnVtYmVyKGQwKSArIE51bWJlcihkMSkpIC8gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGQgPSB0aGlzLnRvRG9tYWluKE51bWJlcihkMCkgKyAoeCAtIHIwKSAvIChyMSAtIHIwKSAqIChOdW1iZXIoZDEpIC0gTnVtYmVyKGQwKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1JbnZlcnQoZCk7XG4gIH1cbiAgcmVmcmVzaCgpIHtcbiAgICBpZiAoIXRoaXMuaW52YWxpZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmludmFsaWQgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIGlmICh0aGlzLmludmFsaWQpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShcIkV4cGVjdGVkIHVwZGF0ZSB0byBub3QgaW52YWxpZGF0ZSBzY2FsZVwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0UGl4ZWxSYW5nZSgpIHtcbiAgICBjb25zdCBbYSwgYl0gPSB0aGlzLnJhbmdlO1xuICAgIHJldHVybiBNYXRoLmFicyhiIC0gYSk7XG4gIH1cbn07XG5fQ29udGludW91c1NjYWxlLmRlZmF1bHRUaWNrQ291bnQgPSA1O1xuX0NvbnRpbnVvdXNTY2FsZS5kZWZhdWx0TWF4VGlja0NvdW50ID0gNjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX0NvbnRpbnVvdXNTY2FsZS5wcm90b3R5cGUsIFwiZG9tYWluXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfQ29udGludW91c1NjYWxlLnByb3RvdHlwZSwgXCJyYW5nZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX0NvbnRpbnVvdXNTY2FsZS5wcm90b3R5cGUsIFwibmljZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX0NvbnRpbnVvdXNTY2FsZS5wcm90b3R5cGUsIFwiaW50ZXJ2YWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9Db250aW51b3VzU2NhbGUucHJvdG90eXBlLCBcInRpY2tDb3VudFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX0NvbnRpbnVvdXNTY2FsZS5wcm90b3R5cGUsIFwibWluVGlja0NvdW50XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBfQ29udGludW91c1NjYWxlLnByb3RvdHlwZSwgXCJtYXhUaWNrQ291bnRcIiwgMik7XG52YXIgQ29udGludW91c1NjYWxlID0gX0NvbnRpbnVvdXNTY2FsZTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9udW1iZXJGb3JtYXQudHNcbmZ1bmN0aW9uIHBhcnNlRm9ybWF0KGZvcm1hdCkge1xuICBsZXQgcHJlZml4O1xuICBsZXQgc3VmZml4O1xuICBjb25zdCBzdXJyb3VuZGVkID0gc3Vycm91bmRlZFJlZ0V4LmV4ZWMoZm9ybWF0KTtcbiAgaWYgKHN1cnJvdW5kZWQpIHtcbiAgICBbLCBwcmVmaXgsIGZvcm1hdCwgc3VmZml4XSA9IHN1cnJvdW5kZWQ7XG4gIH1cbiAgY29uc3QgbWF0Y2ggPSBmb3JtYXRSZWdFeC5leGVjKGZvcm1hdCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBudW1iZXIgZm9ybWF0dGVyIGlzIGludmFsaWQ6ICR7Zm9ybWF0fWApO1xuICB9XG4gIGNvbnN0IFssIGZpbGwsIGFsaWduLCBzaWduLCBzeW1ib2wsIHplcm8sIHdpZHRoLCBjb21tYSwgcHJlY2lzaW9uLCB0cmltLCB0eXBlXSA9IG1hdGNoO1xuICByZXR1cm4ge1xuICAgIGZpbGwsXG4gICAgYWxpZ24sXG4gICAgc2lnbixcbiAgICBzeW1ib2wsXG4gICAgemVybyxcbiAgICB3aWR0aDogcGFyc2VJbnQod2lkdGgpLFxuICAgIGNvbW1hLFxuICAgIHByZWNpc2lvbjogcGFyc2VJbnQocHJlY2lzaW9uKSxcbiAgICB0cmltOiBCb29sZWFuKHRyaW0pLFxuICAgIHR5cGUsXG4gICAgcHJlZml4LFxuICAgIHN1ZmZpeFxuICB9O1xufVxuZnVuY3Rpb24gbnVtYmVyRm9ybWF0KGZvcm1hdCkge1xuICBjb25zdCBvcHRpb25zID0gdHlwZW9mIGZvcm1hdCA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlRm9ybWF0KGZvcm1hdCkgOiBmb3JtYXQ7XG4gIGNvbnN0IHsgZmlsbCwgYWxpZ24sIHNpZ24gPSBcIi1cIiwgc3ltYm9sLCB6ZXJvLCB3aWR0aCwgY29tbWEsIHR5cGUsIHByZWZpeCA9IFwiXCIsIHN1ZmZpeCA9IFwiXCIsIHByZWNpc2lvbiB9ID0gb3B0aW9ucztcbiAgbGV0IHsgdHJpbSB9ID0gb3B0aW9ucztcbiAgY29uc3QgcHJlY2lzaW9uSXNOYU4gPSBwcmVjaXNpb24gPT0gbnVsbCB8fCBpc05hTihwcmVjaXNpb24pO1xuICBsZXQgZm9ybWF0Qm9keTtcbiAgaWYgKCF0eXBlKSB7XG4gICAgZm9ybWF0Qm9keSA9IGRlY2ltYWxUeXBlc1tcImdcIl07XG4gICAgdHJpbSA9IHRydWU7XG4gIH0gZWxzZSBpZiAodHlwZSBpbiBkZWNpbWFsVHlwZXMgJiYgdHlwZSBpbiBpbnRlZ2VyVHlwZXMpIHtcbiAgICBmb3JtYXRCb2R5ID0gcHJlY2lzaW9uSXNOYU4gPyBpbnRlZ2VyVHlwZXNbdHlwZV0gOiBkZWNpbWFsVHlwZXNbdHlwZV07XG4gIH0gZWxzZSBpZiAodHlwZSBpbiBkZWNpbWFsVHlwZXMpIHtcbiAgICBmb3JtYXRCb2R5ID0gZGVjaW1hbFR5cGVzW3R5cGVdO1xuICB9IGVsc2UgaWYgKHR5cGUgaW4gaW50ZWdlclR5cGVzKSB7XG4gICAgZm9ybWF0Qm9keSA9IGludGVnZXJUeXBlc1t0eXBlXTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBudW1iZXIgZm9ybWF0dGVyIHR5cGUgaXMgaW52YWxpZDogJHt0eXBlfWApO1xuICB9XG4gIGxldCBmb3JtYXR0ZXJQcmVjaXNpb247XG4gIGlmIChwcmVjaXNpb24gPT0gbnVsbCB8fCBwcmVjaXNpb25Jc05hTikge1xuICAgIGZvcm1hdHRlclByZWNpc2lvbiA9IHR5cGUgPyA2IDogMTI7XG4gIH0gZWxzZSB7XG4gICAgZm9ybWF0dGVyUHJlY2lzaW9uID0gcHJlY2lzaW9uO1xuICB9XG4gIHJldHVybiAobikgPT4ge1xuICAgIGxldCByZXN1bHQgPSBmb3JtYXRCb2R5KG4sIGZvcm1hdHRlclByZWNpc2lvbik7XG4gICAgaWYgKHRyaW0pIHtcbiAgICAgIHJlc3VsdCA9IHJlbW92ZVRyYWlsaW5nWmVyb3MocmVzdWx0KTtcbiAgICB9XG4gICAgaWYgKGNvbW1hKSB7XG4gICAgICByZXN1bHQgPSBpbnNlcnRTZXBhcmF0b3IocmVzdWx0LCBjb21tYSk7XG4gICAgfVxuICAgIHJlc3VsdCA9IGFkZFNpZ24obiwgcmVzdWx0LCBzaWduKTtcbiAgICBpZiAoc3ltYm9sICYmIHN5bWJvbCAhPT0gXCIjXCIpIHtcbiAgICAgIHJlc3VsdCA9IGAke3N5bWJvbH0ke3Jlc3VsdH1gO1xuICAgIH1cbiAgICBpZiAoc3ltYm9sID09PSBcIiNcIiAmJiB0eXBlID09PSBcInhcIikge1xuICAgICAgcmVzdWx0ID0gYDB4JHtyZXN1bHR9YDtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwic1wiKSB7XG4gICAgICByZXN1bHQgPSBgJHtyZXN1bHR9JHtnZXRTSVByZWZpeChuKX1gO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCIlXCIgfHwgdHlwZSA9PT0gXCJwXCIpIHtcbiAgICAgIHJlc3VsdCA9IGAke3Jlc3VsdH0lYDtcbiAgICB9XG4gICAgaWYgKHdpZHRoICE9IG51bGwgJiYgIWlzTmFOKHdpZHRoKSkge1xuICAgICAgcmVzdWx0ID0gYWRkUGFkZGluZyhyZXN1bHQsIHdpZHRoLCBmaWxsID8/IHplcm8sIGFsaWduKTtcbiAgICB9XG4gICAgcmVzdWx0ID0gYCR7cHJlZml4fSR7cmVzdWx0fSR7c3VmZml4fWA7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cbnZhciBmb3JtYXRSZWdFeCA9IC9eKD86KC4pPyhbPD49Xl0pKT8oWytcXC0oIF0pPyhbJOKCrMKjwqXigqPigrkjXSk/KDApPyhcXGQrKT8oLCk/KD86XFwuKFxcZCspKT8ofik/KFslYS16XSk/JC9pO1xudmFyIHN1cnJvdW5kZWRSZWdFeCA9IC9eKCg/OlteI118I1tee10pKikjeyhbXn1dKyl9KC4qKSQvO1xudmFyIGludGVnZXJUeXBlcyA9IHtcbiAgYjogKG4pID0+IGFic0Zsb29yKG4pLnRvU3RyaW5nKDIpLFxuICBjOiAobikgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShuKSxcbiAgZDogKG4pID0+IE1hdGgucm91bmQoTWF0aC5hYnMobikpLnRvRml4ZWQoMCksXG4gIG86IChuKSA9PiBhYnNGbG9vcihuKS50b1N0cmluZyg4KSxcbiAgeDogKG4pID0+IGFic0Zsb29yKG4pLnRvU3RyaW5nKDE2KSxcbiAgWDogKG4pID0+IGludGVnZXJUeXBlcy54KG4pLnRvVXBwZXJDYXNlKCksXG4gIG46IChuKSA9PiBpbnRlZ2VyVHlwZXMuZChuKSxcbiAgXCIlXCI6IChuKSA9PiBgJHthYnNGbG9vcihuICogMTAwKS50b0ZpeGVkKDApfWBcbn07XG52YXIgZGVjaW1hbFR5cGVzID0ge1xuICBlOiAobiwgZikgPT4gTWF0aC5hYnMobikudG9FeHBvbmVudGlhbChmKSxcbiAgRTogKG4sIGYpID0+IGRlY2ltYWxUeXBlcy5lKG4sIGYpLnRvVXBwZXJDYXNlKCksXG4gIGY6IChuLCBmKSA9PiBNYXRoLmFicyhuKS50b0ZpeGVkKGYpLFxuICBGOiAobiwgZikgPT4gZGVjaW1hbFR5cGVzLmYobiwgZikudG9VcHBlckNhc2UoKSxcbiAgZzogKG4sIGYpID0+IHtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgcmV0dXJuIFwiMFwiO1xuICAgIH1cbiAgICBjb25zdCBhID0gTWF0aC5hYnMobik7XG4gICAgY29uc3QgcCA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChhKSk7XG4gICAgaWYgKHAgPj0gLTQgJiYgcCA8IGYpIHtcbiAgICAgIHJldHVybiBhLnRvRml4ZWQoZiAtIDEgLSBwKTtcbiAgICB9XG4gICAgcmV0dXJuIGEudG9FeHBvbmVudGlhbChmIC0gMSk7XG4gIH0sXG4gIEc6IChuLCBmKSA9PiBkZWNpbWFsVHlwZXMuZyhuLCBmKS50b1VwcGVyQ2FzZSgpLFxuICBuOiAobiwgZikgPT4gZGVjaW1hbFR5cGVzLmcobiwgZiksXG4gIHA6IChuLCBmKSA9PiBkZWNpbWFsVHlwZXMucihuICogMTAwLCBmKSxcbiAgcjogKG4sIGYpID0+IHtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgcmV0dXJuIFwiMFwiO1xuICAgIH1cbiAgICBjb25zdCBhID0gTWF0aC5hYnMobik7XG4gICAgY29uc3QgcCA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChhKSk7XG4gICAgY29uc3QgcSA9IHAgLSAoZiAtIDEpO1xuICAgIGlmIChxIDw9IDApIHtcbiAgICAgIHJldHVybiBhLnRvRml4ZWQoLXEpO1xuICAgIH1cbiAgICBjb25zdCB4ID0gMTAgKiogcTtcbiAgICByZXR1cm4gKE1hdGgucm91bmQoYSAvIHgpICogeCkudG9GaXhlZCgpO1xuICB9LFxuICBzOiAobiwgZikgPT4ge1xuICAgIGNvbnN0IHAgPSBnZXRTSVByZWZpeFBvd2VyKG4pO1xuICAgIHJldHVybiBkZWNpbWFsVHlwZXMucihuIC8gMTAgKiogcCwgZik7XG4gIH0sXG4gIFwiJVwiOiAobiwgZikgPT4gZGVjaW1hbFR5cGVzLmYobiAqIDEwMCwgZilcbn07XG52YXIgbWluU0lQcmVmaXggPSAtMjQ7XG52YXIgbWF4U0lQcmVmaXggPSAyNDtcbnZhciBzaVByZWZpeGVzID0ge1xuICBbbWluU0lQcmVmaXhdOiBcInlcIixcbiAgWy0yMV06IFwielwiLFxuICBbLTE4XTogXCJhXCIsXG4gIFstMTVdOiBcImZcIixcbiAgWy0xMl06IFwicFwiLFxuICBbLTldOiBcIm5cIixcbiAgWy02XTogXCJcXHhCNVwiLFxuICBbLTNdOiBcIm1cIixcbiAgWzBdOiBcIlwiLFxuICBbM106IFwia1wiLFxuICBbNl06IFwiTVwiLFxuICBbOV06IFwiR1wiLFxuICBbMTJdOiBcIlRcIixcbiAgWzE1XTogXCJQXCIsXG4gIFsxOF06IFwiRVwiLFxuICBbMjFdOiBcIlpcIixcbiAgW21heFNJUHJlZml4XTogXCJZXCJcbn07XG52YXIgbWludXNTaWduID0gXCJcXHUyMjEyXCI7XG5mdW5jdGlvbiBhYnNGbG9vcihuKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGguYWJzKG4pKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVRyYWlsaW5nWmVyb3MobnVtU3RyaW5nKSB7XG4gIHJldHVybiBudW1TdHJpbmcucmVwbGFjZSgvXFwuMCskLywgXCJcIikucmVwbGFjZSgvKFxcLlsxLTldKTArJC8sIFwiJDFcIik7XG59XG5mdW5jdGlvbiBpbnNlcnRTZXBhcmF0b3IobnVtU3RyaW5nLCBzZXBhcmF0b3IpIHtcbiAgbGV0IGRvdEluZGV4ID0gbnVtU3RyaW5nLmluZGV4T2YoXCIuXCIpO1xuICBpZiAoZG90SW5kZXggPCAwKSB7XG4gICAgZG90SW5kZXggPSBudW1TdHJpbmcubGVuZ3RoO1xuICB9XG4gIGNvbnN0IGludGVnZXJDaGFycyA9IG51bVN0cmluZy5zdWJzdHJpbmcoMCwgZG90SW5kZXgpLnNwbGl0KFwiXCIpO1xuICBjb25zdCBmcmFjdGlvbmFsUGFydCA9IG51bVN0cmluZy5zdWJzdHJpbmcoZG90SW5kZXgpO1xuICBmb3IgKGxldCBpID0gaW50ZWdlckNoYXJzLmxlbmd0aCAtIDM7IGkgPiAwOyBpIC09IDMpIHtcbiAgICBpbnRlZ2VyQ2hhcnMuc3BsaWNlKGksIDAsIHNlcGFyYXRvcik7XG4gIH1cbiAgcmV0dXJuIGAke2ludGVnZXJDaGFycy5qb2luKFwiXCIpfSR7ZnJhY3Rpb25hbFBhcnR9YDtcbn1cbmZ1bmN0aW9uIGdldFNJUHJlZml4KG4pIHtcbiAgcmV0dXJuIHNpUHJlZml4ZXNbZ2V0U0lQcmVmaXhQb3dlcihuKV07XG59XG5mdW5jdGlvbiBnZXRTSVByZWZpeFBvd2VyKG4pIHtcbiAgcmV0dXJuIGNsYW1wKG1pblNJUHJlZml4LCBuID8gTWF0aC5mbG9vcihNYXRoLmxvZzEwKE1hdGguYWJzKG4pKSAvIDMpICogMyA6IDAsIG1heFNJUHJlZml4KTtcbn1cbmZ1bmN0aW9uIGFkZFNpZ24obnVtLCBudW1TdHJpbmcsIHNpZ25UeXBlID0gXCJcIikge1xuICBpZiAoc2lnblR5cGUgPT09IFwiKFwiKSB7XG4gICAgcmV0dXJuIG51bSA+PSAwID8gbnVtU3RyaW5nIDogYCgke251bVN0cmluZ30pYDtcbiAgfVxuICBjb25zdCBwbHVzU2lnbiA9IHNpZ25UeXBlID09PSBcIitcIiA/IFwiK1wiIDogXCJcIjtcbiAgcmV0dXJuIGAke251bSA+PSAwID8gcGx1c1NpZ24gOiBtaW51c1NpZ259JHtudW1TdHJpbmd9YDtcbn1cbmZ1bmN0aW9uIGFkZFBhZGRpbmcobnVtU3RyaW5nLCB3aWR0aCwgZmlsbCA9IFwiIFwiLCBhbGlnbiA9IFwiPlwiKSB7XG4gIGxldCByZXN1bHQgPSBudW1TdHJpbmc7XG4gIGlmIChhbGlnbiA9PT0gXCI+XCIgfHwgIWFsaWduKSB7XG4gICAgcmVzdWx0ID0gcmVzdWx0LnBhZFN0YXJ0KHdpZHRoLCBmaWxsKTtcbiAgfSBlbHNlIGlmIChhbGlnbiA9PT0gXCI8XCIpIHtcbiAgICByZXN1bHQgPSByZXN1bHQucGFkRW5kKHdpZHRoLCBmaWxsKTtcbiAgfSBlbHNlIGlmIChhbGlnbiA9PT0gXCJeXCIpIHtcbiAgICBjb25zdCBwYWRXaWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIC0gcmVzdWx0Lmxlbmd0aCk7XG4gICAgY29uc3QgcGFkTGVmdCA9IE1hdGguY2VpbChwYWRXaWR0aCAvIDIpO1xuICAgIGNvbnN0IHBhZFJpZ2h0ID0gTWF0aC5mbG9vcihwYWRXaWR0aCAvIDIpO1xuICAgIHJlc3VsdCA9IHJlc3VsdC5wYWRTdGFydChwYWRMZWZ0ICsgcmVzdWx0Lmxlbmd0aCwgZmlsbCk7XG4gICAgcmVzdWx0ID0gcmVzdWx0LnBhZEVuZChwYWRSaWdodCArIHJlc3VsdC5sZW5ndGgsIGZpbGwpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvYXJyYXkudHNcbmZ1bmN0aW9uIHRpbWVzKG4sIGNhbGxiYWNrMikge1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgcmVzdWx0cy5wdXNoKGNhbGxiYWNrMihpKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5mdW5jdGlvbiBleHRlbnQodmFsdWVzKSB7XG4gIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBtaW4gPSBJbmZpbml0eTtcbiAgbGV0IG1heCA9IC1JbmZpbml0eTtcbiAgZm9yIChsZXQgbiBvZiB2YWx1ZXMpIHtcbiAgICBpZiAobiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIG4gPSBuLmdldFRpbWUoKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuICE9PSBcIm51bWJlclwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG4gPCBtaW4pIHtcbiAgICAgIG1pbiA9IG47XG4gICAgfVxuICAgIGlmIChuID4gbWF4KSB7XG4gICAgICBtYXggPSBuO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXN1bHQgPSBbbWluLCBtYXhdO1xuICBpZiAocmVzdWx0LmV2ZXJ5KGlzRmluaXRlKSkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGlzZWRFeHRlbnQoZCwgbWluLCBtYXgpIHtcbiAgcmV0dXJuIG5vcm1hbGlzZWRFeHRlbnRXaXRoTWV0YWRhdGEoZCwgbWluLCBtYXgpLmV4dGVudDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGlzZWRFeHRlbnRXaXRoTWV0YWRhdGEoZCwgbWluLCBtYXgpIHtcbiAgbGV0IGNsaXBwZWQgPSBmYWxzZTtcbiAgaWYgKGQubGVuZ3RoID4gMikge1xuICAgIGQgPSBleHRlbnQoZCkgPz8gW05hTiwgTmFOXTtcbiAgfVxuICBpZiAoIWlzTmFOKG1pbikpIHtcbiAgICBjbGlwcGVkIHx8IChjbGlwcGVkID0gbWluID4gZFswXSk7XG4gICAgZCA9IFttaW4sIGRbMV1dO1xuICB9XG4gIGlmICghaXNOYU4obWF4KSkge1xuICAgIGNsaXBwZWQgfHwgKGNsaXBwZWQgPSBtYXggPCBkWzFdKTtcbiAgICBkID0gW2RbMF0sIG1heF07XG4gIH1cbiAgaWYgKGRbMF0gPiBkWzFdKSB7XG4gICAgZCA9IFtdO1xuICB9XG4gIHJldHVybiB7IGV4dGVudDogZCwgY2xpcHBlZCB9O1xufVxuZnVuY3Rpb24gYXJyYXlzRXF1YWwoYSwgYikge1xuICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCB8fCBhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYVtpXSkgJiYgQXJyYXkuaXNBcnJheShiW2ldKSkge1xuICAgICAgaWYgKCFhcnJheXNFcXVhbChhW2ldLCBiW2ldKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbn1cbmZ1bmN0aW9uIHVuaXF1ZShhcnJheTIpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChhcnJheTIpKTtcbn1cbmZ1bmN0aW9uIGdyb3VwQnkoYXJyYXkyLCBpdGVyYXRlZSkge1xuICByZXR1cm4gYXJyYXkyLnJlZHVjZSgocmVzdWx0LCBpdGVtKSA9PiB7XG4gICAgY29uc3QgZ3JvdXBLZXkgPSBpdGVyYXRlZShpdGVtKTtcbiAgICByZXN1bHRbZ3JvdXBLZXldID8/IChyZXN1bHRbZ3JvdXBLZXldID0gW10pO1xuICAgIHJlc3VsdFtncm91cEtleV0ucHVzaChpdGVtKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBjaXJjdWxhclNsaWNlQXJyYXkoZGF0YSwgc2l6ZSwgb2Zmc2V0NCA9IDApIHtcbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgIHJlc3VsdC5wdXNoKGRhdGEuYXQoKGkgKyBvZmZzZXQ0KSAlIGRhdGEubGVuZ3RoKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGJpZnVyY2F0ZShpc0xlZnQsIGFycmF5Mikge1xuICByZXR1cm4gYXJyYXkyLnJlZHVjZShcbiAgICAoW2xlZnQsIHJpZ2h0XSwgdmFsdWUpID0+IGlzTGVmdCh2YWx1ZSkgPyBbWy4uLmxlZnQsIHZhbHVlXSwgcmlnaHRdIDogW2xlZnQsIFsuLi5yaWdodCwgdmFsdWVdXSxcbiAgICBbW10sIFtdXVxuICApO1xufVxuZnVuY3Rpb24qIG1hcEl0ZXJhYmxlKHNyYywgcHJlZGljYXRlKSB7XG4gIGZvciAoY29uc3QgZSBvZiBzcmMpIHtcbiAgICB5aWVsZCBwcmVkaWNhdGUoZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbnN0U3RyaW5nc0luY2x1ZGVzKGFycmF5MiwgdmFsdWUpIHtcbiAgY29uc3QgY2FzdGluZyA9IGFycmF5MjtcbiAgcmV0dXJuIGNhc3RpbmcuaW5jbHVkZXModmFsdWUpO1xufVxuZnVuY3Rpb24gaXNJblN0cmluZ1VuaW9uKHVuaW9uVmFsdWVzLCB2YWx1ZSkge1xuICByZXR1cm4gY29uc3RTdHJpbmdzSW5jbHVkZXModW5pb25WYWx1ZXMsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGFsbEluU3RyaW5nVW5pb24odW5pb25WYWx1ZXMsIHZhbHVlcykge1xuICByZXR1cm4gIXZhbHVlcy5zb21lKCh2KSA9PiAhaXNJblN0cmluZ1VuaW9uKHVuaW9uVmFsdWVzLCB2KSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGlja3MudHNcbnZhciB0SW50ZXJ2YWwgPSAodGltZUludGVydmFsLCBiYXNlRHVyYXRpb24sIHN0ZXApID0+ICh7XG4gIGR1cmF0aW9uOiBiYXNlRHVyYXRpb24gKiBzdGVwLFxuICB0aW1lSW50ZXJ2YWwsXG4gIHN0ZXBcbn0pO1xudmFyIFRpY2tJbnRlcnZhbHMgPSBbXG4gIHRJbnRlcnZhbChzZWNvbmRfZGVmYXVsdCwgZHVyYXRpb25TZWNvbmQsIDEpLFxuICB0SW50ZXJ2YWwoc2Vjb25kX2RlZmF1bHQsIGR1cmF0aW9uU2Vjb25kLCA1KSxcbiAgdEludGVydmFsKHNlY29uZF9kZWZhdWx0LCBkdXJhdGlvblNlY29uZCwgMTUpLFxuICB0SW50ZXJ2YWwoc2Vjb25kX2RlZmF1bHQsIGR1cmF0aW9uU2Vjb25kLCAzMCksXG4gIHRJbnRlcnZhbChtaW51dGVfZGVmYXVsdCwgZHVyYXRpb25NaW51dGUsIDEpLFxuICB0SW50ZXJ2YWwobWludXRlX2RlZmF1bHQsIGR1cmF0aW9uTWludXRlLCA1KSxcbiAgdEludGVydmFsKG1pbnV0ZV9kZWZhdWx0LCBkdXJhdGlvbk1pbnV0ZSwgMTUpLFxuICB0SW50ZXJ2YWwobWludXRlX2RlZmF1bHQsIGR1cmF0aW9uTWludXRlLCAzMCksXG4gIHRJbnRlcnZhbChob3VyX2RlZmF1bHQsIGR1cmF0aW9uSG91ciwgMSksXG4gIHRJbnRlcnZhbChob3VyX2RlZmF1bHQsIGR1cmF0aW9uSG91ciwgMyksXG4gIHRJbnRlcnZhbChob3VyX2RlZmF1bHQsIGR1cmF0aW9uSG91ciwgNiksXG4gIHRJbnRlcnZhbChob3VyX2RlZmF1bHQsIGR1cmF0aW9uSG91ciwgMTIpLFxuICB0SW50ZXJ2YWwoZGF5X2RlZmF1bHQsIGR1cmF0aW9uRGF5LCAxKSxcbiAgdEludGVydmFsKGRheV9kZWZhdWx0LCBkdXJhdGlvbkRheSwgMiksXG4gIHRJbnRlcnZhbCh3ZWVrX2RlZmF1bHQsIGR1cmF0aW9uV2VlaywgMSksXG4gIHRJbnRlcnZhbCh3ZWVrX2RlZmF1bHQsIGR1cmF0aW9uV2VlaywgMiksXG4gIHRJbnRlcnZhbCh3ZWVrX2RlZmF1bHQsIGR1cmF0aW9uV2VlaywgMyksXG4gIHRJbnRlcnZhbChtb250aF9kZWZhdWx0LCBkdXJhdGlvbk1vbnRoLCAxKSxcbiAgdEludGVydmFsKG1vbnRoX2RlZmF1bHQsIGR1cmF0aW9uTW9udGgsIDIpLFxuICB0SW50ZXJ2YWwobW9udGhfZGVmYXVsdCwgZHVyYXRpb25Nb250aCwgMyksXG4gIHRJbnRlcnZhbChtb250aF9kZWZhdWx0LCBkdXJhdGlvbk1vbnRoLCA0KSxcbiAgdEludGVydmFsKG1vbnRoX2RlZmF1bHQsIGR1cmF0aW9uTW9udGgsIDYpLFxuICB0SW50ZXJ2YWwoeWVhcl9kZWZhdWx0LCBkdXJhdGlvblllYXIsIDEpXG5dO1xudmFyIFRpY2tNdWx0aXBsaWVycyA9IFsxLCAyLCA1LCAxMF07XG5mdW5jdGlvbiBjcmVhdGVUaWNrcyhzdGFydCwgc3RvcCwgY291bnQsIG1pbkNvdW50LCBtYXhDb3VudCkge1xuICBpZiAoY291bnQgPCAyKSB7XG4gICAgcmV0dXJuIHJhbmdlKHN0YXJ0LCBzdG9wLCBzdG9wIC0gc3RhcnQpO1xuICB9XG4gIGNvbnN0IHN0ZXAgPSB0aWNrU3RlcChzdGFydCwgc3RvcCwgY291bnQsIG1pbkNvdW50LCBtYXhDb3VudCk7XG4gIGlmIChpc05hTihzdGVwKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBzdGFydCA9IE1hdGguY2VpbChzdGFydCAvIHN0ZXApICogc3RlcDtcbiAgc3RvcCA9IE1hdGguZmxvb3Ioc3RvcCAvIHN0ZXApICogc3RlcDtcbiAgcmV0dXJuIHJhbmdlKHN0YXJ0LCBzdG9wLCBzdGVwKTtcbn1cbmZ1bmN0aW9uIGdldFRpY2tJbnRlcnZhbChzdGFydCwgc3RvcCwgY291bnQsIG1pbkNvdW50LCBtYXhDb3VudCwgdGFyZ2V0SW50ZXJ2YWwpIHtcbiAgY29uc3QgdGFyZ2V0ID0gdGFyZ2V0SW50ZXJ2YWwgPz8gTWF0aC5hYnMoc3RvcCAtIHN0YXJ0KSAvIE1hdGgubWF4KGNvdW50LCAxKTtcbiAgbGV0IGkgPSAwO1xuICBmb3IgKGNvbnN0IHRpY2tJbnRlcnZhbCBvZiBUaWNrSW50ZXJ2YWxzKSB7XG4gICAgaWYgKHRhcmdldCA8PSB0aWNrSW50ZXJ2YWwuZHVyYXRpb24pXG4gICAgICBicmVhaztcbiAgICBpKys7XG4gIH1cbiAgaWYgKGkgPT09IDApIHtcbiAgICBjb25zdCBzdGVwMiA9IE1hdGgubWF4KHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCwgbWluQ291bnQsIG1heENvdW50KSwgMSk7XG4gICAgcmV0dXJuIG1pbGxpc2Vjb25kX2RlZmF1bHQuZXZlcnkoc3RlcDIpO1xuICB9IGVsc2UgaWYgKGkgPT09IFRpY2tJbnRlcnZhbHMubGVuZ3RoKSB7XG4gICAgY29uc3Qgc3RlcDIgPSB0YXJnZXRJbnRlcnZhbCA9PSBudWxsID8gdGlja1N0ZXAoc3RhcnQgLyBkdXJhdGlvblllYXIsIHN0b3AgLyBkdXJhdGlvblllYXIsIGNvdW50LCBtaW5Db3VudCwgbWF4Q291bnQpIDogMTtcbiAgICByZXR1cm4geWVhcl9kZWZhdWx0LmV2ZXJ5KHN0ZXAyKTtcbiAgfVxuICBjb25zdCBpMCA9IFRpY2tJbnRlcnZhbHNbaSAtIDFdO1xuICBjb25zdCBpMSA9IFRpY2tJbnRlcnZhbHNbaV07XG4gIGNvbnN0IHsgdGltZUludGVydmFsLCBzdGVwIH0gPSB0YXJnZXQgLSBpMC5kdXJhdGlvbiA8IGkxLmR1cmF0aW9uIC0gdGFyZ2V0ID8gaTAgOiBpMTtcbiAgcmV0dXJuIHRpbWVJbnRlcnZhbC5ldmVyeShzdGVwKTtcbn1cbmZ1bmN0aW9uIHRpY2tTdGVwKHN0YXJ0LCBlbmQsIGNvdW50LCBtaW5Db3VudCA9IDAsIG1heENvdW50ID0gSW5maW5pdHkpIHtcbiAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICBpZiAoY291bnQgPCAxKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuICBjb25zdCBleHRlbnQyID0gTWF0aC5hYnMoZW5kIC0gc3RhcnQpO1xuICBjb25zdCBzdGVwID0gMTAgKiogTWF0aC5mbG9vcihNYXRoLmxvZzEwKGV4dGVudDIgLyBjb3VudCkpO1xuICBsZXQgbSA9IE5hTiwgbWluRGlmZiA9IEluZmluaXR5LCBpc0luQm91bmRzID0gZmFsc2U7XG4gIGZvciAoY29uc3QgbXVsdGlwbGllciBvZiBUaWNrTXVsdGlwbGllcnMpIHtcbiAgICBjb25zdCBjID0gTWF0aC5jZWlsKGV4dGVudDIgLyAobXVsdGlwbGllciAqIHN0ZXApKTtcbiAgICBjb25zdCB2YWxpZEJvdW5kcyA9IGMgPj0gbWluQ291bnQgJiYgYyA8PSBtYXhDb3VudDtcbiAgICBpZiAoaXNJbkJvdW5kcyAmJiAhdmFsaWRCb3VuZHMpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBkaWZmQ291bnQgPSBNYXRoLmFicyhjIC0gY291bnQpO1xuICAgIGlmIChtaW5EaWZmID4gZGlmZkNvdW50IHx8IGlzSW5Cb3VuZHMgIT09IHZhbGlkQm91bmRzKSB7XG4gICAgICBpc0luQm91bmRzIHx8IChpc0luQm91bmRzID0gdmFsaWRCb3VuZHMpO1xuICAgICAgbWluRGlmZiA9IGRpZmZDb3VudDtcbiAgICAgIG0gPSBtdWx0aXBsaWVyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbSAqIHN0ZXA7XG59XG5mdW5jdGlvbiBkZWNpbWFsUGxhY2VzKGRlY2ltYWwpIHtcbiAgZm9yIChsZXQgaSA9IGRlY2ltYWwubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICBpZiAoZGVjaW1hbFtpXSAhPT0gXCIwXCIpIHtcbiAgICAgIHJldHVybiBpICsgMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiB0aWNrRm9ybWF0KHRpY2tzLCBmb3JtYXQpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IHBhcnNlRm9ybWF0KGZvcm1hdCA/PyBcIixmXCIpO1xuICBpZiAob3B0aW9ucy5wcmVjaXNpb24gPT0gbnVsbCB8fCBpc05hTihvcHRpb25zLnByZWNpc2lvbikpIHtcbiAgICBpZiAoIW9wdGlvbnMudHlwZSB8fCBcImVFRmdHbnByc1wiLmluY2x1ZGVzKG9wdGlvbnMudHlwZSkpIHtcbiAgICAgIG9wdGlvbnMucHJlY2lzaW9uID0gTWF0aC5tYXgoXG4gICAgICAgIC4uLnRpY2tzLm1hcCgoeCkgPT4ge1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHgpKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgY29uc3QgW2ludGVnZXIsIGRlY2ltYWxdID0geC50b0V4cG9uZW50aWFsKChvcHRpb25zLnR5cGUgPyA2IDogMTIpIC0gMSkuc3BsaXQoL1xcLnxlL2cpO1xuICAgICAgICAgIHJldHVybiAoaW50ZWdlciAhPT0gXCIxXCIgJiYgaW50ZWdlciAhPT0gXCItMVwiID8gMSA6IDApICsgZGVjaW1hbFBsYWNlcyhkZWNpbWFsKSArIDE7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoXCJmJVwiLmluY2x1ZGVzKG9wdGlvbnMudHlwZSkpIHtcbiAgICAgIG9wdGlvbnMucHJlY2lzaW9uID0gTWF0aC5tYXgoXG4gICAgICAgIC4uLnRpY2tzLm1hcCgoeCkgPT4ge1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKHgpIHx8IHggPT09IDApXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICBjb25zdCBsID0gTWF0aC5mbG9vcihNYXRoLmxvZzEwKE1hdGguYWJzKHgpKSk7XG4gICAgICAgICAgY29uc3QgZGlnaXRzID0gb3B0aW9ucy50eXBlID8gNiA6IDEyO1xuICAgICAgICAgIGNvbnN0IFtfaW50ZWdlciwgZGVjaW1hbF0gPSB4LnRvRXhwb25lbnRpYWwoZGlnaXRzIC0gMSkuc3BsaXQoL1xcLnxlL2cpO1xuICAgICAgICAgIGNvbnN0IGRlY2ltYWxMZW5ndGggPSBkZWNpbWFsUGxhY2VzKGRlY2ltYWwpO1xuICAgICAgICAgIHJldHVybiBNYXRoLm1heCgwLCBkZWNpbWFsTGVuZ3RoIC0gbCk7XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBjb25zdCBmb3JtYXR0ZXIgPSBudW1iZXJGb3JtYXQob3B0aW9ucyk7XG4gIHJldHVybiAobikgPT4gZm9ybWF0dGVyKE51bWJlcihuKSk7XG59XG5mdW5jdGlvbiByYW5nZShzdGFydCwgZW5kLCBzdGVwKSB7XG4gIGNvbnN0IG4gPSBNYXRoLmNlaWwoTWF0aC5hYnMoZW5kIC0gc3RhcnQpIC8gc3RlcCk7XG4gIGNvbnN0IGYgPSAxMCAqKiBjb3VudEZyYWN0aW9uRGlnaXRzKHN0ZXApO1xuICBjb25zdCBkMCA9IE1hdGgubWluKHN0YXJ0LCBlbmQpO1xuICByZXR1cm4gdGltZXMobiArIDEsIChpKSA9PiBNYXRoLnJvdW5kKChkMCArIHN0ZXAgKiBpKSAqIGYpIC8gZik7XG59XG5mdW5jdGlvbiBpc0RlbnNlSW50ZXJ2YWwoY291bnQsIGF2YWlsYWJsZVJhbmdlKSB7XG4gIGlmIChjb3VudCA+PSBhdmFpbGFibGVSYW5nZSkge1xuICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgIGB0aGUgY29uZmlndXJlZCBpbnRlcnZhbCByZXN1bHRzIGluIG1vcmUgdGhhbiAxIGl0ZW0gcGVyIHBpeGVsLCBpZ25vcmluZy4gU3VwcGx5IGEgbGFyZ2VyIGludGVydmFsIG9yIG9taXQgdGhpcyBjb25maWd1cmF0aW9uYFxuICAgICk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gbmljZVRpY2tzRG9tYWluKHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgZXh0ZW50MiA9IE1hdGguYWJzKGVuZCAtIHN0YXJ0KTtcbiAgY29uc3Qgc3RlcCA9IDEwICoqIE1hdGguZmxvb3IoTWF0aC5sb2cxMChleHRlbnQyKSk7XG4gIGxldCBtaW5FcnJvciA9IEluZmluaXR5LCB0aWNrcyA9IFtzdGFydCwgZW5kXTtcbiAgZm9yIChjb25zdCBtdWx0aXBsaWVyIG9mIFRpY2tNdWx0aXBsaWVycykge1xuICAgIGNvbnN0IG0gPSBtdWx0aXBsaWVyICogc3RlcDtcbiAgICBjb25zdCBkMCA9IE1hdGguZmxvb3Ioc3RhcnQgLyBtKSAqIG07XG4gICAgY29uc3QgZDEgPSBNYXRoLmNlaWwoZW5kIC8gbSkgKiBtO1xuICAgIGNvbnN0IGVycm9yID0gMSAtIGV4dGVudDIgLyBNYXRoLmFicyhkMSAtIGQwKTtcbiAgICBpZiAobWluRXJyb3IgPiBlcnJvcikge1xuICAgICAgbWluRXJyb3IgPSBlcnJvcjtcbiAgICAgIHRpY2tzID0gW2QwLCBkMV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0aWNrcztcbn1cbmZ1bmN0aW9uIGVzdGltYXRlVGlja0NvdW50KHJhbmdlRXh0ZW50LCBtaW5TcGFjaW5nLCBtYXhTcGFjaW5nLCBkZWZhdWx0VGlja0NvdW50LCBkZWZhdWx0TWluU3BhY2luZykge1xuICBkZWZhdWx0TWluU3BhY2luZyA9IE1hdGgubWF4KGRlZmF1bHRNaW5TcGFjaW5nLCByYW5nZUV4dGVudCAvIChkZWZhdWx0VGlja0NvdW50ICsgMSkpO1xuICBpZiAoaXNOYU4obWluU3BhY2luZykpIHtcbiAgICBtaW5TcGFjaW5nID0gZGVmYXVsdE1pblNwYWNpbmc7XG4gIH1cbiAgaWYgKGlzTmFOKG1heFNwYWNpbmcpKSB7XG4gICAgbWF4U3BhY2luZyA9IHJhbmdlRXh0ZW50O1xuICB9XG4gIGlmIChtaW5TcGFjaW5nID4gbWF4U3BhY2luZykge1xuICAgIGlmIChtaW5TcGFjaW5nID09PSBkZWZhdWx0TWluU3BhY2luZykge1xuICAgICAgbWluU3BhY2luZyA9IG1heFNwYWNpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1heFNwYWNpbmcgPSBtaW5TcGFjaW5nO1xuICAgIH1cbiAgfVxuICBjb25zdCBtYXhUaWNrQ291bnQgPSBjbGFtcCgxLCBNYXRoLmZsb29yKHJhbmdlRXh0ZW50IC8gbWluU3BhY2luZyksIE1hdGgubWluKE1hdGguZmxvb3IocmFuZ2VFeHRlbnQpLCAxMDApKTtcbiAgY29uc3QgbWluVGlja0NvdW50ID0gTWF0aC5taW4obWF4VGlja0NvdW50LCBNYXRoLmNlaWwocmFuZ2VFeHRlbnQgLyBtYXhTcGFjaW5nKSk7XG4gIGNvbnN0IHRpY2tDb3VudCA9IGNsYW1wKG1pblRpY2tDb3VudCwgZGVmYXVsdFRpY2tDb3VudCwgbWF4VGlja0NvdW50KTtcbiAgcmV0dXJuIHsgbWluVGlja0NvdW50LCBtYXhUaWNrQ291bnQsIHRpY2tDb3VudCB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2FsZS9sb2dTY2FsZS50c1xudmFyIF9Mb2dTY2FsZSA9IGNsYXNzIF9Mb2dTY2FsZSBleHRlbmRzIENvbnRpbnVvdXNTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFsxLCAxMF0sIFswLCAxXSk7XG4gICAgdGhpcy50eXBlID0gXCJsb2dcIjtcbiAgICB0aGlzLmJhc2UgPSAxMDtcbiAgICB0aGlzLmJhc2VMb2cgPSBpZGVudGl0eTtcbiAgICB0aGlzLmJhc2VQb3cgPSBpZGVudGl0eTtcbiAgICB0aGlzLmxvZyA9ICh4KSA9PiB7XG4gICAgICBjb25zdCBzdGFydCA9IE1hdGgubWluKC4uLnRoaXMuZG9tYWluKTtcbiAgICAgIHJldHVybiBzdGFydCA+PSAwID8gdGhpcy5iYXNlTG9nKHgpIDogLXRoaXMuYmFzZUxvZygteCk7XG4gICAgfTtcbiAgICB0aGlzLnBvdyA9ICh4KSA9PiB7XG4gICAgICBjb25zdCBzdGFydCA9IE1hdGgubWluKC4uLnRoaXMuZG9tYWluKTtcbiAgICAgIHJldHVybiBzdGFydCA+PSAwID8gdGhpcy5iYXNlUG93KHgpIDogLXRoaXMuYmFzZVBvdygteCk7XG4gICAgfTtcbiAgICB0aGlzLmRlZmF1bHRDbGFtcE1vZGUgPSBcImNsYW1wZWRcIjtcbiAgfVxuICB0b0RvbWFpbihkKSB7XG4gICAgcmV0dXJuIGQ7XG4gIH1cbiAgdHJhbnNmb3JtKHgpIHtcbiAgICBjb25zdCBzdGFydCA9IE1hdGgubWluKC4uLnRoaXMuZG9tYWluKTtcbiAgICByZXR1cm4gc3RhcnQgPj0gMCA/IE1hdGgubG9nKHgpIDogLU1hdGgubG9nKC14KTtcbiAgfVxuICB0cmFuc2Zvcm1JbnZlcnQoeCkge1xuICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5taW4oLi4udGhpcy5kb21haW4pO1xuICAgIHJldHVybiBzdGFydCA+PSAwID8gTWF0aC5leHAoeCkgOiAtTWF0aC5leHAoLXgpO1xuICB9XG4gIHJlZnJlc2goKSB7XG4gICAgaWYgKHRoaXMuYmFzZSA8PSAwKSB7XG4gICAgICB0aGlzLmJhc2UgPSAwO1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKFwiZXhwZWN0aW5nIGEgZmluaXRlIE51bWJlciBncmVhdGVyIHRoYW4gdG8gMFwiKTtcbiAgICB9XG4gICAgc3VwZXIucmVmcmVzaCgpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuZG9tYWluIHx8IHRoaXMuZG9tYWluLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5iYXNlTG9nID0gX0xvZ1NjYWxlLmdldEJhc2VMb2dNZXRob2QodGhpcy5iYXNlKTtcbiAgICB0aGlzLmJhc2VQb3cgPSBfTG9nU2NhbGUuZ2V0QmFzZVBvd2VyTWV0aG9kKHRoaXMuYmFzZSk7XG4gICAgaWYgKHRoaXMubmljZSkge1xuICAgICAgdGhpcy51cGRhdGVOaWNlRG9tYWluKCk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZU5pY2VEb21haW4oKSB7XG4gICAgY29uc3QgW2QwLCBkMV0gPSB0aGlzLmRvbWFpbjtcbiAgICBjb25zdCByb3VuZFN0YXJ0ID0gZDAgPiBkMSA/IE1hdGguY2VpbCA6IE1hdGguZmxvb3I7XG4gICAgY29uc3Qgcm91bmRTdG9wID0gZDAgPiBkMSA/IE1hdGguZmxvb3IgOiBNYXRoLmNlaWw7XG4gICAgY29uc3QgbjAgPSB0aGlzLnBvdyhyb3VuZFN0YXJ0KHRoaXMubG9nKGQwKSkpO1xuICAgIGNvbnN0IG4xID0gdGhpcy5wb3cocm91bmRTdG9wKHRoaXMubG9nKGQxKSkpO1xuICAgIHRoaXMubmljZURvbWFpbiA9IFtuMCwgbjFdO1xuICB9XG4gIHRpY2tzKCkge1xuICAgIGNvbnN0IGNvdW50ID0gdGhpcy50aWNrQ291bnQgPz8gMTA7XG4gICAgaWYgKCF0aGlzLmRvbWFpbiB8fCB0aGlzLmRvbWFpbi5sZW5ndGggPCAyIHx8IGNvdW50IDwgMSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICBjb25zdCBiYXNlID0gdGhpcy5iYXNlO1xuICAgIGNvbnN0IFtkMCwgZDFdID0gdGhpcy5nZXREb21haW4oKTtcbiAgICBjb25zdCBzdGFydCA9IE1hdGgubWluKGQwLCBkMSk7XG4gICAgY29uc3Qgc3RvcCA9IE1hdGgubWF4KGQwLCBkMSk7XG4gICAgbGV0IHAwID0gdGhpcy5sb2coc3RhcnQpO1xuICAgIGxldCBwMSA9IHRoaXMubG9nKHN0b3ApO1xuICAgIGlmICh0aGlzLmludGVydmFsKSB7XG4gICAgICBjb25zdCBpbkJvdW5kcyA9ICh0aWNrKSA9PiB0aWNrID49IHN0YXJ0ICYmIHRpY2sgPD0gc3RvcDtcbiAgICAgIGNvbnN0IHN0ZXAgPSBNYXRoLm1pbihNYXRoLmFicyh0aGlzLmludGVydmFsKSwgTWF0aC5hYnMocDEgLSBwMCkpO1xuICAgICAgY29uc3QgdGlja3MyID0gcmFuZ2UocDAsIHAxLCBzdGVwKS5tYXAodGhpcy5wb3cpLmZpbHRlcihpbkJvdW5kcyk7XG4gICAgICBpZiAoIWlzRGVuc2VJbnRlcnZhbCh0aWNrczIubGVuZ3RoLCB0aGlzLmdldFBpeGVsUmFuZ2UoKSkpIHtcbiAgICAgICAgcmV0dXJuIHRpY2tzMjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaXNCYXNlSW50ZWdlciA9IGJhc2UgJSAxID09PSAwO1xuICAgIGNvbnN0IGlzRGlmZkxhcmdlID0gcDEgLSBwMCA+PSBjb3VudDtcbiAgICBpZiAoIWlzQmFzZUludGVnZXIgfHwgaXNEaWZmTGFyZ2UpIHtcbiAgICAgIHJldHVybiBjcmVhdGVUaWNrcyhwMCwgcDEsIE1hdGgubWluKHAxIC0gcDAsIGNvdW50KSkubWFwKHRoaXMucG93KTtcbiAgICB9XG4gICAgY29uc3QgdGlja3MgPSBbXTtcbiAgICBjb25zdCBpc1Bvc2l0aXZlID0gc3RhcnQgPiAwO1xuICAgIHAwID0gTWF0aC5mbG9vcihwMCkgLSAxO1xuICAgIHAxID0gTWF0aC5yb3VuZChwMSkgKyAxO1xuICAgIGNvbnN0IGF2YWlsYWJsZVNwYWNpbmcgPSBmaW5kUmFuZ2VFeHRlbnQodGhpcy5yYW5nZSkgLyBjb3VudDtcbiAgICBsZXQgbGFzdFRpY2tQb3NpdGlvbiA9IEluZmluaXR5O1xuICAgIGZvciAobGV0IHAgPSBwMDsgcCA8PSBwMTsgcCsrKSB7XG4gICAgICBjb25zdCBuZXh0TWFnbml0dWRlVGlja1Bvc2l0aW9uID0gdGhpcy5jb252ZXJ0KHRoaXMucG93KHAgKyAxKSk7XG4gICAgICBmb3IgKGxldCBrID0gMTsgayA8IGJhc2U7IGsrKykge1xuICAgICAgICBjb25zdCBxID0gaXNQb3NpdGl2ZSA/IGsgOiBiYXNlIC0gayArIDE7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLnBvdyhwKSAqIHE7XG4gICAgICAgIGNvbnN0IHRpY2tQb3NpdGlvbiA9IHRoaXMuY29udmVydCh0KTtcbiAgICAgICAgY29uc3QgcHJldlNwYWNpbmcgPSBNYXRoLmFicyhsYXN0VGlja1Bvc2l0aW9uIC0gdGlja1Bvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgbmV4dFNwYWNpbmcgPSBNYXRoLmFicyh0aWNrUG9zaXRpb24gLSBuZXh0TWFnbml0dWRlVGlja1Bvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgZml0cyA9IHByZXZTcGFjaW5nID49IGF2YWlsYWJsZVNwYWNpbmcgJiYgbmV4dFNwYWNpbmcgPj0gYXZhaWxhYmxlU3BhY2luZztcbiAgICAgICAgaWYgKHQgPj0gc3RhcnQgJiYgdCA8PSBzdG9wICYmIChrID09PSAxIHx8IGZpdHMgfHwgdGlja3MubGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgIHRpY2tzLnB1c2godCk7XG4gICAgICAgICAgbGFzdFRpY2tQb3NpdGlvbiA9IHRpY2tQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cbiAgdGlja0Zvcm1hdCh7XG4gICAgY291bnQsXG4gICAgdGlja3MsXG4gICAgc3BlY2lmaWVyXG4gIH0pIHtcbiAgICBpZiAoY291bnQgIT09IEluZmluaXR5ICYmIHRpY2tzID09IG51bGwpIHtcbiAgICAgIHRoaXMudGlja3MoKTtcbiAgICB9XG4gICAgc3BlY2lmaWVyID8/IChzcGVjaWZpZXIgPSB0aGlzLmJhc2UgPT09IDEwID8gXCIuMGVcIiA6IFwiLFwiKTtcbiAgICByZXR1cm4gaXNTdHJpbmcoc3BlY2lmaWVyKSA/IG51bWJlckZvcm1hdChzcGVjaWZpZXIpIDogc3BlY2lmaWVyO1xuICB9XG4gIHN0YXRpYyBnZXRCYXNlTG9nTWV0aG9kKGJhc2UpIHtcbiAgICBzd2l0Y2ggKGJhc2UpIHtcbiAgICAgIGNhc2UgMTA6XG4gICAgICAgIHJldHVybiBNYXRoLmxvZzEwO1xuICAgICAgY2FzZSBNYXRoLkU6XG4gICAgICAgIHJldHVybiBNYXRoLmxvZztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nMjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnN0IGxvZ0Jhc2UgPSBNYXRoLmxvZyhiYXNlKTtcbiAgICAgICAgcmV0dXJuICh4KSA9PiBNYXRoLmxvZyh4KSAvIGxvZ0Jhc2U7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBnZXRCYXNlUG93ZXJNZXRob2QoYmFzZSkge1xuICAgIHN3aXRjaCAoYmFzZSkge1xuICAgICAgY2FzZSAxMDpcbiAgICAgICAgcmV0dXJuICh4KSA9PiB4ID49IDAgPyAxMCAqKiB4IDogMSAvIDEwICoqIC14O1xuICAgICAgY2FzZSBNYXRoLkU6XG4gICAgICAgIHJldHVybiBNYXRoLmV4cDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiAoeCkgPT4gYmFzZSAqKiB4O1xuICAgIH1cbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEludmFsaWRhdGluZ1xuXSwgX0xvZ1NjYWxlLnByb3RvdHlwZSwgXCJiYXNlXCIsIDIpO1xudmFyIExvZ1NjYWxlID0gX0xvZ1NjYWxlO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2FsZS90aW1lU2NhbGUudHNcbnZhciBUaW1lU2NhbGUgPSBjbGFzcyBfVGltZVNjYWxlIGV4dGVuZHMgQ29udGludW91c1NjYWxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoW10sIFswLCAxXSk7XG4gICAgdGhpcy50eXBlID0gXCJ0aW1lXCI7XG4gIH1cbiAgdG9Eb21haW4oZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShkKTtcbiAgfVxuICBjb252ZXJ0KHgsIG9wdHMpIHtcbiAgICByZXR1cm4gc3VwZXIuY29udmVydChuZXcgRGF0ZSh4KSwgb3B0cyk7XG4gIH1cbiAgaW52ZXJ0KHkpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoc3VwZXIuaW52ZXJ0KHkpKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB1bmlmb3JtbHktc3BhY2VkIGRhdGVzIHRoYXQgcmVwcmVzZW50IHRoZSBzY2FsZSdzIGRvbWFpbi5cbiAgICovXG4gIHRpY2tzKCkge1xuICAgIGlmICghdGhpcy5kb21haW4gfHwgdGhpcy5kb21haW4ubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICBjb25zdCB7IGludGVydmFsLCBuaWNlLCB0aWNrQ291bnQsIG1pblRpY2tDb3VudCwgbWF4VGlja0NvdW50IH0gPSB0aGlzO1xuICAgIGNvbnN0IFtzdGFydCwgc3RvcF0gPSBmaW5kTWluTWF4KHRoaXMuZ2V0RG9tYWluKCkubWFwKGRhdGVUb051bWJlcikpO1xuICAgIGlmIChpbnRlcnZhbCAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gX1RpbWVTY2FsZS5nZXRUaWNrc0ZvckludGVydmFsKHsgc3RhcnQsIHN0b3AsIGludGVydmFsLCBhdmFpbGFibGVSYW5nZTogdGhpcy5nZXRQaXhlbFJhbmdlKCkgfSkgPz8gX1RpbWVTY2FsZS5nZXREZWZhdWx0VGlja3MoeyBzdGFydCwgc3RvcCwgdGlja0NvdW50LCBtaW5UaWNrQ291bnQsIG1heFRpY2tDb3VudCB9KTtcbiAgICB9IGVsc2UgaWYgKG5pY2UgJiYgdGlja0NvdW50ID09PSAyKSB7XG4gICAgICByZXR1cm4gdGhpcy5uaWNlRG9tYWluO1xuICAgIH0gZWxzZSBpZiAobmljZSAmJiB0aWNrQ291bnQgPT09IDEpIHtcbiAgICAgIHJldHVybiB0aGlzLm5pY2VEb21haW4uc2xpY2UoMCwgMSk7XG4gICAgfVxuICAgIHJldHVybiBfVGltZVNjYWxlLmdldERlZmF1bHRUaWNrcyh7IHN0YXJ0LCBzdG9wLCB0aWNrQ291bnQsIG1pblRpY2tDb3VudCwgbWF4VGlja0NvdW50IH0pO1xuICB9XG4gIHN0YXRpYyBnZXREZWZhdWx0VGlja3Moe1xuICAgIHN0YXJ0LFxuICAgIHN0b3AsXG4gICAgdGlja0NvdW50LFxuICAgIG1pblRpY2tDb3VudCxcbiAgICBtYXhUaWNrQ291bnRcbiAgfSkge1xuICAgIGNvbnN0IHQgPSBnZXRUaWNrSW50ZXJ2YWwoc3RhcnQsIHN0b3AsIHRpY2tDb3VudCwgbWluVGlja0NvdW50LCBtYXhUaWNrQ291bnQpO1xuICAgIHJldHVybiB0ID8gdC5yYW5nZShuZXcgRGF0ZShzdGFydCksIG5ldyBEYXRlKHN0b3ApKSA6IFtdO1xuICB9XG4gIHN0YXRpYyBnZXRUaWNrc0ZvckludGVydmFsKHtcbiAgICBzdGFydCxcbiAgICBzdG9wLFxuICAgIGludGVydmFsLFxuICAgIGF2YWlsYWJsZVJhbmdlXG4gIH0pIHtcbiAgICBpZiAoIWludGVydmFsKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmIChpbnRlcnZhbCBpbnN0YW5jZW9mIFRpbWVJbnRlcnZhbCkge1xuICAgICAgY29uc3QgdGlja3MyID0gaW50ZXJ2YWwucmFuZ2UobmV3IERhdGUoc3RhcnQpLCBuZXcgRGF0ZShzdG9wKSk7XG4gICAgICBpZiAoaXNEZW5zZUludGVydmFsKHRpY2tzMi5sZW5ndGgsIGF2YWlsYWJsZVJhbmdlKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gdGlja3MyO1xuICAgIH1cbiAgICBjb25zdCBhYnNJbnRlcnZhbCA9IE1hdGguYWJzKGludGVydmFsKTtcbiAgICBpZiAoaXNEZW5zZUludGVydmFsKChzdG9wIC0gc3RhcnQpIC8gYWJzSW50ZXJ2YWwsIGF2YWlsYWJsZVJhbmdlKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByZXZlcnNlZEludGVydmFsID0gWy4uLlRpY2tJbnRlcnZhbHNdLnJldmVyc2UoKTtcbiAgICBjb25zdCB0aW1lSW50ZXJ2YWwgPSByZXZlcnNlZEludGVydmFsLmZpbmQoKHRpY2tJbnRlcnZhbCkgPT4gYWJzSW50ZXJ2YWwgJSB0aWNrSW50ZXJ2YWwuZHVyYXRpb24gPT09IDApO1xuICAgIGlmICh0aW1lSW50ZXJ2YWwpIHtcbiAgICAgIGNvbnN0IGkgPSB0aW1lSW50ZXJ2YWwudGltZUludGVydmFsLmV2ZXJ5KGFic0ludGVydmFsIC8gKHRpbWVJbnRlcnZhbC5kdXJhdGlvbiAvIHRpbWVJbnRlcnZhbC5zdGVwKSk7XG4gICAgICByZXR1cm4gaS5yYW5nZShuZXcgRGF0ZShzdGFydCksIG5ldyBEYXRlKHN0b3ApKTtcbiAgICB9XG4gICAgbGV0IGRhdGUgPSBuZXcgRGF0ZShzdGFydCk7XG4gICAgY29uc3Qgc3RvcERhdGUgPSBuZXcgRGF0ZShzdG9wKTtcbiAgICBjb25zdCB0aWNrcyA9IFtdO1xuICAgIHdoaWxlIChkYXRlIDw9IHN0b3BEYXRlKSB7XG4gICAgICB0aWNrcy5wdXNoKGRhdGUpO1xuICAgICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGUpO1xuICAgICAgZGF0ZS5zZXRNaWxsaXNlY29uZHMoZGF0ZS5nZXRNaWxsaXNlY29uZHMoKSArIGFic0ludGVydmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgdGltZSBmb3JtYXQgZnVuY3Rpb24gc3VpdGFibGUgZm9yIGRpc3BsYXlpbmcgdGljayB2YWx1ZXMuXG4gICAqIEBwYXJhbSBzcGVjaWZpZXIgSWYgdGhlIHNwZWNpZmllciBzdHJpbmcgaXMgcHJvdmlkZWQsIHRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG9cbiAgICogdGhlIHtAbGluayBUaW1lTG9jYWxlT2JqZWN0LmZvcm1hdH0gbWV0aG9kLlxuICAgKiBJZiBubyBzcGVjaWZpZXIgaXMgcHJvdmlkZWQsIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGRlZmF1bHQgdGltZSBmb3JtYXQgZnVuY3Rpb24uXG4gICAqL1xuICB0aWNrRm9ybWF0KHtcbiAgICB0aWNrcyxcbiAgICBkb21haW4sXG4gICAgc3BlY2lmaWVyLFxuICAgIGZvcm1hdE9mZnNldFxuICB9KSB7XG4gICAgcmV0dXJuIHNwZWNpZmllciA9PSBudWxsID8gZGVmYXVsdFRpbWVUaWNrRm9ybWF0KHRpY2tzLCBkb21haW4sIGZvcm1hdE9mZnNldCkgOiBidWlsZEZvcm1hdHRlcihzcGVjaWZpZXIpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuZG9tYWluIHx8IHRoaXMuZG9tYWluLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubmljZSkge1xuICAgICAgdGhpcy51cGRhdGVOaWNlRG9tYWluKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFeHRlbmRzIHRoZSBkb21haW4gc28gdGhhdCBpdCBzdGFydHMgYW5kIGVuZHMgb24gbmljZSByb3VuZCB2YWx1ZXMuXG4gICAqIFRoaXMgbWV0aG9kIHR5cGljYWxseSBtb2RpZmllcyB0aGUgc2NhbGXigJlzIGRvbWFpbiwgYW5kIG1heSBvbmx5IGV4dGVuZCB0aGUgYm91bmRzIHRvIHRoZSBuZWFyZXN0IHJvdW5kIHZhbHVlLlxuICAgKi9cbiAgdXBkYXRlTmljZURvbWFpbigpIHtcbiAgICBjb25zdCBtYXhBdHRlbXB0cyA9IDQ7XG4gICAgbGV0IFtkMCwgZDFdID0gdGhpcy5kb21haW47XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhBdHRlbXB0czsgaSsrKSB7XG4gICAgICB0aGlzLnVwZGF0ZU5pY2VEb21haW5JdGVyYXRpb24oZDAsIGQxKTtcbiAgICAgIGNvbnN0IFtuMCwgbjFdID0gdGhpcy5uaWNlRG9tYWluO1xuICAgICAgaWYgKGRhdGVUb051bWJlcihkMCkgPT09IGRhdGVUb051bWJlcihuMCkgJiYgZGF0ZVRvTnVtYmVyKGQxKSA9PT0gZGF0ZVRvTnVtYmVyKG4xKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGQwID0gbjA7XG4gICAgICBkMSA9IG4xO1xuICAgIH1cbiAgfVxuICB1cGRhdGVOaWNlRG9tYWluSXRlcmF0aW9uKGQwLCBkMSkge1xuICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5taW4oZGF0ZVRvTnVtYmVyKGQwKSwgZGF0ZVRvTnVtYmVyKGQxKSk7XG4gICAgY29uc3Qgc3RvcCA9IE1hdGgubWF4KGRhdGVUb051bWJlcihkMCksIGRhdGVUb051bWJlcihkMSkpO1xuICAgIGNvbnN0IGlzUmV2ZXJzZWQgPSBkMCA+IGQxO1xuICAgIGNvbnN0IHsgaW50ZXJ2YWwgfSA9IHRoaXM7XG4gICAgbGV0IGk7XG4gICAgaWYgKGludGVydmFsIGluc3RhbmNlb2YgVGltZUludGVydmFsKSB7XG4gICAgICBpID0gaW50ZXJ2YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRpY2tDb3VudCA9IHR5cGVvZiBpbnRlcnZhbCA9PT0gXCJudW1iZXJcIiA/IChzdG9wIC0gc3RhcnQpIC8gTWF0aC5tYXgoaW50ZXJ2YWwsIDEpIDogdGhpcy50aWNrQ291bnQ7XG4gICAgICBpID0gZ2V0VGlja0ludGVydmFsKHN0YXJ0LCBzdG9wLCB0aWNrQ291bnQsIHRoaXMubWluVGlja0NvdW50LCB0aGlzLm1heFRpY2tDb3VudCk7XG4gICAgfVxuICAgIGlmIChpKSB7XG4gICAgICBjb25zdCBpbnRlcnZhbFJhbmdlID0gaS5yYW5nZShuZXcgRGF0ZShzdGFydCksIG5ldyBEYXRlKHN0b3ApLCB0cnVlKTtcbiAgICAgIGNvbnN0IGRvbWFpbiA9IGlzUmV2ZXJzZWQgPyBbLi4uaW50ZXJ2YWxSYW5nZV0ucmV2ZXJzZSgpIDogaW50ZXJ2YWxSYW5nZTtcbiAgICAgIGNvbnN0IG4wID0gZG9tYWluWzBdO1xuICAgICAgY29uc3QgbjEgPSBkb21haW4uYXQoLTEpO1xuICAgICAgdGhpcy5uaWNlRG9tYWluID0gW24wLCBuMV07XG4gICAgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2FsZS9vcmRpbmFsVGltZVNjYWxlLnRzXG5mdW5jdGlvbiBjb21wYXJlTnVtYmVycyhhLCBiKSB7XG4gIHJldHVybiBhIC0gYjtcbn1cbnZhciBfT3JkaW5hbFRpbWVTY2FsZSA9IGNsYXNzIF9PcmRpbmFsVGltZVNjYWxlIGV4dGVuZHMgQmFuZFNjYWxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSBcIm9yZGluYWwtdGltZVwiO1xuICAgIHRoaXMudGlja0NvdW50ID0gQ29udGludW91c1NjYWxlLmRlZmF1bHRUaWNrQ291bnQ7XG4gICAgdGhpcy5taW5UaWNrQ291bnQgPSAwO1xuICAgIHRoaXMubWF4VGlja0NvdW50ID0gSW5maW5pdHk7XG4gICAgdGhpcy5pbnRlcnZhbCA9IHZvaWQgMDtcbiAgICB0aGlzLl9kb21haW4gPSBbXTtcbiAgICB0aGlzLnRpbWVzdGFtcHMgPSBbXTtcbiAgICB0aGlzLnNvcnRlZFRpbWVzdGFtcHMgPSBbXTtcbiAgICB0aGlzLnZpc2libGVSYW5nZSA9IFswLCAxXTtcbiAgfVxuICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBfT3JkaW5hbFRpbWVTY2FsZTtcbiAgfVxuICBzZXRWaXNpYmxlUmFuZ2UodmlzaWJsZVJhbmdlKSB7XG4gICAgdGhpcy52aXNpYmxlUmFuZ2UgPSB2aXNpYmxlUmFuZ2U7XG4gIH1cbiAgc2V0IGRvbWFpbih2YWx1ZXMpIHtcbiAgICB0aGlzLmludmFsaWQgPSB0cnVlO1xuICAgIGlmICh2YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLl9kb21haW4gPSBbXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZG9tYWluID0gdmFsdWVzO1xuICAgIHRoaXMudGltZXN0YW1wcyA9IHVuaXF1ZSh2YWx1ZXMubWFwKGRhdGVUb051bWJlcikpO1xuICAgIHRoaXMuc29ydGVkVGltZXN0YW1wcyA9IHRoaXMudGltZXN0YW1wcy5zbGljZSgpLnNvcnQoY29tcGFyZU51bWJlcnMpO1xuICB9XG4gIGdldCBkb21haW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RvbWFpbjtcbiAgfVxuICB0aWNrcygpIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICBjb25zdCBbdDAsIHQxXSA9IFt0aGlzLnRpbWVzdGFtcHNbMF0sIHRoaXMudGltZXN0YW1wcy5hdCgtMSldO1xuICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5taW4odDAsIHQxKTtcbiAgICBjb25zdCBzdG9wID0gTWF0aC5tYXgodDAsIHQxKTtcbiAgICBjb25zdCBpc1JldmVyc2VkID0gdDAgPiB0MTtcbiAgICBsZXQgdGlja3M7XG4gICAgaWYgKHRoaXMuaW50ZXJ2YWwgPT0gbnVsbCkge1xuICAgICAgdGlja3MgPSB0aGlzLmdldERlZmF1bHRUaWNrcyh0aGlzLm1heFRpY2tDb3VudCwgaXNSZXZlcnNlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IFtyMCwgcjFdID0gdGhpcy5yYW5nZTtcbiAgICAgIGNvbnN0IGF2YWlsYWJsZVJhbmdlID0gTWF0aC5hYnMocjEgLSByMCk7XG4gICAgICB0aWNrcyA9IFRpbWVTY2FsZS5nZXRUaWNrc0ZvckludGVydmFsKHsgc3RhcnQsIHN0b3AsIGludGVydmFsOiB0aGlzLmludGVydmFsLCBhdmFpbGFibGVSYW5nZSB9KSA/PyBbXTtcbiAgICB9XG4gICAgY29uc3QgdGlja1Bvc2l0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgcmV0dXJuIHRpY2tzLmZpbHRlcigodGljaykgPT4ge1xuICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLmNvbnZlcnQodGljayk7XG4gICAgICBpZiAoaXNOYU4ocG9zaXRpb24pIHx8IHRpY2tQb3NpdGlvbnMuaGFzKHBvc2l0aW9uKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aWNrUG9zaXRpb25zLmFkZChwb3NpdGlvbik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgfVxuICBnZXREZWZhdWx0VGlja3MobWF4VGlja0NvdW50LCBpc1JldmVyc2VkKSB7XG4gICAgY29uc3QgdGlja3MgPSBbXTtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMudGltZXN0YW1wcy5sZW5ndGg7XG4gICAgY29uc3QgdGlja0V2ZXJ5ID0gTWF0aC5jZWlsKGNvdW50ICogKHRoaXMudmlzaWJsZVJhbmdlWzFdIC0gdGhpcy52aXNpYmxlUmFuZ2VbMF0pIC8gbWF4VGlja0NvdW50KTtcbiAgICBjb25zdCB0aWNrT2Zmc2V0ID0gTWF0aC5mbG9vcih0aWNrRXZlcnkgLyAyKTtcbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgdmFsdWVdIG9mIHRoaXMudGltZXN0YW1wcy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmICh0aWNrRXZlcnkgPiAwICYmIChpbmRleCArIHRpY2tPZmZzZXQpICUgdGlja0V2ZXJ5KVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChpc1JldmVyc2VkKSB7XG4gICAgICAgIHRpY2tzLnB1c2gobmV3IERhdGUodGhpcy50aW1lc3RhbXBzW2NvdW50IC0gaW5kZXggLSAxXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlja3MucHVzaChuZXcgRGF0ZSh2YWx1ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGlja3M7XG4gIH1cbiAgY29udmVydChkKSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgY29uc3QgbiA9IE51bWJlcihkKTtcbiAgICBpZiAobiA8IHRoaXMuc29ydGVkVGltZXN0YW1wc1swXSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgbGV0IGkgPSB0aGlzLmZpbmRJbnRlcnZhbChuKTtcbiAgICBpZiAodGhpcy50aW1lc3RhbXBzWzBdICE9PSB0aGlzLnNvcnRlZFRpbWVzdGFtcHNbMF0pIHtcbiAgICAgIGkgPSB0aGlzLnRpbWVzdGFtcHMubGVuZ3RoIC0gaSAtIDE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm9yZGluYWxSYW5nZVtpXSA/PyBOYU47XG4gIH1cbiAgZmluZEludGVydmFsKHRhcmdldCkge1xuICAgIGNvbnN0IHsgc29ydGVkVGltZXN0YW1wcyB9ID0gdGhpcztcbiAgICBsZXQgbG93ID0gMDtcbiAgICBsZXQgaGlnaCA9IHNvcnRlZFRpbWVzdGFtcHMubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoc29ydGVkVGltZXN0YW1wc1ttaWRdID09PSB0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIG1pZDtcbiAgICAgIH0gZWxzZSBpZiAoc29ydGVkVGltZXN0YW1wc1ttaWRdIDwgdGFyZ2V0KSB7XG4gICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHRpbWUgZm9ybWF0IGZ1bmN0aW9uIHN1aXRhYmxlIGZvciBkaXNwbGF5aW5nIHRpY2sgdmFsdWVzLlxuICAgKiBAcGFyYW0gc3BlY2lmaWVyIElmIHRoZSBzcGVjaWZpZXIgc3RyaW5nIGlzIHByb3ZpZGVkLCB0aGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvXG4gICAqIHRoZSB7QGxpbmsgVGltZUxvY2FsZU9iamVjdC5mb3JtYXR9IG1ldGhvZC5cbiAgICogSWYgbm8gc3BlY2lmaWVyIGlzIHByb3ZpZGVkLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBkZWZhdWx0IHRpbWUgZm9ybWF0IGZ1bmN0aW9uLlxuICAgKi9cbiAgdGlja0Zvcm1hdCh7XG4gICAgdGlja3MsXG4gICAgZG9tYWluLFxuICAgIHNwZWNpZmllclxuICB9KSB7XG4gICAgcmV0dXJuIHNwZWNpZmllciA9PSBudWxsID8gZGVmYXVsdFRpbWVUaWNrRm9ybWF0KHRpY2tzLCBkb21haW4pIDogYnVpbGRGb3JtYXR0ZXIoc3BlY2lmaWVyKTtcbiAgfVxuICBpbnZlcnQocG9zaXRpb24pIHtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMub3JkaW5hbFJhbmdlLmZpbmRJbmRleCgocCkgPT4gcG9zaXRpb24gPD0gcCk7XG4gICAgcmV0dXJuIHRoaXMuZG9tYWluW2luZGV4XTtcbiAgfVxuICBpbnZlcnROZWFyZXN0KHkpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoc3VwZXIuaW52ZXJ0TmVhcmVzdCh5KSk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9PcmRpbmFsVGltZVNjYWxlLnByb3RvdHlwZSwgXCJ0aWNrQ291bnRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9PcmRpbmFsVGltZVNjYWxlLnByb3RvdHlwZSwgXCJtaW5UaWNrQ291bnRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9PcmRpbmFsVGltZVNjYWxlLnByb3RvdHlwZSwgXCJtYXhUaWNrQ291bnRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIF9PcmRpbmFsVGltZVNjYWxlLnByb3RvdHlwZSwgXCJpbnRlcnZhbFwiLCAyKTtcbnZhciBPcmRpbmFsVGltZVNjYWxlID0gX09yZGluYWxUaW1lU2NhbGU7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvY29tcGFyZS50c1xuZnVuY3Rpb24gYXNjZW5kaW5nU3RyaW5nTnVtYmVyVW5kZWZpbmVkKGEsIGIpIHtcbiAgaWYgKHR5cGVvZiBhID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBiID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBiID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGEubG9jYWxlQ29tcGFyZShiKTtcbiAgfSBlbHNlIGlmIChhID09IG51bGwgJiYgYiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoYSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGIgPT0gbnVsbCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiBTdHJpbmcoYSkubG9jYWxlQ29tcGFyZShTdHJpbmcoYikpO1xufVxuZnVuY3Rpb24gdG9MaXRlcmFsKHYpIHtcbiAgcmV0dXJuIHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCIgPyB2KCkgOiB2O1xufVxuZnVuY3Rpb24gY29tcG91bmRBc2NlbmRpbmcoYSwgYiwgY29tcGFyYXRvcikge1xuICBmb3IgKGNvbnN0IGlkeCBpbiBhKSB7XG4gICAgY29uc3QgZGlmZjIgPSBjb21wYXJhdG9yKHRvTGl0ZXJhbChhW2lkeF0pLCB0b0xpdGVyYWwoYltpZHhdKSk7XG4gICAgaWYgKGRpZmYyICE9PSAwKSB7XG4gICAgICByZXR1cm4gZGlmZjI7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9ncm91cC50c1xudmFyIF9Hcm91cCA9IGNsYXNzIF9Hcm91cCBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgc3VwZXIoeyBpc1ZpcnR1YWw6IG9wdHM/LmlzVmlydHVhbCwgbmFtZTogb3B0cz8ubmFtZSB9KTtcbiAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgIHRoaXMub3BhY2l0eSA9IDE7XG4gICAgdGhpcy5sYXN0QkJveCA9IHZvaWQgMDtcbiAgICBjb25zdCB7IHpJbmRleCwgekluZGV4U3ViT3JkZXIgfSA9IG9wdHMgPz8ge307XG4gICAgdGhpcy5pc0NvbnRhaW5lck5vZGUgPSB0cnVlO1xuICAgIGlmICh6SW5kZXggIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy56SW5kZXggPSB6SW5kZXg7XG4gICAgfVxuICAgIGlmICh6SW5kZXhTdWJPcmRlciAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLnpJbmRleFN1Yk9yZGVyID0gekluZGV4U3ViT3JkZXI7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIF9Hcm91cDtcbiAgfVxuICBvblpJbmRleENoYW5nZSgpIHtcbiAgICBzdXBlci5vblpJbmRleENoYW5nZSgpO1xuICAgIGlmICh0aGlzLmxheWVyKSB7XG4gICAgICB0aGlzLl9sYXllck1hbmFnZXI/Lm1vdmVMYXllcih0aGlzLmxheWVyLCB0aGlzLnpJbmRleCwgdGhpcy56SW5kZXhTdWJPcmRlcik7XG4gICAgfVxuICB9XG4gIGlzTGF5ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXIgIT0gbnVsbDtcbiAgfVxuICBfc2V0TGF5ZXJNYW5hZ2VyKGxheWVyc01hbmFnZXIpIHtcbiAgICBpZiAodGhpcy5fbGF5ZXJNYW5hZ2VyICYmIHRoaXMubGF5ZXIpIHtcbiAgICAgIHRoaXMuX2xheWVyTWFuYWdlci5yZW1vdmVMYXllcih0aGlzLmxheWVyKTtcbiAgICAgIHRoaXMubGF5ZXIgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmICh0aGlzLmxheWVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSB1bmFibGUgdG8gZGVyZWdpc3RlciBzY2VuZSByZW5kZXJpbmcgbGF5ZXIhXCIpO1xuICAgIH1cbiAgICBzdXBlci5fc2V0TGF5ZXJNYW5hZ2VyKGxheWVyc01hbmFnZXIpO1xuICB9XG4gIGluaXRpYWxpc2VMYXllcigpIHtcbiAgICBpZiAodGhpcy5sYXllcilcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIXRoaXMuX2xheWVyTWFuYWdlciB8fCB0aGlzLm9wdHM/LmxheWVyICE9PSB0cnVlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMubGF5ZXIgPSB0aGlzLl9sYXllck1hbmFnZXIuYWRkTGF5ZXIoe1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgekluZGV4OiB0aGlzLnpJbmRleCxcbiAgICAgIHpJbmRleFN1Yk9yZGVyOiB0aGlzLnpJbmRleFN1Yk9yZGVyLFxuICAgICAgZ2V0Q29tcHV0ZWRPcGFjaXR5OiAoKSA9PiB0aGlzLmdldENvbXB1dGVkT3BhY2l0eSgpLFxuICAgICAgZ2V0VmlzaWJpbGl0eTogKCkgPT4gdGhpcy5nZXRWaXNpYmlsaXR5KClcbiAgICB9KTtcbiAgfVxuICBnZXRDb21wdXRlZE9wYWNpdHkoKSB7XG4gICAgbGV0IG9wYWNpdHkgPSAxO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLnRyYXZlcnNlVXAoKSkge1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBfR3JvdXApIHtcbiAgICAgICAgb3BhY2l0eSAqPSBub2RlLm9wYWNpdHk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcGFjaXR5O1xuICB9XG4gIGdldFZpc2liaWxpdHkoKSB7XG4gICAgZm9yIChjb25zdCBub2RlIG9mIHRoaXMudHJhdmVyc2VVcCgpKSB7XG4gICAgICBpZiAoIW5vZGUudmlzaWJsZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIG9uVmlzaWJsZUNoYW5nZSgpIHtcbiAgICBpZiAodGhpcy5sYXllcikge1xuICAgICAgdGhpcy5sYXllci5lbmFibGVkID0gdGhpcy52aXNpYmxlO1xuICAgIH1cbiAgfVxuICBtYXJrRGlydHkoc291cmNlLCB0eXBlID0gMSAvKiBUUklWSUFMICovKSB7XG4gICAgaWYgKHRoaXMuaXNWaXJ0dWFsKSB7XG4gICAgICBzdXBlci5tYXJrRGlydHkoc291cmNlLCB0eXBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHBhcmVudFR5cGUgPSB0eXBlO1xuICAgIGlmICh0eXBlIDwgMiAvKiBNSU5PUiAqLyB8fCB0aGlzLmxheWVyICE9IG51bGwpIHtcbiAgICAgIHBhcmVudFR5cGUgPSAxIC8qIFRSSVZJQUwgKi87XG4gICAgfVxuICAgIHN1cGVyLm1hcmtEaXJ0eShzb3VyY2UsIHR5cGUsIHBhcmVudFR5cGUpO1xuICB9XG4gIC8vIFdlIGNvbnNpZGVyIGEgZ3JvdXAgdG8gYmUgYm91bmRsZXNzLCB0aHVzIGFueSBwb2ludCBiZWxvbmdzIHRvIGl0LlxuICBjb250YWluc1BvaW50KF94LCBfeSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIHRoaXMuY29tcHV0ZVRyYW5zZm9ybU1hdHJpeCgpO1xuICAgIHJldHVybiBfR3JvdXAuY29tcHV0ZUJCb3godGhpcy5jaGlsZHJlbik7XG4gIH1cbiAgY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRCQm94KCk7XG4gIH1cbiAgY29tcHV0ZVRyYW5zZm9ybWVkUmVnaW9uQkJveCgpIHtcbiAgICBpZiAodGhpcy5jbGlwUmVjdCkge1xuICAgICAgdGhpcy5jb21wdXRlVHJhbnNmb3JtTWF0cml4KCk7XG4gICAgICByZXR1cm4gdGhpcy5tYXRyaXgudHJhbnNmb3JtQkJveCh0aGlzLmNsaXBSZWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpO1xuICB9XG4gIHByZVJlbmRlcigpIHtcbiAgICBjb25zdCBjb3VudHMgPSBzdXBlci5wcmVSZW5kZXIoKTtcbiAgICBjb3VudHMuZ3JvdXBzICs9IDE7XG4gICAgY291bnRzLm5vbkdyb3VwcyAtPSAxO1xuICAgIGlmICh0aGlzLm9wdHM/LmxheWVyICE9PSB0cnVlIHx8IHRoaXMubGF5ZXIgIT0gbnVsbClcbiAgICAgIHJldHVybiBjb3VudHM7XG4gICAgaWYgKGNvdW50cy5ub25Hcm91cHMgPiAwKSB7XG4gICAgICB0aGlzLmluaXRpYWxpc2VMYXllcigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRzPy5ub25FbXB0eUNoaWxkRGVyaXZlZFpJbmRleCAmJiBjb3VudHMubm9uR3JvdXBzID4gMCkge1xuICAgICAgdGhpcy5kZXJpdmVaSW5kZXhGcm9tQ2hpbGRyZW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50cztcbiAgfVxuICBkZXJpdmVaSW5kZXhGcm9tQ2hpbGRyZW4oKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLmZpbHRlcigoYykgPT4gYy5fY2hpbGROb2RlQ291bnRzLm5vbkdyb3VwcyA+IDApO1xuICAgIHRoaXMuc29ydENoaWxkcmVuKGNoaWxkcmVuKTtcbiAgICBjb25zdCBsYXN0Q2hpbGQgPSBjaGlsZHJlbi5hdCgtMSk7XG4gICAgdGhpcy56SW5kZXggPSBsYXN0Q2hpbGQ/LnpJbmRleCA/PyAtSW5maW5pdHk7XG4gICAgdGhpcy56SW5kZXhTdWJPcmRlciA9IGxhc3RDaGlsZD8uekluZGV4U3ViT3JkZXI7XG4gIH1cbiAgcmVuZGVyKHJlbmRlckN0eCkge1xuICAgIGNvbnN0IHsgb3B0czogeyBuYW1lID0gdm9pZCAwIH0gPSB7fSwgX2RlYnVnOiBkZWJ1ZzMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBkaXJ0eSwgZGlydHlaSW5kZXgsIGxheWVyLCBjaGlsZHJlbiwgY2xpcFJlY3QsIGRpcnR5VHJhbnNmb3JtIH0gPSB0aGlzO1xuICAgIGxldCB7IGN0eCwgZm9yY2VSZW5kZXIsIGNsaXBCQm94IH0gPSByZW5kZXJDdHg7XG4gICAgY29uc3QgeyByZXNpemVkLCBzdGF0cyB9ID0gcmVuZGVyQ3R4O1xuICAgIGNvbnN0IGNhbnZhc0N0eFRyYW5zZm9ybSA9IGN0eC5nZXRUcmFuc2Zvcm0oKTtcbiAgICBjb25zdCBpc0RpcnR5ID0gZGlydHkgPj0gMiAvKiBNSU5PUiAqLyB8fCBkaXJ0eVpJbmRleCB8fCByZXNpemVkO1xuICAgIGxldCBpc0NoaWxkRGlydHkgPSBpc0RpcnR5O1xuICAgIGxldCBpc0NoaWxkTGF5ZXJEaXJ0eSA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4pIHtcbiAgICAgIGlzQ2hpbGREaXJ0eSB8fCAoaXNDaGlsZERpcnR5ID0gY2hpbGQubGF5ZXJNYW5hZ2VyID09IG51bGwgJiYgY2hpbGQuZGlydHkgPj0gMSAvKiBUUklWSUFMICovKTtcbiAgICAgIGlzQ2hpbGRMYXllckRpcnR5IHx8IChpc0NoaWxkTGF5ZXJEaXJ0eSA9IGNoaWxkLmxheWVyTWFuYWdlciAhPSBudWxsICYmIGNoaWxkLmRpcnR5ID49IDEgLyogVFJJVklBTCAqLyk7XG4gICAgICBpZiAoaXNDaGlsZERpcnR5KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmFtZSkge1xuICAgICAgZGVidWczPy4oeyBuYW1lLCBncm91cDogdGhpcywgaXNEaXJ0eSwgaXNDaGlsZERpcnR5LCBkaXJ0eVRyYW5zZm9ybSwgcmVuZGVyQ3R4LCBmb3JjZVJlbmRlciB9KTtcbiAgICB9XG4gICAgaWYgKGRpcnR5VHJhbnNmb3JtKSB7XG4gICAgICBmb3JjZVJlbmRlciA9IFwiZGlydHlUcmFuc2Zvcm1cIjtcbiAgICB9IGVsc2UgaWYgKGxheWVyKSB7XG4gICAgICBjb25zdCBjdXJyZW50QkJveCA9IHRoaXMuZ2V0QkJveCgpO1xuICAgICAgaWYgKHRoaXMubGFzdEJCb3ggPT09IHZvaWQgMCB8fCAhdGhpcy5sYXN0QkJveC5lcXVhbHMoY3VycmVudEJCb3gpKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyID0gXCJkaXJ0eVRyYW5zZm9ybVwiO1xuICAgICAgICB0aGlzLmxhc3RCQm94ID0gY3VycmVudEJCb3g7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghaXNEaXJ0eSAmJiAhaXNDaGlsZERpcnR5ICYmICFpc0NoaWxkTGF5ZXJEaXJ0eSAmJiAhZm9yY2VSZW5kZXIpIHtcbiAgICAgIGlmIChuYW1lICYmIHN0YXRzKSB7XG4gICAgICAgIGRlYnVnMz8uKHsgbmFtZSwgcmVzdWx0OiBcInNraXBwaW5nXCIsIHJlbmRlckN0eCwgY291bnRzOiB0aGlzLm5vZGVDb3VudCwgZ3JvdXA6IHRoaXMgfSk7XG4gICAgICB9XG4gICAgICBpZiAobGF5ZXIgJiYgc3RhdHMpIHtcbiAgICAgICAgc3RhdHMubGF5ZXJzU2tpcHBlZCsrO1xuICAgICAgICBzdGF0cy5ub2Rlc1NraXBwZWQgKz0gdGhpcy5ub2RlQ291bnQuY291bnQ7XG4gICAgICB9XG4gICAgICB0aGlzLm1hcmtDbGVhbih7IHJlY3Vyc2l2ZTogZmFsc2UgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGdyb3VwVmlzaWJsZSA9IHRoaXMudmlzaWJsZTtcbiAgICBpZiAobGF5ZXIpIHtcbiAgICAgIGN0eCA9IGxheWVyLmNvbnRleHQ7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnNldFRyYW5zZm9ybShsYXllci5waXhlbFJhdGlvLCAwLCAwLCBsYXllci5waXhlbFJhdGlvLCAwLCAwKTtcbiAgICAgIGlmIChmb3JjZVJlbmRlciAhPT0gXCJkaXJ0eVRyYW5zZm9ybVwiKSB7XG4gICAgICAgIGZvcmNlUmVuZGVyID0gaXNDaGlsZERpcnR5IHx8IGRpcnR5WkluZGV4O1xuICAgICAgfVxuICAgICAgaWYgKGZvcmNlUmVuZGVyKVxuICAgICAgICBsYXllci5jbGVhcigpO1xuICAgICAgaWYgKGNsaXBCQm94KSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgeCwgeSB9ID0gY2xpcEJCb3g7XG4gICAgICAgIGRlYnVnMz8uKCgpID0+ICh7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBjbGlwQkJveCxcbiAgICAgICAgICBjdHhUcmFuc2Zvcm06IGN0eC5nZXRUcmFuc2Zvcm0oKSxcbiAgICAgICAgICByZW5kZXJDdHgsXG4gICAgICAgICAgZ3JvdXA6IHRoaXNcbiAgICAgICAgfSkpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICBjdHguY2xpcCgpO1xuICAgICAgfVxuICAgICAgY3R4LnNldFRyYW5zZm9ybShjYW52YXNDdHhUcmFuc2Zvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgKj0gdGhpcy5vcGFjaXR5O1xuICAgIH1cbiAgICBjb25zdCBtYXRyaXggPSB0aGlzLnRyYW5zZm9ybVJlbmRlckNvbnRleHQocmVuZGVyQ3R4LCBjdHgpO1xuICAgIGlmIChjbGlwUmVjdCkge1xuICAgICAgY29uc3QgeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH0gPSBjbGlwUmVjdDtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBkZWJ1ZzM/LigoKSA9PiAoeyBuYW1lLCBjbGlwUmVjdCwgY3R4VHJhbnNmb3JtOiBjdHguZ2V0VHJhbnNmb3JtKCksIHJlbmRlckN0eCwgZ3JvdXA6IHRoaXMgfSkpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHguY2xpcCgpO1xuICAgICAgY2xpcEJCb3ggPSBtYXRyaXgudHJhbnNmb3JtQkJveChjbGlwUmVjdCk7XG4gICAgfVxuICAgIGNvbnN0IGhhc1ZpcnR1YWxDaGlsZHJlbiA9IHRoaXMuaGFzVmlydHVhbENoaWxkcmVuKCk7XG4gICAgaWYgKGRpcnR5WkluZGV4KSB7XG4gICAgICB0aGlzLnNvcnRDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgICBpZiAoZm9yY2VSZW5kZXIgIT09IFwiZGlydHlUcmFuc2Zvcm1cIilcbiAgICAgICAgZm9yY2VSZW5kZXIgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoaGFzVmlydHVhbENoaWxkcmVuKSB7XG4gICAgICB0aGlzLnNvcnRDaGlsZHJlbihjaGlsZHJlbik7XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlckNvbnRleHRDaGFuZ2VkID0gZm9yY2VSZW5kZXIgIT09IHJlbmRlckN0eC5mb3JjZVJlbmRlciB8fCBjbGlwQkJveCAhPT0gcmVuZGVyQ3R4LmNsaXBCQm94IHx8IGN0eCAhPT0gcmVuZGVyQ3R4LmN0eDtcbiAgICBjb25zdCBjaGlsZFJlbmRlckNvbnRleHQgPSByZW5kZXJDb250ZXh0Q2hhbmdlZCA/IHsgLi4ucmVuZGVyQ3R4LCBjdHgsIGZvcmNlUmVuZGVyLCBjbGlwQkJveCB9IDogcmVuZGVyQ3R4O1xuICAgIGxldCBza2lwcGVkID0gMDtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICBpZiAoIWNoaWxkLnZpc2libGUgfHwgIWdyb3VwVmlzaWJsZSkge1xuICAgICAgICBjaGlsZC5tYXJrQ2xlYW4oKTtcbiAgICAgICAgaWYgKHN0YXRzKVxuICAgICAgICAgIHNraXBwZWQgKz0gY2hpbGQubm9kZUNvdW50LmNvdW50O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghZm9yY2VSZW5kZXIgJiYgY2hpbGQuZGlydHkgPT09IDAgLyogTk9ORSAqLykge1xuICAgICAgICBpZiAoc3RhdHMpXG4gICAgICAgICAgc2tpcHBlZCArPSBjaGlsZC5ub2RlQ291bnQuY291bnQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGNoaWxkLnJlbmRlcihjaGlsZFJlbmRlckNvbnRleHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgaWYgKHN0YXRzKVxuICAgICAgc3RhdHMubm9kZXNTa2lwcGVkICs9IHNraXBwZWQ7XG4gICAgc3VwZXIucmVuZGVyKHJlbmRlckN0eCk7XG4gICAgaWYgKGNsaXBSZWN0KSB7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICBpZiAoaGFzVmlydHVhbENoaWxkcmVuKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMudmlydHVhbENoaWxkcmVuKSB7XG4gICAgICAgIGNoaWxkLm1hcmtDbGVhbih7IHJlY3Vyc2l2ZTogXCJ2aXJ0dWFsXCIgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXllcikge1xuICAgICAgaWYgKHN0YXRzKVxuICAgICAgICBzdGF0cy5sYXllcnNSZW5kZXJlZCsrO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGlmIChmb3JjZVJlbmRlcilcbiAgICAgICAgbGF5ZXIuc25hcHNob3QoKTtcbiAgICAgIGxheWVyLmNvbnRleHQudmVyaWZ5RGVwdGhaZXJvPy4oKTtcbiAgICB9XG4gICAgaWYgKG5hbWUgJiYgc3RhdHMpIHtcbiAgICAgIGRlYnVnMz8uKHsgbmFtZSwgcmVzdWx0OiBcInJlbmRlcmVkXCIsIHNraXBwZWQsIHJlbmRlckN0eCwgY291bnRzOiB0aGlzLm5vZGVDb3VudCwgZ3JvdXA6IHRoaXMgfSk7XG4gICAgfVxuICB9XG4gIHNvcnRDaGlsZHJlbihjaGlsZHJlbikge1xuICAgIHRoaXMuZGlydHlaSW5kZXggPSBmYWxzZTtcbiAgICBjaGlsZHJlbi5zb3J0KFxuICAgICAgKGEsIGIpID0+IGNvbXBvdW5kQXNjZW5kaW5nKFxuICAgICAgICBbYS56SW5kZXgsIC4uLmEuekluZGV4U3ViT3JkZXIgPz8gW3ZvaWQgMCwgdm9pZCAwXSwgYS5zZXJpYWxOdW1iZXJdLFxuICAgICAgICBbYi56SW5kZXgsIC4uLmIuekluZGV4U3ViT3JkZXIgPz8gW3ZvaWQgMCwgdm9pZCAwXSwgYi5zZXJpYWxOdW1iZXJdLFxuICAgICAgICBhc2NlbmRpbmdTdHJpbmdOdW1iZXJVbmRlZmluZWRcbiAgICAgIClcbiAgICApO1xuICB9XG4gIHN0YXRpYyBjb21wdXRlQkJveChub2Rlcywgb3B0cykge1xuICAgIGxldCBsZWZ0ID0gSW5maW5pdHk7XG4gICAgbGV0IHJpZ2h0ID0gLUluZmluaXR5O1xuICAgIGxldCB0b3AgPSBJbmZpbml0eTtcbiAgICBsZXQgYm90dG9tID0gLUluZmluaXR5O1xuICAgIGNvbnN0IHNraXBJbnZpc2libGUgPSBvcHRzPy5za2lwSW52aXNpYmxlID8/IHRydWU7XG4gICAgZm9yIChjb25zdCBuIG9mIG5vZGVzKSB7XG4gICAgICBpZiAoc2tpcEludmlzaWJsZSAmJiAhbi52aXNpYmxlKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IGJib3ggPSBuLmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKTtcbiAgICAgIGlmICghYmJveClcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IGJib3g7XG4gICAgICBpZiAoeCA8IGxlZnQpIHtcbiAgICAgICAgbGVmdCA9IHg7XG4gICAgICB9XG4gICAgICBpZiAoeSA8IHRvcCkge1xuICAgICAgICB0b3AgPSB5O1xuICAgICAgfVxuICAgICAgaWYgKHggKyB3aWR0aCA+IHJpZ2h0KSB7XG4gICAgICAgIHJpZ2h0ID0geCArIHdpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKHkgKyBoZWlnaHQgPiBib3R0b20pIHtcbiAgICAgICAgYm90dG9tID0geSArIGhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCQm94KGxlZnQsIHRvcCwgcmlnaHQgLSBsZWZ0LCBib3R0b20gLSB0b3ApO1xuICB9XG4gIC8qKlxuICAgKiBUcmFuc2Zvcm1zIGJib3ggZ2l2ZW4gaW4gdGhlIGNhbnZhcyBjb29yZGluYXRlIHNwYWNlIHRvIGJib3ggaW4gdGhpcyBncm91cCdzIGNvb3JkaW5hdGUgc3BhY2UgYW5kXG4gICAqIHNldHMgdGhpcyBncm91cCdzIGNsaXBSZWN0IHRvIHRoZSB0cmFuc2Zvcm1lZCBiYm94LlxuICAgKiBAcGFyYW0gYmJveCBjbGlwUmVjdCBiYm94IGluIHRoZSBjYW52YXMgY29vcmRpbmF0ZSBzcGFjZS5cbiAgICovXG4gIHNldENsaXBSZWN0SW5Hcm91cENvb3JkaW5hdGVTcGFjZShiYm94KSB7XG4gICAgdGhpcy5jbGlwUmVjdCA9IGJib3ggPyB0aGlzLnRyYW5zZm9ybUJCb3goYmJveCkgOiB2b2lkIDA7XG4gIH1cbn07XG5fR3JvdXAuY2xhc3NOYW1lID0gXCJHcm91cFwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oe1xuICAgIHJlZHJhdzogMyAvKiBNQUpPUiAqLyxcbiAgICBjb252ZXJ0b3I6ICh2KSA9PiBjbGFtcCgwLCB2LCAxKVxuICB9KVxuXSwgX0dyb3VwLnByb3RvdHlwZSwgXCJvcGFjaXR5XCIsIDIpO1xudmFyIEdyb3VwID0gX0dyb3VwO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2RvbS50c1xudmFyIHZlcmlmaWVkR2xvYmFscyA9IHt9O1xuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgdmVyaWZpZWRHbG9iYWxzLndpbmRvdyA9IHdpbmRvdztcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICB2ZXJpZmllZEdsb2JhbHMud2luZG93ID0gZ2xvYmFsLndpbmRvdztcbn1cbmlmICh0eXBlb2YgZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgdmVyaWZpZWRHbG9iYWxzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgdmVyaWZpZWRHbG9iYWxzLmRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQocHJvcGVydHlOYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0eU5hbWUgPyB2ZXJpZmllZEdsb2JhbHMuZG9jdW1lbnQ/Lltwcm9wZXJ0eU5hbWVdIDogdmVyaWZpZWRHbG9iYWxzLmRvY3VtZW50O1xufVxuZnVuY3Rpb24gZ2V0V2luZG93KHByb3BlcnR5TmFtZSkge1xuICByZXR1cm4gcHJvcGVydHlOYW1lID8gdmVyaWZpZWRHbG9iYWxzLndpbmRvdz8uW3Byb3BlcnR5TmFtZV0gOiB2ZXJpZmllZEdsb2JhbHMud2luZG93O1xufVxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWdOYW1lLCBjbGFzc05hbWUsIHN0eWxlKSB7XG4gIGNvbnN0IGVsZW1lbnQyID0gZ2V0RG9jdW1lbnQoKS5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodHlwZW9mIGNsYXNzTmFtZSA9PT0gXCJvYmplY3RcIikge1xuICAgIHN0eWxlID0gY2xhc3NOYW1lO1xuICAgIGNsYXNzTmFtZSA9IHZvaWQgMDtcbiAgfVxuICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgZWxlbWVudDIuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO1xuICB9XG4gIGlmIChzdHlsZSkge1xuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudDIuc3R5bGUsIHN0eWxlKTtcbiAgfVxuICByZXR1cm4gZWxlbWVudDI7XG59XG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCBxdWFsaWZpZWROYW1lKSB7XG4gIHJldHVybiBnZXREb2N1bWVudCgpLmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHF1YWxpZmllZE5hbWUpO1xufVxuZnVuY3Rpb24gZG93bmxvYWRVcmwoZGF0YVVybCwgZmlsZU5hbWUpIHtcbiAgY29uc3QgeyBib2R5IH0gPSBnZXREb2N1bWVudCgpO1xuICBjb25zdCBlbGVtZW50MiA9IGNyZWF0ZUVsZW1lbnQoXCJhXCIsIHsgZGlzcGxheTogXCJub25lXCIgfSk7XG4gIGVsZW1lbnQyLmhyZWYgPSBkYXRhVXJsO1xuICBlbGVtZW50Mi5kb3dubG9hZCA9IGZpbGVOYW1lO1xuICBib2R5LmFwcGVuZENoaWxkKGVsZW1lbnQyKTtcbiAgZWxlbWVudDIuY2xpY2soKTtcbiAgc2V0VGltZW91dCgoKSA9PiBib2R5LnJlbW92ZUNoaWxkKGVsZW1lbnQyKSk7XG59XG5mdW5jdGlvbiBzZXREb2N1bWVudChkb2N1bWVudDIpIHtcbiAgdmVyaWZpZWRHbG9iYWxzLmRvY3VtZW50ID0gZG9jdW1lbnQyO1xufVxuZnVuY3Rpb24gc2V0V2luZG93KHdpbmRvdzIpIHtcbiAgdmVyaWZpZWRHbG9iYWxzLndpbmRvdyA9IHdpbmRvdzI7XG59XG5mdW5jdGlvbiBzZXRFbGVtZW50QkJveChlbGVtZW50MiwgYmJveCkge1xuICBpZiAoZWxlbWVudDIpIHtcbiAgICBlbGVtZW50Mi5zdHlsZS53aWR0aCA9IGAke2Jib3gud2lkdGh9cHhgO1xuICAgIGVsZW1lbnQyLnN0eWxlLmhlaWdodCA9IGAke2Jib3guaGVpZ2h0fXB4YDtcbiAgICBlbGVtZW50Mi5zdHlsZS5sZWZ0ID0gYCR7YmJveC54fXB4YDtcbiAgICBlbGVtZW50Mi5zdHlsZS50b3AgPSBgJHtiYm94Lnl9cHhgO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvZGVidWcudHNcbnZhciBMT05HX1RJTUVfUEVSSU9EX1RIUkVTSE9MRCA9IDJlMztcbnZhciB0aW1lT2ZMYXN0TG9nID0gRGF0ZS5ub3coKTtcbnZhciBsb2dUaW1lR2FwID0gKCkgPT4ge1xuICBjb25zdCB0aW1lU2luY2VMYXN0TG9nID0gRGF0ZS5ub3coKSAtIHRpbWVPZkxhc3RMb2c7XG4gIGlmICh0aW1lU2luY2VMYXN0TG9nID4gTE9OR19USU1FX1BFUklPRF9USFJFU0hPTEQpIHtcbiAgICBjb25zdCBwcmV0dHlEdXJhdGlvbiA9IChNYXRoLmZsb29yKHRpbWVTaW5jZUxhc3RMb2cgLyAxMDApIC8gMTApLnRvRml4ZWQoMSk7XG4gICAgTG9nZ2VyLmxvZyhgKioqKiAke3ByZXR0eUR1cmF0aW9ufXMgc2luY2UgbGFzdCBsb2cgbWVzc2FnZSAqKioqYCk7XG4gIH1cbiAgdGltZU9mTGFzdExvZyA9IERhdGUubm93KCk7XG59O1xudmFyIERlYnVnID0ge1xuICBjcmVhdGUoLi4uZGVidWdTZWxlY3RvcnMpIHtcbiAgICBjb25zdCByZXN1bHRGbiA9ICguLi5sb2dDb250ZW50KSA9PiB7XG4gICAgICBpZiAoRGVidWcuY2hlY2soLi4uZGVidWdTZWxlY3RvcnMpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9nQ29udGVudFswXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgbG9nQ29udGVudCA9IHRvQXJyYXkobG9nQ29udGVudFswXSgpKTtcbiAgICAgICAgfVxuICAgICAgICBsb2dUaW1lR2FwKCk7XG4gICAgICAgIExvZ2dlci5sb2coLi4ubG9nQ29udGVudCk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihyZXN1bHRGbiwgeyBjaGVjazogKCkgPT4gRGVidWcuY2hlY2soLi4uZGVidWdTZWxlY3RvcnMpIH0pO1xuICB9LFxuICBjaGVjayguLi5kZWJ1Z1NlbGVjdG9ycykge1xuICAgIGlmIChkZWJ1Z1NlbGVjdG9ycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlYnVnU2VsZWN0b3JzLnB1c2godHJ1ZSk7XG4gICAgfVxuICAgIGNvbnN0IGNoYXJ0RGVidWcgPSB0b0FycmF5KGdldFdpbmRvdyhcImFnQ2hhcnRzRGVidWdcIikpO1xuICAgIHJldHVybiBjaGFydERlYnVnLnNvbWUoKHNlbGVjdG9yKSA9PiBkZWJ1Z1NlbGVjdG9ycy5pbmNsdWRlcyhzZWxlY3RvcikpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zZWxlY3Rpb24udHNcbnZhciBTZWxlY3Rpb24gPSBjbGFzcyBfU2VsZWN0aW9uIHtcbiAgY29uc3RydWN0b3IocGFyZW50Tm9kZSwgY2xhc3NPckZhY3RvcnksIGF1dG9DbGVhbnVwID0gdHJ1ZSkge1xuICAgIHRoaXMucGFyZW50Tm9kZSA9IHBhcmVudE5vZGU7XG4gICAgdGhpcy5hdXRvQ2xlYW51cCA9IGF1dG9DbGVhbnVwO1xuICAgIHRoaXMuZ2FyYmFnZUJpbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5fbm9kZXNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuX25vZGVzID0gW107XG4gICAgdGhpcy5kYXRhID0gW107XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcInNjZW5lXCIsIFwic2NlbmU6c2VsZWN0aW9uc1wiKTtcbiAgICB0aGlzLm5vZGVGYWN0b3J5ID0gT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwoTm9kZSwgY2xhc3NPckZhY3RvcnkpID8gKCkgPT4gbmV3IGNsYXNzT3JGYWN0b3J5KCkgOiBjbGFzc09yRmFjdG9yeTtcbiAgfVxuICBzdGF0aWMgc2VsZWN0KHBhcmVudCwgY2xhc3NPckZhY3RvcnksIGdhcmJhZ2VDb2xsZWN0aW9uID0gdHJ1ZSkge1xuICAgIHJldHVybiBuZXcgX1NlbGVjdGlvbihwYXJlbnQsIGNsYXNzT3JGYWN0b3J5LCBnYXJiYWdlQ29sbGVjdGlvbik7XG4gIH1cbiAgc3RhdGljIHNlbGVjdEFsbChwYXJlbnQsIHByZWRpY2F0ZSkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBjb25zdCB0cmF2ZXJzZSA9IChub2RlKSA9PiB7XG4gICAgICBpZiAocHJlZGljYXRlKG5vZGUpKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChub2RlKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuY2hpbGRyZW4uZm9yRWFjaCh0cmF2ZXJzZSk7XG4gICAgfTtcbiAgICB0cmF2ZXJzZShwYXJlbnQpO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG4gIHN0YXRpYyBzZWxlY3RCeUNsYXNzKG5vZGUsIENsYXNzLCAuLi5FeHRyYUNsYXNzZXMpIHtcbiAgICByZXR1cm4gX1NlbGVjdGlvbi5zZWxlY3RBbGwobm9kZSwgKG4pID0+IHtcbiAgICAgIHJldHVybiBuIGluc3RhbmNlb2YgQ2xhc3MgfHwgRXh0cmFDbGFzc2VzLnNvbWUoKEMpID0+IG4gaW5zdGFuY2VvZiBDKTtcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgc2VsZWN0QnlUYWcobm9kZSwgdGFnKSB7XG4gICAgcmV0dXJuIF9TZWxlY3Rpb24uc2VsZWN0QWxsKG5vZGUsIChuKSA9PiBuLnRhZyA9PT0gdGFnKTtcbiAgfVxuICBjcmVhdGVOb2RlKGRhdHVtLCBpbml0aWFsaXplciwgaWR4KSB7XG4gICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZUZhY3RvcnkoZGF0dW0pO1xuICAgIG5vZGUuZGF0dW0gPSBkYXR1bTtcbiAgICBpbml0aWFsaXplcj8uKG5vZGUpO1xuICAgIGlmIChpZHggPT0gbnVsbCkge1xuICAgICAgdGhpcy5fbm9kZXMucHVzaChub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbm9kZXMuc3BsaWNlKGlkeCwgMCwgbm9kZSk7XG4gICAgfVxuICAgIHRoaXMucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChub2RlKTtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBkYXRhIGluIGEgc2VsZWN0aW9uLiBJZiBhbiBgZ2V0RGF0dW1JZCgpYCBmdW5jdGlvbiBpcyBwcm92aWRlZCwgbWFpbnRhaW4gYSBsaXN0IG9mIGlkcyByZWxhdGVkIHRvXG4gICAqIHRoZSBub2Rlcy4gT3RoZXJ3aXNlLCB0YWtlIHRoZSBtb3JlIGVmZmljaWVudCByb3V0ZSBvZiBzaW1wbHkgY3JlYXRpbmcgYW5kIGRlc3Ryb3lpbmcgbm9kZXMgYXQgdGhlIGVuZFxuICAgKiBvZiB0aGUgYXJyYXkuXG4gICAqL1xuICB1cGRhdGUoZGF0YSwgaW5pdGlhbGl6ZXIsIGdldERhdHVtSWQpIHtcbiAgICBpZiAodGhpcy5nYXJiYWdlQmluLnNpemUgPiAwKSB7XG4gICAgICB0aGlzLmRlYnVnKGBTZWxlY3Rpb24gLSB1cGRhdGUoKSBjYWxsZWQgd2l0aCBwZW5kaW5nIGdhcmJhZ2U6ICR7ZGF0YX1gKTtcbiAgICB9XG4gICAgaWYgKGdldERhdHVtSWQpIHtcbiAgICAgIGNvbnN0IGRhdGFNYXAgPSBuZXcgTWFwKFxuICAgICAgICBkYXRhLm1hcCgoZGF0dW0sIGlkeCkgPT4gW2dldERhdHVtSWQoZGF0dW0pLCBbZGF0dW0sIGlkeF1dKVxuICAgICAgKTtcbiAgICAgIGZvciAoY29uc3QgW25vZGUsIGRhdHVtSWRdIG9mIHRoaXMuX25vZGVzTWFwLmVudHJpZXMoKSkge1xuICAgICAgICBpZiAoZGF0YU1hcC5oYXMoZGF0dW1JZCkpIHtcbiAgICAgICAgICBjb25zdCBbbmV3RGF0dW1dID0gZGF0YU1hcC5nZXQoZGF0dW1JZCk7XG4gICAgICAgICAgbm9kZS5kYXR1bSA9IG5ld0RhdHVtO1xuICAgICAgICAgIHRoaXMuZ2FyYmFnZUJpbi5kZWxldGUobm9kZSk7XG4gICAgICAgICAgZGF0YU1hcC5kZWxldGUoZGF0dW1JZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5nYXJiYWdlQmluLmFkZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBbZGF0dW1JZCwgW2RhdHVtLCBpZHhdXSBvZiBkYXRhTWFwLmVudHJpZXMoKSkge1xuICAgICAgICB0aGlzLl9ub2Rlc01hcC5zZXQodGhpcy5jcmVhdGVOb2RlKGRhdHVtLCBpbml0aWFsaXplciwgaWR4KSwgZGF0dW1JZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1heExlbmd0aCA9IE1hdGgubWF4KGRhdGEubGVuZ3RoLCB0aGlzLmRhdGEubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPj0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLmdhcmJhZ2VCaW4uYWRkKHRoaXMuX25vZGVzW2ldKTtcbiAgICAgICAgfSBlbHNlIGlmIChpID49IHRoaXMuX25vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuY3JlYXRlTm9kZShkYXRhW2ldLCBpbml0aWFsaXplcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fbm9kZXNbaV0uZGF0dW0gPSBkYXRhW2ldO1xuICAgICAgICAgIHRoaXMuZ2FyYmFnZUJpbi5kZWxldGUodGhpcy5fbm9kZXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGF0YSA9IGRhdGEuc2xpY2UoKTtcbiAgICBpZiAodGhpcy5hdXRvQ2xlYW51cCkge1xuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuZ2FyYmFnZUJpbi5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdGhpcy5fbm9kZXMgPSB0aGlzLl9ub2Rlcy5maWx0ZXIoKG5vZGUpID0+IHtcbiAgICAgIGlmICh0aGlzLmdhcmJhZ2VCaW4uaGFzKG5vZGUpKSB7XG4gICAgICAgIHRoaXMuX25vZGVzTWFwLmRlbGV0ZShub2RlKTtcbiAgICAgICAgdGhpcy5nYXJiYWdlQmluLmRlbGV0ZShub2RlKTtcbiAgICAgICAgbm9kZS5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMudXBkYXRlKFtdKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBpc0dhcmJhZ2Uobm9kZSkge1xuICAgIHJldHVybiB0aGlzLmdhcmJhZ2VCaW4uaGFzKG5vZGUpO1xuICB9XG4gIGhhc0dhcmJhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2FyYmFnZUJpbi5zaXplID4gMDtcbiAgfVxuICBlYWNoKGl0ZXJhdGUyKSB7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiB0aGlzLl9ub2Rlcy5lbnRyaWVzKCkpIHtcbiAgICAgIGl0ZXJhdGUyKGVudHJ5WzFdLCBlbnRyeVsxXS5kYXR1bSwgZW50cnlbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAqW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuX25vZGVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuX25vZGVzW2luZGV4XTtcbiAgICAgIGNvbnN0IGRhdHVtID0gdGhpcy5fbm9kZXNbaW5kZXhdLmRhdHVtO1xuICAgICAgeWllbGQgeyBub2RlLCBkYXR1bSwgaW5kZXggfTtcbiAgICB9XG4gIH1cbiAgc2VsZWN0KHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBfU2VsZWN0aW9uLnNlbGVjdEFsbCh0aGlzLnBhcmVudE5vZGUsIHByZWRpY2F0ZSk7XG4gIH1cbiAgc2VsZWN0QnlDbGFzcyhDbGFzcykge1xuICAgIHJldHVybiBfU2VsZWN0aW9uLnNlbGVjdEJ5Q2xhc3ModGhpcy5wYXJlbnROb2RlLCBDbGFzcyk7XG4gIH1cbiAgc2VsZWN0QnlUYWcodGFnKSB7XG4gICAgcmV0dXJuIF9TZWxlY3Rpb24uc2VsZWN0QnlUYWcodGhpcy5wYXJlbnROb2RlLCB0YWcpO1xuICB9XG4gIG5vZGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9ub2RlcztcbiAgfVxuICBhdChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLl9ub2Rlcy5hdChpbmRleCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvYW5nbGUudHNcbnZhciB0d29QaSA9IE1hdGguUEkgKiAyO1xuZnVuY3Rpb24gbm9ybWFsaXplQW5nbGUzNjAocmFkaWFucykge1xuICByYWRpYW5zICU9IHR3b1BpO1xuICByYWRpYW5zICs9IHR3b1BpO1xuICByYWRpYW5zICU9IHR3b1BpO1xuICByZXR1cm4gcmFkaWFucztcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFuZ2xlMzYwSW5jbHVzaXZlKHJhZGlhbnMpIHtcbiAgcmFkaWFucyAlPSB0d29QaTtcbiAgcmFkaWFucyArPSB0d29QaTtcbiAgaWYgKHJhZGlhbnMgIT09IHR3b1BpKSB7XG4gICAgcmFkaWFucyAlPSB0d29QaTtcbiAgfVxuICByZXR1cm4gcmFkaWFucztcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZUFuZ2xlMTgwKHJhZGlhbnMpIHtcbiAgcmFkaWFucyAlPSB0d29QaTtcbiAgaWYgKHJhZGlhbnMgPCAtTWF0aC5QSSkge1xuICAgIHJhZGlhbnMgKz0gdHdvUGk7XG4gIH0gZWxzZSBpZiAocmFkaWFucyA+PSBNYXRoLlBJKSB7XG4gICAgcmFkaWFucyAtPSB0d29QaTtcbiAgfVxuICByZXR1cm4gcmFkaWFucztcbn1cbmZ1bmN0aW9uIGlzQmV0d2VlbkFuZ2xlcyh0YXJnZXRBbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUpIHtcbiAgY29uc3QgdCA9IG5vcm1hbGl6ZUFuZ2xlMzYwKHRhcmdldEFuZ2xlKTtcbiAgY29uc3QgYTAgPSBub3JtYWxpemVBbmdsZTM2MChzdGFydEFuZ2xlKTtcbiAgY29uc3QgYTEgPSBub3JtYWxpemVBbmdsZTM2MChlbmRBbmdsZSk7XG4gIGlmIChhMCA8IGExKSB7XG4gICAgcmV0dXJuIGEwIDw9IHQgJiYgdCA8PSBhMTtcbiAgfSBlbHNlIGlmIChhMCA+IGExKSB7XG4gICAgcmV0dXJuIGEwIDw9IHQgfHwgdCA8PSBhMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gdG9SYWRpYW5zKGRlZ3JlZXMpIHtcbiAgcmV0dXJuIGRlZ3JlZXMgLyAxODAgKiBNYXRoLlBJO1xufVxuZnVuY3Rpb24gdG9EZWdyZWVzKHJhZGlhbnMpIHtcbiAgcmV0dXJuIHJhZGlhbnMgLyBNYXRoLlBJICogMTgwO1xufVxuZnVuY3Rpb24gYW5nbGVEaWZmKGFuZ2xlMCwgYW5nbGUxLCBjb3VudGVyQ2xvY2t3aXNlKSB7XG4gIGlmIChjb3VudGVyQ2xvY2t3aXNlKSB7XG4gICAgW2FuZ2xlMCwgYW5nbGUxXSA9IFthbmdsZTEsIGFuZ2xlMF07XG4gIH1cbiAgY29uc3QgYTAgPSBub3JtYWxpemVBbmdsZTM2MChhbmdsZTApO1xuICBjb25zdCBhMSA9IG5vcm1hbGl6ZUFuZ2xlMzYwKGFuZ2xlMSkgKyB0d29QaTtcbiAgcmV0dXJuIChhMSAtIGEwKSAlIHR3b1BpO1xufVxuZnVuY3Rpb24gYW5nbGVCZXR3ZWVuKGFuZ2xlMCwgYW5nbGUxKSB7XG4gIGFuZ2xlMCA9IG5vcm1hbGl6ZUFuZ2xlMzYwKGFuZ2xlMCk7XG4gIGFuZ2xlMSA9IG5vcm1hbGl6ZUFuZ2xlMzYwKGFuZ2xlMSk7XG4gIHJldHVybiBhbmdsZTEgLSBhbmdsZTAgKyAoYW5nbGUwID4gYW5nbGUxID8gMiAqIE1hdGguUEkgOiAwKTtcbn1cbmZ1bmN0aW9uIGRpc3BsYWNlUG9pbnRGcm9tVmVjdG9yKGNlbnRlclgsIGNlbnRlclksIHJhZGl1cywgYW5nbGUyKSB7XG4gIGNvbnN0IHggPSBjZW50ZXJYICsgcmFkaXVzICogTWF0aC5jb3MoYW5nbGUyKTtcbiAgY29uc3QgeSA9IGNlbnRlclkgKyByYWRpdXMgKiBNYXRoLnNpbihhbmdsZTIpO1xuICByZXR1cm4geyB4LCB5IH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvZGlzdGFuY2UudHNcbmZ1bmN0aW9uIHBvaW50c0Rpc3RhbmNlU3F1YXJlZCh4MSwgeTEsIHgyLCB5Mikge1xuICBjb25zdCBkeCA9IHgxIC0geDI7XG4gIGNvbnN0IGR5ID0geTEgLSB5MjtcbiAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuZnVuY3Rpb24gbGluZURpc3RhbmNlU3F1YXJlZCh4LCB5LCB4MSwgeTEsIHgyLCB5MiwgYmVzdCkge1xuICBpZiAoeDEgPT09IHgyICYmIHkxID09PSB5Mikge1xuICAgIHJldHVybiBNYXRoLm1pbihiZXN0LCBwb2ludHNEaXN0YW5jZVNxdWFyZWQoeCwgeSwgeDEsIHkxKSk7XG4gIH1cbiAgY29uc3QgZHggPSB4MiAtIHgxO1xuICBjb25zdCBkeSA9IHkyIC0geTE7XG4gIGNvbnN0IHQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoKHggLSB4MSkgKiBkeCArICh5IC0geTEpICogZHkpIC8gKGR4ICogZHggKyBkeSAqIGR5KSkpO1xuICBjb25zdCBpeCA9IHgxICsgdCAqIGR4O1xuICBjb25zdCBpeSA9IHkxICsgdCAqIGR5O1xuICByZXR1cm4gTWF0aC5taW4oYmVzdCwgcG9pbnRzRGlzdGFuY2VTcXVhcmVkKHgsIHksIGl4LCBpeSkpO1xufVxuZnVuY3Rpb24gYXJjRGlzdGFuY2VTcXVhcmVkKHgsIHksIGN4LCBjeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY291bnRlckNsb2Nrd2lzZSwgYmVzdCkge1xuICBpZiAoY291bnRlckNsb2Nrd2lzZSkge1xuICAgIFtlbmRBbmdsZSwgc3RhcnRBbmdsZV0gPSBbc3RhcnRBbmdsZSwgZW5kQW5nbGVdO1xuICB9XG4gIGNvbnN0IGFuZ2xlMiA9IE1hdGguYXRhbjIoeSAtIGN5LCB4IC0gY3gpO1xuICBpZiAoIWlzQmV0d2VlbkFuZ2xlcyhhbmdsZTIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSkge1xuICAgIGNvbnN0IHN0YXJ0WCA9IGN4ICsgTWF0aC5jb3Moc3RhcnRBbmdsZSkgKiByYWRpdXM7XG4gICAgY29uc3Qgc3RhcnRZID0gY3kgKyBNYXRoLnNpbihzdGFydEFuZ2xlKSAqIHJhZGl1cztcbiAgICBjb25zdCBlbmRYID0gY3ggKyBNYXRoLmNvcyhzdGFydEFuZ2xlKSAqIHJhZGl1cztcbiAgICBjb25zdCBlbmRZID0gY3kgKyBNYXRoLnNpbihzdGFydEFuZ2xlKSAqIHJhZGl1cztcbiAgICByZXR1cm4gTWF0aC5taW4oYmVzdCwgcG9pbnRzRGlzdGFuY2VTcXVhcmVkKHgsIHksIHN0YXJ0WCwgc3RhcnRZKSwgcG9pbnRzRGlzdGFuY2VTcXVhcmVkKHgsIHksIGVuZFgsIGVuZFkpKTtcbiAgfVxuICBjb25zdCBkaXN0VG9BcmMgPSByYWRpdXMgLSBNYXRoLnNxcnQocG9pbnRzRGlzdGFuY2VTcXVhcmVkKHgsIHksIGN4LCBjeSkpO1xuICByZXR1cm4gTWF0aC5taW4oYmVzdCwgZGlzdFRvQXJjICogZGlzdFRvQXJjKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvZ3JhZGllbnQvZ3JhZGllbnQudHNcbnZhciBHcmFkaWVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc3RvcHMgPSBbXSkge1xuICAgIHRoaXMuc3RvcHMgPSBzdG9wcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvZ3JhZGllbnQvbGluZWFyR3JhZGllbnQudHNcbnZhciBMaW5lYXJHcmFkaWVudCA9IGNsYXNzIGV4dGVuZHMgR3JhZGllbnQge1xuICBjb25zdHJ1Y3RvcihzdG9wcywgYW5nbGUyID0gMCkge1xuICAgIHN1cGVyKHN0b3BzKTtcbiAgICB0aGlzLmFuZ2xlID0gYW5nbGUyO1xuICB9XG4gIGNyZWF0ZUdyYWRpZW50KGN0eCwgYmJveCkge1xuICAgIGNvbnN0IGFuZ2xlT2Zmc2V0ID0gOTA7XG4gICAgY29uc3QgeyBzdG9wcywgYW5nbGU6IGFuZ2xlMiB9ID0gdGhpcztcbiAgICBjb25zdCByYWRpYW5zID0gbm9ybWFsaXplQW5nbGUzNjAodG9SYWRpYW5zKGFuZ2xlMiArIGFuZ2xlT2Zmc2V0KSk7XG4gICAgY29uc3QgY29zID0gTWF0aC5jb3MocmFkaWFucyk7XG4gICAgY29uc3Qgc2luID0gTWF0aC5zaW4ocmFkaWFucyk7XG4gICAgY29uc3QgdyA9IGJib3gud2lkdGg7XG4gICAgY29uc3QgaCA9IGJib3guaGVpZ2h0O1xuICAgIGNvbnN0IGN4ID0gYmJveC54ICsgdyAqIDAuNTtcbiAgICBjb25zdCBjeSA9IGJib3gueSArIGggKiAwLjU7XG4gICAgaWYgKHcgPiAwICYmIGggPiAwKSB7XG4gICAgICBjb25zdCBkaWFnb25hbCA9IE1hdGguc3FydChoICogaCArIHcgKiB3KSAvIDI7XG4gICAgICBjb25zdCBkaWFnb25hbEFuZ2xlID0gTWF0aC5hdGFuMihoLCB3KTtcbiAgICAgIGxldCBxdWFydGVyZWRBbmdsZTtcbiAgICAgIGlmIChyYWRpYW5zIDwgTWF0aC5QSSAvIDIpIHtcbiAgICAgICAgcXVhcnRlcmVkQW5nbGUgPSByYWRpYW5zO1xuICAgICAgfSBlbHNlIGlmIChyYWRpYW5zIDwgTWF0aC5QSSkge1xuICAgICAgICBxdWFydGVyZWRBbmdsZSA9IE1hdGguUEkgLSByYWRpYW5zO1xuICAgICAgfSBlbHNlIGlmIChyYWRpYW5zIDwgMS41ICogTWF0aC5QSSkge1xuICAgICAgICBxdWFydGVyZWRBbmdsZSA9IHJhZGlhbnMgLSBNYXRoLlBJO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVhcnRlcmVkQW5nbGUgPSAyICogTWF0aC5QSSAtIHJhZGlhbnM7XG4gICAgICB9XG4gICAgICBjb25zdCBsID0gZGlhZ29uYWwgKiBNYXRoLmFicyhNYXRoLmNvcyhxdWFydGVyZWRBbmdsZSAtIGRpYWdvbmFsQW5nbGUpKTtcbiAgICAgIGNvbnN0IGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KGN4ICsgY29zICogbCwgY3kgKyBzaW4gKiBsLCBjeCAtIGNvcyAqIGwsIGN5IC0gc2luICogbCk7XG4gICAgICBmb3IgKGNvbnN0IHN0b3Agb2Ygc3RvcHMpIHtcbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3Aub2Zmc2V0LCBzdG9wLmNvbG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBncmFkaWVudDtcbiAgICB9XG4gICAgcmV0dXJuIFwiYmxhY2tcIjtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvc2hhcGUudHNcbnZhciBMSU5FQVJfR1JBRElFTlRfUkVHRVhQID0gL15saW5lYXItZ3JhZGllbnRcXCgoLT9bXFxkLl0rKWRlZywoLio/KVxcKSQvaTtcbnZhciBfU2hhcGUgPSBjbGFzcyBfU2hhcGUgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcbiAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSAxO1xuICAgIHRoaXMuZmlsbCA9IF9TaGFwZS5kZWZhdWx0U3R5bGVzLmZpbGw7XG4gICAgdGhpcy5zdHJva2UgPSBfU2hhcGUuZGVmYXVsdFN0eWxlcy5zdHJva2U7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IF9TaGFwZS5kZWZhdWx0U3R5bGVzLnN0cm9rZVdpZHRoO1xuICAgIHRoaXMubGluZURhc2ggPSBfU2hhcGUuZGVmYXVsdFN0eWxlcy5saW5lRGFzaDtcbiAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0ID0gX1NoYXBlLmRlZmF1bHRTdHlsZXMubGluZURhc2hPZmZzZXQ7XG4gICAgdGhpcy5saW5lQ2FwID0gX1NoYXBlLmRlZmF1bHRTdHlsZXMubGluZUNhcDtcbiAgICB0aGlzLmxpbmVKb2luID0gX1NoYXBlLmRlZmF1bHRTdHlsZXMubGluZUpvaW47XG4gICAgdGhpcy5taXRlckxpbWl0ID0gdm9pZCAwO1xuICAgIHRoaXMub3BhY2l0eSA9IF9TaGFwZS5kZWZhdWx0U3R5bGVzLm9wYWNpdHk7XG4gICAgdGhpcy5maWxsU2hhZG93ID0gX1NoYXBlLmRlZmF1bHRTdHlsZXMuZmlsbFNoYWRvdztcbiAgfVxuICAvKipcbiAgICogUmVzdG9yZXMgdGhlIGRlZmF1bHQgc3R5bGVzIGludHJvZHVjZWQgYnkgdGhpcyBzdWJjbGFzcy5cbiAgICovXG4gIHJlc3RvcmVPd25TdHlsZXMoKSB7XG4gICAgY29uc3QgeyBkZWZhdWx0U3R5bGVzIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgZGVmYXVsdFN0eWxlcyk7XG4gIH1cbiAgb25GaWxsQ2hhbmdlKCkge1xuICAgIGNvbnN0IHsgZmlsbCB9ID0gdGhpcztcbiAgICBsZXQgbGluZWFyR3JhZGllbnRNYXRjaDtcbiAgICBpZiAoZmlsbD8uc3RhcnRzV2l0aChcImxpbmVhci1ncmFkaWVudFwiKSAmJiAobGluZWFyR3JhZGllbnRNYXRjaCA9IExJTkVBUl9HUkFESUVOVF9SRUdFWFAuZXhlYyhmaWxsKSkpIHtcbiAgICAgIGNvbnN0IGFuZ2xlMiA9IHBhcnNlRmxvYXQobGluZWFyR3JhZGllbnRNYXRjaFsxXSk7XG4gICAgICBjb25zdCBjb2xvcnMgPSBbXTtcbiAgICAgIGNvbnN0IGNvbG9yc1BhcnQgPSBsaW5lYXJHcmFkaWVudE1hdGNoWzJdO1xuICAgICAgY29uc3QgY29sb3JSZWdleCA9IC8oI1swLTlhLWZdKyl8KHJnYmE/XFwoLis/XFwpKXwoW2Etel0rKS9naTtcbiAgICAgIGxldCBjO1xuICAgICAgd2hpbGUgKGMgPSBjb2xvclJlZ2V4LmV4ZWMoY29sb3JzUGFydCkpIHtcbiAgICAgICAgY29sb3JzLnB1c2goY1swXSk7XG4gICAgICB9XG4gICAgICB0aGlzLmdyYWRpZW50ID0gbmV3IExpbmVhckdyYWRpZW50KFxuICAgICAgICBjb2xvcnMubWFwKChjb2xvciwgaW5kZXgpID0+ICh7IGNvbG9yLCBvZmZzZXQ6IGluZGV4IC8gKGNvbG9ycy5sZW5ndGggLSAxKSB9KSksXG4gICAgICAgIGFuZ2xlMlxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ncmFkaWVudCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgYSBkZXZpY2UtcGl4ZWwgYWxpZ25lZCBjb29yZGluYXRlIChvciBsZW5ndGggaWYgbGVuZ3RoIGlzIHN1cHBsaWVkKS5cbiAgICpcbiAgICogTk9URTogTm90IHN1aXRhYmxlIGZvciBzdHJva2VzLCBzaW5jZSB0aGUgc3Ryb2tlIG5lZWRzIHRvIGJlIG9mZnNldCB0byB0aGUgbWlkZGxlXG4gICAqIG9mIGEgZGV2aWNlIHBpeGVsLlxuICAgKi9cbiAgYWxpZ24oc3RhcnQsIGxlbmd0aDIpIHtcbiAgICBjb25zdCBwaXhlbFJhdGlvID0gdGhpcy5sYXllck1hbmFnZXI/LmNhbnZhcz8ucGl4ZWxSYXRpbyA/PyAxO1xuICAgIGNvbnN0IGFsaWduZWRTdGFydCA9IE1hdGgucm91bmQoc3RhcnQgKiBwaXhlbFJhdGlvKSAvIHBpeGVsUmF0aW87XG4gICAgaWYgKGxlbmd0aDIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGFsaWduZWRTdGFydDtcbiAgICB9IGVsc2UgaWYgKGxlbmd0aDIgPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoMiA8IDEpIHtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwobGVuZ3RoMiAqIHBpeGVsUmF0aW8pIC8gcGl4ZWxSYXRpbztcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgucm91bmQoKGxlbmd0aDIgKyBzdGFydCkgKiBwaXhlbFJhdGlvKSAvIHBpeGVsUmF0aW8gLSBhbGlnbmVkU3RhcnQ7XG4gIH1cbiAgZmlsbFN0cm9rZShjdHgsIHBhdGgpIHtcbiAgICB0aGlzLnJlbmRlckZpbGwoY3R4LCBwYXRoKTtcbiAgICB0aGlzLnJlbmRlclN0cm9rZShjdHgsIHBhdGgpO1xuICB9XG4gIHJlbmRlckZpbGwoY3R4LCBwYXRoKSB7XG4gICAgaWYgKHRoaXMuZmlsbCkge1xuICAgICAgY29uc3QgeyBnbG9iYWxBbHBoYSB9ID0gY3R4O1xuICAgICAgdGhpcy5hcHBseUZpbGwoY3R4KTtcbiAgICAgIHRoaXMuYXBwbHlGaWxsQWxwaGEoY3R4KTtcbiAgICAgIHRoaXMuYXBwbHlTaGFkb3coY3R4KTtcbiAgICAgIHRoaXMuZXhlY3V0ZUZpbGwoY3R4LCBwYXRoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGdsb2JhbEFscGhhO1xuICAgIH1cbiAgICBjdHguc2hhZG93Q29sb3IgPSBcInJnYmEoMCwgMCwgMCwgMClcIjtcbiAgfVxuICBleGVjdXRlRmlsbChjdHgsIHBhdGgpIHtcbiAgICBwYXRoID8gY3R4LmZpbGwocGF0aCkgOiBjdHguZmlsbCgpO1xuICB9XG4gIGFwcGx5RmlsbChjdHgpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5ncmFkaWVudD8uY3JlYXRlR3JhZGllbnQoY3R4LCB0aGlzLmdldEJCb3goKSkgPz8gdGhpcy5maWxsO1xuICB9XG4gIGFwcGx5RmlsbEFscGhhKGN0eCkge1xuICAgIGN0eC5nbG9iYWxBbHBoYSAqPSB0aGlzLm9wYWNpdHkgKiB0aGlzLmZpbGxPcGFjaXR5O1xuICB9XG4gIGFwcGx5U2hhZG93KGN0eCkge1xuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB0aGlzLmxheWVyTWFuYWdlcj8uY2FudmFzLnBpeGVsUmF0aW8gPz8gMTtcbiAgICBjb25zdCBmaWxsU2hhZG93ID0gdGhpcy5maWxsU2hhZG93O1xuICAgIGlmIChmaWxsU2hhZG93Py5lbmFibGVkKSB7XG4gICAgICBjdHguc2hhZG93Q29sb3IgPSBmaWxsU2hhZG93LmNvbG9yO1xuICAgICAgY3R4LnNoYWRvd09mZnNldFggPSBmaWxsU2hhZG93LnhPZmZzZXQgKiBwaXhlbFJhdGlvO1xuICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSBmaWxsU2hhZG93LnlPZmZzZXQgKiBwaXhlbFJhdGlvO1xuICAgICAgY3R4LnNoYWRvd0JsdXIgPSBmaWxsU2hhZG93LmJsdXIgKiBwaXhlbFJhdGlvO1xuICAgIH1cbiAgfVxuICByZW5kZXJTdHJva2UoY3R4LCBwYXRoKSB7XG4gICAgaWYgKHRoaXMuc3Ryb2tlICYmIHRoaXMuc3Ryb2tlV2lkdGgpIHtcbiAgICAgIGNvbnN0IHsgZ2xvYmFsQWxwaGEgfSA9IGN0eDtcbiAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHRoaXMuc3Ryb2tlO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhICo9IHRoaXMub3BhY2l0eSAqIHRoaXMuc3Ryb2tlT3BhY2l0eTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLnN0cm9rZVdpZHRoO1xuICAgICAgaWYgKHRoaXMubGluZURhc2gpIHtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKHRoaXMubGluZURhc2gpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGluZURhc2hPZmZzZXQpIHtcbiAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdGhpcy5saW5lRGFzaE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmxpbmVDYXApIHtcbiAgICAgICAgY3R4LmxpbmVDYXAgPSB0aGlzLmxpbmVDYXA7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5saW5lSm9pbikge1xuICAgICAgICBjdHgubGluZUpvaW4gPSB0aGlzLmxpbmVKb2luO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWl0ZXJMaW1pdCAhPSBudWxsKSB7XG4gICAgICAgIGN0eC5taXRlckxpbWl0ID0gdGhpcy5taXRlckxpbWl0O1xuICAgICAgfVxuICAgICAgdGhpcy5leGVjdXRlU3Ryb2tlKGN0eCwgcGF0aCk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBnbG9iYWxBbHBoYTtcbiAgICB9XG4gIH1cbiAgZXhlY3V0ZVN0cm9rZShjdHgsIHBhdGgpIHtcbiAgICBwYXRoID8gY3R4LnN0cm9rZShwYXRoKSA6IGN0eC5zdHJva2UoKTtcbiAgfVxuICBjb250YWluc1BvaW50KHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BvaW50SW5QYXRoKHgsIHkpO1xuICB9XG59O1xuLyoqXG4gKiBEZWZhdWx0cyBmb3Igc3R5bGUgcHJvcGVydGllcy4gTm90ZSB0aGF0IHByb3BlcnRpZXMgdGhhdCBhZmZlY3QgdGhlIHBvc2l0aW9uXG4gKiBhbmQgc2hhcGUgb2YgdGhlIG5vZGUgYXJlIG5vdCBjb25zaWRlcmVkIHN0eWxlIHByb3BlcnRpZXMsIGZvciBleGFtcGxlOlxuICogYHhgLCBgeWAsIGB3aWR0aGAsIGBoZWlnaHRgLCBgcmFkaXVzYCwgYHJvdGF0aW9uYCwgZXRjLlxuICogQ2FuIGJlIHVzZWQgdG8gcmVzZXQgdG8gdGhlIG9yaWdpbmFsIHN0eWxpbmcgYWZ0ZXIgc29tZSBjdXN0b20gc3R5bGluZ1xuICogaGFzIGJlZW4gYXBwbGllZCAodXNpbmcgdGhlIGByZXN0b3JlT3duU3R5bGVzYCBtZXRob2QpLlxuICogVGhlc2Ugc3RhdGljIGRlZmF1bHRzIGFyZSBtZWFudCB0byBiZSBpbmhlcml0ZWQgYnkgc3ViY2xhc3Nlcy5cbiAqL1xuX1NoYXBlLmRlZmF1bHRTdHlsZXMgPSB7XG4gIGZpbGw6IFwiYmxhY2tcIixcbiAgc3Ryb2tlOiB2b2lkIDAsXG4gIHN0cm9rZVdpZHRoOiAwLFxuICBsaW5lRGFzaDogdm9pZCAwLFxuICBsaW5lRGFzaE9mZnNldDogMCxcbiAgbGluZUNhcDogdm9pZCAwLFxuICBsaW5lSm9pbjogdm9pZCAwLFxuICBvcGFjaXR5OiAxLFxuICBmaWxsU2hhZG93OiB2b2lkIDBcbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLywgY2hhbmdlQ2I6IChzKSA9PiBzLm9uRmlsbENoYW5nZSgpIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBfU2hhcGUucHJvdG90eXBlLCBcImxpbmVEYXNoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwibGluZURhc2hPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJsaW5lQ2FwXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwibGluZUpvaW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJtaXRlckxpbWl0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oe1xuICAgIHJlZHJhdzogMiAvKiBNSU5PUiAqLyxcbiAgICBjb252ZXJ0b3I6ICh2KSA9PiBjbGFtcCgwLCB2LCAxKVxuICB9KVxuXSwgX1NoYXBlLnByb3RvdHlwZSwgXCJvcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8sIGNoZWNrRGlydHlPbkFzc2lnbm1lbnQ6IHRydWUgfSlcbl0sIF9TaGFwZS5wcm90b3R5cGUsIFwiZmlsbFNoYWRvd1wiLCAyKTtcbnZhciBTaGFwZSA9IF9TaGFwZTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvbGluZS50c1xudmFyIExpbmUgPSBjbGFzcyBleHRlbmRzIFNoYXBlIHtcbiAgY29uc3RydWN0b3Iob3B0cyA9IHt9KSB7XG4gICAgc3VwZXIob3B0cyk7XG4gICAgdGhpcy54MSA9IDA7XG4gICAgdGhpcy55MSA9IDA7XG4gICAgdGhpcy54MiA9IDA7XG4gICAgdGhpcy55MiA9IDA7XG4gICAgdGhpcy5yZXN0b3JlT3duU3R5bGVzKCk7XG4gIH1cbiAgc2V0IHgodmFsdWUpIHtcbiAgICB0aGlzLngxID0gdmFsdWU7XG4gICAgdGhpcy54MiA9IHZhbHVlO1xuICB9XG4gIHNldCB5KHZhbHVlKSB7XG4gICAgdGhpcy55MSA9IHZhbHVlO1xuICAgIHRoaXMueTIgPSB2YWx1ZTtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICByZXR1cm4gbmV3IEJCb3goXG4gICAgICBNYXRoLm1pbih0aGlzLngxLCB0aGlzLngyKSxcbiAgICAgIE1hdGgubWluKHRoaXMueTEsIHRoaXMueTIpLFxuICAgICAgTWF0aC5hYnModGhpcy54MiAtIHRoaXMueDEpLFxuICAgICAgTWF0aC5hYnModGhpcy55MiAtIHRoaXMueTEpXG4gICAgKTtcbiAgfVxuICBpc1BvaW50SW5QYXRoKHB4LCBweSkge1xuICAgIGlmICh0aGlzLngxID09PSB0aGlzLngyIHx8IHRoaXMueTEgPT09IHRoaXMueTIpIHtcbiAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy50cmFuc2Zvcm1Qb2ludChweCwgcHkpO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0QkJveCgpLmNsb25lKCkuZ3Jvdyh0aGlzLnN0cm9rZVdpZHRoIC8gMikuY29udGFpbnNQb2ludCh4LCB5KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGRpc3RhbmNlU3F1YXJlZChweCwgcHkpIHtcbiAgICBjb25zdCB7IHgxLCB5MSwgeDIsIHkyIH0gPSB0aGlzO1xuICAgIHJldHVybiBsaW5lRGlzdGFuY2VTcXVhcmVkKHB4LCBweSwgeDEsIHkxLCB4MiwgeTIsIEluZmluaXR5KTtcbiAgfVxuICByZW5kZXIocmVuZGVyQ3R4KSB7XG4gICAgY29uc3QgeyBjdHgsIGZvcmNlUmVuZGVyLCBzdGF0cywgZGV2aWNlUGl4ZWxSYXRpbyB9ID0gcmVuZGVyQ3R4O1xuICAgIGlmICh0aGlzLmRpcnR5ID09PSAwIC8qIE5PTkUgKi8gJiYgIWZvcmNlUmVuZGVyKSB7XG4gICAgICBpZiAoc3RhdHMpXG4gICAgICAgIHN0YXRzLm5vZGVzU2tpcHBlZCArPSB0aGlzLm5vZGVDb3VudC5jb3VudDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50cmFuc2Zvcm1SZW5kZXJDb250ZXh0KHJlbmRlckN0eCk7XG4gICAgbGV0IHsgeDEsIHkxLCB4MiwgeTIgfSA9IHRoaXM7XG4gICAgaWYgKHgxID09PSB4Mikge1xuICAgICAgY29uc3QgeyBzdHJva2VXaWR0aCB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHggPSBNYXRoLnJvdW5kKHgxICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvICsgTWF0aC50cnVuYyhzdHJva2VXaWR0aCAqIGRldmljZVBpeGVsUmF0aW8pICUgMiAvIChkZXZpY2VQaXhlbFJhdGlvICogMik7XG4gICAgICB4MSA9IHg7XG4gICAgICB4MiA9IHg7XG4gICAgfSBlbHNlIGlmICh5MSA9PT0geTIpIHtcbiAgICAgIGNvbnN0IHsgc3Ryb2tlV2lkdGggfSA9IHRoaXM7XG4gICAgICBjb25zdCB5ID0gTWF0aC5yb3VuZCh5MSAqIGRldmljZVBpeGVsUmF0aW8pIC8gZGV2aWNlUGl4ZWxSYXRpbyArIE1hdGgudHJ1bmMoc3Ryb2tlV2lkdGggKiBkZXZpY2VQaXhlbFJhdGlvKSAlIDIgLyAoZGV2aWNlUGl4ZWxSYXRpbyAqIDIpO1xuICAgICAgeTEgPSB5O1xuICAgICAgeTIgPSB5O1xuICAgIH1cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICB0aGlzLmZpbGxTdHJva2UoY3R4KTtcbiAgICB0aGlzLmZpbGxTaGFkb3c/Lm1hcmtDbGVhbigpO1xuICAgIHN1cGVyLnJlbmRlcihyZW5kZXJDdHgpO1xuICB9XG59O1xuTGluZS5jbGFzc05hbWUgPSBcIkxpbmVcIjtcbkxpbmUuZGVmYXVsdFN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe30sIFNoYXBlLmRlZmF1bHRTdHlsZXMsIHtcbiAgZmlsbDogdm9pZCAwLFxuICBzdHJva2VXaWR0aDogMVxufSk7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgTGluZS5wcm90b3R5cGUsIFwieDFcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgTGluZS5wcm90b3R5cGUsIFwieTFcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgTGluZS5wcm90b3R5cGUsIFwieDJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgTGluZS5wcm90b3R5cGUsIFwieTJcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvY2FudmFzLnV0aWwudHNcbmZ1bmN0aW9uIGNyZWF0ZUNhbnZhc0NvbnRleHQod2lkdGggPSAwLCBoZWlnaHQgPSAwKSB7XG4gIHJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpLmdldENvbnRleHQoXCIyZFwiKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9scnVDYWNoZS50c1xudmFyIExSVUNhY2hlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihtYXhDYWNoZVNpemUgPSA1KSB7XG4gICAgdGhpcy5tYXhDYWNoZVNpemUgPSBtYXhDYWNoZVNpemU7XG4gICAgdGhpcy5zdG9yZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgZ2V0KGtleSkge1xuICAgIGlmICghdGhpcy5zdG9yZS5oYXMoa2V5KSlcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgY29uc3QgaGl0ID0gdGhpcy5zdG9yZS5nZXQoa2V5KTtcbiAgICB0aGlzLnN0b3JlLmRlbGV0ZShrZXkpO1xuICAgIHRoaXMuc3RvcmUuc2V0KGtleSwgaGl0KTtcbiAgICByZXR1cm4gaGl0O1xuICB9XG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yZS5oYXMoa2V5KTtcbiAgfVxuICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuc3RvcmUuc2V0KGtleSwgdmFsdWUpO1xuICAgIGlmICh0aGlzLnN0b3JlLnNpemUgPiB0aGlzLm1heENhY2hlU2l6ZSkge1xuICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLnN0b3JlLmtleXMoKTtcbiAgICAgIGxldCBldmljdENvdW50ID0gdGhpcy5zdG9yZS5zaXplIC0gdGhpcy5tYXhDYWNoZVNpemU7XG4gICAgICB3aGlsZSAoZXZpY3RDb3VudCA+IDApIHtcbiAgICAgICAgY29uc3QgZXZpY3RLZXlJdGVyYXRvciA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKCFldmljdEtleUl0ZXJhdG9yLmRvbmUpIHtcbiAgICAgICAgICB0aGlzLnN0b3JlLmRlbGV0ZShldmljdEtleUl0ZXJhdG9yLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBldmljdENvdW50LS07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLnN0b3JlLmNsZWFyKCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGV4dE1lYXN1cmVyLnRzXG52YXIgQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbCA9IGNsYXNzIHtcbiAgLy8gTWVhc3VyZXMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHByb3ZpZGVkIHRleHQsIGhhbmRsaW5nIG11bHRpbGluZSBpZiBuZWVkZWQuXG4gIHN0YXRpYyBtZWFzdXJlVGV4dCh0ZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGV4dE1lYXN1cmVyID0gdGhpcy5nZXRNZWFzdXJlcihvcHRpb25zKTtcbiAgICByZXR1cm4gdGV4dE1lYXN1cmVyLm1lYXN1cmVUZXh0KHRleHQpO1xuICB9XG4gIHN0YXRpYyBtZWFzdXJlTGluZXModGV4dCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHRleHRNZWFzdXJlciA9IHRoaXMuZ2V0TWVhc3VyZXIob3B0aW9ucyk7XG4gICAgcmV0dXJuIHRleHRNZWFzdXJlci5tZWFzdXJlTGluZXModGV4dCk7XG4gIH1cbiAgLy8gR2V0cyBhIFRleHRNZWFzdXJlciBpbnN0YW5jZSwgY29uZmlndXJpbmcgdGV4dCBhbGlnbm1lbnQgYW5kIGJhc2VsaW5lIGlmIHByb3ZpZGVkLlxuICBzdGF0aWMgZ2V0TWVhc3VyZXIob3B0aW9ucykge1xuICAgIGNvbnN0IGZvbnQgPSB0eXBlb2Ygb3B0aW9ucy5mb250ID09PSBcInN0cmluZ1wiID8gb3B0aW9ucy5mb250IDogVGV4dFV0aWxzLnRvRm9udFN0cmluZyhvcHRpb25zLmZvbnQpO1xuICAgIGNvbnN0IGtleSA9IGAke2ZvbnR9LSR7b3B0aW9ucy50ZXh0QWxpZ24gPz8gXCJzdGFydFwifS0ke29wdGlvbnMudGV4dEJhc2VsaW5lID8/IFwiYWxwaGFiZXRpY1wifWA7XG4gICAgcmV0dXJuIHRoaXMuaW5zdGFuY2VNYXAuZ2V0KGtleSkgPz8gdGhpcy5jcmVhdGVGb250TWVhc3VyZXIoZm9udCwgb3B0aW9ucywga2V5KTtcbiAgfVxuICAvLyBDcmVhdGVzIG9yIHJldHJpZXZlcyBhIFRleHRNZWFzdXJlciBpbnN0YW5jZSBmb3IgYSBzcGVjaWZpYyBmb250LlxuICBzdGF0aWMgY3JlYXRlRm9udE1lYXN1cmVyKGZvbnQsIG9wdGlvbnMsIGtleSkge1xuICAgIGNvbnN0IGN0eCA9IGNyZWF0ZUNhbnZhc0NvbnRleHQoKTtcbiAgICBjdHguZm9udCA9IGZvbnQ7XG4gICAgY3R4LnRleHRBbGlnbiA9IG9wdGlvbnMudGV4dEFsaWduID8/IFwic3RhcnRcIjtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gb3B0aW9ucy50ZXh0QmFzZWxpbmUgPz8gXCJhbHBoYWJldGljXCI7XG4gICAgY29uc3QgbWVhc3VyZXIgPSBuZXcgQ2FjaGVkVGV4dE1lYXN1cmVyKGN0eCwgb3B0aW9ucyk7XG4gICAgdGhpcy5pbnN0YW5jZU1hcC5zZXQoa2V5LCBtZWFzdXJlcik7XG4gICAgcmV0dXJuIG1lYXN1cmVyO1xuICB9XG59O1xuQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbC5pbnN0YW5jZU1hcCA9IG5ldyBMUlVDYWNoZSgxMCk7XG52YXIgQ2FjaGVkVGV4dE1lYXN1cmVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjdHgsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICAvLyBjYWNoZWQgdGV4dCBtZWFzdXJlbWVudHNcbiAgICB0aGlzLm1lYXN1cmVNYXAgPSBuZXcgTFJVQ2FjaGUoMTAwKTtcbiAgICBpZiAob3B0aW9ucy50ZXh0QWxpZ24pIHtcbiAgICAgIGN0eC50ZXh0QWxpZ24gPSBvcHRpb25zLnRleHRBbGlnbjtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMudGV4dEJhc2VsaW5lKSB7XG4gICAgICBjdHgudGV4dEJhc2VsaW5lID0gb3B0aW9ucy50ZXh0QmFzZWxpbmU7XG4gICAgfVxuICAgIGN0eC5mb250ID0gdHlwZW9mIG9wdGlvbnMuZm9udCA9PT0gXCJzdHJpbmdcIiA/IG9wdGlvbnMuZm9udCA6IFRleHRVdGlscy50b0ZvbnRTdHJpbmcob3B0aW9ucy5mb250KTtcbiAgICB0aGlzLnRleHRNZWFzdXJlciA9IG5ldyBTaW1wbGVUZXh0TWVhc3VyZXIoXG4gICAgICAodCkgPT4gdGhpcy5jYWNoZWRDdHhNZWFzdXJlVGV4dCh0KSxcbiAgICAgIG9wdGlvbnMudGV4dEJhc2VsaW5lID8/IFwiYWxwaGFiZXRpY1wiXG4gICAgKTtcbiAgfVxuICB0ZXh0V2lkdGgodGV4dCwgZXN0aW1hdGUpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0TWVhc3VyZXIudGV4dFdpZHRoKHRleHQsIGVzdGltYXRlKTtcbiAgfVxuICBtZWFzdXJlVGV4dCh0ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dE1lYXN1cmVyLm1lYXN1cmVUZXh0KHRleHQpO1xuICB9XG4gIG1lYXN1cmVMaW5lcyh0ZXh0KSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dE1lYXN1cmVyLm1lYXN1cmVMaW5lcyh0ZXh0KTtcbiAgfVxuICBjYWNoZWRDdHhNZWFzdXJlVGV4dCh0ZXh0KSB7XG4gICAgaWYgKCF0aGlzLm1lYXN1cmVNYXAuaGFzKHRleHQpKSB7XG4gICAgICBjb25zdCByYXdSZXN1bHQgPSB0aGlzLmN0eC5tZWFzdXJlVGV4dCh0ZXh0KTtcbiAgICAgIHRoaXMubWVhc3VyZU1hcC5zZXQodGV4dCwge1xuICAgICAgICBhY3R1YWxCb3VuZGluZ0JveEFzY2VudDogcmF3UmVzdWx0LmFjdHVhbEJvdW5kaW5nQm94QXNjZW50LFxuICAgICAgICBlbUhlaWdodEFzY2VudDogcmF3UmVzdWx0LmVtSGVpZ2h0QXNjZW50LFxuICAgICAgICBlbUhlaWdodERlc2NlbnQ6IHJhd1Jlc3VsdC5lbUhlaWdodERlc2NlbnQsXG4gICAgICAgIGFjdHVhbEJvdW5kaW5nQm94RGVzY2VudDogcmF3UmVzdWx0LmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCxcbiAgICAgICAgYWN0dWFsQm91bmRpbmdCb3hMZWZ0OiByYXdSZXN1bHQuYWN0dWFsQm91bmRpbmdCb3hMZWZ0LFxuICAgICAgICBhY3R1YWxCb3VuZGluZ0JveFJpZ2h0OiByYXdSZXN1bHQuYWN0dWFsQm91bmRpbmdCb3hSaWdodCxcbiAgICAgICAgYWxwaGFiZXRpY0Jhc2VsaW5lOiByYXdSZXN1bHQuYWxwaGFiZXRpY0Jhc2VsaW5lLFxuICAgICAgICBmb250Qm91bmRpbmdCb3hBc2NlbnQ6IHJhd1Jlc3VsdC5mb250Qm91bmRpbmdCb3hBc2NlbnQsXG4gICAgICAgIGZvbnRCb3VuZGluZ0JveERlc2NlbnQ6IHJhd1Jlc3VsdC5mb250Qm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgICBoYW5naW5nQmFzZWxpbmU6IHJhd1Jlc3VsdC5oYW5naW5nQmFzZWxpbmUsXG4gICAgICAgIGlkZW9ncmFwaGljQmFzZWxpbmU6IHJhd1Jlc3VsdC5pZGVvZ3JhcGhpY0Jhc2VsaW5lLFxuICAgICAgICB3aWR0aDogcmF3UmVzdWx0LndpZHRoXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVhc3VyZU1hcC5nZXQodGV4dCk7XG4gIH1cbn07XG52YXIgVGV4dFV0aWxzID0gY2xhc3Mge1xuICBzdGF0aWMgdG9Gb250U3RyaW5nKHsgZm9udFNpemUgPSAxMCwgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250RmFtaWx5LCBsaW5lSGVpZ2h0IH0pIHtcbiAgICBsZXQgZm9udFN0cmluZyA9IFwiXCI7XG4gICAgaWYgKGZvbnRTdHlsZSkge1xuICAgICAgZm9udFN0cmluZyArPSBgJHtmb250U3R5bGV9IGA7XG4gICAgfVxuICAgIGlmIChmb250V2VpZ2h0KSB7XG4gICAgICBmb250U3RyaW5nICs9IGAke2ZvbnRXZWlnaHR9IGA7XG4gICAgfVxuICAgIGZvbnRTdHJpbmcgKz0gYCR7Zm9udFNpemV9cHhgO1xuICAgIGlmIChsaW5lSGVpZ2h0KSB7XG4gICAgICBmb250U3RyaW5nICs9IGAvJHtsaW5lSGVpZ2h0fXB4YDtcbiAgICB9XG4gICAgZm9udFN0cmluZyArPSBgICR7Zm9udEZhbWlseX1gO1xuICAgIHJldHVybiBmb250U3RyaW5nLnRyaW0oKTtcbiAgfVxuICBzdGF0aWMgZ2V0TGluZUhlaWdodChmb250U2l6ZSkge1xuICAgIHJldHVybiBNYXRoLmNlaWwoZm9udFNpemUgKiB0aGlzLmRlZmF1bHRMaW5lSGVpZ2h0KTtcbiAgfVxuICAvLyBEZXRlcm1pbmVzIHZlcnRpY2FsIG9mZnNldCBtb2RpZmllciBiYXNlZCBvbiB0ZXh0IGJhc2VsaW5lLlxuICBzdGF0aWMgZ2V0VmVydGljYWxNb2RpZmllcih0ZXh0QmFzZWxpbmUpIHtcbiAgICBzd2l0Y2ggKHRleHRCYXNlbGluZSkge1xuICAgICAgY2FzZSBcImhhbmdpbmdcIjpcbiAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICBjYXNlIFwibWlkZGxlXCI6XG4gICAgICAgIHJldHVybiAwLjU7XG4gICAgICBjYXNlIFwiYWxwaGFiZXRpY1wiOlxuICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgY2FzZSBcImlkZW9ncmFwaGljXCI6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH1cbn07XG5UZXh0VXRpbHMuRWxsaXBzaXNDaGFyID0gXCJcXHUyMDI2XCI7XG4vLyBSZXByZXNlbnRhdGlvbiBmb3IgdGV4dCBjbGlwcGluZy5cblRleHRVdGlscy5kZWZhdWx0TGluZUhlaWdodCA9IDEuMTU7XG4vLyBOb3JtYWxseSBiZXR3ZWVuIDEuMSBhbmQgMS4yXG5UZXh0VXRpbHMubGluZVNwbGl0dGVyID0gL1xccj9cXG4vZztcbnZhciBTaW1wbGVUZXh0TWVhc3VyZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG1lYXN1cmVUZXh0Rm4sIHRleHRCYXNlbGluZSA9IFwiYWxwaGFiZXRpY1wiKSB7XG4gICAgdGhpcy5tZWFzdXJlVGV4dEZuID0gbWVhc3VyZVRleHRGbjtcbiAgICB0aGlzLnRleHRCYXNlbGluZSA9IHRleHRCYXNlbGluZTtcbiAgICAvLyBsb2NhbCBjaGFycyB3aWR0aCBjYWNoZSBwZXIgVGV4dE1lYXN1cmVyXG4gICAgdGhpcy5jaGFyTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICAvLyBNZWFzdXJlcyBtZXRyaWNzIGZvciBhIHNpbmdsZSBsaW5lIG9mIHRleHQuXG4gIGdldE1ldHJpY3ModGV4dCkge1xuICAgIGNvbnN0IG0gPSB0aGlzLm1lYXN1cmVUZXh0Rm4odGV4dCk7XG4gICAgbS5mb250Qm91bmRpbmdCb3hBc2NlbnQgPz8gKG0uZm9udEJvdW5kaW5nQm94QXNjZW50ID0gbS5lbUhlaWdodEFzY2VudCk7XG4gICAgbS5mb250Qm91bmRpbmdCb3hEZXNjZW50ID8/IChtLmZvbnRCb3VuZGluZ0JveERlc2NlbnQgPSBtLmVtSGVpZ2h0RGVzY2VudCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBtLndpZHRoLFxuICAgICAgaGVpZ2h0OiBtLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50ICsgbS5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQsXG4gICAgICBsaW5lSGVpZ2h0OiBtLmZvbnRCb3VuZGluZ0JveEFzY2VudCArIG0uZm9udEJvdW5kaW5nQm94RGVzY2VudCxcbiAgICAgIG9mZnNldFRvcDogbS5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCxcbiAgICAgIG9mZnNldExlZnQ6IG0uYWN0dWFsQm91bmRpbmdCb3hMZWZ0XG4gICAgfTtcbiAgfVxuICAvLyBDYWxjdWxhdGVzIGFnZ3JlZ2F0ZWQgbWV0cmljcyBmb3IgbXVsdGlsaW5lIHRleHQuXG4gIGdldE11bHRpbGluZU1ldHJpY3MobGluZXMpIHtcbiAgICBsZXQgd2lkdGggPSAwO1xuICAgIGxldCBoZWlnaHQgPSAwO1xuICAgIGxldCBvZmZzZXRUb3AgPSAwO1xuICAgIGxldCBvZmZzZXRMZWZ0ID0gMDtcbiAgICBsZXQgYmFzZWxpbmVEaXN0YW5jZSA9IDA7XG4gICAgY29uc3QgdmVydGljYWxNb2RpZmllciA9IFRleHRVdGlscy5nZXRWZXJ0aWNhbE1vZGlmaWVyKHRoaXMudGV4dEJhc2VsaW5lKTtcbiAgICBjb25zdCBsaW5lTWV0cmljcyA9IFtdO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgY29uc3QgbGVuZ3RoMiA9IGxpbmVzLmxlbmd0aDtcbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgIGNvbnN0IG0gPSB0aGlzLm1lYXN1cmVUZXh0Rm4obGluZSk7XG4gICAgICBtLmZvbnRCb3VuZGluZ0JveEFzY2VudCA/PyAobS5mb250Qm91bmRpbmdCb3hBc2NlbnQgPSBtLmVtSGVpZ2h0QXNjZW50KTtcbiAgICAgIG0uZm9udEJvdW5kaW5nQm94RGVzY2VudCA/PyAobS5mb250Qm91bmRpbmdCb3hEZXNjZW50ID0gbS5lbUhlaWdodERlc2NlbnQpO1xuICAgICAgaWYgKHdpZHRoIDwgbS53aWR0aCkge1xuICAgICAgICB3aWR0aCA9IG0ud2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAob2Zmc2V0TGVmdCA8IG0uYWN0dWFsQm91bmRpbmdCb3hMZWZ0KSB7XG4gICAgICAgIG9mZnNldExlZnQgPSBtLmFjdHVhbEJvdW5kaW5nQm94TGVmdDtcbiAgICAgIH1cbiAgICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgICBoZWlnaHQgKz0gbS5hY3R1YWxCb3VuZGluZ0JveEFzY2VudDtcbiAgICAgICAgb2Zmc2V0VG9wICs9IG0uYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlbGluZURpc3RhbmNlICs9IG0uZm9udEJvdW5kaW5nQm94QXNjZW50O1xuICAgICAgfVxuICAgICAgaWYgKGluZGV4ID09PSBsZW5ndGgyIC0gMSkge1xuICAgICAgICBoZWlnaHQgKz0gbS5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlbGluZURpc3RhbmNlICs9IG0uZm9udEJvdW5kaW5nQm94RGVzY2VudDtcbiAgICAgIH1cbiAgICAgIGxpbmVNZXRyaWNzLnB1c2goe1xuICAgICAgICB0ZXh0OiBsaW5lLFxuICAgICAgICB3aWR0aDogbS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBtLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50ICsgbS5hY3R1YWxCb3VuZGluZ0JveERlc2NlbnQsXG4gICAgICAgIGxpbmVIZWlnaHQ6IG0uZm9udEJvdW5kaW5nQm94QXNjZW50ICsgbS5mb250Qm91bmRpbmdCb3hEZXNjZW50LFxuICAgICAgICBvZmZzZXRUb3A6IG0uYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQsXG4gICAgICAgIG9mZnNldExlZnQ6IG0uYWN0dWFsQm91bmRpbmdCb3hMZWZ0XG4gICAgICB9KTtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuICAgIGhlaWdodCArPSBiYXNlbGluZURpc3RhbmNlO1xuICAgIG9mZnNldFRvcCArPSBiYXNlbGluZURpc3RhbmNlICogdmVydGljYWxNb2RpZmllcjtcbiAgICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0LCBvZmZzZXRUb3AsIG9mZnNldExlZnQsIGxpbmVNZXRyaWNzIH07XG4gIH1cbiAgdGV4dFdpZHRoKHRleHQsIGVzdGltYXRlKSB7XG4gICAgaWYgKGVzdGltYXRlKSB7XG4gICAgICBsZXQgZXN0aW1hdGVkV2lkdGggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVzdGltYXRlZFdpZHRoICs9IHRoaXMudGV4dFdpZHRoKHRleHQuY2hhckF0KGkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlc3RpbWF0ZWRXaWR0aDtcbiAgICB9XG4gICAgaWYgKHRleHQubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHRoaXMubWVhc3VyZVRleHRGbih0ZXh0KS53aWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2hhck1hcC5nZXQodGV4dCkgPz8gdGhpcy5jaGFyV2lkdGgodGV4dCk7XG4gIH1cbiAgbWVhc3VyZVRleHQodGV4dCkge1xuICAgIHJldHVybiB0aGlzLmdldE1ldHJpY3ModGV4dCk7XG4gIH1cbiAgLy8gTWVhc3VyZXMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHByb3ZpZGVkIHRleHQsIGhhbmRsaW5nIG11bHRpbGluZSBpZiBuZWVkZWQuXG4gIG1lYXN1cmVMaW5lcyh0ZXh0KSB7XG4gICAgY29uc3QgbGluZXMgPSB0eXBlb2YgdGV4dCA9PT0gXCJzdHJpbmdcIiA/IHRleHQuc3BsaXQoVGV4dFV0aWxzLmxpbmVTcGxpdHRlcikgOiB0ZXh0O1xuICAgIHJldHVybiB0aGlzLmdldE11bHRpbGluZU1ldHJpY3MobGluZXMpO1xuICB9XG4gIGNoYXJXaWR0aChjaGFyKSB7XG4gICAgY29uc3QgeyB3aWR0aCB9ID0gdGhpcy5tZWFzdXJlVGV4dEZuKGNoYXIpO1xuICAgIHRoaXMuY2hhck1hcC5zZXQoY2hhciwgd2lkdGgpO1xuICAgIHJldHVybiB3aWR0aDtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvc2hhcGUvdGV4dC50c1xuZnVuY3Rpb24gU2NlbmVGb250Q2hhbmdlRGV0ZWN0aW9uKG9wdHMpIHtcbiAgY29uc3QgeyByZWRyYXcgPSAzIC8qIE1BSk9SICovLCBjaGFuZ2VDYiB9ID0gb3B0cyA/PyB7fTtcbiAgcmV0dXJuIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3LCB0eXBlOiBcImZvbnRcIiwgY2hhbmdlQ2IgfSk7XG59XG52YXIgX1RleHQgPSBjbGFzcyBfVGV4dCBleHRlbmRzIFNoYXBlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5saW5lcyA9IFtdO1xuICAgIHRoaXMudGV4dCA9IHZvaWQgMDtcbiAgICB0aGlzLmZvbnRTaXplID0gMTA7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gXCJzYW5zLXNlcmlmXCI7XG4gICAgdGhpcy50ZXh0QWxpZ24gPSBfVGV4dC5kZWZhdWx0U3R5bGVzLnRleHRBbGlnbjtcbiAgICB0aGlzLnRleHRCYXNlbGluZSA9IF9UZXh0LmRlZmF1bHRTdHlsZXMudGV4dEJhc2VsaW5lO1xuICB9XG4gIG9uVGV4dENoYW5nZSgpIHtcbiAgICB0aGlzLmxpbmVzID0gdGhpcy50ZXh0Py5zcGxpdChcIlxcblwiKS5tYXAoKHMpID0+IHMudHJpbSgpKSA/PyBbXTtcbiAgfVxuICBzdGF0aWMgY29tcHV0ZUJCb3gobGluZXMsIHgsIHksIG9wdHMpIHtcbiAgICBjb25zdCB7IG9mZnNldFRvcCwgb2Zmc2V0TGVmdCwgd2lkdGgsIGhlaWdodCB9ID0gQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbC5tZWFzdXJlTGluZXMobGluZXMsIG9wdHMpO1xuICAgIHJldHVybiBuZXcgQkJveCh4IC0gb2Zmc2V0TGVmdCwgeSAtIG9mZnNldFRvcCwgd2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgY29uc3QgeyB4LCB5LCBsaW5lcywgdGV4dEJhc2VsaW5lLCB0ZXh0QWxpZ24gfSA9IHRoaXM7XG4gICAgcmV0dXJuIF9UZXh0LmNvbXB1dGVCQm94KGxpbmVzLCB4LCB5LCB7IGZvbnQ6IHRoaXMsIHRleHRCYXNlbGluZSwgdGV4dEFsaWduIH0pO1xuICB9XG4gIGlzUG9pbnRJblBhdGgoeCwgeSkge1xuICAgIGNvbnN0IHBvaW50ID0gdGhpcy50cmFuc2Zvcm1Qb2ludCh4LCB5KTtcbiAgICBjb25zdCBiYm94ID0gdGhpcy5nZXRCQm94KCk7XG4gICAgcmV0dXJuIGJib3ggPyBiYm94LmNvbnRhaW5zUG9pbnQocG9pbnQueCwgcG9pbnQueSkgOiBmYWxzZTtcbiAgfVxuICByZW5kZXIocmVuZGVyQ3R4KSB7XG4gICAgY29uc3QgeyBjdHgsIGZvcmNlUmVuZGVyLCBzdGF0cyB9ID0gcmVuZGVyQ3R4O1xuICAgIGlmICh0aGlzLmRpcnR5ID09PSAwIC8qIE5PTkUgKi8gJiYgIWZvcmNlUmVuZGVyKSB7XG4gICAgICBpZiAoc3RhdHMpXG4gICAgICAgIHN0YXRzLm5vZGVzU2tpcHBlZCArPSB0aGlzLm5vZGVDb3VudC5jb3VudDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmxpbmVzLmxlbmd0aCB8fCAhdGhpcy5sYXllck1hbmFnZXIpIHtcbiAgICAgIGlmIChzdGF0cylcbiAgICAgICAgc3RhdHMubm9kZXNTa2lwcGVkICs9IHRoaXMubm9kZUNvdW50LmNvdW50O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRyYW5zZm9ybVJlbmRlckNvbnRleHQocmVuZGVyQ3R4KTtcbiAgICBjb25zdCB7IGZpbGwsIHN0cm9rZSwgc3Ryb2tlV2lkdGggfSA9IHRoaXM7XG4gICAgY29uc3QgeyBwaXhlbFJhdGlvIH0gPSB0aGlzLmxheWVyTWFuYWdlci5jYW52YXM7XG4gICAgY3R4LmZvbnQgPSBUZXh0VXRpbHMudG9Gb250U3RyaW5nKHRoaXMpO1xuICAgIGN0eC50ZXh0QWxpZ24gPSB0aGlzLnRleHRBbGlnbjtcbiAgICBjdHgudGV4dEJhc2VsaW5lID0gdGhpcy50ZXh0QmFzZWxpbmU7XG4gICAgaWYgKGZpbGwpIHtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhICo9IHRoaXMub3BhY2l0eSAqIHRoaXMuZmlsbE9wYWNpdHk7XG4gICAgICBjb25zdCB7IGZpbGxTaGFkb3cgfSA9IHRoaXM7XG4gICAgICBpZiAoZmlsbFNoYWRvdz8uZW5hYmxlZCkge1xuICAgICAgICBjdHguc2hhZG93Q29sb3IgPSBmaWxsU2hhZG93LmNvbG9yO1xuICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IGZpbGxTaGFkb3cueE9mZnNldCAqIHBpeGVsUmF0aW87XG4gICAgICAgIGN0eC5zaGFkb3dPZmZzZXRZID0gZmlsbFNoYWRvdy55T2Zmc2V0ICogcGl4ZWxSYXRpbztcbiAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSBmaWxsU2hhZG93LmJsdXIgKiBwaXhlbFJhdGlvO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJMaW5lcygobGluZSwgeCwgeSkgPT4gY3R4LmZpbGxUZXh0KGxpbmUsIHgsIHkpKTtcbiAgICB9XG4gICAgaWYgKHN0cm9rZSAmJiBzdHJva2VXaWR0aCkge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlO1xuICAgICAgY3R4LmxpbmVXaWR0aCA9IHN0cm9rZVdpZHRoO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhICo9IHRoaXMub3BhY2l0eSAqIHRoaXMuc3Ryb2tlT3BhY2l0eTtcbiAgICAgIGNvbnN0IHsgbGluZURhc2gsIGxpbmVEYXNoT2Zmc2V0LCBsaW5lQ2FwLCBsaW5lSm9pbiB9ID0gdGhpcztcbiAgICAgIGlmIChsaW5lRGFzaCkge1xuICAgICAgICBjdHguc2V0TGluZURhc2gobGluZURhc2gpO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVEYXNoT2Zmc2V0KSB7XG4gICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVDYXApIHtcbiAgICAgICAgY3R4LmxpbmVDYXAgPSBsaW5lQ2FwO1xuICAgICAgfVxuICAgICAgaWYgKGxpbmVKb2luKSB7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9IGxpbmVKb2luO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJMaW5lcygobGluZSwgeCwgeSkgPT4gY3R4LnN0cm9rZVRleHQobGluZSwgeCwgeSkpO1xuICAgIH1cbiAgICBzdXBlci5yZW5kZXIocmVuZGVyQ3R4KTtcbiAgfVxuICByZW5kZXJMaW5lcyhyZW5kZXJDYWxsYmFjaykge1xuICAgIGNvbnN0IHsgbGluZXMsIHgsIHkgfSA9IHRoaXM7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodCA/PyBUZXh0VXRpbHMuZ2V0TGluZUhlaWdodCh0aGlzLmZvbnRTaXplKTtcbiAgICBsZXQgb2Zmc2V0WSA9IChsaW5lSGVpZ2h0IC0gbGluZUhlaWdodCAqIGxpbmVzLmxlbmd0aCkgKiBUZXh0VXRpbHMuZ2V0VmVydGljYWxNb2RpZmllcih0aGlzLnRleHRCYXNlbGluZSk7XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgICByZW5kZXJDYWxsYmFjayhsaW5lLCB4LCB5ICsgb2Zmc2V0WSk7XG4gICAgICBvZmZzZXRZICs9IGxpbmVIZWlnaHQ7XG4gICAgfVxuICB9XG4gIHNldEZvbnQocHJvcHMpIHtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBwcm9wcy5mb250RmFtaWx5O1xuICAgIHRoaXMuZm9udFNpemUgPSBwcm9wcy5mb250U2l6ZTtcbiAgICB0aGlzLmZvbnRTdHlsZSA9IHByb3BzLmZvbnRTdHlsZTtcbiAgICB0aGlzLmZvbnRXZWlnaHQgPSBwcm9wcy5mb250V2VpZ2h0O1xuICB9XG4gIHNldEFsaWduKHByb3BzKSB7XG4gICAgdGhpcy50ZXh0QWxpZ24gPSBwcm9wcy50ZXh0QWxpZ247XG4gICAgdGhpcy50ZXh0QmFzZWxpbmUgPSBwcm9wcy50ZXh0QmFzZWxpbmU7XG4gIH1cbn07XG5fVGV4dC5jbGFzc05hbWUgPSBcIlRleHRcIjtcbi8vIFRoZSBkZWZhdWx0IGxpbmUgc3BhY2luZyBmb3IgZG9jdW1lbnQgZWRpdG9ycyBpcyB1c3VhbGx5IDEuMTVcbl9UZXh0LmRlZmF1bHRMaW5lSGVpZ2h0UmF0aW8gPSAxLjE1O1xuX1RleHQuZGVmYXVsdFN0eWxlcyA9IE9iamVjdC5hc3NpZ24oe30sIFNoYXBlLmRlZmF1bHRTdHlsZXMsIHtcbiAgdGV4dEFsaWduOiBcInN0YXJ0XCIsXG4gIGZvbnRTdHlsZTogdm9pZCAwLFxuICBmb250V2VpZ2h0OiB2b2lkIDAsXG4gIGZvbnRTaXplOiAxMCxcbiAgZm9udEZhbWlseTogXCJzYW5zLXNlcmlmXCIsXG4gIHRleHRCYXNlbGluZTogXCJhbHBoYWJldGljXCJcbn0pO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIF9UZXh0LnByb3RvdHlwZSwgXCJ4XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIF9UZXh0LnByb3RvdHlwZSwgXCJ5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8sIGNoYW5nZUNiOiAobykgPT4gby5vblRleHRDaGFuZ2UoKSB9KVxuXSwgX1RleHQucHJvdG90eXBlLCBcInRleHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUZvbnRDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgX1RleHQucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lRm9udENoYW5nZURldGVjdGlvbigpXG5dLCBfVGV4dC5wcm90b3R5cGUsIFwiZm9udFdlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lRm9udENoYW5nZURldGVjdGlvbigpXG5dLCBfVGV4dC5wcm90b3R5cGUsIFwiZm9udFNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUZvbnRDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgX1RleHQucHJvdG90eXBlLCBcImZvbnRGYW1pbHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgX1RleHQucHJvdG90eXBlLCBcInRleHRBbGlnblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBfVGV4dC5wcm90b3R5cGUsIFwidGV4dEJhc2VsaW5lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIF9UZXh0LnByb3RvdHlwZSwgXCJsaW5lSGVpZ2h0XCIsIDIpO1xudmFyIFRleHQgPSBfVGV4dDtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvdXRpbC9sYWJlbFBsYWNlbWVudC50c1xuZnVuY3Rpb24gY2lyY2xlUmVjdE92ZXJsYXAoYywgdW5pdENlbnRlciwgeCwgeSwgdywgaCkge1xuICBpZiAoYy5zaXplID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBjeCA9IGMueDtcbiAgbGV0IGN5ID0gYy55O1xuICBpZiAodW5pdENlbnRlciAhPSBudWxsKSB7XG4gICAgY3ggLT0gKHVuaXRDZW50ZXIueCAtIDAuNSkgKiBjLnNpemU7XG4gICAgY3kgLT0gKHVuaXRDZW50ZXIueSAtIDAuNSkgKiBjLnNpemU7XG4gIH1cbiAgbGV0IGVkZ2VYID0gY3g7XG4gIGlmIChjeCA8IHgpIHtcbiAgICBlZGdlWCA9IHg7XG4gIH0gZWxzZSBpZiAoY3ggPiB4ICsgdykge1xuICAgIGVkZ2VYID0geCArIHc7XG4gIH1cbiAgbGV0IGVkZ2VZID0gY3k7XG4gIGlmIChjeSA8IHkpIHtcbiAgICBlZGdlWSA9IHk7XG4gIH0gZWxzZSBpZiAoY3kgPiB5ICsgaCkge1xuICAgIGVkZ2VZID0geSArIGg7XG4gIH1cbiAgY29uc3QgZHggPSBjeCAtIGVkZ2VYO1xuICBjb25zdCBkeSA9IGN5IC0gZWRnZVk7XG4gIGNvbnN0IGQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICByZXR1cm4gZCA8PSBjLnNpemUgKiAwLjU7XG59XG5mdW5jdGlvbiByZWN0UmVjdE92ZXJsYXAocjEsIHgyLCB5MiwgdzIsIGgyKSB7XG4gIGNvbnN0IHhPdmVybGFwID0gcjEueCArIHIxLndpZHRoID4geDIgJiYgcjEueCA8IHgyICsgdzI7XG4gIGNvbnN0IHlPdmVybGFwID0gcjEueSArIHIxLmhlaWdodCA+IHkyICYmIHIxLnkgPCB5MiArIGgyO1xuICByZXR1cm4geE92ZXJsYXAgJiYgeU92ZXJsYXA7XG59XG5mdW5jdGlvbiByZWN0Q29udGFpbnNSZWN0KHIxLCByMngsIHIyeSwgcjJ3LCByMmgpIHtcbiAgcmV0dXJuIHIyeCArIHIydyA8IHIxLnggKyByMS53aWR0aCAmJiByMnggPiByMS54ICYmIHIyeSA+IHIxLnkgJiYgcjJ5ICsgcjJoIDwgcjEueSArIHIxLmhlaWdodDtcbn1cbmZ1bmN0aW9uIGlzUG9pbnRMYWJlbERhdHVtKHgpIHtcbiAgcmV0dXJuIHggIT0gbnVsbCAmJiB0eXBlb2YgeC5wb2ludCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgeC5sYWJlbCA9PT0gXCJvYmplY3RcIjtcbn1cbnZhciBsYWJlbFBsYWNlbWVudHMgPSB7XG4gIHRvcDogeyB4OiAwLCB5OiAtMSB9LFxuICBib3R0b206IHsgeDogMCwgeTogMSB9LFxuICBsZWZ0OiB7IHg6IC0xLCB5OiAwIH0sXG4gIHJpZ2h0OiB7IHg6IDEsIHk6IDAgfVxufTtcbmZ1bmN0aW9uIHBsYWNlTGFiZWxzKGRhdGEsIGJvdW5kcywgcGFkZGluZyA9IDUpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGRhdGEgPSBkYXRhLm1hcCgoZCkgPT4gZC5zbGljZSgpLnNvcnQoKGEsIGIpID0+IGIucG9pbnQuc2l6ZSAtIGEucG9pbnQuc2l6ZSkpO1xuICBmb3IgKGxldCBqID0gMDsgaiA8IGRhdGEubGVuZ3RoOyBqKyspIHtcbiAgICBjb25zdCBsYWJlbHMgPSByZXN1bHRbal0gPSBbXTtcbiAgICBjb25zdCBkYXR1bSA9IGRhdGFbal07XG4gICAgaWYgKCEoZGF0dW0/Lmxlbmd0aCAmJiBkYXR1bVswXS5sYWJlbCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IgKGxldCBpbmRleCA9IDAsIGxuID0gZGF0dW0ubGVuZ3RoOyBpbmRleCA8IGxuOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBkID0gZGF0dW1baW5kZXhdO1xuICAgICAgY29uc3QgeyBwb2ludCwgbGFiZWwsIG1hcmtlciB9ID0gZDtcbiAgICAgIGNvbnN0IHsgdGV4dCwgd2lkdGgsIGhlaWdodCB9ID0gbGFiZWw7XG4gICAgICBjb25zdCByID0gcG9pbnQuc2l6ZSAqIDAuNTtcbiAgICAgIGxldCBkeCA9IDA7XG4gICAgICBsZXQgZHkgPSAwO1xuICAgICAgaWYgKHIgPiAwICYmIGQucGxhY2VtZW50ICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgcGxhY2VtZW50ID0gbGFiZWxQbGFjZW1lbnRzW2QucGxhY2VtZW50XTtcbiAgICAgICAgZHggPSAod2lkdGggKiAwLjUgKyByICsgcGFkZGluZykgKiBwbGFjZW1lbnQueDtcbiAgICAgICAgZHkgPSAoaGVpZ2h0ICogMC41ICsgciArIHBhZGRpbmcpICogcGxhY2VtZW50Lnk7XG4gICAgICB9XG4gICAgICBjb25zdCB4ID0gcG9pbnQueCAtIHdpZHRoICogMC41ICsgZHggLSAoKG1hcmtlcj8uY2VudGVyLnggPz8gMC41KSAtIDAuNSkgKiBwb2ludC5zaXplO1xuICAgICAgY29uc3QgeSA9IHBvaW50LnkgLSBoZWlnaHQgKiAwLjUgKyBkeSAtICgobWFya2VyPy5jZW50ZXIueSA/PyAwLjUpIC0gMC41KSAqIHBvaW50LnNpemU7XG4gICAgICBjb25zdCB3aXRoaW5Cb3VuZHMgPSAhYm91bmRzIHx8IHJlY3RDb250YWluc1JlY3QoYm91bmRzLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGlmICghd2l0aGluQm91bmRzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3ZlcmxhcFBvaW50cyA9IGRhdGEuc29tZShcbiAgICAgICAgKGRhdGFEYXR1bXMpID0+IGRhdGFEYXR1bXMuc29tZShcbiAgICAgICAgICAoZGF0YURhdHVtKSA9PiBjaXJjbGVSZWN0T3ZlcmxhcChkYXRhRGF0dW0ucG9pbnQsIGRhdGFEYXR1bS5tYXJrZXI/LmNlbnRlciwgeCwgeSwgd2lkdGgsIGhlaWdodClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGlmIChvdmVybGFwUG9pbnRzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3ZlcmxhcExhYmVscyA9IHJlc3VsdC5zb21lKChsMikgPT4gbDIuc29tZSgobDMpID0+IHJlY3RSZWN0T3ZlcmxhcChsMywgeCwgeSwgd2lkdGgsIGhlaWdodCkpKTtcbiAgICAgIGlmIChvdmVybGFwTGFiZWxzKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGFiZWxzLnB1c2goeyBpbmRleCwgdGV4dCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgZGF0dW06IGQgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBheGlzTGFiZWxzT3ZlcmxhcChkYXRhLCBwYWRkaW5nKSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgZGF0YS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBkYXR1bSA9IGRhdGFbaW5kZXhdO1xuICAgIGNvbnN0IHtcbiAgICAgIHBvaW50OiB7IHgsIHkgfSxcbiAgICAgIGxhYmVsOiB7IHRleHQgfVxuICAgIH0gPSBkYXR1bTtcbiAgICBsZXQgeyB3aWR0aCwgaGVpZ2h0IH0gPSBkYXR1bS5sYWJlbDtcbiAgICB3aWR0aCArPSBwYWRkaW5nID8/IDA7XG4gICAgaGVpZ2h0ICs9IHBhZGRpbmcgPz8gMDtcbiAgICBpZiAocmVzdWx0LnNvbWUoKGwpID0+IHJlY3RSZWN0T3ZlcmxhcChsLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXN1bHQucHVzaCh7IGluZGV4LCB0ZXh0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBkYXR1bSB9KTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvZXF1YWwudHNcbmZ1bmN0aW9uIGFyZUFycmF5TnVtYmVyc0VxdWFsKGFyckEsIGFyckIpIHtcbiAgcmV0dXJuIGFyckEubGVuZ3RoID09PSBhcnJCLmxlbmd0aCAmJiBhcnJBLmV2ZXJ5KChpdGVtLCBpKSA9PiBOdW1iZXIoaXRlbSkgPT09IE51bWJlcihhcnJCW2ldKSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvcHJveHkudHNcbmZ1bmN0aW9uIFByb3h5UHJvcGVydHkocHJveHlQYXRoLCBjb25maWdNZXRhZGF0YSkge1xuICBjb25zdCBwYXRoQXJyYXkgPSBpc0FycmF5KHByb3h5UGF0aCkgPyBwcm94eVBhdGggOiBwcm94eVBhdGguc3BsaXQoXCIuXCIpO1xuICBpZiAocGF0aEFycmF5Lmxlbmd0aCA9PT0gMSkge1xuICAgIGNvbnN0IFtwcm9wZXJ0eV0gPSBwYXRoQXJyYXk7XG4gICAgcmV0dXJuIGFkZFRyYW5zZm9ybVRvSW5zdGFuY2VQcm9wZXJ0eShcbiAgICAgICh0YXJnZXQsIF8sIHZhbHVlKSA9PiB0YXJnZXRbcHJvcGVydHldID0gdmFsdWUsXG4gICAgICAodGFyZ2V0KSA9PiB0YXJnZXRbcHJvcGVydHldLFxuICAgICAgY29uZmlnTWV0YWRhdGFcbiAgICApO1xuICB9XG4gIHJldHVybiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoXG4gICAgKHRhcmdldCwgXywgdmFsdWUpID0+IHNldFBhdGgodGFyZ2V0LCBwYXRoQXJyYXksIHZhbHVlKSxcbiAgICAodGFyZ2V0KSA9PiBnZXRQYXRoKHRhcmdldCwgcGF0aEFycmF5KSxcbiAgICBjb25maWdNZXRhZGF0YVxuICApO1xufVxuZnVuY3Rpb24gUHJveHlPbldyaXRlKHByb3h5UHJvcGVydHkpIHtcbiAgcmV0dXJuIGFkZFRyYW5zZm9ybVRvSW5zdGFuY2VQcm9wZXJ0eSgodGFyZ2V0LCBfLCB2YWx1ZSkgPT4gdGFyZ2V0W3Byb3h5UHJvcGVydHldID0gdmFsdWUpO1xufVxuZnVuY3Rpb24gUHJveHlQcm9wZXJ0eU9uV3JpdGUoY2hpbGROYW1lLCBjaGlsZFByb3BlcnR5KSB7XG4gIHJldHVybiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoKHRhcmdldCwga2V5LCB2YWx1ZSkgPT4gdGFyZ2V0W2NoaWxkTmFtZV1bY2hpbGRQcm9wZXJ0eSA/PyBrZXldID0gdmFsdWUpO1xufVxuZnVuY3Rpb24gQWN0aW9uT25TZXQob3B0cykge1xuICBjb25zdCB7IG5ld1ZhbHVlOiBuZXdWYWx1ZUZuLCBvbGRWYWx1ZTogb2xkVmFsdWVGbiwgY2hhbmdlVmFsdWU6IGNoYW5nZVZhbHVlRm4gfSA9IG9wdHM7XG4gIHJldHVybiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoKHRhcmdldCwgXywgbmV3VmFsdWUsIG9sZFZhbHVlKSA9PiB7XG4gICAgaWYgKG5ld1ZhbHVlICE9PSBvbGRWYWx1ZSkge1xuICAgICAgaWYgKG9sZFZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgb2xkVmFsdWVGbj8uY2FsbCh0YXJnZXQsIG9sZFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdWYWx1ZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgIG5ld1ZhbHVlRm4/LmNhbGwodGFyZ2V0LCBuZXdWYWx1ZSk7XG4gICAgICB9XG4gICAgICBjaGFuZ2VWYWx1ZUZuPy5jYWxsKHRhcmdldCwgbmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIE9ic2VydmVDaGFuZ2VzKG9ic2VydmVyRm4pIHtcbiAgcmV0dXJuIGFkZE9ic2VydmVyVG9JbnN0YW5jZVByb3BlcnR5KG9ic2VydmVyRm4pO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3N0YXRlTWFjaGluZS50c1xudmFyIGRlYnVnQ29sb3IgPSBcImNvbG9yOiBncmVlblwiO1xudmFyIGRlYnVnUXVpZXRDb2xvciA9IFwiY29sb3I6IGdyZXlcIjtcbnZhciBfU3RhdGVNYWNoaW5lID0gY2xhc3MgX1N0YXRlTWFjaGluZSB7XG4gIGNvbnN0cnVjdG9yKGRlZmF1bHRTdGF0ZSwgc3RhdGVzLCBlbnRlckVhY2gpIHtcbiAgICB0aGlzLmRlZmF1bHRTdGF0ZSA9IGRlZmF1bHRTdGF0ZTtcbiAgICB0aGlzLnN0YXRlcyA9IHN0YXRlcztcbiAgICB0aGlzLmVudGVyRWFjaCA9IGVudGVyRWFjaDtcbiAgICB0aGlzLmRlYnVnID0gRGVidWcuY3JlYXRlKHRydWUsIFwiYW5pbWF0aW9uXCIpO1xuICAgIHRoaXMuc3RhdGUgPSBkZWZhdWx0U3RhdGU7XG4gICAgdGhpcy5kZWJ1ZyhgJWMke3RoaXMuY29uc3RydWN0b3IubmFtZX0gfCBpbml0IC0+ICR7ZGVmYXVsdFN0YXRlfWAsIGRlYnVnQ29sb3IpO1xuICB9XG4gIHRyYW5zaXRpb24oZXZlbnQsIGRhdGEpIHtcbiAgICBjb25zdCBzaG91bGRUcmFuc2l0aW9uU2VsZiA9IHRoaXMudHJhbnNpdGlvbkNoaWxkKGV2ZW50LCBkYXRhKTtcbiAgICBpZiAoIXNob3VsZFRyYW5zaXRpb25TZWxmIHx8IHRoaXMuc3RhdGUgPT09IF9TdGF0ZU1hY2hpbmUuY2hpbGQgfHwgdGhpcy5zdGF0ZSA9PT0gX1N0YXRlTWFjaGluZS5wYXJlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBjdXJyZW50U3RhdGVDb25maWcgPSB0aGlzLnN0YXRlc1t0aGlzLnN0YXRlXTtcbiAgICBsZXQgZGVzdGluYXRpb24gPSBjdXJyZW50U3RhdGVDb25maWdbZXZlbnRdO1xuICAgIGNvbnN0IGRlYnVnUHJlZml4ID0gYCVjJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9IHwgJHt0aGlzLnN0YXRlfSAtPiAke2V2ZW50fSAtPmA7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVzdGluYXRpb24pKSB7XG4gICAgICBkZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uLmZpbmQoKHRyYW5zaXRpb24pID0+IHtcbiAgICAgICAgaWYgKCF0cmFuc2l0aW9uLmd1YXJkKVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCB2YWxpZCA9IHRyYW5zaXRpb24uZ3VhcmQoZGF0YSk7XG4gICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICB0aGlzLmRlYnVnKGAke2RlYnVnUHJlZml4fSAke3RyYW5zaXRpb24udGFyZ2V0fSAoZ3VhcmRlZClgLCBkZWJ1Z1F1aWV0Q29sb3IpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWxpZDtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3RpbmF0aW9uID09PSBcIm9iamVjdFwiICYmICEoZGVzdGluYXRpb24gaW5zdGFuY2VvZiBfU3RhdGVNYWNoaW5lKSAmJiBkZXN0aW5hdGlvbi5ndWFyZCAmJiAhZGVzdGluYXRpb24uZ3VhcmQoZGF0YSkpIHtcbiAgICAgIHRoaXMuZGVidWcoYCR7ZGVidWdQcmVmaXh9ICR7ZGVzdGluYXRpb24udGFyZ2V0fSAoZ3VhcmRlZClgLCBkZWJ1Z1F1aWV0Q29sb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWRlc3RpbmF0aW9uKSB7XG4gICAgICB0aGlzLmRlYnVnKGAke2RlYnVnUHJlZml4fSAke3RoaXMuc3RhdGV9YCwgZGVidWdRdWlldENvbG9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGVzdGluYXRpb25TdGF0ZSA9IHRoaXMuZ2V0RGVzdGluYXRpb25TdGF0ZShkZXN0aW5hdGlvbik7XG4gICAgY29uc3QgZXhpdEZuID0gZGVzdGluYXRpb25TdGF0ZSA9PT0gdGhpcy5zdGF0ZSA/IHZvaWQgMCA6IGN1cnJlbnRTdGF0ZUNvbmZpZy5vbkV4aXQ7XG4gICAgdGhpcy5kZWJ1ZyhgJHtkZWJ1Z1ByZWZpeH0gJHtkZXN0aW5hdGlvblN0YXRlfWAsIGRlYnVnQ29sb3IpO1xuICAgIHRoaXMuc3RhdGUgPSBkZXN0aW5hdGlvblN0YXRlO1xuICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZGVzdGluYXRpb24oZGF0YSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVzdGluYXRpb24gPT09IFwib2JqZWN0XCIgJiYgIShkZXN0aW5hdGlvbiBpbnN0YW5jZW9mIF9TdGF0ZU1hY2hpbmUpKSB7XG4gICAgICBkZXN0aW5hdGlvbi5hY3Rpb24/LihkYXRhKTtcbiAgICB9XG4gICAgZXhpdEZuPy4oKTtcbiAgICB0aGlzLmVudGVyRWFjaD8uKGN1cnJlbnRTdGF0ZSwgZGVzdGluYXRpb25TdGF0ZSk7XG4gICAgaWYgKGRlc3RpbmF0aW9uU3RhdGUgIT09IGN1cnJlbnRTdGF0ZSAmJiBkZXN0aW5hdGlvblN0YXRlICE9PSBfU3RhdGVNYWNoaW5lLmNoaWxkICYmIGRlc3RpbmF0aW9uU3RhdGUgIT09IF9TdGF0ZU1hY2hpbmUucGFyZW50KSB7XG4gICAgICB0aGlzLnN0YXRlc1tkZXN0aW5hdGlvblN0YXRlXS5vbkVudGVyPy4oY3VycmVudFN0YXRlLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgaXModmFsdWUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gX1N0YXRlTWFjaGluZS5jaGlsZCAmJiB0aGlzLmNoaWxkU3RhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkU3RhdGUuaXModmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gdmFsdWU7XG4gIH1cbiAgcmVzZXRIaWVyYXJjaHkoKSB7XG4gICAgdGhpcy5kZWJ1ZyhcbiAgICAgIGAlYyR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSB8ICR7dGhpcy5zdGF0ZX0gLT4gW3Jlc2V0SGllcmFyY2h5XSAtPiAke3RoaXMuZGVmYXVsdFN0YXRlfWAsXG4gICAgICBcImNvbG9yOiBncmVlblwiXG4gICAgKTtcbiAgICB0aGlzLnN0YXRlID0gdGhpcy5kZWZhdWx0U3RhdGU7XG4gIH1cbiAgdHJhbnNpdGlvbkNoaWxkKGV2ZW50LCBkYXRhKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IF9TdGF0ZU1hY2hpbmUuY2hpbGQgfHwgIXRoaXMuY2hpbGRTdGF0ZSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIHRoaXMuY2hpbGRTdGF0ZS50cmFuc2l0aW9uKGV2ZW50LCBkYXRhKTtcbiAgICBpZiAoIXRoaXMuY2hpbGRTdGF0ZS5pcyhfU3RhdGVNYWNoaW5lLnBhcmVudCkpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB0aGlzLmRlYnVnKGAlYyR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSB8ICR7dGhpcy5zdGF0ZX0gLT4gJHtldmVudH0gLT4gJHt0aGlzLmRlZmF1bHRTdGF0ZX1gLCBkZWJ1Z0NvbG9yKTtcbiAgICB0aGlzLnN0YXRlID0gdGhpcy5kZWZhdWx0U3RhdGU7XG4gICAgdGhpcy5zdGF0ZXNbdGhpcy5zdGF0ZV0ub25FbnRlcj8uKCk7XG4gICAgdGhpcy5jaGlsZFN0YXRlLnJlc2V0SGllcmFyY2h5KCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGdldERlc3RpbmF0aW9uU3RhdGUoZGVzdGluYXRpb24pIHtcbiAgICBsZXQgc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHN0YXRlID0gZGVzdGluYXRpb247XG4gICAgfSBlbHNlIGlmIChkZXN0aW5hdGlvbiBpbnN0YW5jZW9mIF9TdGF0ZU1hY2hpbmUpIHtcbiAgICAgIHRoaXMuY2hpbGRTdGF0ZSA9IGRlc3RpbmF0aW9uO1xuICAgICAgc3RhdGUgPSBfU3RhdGVNYWNoaW5lLmNoaWxkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3RpbmF0aW9uID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAoZGVzdGluYXRpb24udGFyZ2V0IGluc3RhbmNlb2YgX1N0YXRlTWFjaGluZSkge1xuICAgICAgICB0aGlzLmNoaWxkU3RhdGUgPSBkZXN0aW5hdGlvbi50YXJnZXQ7XG4gICAgICAgIHN0YXRlID0gX1N0YXRlTWFjaGluZS5jaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlID0gZGVzdGluYXRpb24udGFyZ2V0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGU7XG4gIH1cbn07XG5fU3RhdGVNYWNoaW5lLmNoaWxkID0gXCJfX2NoaWxkXCI7XG5fU3RhdGVNYWNoaW5lLnBhcmVudCA9IFwiX19wYXJlbnRcIjtcbnZhciBTdGF0ZU1hY2hpbmUgPSBfU3RhdGVNYWNoaW5lO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3RleHRXcmFwcGVyLnRzXG52YXIgVGV4dFdyYXBwZXIgPSBjbGFzcyB7XG4gIHN0YXRpYyB3cmFwVGV4dCh0ZXh0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMud3JhcExpbmVzKHRleHQsIG9wdGlvbnMpLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgc3RhdGljIHdyYXBMaW5lcyh0ZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2xpcHBlZFJlc3VsdCA9IHRoaXMudGV4dFdyYXAodGV4dCwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMub3ZlcmZsb3cgPT09IFwiaGlkZVwiICYmIGNsaXBwZWRSZXN1bHQuc29tZSgobCkgPT4gbC5lbmRzV2l0aChUZXh0VXRpbHMuRWxsaXBzaXNDaGFyKSkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGNsaXBwZWRSZXN1bHQ7XG4gIH1cbiAgc3RhdGljIGFwcGVuZEVsbGlwc2lzKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC9bLixdezEsNX0kLywgXCJcIikgKyBUZXh0VXRpbHMuRWxsaXBzaXNDaGFyO1xuICB9XG4gIHN0YXRpYyB0cnVuY2F0ZUxpbmUodGV4dCwgbWVhc3VyZXIsIG1heFdpZHRoLCBlbGxpcHNpc0ZvcmNlKSB7XG4gICAgY29uc3QgZWxsaXBzaXNXaWR0aCA9IG1lYXN1cmVyLnRleHRXaWR0aChUZXh0VXRpbHMuRWxsaXBzaXNDaGFyKTtcbiAgICBsZXQgZXN0aW1hdGVkV2lkdGggPSAwO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNoYXJXaWR0aCA9IG1lYXN1cmVyLnRleHRXaWR0aCh0ZXh0LmNoYXJBdChpKSk7XG4gICAgICBpZiAoZXN0aW1hdGVkV2lkdGggKyBjaGFyV2lkdGggPiBtYXhXaWR0aClcbiAgICAgICAgYnJlYWs7XG4gICAgICBlc3RpbWF0ZWRXaWR0aCArPSBjaGFyV2lkdGg7XG4gICAgfVxuICAgIGlmICh0ZXh0Lmxlbmd0aCA9PT0gaSAmJiAoIWVsbGlwc2lzRm9yY2UgfHwgZXN0aW1hdGVkV2lkdGggKyBlbGxpcHNpc1dpZHRoIDw9IG1heFdpZHRoKSkge1xuICAgICAgcmV0dXJuIGVsbGlwc2lzRm9yY2UgPyB0ZXh0ICsgVGV4dFV0aWxzLkVsbGlwc2lzQ2hhciA6IHRleHQ7XG4gICAgfVxuICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIGkpLnRyaW1FbmQoKTtcbiAgICB3aGlsZSAodGV4dC5sZW5ndGggJiYgbWVhc3VyZXIudGV4dFdpZHRoKHRleHQpICsgZWxsaXBzaXNXaWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICB0ZXh0ID0gdGV4dC5zbGljZSgwLCAtMSkudHJpbUVuZCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dCArIFRleHRVdGlscy5FbGxpcHNpc0NoYXI7XG4gIH1cbiAgc3RhdGljIHRleHRXcmFwKHRleHQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoVGV4dFV0aWxzLmxpbmVTcGxpdHRlcik7XG4gICAgY29uc3QgbWVhc3VyZXIgPSBDYWNoZWRUZXh0TWVhc3VyZXJQb29sLmdldE1lYXN1cmVyKG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLnRleHRXcmFwID09PSBcIm5ldmVyXCIpIHtcbiAgICAgIHJldHVybiBsaW5lcy5tYXAoKGxpbmUpID0+IHRoaXMudHJ1bmNhdGVMaW5lKGxpbmUudHJpbUVuZCgpLCBtZWFzdXJlciwgb3B0aW9ucy5tYXhXaWR0aCkpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCB3cmFwSHlwaGVuYXRlID0gb3B0aW9ucy50ZXh0V3JhcCA9PT0gXCJoeXBoZW5hdGVcIjtcbiAgICBjb25zdCB3cmFwT25TcGFjZSA9IG9wdGlvbnMudGV4dFdyYXAgPT0gbnVsbCB8fCBvcHRpb25zLnRleHRXcmFwID09PSBcIm9uLXNwYWNlXCI7XG4gICAgZm9yIChsZXQgbGluZSBvZiBsaW5lcykge1xuICAgICAgbGluZSA9IGxpbmUudHJpbUVuZCgpO1xuICAgICAgaWYgKGxpbmUgPT09IFwiXCIpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobGluZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDAsIGVzdGltYXRlZFdpZHRoID0gMCwgbGFzdFNwYWNlSW5kZXggPSAwOyBpIDwgbGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaGFyID0gbGluZS5jaGFyQXQoaSk7XG4gICAgICAgIGVzdGltYXRlZFdpZHRoICs9IG1lYXN1cmVyLnRleHRXaWR0aChjaGFyKTtcbiAgICAgICAgaWYgKGNoYXIgPT09IFwiIFwiKSB7XG4gICAgICAgICAgbGFzdFNwYWNlSW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlc3RpbWF0ZWRXaWR0aCA+IG9wdGlvbnMubWF4V2lkdGgpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNvbnN0IGFjdHVhbFdpZHRoID0gbWVhc3VyZXIudGV4dFdpZHRoKGxpbmUuc2xpY2UoMCwgaSArIDEpKTtcbiAgICAgICAgICBpZiAoYWN0dWFsV2lkdGggPD0gb3B0aW9ucy5tYXhXaWR0aCkge1xuICAgICAgICAgICAgZXN0aW1hdGVkV2lkdGggPSBhY3R1YWxXaWR0aDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGFzdFNwYWNlSW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRXb3JkID0gdGhpcy5nZXRXb3JkQXQobGluZSwgbGFzdFNwYWNlSW5kZXggKyAxKTtcbiAgICAgICAgICAgIGNvbnN0IHRleHRXaWR0aCA9IG1lYXN1cmVyLnRleHRXaWR0aChuZXh0V29yZCk7XG4gICAgICAgICAgICBpZiAodGV4dFdpZHRoIDw9IG9wdGlvbnMubWF4V2lkdGgpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobGluZS5zbGljZSgwLCBsYXN0U3BhY2VJbmRleCkudHJpbUVuZCgpKTtcbiAgICAgICAgICAgICAgbGluZSA9IGxpbmUuc2xpY2UobGFzdFNwYWNlSW5kZXgpLnRyaW1TdGFydCgpO1xuICAgICAgICAgICAgICBpID0gLTE7XG4gICAgICAgICAgICAgIGVzdGltYXRlZFdpZHRoID0gMDtcbiAgICAgICAgICAgICAgbGFzdFNwYWNlSW5kZXggPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAod3JhcE9uU3BhY2UgJiYgdGV4dFdpZHRoID4gb3B0aW9ucy5tYXhXaWR0aCkge1xuICAgICAgICAgICAgICByZXN1bHQucHVzaChcbiAgICAgICAgICAgICAgICBsaW5lLnNsaWNlKDAsIGxhc3RTcGFjZUluZGV4KS50cmltRW5kKCksXG4gICAgICAgICAgICAgICAgdGhpcy50cnVuY2F0ZUxpbmUoXG4gICAgICAgICAgICAgICAgICBsaW5lLnNsaWNlKGxhc3RTcGFjZUluZGV4KS50cmltU3RhcnQoKSxcbiAgICAgICAgICAgICAgICAgIG1lYXN1cmVyLFxuICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tYXhXaWR0aCxcbiAgICAgICAgICAgICAgICAgIHRydWVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh3cmFwT25TcGFjZSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy50cnVuY2F0ZUxpbmUobGluZSwgbWVhc3VyZXIsIG9wdGlvbnMubWF4V2lkdGgsIHRydWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHdyYXBPblNwYWNlKSB7XG4gICAgICAgICAgICBsaW5lID0gXCJcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBwb3N0Zml4ID0gd3JhcEh5cGhlbmF0ZSA/IFwiLVwiIDogXCJcIjtcbiAgICAgICAgICBsZXQgbmV3TGluZSA9IGxpbmUuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgICAgIHdoaWxlIChuZXdMaW5lLmxlbmd0aCAmJiBtZWFzdXJlci50ZXh0V2lkdGgobmV3TGluZSArIHBvc3RmaXgpID4gb3B0aW9ucy5tYXhXaWR0aCkge1xuICAgICAgICAgICAgbmV3TGluZSA9IG5ld0xpbmUuc2xpY2UoMCwgLTEpLnRyaW1FbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2gobmV3TGluZSArIHBvc3RmaXgpO1xuICAgICAgICAgIGlmICghbmV3TGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxpbmUgPSBcIlwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKG5ld0xpbmUubGVuZ3RoKS50cmltU3RhcnQoKTtcbiAgICAgICAgICBpID0gLTE7XG4gICAgICAgICAgZXN0aW1hdGVkV2lkdGggPSAwO1xuICAgICAgICAgIGxhc3RTcGFjZUluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobGluZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYXZvaWRPcnBoYW5zKHJlc3VsdCwgbWVhc3VyZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLmNsaXBMaW5lcyhyZXN1bHQsIG1lYXN1cmVyLCBvcHRpb25zKTtcbiAgfVxuICBzdGF0aWMgZ2V0V29yZEF0KHRleHQsIHBvc2l0aW9uKSB7XG4gICAgY29uc3QgbmV4dFNwYWNlSW5kZXggPSB0ZXh0LmluZGV4T2YoXCIgXCIsIHBvc2l0aW9uKTtcbiAgICByZXR1cm4gbmV4dFNwYWNlSW5kZXggPT09IC0xID8gdGV4dC5zbGljZShwb3NpdGlvbikgOiB0ZXh0LnNsaWNlKHBvc2l0aW9uLCBuZXh0U3BhY2VJbmRleCk7XG4gIH1cbiAgc3RhdGljIGNsaXBMaW5lcyhsaW5lcywgbWVhc3VyZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMubWF4SGVpZ2h0KSB7XG4gICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxuICAgIGNvbnN0IHsgaGVpZ2h0LCBsaW5lTWV0cmljcyB9ID0gbWVhc3VyZXIubWVhc3VyZUxpbmVzKGxpbmVzKTtcbiAgICBpZiAoaGVpZ2h0IDw9IG9wdGlvbnMubWF4SGVpZ2h0KSB7XG4gICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwLCBjdW11bGF0aXZlSGVpZ2h0ID0gMDsgaSA8IGxpbmVNZXRyaWNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB7IGxpbmVIZWlnaHQgfSA9IGxpbmVNZXRyaWNzW2ldO1xuICAgICAgY3VtdWxhdGl2ZUhlaWdodCArPSBsaW5lSGVpZ2h0O1xuICAgICAgaWYgKGN1bXVsYXRpdmVIZWlnaHQgPiBvcHRpb25zLm1heEhlaWdodCkge1xuICAgICAgICBpZiAob3B0aW9ucy5vdmVyZmxvdyA9PT0gXCJoaWRlXCIpIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2xpcHBlZFJlc3VsdHMgPSBsaW5lcy5zbGljZSgwLCBpIHx8IDEpO1xuICAgICAgICBjb25zdCBsYXN0TGluZSA9IGNsaXBwZWRSZXN1bHRzLnBvcCgpO1xuICAgICAgICByZXR1cm4gY2xpcHBlZFJlc3VsdHMuY29uY2F0KHRoaXMudHJ1bmNhdGVMaW5lKGxhc3RMaW5lLCBtZWFzdXJlciwgb3B0aW9ucy5tYXhXaWR0aCwgdHJ1ZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGluZXM7XG4gIH1cbiAgc3RhdGljIGF2b2lkT3JwaGFucyhsaW5lcywgbWVhc3VyZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5hdm9pZE9ycGhhbnMgPT09IGZhbHNlIHx8IGxpbmVzLmxlbmd0aCA8IDIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBsZW5ndGg6IGxlbmd0aDIgfSA9IGxpbmVzO1xuICAgIGNvbnN0IGxhc3RMaW5lID0gbGluZXNbbGVuZ3RoMiAtIDFdO1xuICAgIGNvbnN0IGJlZm9yZUxhc3QgPSBsaW5lc1tsZW5ndGgyIC0gMl07XG4gICAgaWYgKGJlZm9yZUxhc3QubGVuZ3RoIDwgbGFzdExpbmUubGVuZ3RoKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGxhc3RTcGFjZUluZGV4ID0gYmVmb3JlTGFzdC5sYXN0SW5kZXhPZihcIiBcIik7XG4gICAgaWYgKGxhc3RTcGFjZUluZGV4ID09PSAtMSB8fCBsYXN0U3BhY2VJbmRleCA9PT0gYmVmb3JlTGFzdC5pbmRleE9mKFwiIFwiKSB8fCBsYXN0TGluZS5pbmNsdWRlcyhcIiBcIikpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbGFzdFdvcmQgPSBiZWZvcmVMYXN0LnNsaWNlKGxhc3RTcGFjZUluZGV4ICsgMSk7XG4gICAgaWYgKG1lYXN1cmVyLnRleHRXaWR0aChsYXN0TGluZSArIGxhc3RXb3JkKSA8PSBvcHRpb25zLm1heFdpZHRoKSB7XG4gICAgICBsaW5lc1tsZW5ndGgyIC0gMl0gPSBiZWZvcmVMYXN0LnNsaWNlKDAsIGxhc3RTcGFjZUluZGV4KTtcbiAgICAgIGxpbmVzW2xlbmd0aDIgLSAxXSA9IGxhc3RXb3JkICsgXCIgXCIgKyBsYXN0TGluZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvYXR0cmlidXRlVXRpbC50c1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlKGUsIHF1YWxpZmllZE5hbWUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwIHx8IHZhbHVlID09PSBcIlwiKSB7XG4gICAgZT8ucmVtb3ZlQXR0cmlidXRlKHF1YWxpZmllZE5hbWUpO1xuICB9IGVsc2Uge1xuICAgIGU/LnNldEF0dHJpYnV0ZShxdWFsaWZpZWROYW1lLCB2YWx1ZS50b1N0cmluZygpKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0VmlzaWJpbGl0eShlbGVtZW50MiwgaGlkZGVuVG9rZW4sIGhpZGRlbikge1xuICBlbGVtZW50Mi5hcmlhSGlkZGVuID0gYCR7aGlkZGVufWA7XG4gIGVsZW1lbnQyLmNsYXNzTGlzdC50b2dnbGUoaGlkZGVuVG9rZW4sIGhpZGRlbik7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvcGxhY2VtZW50LnRzXG5mdW5jdGlvbiBjYWxjdWxhdGVQbGFjZW1lbnQobmF0dXJhbFdpZHRoLCBuYXR1cmFsSGVpZ2h0LCBjb250YWluZXIsIGJvdW5kcykge1xuICBsZXQgeyB0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHdpZHRoLCBoZWlnaHQgfSA9IGJvdW5kcztcbiAgaWYgKGxlZnQgIT0gbnVsbCkge1xuICAgIGlmICh3aWR0aCAhPSBudWxsKSB7XG4gICAgICByaWdodCA9IGNvbnRhaW5lci53aWR0aCAtIGxlZnQgKyB3aWR0aDtcbiAgICB9IGVsc2UgaWYgKHJpZ2h0ICE9IG51bGwpIHtcbiAgICAgIHdpZHRoID0gY29udGFpbmVyLndpZHRoIC0gbGVmdCAtIHJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChyaWdodCAhPSBudWxsICYmIHdpZHRoICE9IG51bGwpIHtcbiAgICBsZWZ0ID0gY29udGFpbmVyLndpZHRoIC0gcmlnaHQgLSB3aWR0aDtcbiAgfVxuICBpZiAodG9wICE9IG51bGwpIHtcbiAgICBpZiAoaGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgIGJvdHRvbSA9IGNvbnRhaW5lci5oZWlnaHQgLSB0b3AgLSBoZWlnaHQ7XG4gICAgfSBlbHNlIGlmIChib3R0b20gIT0gbnVsbCkge1xuICAgICAgaGVpZ2h0ID0gY29udGFpbmVyLmhlaWdodCAtIGJvdHRvbSAtIHRvcDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYm90dG9tICE9IG51bGwgJiYgaGVpZ2h0ICE9IG51bGwpIHtcbiAgICB0b3AgPSBjb250YWluZXIuaGVpZ2h0IC0gYm90dG9tIC0gaGVpZ2h0O1xuICB9XG4gIGlmICh3aWR0aCA9PSBudWxsKSB7XG4gICAgaWYgKGhlaWdodCA9PSBudWxsKSB7XG4gICAgICB3aWR0aCA9IG5hdHVyYWxXaWR0aDtcbiAgICAgIGhlaWdodCA9IG5hdHVyYWxIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gTWF0aC5jZWlsKG5hdHVyYWxXaWR0aCAqIGhlaWdodCAvIG5hdHVyYWxIZWlnaHQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChoZWlnaHQgPT0gbnVsbCkge1xuICAgIGhlaWdodCA9IE1hdGguY2VpbChuYXR1cmFsSGVpZ2h0ICogd2lkdGggLyBuYXR1cmFsV2lkdGgpO1xuICB9XG4gIGlmIChsZWZ0ID09IG51bGwpIHtcbiAgICBpZiAocmlnaHQgPT0gbnVsbCkge1xuICAgICAgbGVmdCA9IE1hdGguZmxvb3IoKGNvbnRhaW5lci53aWR0aCAtIHdpZHRoKSAvIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gY29udGFpbmVyLndpZHRoIC0gcmlnaHQgLSB3aWR0aDtcbiAgICB9XG4gIH1cbiAgaWYgKHRvcCA9PSBudWxsKSB7XG4gICAgaWYgKGJvdHRvbSA9PSBudWxsKSB7XG4gICAgICB0b3AgPSBNYXRoLmZsb29yKChjb250YWluZXIuaGVpZ2h0IC0gaGVpZ2h0KSAvIDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3AgPSBjb250YWluZXIuaGVpZ2h0IC0gaGVpZ2h0IC0gYm90dG9tO1xuICAgIH1cbiAgfVxuICByZXR1cm4geyB4OiBsZWZ0LCB5OiB0b3AsIHdpZHRoLCBoZWlnaHQgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdG9vbHRpcC90b29sdGlwLnRzXG52YXIgREVGQVVMVF9UT09MVElQX0NMQVNTID0gXCJhZy1jaGFydC10b29sdGlwXCI7XG52YXIgREVGQVVMVF9UT09MVElQX0RBUktfQ0xBU1MgPSBcImFnLWNoYXJ0LWRhcmstdG9vbHRpcFwiO1xudmFyIEVNUFRZX1RPT0xUSVBfQ09OVEVOVCA9IHsgaHRtbDogXCJcIiwgYXJpYUxhYmVsOiBcIlwiIH07XG5mdW5jdGlvbiB0b0FjY2Vzc2libGVUZXh0KGlucHV0SHRtbCkge1xuICBjb25zdCBsaW5lQ29udmVydGVyID0gKF9tYXRjaCwgb2Zmc2V0NCwgc3RyKSA9PiB7XG4gICAgaWYgKG9mZnNldDQgPT09IDAgfHwgc3RyW29mZnNldDQgLSAxXSAhPT0gXCIuXCIpIHtcbiAgICAgIHJldHVybiBcIi4gXCI7XG4gICAgfVxuICAgIHJldHVybiBcIiBcIjtcbiAgfTtcbiAgcmV0dXJuIGlucHV0SHRtbC5yZXBsYWNlKC88YnJcXHMqXFwvPz4vZywgbGluZUNvbnZlcnRlcikucmVwbGFjZSgvPFxcL3BcXHMrPi9nLCBsaW5lQ29udmVydGVyKS5yZXBsYWNlKC88XFwvbGlcXHMqPi9nLCBsaW5lQ29udmVydGVyKS5yZXBsYWNlKC88W148Pl0rPi9nLCBcIlwiKS5yZXBsYWNlKC9cXG4rL2csIFwiIFwiKS5yZXBsYWNlKC9cXHMrL2csIFwiIFwiKTtcbn1cbmZ1bmN0aW9uIHRvVG9vbHRpcEh0bWwoaW5wdXQsIGRlZmF1bHRzKSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4geyBodG1sOiBpbnB1dCwgYXJpYUxhYmVsOiBpbnB1dCB9O1xuICB9XG4gIGNvbnN0IHtcbiAgICBjb250ZW50ID0gZGVmYXVsdHM/LmNvbnRlbnQgPz8gXCJcIixcbiAgICB0aXRsZSA9IGRlZmF1bHRzPy50aXRsZSxcbiAgICBjb2xvciA9IGRlZmF1bHRzPy5jb2xvciA/PyBcIndoaXRlXCIsXG4gICAgYmFja2dyb3VuZENvbG9yID0gZGVmYXVsdHM/LmJhY2tncm91bmRDb2xvciA/PyBcIiM4ODhcIlxuICB9ID0gaW5wdXQ7XG4gIGNvbnN0IHRpdGxlSHRtbCA9IHRpdGxlID8gYDxkaXYgY2xhc3M9XCIke0RFRkFVTFRfVE9PTFRJUF9DTEFTU30tdGl0bGVcIlxuICAgICAgICBzdHlsZT1cImNvbG9yOiAke2NvbG9yfTsgYmFja2dyb3VuZC1jb2xvcjogJHtiYWNrZ3JvdW5kQ29sb3J9XCI+JHt0aXRsZX08L2Rpdj5gIDogXCJcIjtcbiAgY29uc3QgdGl0bGVBcmlhID0gdGl0bGUgPyBgJHt0aXRsZX06IGAgOiBcIlwiO1xuICBjb25zdCBjb250ZW50SHRtbCA9IGNvbnRlbnQgPyBgPGRpdiBjbGFzcz1cIiR7REVGQVVMVF9UT09MVElQX0NMQVNTfS1jb250ZW50XCI+JHtjb250ZW50fTwvZGl2PmAgOiBcIlwiO1xuICByZXR1cm4ge1xuICAgIGh0bWw6IGAke3RpdGxlSHRtbH0ke2NvbnRlbnRIdG1sfWAsXG4gICAgYXJpYUxhYmVsOiB0b0FjY2Vzc2libGVUZXh0KGAke3RpdGxlQXJpYX0ke2NvbnRlbnR9YClcbiAgfTtcbn1cbnZhciBUb29sdGlwUG9zaXRpb24gPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAvKiogVGhlIHR5cGUgb2YgcG9zaXRpb25pbmcgZm9yIHRoZSB0b29sdGlwLiBCeSBkZWZhdWx0LCB0aGUgdG9vbHRpcCBmb2xsb3dzIHRoZSBwb2ludGVyLiAqL1xuICAgIHRoaXMudHlwZSA9IFwicG9pbnRlclwiO1xuICAgIC8qKiBUaGUgaG9yaXpvbnRhbCBvZmZzZXQgaW4gcGl4ZWxzIGZvciB0aGUgcG9zaXRpb24gb2YgdGhlIHRvb2x0aXAuICovXG4gICAgdGhpcy54T2Zmc2V0ID0gMDtcbiAgICAvKiogVGhlIHZlcnRpY2FsIG9mZnNldCBpbiBwaXhlbHMgZm9yIHRoZSBwb3NpdGlvbiBvZiB0aGUgdG9vbHRpcC4gKi9cbiAgICB0aGlzLnlPZmZzZXQgPSAwO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoXG4gICAgVU5JT04oXG4gICAgICBbXG4gICAgICAgIFwicG9pbnRlclwiLFxuICAgICAgICBcIm5vZGVcIixcbiAgICAgICAgXCJ0b3BcIixcbiAgICAgICAgXCJyaWdodFwiLFxuICAgICAgICBcImJvdHRvbVwiLFxuICAgICAgICBcImxlZnRcIixcbiAgICAgICAgXCJ0b3AtbGVmdFwiLFxuICAgICAgICBcInRvcC1yaWdodFwiLFxuICAgICAgICBcImJvdHRvbS1yaWdodFwiLFxuICAgICAgICBcImJvdHRvbS1sZWZ0XCJcbiAgICAgIF0sXG4gICAgICBcImEgcG9zaXRpb24gdHlwZVwiXG4gICAgKVxuICApXG5dLCBUb29sdGlwUG9zaXRpb24ucHJvdG90eXBlLCBcInR5cGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBUb29sdGlwUG9zaXRpb24ucHJvdG90eXBlLCBcInhPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBUb29sdGlwUG9zaXRpb24ucHJvdG90eXBlLCBcInlPZmZzZXRcIiwgMik7XG52YXIgVG9vbHRpcCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5kZWxheSA9IDA7XG4gICAgdGhpcy5yYW5nZSA9IHZvaWQgMDtcbiAgICB0aGlzLndyYXBwaW5nID0gXCJoeXBoZW5hdGVcIjtcbiAgICB0aGlzLnBvc2l0aW9uID0gbmV3IFRvb2x0aXBQb3NpdGlvbigpO1xuICAgIHRoaXMuZGFya1RoZW1lID0gZmFsc2U7XG4gICAgdGhpcy5ib3VuZHMgPSBcImV4dGVuZGVkXCI7XG4gICAgdGhpcy5lbmFibGVJbnRlcmFjdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMubGFzdFZpc2liaWxpdHlDaGFuZ2UgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMud3JhcFR5cGVzID0gW1wiYWx3YXlzXCIsIFwiaHlwaGVuYXRlXCIsIFwib24tc3BhY2VcIiwgXCJuZXZlclwiXTtcbiAgICB0aGlzLnNob3dUaW1lb3V0ID0gMDtcbiAgICB0aGlzLl9zaG93QXJyb3cgPSB0cnVlO1xuICB9XG4gIGdldCBpbnRlcmFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmFibGVJbnRlcmFjdGlvbjtcbiAgfVxuICBzZXR1cChkb21NYW5hZ2VyKSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZG9tTWFuYWdlci5hZGRDaGlsZChcImNhbnZhcy1vdmVybGF5XCIsIERFRkFVTFRfVE9PTFRJUF9DTEFTUyk7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoREVGQVVMVF9UT09MVElQX0NMQVNTKTtcbiAgICBzZXRBdHRyaWJ1dGUodGhpcy5lbGVtZW50LCBcImFyaWEtaGlkZGVuXCIsIHRydWUpO1xuICB9XG4gIGRlc3Ryb3koZG9tTWFuYWdlcikge1xuICAgIGRvbU1hbmFnZXIucmVtb3ZlQ2hpbGQoXCJjYW52YXMtb3ZlcmxheVwiLCBERUZBVUxUX1RPT0xUSVBfQ0xBU1MpO1xuICB9XG4gIGlzVmlzaWJsZSgpIHtcbiAgICByZXR1cm4gIXRoaXMuZWxlbWVudD8uY2xhc3NMaXN0LmNvbnRhaW5zKERFRkFVTFRfVE9PTFRJUF9DTEFTUyArIFwiLWhpZGRlblwiKTtcbiAgfVxuICAvKipcbiAgICogU2hvd3MgdG9vbHRpcCBhdCB0aGUgZ2l2ZW4gZXZlbnQncyBjb29yZGluYXRlcy5cbiAgICogSWYgdGhlIGBodG1sYCBwYXJhbWV0ZXIgaXMgbWlzc2luZywgbW92ZXMgdGhlIGV4aXN0aW5nIHRvb2x0aXAgdG8gdGhlIG5ldyBwb3NpdGlvbi5cbiAgICovXG4gIHNob3coYm91bmRpbmdSZWN0LCBjYW52YXNSZWN0LCBtZXRhLCBjb250ZW50LCBpbnN0YW50bHkgPSBmYWxzZSkge1xuICAgIGNvbnN0IHsgZWxlbWVudDogZWxlbWVudDIgfSA9IHRoaXM7XG4gICAgaWYgKGNvbnRlbnQgIT0gbnVsbCAmJiBlbGVtZW50MiAhPSBudWxsKSB7XG4gICAgICBlbGVtZW50Mi5pbm5lckhUTUwgPSBjb250ZW50Lmh0bWw7XG4gICAgfSBlbHNlIGlmICghZWxlbWVudDI/LmlubmVySFRNTCkge1xuICAgICAgdGhpcy50b2dnbGUoZmFsc2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwb3NpdGlvblR5cGUgPSBtZXRhLnBvc2l0aW9uPy50eXBlID8/IHRoaXMucG9zaXRpb24udHlwZTtcbiAgICBjb25zdCB4T2Zmc2V0ID0gbWV0YS5wb3NpdGlvbj8ueE9mZnNldCA/PyAwO1xuICAgIGNvbnN0IHlPZmZzZXQgPSBtZXRhLnBvc2l0aW9uPy55T2Zmc2V0ID8/IDA7XG4gICAgY29uc3QgdG9vbHRpcEJvdW5kcyA9IHRoaXMuZ2V0VG9vbHRpcEJvdW5kcyh7IHBvc2l0aW9uVHlwZSwgbWV0YSwgeU9mZnNldCwgeE9mZnNldCwgY2FudmFzUmVjdCB9KTtcbiAgICBjb25zdCByZWxhdGl2ZVJlY3QgPSB7XG4gICAgICB4OiBib3VuZGluZ1JlY3QueCAtIGNhbnZhc1JlY3QueCxcbiAgICAgIHk6IGJvdW5kaW5nUmVjdC55IC0gY2FudmFzUmVjdC55LFxuICAgICAgd2lkdGg6IGJvdW5kaW5nUmVjdC53aWR0aCxcbiAgICAgIGhlaWdodDogYm91bmRpbmdSZWN0LmhlaWdodFxuICAgIH07XG4gICAgY29uc3QgcG9zaXRpb24gPSBjYWxjdWxhdGVQbGFjZW1lbnQoZWxlbWVudDIuY2xpZW50V2lkdGgsIGVsZW1lbnQyLmNsaWVudEhlaWdodCwgcmVsYXRpdmVSZWN0LCB0b29sdGlwQm91bmRzKTtcbiAgICBjb25zdCBtaW5YID0gcmVsYXRpdmVSZWN0Lng7XG4gICAgY29uc3QgbWluWSA9IHJlbGF0aXZlUmVjdC55O1xuICAgIGNvbnN0IG1heFggPSByZWxhdGl2ZVJlY3Qud2lkdGggLSBlbGVtZW50Mi5jbGllbnRXaWR0aCAtIDEgKyBtaW5YO1xuICAgIGNvbnN0IG1heFkgPSByZWxhdGl2ZVJlY3QuaGVpZ2h0IC0gZWxlbWVudDIuY2xpZW50SGVpZ2h0ICsgbWluWTtcbiAgICBjb25zdCBsZWZ0ID0gY2xhbXAobWluWCwgcG9zaXRpb24ueCwgbWF4WCk7XG4gICAgY29uc3QgdG9wID0gY2xhbXAobWluWSwgcG9zaXRpb24ueSwgbWF4WSk7XG4gICAgY29uc3QgY29uc3RyYWluZWQgPSBsZWZ0ICE9PSBwb3NpdGlvbi54IHx8IHRvcCAhPT0gcG9zaXRpb24ueTtcbiAgICBjb25zdCBkZWZhdWx0U2hvd0Fycm93ID0gKHBvc2l0aW9uVHlwZSA9PT0gXCJub2RlXCIgfHwgcG9zaXRpb25UeXBlID09PSBcInBvaW50ZXJcIikgJiYgIWNvbnN0cmFpbmVkICYmICF4T2Zmc2V0ICYmICF5T2Zmc2V0O1xuICAgIGNvbnN0IHNob3dBcnJvdyA9IG1ldGEuc2hvd0Fycm93ID8/IHRoaXMuc2hvd0Fycm93ID8/IGRlZmF1bHRTaG93QXJyb3c7XG4gICAgdGhpcy51cGRhdGVTaG93QXJyb3coc2hvd0Fycm93KTtcbiAgICBlbGVtZW50Mi5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7TWF0aC5yb3VuZChsZWZ0KX1weCwgJHtNYXRoLnJvdW5kKHRvcCl9cHgpYDtcbiAgICBlbGVtZW50Mi5zdHlsZS5wb2ludGVyRXZlbnRzID0gbWV0YS5lbmFibGVJbnRlcmFjdGlvbiA/IFwiYXV0b1wiIDogXCJub25lXCI7XG4gICAgZWxlbWVudDIuc2V0QXR0cmlidXRlKFwiZGF0YS1wb2ludGVyLWNhcHR1cmVcIiwgXCJyZXRhaW5cIik7XG4gICAgdGhpcy5lbmFibGVJbnRlcmFjdGlvbiA9IG1ldGEuZW5hYmxlSW50ZXJhY3Rpb24gPz8gZmFsc2U7XG4gICAgaWYgKHRoaXMuZGVsYXkgPiAwICYmICFpbnN0YW50bHkpIHtcbiAgICAgIHRoaXMudG9nZ2xlKGZhbHNlKTtcbiAgICAgIHRoaXMuc2hvd1RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy50b2dnbGUodHJ1ZSk7XG4gICAgICB9LCB0aGlzLmRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50b2dnbGUodHJ1ZSk7XG4gICAgfVxuICB9XG4gIHRvZ2dsZSh2aXNpYmxlKSB7XG4gICAgaWYgKCF0aGlzLmVsZW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBjbGFzc0xpc3QgfSA9IHRoaXMuZWxlbWVudDtcbiAgICBjb25zdCB0b2dnbGVDbGFzcyA9IChuYW1lLCBpbmNsdWRlKSA9PiBjbGFzc0xpc3QudG9nZ2xlKGAke0RFRkFVTFRfVE9PTFRJUF9DTEFTU30tJHtuYW1lfWAsIGluY2x1ZGUpO1xuICAgIGNvbnN0IHdhc1Zpc2libGUgPSB0aGlzLmlzVmlzaWJsZSgpO1xuICAgIGxldCB0aW1lU2luY2VMYXN0VmlzaWJpbGl0eUNoYW5nZU1zID0gSW5maW5pdHk7XG4gICAgaWYgKCF2aXNpYmxlKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5zaG93VGltZW91dCk7XG4gICAgfVxuICAgIGlmICh3YXNWaXNpYmxlICE9PSB2aXNpYmxlKSB7XG4gICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgdGltZVNpbmNlTGFzdFZpc2liaWxpdHlDaGFuZ2VNcyA9IG5vdyAtIHRoaXMubGFzdFZpc2liaWxpdHlDaGFuZ2U7XG4gICAgICB0aGlzLmxhc3RWaXNpYmlsaXR5Q2hhbmdlID0gbm93O1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRlZE1vdmVUaHJlc2hvbGRNcyA9IDEwMDtcbiAgICBjb25zdCB0aHJhc2hpbmdUaHJlc2hvbGRNcyA9IDU7XG4gICAgY29uc3Qgbm9BbmltYXRpb24gPSAhd2FzVmlzaWJsZSAmJiB2aXNpYmxlICYmIHRpbWVTaW5jZUxhc3RWaXNpYmlsaXR5Q2hhbmdlTXMgPiBhbmltYXRlZE1vdmVUaHJlc2hvbGRNcztcbiAgICBpZiAodGltZVNpbmNlTGFzdFZpc2liaWxpdHlDaGFuZ2VNcyA+IHRocmFzaGluZ1RocmVzaG9sZE1zKSB7XG4gICAgICB0b2dnbGVDbGFzcyhcIm5vLWFuaW1hdGlvblwiLCBub0FuaW1hdGlvbik7XG4gICAgfVxuICAgIHRvZ2dsZUNsYXNzKFwibm8taW50ZXJhY3Rpb25cIiwgIXRoaXMuZW5hYmxlSW50ZXJhY3Rpb24pO1xuICAgIHRvZ2dsZUNsYXNzKFwiaGlkZGVuXCIsICF2aXNpYmxlKTtcbiAgICB0b2dnbGVDbGFzcyhcImFycm93XCIsIHRoaXMuX3Nob3dBcnJvdyk7XG4gICAgY2xhc3NMaXN0LnRvZ2dsZShERUZBVUxUX1RPT0xUSVBfREFSS19DTEFTUywgdGhpcy5kYXJrVGhlbWUpO1xuICAgIGZvciAoY29uc3Qgd3JhcFR5cGUgb2YgdGhpcy53cmFwVHlwZXMpIHtcbiAgICAgIGNsYXNzTGlzdC50b2dnbGUoYCR7REVGQVVMVF9UT09MVElQX0NMQVNTfS13cmFwLSR7d3JhcFR5cGV9YCwgd3JhcFR5cGUgPT09IHRoaXMud3JhcHBpbmcpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVTaG93QXJyb3coc2hvdykge1xuICAgIHRoaXMuX3Nob3dBcnJvdyA9IHNob3c7XG4gIH1cbiAgZ2V0VG9vbHRpcEJvdW5kcyhvcHRzKSB7XG4gICAgaWYgKCF0aGlzLmVsZW1lbnQpXG4gICAgICByZXR1cm4ge307XG4gICAgY29uc3QgeyBwb3NpdGlvblR5cGUsIG1ldGEsIHlPZmZzZXQsIHhPZmZzZXQsIGNhbnZhc1JlY3QgfSA9IG9wdHM7XG4gICAgY29uc3QgeyBjbGllbnRXaWR0aDogdG9vbHRpcFdpZHRoLCBjbGllbnRIZWlnaHQ6IHRvb2x0aXBIZWlnaHQgfSA9IHRoaXMuZWxlbWVudDtcbiAgICBjb25zdCBib3VuZHMgPSB7IHdpZHRoOiB0b29sdGlwV2lkdGgsIGhlaWdodDogdG9vbHRpcEhlaWdodCB9O1xuICAgIHN3aXRjaCAocG9zaXRpb25UeXBlKSB7XG4gICAgICBjYXNlIFwibm9kZVwiOlxuICAgICAgY2FzZSBcInBvaW50ZXJcIjoge1xuICAgICAgICBib3VuZHMudG9wID0gbWV0YS5vZmZzZXRZICsgeU9mZnNldCAtIHRvb2x0aXBIZWlnaHQgLSA4O1xuICAgICAgICBib3VuZHMubGVmdCA9IG1ldGEub2Zmc2V0WCArIHhPZmZzZXQgLSB0b29sdGlwV2lkdGggLyAyO1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvcFwiOiB7XG4gICAgICAgIGJvdW5kcy50b3AgPSB5T2Zmc2V0O1xuICAgICAgICBib3VuZHMubGVmdCA9IGNhbnZhc1JlY3Qud2lkdGggLyAyIC0gdG9vbHRpcFdpZHRoIC8gMiArIHhPZmZzZXQ7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICB9XG4gICAgICBjYXNlIFwicmlnaHRcIjoge1xuICAgICAgICBib3VuZHMudG9wID0gY2FudmFzUmVjdC5oZWlnaHQgLyAyIC0gdG9vbHRpcEhlaWdodCAvIDIgKyB5T2Zmc2V0O1xuICAgICAgICBib3VuZHMubGVmdCA9IGNhbnZhc1JlY3Qud2lkdGggLSB0b29sdGlwV2lkdGggLyAyICsgeE9mZnNldDtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJsZWZ0XCI6IHtcbiAgICAgICAgYm91bmRzLnRvcCA9IGNhbnZhc1JlY3QuaGVpZ2h0IC8gMiAtIHRvb2x0aXBIZWlnaHQgLyAyICsgeU9mZnNldDtcbiAgICAgICAgYm91bmRzLmxlZnQgPSB4T2Zmc2V0O1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfVxuICAgICAgY2FzZSBcImJvdHRvbVwiOiB7XG4gICAgICAgIGJvdW5kcy50b3AgPSBjYW52YXNSZWN0LmhlaWdodCAtIHRvb2x0aXBIZWlnaHQgKyB5T2Zmc2V0O1xuICAgICAgICBib3VuZHMubGVmdCA9IGNhbnZhc1JlY3Qud2lkdGggLyAyIC0gdG9vbHRpcFdpZHRoIC8gMiArIHhPZmZzZXQ7XG4gICAgICAgIHJldHVybiBib3VuZHM7XG4gICAgICB9XG4gICAgICBjYXNlIFwidG9wLWxlZnRcIjoge1xuICAgICAgICBib3VuZHMudG9wID0geU9mZnNldDtcbiAgICAgICAgYm91bmRzLmxlZnQgPSB4T2Zmc2V0O1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfVxuICAgICAgY2FzZSBcInRvcC1yaWdodFwiOiB7XG4gICAgICAgIGJvdW5kcy50b3AgPSB5T2Zmc2V0O1xuICAgICAgICBib3VuZHMubGVmdCA9IGNhbnZhc1JlY3Qud2lkdGggLSB0b29sdGlwV2lkdGggKyB4T2Zmc2V0O1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfVxuICAgICAgY2FzZSBcImJvdHRvbS1yaWdodFwiOiB7XG4gICAgICAgIGJvdW5kcy50b3AgPSBjYW52YXNSZWN0LmhlaWdodCAtIHRvb2x0aXBIZWlnaHQgKyB5T2Zmc2V0O1xuICAgICAgICBib3VuZHMubGVmdCA9IGNhbnZhc1JlY3Qud2lkdGggLSB0b29sdGlwV2lkdGggKyB4T2Zmc2V0O1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgICAgfVxuICAgICAgY2FzZSBcImJvdHRvbS1sZWZ0XCI6IHtcbiAgICAgICAgYm91bmRzLnRvcCA9IGNhbnZhc1JlY3QuaGVpZ2h0IC0gdG9vbHRpcEhlaWdodCArIHlPZmZzZXQ7XG4gICAgICAgIGJvdW5kcy5sZWZ0ID0geE9mZnNldDtcbiAgICAgICAgcmV0dXJuIGJvdW5kcztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFRvb2x0aXAucHJvdG90eXBlLCBcInNob3dBcnJvd1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQsIG5ld1ZhbHVlLCBvbGRWYWx1ZSkgPT4ge1xuICAgIGlmIChuZXdWYWx1ZSkge1xuICAgICAgdGFyZ2V0LmVsZW1lbnQ/LmNsYXNzTGlzdC5hZGQobmV3VmFsdWUpO1xuICAgIH1cbiAgICBpZiAob2xkVmFsdWUpIHtcbiAgICAgIHRhcmdldC5lbGVtZW50Py5jbGFzc0xpc3QucmVtb3ZlKG9sZFZhbHVlKTtcbiAgICB9XG4gIH0pLFxuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFRvb2x0aXAucHJvdG90eXBlLCBcImNsYXNzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwiZGVsYXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShJTlRFUkFDVElPTl9SQU5HRSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgVG9vbHRpcC5wcm90b3R5cGUsIFwicmFuZ2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShURVhUX1dSQVApXG5dLCBUb29sdGlwLnByb3RvdHlwZSwgXCJ3cmFwcGluZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFRvb2x0aXAucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIFRvb2x0aXAucHJvdG90eXBlLCBcImRhcmtUaGVtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFVOSU9OKFtcImV4dGVuZGVkXCIsIFwiY2FudmFzXCJdKSlcbl0sIFRvb2x0aXAucHJvdG90eXBlLCBcImJvdW5kc1wiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvY2FwdGlvbi50c1xudmFyIENhcHRpb24gPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmlkID0gY3JlYXRlSWQodGhpcyk7XG4gICAgdGhpcy5ub2RlID0gbmV3IFRleHQoeyB6SW5kZXg6IDEgfSkuc2V0UHJvcGVydGllcyh7XG4gICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXG4gICAgICBwb2ludGVyRXZlbnRzOiAxIC8qIE5vbmUgKi9cbiAgICB9KTtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgdGhpcy5mb250U2l6ZSA9IDEwO1xuICAgIHRoaXMuZm9udEZhbWlseSA9IFwic2Fucy1zZXJpZlwiO1xuICAgIHRoaXMud3JhcHBpbmcgPSBcImFsd2F5c1wiO1xuICAgIHRoaXMudHJ1bmNhdGVkID0gZmFsc2U7XG4gICAgdGhpcy5sYXlvdXRTdHlsZSA9IFwiYmxvY2tcIjtcbiAgfVxuICByZWdpc3RlckludGVyYWN0aW9uKG1vZHVsZUN0eCkge1xuICAgIGNvbnN0IHsgcmVnaW9uTWFuYWdlciwgcHJveHlJbnRlcmFjdGlvblNlcnZpY2UsIGxheW91dFNlcnZpY2UgfSA9IG1vZHVsZUN0eDtcbiAgICBjb25zdCByZWdpb24gPSByZWdpb25NYW5hZ2VyLmdldFJlZ2lvbihcInJvb3RcIik7XG4gICAgY29uc3QgZGVzdHJveUZucyA9IFtcbiAgICAgIGxheW91dFNlcnZpY2UuYWRkTGlzdGVuZXIoXCJsYXlvdXQtY29tcGxldGVcIiwgKCkgPT4gdGhpcy51cGRhdGVBMTF5VGV4dChwcm94eUludGVyYWN0aW9uU2VydmljZSkpLFxuICAgICAgcmVnaW9uLmFkZExpc3RlbmVyKFwiaG92ZXJcIiwgKGV2ZW50KSA9PiB0aGlzLmhhbmRsZU1vdXNlTW92ZShtb2R1bGVDdHgsIGV2ZW50KSksXG4gICAgICByZWdpb24uYWRkTGlzdGVuZXIoXCJsZWF2ZVwiLCAoZXZlbnQpID0+IHRoaXMuaGFuZGxlTW91c2VMZWF2ZShtb2R1bGVDdHgsIGV2ZW50KSlcbiAgICBdO1xuICAgIHJldHVybiBqb2luRnVuY3Rpb25zKC4uLmRlc3Ryb3lGbnMpO1xuICB9XG4gIGNvbXB1dGVUZXh0V3JhcChjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0KSB7XG4gICAgY29uc3QgeyB0ZXh0LCB3cmFwcGluZyB9ID0gdGhpcztcbiAgICBjb25zdCBtYXhXaWR0aCA9IE1hdGgubWluKHRoaXMubWF4V2lkdGggPz8gSW5maW5pdHksIGNvbnRhaW5lcldpZHRoKTtcbiAgICBjb25zdCBtYXhIZWlnaHQgPSB0aGlzLm1heEhlaWdodCA/PyBjb250YWluZXJIZWlnaHQ7XG4gICAgaWYgKCFpc0Zpbml0ZShtYXhXaWR0aCkgJiYgIWlzRmluaXRlKG1heEhlaWdodCkpIHtcbiAgICAgIHRoaXMubm9kZS50ZXh0ID0gdGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgd3JhcHBlZFRleHQgPSBUZXh0V3JhcHBlci53cmFwVGV4dCh0ZXh0ID8/IFwiXCIsIHsgbWF4V2lkdGgsIG1heEhlaWdodCwgZm9udDogdGhpcywgdGV4dFdyYXA6IHdyYXBwaW5nIH0pO1xuICAgIHRoaXMubm9kZS50ZXh0ID0gd3JhcHBlZFRleHQ7XG4gICAgdGhpcy50cnVuY2F0ZWQgPSB3cmFwcGVkVGV4dC5pbmNsdWRlcyhUZXh0VXRpbHMuRWxsaXBzaXNDaGFyKTtcbiAgfVxuICB1cGRhdGVBMTF5VGV4dChwcm94eVNlcnZpY2UpIHtcbiAgICBpZiAodGhpcy5lbmFibGVkICYmIHRoaXMudGV4dCkge1xuICAgICAgY29uc3QgYmJveCA9IHRoaXMubm9kZS5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XG4gICAgICBpZiAoYmJveCkge1xuICAgICAgICBjb25zdCB7IGlkIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLnByb3h5VGV4dCA/PyAodGhpcy5wcm94eVRleHQgPSBwcm94eVNlcnZpY2UuY3JlYXRlUHJveHlFbGVtZW50KHsgdHlwZTogXCJ0ZXh0XCIsIGlkLCBwYXJlbnQ6IFwiY2FudmFzLXByb3h5XCIgfSkpO1xuICAgICAgICB0aGlzLnByb3h5VGV4dC50ZXh0Q29udGVudCA9IHRoaXMudGV4dDtcbiAgICAgICAgdGhpcy5wcm94eVRleHQudXBkYXRlQm91bmRzKGJib3gpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByb3h5VGV4dD8ucmVtb3ZlKCk7XG4gICAgICB0aGlzLnByb3h5VGV4dCA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgaGFuZGxlTW91c2VNb3ZlKG1vZHVsZUN0eCwgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgIT09IHZvaWQgMCAmJiB0aGlzLmVuYWJsZWQgJiYgdGhpcy5ub2RlLnZpc2libGUgJiYgdGhpcy50cnVuY2F0ZWQpIHtcbiAgICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnQ7XG4gICAgICBtb2R1bGVDdHgudG9vbHRpcE1hbmFnZXIudXBkYXRlVG9vbHRpcChcbiAgICAgICAgdGhpcy5pZCxcbiAgICAgICAgeyBvZmZzZXRYLCBvZmZzZXRZLCBsYXN0UG9pbnRlckV2ZW50OiBldmVudCwgc2hvd0Fycm93OiBmYWxzZSB9LFxuICAgICAgICB0b1Rvb2x0aXBIdG1sKHsgY29udGVudDogdGhpcy50ZXh0IH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBoYW5kbGVNb3VzZUxlYXZlKG1vZHVsZUN0eCwgX2V2ZW50KSB7XG4gICAgbW9kdWxlQ3R4LnRvb2x0aXBNYW5hZ2VyLnJlbW92ZVRvb2x0aXAodGhpcy5pZCk7XG4gIH1cbn07XG5DYXB0aW9uLlNNQUxMX1BBRERJTkcgPSAxMDtcbkNhcHRpb24uTEFSR0VfUEFERElORyA9IDIwO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibm9kZVwiKVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwidGV4dFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFRFWFRfQUxJR04sIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibm9kZVwiKVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwidGV4dEFsaWduXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9TVFlMRSwgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJub2RlXCIpXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1dFSUdIVCwgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJub2RlXCIpXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJub2RlXCIpXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORyksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibm9kZVwiKVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KSxcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJub2RlXCIsIFwiZmlsbFwiKVxuXSwgQ2FwdGlvbi5wcm90b3R5cGUsIFwiY29sb3JcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcInNwYWNpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcImxpbmVIZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcIm1heFdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJtYXhIZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShURVhUX1dSQVApXG5dLCBDYXB0aW9uLnByb3RvdHlwZSwgXCJ3cmFwcGluZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIENhcHRpb24ucHJvdG90eXBlLCBcImxheW91dFN0eWxlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zaGFwZS9yYW5nZS50c1xudmFyIFJhbmdlID0gY2xhc3MgZXh0ZW5kcyBTaGFwZSB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKG9wdHMpO1xuICAgIHRoaXMueDEgPSAwO1xuICAgIHRoaXMueTEgPSAwO1xuICAgIHRoaXMueDIgPSAwO1xuICAgIHRoaXMueTIgPSAwO1xuICAgIHRoaXMuc3RhcnRMaW5lID0gZmFsc2U7XG4gICAgdGhpcy5lbmRMaW5lID0gZmFsc2U7XG4gICAgdGhpcy5pc1JhbmdlID0gZmFsc2U7XG4gICAgdGhpcy5yZXN0b3JlT3duU3R5bGVzKCk7XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgcmV0dXJuIG5ldyBCQm94KHRoaXMueDEsIHRoaXMueTEsIHRoaXMueDIgLSB0aGlzLngxLCB0aGlzLnkyIC0gdGhpcy55MSk7XG4gIH1cbiAgaXNQb2ludEluUGF0aChfeCwgX3kpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmVuZGVyKHJlbmRlckN0eCkge1xuICAgIGNvbnN0IHsgY3R4LCBmb3JjZVJlbmRlciwgc3RhdHMgfSA9IHJlbmRlckN0eDtcbiAgICBpZiAodGhpcy5kaXJ0eSA9PT0gMCAvKiBOT05FICovICYmICFmb3JjZVJlbmRlcikge1xuICAgICAgaWYgKHN0YXRzKVxuICAgICAgICBzdGF0cy5ub2Rlc1NraXBwZWQgKz0gdGhpcy5ub2RlQ291bnQuY291bnQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudHJhbnNmb3JtUmVuZGVyQ29udGV4dChyZW5kZXJDdHgpO1xuICAgIGxldCB7IHgxLCB5MSwgeDIsIHkyIH0gPSB0aGlzO1xuICAgIHgxID0gdGhpcy5hbGlnbih4MSk7XG4gICAgeTEgPSB0aGlzLmFsaWduKHkxKTtcbiAgICB4MiA9IHRoaXMuYWxpZ24oeDIpO1xuICAgIHkyID0gdGhpcy5hbGlnbih5Mik7XG4gICAgY29uc3QgeyBmaWxsLCBvcGFjaXR5LCBpc1JhbmdlIH0gPSB0aGlzO1xuICAgIGNvbnN0IGZpbGxBY3RpdmUgPSAhIShpc1JhbmdlICYmIGZpbGwpO1xuICAgIGlmIChmaWxsQWN0aXZlKSB7XG4gICAgICBjb25zdCB7IGZpbGxPcGFjaXR5IH0gPSB0aGlzO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGw7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5ICogZmlsbE9wYWNpdHk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgICBjdHgubGluZVRvKHgyLCB5MSk7XG4gICAgICBjdHgubGluZVRvKHgyLCB5Mik7XG4gICAgICBjdHgubGluZVRvKHgxLCB5Mik7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICBjdHguZmlsbCgpO1xuICAgIH1cbiAgICBjb25zdCB7IHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0YXJ0TGluZSwgZW5kTGluZSB9ID0gdGhpcztcbiAgICBjb25zdCBzdHJva2VBY3RpdmUgPSAhISgoc3RhcnRMaW5lIHx8IGVuZExpbmUpICYmIHN0cm9rZSAmJiBzdHJva2VXaWR0aCk7XG4gICAgaWYgKHN0cm9rZUFjdGl2ZSkge1xuICAgICAgY29uc3QgeyBzdHJva2VPcGFjaXR5LCBsaW5lRGFzaCwgbGluZURhc2hPZmZzZXQsIGxpbmVDYXAsIGxpbmVKb2luIH0gPSB0aGlzO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eSAqIHN0cm9rZU9wYWNpdHk7XG4gICAgICBjdHgubGluZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG4gICAgICBpZiAobGluZURhc2gpIHtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKGxpbmVEYXNoKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lRGFzaE9mZnNldCkge1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBsaW5lRGFzaE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lQ2FwKSB7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gbGluZUNhcDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lSm9pbikge1xuICAgICAgICBjdHgubGluZUpvaW4gPSBsaW5lSm9pbjtcbiAgICAgIH1cbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGlmIChzdGFydExpbmUpIHtcbiAgICAgICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuICAgICAgICBjdHgubGluZVRvKHgyLCB5MSk7XG4gICAgICB9XG4gICAgICBpZiAoZW5kTGluZSkge1xuICAgICAgICBjdHgubW92ZVRvKHgyLCB5Mik7XG4gICAgICAgIGN0eC5saW5lVG8oeDEsIHkyKTtcbiAgICAgIH1cbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG4gICAgdGhpcy5maWxsU2hhZG93Py5tYXJrQ2xlYW4oKTtcbiAgICBzdXBlci5yZW5kZXIocmVuZGVyQ3R4KTtcbiAgfVxufTtcblJhbmdlLmNsYXNzTmFtZSA9IFwiUmFuZ2VcIjtcblJhbmdlLmRlZmF1bHRTdHlsZXMgPSB7XG4gIC4uLlNoYXBlLmRlZmF1bHRTdHlsZXMsXG4gIHN0cm9rZVdpZHRoOiAxXG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIFJhbmdlLnByb3RvdHlwZSwgXCJ4MVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBSYW5nZS5wcm90b3R5cGUsIFwieTFcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMiAvKiBNSU5PUiAqLyB9KVxuXSwgUmFuZ2UucHJvdG90eXBlLCBcIngyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIFJhbmdlLnByb3RvdHlwZSwgXCJ5MlwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAyIC8qIE1JTk9SICovIH0pXG5dLCBSYW5nZS5wcm90b3R5cGUsIFwic3RhcnRMaW5lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIFJhbmdlLnByb3RvdHlwZSwgXCJlbmRMaW5lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDIgLyogTUlOT1IgKi8gfSlcbl0sIFJhbmdlLnByb3RvdHlwZSwgXCJpc1JhbmdlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9sYWJlbC50c1xudmFyIExhYmVsID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmZvbnRTaXplID0gMTI7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gXCJWZXJkYW5hLCBzYW5zLXNlcmlmXCI7XG4gIH1cbiAgZ2V0Rm9udCgpIHtcbiAgICByZXR1cm4gVGV4dFV0aWxzLnRvRm9udFN0cmluZyh0aGlzKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBMYWJlbC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGFiZWwucHJvdG90eXBlLCBcImNvbG9yXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9TVFlMRSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGFiZWwucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfV0VJR0hULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMYWJlbC5wcm90b3R5cGUsIFwiZm9udFdlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIExhYmVsLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIExhYmVsLnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExhYmVsLnByb3RvdHlwZSwgXCJmb3JtYXR0ZXJcIiwgMik7XG5mdW5jdGlvbiBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKG9wdHMpIHtcbiAgY29uc3QgeyBwYXJhbGxlbEZsaXBSb3RhdGlvbiA9IDAsIHJlZ3VsYXJGbGlwUm90YXRpb24gPSAwIH0gPSBvcHRzO1xuICBjb25zdCBjb25maWd1cmVkUm90YXRpb24gPSBvcHRzLnJvdGF0aW9uID8gbm9ybWFsaXplQW5nbGUzNjAodG9SYWRpYW5zKG9wdHMucm90YXRpb24pKSA6IDA7XG4gIGNvbnN0IHBhcmFsbGVsRmxpcEZsYWcgPSAhY29uZmlndXJlZFJvdGF0aW9uICYmIHBhcmFsbGVsRmxpcFJvdGF0aW9uID49IDAgJiYgcGFyYWxsZWxGbGlwUm90YXRpb24gPD0gTWF0aC5QSSA/IC0xIDogMTtcbiAgY29uc3QgcmVndWxhckZsaXBGbGFnID0gIWNvbmZpZ3VyZWRSb3RhdGlvbiAmJiByZWd1bGFyRmxpcFJvdGF0aW9uID49IDAgJiYgcmVndWxhckZsaXBSb3RhdGlvbiA8PSBNYXRoLlBJID8gLTEgOiAxO1xuICBsZXQgZGVmYXVsdFJvdGF0aW9uID0gMDtcbiAgaWYgKG9wdHMucGFyYWxsZWwpIHtcbiAgICBkZWZhdWx0Um90YXRpb24gPSBwYXJhbGxlbEZsaXBGbGFnICogTWF0aC5QSSAvIDI7XG4gIH0gZWxzZSBpZiAocmVndWxhckZsaXBGbGFnID09PSAtMSkge1xuICAgIGRlZmF1bHRSb3RhdGlvbiA9IE1hdGguUEk7XG4gIH1cbiAgcmV0dXJuIHsgY29uZmlndXJlZFJvdGF0aW9uLCBkZWZhdWx0Um90YXRpb24sIHBhcmFsbGVsRmxpcEZsYWcsIHJlZ3VsYXJGbGlwRmxhZyB9O1xufVxuZnVuY3Rpb24gZ2V0TGFiZWxTcGFjaW5nKG1pblNwYWNpbmcsIHJvdGF0ZWQpIHtcbiAgaWYgKCFpc05hTihtaW5TcGFjaW5nKSkge1xuICAgIHJldHVybiBtaW5TcGFjaW5nO1xuICB9XG4gIHJldHVybiByb3RhdGVkID8gMCA6IDEwO1xufVxuZnVuY3Rpb24gZ2V0VGV4dEJhc2VsaW5lKHBhcmFsbGVsLCBsYWJlbFJvdGF0aW9uLCBzaWRlRmxhZywgcGFyYWxsZWxGbGlwRmxhZykge1xuICBpZiAocGFyYWxsZWwgJiYgIWxhYmVsUm90YXRpb24pIHtcbiAgICByZXR1cm4gc2lkZUZsYWcgKiBwYXJhbGxlbEZsaXBGbGFnID09PSAtMSA/IFwiaGFuZ2luZ1wiIDogXCJib3R0b21cIjtcbiAgfVxuICByZXR1cm4gXCJtaWRkbGVcIjtcbn1cbmZ1bmN0aW9uIGdldFRleHRBbGlnbihwYXJhbGxlbCwgbGFiZWxSb3RhdGlvbiwgbGFiZWxBdXRvUm90YXRpb24sIHNpZGVGbGFnLCByZWd1bGFyRmxpcEZsYWcpIHtcbiAgY29uc3QgbGFiZWxSb3RhdGVkID0gbGFiZWxSb3RhdGlvbiA+IDAgJiYgbGFiZWxSb3RhdGlvbiA8PSBNYXRoLlBJO1xuICBjb25zdCBsYWJlbEF1dG9Sb3RhdGVkID0gbGFiZWxBdXRvUm90YXRpb24gPiAwICYmIGxhYmVsQXV0b1JvdGF0aW9uIDw9IE1hdGguUEk7XG4gIGNvbnN0IGFsaWduRmxhZyA9IGxhYmVsUm90YXRlZCB8fCBsYWJlbEF1dG9Sb3RhdGVkID8gLTEgOiAxO1xuICBpZiAocGFyYWxsZWwpIHtcbiAgICBpZiAobGFiZWxSb3RhdGlvbiB8fCBsYWJlbEF1dG9Sb3RhdGlvbikge1xuICAgICAgaWYgKHNpZGVGbGFnICogYWxpZ25GbGFnID09PSAtMSkge1xuICAgICAgICByZXR1cm4gXCJlbmRcIjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwiY2VudGVyXCI7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNpZGVGbGFnICogcmVndWxhckZsaXBGbGFnID09PSAtMSkge1xuICAgIHJldHVybiBcImVuZFwiO1xuICB9XG4gIHJldHVybiBcInN0YXJ0XCI7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVMYWJlbEJCb3godGV4dCwgYmJveCwgbGFiZWxNYXRyaXgpIHtcbiAgY29uc3QgeyB4OiBsYWJlbFgsIHk6IGxhYmVsWSwgd2lkdGgsIGhlaWdodCB9ID0gYmJveDtcbiAgY29uc3QgdHJhbnNsYXRlZEJCb3ggPSBuZXcgQkJveChsYWJlbFgsIGxhYmVsWSwgMCwgMCk7XG4gIGxhYmVsTWF0cml4LnRyYW5zZm9ybUJCb3godHJhbnNsYXRlZEJCb3gsIGJib3gpO1xuICBjb25zdCB7IHgsIHkgfSA9IGJib3g7XG4gIHJldHVybiB7XG4gICAgcG9pbnQ6IHsgeCwgeSB9LFxuICAgIGxhYmVsOiB7IHRleHQsIHdpZHRoLCBoZWlnaHQgfVxuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9sYXllcnMudHNcbnZhciBMYXllcnMgPSAvKiBAX19QVVJFX18gKi8gKChMYXllcnMyKSA9PiB7XG4gIExheWVyczJbTGF5ZXJzMltcIlNFUklFU19CQUNLR1JPVU5EX1pJTkRFWFwiXSA9IDBdID0gXCJTRVJJRVNfQkFDS0dST1VORF9aSU5ERVhcIjtcbiAgTGF5ZXJzMltMYXllcnMyW1wiQVhJU19HUklEX1pJTkRFWFwiXSA9IDFdID0gXCJBWElTX0dSSURfWklOREVYXCI7XG4gIExheWVyczJbTGF5ZXJzMltcIkFYSVNfWklOREVYXCJdID0gMl0gPSBcIkFYSVNfWklOREVYXCI7XG4gIExheWVyczJbTGF5ZXJzMltcIlNFUklFU19DUk9TU0xJTkVfUkFOR0VfWklOREVYXCJdID0gM10gPSBcIlNFUklFU19DUk9TU0xJTkVfUkFOR0VfWklOREVYXCI7XG4gIExheWVyczJbTGF5ZXJzMltcIlNFUklFU19MQVlFUl9aSU5ERVhcIl0gPSA0XSA9IFwiU0VSSUVTX0xBWUVSX1pJTkRFWFwiO1xuICBMYXllcnMyW0xheWVyczJbXCJTRVJJRVNfSElHSExJR0hUX1pJTkRFWFwiXSA9IDVdID0gXCJTRVJJRVNfSElHSExJR0hUX1pJTkRFWFwiO1xuICBMYXllcnMyW0xheWVyczJbXCJBWElTX0ZPUkVHUk9VTkRfWklOREVYXCJdID0gNl0gPSBcIkFYSVNfRk9SRUdST1VORF9aSU5ERVhcIjtcbiAgTGF5ZXJzMltMYXllcnMyW1wiU0VSSUVTX0NST1NTSEFJUl9aSU5ERVhcIl0gPSA3XSA9IFwiU0VSSUVTX0NST1NTSEFJUl9aSU5ERVhcIjtcbiAgTGF5ZXJzMltMYXllcnMyW1wiU0VSSUVTX0xBQkVMX1pJTkRFWFwiXSA9IDhdID0gXCJTRVJJRVNfTEFCRUxfWklOREVYXCI7XG4gIExheWVyczJbTGF5ZXJzMltcIlNFUklFU19DUk9TU0xJTkVfTElORV9aSU5ERVhcIl0gPSA5XSA9IFwiU0VSSUVTX0NST1NTTElORV9MSU5FX1pJTkRFWFwiO1xuICBMYXllcnMyW0xheWVyczJbXCJTRVJJRVNfQU5OT1RBVElPTl9aSU5ERVhcIl0gPSAxMF0gPSBcIlNFUklFU19BTk5PVEFUSU9OX1pJTkRFWFwiO1xuICBMYXllcnMyW0xheWVyczJbXCJDSEFSVF9BTk5PVEFUSU9OX1pJTkRFWFwiXSA9IDExXSA9IFwiQ0hBUlRfQU5OT1RBVElPTl9aSU5ERVhcIjtcbiAgTGF5ZXJzMltMYXllcnMyW1wiQ0hBUlRfQU5OT1RBVElPTl9GT0NVU0VEX1pJTkRFWFwiXSA9IDEyXSA9IFwiQ0hBUlRfQU5OT1RBVElPTl9GT0NVU0VEX1pJTkRFWFwiO1xuICBMYXllcnMyW0xheWVyczJbXCJMRUdFTkRfWklOREVYXCJdID0gMTNdID0gXCJMRUdFTkRfWklOREVYXCI7XG4gIExheWVyczJbTGF5ZXJzMltcIk5BVklHQVRPUl9aSU5ERVhcIl0gPSAxNF0gPSBcIk5BVklHQVRPUl9aSU5ERVhcIjtcbiAgTGF5ZXJzMltMYXllcnMyW1wiRk9SRUdST1VORF9aSU5ERVhcIl0gPSAxNV0gPSBcIkZPUkVHUk9VTkRfWklOREVYXCI7XG4gIHJldHVybiBMYXllcnMyO1xufSkoTGF5ZXJzIHx8IHt9KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC92YWx1ZS50c1xuZnVuY3Rpb24gaXNTdHJpbmdPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgT2JqZWN0Lmhhc093bih2YWx1ZSwgXCJ0b1N0cmluZ1wiKSAmJiBpc1N0cmluZyh2YWx1ZS50b1N0cmluZygpKTtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIE9iamVjdC5oYXNPd24odmFsdWUsIFwidmFsdWVPZlwiKSAmJiBpc0Zpbml0ZU51bWJlcih2YWx1ZS52YWx1ZU9mKCkpO1xufVxuZnVuY3Rpb24gaXNDb250aW51b3VzKHZhbHVlKSB7XG4gIHJldHVybiBpc0Zpbml0ZU51bWJlcih2YWx1ZSkgfHwgaXNWYWxpZERhdGUodmFsdWUpIHx8IGlzTnVtYmVyT2JqZWN0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGNoZWNrRGF0dW0odmFsdWUsIGlzQ29udGludW91c1NjYWxlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICghaXNDb250aW51b3VzU2NhbGUgfHwgaXNDb250aW51b3VzKHZhbHVlKSk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1JbnRlZ3JhdGVkQ2F0ZWdvcnlWYWx1ZSh2YWx1ZSkge1xuICBpZiAoaXNTdHJpbmdPYmplY3QodmFsdWUpICYmIE9iamVjdC5oYXNPd24odmFsdWUsIFwiaWRcIikpIHtcbiAgICByZXR1cm4gdmFsdWUuaWQ7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jcm9zc2xpbmUvY3Jvc3NMaW5lLnRzXG52YXIgTUFUQ0hJTkdfQ1JPU1NMSU5FX1RZUEUgPSAocHJvcGVydHkpID0+IHtcbiAgcmV0dXJuIHByb3BlcnR5ID09PSBcInZhbHVlXCIgPyBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgICAoXywgY3R4KSA9PiBjdHgudGFyZ2V0W1widHlwZVwiXSA9PT0gXCJsaW5lXCIsXG4gICAgKGN0eCkgPT4gY3R4LnRhcmdldFtcInR5cGVcIl0gPT09IFwicmFuZ2VcIiA/IGBjcm9zc0xpbmUgdHlwZSAncmFuZ2UnIHRvIGhhdmUgYSAncmFuZ2UnIHByb3BlcnR5IGluc3RlYWQgb2YgJ3ZhbHVlJ2AgOiBgY3Jvc3NMaW5lIHByb3BlcnR5ICd0eXBlJyB0byBiZSAnbGluZSdgXG4gICkgOiBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgICAoXywgY3R4KSA9PiBjdHgudGFyZ2V0W1widHlwZVwiXSA9PT0gXCJyYW5nZVwiLFxuICAgIChjdHgpID0+IGN0eC50YXJnZXQudHlwZSA9PT0gXCJsaW5lXCIgPyBgY3Jvc3NMaW5lIHR5cGUgJ2xpbmUnIHRvIGhhdmUgYSAndmFsdWUnIHByb3BlcnR5IGluc3RlYWQgb2YgJ3JhbmdlJ2AgOiBgY3Jvc3NMaW5lIHByb3BlcnR5ICd0eXBlJyB0byBiZSAncmFuZ2UnYFxuICApO1xufTtcbnZhciB2YWxpZGF0ZUNyb3NzTGluZVZhbHVlcyA9ICh0eXBlLCB2YWx1ZSwgcmFuZ2UzLCBzY2FsZTIpID0+IHtcbiAgY29uc3QgbGluZUNyb3NzTGluZSA9IHR5cGUgPT09IFwibGluZVwiICYmIHZhbHVlICE9PSB2b2lkIDA7XG4gIGNvbnN0IHJhbmdlQ3Jvc3NMaW5lID0gdHlwZSA9PT0gXCJyYW5nZVwiICYmIHJhbmdlMyAhPT0gdm9pZCAwO1xuICBpZiAoIWxpbmVDcm9zc0xpbmUgJiYgIXJhbmdlQ3Jvc3NMaW5lKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgW3N0YXJ0LCBlbmRdID0gcmFuZ2UzID8/IFt2YWx1ZSwgdm9pZCAwXTtcbiAgY29uc3QgaXNDb250aW51b3VzMiA9IENvbnRpbnVvdXNTY2FsZS5pcyhzY2FsZTIpIHx8IE9yZGluYWxUaW1lU2NhbGUuaXMoc2NhbGUyKTtcbiAgY29uc3QgdmFsaWRTdGFydCA9IGNoZWNrRGF0dW0oc3RhcnQsIGlzQ29udGludW91czIpICYmICFpc05hTihzY2FsZTIuY29udmVydChzdGFydCkpO1xuICBjb25zdCB2YWxpZEVuZCA9IGNoZWNrRGF0dW0oZW5kLCBpc0NvbnRpbnVvdXMyKSAmJiAhaXNOYU4oc2NhbGUyLmNvbnZlcnQoZW5kKSk7XG4gIGlmIChsaW5lQ3Jvc3NMaW5lICYmIHZhbGlkU3RhcnQgfHwgcmFuZ2VDcm9zc0xpbmUgJiYgdmFsaWRTdGFydCAmJiB2YWxpZEVuZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IG1lc3NhZ2UgPSBbYEV4cGVjdGluZyBjcm9zc0xpbmVgXTtcbiAgaWYgKHJhbmdlQ3Jvc3NMaW5lKSB7XG4gICAgaWYgKCF2YWxpZFN0YXJ0KSB7XG4gICAgICBtZXNzYWdlLnB1c2goYHJhbmdlIHN0YXJ0ICR7c3RyaW5naWZ5KHN0YXJ0KX1gKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZEVuZCkge1xuICAgICAgbWVzc2FnZS5wdXNoKGAke3ZhbGlkU3RhcnQgPyBcIlwiIDogXCJhbmQgXCJ9cmFuZ2UgZW5kICR7c3RyaW5naWZ5KGVuZCl9YCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG1lc3NhZ2UucHVzaChgdmFsdWUgJHtzdHJpbmdpZnkoc3RhcnQpfWApO1xuICB9XG4gIG1lc3NhZ2UucHVzaChgdG8gbWF0Y2ggdGhlIGF4aXMgc2NhbGUgZG9tYWluLmApO1xuICBMb2dnZXIud2Fybk9uY2UobWVzc2FnZS5qb2luKFwiIFwiKSk7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2Nyb3NzbGluZS9jcm9zc0xpbmVMYWJlbFBvc2l0aW9uLnRzXG52YXIgaG9yaXpvbnRhbENyb3NzbGluZVRyYW5zbGF0aW9uRGlyZWN0aW9ucyA9IHtcbiAgdG9wOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9LFxuICBib3R0b206IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcbiAgbGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcbiAgcmlnaHQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcbiAgdG9wTGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgdG9wUmlnaHQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9LFxuICBib3R0b21MZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIGJvdHRvbVJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBpbnNpZGU6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcbiAgaW5zaWRlTGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCB9LFxuICBpbnNpZGVSaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcbiAgaW5zaWRlVG9wOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIGluc2lkZUJvdHRvbTogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgaW5zaWRlVG9wTGVmdDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBpbnNpZGVCb3R0b21MZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9LFxuICBpbnNpZGVUb3BSaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDEgfSxcbiAgaW5zaWRlQm90dG9tUmlnaHQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9XG59O1xudmFyIHZlcnRpY2FsQ3Jvc3NMaW5lVHJhbnNsYXRpb25EaXJlY3Rpb25zID0ge1xuICB0b3A6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IDAgfSxcbiAgYm90dG9tOiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCB9LFxuICBsZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9LFxuICByaWdodDogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICB0b3BMZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgdG9wUmlnaHQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIGJvdHRvbUxlZnQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH0sXG4gIGJvdHRvbVJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIGluc2lkZTogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDAsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCB9LFxuICBpbnNpZGVMZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIGluc2lkZVJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSB9LFxuICBpbnNpZGVUb3A6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAtMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAwIH0sXG4gIGluc2lkZUJvdHRvbTogeyB4VHJhbnNsYXRpb25EaXJlY3Rpb246IDEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMCB9LFxuICBpbnNpZGVUb3BMZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSB9LFxuICBpbnNpZGVCb3R0b21MZWZ0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogMSwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxIH0sXG4gIGluc2lkZVRvcFJpZ2h0OiB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEsIHlUcmFuc2xhdGlvbkRpcmVjdGlvbjogLTEgfSxcbiAgaW5zaWRlQm90dG9tUmlnaHQ6IHsgeFRyYW5zbGF0aW9uRGlyZWN0aW9uOiAxLCB5VHJhbnNsYXRpb25EaXJlY3Rpb246IC0xIH1cbn07XG5mdW5jdGlvbiBjYWxjdWxhdGVMYWJlbFRyYW5zbGF0aW9uKHtcbiAgeURpcmVjdGlvbixcbiAgcGFkZGluZyA9IDAsXG4gIHBvc2l0aW9uID0gXCJ0b3BcIixcbiAgYmJveFxufSkge1xuICBjb25zdCBjcm9zc0xpbmVUcmFuc2xhdGlvbkRpcmVjdGlvbnMgPSB5RGlyZWN0aW9uID8gaG9yaXpvbnRhbENyb3NzbGluZVRyYW5zbGF0aW9uRGlyZWN0aW9ucyA6IHZlcnRpY2FsQ3Jvc3NMaW5lVHJhbnNsYXRpb25EaXJlY3Rpb25zO1xuICBjb25zdCB7IHhUcmFuc2xhdGlvbkRpcmVjdGlvbiwgeVRyYW5zbGF0aW9uRGlyZWN0aW9uIH0gPSBjcm9zc0xpbmVUcmFuc2xhdGlvbkRpcmVjdGlvbnNbcG9zaXRpb25dO1xuICBjb25zdCB3ID0geURpcmVjdGlvbiA/IGJib3gud2lkdGggOiBiYm94LmhlaWdodDtcbiAgY29uc3QgaCA9IHlEaXJlY3Rpb24gPyBiYm94LmhlaWdodCA6IGJib3gud2lkdGg7XG4gIGNvbnN0IHhUcmFuc2xhdGlvbiA9IHhUcmFuc2xhdGlvbkRpcmVjdGlvbiAqIChwYWRkaW5nICsgdyAvIDIpO1xuICBjb25zdCB5VHJhbnNsYXRpb24gPSB5VHJhbnNsYXRpb25EaXJlY3Rpb24gKiAocGFkZGluZyArIGggLyAyKTtcbiAgcmV0dXJuIHtcbiAgICB4VHJhbnNsYXRpb24sXG4gICAgeVRyYW5zbGF0aW9uXG4gIH07XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVMYWJlbENoYXJ0UGFkZGluZyh7XG4gIHlEaXJlY3Rpb24sXG4gIGJib3gsXG4gIHBhZGRpbmcgPSAwLFxuICBwb3NpdGlvbiA9IFwidG9wXCJcbn0pIHtcbiAgY29uc3QgY2hhcnRQYWRkaW5nID0ge307XG4gIGlmIChwb3NpdGlvbi5zdGFydHNXaXRoKFwiaW5zaWRlXCIpKVxuICAgIHJldHVybiBjaGFydFBhZGRpbmc7XG4gIGlmIChwb3NpdGlvbiA9PT0gXCJ0b3BcIiAmJiAheURpcmVjdGlvbikge1xuICAgIGNoYXJ0UGFkZGluZy50b3AgPSBwYWRkaW5nICsgYmJveC5oZWlnaHQ7XG4gIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IFwiYm90dG9tXCIgJiYgIXlEaXJlY3Rpb24pIHtcbiAgICBjaGFydFBhZGRpbmcuYm90dG9tID0gcGFkZGluZyArIGJib3guaGVpZ2h0O1xuICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSBcImxlZnRcIiAmJiB5RGlyZWN0aW9uKSB7XG4gICAgY2hhcnRQYWRkaW5nLmxlZnQgPSBwYWRkaW5nICsgYmJveC53aWR0aDtcbiAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gXCJyaWdodFwiICYmIHlEaXJlY3Rpb24pIHtcbiAgICBjaGFydFBhZGRpbmcucmlnaHQgPSBwYWRkaW5nICsgYmJveC53aWR0aDtcbiAgfVxuICByZXR1cm4gY2hhcnRQYWRkaW5nO1xufVxudmFyIFBPU0lUSU9OX1RPUF9DT09SRElOQVRFUyA9ICh7IHlEaXJlY3Rpb24sIHhFbmQsIHlTdGFydCwgeUVuZCB9KSA9PiB7XG4gIGlmICh5RGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCAvIDIsIHk6IHlTdGFydCB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHg6IHhFbmQsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogKHlTdGFydCArIHlFbmQpIC8gMiB9O1xuICB9XG59O1xudmFyIFBPU0lUSU9OX0xFRlRfQ09PUkRJTkFURVMgPSAoeyB5RGlyZWN0aW9uLCB4U3RhcnQsIHhFbmQsIHlTdGFydCwgeUVuZCB9KSA9PiB7XG4gIGlmICh5RGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIHsgeDogeFN0YXJ0LCB5OiBpc05hTih5RW5kKSA/IHlTdGFydCA6ICh5U3RhcnQgKyB5RW5kKSAvIDIgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyB4OiB4RW5kIC8gMiwgeTogeVN0YXJ0IH07XG4gIH1cbn07XG52YXIgUE9TSVRJT05fUklHSFRfQ09PUkRJTkFURVMgPSAoeyB5RGlyZWN0aW9uLCB4RW5kLCB5U3RhcnQsIHlFbmQgfSkgPT4ge1xuICBpZiAoeURpcmVjdGlvbikge1xuICAgIHJldHVybiB7IHg6IHhFbmQsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogKHlTdGFydCArIHlFbmQpIC8gMiB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHg6IHhFbmQgLyAyLCB5OiBpc05hTih5RW5kKSA/IHlTdGFydCA6IHlFbmQgfTtcbiAgfVxufTtcbnZhciBQT1NJVElPTl9CT1RUT01fQ09PUkRJTkFURVMgPSAoeyB5RGlyZWN0aW9uLCB4U3RhcnQsIHhFbmQsIHlTdGFydCwgeUVuZCB9KSA9PiB7XG4gIGlmICh5RGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCAvIDIsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogeUVuZCB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHg6IHhTdGFydCwgeTogaXNOYU4oeUVuZCkgPyB5U3RhcnQgOiAoeVN0YXJ0ICsgeUVuZCkgLyAyIH07XG4gIH1cbn07XG52YXIgUE9TSVRJT05fSU5TSURFX0NPT1JESU5BVEVTID0gKHsgeEVuZCwgeVN0YXJ0LCB5RW5kIH0pID0+IHtcbiAgcmV0dXJuIHsgeDogeEVuZCAvIDIsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogKHlTdGFydCArIHlFbmQpIC8gMiB9O1xufTtcbnZhciBQT1NJVElPTl9UT1BfTEVGVF9DT09SRElOQVRFUyA9ICh7IHlEaXJlY3Rpb24sIHhTdGFydCwgeEVuZCwgeVN0YXJ0IH0pID0+IHtcbiAgaWYgKHlEaXJlY3Rpb24pIHtcbiAgICByZXR1cm4geyB4OiB4U3RhcnQgLyAyLCB5OiB5U3RhcnQgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyB4OiB4RW5kLCB5OiB5U3RhcnQgfTtcbiAgfVxufTtcbnZhciBQT1NJVElPTl9CT1RUT01fTEVGVF9DT09SRElOQVRFUyA9ICh7IHlEaXJlY3Rpb24sIHhTdGFydCwgeVN0YXJ0LCB5RW5kIH0pID0+IHtcbiAgaWYgKHlEaXJlY3Rpb24pIHtcbiAgICByZXR1cm4geyB4OiB4U3RhcnQsIHk6IGlzTmFOKHlFbmQpID8geVN0YXJ0IDogeUVuZCB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHg6IHhTdGFydCwgeTogeVN0YXJ0IH07XG4gIH1cbn07XG52YXIgUE9TSVRJT05fVE9QX1JJR0hUX0NPT1JESU5BVEVTID0gKHsgeURpcmVjdGlvbiwgeEVuZCwgeVN0YXJ0LCB5RW5kIH0pID0+IHtcbiAgaWYgKHlEaXJlY3Rpb24pIHtcbiAgICByZXR1cm4geyB4OiB4RW5kLCB5OiB5U3RhcnQgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyB4OiB4RW5kLCB5OiBpc05hTih5RW5kKSA/IHlTdGFydCA6IHlFbmQgfTtcbiAgfVxufTtcbnZhciBQT1NJVElPTl9CT1RUT01fUklHSFRfQ09PUkRJTkFURVMgPSAoeyB5RGlyZWN0aW9uLCB4U3RhcnQsIHhFbmQsIHlTdGFydCwgeUVuZCB9KSA9PiB7XG4gIGlmICh5RGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIHsgeDogeEVuZCwgeTogaXNOYU4oeUVuZCkgPyB5U3RhcnQgOiB5RW5kIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgeDogeFN0YXJ0LCB5OiBpc05hTih5RW5kKSA/IHlTdGFydCA6IHlFbmQgfTtcbiAgfVxufTtcbnZhciBsYWJlbERpcmVjdGlvbkhhbmRsaW5nID0ge1xuICB0b3A6IHsgYzogUE9TSVRJT05fVE9QX0NPT1JESU5BVEVTIH0sXG4gIGJvdHRvbTogeyBjOiBQT1NJVElPTl9CT1RUT01fQ09PUkRJTkFURVMgfSxcbiAgbGVmdDogeyBjOiBQT1NJVElPTl9MRUZUX0NPT1JESU5BVEVTIH0sXG4gIHJpZ2h0OiB7IGM6IFBPU0lUSU9OX1JJR0hUX0NPT1JESU5BVEVTIH0sXG4gIHRvcExlZnQ6IHsgYzogUE9TSVRJT05fVE9QX0xFRlRfQ09PUkRJTkFURVMgfSxcbiAgdG9wUmlnaHQ6IHsgYzogUE9TSVRJT05fVE9QX1JJR0hUX0NPT1JESU5BVEVTIH0sXG4gIGJvdHRvbUxlZnQ6IHsgYzogUE9TSVRJT05fQk9UVE9NX0xFRlRfQ09PUkRJTkFURVMgfSxcbiAgYm90dG9tUmlnaHQ6IHsgYzogUE9TSVRJT05fQk9UVE9NX1JJR0hUX0NPT1JESU5BVEVTIH0sXG4gIGluc2lkZTogeyBjOiBQT1NJVElPTl9JTlNJREVfQ09PUkRJTkFURVMgfSxcbiAgaW5zaWRlTGVmdDogeyBjOiBQT1NJVElPTl9MRUZUX0NPT1JESU5BVEVTIH0sXG4gIGluc2lkZVJpZ2h0OiB7IGM6IFBPU0lUSU9OX1JJR0hUX0NPT1JESU5BVEVTIH0sXG4gIGluc2lkZVRvcDogeyBjOiBQT1NJVElPTl9UT1BfQ09PUkRJTkFURVMgfSxcbiAgaW5zaWRlQm90dG9tOiB7IGM6IFBPU0lUSU9OX0JPVFRPTV9DT09SRElOQVRFUyB9LFxuICBpbnNpZGVUb3BMZWZ0OiB7IGM6IFBPU0lUSU9OX1RPUF9MRUZUX0NPT1JESU5BVEVTIH0sXG4gIGluc2lkZUJvdHRvbUxlZnQ6IHsgYzogUE9TSVRJT05fQk9UVE9NX0xFRlRfQ09PUkRJTkFURVMgfSxcbiAgaW5zaWRlVG9wUmlnaHQ6IHsgYzogUE9TSVRJT05fVE9QX1JJR0hUX0NPT1JESU5BVEVTIH0sXG4gIGluc2lkZUJvdHRvbVJpZ2h0OiB7IGM6IFBPU0lUSU9OX0JPVFRPTV9SSUdIVF9DT09SRElOQVRFUyB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jcm9zc2xpbmUvY2FydGVzaWFuQ3Jvc3NMaW5lLnRzXG52YXIgQ1JPU1NMSU5FX0xBQkVMX1BPU0lUSU9OID0gVU5JT04oXG4gIFtcbiAgICBcInRvcFwiLFxuICAgIFwibGVmdFwiLFxuICAgIFwicmlnaHRcIixcbiAgICBcImJvdHRvbVwiLFxuICAgIFwidG9wTGVmdFwiLFxuICAgIFwidG9wUmlnaHRcIixcbiAgICBcImJvdHRvbUxlZnRcIixcbiAgICBcImJvdHRvbVJpZ2h0XCIsXG4gICAgXCJpbnNpZGVcIixcbiAgICBcImluc2lkZUxlZnRcIixcbiAgICBcImluc2lkZVJpZ2h0XCIsXG4gICAgXCJpbnNpZGVUb3BcIixcbiAgICBcImluc2lkZUJvdHRvbVwiLFxuICAgIFwiaW5zaWRlVG9wTGVmdFwiLFxuICAgIFwiaW5zaWRlQm90dG9tTGVmdFwiLFxuICAgIFwiaW5zaWRlVG9wUmlnaHRcIixcbiAgICBcImluc2lkZUJvdHRvbVJpZ2h0XCJcbiAgXSxcbiAgXCJjcm9zc0xpbmUgbGFiZWwgcG9zaXRpb25cIlxuKTtcbnZhciBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZm9udFNpemUgPSAxNDtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBcIlZlcmRhbmEsIHNhbnMtc2VyaWZcIjtcbiAgICB0aGlzLnBhZGRpbmcgPSA1O1xuICAgIHRoaXMuY29sb3IgPSBcInJnYmEoODcsIDg3LCA4NywgMSlcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwidGV4dFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfU1RZTEUsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1dFSUdIVCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcImZvbnRXZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwiZm9udFNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5Dcm9zc0xpbmVMYWJlbC5wcm90b3R5cGUsIFwiY29sb3JcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDUk9TU0xJTkVfTEFCRUxfUE9TSVRJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhbkNyb3NzTGluZUxhYmVsLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKERFR1JFRSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuQ3Jvc3NMaW5lTGFiZWwucHJvdG90eXBlLCBcInBhcmFsbGVsXCIsIDIpO1xudmFyIF9DYXJ0ZXNpYW5Dcm9zc0xpbmUgPSBjbGFzcyBfQ2FydGVzaWFuQ3Jvc3NMaW5lIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaWQgPSBjcmVhdGVJZCh0aGlzKTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IENhcnRlc2lhbkNyb3NzTGluZUxhYmVsKCk7XG4gICAgdGhpcy5zY2FsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmNsaXBwZWRSYW5nZSA9IFstSW5maW5pdHksIEluZmluaXR5XTtcbiAgICB0aGlzLmdyaWRMZW5ndGggPSAwO1xuICAgIHRoaXMuc2lkZUZsYWcgPSAtMTtcbiAgICB0aGlzLnBhcmFsbGVsRmxpcFJvdGF0aW9uID0gMDtcbiAgICB0aGlzLnJlZ3VsYXJGbGlwUm90YXRpb24gPSAwO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gXCJ4XCIgLyogWCAqLztcbiAgICB0aGlzLmdyb3VwID0gbmV3IEdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH1gLCBsYXllcjogdHJ1ZSwgekluZGV4OiBfQ2FydGVzaWFuQ3Jvc3NMaW5lLkxJTkVfTEFZRVJfWklOREVYIH0pO1xuICAgIHRoaXMubGFiZWxHcm91cCA9IG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9YCwgbGF5ZXI6IHRydWUsIHpJbmRleDogX0NhcnRlc2lhbkNyb3NzTGluZS5MQUJFTF9MQVlFUl9aSU5ERVggfSk7XG4gICAgdGhpcy5jcm9zc0xpbmVSYW5nZSA9IG5ldyBSYW5nZSgpO1xuICAgIHRoaXMuY3Jvc3NMaW5lTGFiZWwgPSBuZXcgVGV4dCgpO1xuICAgIHRoaXMubGFiZWxQb2ludCA9IHZvaWQgMDtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICB0aGlzLnN0YXJ0TGluZSA9IGZhbHNlO1xuICAgIHRoaXMuZW5kTGluZSA9IGZhbHNlO1xuICAgIHRoaXMuaXNSYW5nZSA9IGZhbHNlO1xuICAgIHRoaXMuZ3JvdXAuYXBwZW5kKHRoaXMuY3Jvc3NMaW5lUmFuZ2UpO1xuICAgIHRoaXMubGFiZWxHcm91cC5hcHBlbmQodGhpcy5jcm9zc0xpbmVMYWJlbCk7XG4gICAgdGhpcy5jcm9zc0xpbmVSYW5nZS5wb2ludGVyRXZlbnRzID0gMSAvKiBOb25lICovO1xuICB9XG4gIHVwZGF0ZSh2aXNpYmxlKSB7XG4gICAgY29uc3QgeyBlbmFibGVkLCBkYXRhLCB0eXBlLCB2YWx1ZSwgcmFuZ2U6IHJhbmdlMywgc2NhbGU6IHNjYWxlMiB9ID0gdGhpcztcbiAgICBpZiAoIXR5cGUgfHwgIXNjYWxlMiB8fCAhZW5hYmxlZCB8fCAhdmlzaWJsZSB8fCAhdmFsaWRhdGVDcm9zc0xpbmVWYWx1ZXModHlwZSwgdmFsdWUsIHJhbmdlMywgc2NhbGUyKSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5ncm91cC52aXNpYmxlID0gZmFsc2U7XG4gICAgICB0aGlzLmxhYmVsR3JvdXAudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmdyb3VwLnZpc2libGUgPSB2aXNpYmxlO1xuICAgIHRoaXMubGFiZWxHcm91cC52aXNpYmxlID0gdmlzaWJsZTtcbiAgICB0aGlzLmdyb3VwLnpJbmRleCA9IHRoaXMuZ2V0WkluZGV4KHRoaXMuaXNSYW5nZSk7XG4gICAgdGhpcy51cGRhdGVOb2RlcygpO1xuICB9XG4gIGNhbGN1bGF0ZUxheW91dCh2aXNpYmxlLCByZXZlcnNlZEF4aXMpIHtcbiAgICBpZiAoIXZpc2libGUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgc2NhbGU6IHNjYWxlMixcbiAgICAgIGdyaWRMZW5ndGgsXG4gICAgICBzaWRlRmxhZyxcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIGxhYmVsOiB7IHBvc2l0aW9uID0gXCJ0b3BcIiB9LFxuICAgICAgY2xpcHBlZFJhbmdlLFxuICAgICAgc3Ryb2tlV2lkdGggPSAwXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5kYXRhID0gW107XG4gICAgaWYgKCFzY2FsZTIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYmFuZHdpZHRoID0gc2NhbGUyLmJhbmR3aWR0aCA/PyAwO1xuICAgIGNvbnN0IHN0ZXAgPSBzY2FsZTIuc3RlcCA/PyAwO1xuICAgIGNvbnN0IHBhZGRpbmcgPSAocmV2ZXJzZWRBeGlzID8gLTEgOiAxKSAqIChzY2FsZTIgaW5zdGFuY2VvZiBCYW5kU2NhbGUgPyAoc3RlcCAtIGJhbmR3aWR0aCkgLyAyIDogMCk7XG4gICAgY29uc3QgW3hTdGFydCwgeEVuZF0gPSBbMCwgc2lkZUZsYWcgKiBncmlkTGVuZ3RoXTtcbiAgICBsZXQgW3lTdGFydCwgeUVuZF0gPSB0aGlzLmdldFJhbmdlKCk7XG4gICAgY29uc3Qgb3JkaW5hbFRpbWVTY2FsZVBhZGRpbmcgPSB5RW5kID09PSB2b2lkIDAgJiYgT3JkaW5hbFRpbWVTY2FsZS5pcyhzY2FsZTIpID8gYmFuZHdpZHRoIC8gMiArIHBhZGRpbmcgOiAwO1xuICAgIGxldCBbY2xhbXBlZFlTdGFydCwgY2xhbXBlZFlFbmRdID0gW1xuICAgICAgTnVtYmVyKHNjYWxlMi5jb252ZXJ0KHlTdGFydCwgeyBjbGFtcE1vZGU6IFwiY2xhbXBlZFwiIH0pKSAtIHBhZGRpbmcgKyBvcmRpbmFsVGltZVNjYWxlUGFkZGluZyxcbiAgICAgIHNjYWxlMi5jb252ZXJ0KHlFbmQsIHsgY2xhbXBNb2RlOiBcImNsYW1wZWRcIiB9KSArIGJhbmR3aWR0aCArIHBhZGRpbmdcbiAgICBdO1xuICAgIGNsYW1wZWRZU3RhcnQgPSBjbGFtcEFycmF5KGNsYW1wZWRZU3RhcnQsIGNsaXBwZWRSYW5nZSk7XG4gICAgY2xhbXBlZFlFbmQgPSBjbGFtcEFycmF5KGNsYW1wZWRZRW5kLCBjbGlwcGVkUmFuZ2UpO1xuICAgIFt5U3RhcnQsIHlFbmRdID0gW051bWJlcihzY2FsZTIuY29udmVydCh5U3RhcnQpKSArIG9yZGluYWxUaW1lU2NhbGVQYWRkaW5nLCBzY2FsZTIuY29udmVydCh5RW5kKSArIGJhbmR3aWR0aF07XG4gICAgY29uc3QgdmFsaWRSYW5nZSA9ICh5U3RhcnQgPT09IGNsYW1wZWRZU3RhcnQgfHwgeUVuZCA9PT0gY2xhbXBlZFlFbmQgfHwgY2xhbXBlZFlTdGFydCAhPT0gY2xhbXBlZFlFbmQpICYmIE1hdGguYWJzKGNsYW1wZWRZRW5kIC0gY2xhbXBlZFlTdGFydCkgPiAwO1xuICAgIGlmICh2YWxpZFJhbmdlICYmIGNsYW1wZWRZU3RhcnQgPiBjbGFtcGVkWUVuZCkge1xuICAgICAgW2NsYW1wZWRZU3RhcnQsIGNsYW1wZWRZRW5kXSA9IFtjbGFtcGVkWUVuZCwgY2xhbXBlZFlTdGFydF07XG4gICAgICBbeVN0YXJ0LCB5RW5kXSA9IFt5RW5kLCB5U3RhcnRdO1xuICAgIH1cbiAgICBpZiAoeVN0YXJ0IC0gcGFkZGluZyA+PSBjbGFtcGVkWVN0YXJ0KVxuICAgICAgeVN0YXJ0IC09IHBhZGRpbmc7XG4gICAgaWYgKHlFbmQgKyBwYWRkaW5nIDw9IGNsYW1wZWRZRW5kKVxuICAgICAgeUVuZCArPSBwYWRkaW5nO1xuICAgIHRoaXMuaXNSYW5nZSA9IHZhbGlkUmFuZ2U7XG4gICAgdGhpcy5zdGFydExpbmUgPSBzdHJva2VXaWR0aCA+IDAgJiYgeVN0YXJ0ID49IGNsYW1wZWRZU3RhcnQgJiYgeVN0YXJ0IDw9IGNsYW1wZWRZU3RhcnQgKyBwYWRkaW5nO1xuICAgIHRoaXMuZW5kTGluZSA9IHN0cm9rZVdpZHRoID4gMCAmJiB5RW5kID49IGNsYW1wZWRZRW5kIC0gYmFuZHdpZHRoIC0gcGFkZGluZyAmJiB5RW5kIDw9IGNsYW1wZWRZRW5kO1xuICAgIGlmICghdmFsaWRSYW5nZSAmJiAhdGhpcy5zdGFydExpbmUgJiYgIXRoaXMuZW5kTGluZSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmRhdGEgPSBbY2xhbXBlZFlTdGFydCwgY2xhbXBlZFlFbmRdO1xuICAgIGlmICh0aGlzLmxhYmVsLmVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IHlEaXJlY3Rpb24gPSBkaXJlY3Rpb24gPT09IFwieVwiIC8qIFkgKi87XG4gICAgICBjb25zdCB7IGMgPSBQT1NJVElPTl9UT1BfQ09PUkRJTkFURVMgfSA9IGxhYmVsRGlyZWN0aW9uSGFuZGxpbmdbcG9zaXRpb25dID8/IHt9O1xuICAgICAgY29uc3QgeyB4OiBsYWJlbFgsIHk6IGxhYmVsWSB9ID0gYyh7XG4gICAgICAgIHlEaXJlY3Rpb24sXG4gICAgICAgIHhTdGFydCxcbiAgICAgICAgeEVuZCxcbiAgICAgICAgeVN0YXJ0OiBjbGFtcGVkWVN0YXJ0LFxuICAgICAgICB5RW5kOiBjbGFtcGVkWUVuZFxuICAgICAgfSk7XG4gICAgICB0aGlzLmxhYmVsUG9pbnQgPSB7XG4gICAgICAgIHg6IGxhYmVsWCxcbiAgICAgICAgeTogbGFiZWxZXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICB1cGRhdGVOb2RlcygpIHtcbiAgICB0aGlzLnVwZGF0ZVJhbmdlTm9kZSgpO1xuICAgIGlmICh0aGlzLmxhYmVsLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlTGFiZWwoKTtcbiAgICAgIHRoaXMucG9zaXRpb25MYWJlbCgpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVSYW5nZU5vZGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3Jvc3NMaW5lUmFuZ2UsXG4gICAgICBzaWRlRmxhZyxcbiAgICAgIGdyaWRMZW5ndGgsXG4gICAgICBkYXRhLFxuICAgICAgc3RhcnRMaW5lLFxuICAgICAgZW5kTGluZSxcbiAgICAgIGlzUmFuZ2UsXG4gICAgICBmaWxsLFxuICAgICAgZmlsbE9wYWNpdHksXG4gICAgICBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aCxcbiAgICAgIGxpbmVEYXNoXG4gICAgfSA9IHRoaXM7XG4gICAgY3Jvc3NMaW5lUmFuZ2UueDEgPSAwO1xuICAgIGNyb3NzTGluZVJhbmdlLngyID0gc2lkZUZsYWcgKiBncmlkTGVuZ3RoO1xuICAgIGNyb3NzTGluZVJhbmdlLnkxID0gZGF0YVswXTtcbiAgICBjcm9zc0xpbmVSYW5nZS55MiA9IGRhdGFbMV07XG4gICAgY3Jvc3NMaW5lUmFuZ2Uuc3RhcnRMaW5lID0gc3RhcnRMaW5lO1xuICAgIGNyb3NzTGluZVJhbmdlLmVuZExpbmUgPSBlbmRMaW5lO1xuICAgIGNyb3NzTGluZVJhbmdlLmlzUmFuZ2UgPSBpc1JhbmdlO1xuICAgIGNyb3NzTGluZVJhbmdlLmZpbGwgPSBmaWxsO1xuICAgIGNyb3NzTGluZVJhbmdlLmZpbGxPcGFjaXR5ID0gZmlsbE9wYWNpdHkgPz8gMTtcbiAgICBjcm9zc0xpbmVSYW5nZS5zdHJva2UgPSBzdHJva2U7XG4gICAgY3Jvc3NMaW5lUmFuZ2Uuc3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aCA/PyAxO1xuICAgIGNyb3NzTGluZVJhbmdlLnN0cm9rZU9wYWNpdHkgPSB0aGlzLnN0cm9rZU9wYWNpdHkgPz8gMTtcbiAgICBjcm9zc0xpbmVSYW5nZS5saW5lRGFzaCA9IGxpbmVEYXNoO1xuICB9XG4gIHVwZGF0ZUxhYmVsKCkge1xuICAgIGNvbnN0IHsgY3Jvc3NMaW5lTGFiZWwsIGxhYmVsIH0gPSB0aGlzO1xuICAgIGlmICghbGFiZWwudGV4dClcbiAgICAgIHJldHVybjtcbiAgICBjcm9zc0xpbmVMYWJlbC5mb250U3R5bGUgPSBsYWJlbC5mb250U3R5bGU7XG4gICAgY3Jvc3NMaW5lTGFiZWwuZm9udFdlaWdodCA9IGxhYmVsLmZvbnRXZWlnaHQ7XG4gICAgY3Jvc3NMaW5lTGFiZWwuZm9udFNpemUgPSBsYWJlbC5mb250U2l6ZTtcbiAgICBjcm9zc0xpbmVMYWJlbC5mb250RmFtaWx5ID0gbGFiZWwuZm9udEZhbWlseTtcbiAgICBjcm9zc0xpbmVMYWJlbC5maWxsID0gbGFiZWwuY29sb3I7XG4gICAgY3Jvc3NMaW5lTGFiZWwudGV4dCA9IGxhYmVsLnRleHQ7XG4gIH1cbiAgcG9zaXRpb25MYWJlbCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjcm9zc0xpbmVMYWJlbCxcbiAgICAgIGxhYmVsUG9pbnQ6IHsgeCA9IHZvaWQgMCwgeSA9IHZvaWQgMCB9ID0ge30sXG4gICAgICBsYWJlbDogeyBwYXJhbGxlbCwgcm90YXRpb24sIHBvc2l0aW9uID0gXCJ0b3BcIiwgcGFkZGluZyA9IDAgfSxcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHBhcmFsbGVsRmxpcFJvdGF0aW9uLFxuICAgICAgcmVndWxhckZsaXBSb3RhdGlvblxuICAgIH0gPSB0aGlzO1xuICAgIGlmICh4ID09PSB2b2lkIDAgfHwgeSA9PT0gdm9pZCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgZGVmYXVsdFJvdGF0aW9uLCBjb25maWd1cmVkUm90YXRpb24gfSA9IGNhbGN1bGF0ZUxhYmVsUm90YXRpb24oe1xuICAgICAgcm90YXRpb24sXG4gICAgICBwYXJhbGxlbCxcbiAgICAgIHJlZ3VsYXJGbGlwUm90YXRpb24sXG4gICAgICBwYXJhbGxlbEZsaXBSb3RhdGlvblxuICAgIH0pO1xuICAgIGNyb3NzTGluZUxhYmVsLnJvdGF0aW9uID0gZGVmYXVsdFJvdGF0aW9uICsgY29uZmlndXJlZFJvdGF0aW9uO1xuICAgIGNyb3NzTGluZUxhYmVsLnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgY3Jvc3NMaW5lTGFiZWwudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICBjb25zdCBiYm94ID0gY3Jvc3NMaW5lTGFiZWwuY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpO1xuICAgIGlmICghYmJveClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB5RGlyZWN0aW9uID0gZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovO1xuICAgIGNvbnN0IHsgeFRyYW5zbGF0aW9uLCB5VHJhbnNsYXRpb24gfSA9IGNhbGN1bGF0ZUxhYmVsVHJhbnNsYXRpb24oe1xuICAgICAgeURpcmVjdGlvbixcbiAgICAgIHBhZGRpbmcsXG4gICAgICBwb3NpdGlvbixcbiAgICAgIGJib3hcbiAgICB9KTtcbiAgICBjcm9zc0xpbmVMYWJlbC50cmFuc2xhdGlvblggPSB4ICsgeFRyYW5zbGF0aW9uO1xuICAgIGNyb3NzTGluZUxhYmVsLnRyYW5zbGF0aW9uWSA9IHkgKyB5VHJhbnNsYXRpb247XG4gIH1cbiAgZ2V0WkluZGV4KGlzUmFuZ2UgPSBmYWxzZSkge1xuICAgIHJldHVybiBpc1JhbmdlID8gX0NhcnRlc2lhbkNyb3NzTGluZS5SQU5HRV9MQVlFUl9aSU5ERVggOiBfQ2FydGVzaWFuQ3Jvc3NMaW5lLkxJTkVfTEFZRVJfWklOREVYO1xuICB9XG4gIGdldFJhbmdlKCkge1xuICAgIGNvbnN0IHsgdmFsdWUsIHJhbmdlOiByYW5nZTMsIHNjYWxlOiBzY2FsZTIgfSA9IHRoaXM7XG4gICAgY29uc3QgaXNDb250aW51b3VzMiA9IENvbnRpbnVvdXNTY2FsZS5pcyhzY2FsZTIpIHx8IE9yZGluYWxUaW1lU2NhbGUuaXMoc2NhbGUyKTtcbiAgICBjb25zdCBzdGFydCA9IHJhbmdlMz8uWzBdID8/IHZhbHVlO1xuICAgIGxldCBlbmQgPSByYW5nZTM/LlsxXTtcbiAgICBpZiAoIWlzQ29udGludW91czIgJiYgZW5kID09PSB2b2lkIDApIHtcbiAgICAgIGVuZCA9IHN0YXJ0O1xuICAgIH1cbiAgICBpZiAoaXNDb250aW51b3VzMiAmJiBzdGFydCA9PT0gZW5kKSB7XG4gICAgICBlbmQgPSB2b2lkIDA7XG4gICAgfVxuICAgIHJldHVybiBbc3RhcnQsIGVuZF07XG4gIH1cbiAgY29tcHV0ZUxhYmVsQkJveCgpIHtcbiAgICBjb25zdCB7IGxhYmVsIH0gPSB0aGlzO1xuICAgIGlmICghbGFiZWwuZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ZW1wVGV4dCA9IG5ldyBUZXh0KCk7XG4gICAgdGVtcFRleHQuZm9udEZhbWlseSA9IGxhYmVsLmZvbnRGYW1pbHk7XG4gICAgdGVtcFRleHQuZm9udFNpemUgPSBsYWJlbC5mb250U2l6ZTtcbiAgICB0ZW1wVGV4dC5mb250U3R5bGUgPSBsYWJlbC5mb250U3R5bGU7XG4gICAgdGVtcFRleHQuZm9udFdlaWdodCA9IGxhYmVsLmZvbnRXZWlnaHQ7XG4gICAgdGVtcFRleHQudGV4dCA9IGxhYmVsLnRleHQ7XG4gICAgY29uc3Qge1xuICAgICAgbGFiZWxQb2ludDogeyB4ID0gdm9pZCAwLCB5ID0gdm9pZCAwIH0gPSB7fSxcbiAgICAgIGxhYmVsOiB7IHBhcmFsbGVsLCByb3RhdGlvbiwgcG9zaXRpb24gPSBcInRvcFwiLCBwYWRkaW5nID0gMCB9LFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgcGFyYWxsZWxGbGlwUm90YXRpb24sXG4gICAgICByZWd1bGFyRmxpcFJvdGF0aW9uXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHggPT09IHZvaWQgMCB8fCB5ID09PSB2b2lkIDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBjb25maWd1cmVkUm90YXRpb24gfSA9IGNhbGN1bGF0ZUxhYmVsUm90YXRpb24oe1xuICAgICAgcm90YXRpb24sXG4gICAgICBwYXJhbGxlbCxcbiAgICAgIHJlZ3VsYXJGbGlwUm90YXRpb24sXG4gICAgICBwYXJhbGxlbEZsaXBSb3RhdGlvblxuICAgIH0pO1xuICAgIHRlbXBUZXh0LnJvdGF0aW9uID0gY29uZmlndXJlZFJvdGF0aW9uO1xuICAgIHRlbXBUZXh0LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgdGVtcFRleHQudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICBjb25zdCBiYm94ID0gdGVtcFRleHQuY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpO1xuICAgIGlmICghYmJveClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB5RGlyZWN0aW9uID0gZGlyZWN0aW9uID09PSBcInlcIiAvKiBZICovO1xuICAgIGNvbnN0IHsgeFRyYW5zbGF0aW9uLCB5VHJhbnNsYXRpb24gfSA9IGNhbGN1bGF0ZUxhYmVsVHJhbnNsYXRpb24oe1xuICAgICAgeURpcmVjdGlvbixcbiAgICAgIHBhZGRpbmcsXG4gICAgICBwb3NpdGlvbixcbiAgICAgIGJib3hcbiAgICB9KTtcbiAgICB0ZW1wVGV4dC50cmFuc2xhdGlvblggPSB4ICsgeFRyYW5zbGF0aW9uO1xuICAgIHRlbXBUZXh0LnRyYW5zbGF0aW9uWSA9IHkgKyB5VHJhbnNsYXRpb247XG4gICAgcmV0dXJuIHRlbXBUZXh0LmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKTtcbiAgfVxuICBjYWxjdWxhdGVQYWRkaW5nKHBhZGRpbmcpIHtcbiAgICBjb25zdCB7XG4gICAgICBpc1JhbmdlLFxuICAgICAgc3RhcnRMaW5lLFxuICAgICAgZW5kTGluZSxcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIGxhYmVsOiB7IHBhZGRpbmc6IGxhYmVsUGFkZGluZyA9IDAsIHBvc2l0aW9uID0gXCJ0b3BcIiB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFpc1JhbmdlICYmICFzdGFydExpbmUgJiYgIWVuZExpbmUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgY3Jvc3NMaW5lTGFiZWxCQm94ID0gdGhpcy5jb21wdXRlTGFiZWxCQm94KCk7XG4gICAgaWYgKGNyb3NzTGluZUxhYmVsQkJveD8ueCA9PSBudWxsIHx8IGNyb3NzTGluZUxhYmVsQkJveD8ueSA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGNoYXJ0UGFkZGluZyA9IGNhbGN1bGF0ZUxhYmVsQ2hhcnRQYWRkaW5nKHtcbiAgICAgIHlEaXJlY3Rpb246IGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLyxcbiAgICAgIHBhZGRpbmc6IGxhYmVsUGFkZGluZyxcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgYmJveDogY3Jvc3NMaW5lTGFiZWxCQm94XG4gICAgfSk7XG4gICAgcGFkZGluZy5sZWZ0ID0gTWF0aC5tYXgocGFkZGluZy5sZWZ0ID8/IDAsIGNoYXJ0UGFkZGluZy5sZWZ0ID8/IDApO1xuICAgIHBhZGRpbmcucmlnaHQgPSBNYXRoLm1heChwYWRkaW5nLnJpZ2h0ID8/IDAsIGNoYXJ0UGFkZGluZy5yaWdodCA/PyAwKTtcbiAgICBwYWRkaW5nLnRvcCA9IE1hdGgubWF4KHBhZGRpbmcudG9wID8/IDAsIGNoYXJ0UGFkZGluZy50b3AgPz8gMCk7XG4gICAgcGFkZGluZy5ib3R0b20gPSBNYXRoLm1heChwYWRkaW5nLmJvdHRvbSA/PyAwLCBjaGFydFBhZGRpbmcuYm90dG9tID8/IDApO1xuICB9XG59O1xuX0NhcnRlc2lhbkNyb3NzTGluZS5MSU5FX0xBWUVSX1pJTkRFWCA9IDkgLyogU0VSSUVTX0NST1NTTElORV9MSU5FX1pJTkRFWCAqLztcbl9DYXJ0ZXNpYW5Dcm9zc0xpbmUuUkFOR0VfTEFZRVJfWklOREVYID0gMyAvKiBTRVJJRVNfQ1JPU1NMSU5FX1JBTkdFX1pJTkRFWCAqLztcbl9DYXJ0ZXNpYW5Dcm9zc0xpbmUuTEFCRUxfTEFZRVJfWklOREVYID0gOCAvKiBTRVJJRVNfTEFCRUxfWklOREVYICovO1xuX0NhcnRlc2lhbkNyb3NzTGluZS5jbGFzc05hbWUgPSBcIkNyb3NzTGluZVwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgX0NhcnRlc2lhbkNyb3NzTGluZS5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFVOSU9OKFtcInJhbmdlXCIsIFwibGluZVwiXSwgXCJhIGNyb3NzTGluZSB0eXBlXCIpLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBfQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJ0eXBlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQU5EKE1BVENISU5HX0NST1NTTElORV9UWVBFKFwicmFuZ2VcIiksIEFSUkFZLnJlc3RyaWN0KHsgbGVuZ3RoOiAyIH0pKSwge1xuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pXG5dLCBfQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJyYW5nZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE1BVENISU5HX0NST1NTTElORV9UWVBFKFwidmFsdWVcIiksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIF9DYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcInZhbHVlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBfQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIF9DYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBfQ2FydGVzaWFuQ3Jvc3NMaW5lLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIF9DYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIF9DYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShMSU5FX0RBU0gsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIF9DYXJ0ZXNpYW5Dcm9zc0xpbmUucHJvdG90eXBlLCBcImxpbmVEYXNoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgX0NhcnRlc2lhbkNyb3NzTGluZS5wcm90b3R5cGUsIFwibGFiZWxcIiwgMik7XG52YXIgQ2FydGVzaWFuQ3Jvc3NMaW5lID0gX0NhcnRlc2lhbkNyb3NzTGluZTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vcmVnaW9ucy50c1xudmFyIFJFR0lPTlMgPSAvKiBAX19QVVJFX18gKi8gKChSRUdJT05TMikgPT4ge1xuICBSRUdJT05TMltcIlRJVExFXCJdID0gXCJ0aXRsZVwiO1xuICBSRUdJT05TMltcIlNVQlRJVExFXCJdID0gXCJzdWJ0aXRsZVwiO1xuICBSRUdJT05TMltcIkZPT1ROT1RFXCJdID0gXCJmb290bm90ZVwiO1xuICBSRUdJT05TMltcIkxFR0VORFwiXSA9IFwibGVnZW5kXCI7XG4gIFJFR0lPTlMyW1wiTkFWSUdBVE9SXCJdID0gXCJuYXZpZ2F0b3JcIjtcbiAgUkVHSU9OUzJbXCJQQUdJTkFUSU9OXCJdID0gXCJwYWdpbmF0aW9uXCI7XG4gIFJFR0lPTlMyW1wiUk9PVFwiXSA9IFwicm9vdFwiO1xuICBSRUdJT05TMltcIlNFUklFU1wiXSA9IFwic2VyaWVzXCI7XG4gIFJFR0lPTlMyW1wiSE9SSVpPTlRBTF9BWEVTXCJdID0gXCJob3Jpem9udGFsLWF4ZXNcIjtcbiAgUkVHSU9OUzJbXCJWRVJUSUNBTF9BWEVTXCJdID0gXCJ2ZXJ0aWNhbC1heGVzXCI7XG4gIFJFR0lPTlMyW1wiVE9PTEJBUlwiXSA9IFwidG9vbGJhclwiO1xuICByZXR1cm4gUkVHSU9OUzI7XG59KShSRUdJT05TIHx8IHt9KTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9heGlzR3JpZExpbmUudHNcbnZhciBHUklEX1NUWUxFX0tFWVMgPSBbXCJzdHJva2VcIiwgXCJsaW5lRGFzaFwiXTtcbnZhciBHUklEX1NUWUxFID0gQVJSQVlfT0YoXG4gICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpICYmIE9iamVjdC5rZXlzKHZhbHVlKS5ldmVyeSgoa2V5KSA9PiBHUklEX1NUWUxFX0tFWVMuaW5jbHVkZXMoa2V5KSksXG4gIFwib2JqZWN0cyB3aXRoIGdyaWRsaW5lIHN0eWxlIHByb3BlcnRpZXMgc3VjaCBhcyAnc3Ryb2tlJyBvciAnbGluZURhc2gnXCJcbik7XG52YXIgQXhpc0dyaWRMaW5lID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMud2lkdGggPSAxO1xuICAgIHRoaXMuc3R5bGUgPSBbXG4gICAgICB7XG4gICAgICAgIHN0cm9rZTogdm9pZCAwLFxuICAgICAgICBsaW5lRGFzaDogW11cbiAgICAgIH1cbiAgICBdO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEF4aXNHcmlkTGluZS5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEF4aXNHcmlkTGluZS5wcm90b3R5cGUsIFwid2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShHUklEX1NUWUxFKVxuXSwgQXhpc0dyaWRMaW5lLnByb3RvdHlwZSwgXCJzdHlsZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9kZWZhdWx0LnRzXG5mdW5jdGlvbiBEZWZhdWx0KGRlZmF1bHRWYWx1ZSwgcmVwbGFjZXMgPSBbdm9pZCAwXSkge1xuICByZXR1cm4gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KChfLCBfXywgdikgPT4ge1xuICAgIGlmIChyZXBsYWNlcy5pbmNsdWRlcyh2KSkge1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZGVmYXVsdFZhbHVlKSA/IGRlZmF1bHRWYWx1ZSh2KSA6IGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH0pO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2F4aXNJbnRlcnZhbC50c1xudmFyIFRJQ0tfSU5URVJWQUwgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZShcbiAgKHZhbHVlKSA9PiBpc0Zpbml0ZU51bWJlcih2YWx1ZSkgJiYgdmFsdWUgPiAwIHx8IHZhbHVlIGluc3RhbmNlb2YgVGltZUludGVydmFsLFxuICBgYSBub24temVybyBwb3NpdGl2ZSBOdW1iZXIgdmFsdWUgb3IsIGZvciBhIHRpbWUgYXhpcywgYSBUaW1lIEludGVydmFsIHN1Y2ggYXMgJ2FnQ2hhcnRzLnRpbWUubW9udGgnYFxuKTtcbnZhciBBeGlzSW50ZXJ2YWwgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLm1pblNwYWNpbmcgPSBOYU47XG4gICAgdGhpcy5tYXhTcGFjaW5nID0gTmFOO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVElDS19JTlRFUlZBTCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc0ludGVydmFsLnByb3RvdHlwZSwgXCJzdGVwXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQVJSQVksIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNJbnRlcnZhbC5wcm90b3R5cGUsIFwidmFsdWVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTUlOX1NQQUNJTkcpLFxuICBEZWZhdWx0KE5hTilcbl0sIEF4aXNJbnRlcnZhbC5wcm90b3R5cGUsIFwibWluU3BhY2luZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE1BWF9TUEFDSU5HKSxcbiAgRGVmYXVsdChOYU4pXG5dLCBBeGlzSW50ZXJ2YWwucHJvdG90eXBlLCBcIm1heFNwYWNpbmdcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvYXhpc0xhYmVsLnRzXG52YXIgQXhpc0xhYmVsID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmZvbnRTaXplID0gMTI7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gXCJWZXJkYW5hLCBzYW5zLXNlcmlmXCI7XG4gICAgdGhpcy5wYWRkaW5nID0gNTtcbiAgICB0aGlzLm1pblNwYWNpbmcgPSBOYU47XG4gICAgdGhpcy5jb2xvciA9IFwiIzU3NTc1N1wiO1xuICAgIHRoaXMuYXZvaWRDb2xsaXNpb25zID0gdHJ1ZTtcbiAgICB0aGlzLm1pcnJvcmVkID0gZmFsc2U7XG4gICAgdGhpcy5wYXJhbGxlbCA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgc2lkZSBvZiB0aGUgYXhpcyBsaW5lIHRvIHBvc2l0aW9uIHRoZSBsYWJlbHMgb24uXG4gICAqIC0xID0gbGVmdCAoZGVmYXVsdClcbiAgICogMSA9IHJpZ2h0XG4gICAqL1xuICBnZXRTaWRlRmxhZygpIHtcbiAgICByZXR1cm4gdGhpcy5taXJyb3JlZCA/IDEgOiAtMTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1NUWUxFLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfV0VJR0hULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcImZvbnRXZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIucmVzdHJpY3QoeyBtaW46IDEgfSkpXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSX09SX05BTiksXG4gIERlZmF1bHQoTmFOKVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJtaW5TcGFjaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcImNvbG9yXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoREVHUkVFLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwiYXZvaWRDb2xsaXNpb25zXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEF4aXNMYWJlbC5wcm90b3R5cGUsIFwibWlycm9yZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJwYXJhbGxlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBeGlzTGFiZWwucHJvdG90eXBlLCBcImZvcm1hdHRlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc0xhYmVsLnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvYXhpc0xpbmUudHNcbnZhciBBeGlzTGluZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLndpZHRoID0gMTtcbiAgICB0aGlzLnN0cm9rZSA9IHZvaWQgMDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBBeGlzTGluZS5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEF4aXNMaW5lLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc0xpbmUucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9heGlzVGljay50c1xudmFyIEF4aXNUaWNrID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLndpZHRoID0gMTtcbiAgICB0aGlzLnNpemUgPSA2O1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIEF4aXNUaWNrLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQXhpc1RpY2sucHJvdG90eXBlLCBcIndpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQXhpc1RpY2sucHJvdG90eXBlLCBcInNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNUaWNrLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvYXhpc1RpdGxlLnRzXG52YXIgQXhpc1RpdGxlID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5zcGFjaW5nID0gQ2FwdGlvbi5TTUFMTF9QQURESU5HO1xuICAgIHRoaXMuZm9udFNpemUgPSAxMDtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBcInNhbnMtc2VyaWZcIjtcbiAgICB0aGlzLndyYXBwaW5nID0gXCJhbHdheXNcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBBeGlzVGl0bGUucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEF4aXNUaXRsZS5wcm90b3R5cGUsIFwidGV4dFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJzcGFjaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9TVFlMRSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1dFSUdIVCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEF4aXNUaXRsZS5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJjb2xvclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFRFWFRfV1JBUClcbl0sIEF4aXNUaXRsZS5wcm90b3R5cGUsIFwid3JhcHBpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQXhpc1RpdGxlLnByb3RvdHlwZSwgXCJmb3JtYXR0ZXJcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvYXhpc1V0aWwudHNcbmZ1bmN0aW9uIHByZXBhcmVBeGlzQW5pbWF0aW9uQ29udGV4dChheGlzKSB7XG4gIGNvbnN0IFtyZXF1ZXN0ZWRSYW5nZU1pbiwgcmVxdWVzdGVkUmFuZ2VNYXhdID0gZmluZE1pbk1heChheGlzLnJhbmdlKTtcbiAgY29uc3QgbWluID0gTWF0aC5mbG9vcihyZXF1ZXN0ZWRSYW5nZU1pbik7XG4gIGNvbnN0IG1heCA9IE1hdGguY2VpbChyZXF1ZXN0ZWRSYW5nZU1heCk7XG4gIHJldHVybiB7IG1pbiwgbWF4LCB2aXNpYmxlOiBtaW4gIT09IG1heCB9O1xufVxudmFyIGZ1bGxDaXJjbGUgPSBNYXRoLlBJICogMjtcbnZhciBoYWxmQ2lyY2xlID0gZnVsbENpcmNsZSAvIDI7XG5mdW5jdGlvbiBub3JtYWxpc2VFbmRSb3RhdGlvbihzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGRpcmVjdERpc3RhbmNlID0gTWF0aC5hYnMoZW5kIC0gc3RhcnQpO1xuICBpZiAoZGlyZWN0RGlzdGFuY2UgPCBoYWxmQ2lyY2xlKVxuICAgIHJldHVybiBlbmQ7XG4gIGlmIChzdGFydCA+IGVuZClcbiAgICByZXR1cm4gZW5kICsgZnVsbENpcmNsZTtcbiAgcmV0dXJuIGVuZCAtIGZ1bGxDaXJjbGU7XG59XG5mdW5jdGlvbiBwcmVwYXJlQXhpc0FuaW1hdGlvbkZ1bmN0aW9ucyhjdHgpIHtcbiAgY29uc3Qgb3V0T2ZCb3VuZHMgPSAoeSwgcmFuZ2UzKSA9PiB7XG4gICAgY29uc3QgW21pbiA9IGN0eC5taW4sIG1heCA9IGN0eC5tYXhdID0gZmluZE1pbk1heChyYW5nZTMgPz8gW10pO1xuICAgIHJldHVybiB5IDwgbWluIHx8IHkgPiBtYXg7XG4gIH07XG4gIGNvbnN0IHRpY2sgPSB7XG4gICAgZnJvbUZuKG5vZGUsIGRhdHVtLCBzdGF0dXMpIHtcbiAgICAgIGxldCB5ID0gbm9kZS55MSArIG5vZGUudHJhbnNsYXRpb25ZO1xuICAgICAgbGV0IG9wYWNpdHkgPSBub2RlLm9wYWNpdHk7XG4gICAgICBpZiAoc3RhdHVzID09PSBcImFkZGVkXCIgfHwgb3V0T2ZCb3VuZHMobm9kZS5kYXR1bS50cmFuc2xhdGlvblksIG5vZGUuZGF0dW0ucmFuZ2UpKSB7XG4gICAgICAgIHkgPSBkYXR1bS50cmFuc2xhdGlvblk7XG4gICAgICAgIG9wYWNpdHkgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgeTogMCwgdHJhbnNsYXRpb25ZOiB5LCBvcGFjaXR5LCBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1tzdGF0dXNdIH07XG4gICAgfSxcbiAgICB0b0ZuKF9ub2RlLCBkYXR1bSwgc3RhdHVzKSB7XG4gICAgICBjb25zdCB5ID0gZGF0dW0udHJhbnNsYXRpb25ZO1xuICAgICAgbGV0IG9wYWNpdHkgPSAxO1xuICAgICAgaWYgKHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIpIHtcbiAgICAgICAgb3BhY2l0eSA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB5OiAwLFxuICAgICAgICB0cmFuc2xhdGlvblk6IHksXG4gICAgICAgIG9wYWNpdHksXG4gICAgICAgIGZpbmlzaDoge1xuICAgICAgICAgIC8vIFNldCBleHBsaWNpdCB5IGFmdGVyIGFuaW1hdGlvbiBzbyBpdCdzIHBpeGVsIGFsaWduZWRcbiAgICAgICAgICB5LFxuICAgICAgICAgIHRyYW5zbGF0aW9uWTogMFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgaW50ZXJtZWRpYXRlRm4obm9kZSwgX2RhdHVtLCBfc3RhdHVzKSB7XG4gICAgICByZXR1cm4geyB2aXNpYmxlOiAhb3V0T2ZCb3VuZHMobm9kZS55KSB9O1xuICAgIH1cbiAgfTtcbiAgY29uc3QgbGFiZWwgPSB7XG4gICAgZnJvbUZuKG5vZGUsIG5ld0RhdHVtLCBzdGF0dXMpIHtcbiAgICAgIGNvbnN0IGRhdHVtID0gbm9kZS5wcmV2aW91c0RhdHVtID8/IG5ld0RhdHVtO1xuICAgICAgY29uc3QgeCA9IGRhdHVtLng7XG4gICAgICBjb25zdCB5ID0gZGF0dW0ueTtcbiAgICAgIGNvbnN0IHJvdGF0aW9uQ2VudGVyWCA9IGRhdHVtLnJvdGF0aW9uQ2VudGVyWDtcbiAgICAgIGxldCB0cmFuc2xhdGlvblkgPSBNYXRoLnJvdW5kKG5vZGUudHJhbnNsYXRpb25ZKTtcbiAgICAgIGxldCByb3RhdGlvbiA9IGRhdHVtLnJvdGF0aW9uO1xuICAgICAgbGV0IG9wYWNpdHkgPSBub2RlLm9wYWNpdHk7XG4gICAgICBpZiAoc3RhdHVzID09PSBcInJlbW92ZWRcIiB8fCBvdXRPZkJvdW5kcyhkYXR1bS55LCBkYXR1bS5yYW5nZSkpIHtcbiAgICAgICAgcm90YXRpb24gPSBuZXdEYXR1bS5yb3RhdGlvbjtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBcImFkZGVkXCIgfHwgb3V0T2ZCb3VuZHMobm9kZS5kYXR1bS55LCBub2RlLmRhdHVtLnJhbmdlKSkge1xuICAgICAgICB0cmFuc2xhdGlvblkgPSBNYXRoLnJvdW5kKGRhdHVtLnRyYW5zbGF0aW9uWSk7XG4gICAgICAgIG9wYWNpdHkgPSAwO1xuICAgICAgICByb3RhdGlvbiA9IG5ld0RhdHVtLnJvdGF0aW9uO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgcm90YXRpb25DZW50ZXJYLFxuICAgICAgICB0cmFuc2xhdGlvblksXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1tzdGF0dXNdXG4gICAgICB9O1xuICAgIH0sXG4gICAgdG9Gbihub2RlLCBkYXR1bSwgc3RhdHVzKSB7XG4gICAgICBjb25zdCB4ID0gZGF0dW0ueDtcbiAgICAgIGNvbnN0IHkgPSBkYXR1bS55O1xuICAgICAgY29uc3Qgcm90YXRpb25DZW50ZXJYID0gZGF0dW0ucm90YXRpb25DZW50ZXJYO1xuICAgICAgY29uc3QgdHJhbnNsYXRpb25ZID0gTWF0aC5yb3VuZChkYXR1bS50cmFuc2xhdGlvblkpO1xuICAgICAgbGV0IHJvdGF0aW9uID0gMDtcbiAgICAgIGxldCBvcGFjaXR5ID0gMTtcbiAgICAgIGlmIChzdGF0dXMgPT09IFwiYWRkZWRcIikge1xuICAgICAgICBvcGFjaXR5ID0gMTtcbiAgICAgICAgcm90YXRpb24gPSBkYXR1bS5yb3RhdGlvbjtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBcInJlbW92ZWRcIikge1xuICAgICAgICBvcGFjaXR5ID0gMDtcbiAgICAgICAgcm90YXRpb24gPSBkYXR1bS5yb3RhdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvdGF0aW9uID0gbm9ybWFsaXNlRW5kUm90YXRpb24obm9kZS5wcmV2aW91c0RhdHVtPy5yb3RhdGlvbiA/PyBkYXR1bS5yb3RhdGlvbiwgZGF0dW0ucm90YXRpb24pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgeCwgeSwgcm90YXRpb25DZW50ZXJYLCB0cmFuc2xhdGlvblksIHJvdGF0aW9uLCBvcGFjaXR5LCBmaW5pc2g6IHsgcm90YXRpb246IGRhdHVtLnJvdGF0aW9uIH0gfTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGxpbmUgPSB7XG4gICAgZnJvbUZuKG5vZGUsIGRhdHVtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5ub2RlLnByZXZpb3VzRGF0dW0gPz8gZGF0dW0sXG4gICAgICAgIHBoYXNlOiBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HW1widXBkYXRlZFwiXVxuICAgICAgfTtcbiAgICB9LFxuICAgIHRvRm4oX25vZGUsIGRhdHVtKSB7XG4gICAgICByZXR1cm4geyAuLi5kYXR1bSB9O1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZ3JvdXAgPSB7XG4gICAgZnJvbUZuKG5vZGUsIF9kYXR1bSkge1xuICAgICAgY29uc3QgeyByb3RhdGlvbiwgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSA9IG5vZGU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgdHJhbnNsYXRpb25YLFxuICAgICAgICB0cmFuc2xhdGlvblksXG4gICAgICAgIHBoYXNlOiBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HW1widXBkYXRlZFwiXVxuICAgICAgfTtcbiAgICB9LFxuICAgIHRvRm4oX25vZGUsIGRhdHVtKSB7XG4gICAgICBjb25zdCB7IHJvdGF0aW9uLCB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSB9ID0gZGF0dW07XG4gICAgICByZXR1cm4ge1xuICAgICAgICByb3RhdGlvbixcbiAgICAgICAgdHJhbnNsYXRpb25YLFxuICAgICAgICB0cmFuc2xhdGlvbllcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICByZXR1cm4geyB0aWNrLCBsaW5lLCBsYWJlbCwgZ3JvdXAgfTtcbn1cbmZ1bmN0aW9uIHJlc2V0QXhpc0dyb3VwRm4oKSB7XG4gIHJldHVybiAoX25vZGUsIGRhdHVtKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvdGF0aW9uOiBkYXR1bS5yb3RhdGlvbixcbiAgICAgIHJvdGF0aW9uQ2VudGVyWDogZGF0dW0ucm90YXRpb25DZW50ZXJYLFxuICAgICAgcm90YXRpb25DZW50ZXJZOiBkYXR1bS5yb3RhdGlvbkNlbnRlclksXG4gICAgICB0cmFuc2xhdGlvblg6IGRhdHVtLnRyYW5zbGF0aW9uWCxcbiAgICAgIHRyYW5zbGF0aW9uWTogZGF0dW0udHJhbnNsYXRpb25ZXG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc2V0QXhpc1NlbGVjdGlvbkZuKGN0eCkge1xuICBjb25zdCB7IHZpc2libGU6IHJhbmdlVmlzaWJsZSwgbWluLCBtYXggfSA9IGN0eDtcbiAgcmV0dXJuIChfbm9kZSwgZGF0dW0pID0+IHtcbiAgICBjb25zdCB5ID0gZGF0dW0udHJhbnNsYXRpb25ZO1xuICAgIGNvbnN0IHZpc2libGUgPSByYW5nZVZpc2libGUgJiYgeSA+PSBtaW4gJiYgeSA8PSBtYXg7XG4gICAgcmV0dXJuIHtcbiAgICAgIHksXG4gICAgICB0cmFuc2xhdGlvblk6IDAsXG4gICAgICBvcGFjaXR5OiAxLFxuICAgICAgdmlzaWJsZVxuICAgIH07XG4gIH07XG59XG5mdW5jdGlvbiByZXNldEF4aXNMYWJlbFNlbGVjdGlvbkZuKCkge1xuICByZXR1cm4gKF9ub2RlLCBkYXR1bSkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBkYXR1bS54LFxuICAgICAgeTogZGF0dW0ueSxcbiAgICAgIHRyYW5zbGF0aW9uWTogZGF0dW0udHJhbnNsYXRpb25ZLFxuICAgICAgcm90YXRpb246IGRhdHVtLnJvdGF0aW9uLFxuICAgICAgcm90YXRpb25DZW50ZXJYOiBkYXR1bS5yb3RhdGlvbkNlbnRlclhcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gcmVzZXRBeGlzTGluZVNlbGVjdGlvbkZuKCkge1xuICByZXR1cm4gKF9ub2RlLCBkYXR1bSkgPT4ge1xuICAgIHJldHVybiB7IC4uLmRhdHVtIH07XG4gIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvYXhpcy50c1xudmFyIF9BeGlzID0gY2xhc3MgX0F4aXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgsIHNjYWxlMikge1xuICAgIHRoaXMubW9kdWxlQ3R4ID0gbW9kdWxlQ3R4O1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTI7XG4gICAgdGhpcy5pZCA9IGNyZWF0ZUlkKHRoaXMpO1xuICAgIHRoaXMubmljZSA9IHRydWU7XG4gICAgdGhpcy5yZXZlcnNlID0gZmFsc2U7XG4gICAgdGhpcy5rZXlzID0gW107XG4gICAgdGhpcy5pbnRlcnZhbCA9IG5ldyBBeGlzSW50ZXJ2YWwoKTtcbiAgICB0aGlzLmRhdGFEb21haW4gPSB7IGRvbWFpbjogW10sIGNsaXBwZWQ6IGZhbHNlIH07XG4gICAgdGhpcy5sYXlvdXRDb25zdHJhaW50cyA9IHtcbiAgICAgIHN0YWNrZWQ6IHRydWUsXG4gICAgICBhbGlnbjogXCJzdGFydFwiLFxuICAgICAgd2lkdGg6IDEwMCxcbiAgICAgIHVuaXQ6IFwicGVyY2VudFwiXG4gICAgfTtcbiAgICB0aGlzLmJvdW5kU2VyaWVzID0gW107XG4gICAgdGhpcy5pbmNsdWRlSW52aXNpYmxlRG9tYWlucyA9IGZhbHNlO1xuICAgIHRoaXMuaW50ZXJhY3Rpb25FbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmF4aXNHcm91cCA9IG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LWF4aXNgLCB6SW5kZXg6IDIgLyogQVhJU19aSU5ERVggKi8gfSk7XG4gICAgdGhpcy5saW5lTm9kZSA9IHRoaXMuYXhpc0dyb3VwLmFwcGVuZENoaWxkKG5ldyBMaW5lKHsgbmFtZTogYCR7dGhpcy5pZH0tQXhpcy1saW5lYCB9KSk7XG4gICAgdGhpcy50aWNrTGluZUdyb3VwID0gdGhpcy5heGlzR3JvdXAuYXBwZW5kQ2hpbGQoXG4gICAgICBuZXcgR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS1BeGlzLXRpY2stbGluZXNgLCB6SW5kZXg6IDIgLyogQVhJU19aSU5ERVggKi8gfSlcbiAgICApO1xuICAgIHRoaXMudGlja0xhYmVsR3JvdXAgPSB0aGlzLmF4aXNHcm91cC5hcHBlbmRDaGlsZChcbiAgICAgIG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LUF4aXMtdGljay1sYWJlbHNgLCB6SW5kZXg6IDIgLyogQVhJU19aSU5ERVggKi8gfSlcbiAgICApO1xuICAgIHRoaXMuY3Jvc3NMaW5lR3JvdXAgPSBuZXcgR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS1Dcm9zc0xpbmVzYCB9KTtcbiAgICB0aGlzLmxhYmVsR3JvdXAgPSBuZXcgR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS1MYWJlbHNgLCB6SW5kZXg6IDEwIC8qIFNFUklFU19BTk5PVEFUSU9OX1pJTkRFWCAqLyB9KTtcbiAgICB0aGlzLmdyaWRHcm91cCA9IG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LUF4aXMtZ3JpZGAgfSk7XG4gICAgdGhpcy5ncmlkTGluZUdyb3VwID0gdGhpcy5ncmlkR3JvdXAuYXBwZW5kQ2hpbGQoXG4gICAgICBuZXcgR3JvdXAoe1xuICAgICAgICBuYW1lOiBgJHt0aGlzLmlkfS1ncmlkTGluZXNgLFxuICAgICAgICB6SW5kZXg6IDEgLyogQVhJU19HUklEX1pJTkRFWCAqL1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMudGlja0xpbmVHcm91cFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QodGhpcy50aWNrTGluZUdyb3VwLCBMaW5lLCBmYWxzZSk7XG4gICAgdGhpcy50aWNrTGFiZWxHcm91cFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QodGhpcy50aWNrTGFiZWxHcm91cCwgVGV4dCwgZmFsc2UpO1xuICAgIHRoaXMuZ3JpZExpbmVHcm91cFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QodGhpcy5ncmlkTGluZUdyb3VwLCBMaW5lLCBmYWxzZSk7XG4gICAgdGhpcy5fY3Jvc3NMaW5lcyA9IFtdO1xuICAgIHRoaXMubGluZSA9IG5ldyBBeGlzTGluZSgpO1xuICAgIHRoaXMudGljayA9IG5ldyBBeGlzVGljaygpO1xuICAgIHRoaXMuZ3JpZExpbmUgPSBuZXcgQXhpc0dyaWRMaW5lKCk7XG4gICAgdGhpcy5sYWJlbCA9IHRoaXMuY3JlYXRlTGFiZWwoKTtcbiAgICB0aGlzLmRlZmF1bHRUaWNrTWluU3BhY2luZyA9IF9BeGlzLmRlZmF1bHRUaWNrTWluU3BhY2luZztcbiAgICB0aGlzLnRyYW5zbGF0aW9uID0geyB4OiAwLCB5OiAwIH07XG4gICAgdGhpcy5yb3RhdGlvbiA9IDA7XG4gICAgLy8gYXhpcyByb3RhdGlvbiBhbmdsZSBpbiBkZWdyZWVzXG4gICAgdGhpcy5sYXlvdXQgPSB7XG4gICAgICBsYWJlbDoge1xuICAgICAgICBmcmFjdGlvbkRpZ2l0czogMCxcbiAgICAgICAgcGFkZGluZzogdGhpcy5sYWJlbC5wYWRkaW5nLFxuICAgICAgICBmb3JtYXQ6IHRoaXMubGFiZWwuZm9ybWF0XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLnJhbmdlID0gWzAsIDFdO1xuICAgIHRoaXMudmlzaWJsZVJhbmdlID0gWzAsIDFdO1xuICAgIHRoaXMudGl0bGUgPSBuZXcgQXhpc1RpdGxlKCk7XG4gICAgdGhpcy5fdGl0bGVDYXB0aW9uID0gbmV3IENhcHRpb24oKTtcbiAgICB0aGlzLmdyaWRMZW5ndGggPSAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBncmlkIHRpY2tzIGFuZCB0aGUgYXhpcyB0aWNrcy5cbiAgICAgKi9cbiAgICB0aGlzLmdyaWRQYWRkaW5nID0gMDtcbiAgICAvKipcbiAgICAgKiBJcyB1c2VkIHRvIGF2b2lkIGNvbGxpc2lvbnMgYmV0d2VlbiBheGlzIGxhYmVscyBhbmQgc2VyaWVzLlxuICAgICAqL1xuICAgIHRoaXMuc2VyaWVzQXJlYVBhZGRpbmcgPSAwO1xuICAgIHRoaXMudGlja0dlbmVyYXRpb25SZXN1bHQgPSB2b2lkIDA7XG4gICAgdGhpcy5tYXhUaGlja25lc3MgPSBJbmZpbml0eTtcbiAgICB0aGlzLm1vZHVsZU1hcCA9IG5ldyBNb2R1bGVNYXAoKTtcbiAgICB0aGlzLnJhbmdlID0gdGhpcy5zY2FsZS5yYW5nZS5zbGljZSgpO1xuICAgIHRoaXMuY3Jvc3NMaW5lcy5mb3JFYWNoKChjcm9zc0xpbmUpID0+IHRoaXMuaW5pdENyb3NzTGluZShjcm9zc0xpbmUpKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaCh0aGlzLl90aXRsZUNhcHRpb24ucmVnaXN0ZXJJbnRlcmFjdGlvbih0aGlzLm1vZHVsZUN0eCkpO1xuICAgIHRoaXMuX3RpdGxlQ2FwdGlvbi5ub2RlLnJvdGF0aW9uID0gLU1hdGguUEkgLyAyO1xuICAgIHRoaXMuYXhpc0dyb3VwLmFwcGVuZENoaWxkKHRoaXMuX3RpdGxlQ2FwdGlvbi5ub2RlKTtcbiAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIgPSBtb2R1bGVDdHguYW5pbWF0aW9uTWFuYWdlcjtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gbmV3IFN0YXRlTWFjaGluZShcImVtcHR5XCIsIHtcbiAgICAgIGVtcHR5OiB7XG4gICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgIHRhcmdldDogXCJyZWFkeVwiLFxuICAgICAgICAgIGFjdGlvbjogKCkgPT4gdGhpcy5yZXNldFNlbGVjdGlvbk5vZGVzKClcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIlxuICAgICAgfSxcbiAgICAgIHJlYWR5OiB7XG4gICAgICAgIHVwZGF0ZTogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVJlYWR5VXBkYXRlKGRhdGEpLFxuICAgICAgICByZXNpemU6ICgpID0+IHRoaXMucmVzZXRTZWxlY3Rpb25Ob2RlcygpLFxuICAgICAgICByZXNldDogXCJlbXB0eVwiXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5fY3Jvc3NMaW5lcyA9IFtdO1xuICAgIGxldCBwcmV2aW91c1NpemUgPSB2b2lkIDA7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICBtb2R1bGVDdHgubGF5b3V0U2VydmljZS5hZGRMaXN0ZW5lcihcImxheW91dC1jb21wbGV0ZVwiLCAoZSkgPT4ge1xuICAgICAgICBpZiAocHJldmlvdXNTaXplICE9IG51bGwgJiYganNvbkRpZmYoZS5jaGFydCwgcHJldmlvdXNTaXplKSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwicmVzaXplXCIpO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzU2l6ZSA9IHsgLi4uZS5jaGFydCB9O1xuICAgICAgfSlcbiAgICApO1xuICB9XG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLnR5cGUgPz8gXCJcIjtcbiAgfVxuICBzZXQgY3Jvc3NMaW5lcyh2YWx1ZSkge1xuICAgIGNvbnN0IHsgQ3Jvc3NMaW5lQ29uc3RydWN0b3IgfSA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgdGhpcy5fY3Jvc3NMaW5lcy5mb3JFYWNoKChjcm9zc0xpbmUpID0+IHRoaXMuZGV0YWNoQ3Jvc3NMaW5lKGNyb3NzTGluZSkpO1xuICAgIHRoaXMuX2Nyb3NzTGluZXMgPSB2YWx1ZS5tYXAoKGNyb3NzTGluZSkgPT4ge1xuICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgQ3Jvc3NMaW5lQ29uc3RydWN0b3IoKTtcbiAgICAgIGluc3RhbmNlLnNldChjcm9zc0xpbmUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH0pO1xuICAgIHRoaXMuX2Nyb3NzTGluZXMuZm9yRWFjaCgoY3Jvc3NMaW5lKSA9PiB7XG4gICAgICB0aGlzLmF0dGFjaENyb3NzTGluZShjcm9zc0xpbmUpO1xuICAgICAgdGhpcy5pbml0Q3Jvc3NMaW5lKGNyb3NzTGluZSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGNyb3NzTGluZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nyb3NzTGluZXM7XG4gIH1cbiAgcmVzZXRBbmltYXRpb24ocGhhc2UpIHtcbiAgICBpZiAocGhhc2UgPT09IFwiaW5pdGlhbFwiKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJyZXNldFwiKTtcbiAgICB9XG4gIH1cbiAgYXR0YWNoQ3Jvc3NMaW5lKGNyb3NzTGluZSkge1xuICAgIHRoaXMuY3Jvc3NMaW5lR3JvdXAuYXBwZW5kQ2hpbGQoY3Jvc3NMaW5lLmdyb3VwKTtcbiAgICB0aGlzLmNyb3NzTGluZUdyb3VwLmFwcGVuZENoaWxkKGNyb3NzTGluZS5sYWJlbEdyb3VwKTtcbiAgfVxuICBkZXRhY2hDcm9zc0xpbmUoY3Jvc3NMaW5lKSB7XG4gICAgdGhpcy5jcm9zc0xpbmVHcm91cC5yZW1vdmVDaGlsZChjcm9zc0xpbmUuZ3JvdXApO1xuICAgIHRoaXMuY3Jvc3NMaW5lR3JvdXAucmVtb3ZlQ2hpbGQoY3Jvc3NMaW5lLmxhYmVsR3JvdXApO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5tb2R1bGVNYXAuZGVzdHJveSgpO1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChmKSA9PiBmKCkpO1xuICB9XG4gIHVwZGF0ZVJhbmdlKCkge1xuICAgIGNvbnN0IHsgcmFuZ2U6IHJyLCB2aXNpYmxlUmFuZ2U6IHZyLCBzY2FsZTogc2NhbGUyIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNwYW4gPSAocnJbMV0gLSByclswXSkgLyAodnJbMV0gLSB2clswXSk7XG4gICAgY29uc3Qgc2hpZnQgPSBzcGFuICogdnJbMF07XG4gICAgY29uc3Qgc3RhcnQgPSByclswXSAtIHNoaWZ0O1xuICAgIHNjYWxlMi5zZXRWaXNpYmxlUmFuZ2U/Lih2cik7XG4gICAgc2NhbGUyLnJhbmdlID0gW3N0YXJ0LCBzdGFydCArIHNwYW5dO1xuICAgIHRoaXMuY3Jvc3NMaW5lcy5mb3JFYWNoKChjcm9zc0xpbmUpID0+IHtcbiAgICAgIGNyb3NzTGluZS5jbGlwcGVkUmFuZ2UgPSBbcnJbMF0sIHJyWzFdXTtcbiAgICB9KTtcbiAgfVxuICBzZXRDcm9zc0xpbmVzVmlzaWJsZSh2aXNpYmxlKSB7XG4gICAgdGhpcy5jcm9zc0xpbmVHcm91cC52aXNpYmxlID0gdmlzaWJsZTtcbiAgfVxuICBhdHRhY2hBeGlzKGF4aXNOb2RlLCBncmlkTm9kZSkge1xuICAgIGdyaWROb2RlLmFwcGVuZENoaWxkKHRoaXMuZ3JpZEdyb3VwKTtcbiAgICBheGlzTm9kZS5hcHBlbmRDaGlsZCh0aGlzLmF4aXNHcm91cCk7XG4gICAgYXhpc05vZGUuYXBwZW5kQ2hpbGQodGhpcy5jcm9zc0xpbmVHcm91cCk7XG4gICAgYXhpc05vZGUuYXBwZW5kQ2hpbGQodGhpcy5sYWJlbEdyb3VwKTtcbiAgfVxuICBhdHRhY2hMYWJlbChheGlzTGFiZWxOb2RlKSB7XG4gICAgdGhpcy5sYWJlbEdyb3VwLmFwcGVuZChheGlzTGFiZWxOb2RlKTtcbiAgfVxuICBkZXRhY2hBeGlzKGF4aXNOb2RlLCBncmlkTm9kZSkge1xuICAgIGdyaWROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZ3JpZEdyb3VwKTtcbiAgICBheGlzTm9kZS5yZW1vdmVDaGlsZCh0aGlzLmF4aXNHcm91cCk7XG4gICAgYXhpc05vZGUucmVtb3ZlQ2hpbGQodGhpcy5jcm9zc0xpbmVHcm91cCk7XG4gICAgYXhpc05vZGUucmVtb3ZlQ2hpbGQodGhpcy5sYWJlbEdyb3VwKTtcbiAgfVxuICBnZXRBeGlzR3JvdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXhpc0dyb3VwO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYSBwb2ludCBvciBhbiBvYmplY3QgaXMgaW4gcmFuZ2UuXG4gICAqIEBwYXJhbSB4IEEgcG9pbnQgKG9yIG9iamVjdCdzIHN0YXJ0aW5nIHBvaW50KS5cbiAgICogQHBhcmFtIHRvbGVyYW5jZSBFeHBhbmRzIHRoZSByYW5nZSBvbiBib3RoIGVuZHMgYnkgdGhpcyBhbW91bnQuXG4gICAqL1xuICBpblJhbmdlKHgsIHRvbGVyYW5jZSA9IDApIHtcbiAgICBjb25zdCBbbWluLCBtYXhdID0gZmluZE1pbk1heCh0aGlzLnJhbmdlKTtcbiAgICByZXR1cm4geCA+PSBtaW4gLSB0b2xlcmFuY2UgJiYgeCA8PSBtYXggKyB0b2xlcmFuY2U7XG4gIH1cbiAgb25Gb3JtYXRDaGFuZ2UodGlja3MsIGZyYWN0aW9uRGlnaXRzLCBfZG9tYWluLCBmb3JtYXQpIHtcbiAgICBjb25zdCB7IHNjYWxlOiBzY2FsZTIgfSA9IHRoaXM7XG4gICAgY29uc3QgbG9nU2NhbGUgPSBzY2FsZTIgaW5zdGFuY2VvZiBMb2dTY2FsZTtcbiAgICBjb25zdCBkZWZhdWx0Rm9ybWF0dGVyID0gKGZvcm1hdE9mZnNldCkgPT4gbG9nU2NhbGUgPyBTdHJpbmcgOiAoeCkgPT4gdHlwZW9mIHggPT09IFwibnVtYmVyXCIgPyB4LnRvRml4ZWQoZnJhY3Rpb25EaWdpdHMgKyBmb3JtYXRPZmZzZXQpIDogU3RyaW5nKHgpO1xuICAgIGlmIChmb3JtYXQgJiYgc2NhbGUyICYmIHNjYWxlMi50aWNrRm9ybWF0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBzY2FsZTIudGlja0Zvcm1hdCh7IHRpY2tzLCBzcGVjaWZpZXI6IGZvcm1hdCB9KTtcbiAgICAgICAgdGhpcy5sYWJlbEZvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICAgICAgdGhpcy5kYXR1bUZvcm1hdHRlciA9IGZvcm1hdHRlcjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sYWJlbEZvcm1hdHRlciA9IGRlZmF1bHRGb3JtYXR0ZXIoMCk7XG4gICAgICAgIHRoaXMuZGF0dW1Gb3JtYXR0ZXIgPSBkZWZhdWx0Rm9ybWF0dGVyKDEpO1xuICAgICAgICBMb2dnZXIud2Fybk9uY2UoYHRoZSBheGlzIGxhYmVsIGZvcm1hdCBzdHJpbmcgJHtmb3JtYXR9IGlzIGludmFsaWQuIE5vIGZvcm1hdHRpbmcgd2lsbCBiZSBhcHBsaWVkYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGFiZWxGb3JtYXR0ZXIgPSBkZWZhdWx0Rm9ybWF0dGVyKDApO1xuICAgICAgdGhpcy5kYXR1bUZvcm1hdHRlciA9IGRlZmF1bHRGb3JtYXR0ZXIoMSk7XG4gICAgfVxuICB9XG4gIHNldFRpY2tJbnRlcnZhbChpbnRlcnZhbCkge1xuICAgIHRoaXMuc2NhbGUuaW50ZXJ2YWwgPSB0aGlzLmludGVydmFsPy5zdGVwID8/IGludGVydmFsO1xuICB9XG4gIG9uR3JpZExlbmd0aENoYW5nZSh2YWx1ZSwgcHJldlZhbHVlKSB7XG4gICAgaWYgKHByZXZWYWx1ZSAmJiAhdmFsdWUgfHwgIXByZXZWYWx1ZSAmJiB2YWx1ZSkge1xuICAgICAgdGhpcy5vbkdyaWRWaXNpYmlsaXR5Q2hhbmdlKCk7XG4gICAgfVxuICAgIHRoaXMuY3Jvc3NMaW5lcy5mb3JFYWNoKChjcm9zc0xpbmUpID0+IHRoaXMuaW5pdENyb3NzTGluZShjcm9zc0xpbmUpKTtcbiAgfVxuICBvbkdyaWRWaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgIHRoaXMuZ3JpZExpbmVHcm91cFNlbGVjdGlvbi5jbGVhcigpO1xuICB9XG4gIGNyZWF0ZUxhYmVsKCkge1xuICAgIHJldHVybiBuZXcgQXhpc0xhYmVsKCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMvcmVtb3Zlcy91cGRhdGVzIHRoZSBzY2VuZSBncmFwaCBub2RlcyB0aGF0IGNvbnN0aXR1dGUgdGhlIGF4aXMuXG4gICAqL1xuICB1cGRhdGUoX3ByaW1hcnlUaWNrQ291bnQgPSAwLCBhbmltYXRlZCA9IHRydWUpIHtcbiAgICBpZiAoIXRoaXMudGlja0dlbmVyYXRpb25SZXN1bHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyByb3RhdGlvbiwgcGFyYWxsZWxGbGlwUm90YXRpb24sIHJlZ3VsYXJGbGlwUm90YXRpb24gfSA9IHRoaXMuY2FsY3VsYXRlUm90YXRpb25zKCk7XG4gICAgY29uc3Qgc2lkZUZsYWcgPSB0aGlzLmxhYmVsLmdldFNpZGVGbGFnKCk7XG4gICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuICAgIGNvbnN0IGxpbmVEYXRhID0gdGhpcy5nZXRBeGlzTGluZUNvb3JkaW5hdGVzKCk7XG4gICAgY29uc3QgeyB0aWNrRGF0YSwgY29tYmluZWRSb3RhdGlvbiwgdGV4dEJhc2VsaW5lLCB0ZXh0QWxpZ24sIHByaW1hcnlUaWNrQ291bnQgfSA9IHRoaXMudGlja0dlbmVyYXRpb25SZXN1bHQ7XG4gICAgY29uc3QgcHJldmlvdXNUaWNrcyA9IHRoaXMudGlja0xhYmVsR3JvdXBTZWxlY3Rpb24ubm9kZXMoKS5tYXAoKG5vZGUpID0+IG5vZGUuZGF0dW0udGlja0lkKTtcbiAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbnMobGluZURhdGEsIHRpY2tEYXRhLnRpY2tzLCB7XG4gICAgICBjb21iaW5lZFJvdGF0aW9uLFxuICAgICAgdGV4dEFsaWduLFxuICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgcmFuZ2U6IHRoaXMuc2NhbGUucmFuZ2VcbiAgICB9KTtcbiAgICBpZiAoIWFuaW1hdGVkIHx8IHRoaXMuYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKSkge1xuICAgICAgdGhpcy5yZXNldFNlbGVjdGlvbk5vZGVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGRpZmYyID0gdGhpcy5jYWxjdWxhdGVVcGRhdGVEaWZmKHByZXZpb3VzVGlja3MsIHRpY2tEYXRhKTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZVwiLCBkaWZmMik7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlQXhpc0xpbmUoKTtcbiAgICB0aGlzLnVwZGF0ZUxhYmVscygpO1xuICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIHRoaXMudXBkYXRlR3JpZExpbmVzKHNpZGVGbGFnKTtcbiAgICB0aGlzLnVwZGF0ZVRpY2tMaW5lcygpO1xuICAgIHRoaXMudXBkYXRlVGl0bGUoeyBhbnlUaWNrVmlzaWJsZTogdGlja0RhdGEudGlja3MubGVuZ3RoID4gMCB9KTtcbiAgICB0aGlzLnVwZGF0ZUNyb3NzTGluZXMoeyByb3RhdGlvbiwgcGFyYWxsZWxGbGlwUm90YXRpb24sIHJlZ3VsYXJGbGlwUm90YXRpb24gfSk7XG4gICAgdGhpcy51cGRhdGVMYXlvdXRTdGF0ZSh0aWNrRGF0YS5mcmFjdGlvbkRpZ2l0cyk7XG4gICAgcmV0dXJuIHByaW1hcnlUaWNrQ291bnQ7XG4gIH1cbiAgZ2V0QXhpc0xpbmVDb29yZGluYXRlcygpIHtcbiAgICBjb25zdCBbbWluLCBtYXhdID0gZmluZE1pbk1heCh0aGlzLnJhbmdlKTtcbiAgICByZXR1cm4geyB4OiAwLCB5MTogbWluLCB5MjogbWF4IH07XG4gIH1cbiAgZ2V0VGlja0xpbmVDb29yZGluYXRlcyhkYXR1bSkge1xuICAgIGNvbnN0IHNpZGVGbGFnID0gdGhpcy5sYWJlbC5nZXRTaWRlRmxhZygpO1xuICAgIGNvbnN0IHggPSBzaWRlRmxhZyAqIHRoaXMuZ2V0VGlja1NpemUoKTtcbiAgICBjb25zdCB4MSA9IE1hdGgubWluKDAsIHgpO1xuICAgIGNvbnN0IHgyID0geDEgKyBNYXRoLmFicyh4KTtcbiAgICBjb25zdCB5ID0gZGF0dW0udHJhbnNsYXRpb25ZO1xuICAgIHJldHVybiB7IHgxLCB4MiwgeSB9O1xuICB9XG4gIGdldFRpY2tMYWJlbFByb3BzKGRhdHVtLCBwYXJhbXMpIHtcbiAgICBjb25zdCB7IGxhYmVsIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgY29tYmluZWRSb3RhdGlvbiwgdGV4dEJhc2VsaW5lLCB0ZXh0QWxpZ24sIHJhbmdlOiByYW5nZTMgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0ZXh0ID0gZGF0dW0udGlja0xhYmVsO1xuICAgIGNvbnN0IHNpZGVGbGFnID0gbGFiZWwuZ2V0U2lkZUZsYWcoKTtcbiAgICBjb25zdCBsYWJlbFggPSBzaWRlRmxhZyAqICh0aGlzLmdldFRpY2tTaXplKCkgKyBsYWJlbC5wYWRkaW5nICsgdGhpcy5zZXJpZXNBcmVhUGFkZGluZyk7XG4gICAgY29uc3QgdmlzaWJsZSA9IHRleHQgIT09IFwiXCIgJiYgdGV4dCAhPSBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICB0aWNrSWQ6IGRhdHVtLnRpY2tJZCxcbiAgICAgIHRyYW5zbGF0aW9uWTogZGF0dW0udHJhbnNsYXRpb25ZLFxuICAgICAgZmlsbDogbGFiZWwuY29sb3IsXG4gICAgICBmb250RmFtaWx5OiBsYWJlbC5mb250RmFtaWx5LFxuICAgICAgZm9udFNpemU6IGxhYmVsLmZvbnRTaXplLFxuICAgICAgZm9udFN0eWxlOiBsYWJlbC5mb250U3R5bGUsXG4gICAgICBmb250V2VpZ2h0OiBsYWJlbC5mb250V2VpZ2h0LFxuICAgICAgcm90YXRpb246IGNvbWJpbmVkUm90YXRpb24sXG4gICAgICByb3RhdGlvbkNlbnRlclg6IGxhYmVsWCxcbiAgICAgIHRleHQsXG4gICAgICB0ZXh0QWxpZ24sXG4gICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgICB2aXNpYmxlLFxuICAgICAgeDogbGFiZWxYLFxuICAgICAgeTogMCxcbiAgICAgIHJhbmdlOiByYW5nZTNcbiAgICB9O1xuICB9XG4gIGdldFRpY2tTaXplKCkge1xuICAgIHJldHVybiB0aGlzLnRpY2suZW5hYmxlZCA/IHRoaXMudGljay5zaXplIDogNjtcbiAgfVxuICBzZXRUaXRsZVByb3BzKGNhcHRpb24sIHBhcmFtcykge1xuICAgIGNvbnN0IHsgdGl0bGUgfSA9IHRoaXM7XG4gICAgaWYgKCF0aXRsZS5lbmFibGVkKSB7XG4gICAgICBjYXB0aW9uLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIGNhcHRpb24ubm9kZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhcHRpb24uY29sb3IgPSB0aXRsZS5jb2xvcjtcbiAgICBjYXB0aW9uLmZvbnRGYW1pbHkgPSB0aXRsZS5mb250RmFtaWx5O1xuICAgIGNhcHRpb24uZm9udFNpemUgPSB0aXRsZS5mb250U2l6ZTtcbiAgICBjYXB0aW9uLmZvbnRTdHlsZSA9IHRpdGxlLmZvbnRTdHlsZTtcbiAgICBjYXB0aW9uLmZvbnRXZWlnaHQgPSB0aXRsZS5mb250V2VpZ2h0O1xuICAgIGNhcHRpb24uZW5hYmxlZCA9IHRpdGxlLmVuYWJsZWQ7XG4gICAgY2FwdGlvbi53cmFwcGluZyA9IHRpdGxlLndyYXBwaW5nO1xuICAgIGNvbnN0IHRpdGxlTm9kZSA9IGNhcHRpb24ubm9kZTtcbiAgICBjb25zdCBwYWRkaW5nID0gKHRpdGxlLnNwYWNpbmcgPz8gMCkgKyBwYXJhbXMuc3BhY2luZztcbiAgICBjb25zdCBzaWRlRmxhZyA9IHRoaXMubGFiZWwuZ2V0U2lkZUZsYWcoKTtcbiAgICBjb25zdCBwYXJhbGxlbEZsaXBSb3RhdGlvbiA9IG5vcm1hbGl6ZUFuZ2xlMzYwKHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IHRpdGxlUm90YXRpb25GbGFnID0gc2lkZUZsYWcgPT09IC0xICYmIHBhcmFsbGVsRmxpcFJvdGF0aW9uID4gTWF0aC5QSSAmJiBwYXJhbGxlbEZsaXBSb3RhdGlvbiA8IE1hdGguUEkgKiAyID8gLTEgOiAxO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdGl0bGVSb3RhdGlvbkZsYWcgKiBzaWRlRmxhZyAqIE1hdGguUEkgLyAyO1xuICAgIGNvbnN0IHRleHRCYXNlbGluZSA9IHRpdGxlUm90YXRpb25GbGFnID09PSAxID8gXCJib3R0b21cIiA6IFwidG9wXCI7XG4gICAgY29uc3QgeyByYW5nZTogcmFuZ2UzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHggPSBNYXRoLmZsb29yKHRpdGxlUm90YXRpb25GbGFnICogc2lkZUZsYWcgKiAocmFuZ2UzWzBdICsgcmFuZ2UzWzFdKSAvIDIpO1xuICAgIGNvbnN0IHkgPSBzaWRlRmxhZyA9PT0gLTEgPyBNYXRoLmZsb29yKHRpdGxlUm90YXRpb25GbGFnICogLXBhZGRpbmcpIDogTWF0aC5mbG9vcigtcGFkZGluZyk7XG4gICAgY29uc3QgeyBjYWxsYmFja0NhY2hlIH0gPSB0aGlzLm1vZHVsZUN0eDtcbiAgICBjb25zdCB7IGZvcm1hdHRlciA9IChwKSA9PiBwLmRlZmF1bHRWYWx1ZSB9ID0gdGl0bGU7XG4gICAgY29uc3QgdGV4dCA9IGNhbGxiYWNrQ2FjaGUuY2FsbChmb3JtYXR0ZXIsIHRoaXMuZ2V0VGl0bGVGb3JtYXR0ZXJQYXJhbXMoKSk7XG4gICAgdGl0bGVOb2RlLnNldFByb3BlcnRpZXMoe1xuICAgICAgcm90YXRpb24sXG4gICAgICB0ZXh0LFxuICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSk7XG4gIH1cbiAgY2FsY3VsYXRlTGF5b3V0KHByaW1hcnlUaWNrQ291bnQpIHtcbiAgICBjb25zdCB7IHJvdGF0aW9uLCBwYXJhbGxlbEZsaXBSb3RhdGlvbiwgcmVndWxhckZsaXBSb3RhdGlvbiB9ID0gdGhpcy5jYWxjdWxhdGVSb3RhdGlvbnMoKTtcbiAgICBjb25zdCBzaWRlRmxhZyA9IHRoaXMubGFiZWwuZ2V0U2lkZUZsYWcoKTtcbiAgICBjb25zdCBsYWJlbFggPSBzaWRlRmxhZyAqICh0aGlzLmdldFRpY2tTaXplKCkgKyB0aGlzLmxhYmVsLnBhZGRpbmcgKyB0aGlzLnNlcmllc0FyZWFQYWRkaW5nKTtcbiAgICB0aGlzLnVwZGF0ZVNjYWxlKCk7XG4gICAgdGhpcy50aWNrR2VuZXJhdGlvblJlc3VsdCA9IHRoaXMuZ2VuZXJhdGVUaWNrcyh7XG4gICAgICBwcmltYXJ5VGlja0NvdW50LFxuICAgICAgcGFyYWxsZWxGbGlwUm90YXRpb24sXG4gICAgICByZWd1bGFyRmxpcFJvdGF0aW9uLFxuICAgICAgbGFiZWxYLFxuICAgICAgc2lkZUZsYWdcbiAgICB9KTtcbiAgICBjb25zdCB7IHRpY2tEYXRhLCBjb21iaW5lZFJvdGF0aW9uLCB0ZXh0QmFzZWxpbmUsIHRleHRBbGlnbiwgLi4udGlja3NSZXN1bHQgfSA9IHRoaXMudGlja0dlbmVyYXRpb25SZXN1bHQ7XG4gICAgdGhpcy51cGRhdGVMYXlvdXRTdGF0ZSh0aWNrRGF0YS5mcmFjdGlvbkRpZ2l0cyk7XG4gICAgY29uc3QgYm94ZXMgPSBbXTtcbiAgICBjb25zdCB7IHgsIHkxLCB5MiB9ID0gdGhpcy5nZXRBeGlzTGluZUNvb3JkaW5hdGVzKCk7XG4gICAgY29uc3QgbGluZUJveCA9IG5ldyBCQm94KFxuICAgICAgeCArIE1hdGgubWluKHNpZGVGbGFnICogdGhpcy5zZXJpZXNBcmVhUGFkZGluZywgMCksXG4gICAgICB5MSxcbiAgICAgIHRoaXMuc2VyaWVzQXJlYVBhZGRpbmcsXG4gICAgICB5MiAtIHkxXG4gICAgKTtcbiAgICBib3hlcy5wdXNoKGxpbmVCb3gpO1xuICAgIGlmICh0aGlzLnRpY2suZW5hYmxlZCkge1xuICAgICAgdGlja0RhdGEudGlja3MuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgICAgY29uc3QgeyB4MSwgeDIsIHkgfSA9IHRoaXMuZ2V0VGlja0xpbmVDb29yZGluYXRlcyhkYXR1bSk7XG4gICAgICAgIGNvbnN0IHRpY2tMaW5lQm94ID0gbmV3IEJCb3goeDEsIHksIHgyIC0geDEsIDApO1xuICAgICAgICBib3hlcy5wdXNoKHRpY2tMaW5lQm94KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5sYWJlbC5lbmFibGVkKSB7XG4gICAgICBjb25zdCB0ZW1wVGV4dCA9IG5ldyBUZXh0KCk7XG4gICAgICB0aWNrRGF0YS50aWNrcy5mb3JFYWNoKChkYXR1bSkgPT4ge1xuICAgICAgICBjb25zdCBsYWJlbFByb3BzID0gdGhpcy5nZXRUaWNrTGFiZWxQcm9wcyhkYXR1bSwge1xuICAgICAgICAgIGNvbWJpbmVkUm90YXRpb24sXG4gICAgICAgICAgdGV4dEFsaWduLFxuICAgICAgICAgIHRleHRCYXNlbGluZSxcbiAgICAgICAgICByYW5nZTogdGhpcy5zY2FsZS5yYW5nZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFsYWJlbFByb3BzLnZpc2libGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGVtcFRleHQuc2V0UHJvcGVydGllcyh7XG4gICAgICAgICAgLi4ubGFiZWxQcm9wcyxcbiAgICAgICAgICB0cmFuc2xhdGlvblk6IE1hdGgucm91bmQoZGF0dW0udHJhbnNsYXRpb25ZKVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYm94ID0gdGVtcFRleHQuY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpO1xuICAgICAgICBpZiAoYm94KSB7XG4gICAgICAgICAgYm94ZXMucHVzaChib3gpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGl0bGU/LmVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IGNhcHRpb24gPSBuZXcgQ2FwdGlvbigpO1xuICAgICAgY29uc3Qgc3BhY2luZyA9IEJCb3gubWVyZ2UoYm94ZXMpLndpZHRoO1xuICAgICAgdGhpcy5zZXRUaXRsZVByb3BzKGNhcHRpb24sIHsgc3BhY2luZyB9KTtcbiAgICAgIGNvbnN0IHRpdGxlTm9kZSA9IGNhcHRpb24ubm9kZTtcbiAgICAgIGNvbnN0IHRpdGxlQm94ID0gdGl0bGVOb2RlLmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKTtcbiAgICAgIGlmICh0aXRsZUJveCkge1xuICAgICAgICBib3hlcy5wdXNoKHRpdGxlQm94KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYmJveCA9IEJCb3gubWVyZ2UoYm94ZXMpO1xuICAgIGNvbnN0IHRyYW5zZm9ybWVkQkJveCA9IHRoaXMuZ2V0VHJhbnNmb3JtQm94KGJib3gpO1xuICAgIGNvbnN0IGFueVNlcmllc0FjdGl2ZSA9IHRoaXMuaXNBbnlTZXJpZXNBY3RpdmUoKTtcbiAgICB0aGlzLmNyb3NzTGluZXMuZm9yRWFjaCgoY3Jvc3NMaW5lKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjcm9zc0xpbmUuc2lkZUZsYWcgPSAtc2lkZUZsYWc7XG4gICAgICBjcm9zc0xpbmUuZGlyZWN0aW9uID0gcm90YXRpb24gPT09IC1NYXRoLlBJIC8gMiA/IFwieFwiIC8qIFggKi8gOiBcInlcIiAvKiBZICovO1xuICAgICAgaWYgKGNyb3NzTGluZSBpbnN0YW5jZW9mIENhcnRlc2lhbkNyb3NzTGluZSkge1xuICAgICAgICAoX2EgPSBjcm9zc0xpbmUubGFiZWwpLnBhcmFsbGVsID8/IChfYS5wYXJhbGxlbCA9IHRoaXMubGFiZWwucGFyYWxsZWwpO1xuICAgICAgfVxuICAgICAgY3Jvc3NMaW5lLnBhcmFsbGVsRmxpcFJvdGF0aW9uID0gcGFyYWxsZWxGbGlwUm90YXRpb247XG4gICAgICBjcm9zc0xpbmUucmVndWxhckZsaXBSb3RhdGlvbiA9IHJlZ3VsYXJGbGlwUm90YXRpb247XG4gICAgICBjcm9zc0xpbmUuY2FsY3VsYXRlTGF5b3V0Py4oYW55U2VyaWVzQWN0aXZlLCB0aGlzLnJldmVyc2UpO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBwcmltYXJ5VGlja0NvdW50OiB0aWNrc1Jlc3VsdC5wcmltYXJ5VGlja0NvdW50LFxuICAgICAgYmJveDogdHJhbnNmb3JtZWRCQm94XG4gICAgfTtcbiAgfVxuICB1cGRhdGVMYXlvdXRTdGF0ZShmcmFjdGlvbkRpZ2l0cykge1xuICAgIHRoaXMubGF5b3V0LmxhYmVsID0ge1xuICAgICAgZnJhY3Rpb25EaWdpdHMsXG4gICAgICBwYWRkaW5nOiB0aGlzLmxhYmVsLnBhZGRpbmcsXG4gICAgICBmb3JtYXQ6IHRoaXMubGFiZWwuZm9ybWF0XG4gICAgfTtcbiAgfVxuICBnZXRUcmFuc2Zvcm1Cb3goYmJveCkge1xuICAgIGNvbnN0IG1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICBjb25zdCB7XG4gICAgICByb3RhdGlvbjogYXhpc1JvdGF0aW9uLFxuICAgICAgdHJhbnNsYXRpb25YLFxuICAgICAgdHJhbnNsYXRpb25ZLFxuICAgICAgcm90YXRpb25DZW50ZXJYLFxuICAgICAgcm90YXRpb25DZW50ZXJZXG4gICAgfSA9IHRoaXMuZ2V0QXhpc1RyYW5zZm9ybSgpO1xuICAgIE1hdHJpeC51cGRhdGVUcmFuc2Zvcm1NYXRyaXgobWF0cml4LCAxLCAxLCBheGlzUm90YXRpb24sIHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZLCB7XG4gICAgICBzY2FsaW5nQ2VudGVyWDogMCxcbiAgICAgIHNjYWxpbmdDZW50ZXJZOiAwLFxuICAgICAgcm90YXRpb25DZW50ZXJYLFxuICAgICAgcm90YXRpb25DZW50ZXJZXG4gICAgfSk7XG4gICAgcmV0dXJuIG1hdHJpeC50cmFuc2Zvcm1CQm94KGJib3gpO1xuICB9XG4gIHNldERvbWFpbihkb21haW4pIHtcbiAgICB0aGlzLmRhdGFEb21haW4gPSB0aGlzLm5vcm1hbGlzZURhdGFEb21haW4oZG9tYWluKTtcbiAgICBpZiAodGhpcy5yZXZlcnNlKSB7XG4gICAgICB0aGlzLmRhdGFEb21haW4uZG9tYWluLnJldmVyc2UoKTtcbiAgICB9XG4gICAgdGhpcy5zY2FsZS5kb21haW4gPSB0aGlzLmRhdGFEb21haW4uZG9tYWluO1xuICB9XG4gIHVwZGF0ZVNjYWxlKCkge1xuICAgIHRoaXMudXBkYXRlUmFuZ2UoKTtcbiAgICB0aGlzLmNhbGN1bGF0ZURvbWFpbigpO1xuICAgIHRoaXMuc2V0VGlja0ludGVydmFsKHRoaXMuaW50ZXJ2YWwuc3RlcCk7XG4gICAgY29uc3QgeyBzY2FsZTogc2NhbGUyLCBuaWNlIH0gPSB0aGlzO1xuICAgIGlmICghQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2NhbGUyLm5pY2UgPSBuaWNlO1xuICAgIHNjYWxlMi51cGRhdGUoKTtcbiAgfVxuICBjYWxjdWxhdGVSb3RhdGlvbnMoKSB7XG4gICAgY29uc3Qgcm90YXRpb24gPSB0b1JhZGlhbnModGhpcy5yb3RhdGlvbik7XG4gICAgY29uc3QgcGFyYWxsZWxGbGlwUm90YXRpb24gPSBub3JtYWxpemVBbmdsZTM2MChyb3RhdGlvbik7XG4gICAgY29uc3QgcmVndWxhckZsaXBSb3RhdGlvbiA9IG5vcm1hbGl6ZUFuZ2xlMzYwKHJvdGF0aW9uIC0gTWF0aC5QSSAvIDIpO1xuICAgIHJldHVybiB7IHJvdGF0aW9uLCBwYXJhbGxlbEZsaXBSb3RhdGlvbiwgcmVndWxhckZsaXBSb3RhdGlvbiB9O1xuICB9XG4gIGdlbmVyYXRlVGlja3Moe1xuICAgIHByaW1hcnlUaWNrQ291bnQsXG4gICAgcGFyYWxsZWxGbGlwUm90YXRpb24sXG4gICAgcmVndWxhckZsaXBSb3RhdGlvbixcbiAgICBsYWJlbFgsXG4gICAgc2lkZUZsYWdcbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNjYWxlOiBzY2FsZTIsXG4gICAgICBpbnRlcnZhbDogeyBtaW5TcGFjaW5nLCBtYXhTcGFjaW5nIH0sXG4gICAgICBsYWJlbDogeyBwYXJhbGxlbCwgcm90YXRpb24sIGZvbnRGYW1pbHksIGZvbnRTaXplLCBmb250U3R5bGUsIGZvbnRXZWlnaHQgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNlY29uZGFyeUF4aXMgPSBwcmltYXJ5VGlja0NvdW50ICE9PSB2b2lkIDA7XG4gICAgY29uc3QgeyBkZWZhdWx0Um90YXRpb24sIGNvbmZpZ3VyZWRSb3RhdGlvbiwgcGFyYWxsZWxGbGlwRmxhZywgcmVndWxhckZsaXBGbGFnIH0gPSBjYWxjdWxhdGVMYWJlbFJvdGF0aW9uKHtcbiAgICAgIHJvdGF0aW9uLFxuICAgICAgcGFyYWxsZWwsXG4gICAgICByZWd1bGFyRmxpcFJvdGF0aW9uLFxuICAgICAgcGFyYWxsZWxGbGlwUm90YXRpb25cbiAgICB9KTtcbiAgICBjb25zdCBpbml0aWFsUm90YXRpb24gPSBjb25maWd1cmVkUm90YXRpb24gKyBkZWZhdWx0Um90YXRpb247XG4gICAgY29uc3QgbGFiZWxNYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgY29uc3QgeyBtYXhUaWNrQ291bnQgfSA9IHRoaXMuZXN0aW1hdGVUaWNrQ291bnQoeyBtaW5TcGFjaW5nLCBtYXhTcGFjaW5nIH0pO1xuICAgIGNvbnN0IGNvbnRpbnVvdXMgPSBDb250aW51b3VzU2NhbGUuaXMoc2NhbGUyKSB8fCBPcmRpbmFsVGltZVNjYWxlLmlzKHNjYWxlMik7XG4gICAgY29uc3QgbWF4SXRlcmF0aW9ucyA9ICFjb250aW51b3VzIHx8IGlzTmFOKG1heFRpY2tDb3VudCkgPyAxMCA6IG1heFRpY2tDb3VudDtcbiAgICBsZXQgdGV4dEFsaWduID0gZ2V0VGV4dEFsaWduKHBhcmFsbGVsLCBjb25maWd1cmVkUm90YXRpb24sIDAsIHNpZGVGbGFnLCByZWd1bGFyRmxpcEZsYWcpO1xuICAgIGNvbnN0IHRleHRCYXNlbGluZSA9IGdldFRleHRCYXNlbGluZShwYXJhbGxlbCwgY29uZmlndXJlZFJvdGF0aW9uLCBzaWRlRmxhZywgcGFyYWxsZWxGbGlwRmxhZyk7XG4gICAgY29uc3QgZm9udCA9IFRleHRVdGlscy50b0ZvbnRTdHJpbmcoeyBmb250RmFtaWx5LCBmb250U2l6ZSwgZm9udFN0eWxlLCBmb250V2VpZ2h0IH0pO1xuICAgIGNvbnN0IHRleHRNZWFzdXJlciA9IENhY2hlZFRleHRNZWFzdXJlclBvb2wuZ2V0TWVhc3VyZXIoeyBmb250IH0pO1xuICAgIGNvbnN0IHRleHRQcm9wcyA9IHtcbiAgICAgIGZvbnRGYW1pbHksXG4gICAgICBmb250U2l6ZSxcbiAgICAgIGZvbnRTdHlsZSxcbiAgICAgIGZvbnRXZWlnaHQsXG4gICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgICB0ZXh0QWxpZ25cbiAgICB9O1xuICAgIGxldCB0aWNrRGF0YSA9IHtcbiAgICAgIHJhd1RpY2tzOiBbXSxcbiAgICAgIGZyYWN0aW9uRGlnaXRzOiAwLFxuICAgICAgdGlja3M6IFtdLFxuICAgICAgbGFiZWxDb3VudDogMFxuICAgIH07XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICBsZXQgYXV0b1JvdGF0aW9uID0gMDtcbiAgICBsZXQgbGFiZWxPdmVybGFwID0gdHJ1ZTtcbiAgICBsZXQgdGVybWluYXRlID0gZmFsc2U7XG4gICAgd2hpbGUgKGxhYmVsT3ZlcmxhcCAmJiBpbmRleCA8PSBtYXhJdGVyYXRpb25zKSB7XG4gICAgICBpZiAodGVybWluYXRlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYXV0b1JvdGF0aW9uID0gMDtcbiAgICAgIHRleHRBbGlnbiA9IGdldFRleHRBbGlnbihwYXJhbGxlbCwgY29uZmlndXJlZFJvdGF0aW9uLCAwLCBzaWRlRmxhZywgcmVndWxhckZsaXBGbGFnKTtcbiAgICAgIGNvbnN0IHRpY2tTdHJhdGVnaWVzID0gdGhpcy5nZXRUaWNrU3RyYXRlZ2llcyh7IHNlY29uZGFyeUF4aXMsIGluZGV4IH0pO1xuICAgICAgZm9yIChjb25zdCBzdHJhdGVneSBvZiB0aWNrU3RyYXRlZ2llcykge1xuICAgICAgICAoeyB0aWNrRGF0YSwgaW5kZXgsIGF1dG9Sb3RhdGlvbiwgdGVybWluYXRlIH0gPSBzdHJhdGVneSh7XG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgdGlja0RhdGEsXG4gICAgICAgICAgdGV4dFByb3BzLFxuICAgICAgICAgIGxhYmVsT3ZlcmxhcCxcbiAgICAgICAgICB0ZXJtaW5hdGUsXG4gICAgICAgICAgcHJpbWFyeVRpY2tDb3VudFxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHJvdGF0ZWQgPSBjb25maWd1cmVkUm90YXRpb24gIT09IDAgfHwgYXV0b1JvdGF0aW9uICE9PSAwO1xuICAgICAgICBjb25zdCBsYWJlbFJvdGF0aW9uID0gaW5pdGlhbFJvdGF0aW9uICsgYXV0b1JvdGF0aW9uO1xuICAgICAgICB0ZXh0QWxpZ24gPSBnZXRUZXh0QWxpZ24ocGFyYWxsZWwsIGNvbmZpZ3VyZWRSb3RhdGlvbiwgYXV0b1JvdGF0aW9uLCBzaWRlRmxhZywgcmVndWxhckZsaXBGbGFnKTtcbiAgICAgICAgbGFiZWxPdmVybGFwID0gdGhpcy5sYWJlbC5hdm9pZENvbGxpc2lvbnMgPyB0aGlzLmNoZWNrTGFiZWxPdmVybGFwKGxhYmVsUm90YXRpb24sIHJvdGF0ZWQsIGxhYmVsTWF0cml4LCB0aWNrRGF0YS50aWNrcywgbGFiZWxYLCB0ZXh0TWVhc3VyZXIpIDogZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNvbWJpbmVkUm90YXRpb24gPSBkZWZhdWx0Um90YXRpb24gKyBjb25maWd1cmVkUm90YXRpb24gKyBhdXRvUm90YXRpb247XG4gICAgaWYgKCFzZWNvbmRhcnlBeGlzICYmIHRpY2tEYXRhLnJhd1RpY2tzLmxlbmd0aCA+IDApIHtcbiAgICAgIHByaW1hcnlUaWNrQ291bnQgPSB0aWNrRGF0YS5yYXdUaWNrcy5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiB7IHRpY2tEYXRhLCBwcmltYXJ5VGlja0NvdW50LCBjb21iaW5lZFJvdGF0aW9uLCB0ZXh0QmFzZWxpbmUsIHRleHRBbGlnbiB9O1xuICB9XG4gIGdldFRpY2tTdHJhdGVnaWVzKHtcbiAgICBpbmRleDogaXRlcmF0aW9uLFxuICAgIHNlY29uZGFyeUF4aXNcbiAgfSkge1xuICAgIGNvbnN0IHsgc2NhbGU6IHNjYWxlMiwgbGFiZWwgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBtaW5TcGFjaW5nIH0gPSB0aGlzLmludGVydmFsO1xuICAgIGNvbnN0IGNvbnRpbnVvdXMgPSBDb250aW51b3VzU2NhbGUuaXMoc2NhbGUyKSB8fCBPcmRpbmFsVGltZVNjYWxlLmlzKHNjYWxlMik7XG4gICAgY29uc3QgYXZvaWRMYWJlbENvbGxpc2lvbnMgPSBsYWJlbC5lbmFibGVkICYmIGxhYmVsLmF2b2lkQ29sbGlzaW9ucztcbiAgICBjb25zdCBmaWx0ZXJUaWNrcyA9ICFjb250aW51b3VzICYmIGl0ZXJhdGlvbiAhPT0gMCAmJiBhdm9pZExhYmVsQ29sbGlzaW9ucztcbiAgICBjb25zdCBhdXRvUm90YXRlID0gbGFiZWwuYXV0b1JvdGF0ZSA9PT0gdHJ1ZSAmJiBsYWJlbC5yb3RhdGlvbiA9PT0gdm9pZCAwO1xuICAgIGNvbnN0IHN0cmF0ZWdpZXMgPSBbXTtcbiAgICBsZXQgdGlja0dlbmVyYXRpb25UeXBlO1xuICAgIGlmICh0aGlzLmludGVydmFsLnZhbHVlcykge1xuICAgICAgdGlja0dlbmVyYXRpb25UeXBlID0gMyAvKiBWQUxVRVMgKi87XG4gICAgfSBlbHNlIGlmIChzZWNvbmRhcnlBeGlzKSB7XG4gICAgICB0aWNrR2VuZXJhdGlvblR5cGUgPSAxIC8qIENSRUFURV9TRUNPTkRBUlkgKi87XG4gICAgfSBlbHNlIGlmIChmaWx0ZXJUaWNrcykge1xuICAgICAgdGlja0dlbmVyYXRpb25UeXBlID0gMiAvKiBGSUxURVIgKi87XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpY2tHZW5lcmF0aW9uVHlwZSA9IDAgLyogQ1JFQVRFICovO1xuICAgIH1cbiAgICBjb25zdCB0aWNrR2VuZXJhdGlvblN0cmF0ZWd5ID0gKHsgaW5kZXgsIHRpY2tEYXRhLCBwcmltYXJ5VGlja0NvdW50LCB0ZXJtaW5hdGUgfSkgPT4gdGhpcy5jcmVhdGVUaWNrRGF0YSh0aWNrR2VuZXJhdGlvblR5cGUsIGluZGV4LCB0aWNrRGF0YSwgdGVybWluYXRlLCBwcmltYXJ5VGlja0NvdW50KTtcbiAgICBzdHJhdGVnaWVzLnB1c2godGlja0dlbmVyYXRpb25TdHJhdGVneSk7XG4gICAgaWYgKCFjb250aW51b3VzICYmICFpc05hTihtaW5TcGFjaW5nKSkge1xuICAgICAgY29uc3QgdGlja0ZpbHRlclN0cmF0ZWd5ID0gKHsgaW5kZXgsIHRpY2tEYXRhLCBwcmltYXJ5VGlja0NvdW50LCB0ZXJtaW5hdGUgfSkgPT4gdGhpcy5jcmVhdGVUaWNrRGF0YSgyIC8qIEZJTFRFUiAqLywgaW5kZXgsIHRpY2tEYXRhLCB0ZXJtaW5hdGUsIHByaW1hcnlUaWNrQ291bnQpO1xuICAgICAgc3RyYXRlZ2llcy5wdXNoKHRpY2tGaWx0ZXJTdHJhdGVneSk7XG4gICAgfVxuICAgIGlmICghYXZvaWRMYWJlbENvbGxpc2lvbnMpIHtcbiAgICAgIHJldHVybiBzdHJhdGVnaWVzO1xuICAgIH1cbiAgICBpZiAoYXV0b1JvdGF0ZSkge1xuICAgICAgY29uc3QgYXV0b1JvdGF0ZVN0cmF0ZWd5ID0gKHsgaW5kZXgsIHRpY2tEYXRhLCBsYWJlbE92ZXJsYXAsIHRlcm1pbmF0ZSB9KSA9PiAoe1xuICAgICAgICBpbmRleCxcbiAgICAgICAgdGlja0RhdGEsXG4gICAgICAgIGF1dG9Sb3RhdGlvbjogdGhpcy5nZXRBdXRvUm90YXRpb24obGFiZWxPdmVybGFwKSxcbiAgICAgICAgdGVybWluYXRlXG4gICAgICB9KTtcbiAgICAgIHN0cmF0ZWdpZXMucHVzaChhdXRvUm90YXRlU3RyYXRlZ3kpO1xuICAgIH1cbiAgICByZXR1cm4gc3RyYXRlZ2llcztcbiAgfVxuICBjcmVhdGVUaWNrRGF0YSh0aWNrR2VuZXJhdGlvblR5cGUsIGluZGV4LCB0aWNrRGF0YSwgdGVybWluYXRlLCBwcmltYXJ5VGlja0NvdW50KSB7XG4gICAgY29uc3QgeyBzY2FsZTogc2NhbGUyIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgc3RlcCwgdmFsdWVzLCBtaW5TcGFjaW5nLCBtYXhTcGFjaW5nIH0gPSB0aGlzLmludGVydmFsO1xuICAgIGNvbnN0IHsgbWF4VGlja0NvdW50LCBtaW5UaWNrQ291bnQsIGRlZmF1bHRUaWNrQ291bnQgfSA9IHRoaXMuZXN0aW1hdGVUaWNrQ291bnQoeyBtaW5TcGFjaW5nLCBtYXhTcGFjaW5nIH0pO1xuICAgIGNvbnN0IGNvbnRpbnVvdXMgPSBDb250aW51b3VzU2NhbGUuaXMoc2NhbGUyKSB8fCBPcmRpbmFsVGltZVNjYWxlLmlzKHNjYWxlMik7XG4gICAgY29uc3QgbWF4SXRlcmF0aW9ucyA9ICFjb250aW51b3VzIHx8IGlzTmFOKG1heFRpY2tDb3VudCkgPyAxMCA6IG1heFRpY2tDb3VudDtcbiAgICBsZXQgdGlja0NvdW50ID0gY29udGludW91cyA/IE1hdGgubWF4KGRlZmF1bHRUaWNrQ291bnQgLSBpbmRleCwgbWluVGlja0NvdW50KSA6IG1heFRpY2tDb3VudDtcbiAgICBjb25zdCByZWdlbmVyYXRlVGlja3MgPSBzdGVwID09PSB2b2lkIDAgJiYgdmFsdWVzID09PSB2b2lkIDAgJiYgdGlja0NvdW50ID4gbWluVGlja0NvdW50ICYmIChjb250aW51b3VzIHx8IHRpY2tHZW5lcmF0aW9uVHlwZSA9PT0gMiAvKiBGSUxURVIgKi8pO1xuICAgIGxldCB1bmNoYW5nZWQgPSB0cnVlO1xuICAgIHdoaWxlICh1bmNoYW5nZWQgJiYgaW5kZXggPD0gbWF4SXRlcmF0aW9ucykge1xuICAgICAgY29uc3QgcHJldlRpY2tzID0gdGlja0RhdGEucmF3VGlja3M7XG4gICAgICB0aWNrQ291bnQgPSBjb250aW51b3VzID8gTWF0aC5tYXgoZGVmYXVsdFRpY2tDb3VudCAtIGluZGV4LCBtaW5UaWNrQ291bnQpIDogbWF4VGlja0NvdW50O1xuICAgICAgY29uc3QgeyByYXdUaWNrcywgZnJhY3Rpb25EaWdpdHMsIHRpY2tzLCBsYWJlbENvdW50IH0gPSB0aGlzLmdldFRpY2tzKHtcbiAgICAgICAgdGlja0dlbmVyYXRpb25UeXBlLFxuICAgICAgICBwcmV2aW91c1RpY2tzOiBwcmV2VGlja3MsXG4gICAgICAgIHRpY2tDb3VudCxcbiAgICAgICAgbWluVGlja0NvdW50LFxuICAgICAgICBtYXhUaWNrQ291bnQsXG4gICAgICAgIHByaW1hcnlUaWNrQ291bnRcbiAgICAgIH0pO1xuICAgICAgdGlja0RhdGEucmF3VGlja3MgPSByYXdUaWNrcztcbiAgICAgIHRpY2tEYXRhLmZyYWN0aW9uRGlnaXRzID0gZnJhY3Rpb25EaWdpdHM7XG4gICAgICB0aWNrRGF0YS50aWNrcyA9IHRpY2tzO1xuICAgICAgdGlja0RhdGEubGFiZWxDb3VudCA9IGxhYmVsQ291bnQ7XG4gICAgICB1bmNoYW5nZWQgPSByZWdlbmVyYXRlVGlja3MgPyBhcmVBcnJheU51bWJlcnNFcXVhbChyYXdUaWNrcywgcHJldlRpY2tzKSA6IGZhbHNlO1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gICAgY29uc3Qgc2hvdWxkVGVybWluYXRlID0gc3RlcCAhPT0gdm9pZCAwIHx8IHZhbHVlcyAhPT0gdm9pZCAwO1xuICAgIHRlcm1pbmF0ZSB8fCAodGVybWluYXRlID0gc2hvdWxkVGVybWluYXRlKTtcbiAgICByZXR1cm4geyB0aWNrRGF0YSwgaW5kZXgsIGF1dG9Sb3RhdGlvbjogMCwgdGVybWluYXRlIH07XG4gIH1cbiAgY2hlY2tMYWJlbE92ZXJsYXAocm90YXRpb24sIHJvdGF0ZWQsIGxhYmVsTWF0cml4LCB0aWNrRGF0YSwgbGFiZWxYLCB0ZXh0TWVhc3VyZXIpIHtcbiAgICBNYXRyaXgudXBkYXRlVHJhbnNmb3JtTWF0cml4KGxhYmVsTWF0cml4LCAxLCAxLCByb3RhdGlvbiwgMCwgMCk7XG4gICAgY29uc3QgbGFiZWxEYXRhID0gdGhpcy5jcmVhdGVMYWJlbERhdGEodGlja0RhdGEsIGxhYmVsWCwgbGFiZWxNYXRyaXgsIHRleHRNZWFzdXJlcik7XG4gICAgY29uc3QgbGFiZWxTcGFjaW5nID0gZ2V0TGFiZWxTcGFjaW5nKHRoaXMubGFiZWwubWluU3BhY2luZywgcm90YXRlZCk7XG4gICAgcmV0dXJuIGF4aXNMYWJlbHNPdmVybGFwKGxhYmVsRGF0YSwgbGFiZWxTcGFjaW5nKTtcbiAgfVxuICBjcmVhdGVMYWJlbERhdGEodGlja0RhdGEsIGxhYmVsWCwgbGFiZWxNYXRyaXgsIHRleHRNZWFzdXJlcikge1xuICAgIGNvbnN0IGxhYmVsRGF0YSA9IFtdO1xuICAgIGZvciAoY29uc3QgeyB0aWNrTGFiZWwsIHRyYW5zbGF0aW9uWSB9IG9mIHRpY2tEYXRhKSB7XG4gICAgICBpZiAoIXRpY2tMYWJlbClcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRleHRNZWFzdXJlci5tZWFzdXJlTGluZXModGlja0xhYmVsKTtcbiAgICAgIGNvbnN0IGJib3ggPSBuZXcgQkJveChsYWJlbFgsIHRyYW5zbGF0aW9uWSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjb25zdCBsYWJlbERhdHVtID0gY2FsY3VsYXRlTGFiZWxCQm94KHRpY2tMYWJlbCwgYmJveCwgbGFiZWxNYXRyaXgpO1xuICAgICAgbGFiZWxEYXRhLnB1c2gobGFiZWxEYXR1bSk7XG4gICAgfVxuICAgIHJldHVybiBsYWJlbERhdGE7XG4gIH1cbiAgZ2V0QXV0b1JvdGF0aW9uKGxhYmVsT3ZlcmxhcCkge1xuICAgIHJldHVybiBsYWJlbE92ZXJsYXAgPyBub3JtYWxpemVBbmdsZTM2MCh0b1JhZGlhbnModGhpcy5sYWJlbC5hdXRvUm90YXRlQW5nbGUgPz8gMCkpIDogMDtcbiAgfVxuICBnZXRUaWNrcyh7XG4gICAgdGlja0dlbmVyYXRpb25UeXBlLFxuICAgIHByZXZpb3VzVGlja3MsXG4gICAgdGlja0NvdW50LFxuICAgIG1pblRpY2tDb3VudCxcbiAgICBtYXhUaWNrQ291bnQsXG4gICAgcHJpbWFyeVRpY2tDb3VudFxuICB9KSB7XG4gICAgY29uc3QgeyByYW5nZTogcmFuZ2UzLCBzY2FsZTogc2NhbGUyLCB2aXNpYmxlUmFuZ2UgfSA9IHRoaXM7XG4gICAgbGV0IHJhd1RpY2tzO1xuICAgIHN3aXRjaCAodGlja0dlbmVyYXRpb25UeXBlKSB7XG4gICAgICBjYXNlIDMgLyogVkFMVUVTICovOlxuICAgICAgICByYXdUaWNrcyA9IHRoaXMuaW50ZXJ2YWwudmFsdWVzO1xuICAgICAgICBpZiAoQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikpIHtcbiAgICAgICAgICBjb25zdCBbZDAsIGQxXSA9IGZpbmRNaW5NYXgoc2NhbGUyLmdldERvbWFpbigpLm1hcChOdW1iZXIpKTtcbiAgICAgICAgICByYXdUaWNrcyA9IHJhd1RpY2tzLmZpbHRlcigodmFsdWUpID0+IHZhbHVlID49IGQwICYmIHZhbHVlIDw9IGQxKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEgLyogQ1JFQVRFX1NFQ09OREFSWSAqLzpcbiAgICAgICAgaWYgKENvbnRpbnVvdXNTY2FsZS5pcyhzY2FsZTIpKSB7XG4gICAgICAgICAgcmF3VGlja3MgPSB0aGlzLnVwZGF0ZVNlY29uZGFyeUF4aXNUaWNrcyhwcmltYXJ5VGlja0NvdW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByYXdUaWNrcyA9IHRoaXMuY3JlYXRlVGlja3ModGlja0NvdW50LCBtaW5UaWNrQ291bnQsIG1heFRpY2tDb3VudCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDIgLyogRklMVEVSICovOlxuICAgICAgICByYXdUaWNrcyA9IHRoaXMuZmlsdGVyVGlja3MocHJldmlvdXNUaWNrcywgdGlja0NvdW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByYXdUaWNrcyA9IHRoaXMuY3JlYXRlVGlja3ModGlja0NvdW50LCBtaW5UaWNrQ291bnQsIG1heFRpY2tDb3VudCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBmcmFjdGlvbkRpZ2l0cyA9IHJhd1RpY2tzLnJlZHVjZSgobWF4LCB0aWNrKSA9PiBNYXRoLm1heChtYXgsIGNvdW50RnJhY3Rpb25EaWdpdHModGljaykpLCAwKTtcbiAgICBjb25zdCBoYWxmQmFuZHdpZHRoID0gKHNjYWxlMi5iYW5kd2lkdGggPz8gMCkgLyAyO1xuICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgbGV0IGxhYmVsQ291bnQgPSAwO1xuICAgIGNvbnN0IHRpY2tJZENvdW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHZpc2libGVSYW5nZVswXSAqIHJhd1RpY2tzLmxlbmd0aCkpO1xuICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKHJhd1RpY2tzLmxlbmd0aCwgTWF0aC5jZWlsKHZpc2libGVSYW5nZVsxXSAqIHJhd1RpY2tzLmxlbmd0aCkpO1xuICAgIGNvbnN0IGZpbHRlcmVkVGlja3MgPSByYXdUaWNrcy5zbGljZShzdGFydCwgZW5kKTtcbiAgICB0aGlzLm9uRm9ybWF0Q2hhbmdlKGZpbHRlcmVkVGlja3MsIGZyYWN0aW9uRGlnaXRzLCByYXdUaWNrcywgdGhpcy5sYWJlbC5mb3JtYXQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmlsdGVyZWRUaWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgdGljayA9IGZpbHRlcmVkVGlja3NbaV07XG4gICAgICBjb25zdCB0cmFuc2xhdGlvblkgPSBzY2FsZTIuY29udmVydCh0aWNrKSArIGhhbGZCYW5kd2lkdGg7XG4gICAgICBpZiAocmFuZ2UzLmxlbmd0aCA+IDAgJiYgIXRoaXMuaW5SYW5nZSh0cmFuc2xhdGlvblksIDFlLTMpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHRpY2tMYWJlbCA9IHRoaXMuZm9ybWF0VGljayh0aWNrLCBmcmFjdGlvbkRpZ2l0cywgc3RhcnQgKyBpKTtcbiAgICAgIGxldCB0aWNrSWQgPSB0aWNrTGFiZWw7XG4gICAgICBpZiAodGlja0lkQ291bnRzLmhhcyh0aWNrSWQpKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGlja0lkQ291bnRzLmdldCh0aWNrSWQpO1xuICAgICAgICB0aWNrSWRDb3VudHMuc2V0KHRpY2tJZCwgY291bnQgKyAxKTtcbiAgICAgICAgdGlja0lkID0gYCR7dGlja0lkfV8ke2NvdW50fWA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWNrSWRDb3VudHMuc2V0KHRpY2tJZCwgMSk7XG4gICAgICB9XG4gICAgICB0aWNrcy5wdXNoKHsgdGljaywgdGlja0lkLCB0aWNrTGFiZWwsIHRyYW5zbGF0aW9uWTogTWF0aC5mbG9vcih0cmFuc2xhdGlvblkpIH0pO1xuICAgICAgaWYgKHRpY2tMYWJlbCA9PT0gXCJcIiB8fCB0aWNrTGFiZWwgPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxhYmVsQ291bnQrKztcbiAgICB9XG4gICAgcmV0dXJuIHsgcmF3VGlja3MsIGZyYWN0aW9uRGlnaXRzLCB0aWNrcywgbGFiZWxDb3VudCB9O1xuICB9XG4gIGZpbHRlclRpY2tzKHRpY2tzLCB0aWNrQ291bnQpIHtcbiAgICBjb25zdCB7IG1pblNwYWNpbmcsIG1heFNwYWNpbmcgfSA9IHRoaXMuaW50ZXJ2YWw7XG4gICAgY29uc3QgdGlja1NwYWNpbmcgPSAhaXNOYU4obWluU3BhY2luZykgfHwgIWlzTmFOKG1heFNwYWNpbmcpO1xuICAgIGNvbnN0IGtlZXBFdmVyeSA9IHRpY2tTcGFjaW5nID8gTWF0aC5jZWlsKHRpY2tzLmxlbmd0aCAvIHRpY2tDb3VudCkgOiAyO1xuICAgIHJldHVybiB0aWNrcy5maWx0ZXIoKF8sIGkpID0+IGkgJSBrZWVwRXZlcnkgPT09IDApO1xuICB9XG4gIGNyZWF0ZVRpY2tzKHRpY2tDb3VudCwgbWluVGlja0NvdW50LCBtYXhUaWNrQ291bnQpIHtcbiAgICBjb25zdCB7IHNjYWxlOiBzY2FsZTIgfSA9IHRoaXM7XG4gICAgaWYgKHRpY2tDb3VudCAmJiAoQ29udGludW91c1NjYWxlLmlzKHNjYWxlMikgfHwgT3JkaW5hbFRpbWVTY2FsZS5pcyhzY2FsZTIpKSkge1xuICAgICAgaWYgKHR5cGVvZiB0aWNrQ291bnQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgc2NhbGUyLnRpY2tDb3VudCA9IHRpY2tDb3VudDtcbiAgICAgICAgc2NhbGUyLm1pblRpY2tDb3VudCA9IG1pblRpY2tDb3VudCA/PyAwO1xuICAgICAgICBzY2FsZTIubWF4VGlja0NvdW50ID0gbWF4VGlja0NvdW50ID8/IEluZmluaXR5O1xuICAgICAgfSBlbHNlIGlmIChzY2FsZTIgaW5zdGFuY2VvZiBUaW1lU2NhbGUpIHtcbiAgICAgICAgdGhpcy5zZXRUaWNrSW50ZXJ2YWwodGlja0NvdW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNjYWxlMi50aWNrcz8uKCkgPz8gW107XG4gIH1cbiAgZXN0aW1hdGVUaWNrQ291bnQoeyBtaW5TcGFjaW5nLCBtYXhTcGFjaW5nIH0pIHtcbiAgICBpZiAoIXRoaXMubGFiZWwuYXZvaWRDb2xsaXNpb25zKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW5UaWNrQ291bnQ6IENvbnRpbnVvdXNTY2FsZS5kZWZhdWx0TWF4VGlja0NvdW50LFxuICAgICAgICBtYXhUaWNrQ291bnQ6IENvbnRpbnVvdXNTY2FsZS5kZWZhdWx0TWF4VGlja0NvdW50LFxuICAgICAgICBkZWZhdWx0VGlja0NvdW50OiBDb250aW51b3VzU2NhbGUuZGVmYXVsdE1heFRpY2tDb3VudFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2VXaXRoQmxlZWQgPSB0aGlzLmNhbGN1bGF0ZVJhbmdlV2l0aEJsZWVkKCk7XG4gICAgY29uc3QgZGVmYXVsdE1pblNwYWNpbmcgPSBNYXRoLm1heChcbiAgICAgIHRoaXMuZGVmYXVsdFRpY2tNaW5TcGFjaW5nLFxuICAgICAgcmFuZ2VXaXRoQmxlZWQgLyBDb250aW51b3VzU2NhbGUuZGVmYXVsdE1heFRpY2tDb3VudFxuICAgICk7XG4gICAgbGV0IGNsYW1wTWF4VGlja0NvdW50ID0gIWlzTmFOKG1heFNwYWNpbmcpO1xuICAgIGlmIChpc05hTihtaW5TcGFjaW5nKSkge1xuICAgICAgbWluU3BhY2luZyA9IGRlZmF1bHRNaW5TcGFjaW5nO1xuICAgIH1cbiAgICBpZiAoaXNOYU4obWF4U3BhY2luZykpIHtcbiAgICAgIG1heFNwYWNpbmcgPSByYW5nZVdpdGhCbGVlZDtcbiAgICB9XG4gICAgaWYgKG1pblNwYWNpbmcgPiBtYXhTcGFjaW5nKSB7XG4gICAgICBpZiAobWluU3BhY2luZyA9PT0gZGVmYXVsdE1pblNwYWNpbmcpIHtcbiAgICAgICAgbWluU3BhY2luZyA9IG1heFNwYWNpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXhTcGFjaW5nID0gbWluU3BhY2luZztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWluUmVjdERpc3RhbmNlID0gMjtcbiAgICBjbGFtcE1heFRpY2tDb3VudCAmJiAoY2xhbXBNYXhUaWNrQ291bnQgPSBtaW5SZWN0RGlzdGFuY2UgPCBkZWZhdWx0TWluU3BhY2luZyk7XG4gICAgY29uc3QgbWF4VGlja0NvdW50ID0gY2xhbXAoXG4gICAgICAxLFxuICAgICAgTWF0aC5mbG9vcihyYW5nZVdpdGhCbGVlZCAvIG1pblNwYWNpbmcpLFxuICAgICAgY2xhbXBNYXhUaWNrQ291bnQgPyBNYXRoLm1pbihNYXRoLmZsb29yKHJhbmdlV2l0aEJsZWVkIC8gbWluUmVjdERpc3RhbmNlKSwgMTAwKSA6IDEwMFxuICAgICk7XG4gICAgY29uc3QgbWluVGlja0NvdW50ID0gTWF0aC5taW4obWF4VGlja0NvdW50LCBNYXRoLmNlaWwocmFuZ2VXaXRoQmxlZWQgLyBtYXhTcGFjaW5nKSk7XG4gICAgY29uc3QgZGVmYXVsdFRpY2tDb3VudCA9IGNsYW1wKG1pblRpY2tDb3VudCwgQ29udGludW91c1NjYWxlLmRlZmF1bHRUaWNrQ291bnQsIG1heFRpY2tDb3VudCk7XG4gICAgcmV0dXJuIHsgbWluVGlja0NvdW50LCBtYXhUaWNrQ291bnQsIGRlZmF1bHRUaWNrQ291bnQgfTtcbiAgfVxuICB1cGRhdGVWaXNpYmlsaXR5KCkge1xuICAgIGlmICh0aGlzLm1vZHVsZUN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpKSB7XG4gICAgICB0aGlzLnJlc2V0U2VsZWN0aW9uTm9kZXMoKTtcbiAgICB9XG4gICAgdGhpcy50aWNrTGluZUdyb3VwLnZpc2libGUgPSB0aGlzLnRpY2suZW5hYmxlZDtcbiAgICB0aGlzLmdyaWRMaW5lR3JvdXAudmlzaWJsZSA9IHRoaXMuZ3JpZExpbmUuZW5hYmxlZDtcbiAgICB0aGlzLnRpY2tMYWJlbEdyb3VwLnZpc2libGUgPSB0aGlzLmxhYmVsLmVuYWJsZWQ7XG4gIH1cbiAgdXBkYXRlQ3Jvc3NMaW5lcyh7XG4gICAgcm90YXRpb24sXG4gICAgcGFyYWxsZWxGbGlwUm90YXRpb24sXG4gICAgcmVndWxhckZsaXBSb3RhdGlvblxuICB9KSB7XG4gICAgY29uc3Qgc2lkZUZsYWcgPSB0aGlzLmxhYmVsLmdldFNpZGVGbGFnKCk7XG4gICAgY29uc3QgYW55U2VyaWVzQWN0aXZlID0gdGhpcy5pc0FueVNlcmllc0FjdGl2ZSgpO1xuICAgIHRoaXMuY3Jvc3NMaW5lcy5mb3JFYWNoKChjcm9zc0xpbmUpID0+IHtcbiAgICAgIGNyb3NzTGluZS5zaWRlRmxhZyA9IC1zaWRlRmxhZztcbiAgICAgIGNyb3NzTGluZS5kaXJlY3Rpb24gPSByb3RhdGlvbiA9PT0gLU1hdGguUEkgLyAyID8gXCJ4XCIgLyogWCAqLyA6IFwieVwiIC8qIFkgKi87XG4gICAgICBpZiAoY3Jvc3NMaW5lIGluc3RhbmNlb2YgQ2FydGVzaWFuQ3Jvc3NMaW5lKSB7XG4gICAgICAgIGNyb3NzTGluZS5sYWJlbC5wYXJhbGxlbCA9IGNyb3NzTGluZS5sYWJlbC5wYXJhbGxlbCA/PyB0aGlzLmxhYmVsLnBhcmFsbGVsO1xuICAgICAgfVxuICAgICAgY3Jvc3NMaW5lLnBhcmFsbGVsRmxpcFJvdGF0aW9uID0gcGFyYWxsZWxGbGlwUm90YXRpb247XG4gICAgICBjcm9zc0xpbmUucmVndWxhckZsaXBSb3RhdGlvbiA9IHJlZ3VsYXJGbGlwUm90YXRpb247XG4gICAgICBjcm9zc0xpbmUudXBkYXRlKGFueVNlcmllc0FjdGl2ZSk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlVGlja0xpbmVzKCkge1xuICAgIGNvbnN0IHsgdGljaywgbGFiZWwgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2lkZUZsYWcgPSBsYWJlbC5nZXRTaWRlRmxhZygpO1xuICAgIHRoaXMudGlja0xpbmVHcm91cFNlbGVjdGlvbi5lYWNoKChsaW5lKSA9PiB7XG4gICAgICBsaW5lLnN0cm9rZVdpZHRoID0gdGljay53aWR0aDtcbiAgICAgIGxpbmUuc3Ryb2tlID0gdGljay5zdHJva2U7XG4gICAgICBsaW5lLngxID0gc2lkZUZsYWcgKiB0aGlzLmdldFRpY2tTaXplKCk7XG4gICAgICBsaW5lLngyID0gMDtcbiAgICB9KTtcbiAgfVxuICBjYWxjdWxhdGVBdmFpbGFibGVSYW5nZSgpIHtcbiAgICByZXR1cm4gZmluZFJhbmdlRXh0ZW50KHRoaXMucmFuZ2UpO1xuICB9XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBhdmFpbGFibGUgcmFuZ2Ugd2l0aCBhbiBhZGRpdGlvbmFsIFwiYmxlZWRcIiBiZXlvbmQgdGhlIGNhbnZhcyB0aGF0IGVuY29tcGFzc2VzIHRoZSBmdWxsIGF4aXMgd2hlblxuICAgKiB0aGUgdmlzaWJsZSByYW5nZSBpcyBvbmx5IGEgcG9ydGlvbiBvZiB0aGUgYXhpcy5cbiAgICovXG4gIGNhbGN1bGF0ZVJhbmdlV2l0aEJsZWVkKCkge1xuICAgIGNvbnN0IHZpc2libGVTY2FsZSA9IDEgLyBmaW5kUmFuZ2VFeHRlbnQodGhpcy52aXNpYmxlUmFuZ2UpO1xuICAgIHJldHVybiByb3VuZCh0aGlzLmNhbGN1bGF0ZUF2YWlsYWJsZVJhbmdlKCkgKiB2aXNpYmxlU2NhbGUsIDIpO1xuICB9XG4gIGNhbGN1bGF0ZURvbWFpbigpIHtcbiAgICBjb25zdCB2aXNpYmxlU2VyaWVzID0gdGhpcy5ib3VuZFNlcmllcy5maWx0ZXIoKHMpID0+IHRoaXMuaW5jbHVkZUludmlzaWJsZURvbWFpbnMgfHwgcy5pc0VuYWJsZWQoKSk7XG4gICAgY29uc3QgZG9tYWlucyA9IHZpc2libGVTZXJpZXMuZmxhdE1hcCgoc2VyaWVzKSA9PiBzZXJpZXMuZ2V0RG9tYWluKHRoaXMuZGlyZWN0aW9uKSk7XG4gICAgdGhpcy5zZXREb21haW4oZG9tYWlucyk7XG4gIH1cbiAgZ2V0QXhpc1RyYW5zZm9ybSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm90YXRpb246IHRvUmFkaWFucyh0aGlzLnJvdGF0aW9uKSxcbiAgICAgIHJvdGF0aW9uQ2VudGVyWDogMCxcbiAgICAgIHJvdGF0aW9uQ2VudGVyWTogMCxcbiAgICAgIHRyYW5zbGF0aW9uWDogTWF0aC5mbG9vcih0aGlzLnRyYW5zbGF0aW9uLngpLFxuICAgICAgdHJhbnNsYXRpb25ZOiBNYXRoLmZsb29yKHRoaXMudHJhbnNsYXRpb24ueSlcbiAgICB9O1xuICB9XG4gIHVwZGF0ZVBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHsgY3Jvc3NMaW5lR3JvdXAsIGF4aXNHcm91cCwgZ3JpZEdyb3VwLCB0cmFuc2xhdGlvbiwgZ3JpZExpbmVHcm91cFNlbGVjdGlvbiwgZ3JpZFBhZGRpbmcsIGdyaWRMZW5ndGggfSA9IHRoaXM7XG4gICAgY29uc3QgeyByb3RhdGlvbiB9ID0gdGhpcy5jYWxjdWxhdGVSb3RhdGlvbnMoKTtcbiAgICBjb25zdCBzaWRlRmxhZyA9IHRoaXMubGFiZWwuZ2V0U2lkZUZsYWcoKTtcbiAgICBjb25zdCB0cmFuc2xhdGlvblggPSBNYXRoLmZsb29yKHRyYW5zbGF0aW9uLngpO1xuICAgIGNvbnN0IHRyYW5zbGF0aW9uWSA9IE1hdGguZmxvb3IodHJhbnNsYXRpb24ueSk7XG4gICAgY3Jvc3NMaW5lR3JvdXAuc2V0UHJvcGVydGllcyh7IHJvdGF0aW9uLCB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSB9KTtcbiAgICBncmlkR3JvdXAuc2V0UHJvcGVydGllcyh7IHJvdGF0aW9uLCB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSB9KTtcbiAgICBheGlzR3JvdXAuZGF0dW0gPSB0aGlzLmdldEF4aXNUcmFuc2Zvcm0oKTtcbiAgICBncmlkTGluZUdyb3VwU2VsZWN0aW9uLmVhY2goKGxpbmUpID0+IHtcbiAgICAgIGxpbmUueDEgPSBncmlkUGFkZGluZztcbiAgICAgIGxpbmUueDIgPSAtc2lkZUZsYWcgKiBncmlkTGVuZ3RoICsgZ3JpZFBhZGRpbmc7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlU2Vjb25kYXJ5QXhpc1RpY2tzKF9wcmltYXJ5VGlja0NvdW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gdW5leHBlY3RlZCBjYWxsIHRvIHVwZGF0ZVNlY29uZGFyeUF4aXNUaWNrcygpIC0gY2hlY2sgYXhlcyBjb25maWd1cmF0aW9uLlwiKTtcbiAgfVxuICB1cGRhdGVTZWxlY3Rpb25zKGxpbmVEYXRhLCBkYXRhLCBwYXJhbXMpIHtcbiAgICB0aGlzLmxpbmVOb2RlLmRhdHVtID0gbGluZURhdGE7XG4gICAgdGhpcy5ncmlkTGluZUdyb3VwU2VsZWN0aW9uLnVwZGF0ZShcbiAgICAgIHRoaXMuZ3JpZExlbmd0aCA/IGRhdGEgOiBbXSxcbiAgICAgIChncm91cCkgPT4gZ3JvdXAuYXBwZW5kKG5ldyBMaW5lKCkpLFxuICAgICAgKGRhdHVtKSA9PiBkYXR1bS50aWNrSWRcbiAgICApO1xuICAgIHRoaXMudGlja0xpbmVHcm91cFNlbGVjdGlvbi51cGRhdGUoXG4gICAgICBkYXRhLFxuICAgICAgKGdyb3VwKSA9PiBncm91cC5hcHBlbmRDaGlsZChuZXcgTGluZSgpKSxcbiAgICAgIChkYXR1bSkgPT4gZGF0dW0udGlja0lkXG4gICAgKTtcbiAgICB0aGlzLnRpY2tMYWJlbEdyb3VwU2VsZWN0aW9uLnVwZGF0ZShcbiAgICAgIGRhdGEubWFwKChkKSA9PiB0aGlzLmdldFRpY2tMYWJlbFByb3BzKGQsIHBhcmFtcykpLFxuICAgICAgKGdyb3VwKSA9PiBncm91cC5hcHBlbmRDaGlsZChuZXcgVGV4dCgpKSxcbiAgICAgIChkYXR1bSkgPT4gZGF0dW0udGlja0lkXG4gICAgKTtcbiAgfVxuICB1cGRhdGVBeGlzTGluZSgpIHtcbiAgICBjb25zdCB7IGxpbmUgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBsaW5lLmVuYWJsZWQgPyBsaW5lLndpZHRoIDogMDtcbiAgICB0aGlzLmxpbmVOb2RlLnNldFByb3BlcnRpZXMoe1xuICAgICAgc3Ryb2tlOiBsaW5lLnN0cm9rZSxcbiAgICAgIHN0cm9rZVdpZHRoXG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlR3JpZExpbmVzKHNpZGVGbGFnKSB7XG4gICAgY29uc3Qge1xuICAgICAgZ3JpZExpbmU6IHsgc3R5bGUsIHdpZHRoIH0sXG4gICAgICBncmlkUGFkZGluZyxcbiAgICAgIGdyaWRMZW5ndGhcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoZ3JpZExlbmd0aCA9PT0gMCB8fCBzdHlsZS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5ncmlkTGluZUdyb3VwU2VsZWN0aW9uLmVhY2goKGxpbmUsIF8sIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7IHN0cm9rZSwgbGluZURhc2ggfSA9IHN0eWxlW2luZGV4ICUgc3R5bGUubGVuZ3RoXTtcbiAgICAgIGxpbmUuc2V0UHJvcGVydGllcyh7XG4gICAgICAgIHgxOiBncmlkUGFkZGluZyxcbiAgICAgICAgeDI6IC1zaWRlRmxhZyAqIGdyaWRMZW5ndGggKyBncmlkUGFkZGluZyxcbiAgICAgICAgZmlsbDogdm9pZCAwLFxuICAgICAgICBzdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoOiB3aWR0aCxcbiAgICAgICAgbGluZURhc2hcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUxhYmVscygpIHtcbiAgICBjb25zdCB7IGxhYmVsIH0gPSB0aGlzO1xuICAgIGlmICghbGFiZWwuZW5hYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRpY2tMYWJlbEdyb3VwU2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtKSA9PiB7XG4gICAgICBub2RlLnNldFByb3BlcnRpZXMoZGF0dW0sIFtcbiAgICAgICAgXCJmaWxsXCIsXG4gICAgICAgIFwiZm9udEZhbWlseVwiLFxuICAgICAgICBcImZvbnRTaXplXCIsXG4gICAgICAgIFwiZm9udFN0eWxlXCIsXG4gICAgICAgIFwiZm9udFdlaWdodFwiLFxuICAgICAgICBcInRleHRcIixcbiAgICAgICAgXCJ0ZXh0QWxpZ25cIixcbiAgICAgICAgXCJ0ZXh0QmFzZWxpbmVcIlxuICAgICAgXSk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlVGl0bGUocGFyYW1zKSB7XG4gICAgY29uc3QgeyByb3RhdGlvbiwgdGl0bGUsIF90aXRsZUNhcHRpb24sIGxpbmVOb2RlLCB0aWNrTGluZUdyb3VwLCB0aWNrTGFiZWxHcm91cCB9ID0gdGhpcztcbiAgICBsZXQgc3BhY2luZyA9IDA7XG4gICAgaWYgKHRpdGxlLmVuYWJsZWQgJiYgcGFyYW1zLmFueVRpY2tWaXNpYmxlKSB7XG4gICAgICBjb25zdCB0aWNrQkJveCA9IEdyb3VwLmNvbXB1dGVCQm94KFt0aWNrTGluZUdyb3VwLCB0aWNrTGFiZWxHcm91cCwgbGluZU5vZGVdKTtcbiAgICAgIGNvbnN0IHRpY2tXaWR0aCA9IHJvdGF0aW9uID09PSAwID8gdGlja0JCb3gud2lkdGggOiB0aWNrQkJveC5oZWlnaHQ7XG4gICAgICBzcGFjaW5nICs9IHRpY2tXaWR0aCArICh0aGlzLnRpY2tMYWJlbEdyb3VwLnZpc2libGUgPyAwIDogdGhpcy5zZXJpZXNBcmVhUGFkZGluZyk7XG4gICAgfVxuICAgIHRoaXMuc2V0VGl0bGVQcm9wcyhfdGl0bGVDYXB0aW9uLCB7IHNwYWNpbmcgfSk7XG4gIH1cbiAgLy8gRm9yIGZvcm1hdHRpbmcgKG5pY2Ugcm91bmRlZCkgdGljayB2YWx1ZXMuXG4gIGZvcm1hdFRpY2soZGF0dW0sIGZyYWN0aW9uRGlnaXRzLCBpbmRleCkge1xuICAgIHJldHVybiBTdHJpbmcodGhpcy5nZXRGb3JtYXR0ZXIoaW5kZXgsIHRydWUpKGRhdHVtLCBmcmFjdGlvbkRpZ2l0cykpO1xuICB9XG4gIC8vIEZvciBmb3JtYXR0aW5nIGFyYml0cmFyeSB2YWx1ZXMgYmV0d2VlbiB0aGUgdGlja3MuXG4gIGZvcm1hdERhdHVtKGRhdHVtKSB7XG4gICAgcmV0dXJuIFN0cmluZyh0aGlzLmdldEZvcm1hdHRlcigpKGRhdHVtKSk7XG4gIH1cbiAgZ2V0Rm9ybWF0dGVyKGluZGV4ID0gMCwgaXNUaWNrTGFiZWwpIHtcbiAgICBjb25zdCB7XG4gICAgICBsYWJlbCxcbiAgICAgIGxhYmVsRm9ybWF0dGVyLFxuICAgICAgZGF0dW1Gb3JtYXR0ZXIsXG4gICAgICBtb2R1bGVDdHg6IHsgY2FsbGJhY2tDYWNoZSB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGxhYmVsLmZvcm1hdHRlcikge1xuICAgICAgcmV0dXJuIChkYXR1bSwgZnJhY3Rpb25EaWdpdHMpID0+IGNhbGxiYWNrQ2FjaGUuY2FsbChsYWJlbC5mb3JtYXR0ZXIsIHsgdmFsdWU6IGRhdHVtLCBpbmRleCwgZnJhY3Rpb25EaWdpdHMgfSkgPz8gZGF0dW07XG4gICAgfSBlbHNlIGlmICghaXNUaWNrTGFiZWwgJiYgZGF0dW1Gb3JtYXR0ZXIpIHtcbiAgICAgIHJldHVybiAoZGF0dW0pID0+IGNhbGxiYWNrQ2FjaGUuY2FsbChkYXR1bUZvcm1hdHRlciwgZGF0dW0pID8/IFN0cmluZyhkYXR1bSk7XG4gICAgfSBlbHNlIGlmIChsYWJlbEZvcm1hdHRlcikge1xuICAgICAgcmV0dXJuIChkYXR1bSkgPT4gY2FsbGJhY2tDYWNoZS5jYWxsKGxhYmVsRm9ybWF0dGVyLCBkYXR1bSkgPz8gU3RyaW5nKGRhdHVtKTtcbiAgICB9XG4gICAgcmV0dXJuIChkYXR1bSkgPT4gU3RyaW5nKGRhdHVtKTtcbiAgfVxuICBnZXRCQm94KCkge1xuICAgIHJldHVybiB0aGlzLmF4aXNHcm91cC5nZXRCQm94KCk7XG4gIH1cbiAgZ2V0UmVnaW9uQkJveFByb3ZpZGVyKCkge1xuICAgIGNvbnN0IHsgYXhpc0dyb3VwIH0gPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIGNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKSB7XG4gICAgICAgIHJldHVybiBheGlzR3JvdXAuY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpO1xuICAgICAgfSxcbiAgICAgIGNvbXB1dGVUcmFuc2Zvcm1lZFJlZ2lvbkJCb3goKSB7XG4gICAgICAgIHJldHVybiBheGlzR3JvdXAuY29tcHV0ZVRyYW5zZm9ybWVkUmVnaW9uQkJveCgpO1xuICAgICAgfSxcbiAgICAgIGdldCB2aXNpYmxlKCkge1xuICAgICAgICByZXR1cm4gYXhpc0dyb3VwLnZpc2libGU7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBpbml0Q3Jvc3NMaW5lKGNyb3NzTGluZSkge1xuICAgIGNyb3NzTGluZS5zY2FsZSA9IHRoaXMuc2NhbGU7XG4gICAgY3Jvc3NMaW5lLmdyaWRMZW5ndGggPSB0aGlzLmdyaWRMZW5ndGg7XG4gIH1cbiAgaXNBbnlTZXJpZXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm91bmRTZXJpZXMuc29tZSgocykgPT4gdGhpcy5pbmNsdWRlSW52aXNpYmxlRG9tYWlucyB8fCBzLmlzRW5hYmxlZCgpKTtcbiAgfVxuICBjbGlwVGlja0xpbmVzKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICB0aGlzLnRpY2tMaW5lR3JvdXAuc2V0Q2xpcFJlY3RJbkdyb3VwQ29vcmRpbmF0ZVNwYWNlKG5ldyBCQm94KHgsIHksIHdpZHRoLCBoZWlnaHQpKTtcbiAgfVxuICBjbGlwR3JpZCh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5ncmlkR3JvdXAuc2V0Q2xpcFJlY3RJbkdyb3VwQ29vcmRpbmF0ZVNwYWNlKG5ldyBCQm94KHgsIHksIHdpZHRoLCBoZWlnaHQpKTtcbiAgfVxuICBjYWxjdWxhdGVQYWRkaW5nKG1pbiwgbWF4KSB7XG4gICAgY29uc3QgcGFkZGluZyA9IE1hdGguYWJzKHRoaXMucmV2ZXJzZSA/IG1heCA6IG1pbikgKiAwLjAxO1xuICAgIHJldHVybiBbcGFkZGluZywgcGFkZGluZ107XG4gIH1cbiAgZ2V0VGl0bGVGb3JtYXR0ZXJQYXJhbXMoKSB7XG4gICAgY29uc3QgYm91bmRTZXJpZXMgPSB0aGlzLmJvdW5kU2VyaWVzLnJlZHVjZSgoYWNjLCBuZXh0KSA9PiB7XG4gICAgICBjb25zdCBrZXlzID0gbmV4dC5nZXRLZXlzKHRoaXMuZGlyZWN0aW9uKTtcbiAgICAgIGNvbnN0IG5hbWVzID0gbmV4dC5nZXROYW1lcyh0aGlzLmRpcmVjdGlvbik7XG4gICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBrZXlzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgYWNjLnB1c2goeyBrZXk6IGtleXNbaWR4XSwgbmFtZTogbmFtZXNbaWR4XSB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiB7XG4gICAgICBkaXJlY3Rpb246IHRoaXMuZGlyZWN0aW9uLFxuICAgICAgYm91bmRTZXJpZXMsXG4gICAgICBkZWZhdWx0VmFsdWU6IHRoaXMudGl0bGU/LnRleHRcbiAgICB9O1xuICB9XG4gIG5vcm1hbGlzZURhdGFEb21haW4oZCkge1xuICAgIHJldHVybiB7IGRvbWFpbjogWy4uLmRdLCBjbGlwcGVkOiBmYWxzZSB9O1xuICB9XG4gIGdldExheW91dFN0YXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5pZCxcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0QkJveCgpLFxuICAgICAgZ3JpZFBhZGRpbmc6IHRoaXMuZ3JpZFBhZGRpbmcsXG4gICAgICBzZXJpZXNBcmVhUGFkZGluZzogdGhpcy5zZXJpZXNBcmVhUGFkZGluZyxcbiAgICAgIHRpY2tTaXplOiB0aGlzLmdldFRpY2tTaXplKCksXG4gICAgICBkaXJlY3Rpb246IHRoaXMuZGlyZWN0aW9uLFxuICAgICAgZG9tYWluOiB0aGlzLmRhdGFEb21haW4uZG9tYWluLFxuICAgICAgc2NhbGU6IHRoaXMuc2NhbGUsXG4gICAgICAuLi50aGlzLmxheW91dFxuICAgIH07XG4gIH1cbiAgZ2V0TW9kdWxlTWFwKCkge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZU1hcDtcbiAgfVxuICBjcmVhdGVNb2R1bGVDb250ZXh0KCkge1xuICAgIHRoaXMuYXhpc0NvbnRleHQgPz8gKHRoaXMuYXhpc0NvbnRleHQgPSB0aGlzLmNyZWF0ZUF4aXNDb250ZXh0KCkpO1xuICAgIHJldHVybiB7IC4uLnRoaXMubW9kdWxlQ3R4LCBwYXJlbnQ6IHRoaXMuYXhpc0NvbnRleHQgfTtcbiAgfVxuICBjcmVhdGVBeGlzQ29udGV4dCgpIHtcbiAgICBjb25zdCB7IHNjYWxlOiBzY2FsZTIgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF4aXNJZDogdGhpcy5pZCxcbiAgICAgIGRpcmVjdGlvbjogdGhpcy5kaXJlY3Rpb24sXG4gICAgICBjb250aW51b3VzOiBDb250aW51b3VzU2NhbGUuaXMoc2NhbGUyKSB8fCBPcmRpbmFsVGltZVNjYWxlLmlzKHNjYWxlMiksXG4gICAgICBrZXlzOiAoKSA9PiB0aGlzLmJvdW5kU2VyaWVzLmZsYXRNYXAoKHMpID0+IHMuZ2V0S2V5cyh0aGlzLmRpcmVjdGlvbikpLFxuICAgICAgc2VyaWVzS2V5UHJvcGVydGllczogKCkgPT4gdGhpcy5ib3VuZFNlcmllcy5yZWR1Y2UoKGtleXMsIHNlcmllcykgPT4ge1xuICAgICAgICBjb25zdCBzZXJpZXNLZXlzID0gc2VyaWVzLmdldEtleVByb3BlcnRpZXModGhpcy5kaXJlY3Rpb24pO1xuICAgICAgICBzZXJpZXNLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgIGlmIChrZXlzLmluZGV4T2Yoa2V5KSA8IDApIHtcbiAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgfSwgW10pLFxuICAgICAgc2NhbGVWYWx1ZUZvcm1hdHRlcjogKHNwZWNpZmllcikgPT4gdGhpcy5nZXRTY2FsZVZhbHVlRm9ybWF0dGVyKHNwZWNpZmllciksXG4gICAgICBzY2FsZUJhbmR3aWR0aDogKCkgPT4gc2NhbGUyLmJhbmR3aWR0aCA/PyAwLFxuICAgICAgc2NhbGVEb21haW46ICgpID0+IHNjYWxlMi5nZXREb21haW4/LigpLFxuICAgICAgc2NhbGVDb252ZXJ0OiAodmFsKSA9PiBzY2FsZTIuY29udmVydCh2YWwpLFxuICAgICAgc2NhbGVJbnZlcnQ6IE9yZGluYWxUaW1lU2NhbGUuaXMoc2NhbGUyKSA/ICh2YWwpID0+IHNjYWxlMi5pbnZlcnROZWFyZXN0Py4odmFsKSA6ICh2YWwpID0+IHNjYWxlMi5pbnZlcnQ/Lih2YWwpLFxuICAgICAgc2NhbGVJbnZlcnROZWFyZXN0OiAodmFsKSA9PiBzY2FsZTIuaW52ZXJ0TmVhcmVzdD8uKHZhbCksXG4gICAgICBhdHRhY2hMYWJlbDogKG5vZGUpID0+IHRoaXMuYXR0YWNoTGFiZWwobm9kZSksXG4gICAgICBpblJhbmdlOiAoeCwgdG9sZXJhbmNlKSA9PiB0aGlzLmluUmFuZ2UoeCwgdG9sZXJhbmNlKVxuICAgIH07XG4gIH1cbiAgZ2V0U2NhbGVWYWx1ZUZvcm1hdHRlcihmb3JtYXQpIHtcbiAgICBjb25zdCB7IHNjYWxlOiBzY2FsZTIgfSA9IHRoaXM7XG4gICAgaWYgKGZvcm1hdCAmJiBzY2FsZTIgJiYgc2NhbGUyLnRpY2tGb3JtYXQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBzY2FsZTIudGlja0Zvcm1hdCh7IHNwZWNpZmllcjogZm9ybWF0IH0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBMb2dnZXIud2Fybk9uY2UoYHRoZSBmb3JtYXQgc3RyaW5nICR7Zm9ybWF0fSBpcyBpbnZhbGlkLCBpZ25vcmluZy5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0Rm9ybWF0dGVyKCk7XG4gIH1cbiAgYW5pbWF0ZVJlYWR5VXBkYXRlKGRpZmYyKSB7XG4gICAgY29uc3QgeyBhbmltYXRpb25NYW5hZ2VyIH0gPSB0aGlzLm1vZHVsZUN0eDtcbiAgICBjb25zdCBzZWxlY3Rpb25DdHggPSBwcmVwYXJlQXhpc0FuaW1hdGlvbkNvbnRleHQodGhpcyk7XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZUF4aXNBbmltYXRpb25GdW5jdGlvbnMoc2VsZWN0aW9uQ3R4KTtcbiAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgXCJheGlzLWdyb3VwXCIsIGFuaW1hdGlvbk1hbmFnZXIsIFt0aGlzLmF4aXNHcm91cF0sIGZucy5ncm91cCk7XG4gICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsIFwibGluZVwiLCBhbmltYXRpb25NYW5hZ2VyLCBbdGhpcy5saW5lTm9kZV0sIGZucy5saW5lKTtcbiAgICBmcm9tVG9Nb3Rpb24oXG4gICAgICB0aGlzLmlkLFxuICAgICAgXCJsaW5lLXBhdGhzXCIsXG4gICAgICBhbmltYXRpb25NYW5hZ2VyLFxuICAgICAgW3RoaXMuZ3JpZExpbmVHcm91cFNlbGVjdGlvbiwgdGhpcy50aWNrTGluZUdyb3VwU2VsZWN0aW9uXSxcbiAgICAgIGZucy50aWNrLFxuICAgICAgKF8sIGQpID0+IGQudGlja0lkLFxuICAgICAgZGlmZjJcbiAgICApO1xuICAgIGZyb21Ub01vdGlvbihcbiAgICAgIHRoaXMuaWQsXG4gICAgICBcInRpY2stbGFiZWxzXCIsXG4gICAgICBhbmltYXRpb25NYW5hZ2VyLFxuICAgICAgW3RoaXMudGlja0xhYmVsR3JvdXBTZWxlY3Rpb25dLFxuICAgICAgZm5zLmxhYmVsLFxuICAgICAgKF8sIGQpID0+IGQudGlja0lkLFxuICAgICAgZGlmZjJcbiAgICApO1xuICB9XG4gIHJlc2V0U2VsZWN0aW9uTm9kZXMoKSB7XG4gICAgY29uc3QgeyBncmlkTGluZUdyb3VwU2VsZWN0aW9uLCB0aWNrTGluZUdyb3VwU2VsZWN0aW9uLCB0aWNrTGFiZWxHcm91cFNlbGVjdGlvbiwgbGluZU5vZGUgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2VsZWN0aW9uQ3R4ID0gcHJlcGFyZUF4aXNBbmltYXRpb25Db250ZXh0KHRoaXMpO1xuICAgIHJlc2V0TW90aW9uKFt0aGlzLmF4aXNHcm91cF0sIHJlc2V0QXhpc0dyb3VwRm4oKSk7XG4gICAgcmVzZXRNb3Rpb24oW2dyaWRMaW5lR3JvdXBTZWxlY3Rpb24sIHRpY2tMaW5lR3JvdXBTZWxlY3Rpb25dLCByZXNldEF4aXNTZWxlY3Rpb25GbihzZWxlY3Rpb25DdHgpKTtcbiAgICByZXNldE1vdGlvbihbdGlja0xhYmVsR3JvdXBTZWxlY3Rpb25dLCByZXNldEF4aXNMYWJlbFNlbGVjdGlvbkZuKCkpO1xuICAgIHJlc2V0TW90aW9uKFtsaW5lTm9kZV0sIHJlc2V0QXhpc0xpbmVTZWxlY3Rpb25GbigpKTtcbiAgfVxuICBjYWxjdWxhdGVVcGRhdGVEaWZmKHByZXZpb3VzLCB0aWNrRGF0YSkge1xuICAgIGNvbnN0IGFkZGVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCByZW1vdmVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCB0aWNrTWFwID0ge307XG4gICAgY29uc3QgdGlja0NvdW50ID0gTWF0aC5tYXgocHJldmlvdXMubGVuZ3RoLCB0aWNrRGF0YS50aWNrcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGlja0NvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHRpY2tEYXR1bSA9IHRpY2tEYXRhLnRpY2tzW2ldO1xuICAgICAgY29uc3QgcHJldiA9IHByZXZpb3VzW2ldO1xuICAgICAgY29uc3QgdGljayA9IHRpY2tEYXR1bT8udGlja0lkO1xuICAgICAgdGlja01hcFt0aWNrID8/IHByZXZdID0gdGlja0RhdHVtO1xuICAgICAgaWYgKHByZXYgPT09IHRpY2spIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocmVtb3ZlZC5oYXModGljaykpIHtcbiAgICAgICAgcmVtb3ZlZC5kZWxldGUodGljayk7XG4gICAgICB9IGVsc2UgaWYgKHRpY2spIHtcbiAgICAgICAgYWRkZWQuYWRkKHRpY2spO1xuICAgICAgfVxuICAgICAgaWYgKGFkZGVkLmhhcyhwcmV2KSkge1xuICAgICAgICBhZGRlZC5kZWxldGUocHJldik7XG4gICAgICB9IGVsc2UgaWYgKHByZXYpIHtcbiAgICAgICAgcmVtb3ZlZC5hZGQocHJldik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGNoYW5nZWQ6IGFkZGVkLnNpemUgPiAwIHx8IHJlbW92ZWQuc2l6ZSA+IDAsIGFkZGVkLCByZW1vdmVkIH07XG4gIH1cbiAgaXNSZXZlcnNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXZlcnNlO1xuICB9XG59O1xuX0F4aXMuZGVmYXVsdFRpY2tNaW5TcGFjaW5nID0gNTA7XG5fQXhpcy5Dcm9zc0xpbmVDb25zdHJ1Y3RvciA9IENhcnRlc2lhbkNyb3NzTGluZTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBfQXhpcy5wcm90b3R5cGUsIFwibmljZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBfQXhpcy5wcm90b3R5cGUsIFwicmV2ZXJzZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklOR19BUlJBWSlcbl0sIF9BeGlzLnByb3RvdHlwZSwgXCJrZXlzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgX0F4aXMucHJvdG90eXBlLCBcImludGVydmFsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBfQXhpcy5wcm90b3R5cGUsIFwidGl0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0LCB2YWx1ZSwgb2xkVmFsdWUpID0+IHRhcmdldC5vbkdyaWRMZW5ndGhDaGFuZ2UodmFsdWUsIG9sZFZhbHVlKSlcbl0sIF9BeGlzLnByb3RvdHlwZSwgXCJncmlkTGVuZ3RoXCIsIDIpO1xudmFyIEF4aXMgPSBfQXhpcztcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9jYXJ0ZXNpYW5BeGlzTGFiZWwudHNcbnZhciBDYXJ0ZXNpYW5BeGlzTGFiZWwgPSBjbGFzcyBleHRlbmRzIEF4aXNMYWJlbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5hdXRvUm90YXRlQW5nbGUgPSAzMzU7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBDYXJ0ZXNpYW5BeGlzTGFiZWwucHJvdG90eXBlLCBcImF1dG9Sb3RhdGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShERUdSRUUpXG5dLCBDYXJ0ZXNpYW5BeGlzTGFiZWwucHJvdG90eXBlLCBcImF1dG9Sb3RhdGVBbmdsZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9jYXJ0ZXNpYW5BeGlzLnRzXG52YXIgX0NhcnRlc2lhbkF4aXMgPSBjbGFzcyBfQ2FydGVzaWFuQXhpcyBleHRlbmRzIEF4aXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudGhpY2tuZXNzID0gMDtcbiAgfVxuICBzdGF0aWMgaXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBfQ2FydGVzaWFuQXhpcztcbiAgfVxuICBnZXQgZGlyZWN0aW9uKCkge1xuICAgIHJldHVybiBbXCJ0b3BcIiwgXCJib3R0b21cIl0uaW5jbHVkZXModGhpcy5wb3NpdGlvbikgPyBcInhcIiAvKiBYICovIDogXCJ5XCIgLyogWSAqLztcbiAgfVxuICB1cGRhdGVEaXJlY3Rpb24oKSB7XG4gICAgc3dpdGNoICh0aGlzLnBvc2l0aW9uKSB7XG4gICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgIHRoaXMucm90YXRpb24gPSAtOTA7XG4gICAgICAgIHRoaXMubGFiZWwubWlycm9yZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhYmVsLnBhcmFsbGVsID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7XG4gICAgICAgIHRoaXMubGFiZWwubWlycm9yZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmxhYmVsLnBhcmFsbGVsID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gLTkwO1xuICAgICAgICB0aGlzLmxhYmVsLm1pcnJvcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFiZWwucGFyYWxsZWwgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgIHRoaXMucm90YXRpb24gPSAwO1xuICAgICAgICB0aGlzLmxhYmVsLm1pcnJvcmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGFiZWwucGFyYWxsZWwgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0aGlzLmF4aXNDb250ZXh0KSB7XG4gICAgICB0aGlzLmF4aXNDb250ZXh0LnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICAgIHRoaXMuYXhpc0NvbnRleHQuZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb247XG4gICAgfVxuICB9XG4gIHVwZGF0ZShwcmltYXJ5VGlja0NvdW50LCBhbmltYXRlZCkge1xuICAgIHRoaXMudXBkYXRlRGlyZWN0aW9uKCk7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZShwcmltYXJ5VGlja0NvdW50LCBhbmltYXRlZCk7XG4gIH1cbiAgY2FsY3VsYXRlTGF5b3V0KHByaW1hcnlUaWNrQ291bnQpIHtcbiAgICB0aGlzLnVwZGF0ZURpcmVjdGlvbigpO1xuICAgIHJldHVybiBzdXBlci5jYWxjdWxhdGVMYXlvdXQocHJpbWFyeVRpY2tDb3VudCk7XG4gIH1cbiAgY3JlYXRlQXhpc0NvbnRleHQoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmNyZWF0ZUF4aXNDb250ZXh0KCksXG4gICAgICBwb3NpdGlvbjogdGhpcy5wb3NpdGlvblxuICAgIH07XG4gIH1cbiAgY3JlYXRlTGFiZWwoKSB7XG4gICAgcmV0dXJuIG5ldyBDYXJ0ZXNpYW5BeGlzTGFiZWwoKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIF9DYXJ0ZXNpYW5BeGlzLnByb3RvdHlwZSwgXCJ0aGlja25lc3NcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElPTilcbl0sIF9DYXJ0ZXNpYW5BeGlzLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCAyKTtcbnZhciBDYXJ0ZXNpYW5BeGlzID0gX0NhcnRlc2lhbkF4aXM7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvY2F0ZWdvcnlBeGlzLnRzXG52YXIgQ2F0ZWdvcnlBeGlzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5BeGlzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4LCBzY2FsZTIgPSBuZXcgQmFuZFNjYWxlKCkpIHtcbiAgICBzdXBlcihtb2R1bGVDdHgsIHNjYWxlMik7XG4gICAgdGhpcy5fcGFkZGluZ092ZXJyaWRlRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuZ3JvdXBQYWRkaW5nSW5uZXIgPSAwLjE7XG4gICAgdGhpcy5pbmNsdWRlSW52aXNpYmxlRG9tYWlucyA9IHRydWU7XG4gIH1cbiAgc2V0IHBhZGRpbmdJbm5lcih2YWx1ZSkge1xuICAgIHRoaXMuX3BhZGRpbmdPdmVycmlkZUVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuc2NhbGUucGFkZGluZ0lubmVyID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHBhZGRpbmdJbm5lcigpIHtcbiAgICB0aGlzLl9wYWRkaW5nT3ZlcnJpZGVFbmFibGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcy5zY2FsZS5wYWRkaW5nSW5uZXI7XG4gIH1cbiAgc2V0IHBhZGRpbmdPdXRlcih2YWx1ZSkge1xuICAgIHRoaXMuc2NhbGUucGFkZGluZ091dGVyID0gdmFsdWU7XG4gIH1cbiAgZ2V0IHBhZGRpbmdPdXRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZS5wYWRkaW5nT3V0ZXI7XG4gIH1cbiAgbm9ybWFsaXNlRGF0YURvbWFpbihkKSB7XG4gICAgY29uc3QgZG9tYWluID0gW107XG4gICAgY29uc3QgdW5pcXVlVmFsdWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IHYgb2YgZCkge1xuICAgICAgY29uc3Qga2V5ID0gdiBpbnN0YW5jZW9mIERhdGUgPyB2LmdldFRpbWUoKSA6IHY7XG4gICAgICBpZiAoIXVuaXF1ZVZhbHVlcy5oYXMoa2V5KSkge1xuICAgICAgICB1bmlxdWVWYWx1ZXMuYWRkKGtleSk7XG4gICAgICAgIGRvbWFpbi5wdXNoKHYpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkb21haW4sIGNsaXBwZWQ6IGZhbHNlIH07XG4gIH1cbiAgY2FsY3VsYXRlRG9tYWluKCkge1xuICAgIGlmICghdGhpcy5fcGFkZGluZ092ZXJyaWRlRW5hYmxlZCkge1xuICAgICAgbGV0IHBhZGRpbmdJbm5lciA9IEluZmluaXR5O1xuICAgICAgbGV0IHBhZGRpbmdPdXRlciA9IC1JbmZpbml0eTtcbiAgICAgIGZvciAoY29uc3QgcyBvZiB0aGlzLmJvdW5kU2VyaWVzKSB7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSBzLmdldEJhbmRTY2FsZVBhZGRpbmc/LigpO1xuICAgICAgICBpZiAocGFkZGluZyA9PSBudWxsKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBwYWRkaW5nSW5uZXIgPSBNYXRoLm1pbihwYWRkaW5nSW5uZXIsIHBhZGRpbmcuaW5uZXIpO1xuICAgICAgICBwYWRkaW5nT3V0ZXIgPSBNYXRoLm1heChwYWRkaW5nT3V0ZXIsIHBhZGRpbmcub3V0ZXIpO1xuICAgICAgfVxuICAgICAgdGhpcy5zY2FsZS5wYWRkaW5nSW5uZXIgPSBOdW1iZXIuaXNGaW5pdGUocGFkZGluZ0lubmVyKSA/IHBhZGRpbmdJbm5lciA6IDA7XG4gICAgICB0aGlzLnNjYWxlLnBhZGRpbmdPdXRlciA9IE51bWJlci5pc0Zpbml0ZShwYWRkaW5nT3V0ZXIpID8gcGFkZGluZ091dGVyIDogMDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmNhbGN1bGF0ZURvbWFpbigpO1xuICB9XG59O1xuQ2F0ZWdvcnlBeGlzLmNsYXNzTmFtZSA9IFwiQ2F0ZWdvcnlBeGlzXCI7XG5DYXRlZ29yeUF4aXMudHlwZSA9IFwiY2F0ZWdvcnlcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgQ2F0ZWdvcnlBeGlzLnByb3RvdHlwZSwgXCJncm91cFBhZGRpbmdJbm5lclwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy90cmVlLnRzXG52YXIgVHJlZU5vZGUgPSBjbGFzcyB7XG4gIC8vIGN1cnJlbnQgbnVtYmVyIGluIHNpYmxpbmcgZ3JvdXAgKGluZGV4KVxuICBjb25zdHJ1Y3RvcihsYWJlbCA9IFwiXCIsIHBhcmVudCwgbnVtYmVyMiA9IDApIHtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5zdWJ0cmVlTGVmdCA9IE5hTjtcbiAgICB0aGlzLnN1YnRyZWVSaWdodCA9IE5hTjtcbiAgICB0aGlzLnNjcmVlblggPSAwO1xuICAgIHRoaXMuc2NyZWVuWSA9IDA7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMubGVhZkNvdW50ID0gMDtcbiAgICB0aGlzLnByZWxpbSA9IDA7XG4gICAgdGhpcy5tb2QgPSAwO1xuICAgIHRoaXMuYW5jZXN0b3IgPSB0aGlzO1xuICAgIHRoaXMuY2hhbmdlID0gMDtcbiAgICB0aGlzLnNoaWZ0ID0gMDtcbiAgICB0aGlzLmxhYmVsID0gbGFiZWw7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5kZXB0aCA9IHBhcmVudCA/IHBhcmVudC5kZXB0aCArIDEgOiAwO1xuICAgIHRoaXMubnVtYmVyID0gbnVtYmVyMjtcbiAgfVxuICBnZXRMZWZ0U2libGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5udW1iZXIgPiAwICYmIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuY2hpbGRyZW5bdGhpcy5udW1iZXIgLSAxXSA6IHZvaWQgMDtcbiAgfVxuICBnZXRMZWZ0bW9zdFNpYmxpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubnVtYmVyID4gMCAmJiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmNoaWxkcmVuWzBdIDogdm9pZCAwO1xuICB9XG4gIC8vIHRyYXZlcnNlIHRoZSBsZWZ0IGNvbnRvdXIgb2YgYSBzdWJ0cmVlLCByZXR1cm4gdGhlIHN1Y2Nlc3NvciBvZiB2IG9uIHRoaXMgY29udG91clxuICBuZXh0TGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbiA/IHRoaXMuY2hpbGRyZW5bMF0gOiB0aGlzLnRocmVhZDtcbiAgfVxuICAvLyB0cmF2ZXJzZSB0aGUgcmlnaHQgY29udG91ciBvZiBhIHN1YnRyZWUsIHJldHVybiB0aGUgc3VjY2Vzc29yIG9mIHYgb24gdGhpcyBjb250b3VyXG4gIG5leHRSaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbiA/IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA6IHRoaXMudGhyZWFkO1xuICB9XG4gIGdldFNpYmxpbmdzKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmNoaWxkcmVuLmZpbHRlcigoXywgaSkgPT4gaSAhPT0gdGhpcy5udW1iZXIpIDogW107XG4gIH1cbn07XG5mdW5jdGlvbiB0aWNrc1RvVHJlZSh0aWNrcywgcGFkMiA9IHRydWUpIHtcbiAgY29uc3Qgcm9vdCA9IG5ldyBUcmVlTm9kZSgpO1xuICBsZXQgZGVwdGggPSAwO1xuICBpZiAocGFkMikge1xuICAgIHRpY2tzLmZvckVhY2goKHRpY2spID0+IGRlcHRoID0gTWF0aC5tYXgoZGVwdGgsIHRpY2subGFiZWxzLmxlbmd0aCkpO1xuICB9XG4gIHRpY2tzLmZvckVhY2goKHRpY2spID0+IHtcbiAgICBpZiAocGFkMikge1xuICAgICAgd2hpbGUgKHRpY2subGFiZWxzLmxlbmd0aCA8IGRlcHRoKSB7XG4gICAgICAgIHRpY2subGFiZWxzLnVuc2hpZnQoXCJcIik7XG4gICAgICB9XG4gICAgfVxuICAgIGluc2VydFRpY2socm9vdCwgdGljayk7XG4gIH0pO1xuICByZXR1cm4gcm9vdDtcbn1cbmZ1bmN0aW9uIGluc2VydFRpY2socm9vdCwgdGljaykge1xuICBjb25zdCBwYXRoUGFydHMgPSB0aWNrLmxhYmVscy5zbGljZSgpLnJldmVyc2UoKTtcbiAgY29uc3QgbGFzdFBhcnRJbmRleCA9IHBhdGhQYXJ0cy5sZW5ndGggLSAxO1xuICBwYXRoUGFydHMuZm9yRWFjaCgocGF0aFBhcnQsIHBhcnRJbmRleCkgPT4ge1xuICAgIGNvbnN0IGNoaWxkcmVuID0gcm9vdC5jaGlsZHJlbjtcbiAgICBjb25zdCBleGlzdGluZ05vZGUgPSBjaGlsZHJlbi5maW5kKChjaGlsZCkgPT4gY2hpbGQubGFiZWwgPT09IHBhdGhQYXJ0KTtcbiAgICBjb25zdCBpc05vdExlYWYgPSBwYXJ0SW5kZXggIT09IGxhc3RQYXJ0SW5kZXg7XG4gICAgaWYgKGV4aXN0aW5nTm9kZSAmJiBpc05vdExlYWYpIHtcbiAgICAgIHJvb3QgPSBleGlzdGluZ05vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBuZXcgVHJlZU5vZGUocGF0aFBhcnQsIHJvb3QpO1xuICAgICAgbm9kZS5udW1iZXIgPSBjaGlsZHJlbi5sZW5ndGg7XG4gICAgICBjaGlsZHJlbi5wdXNoKG5vZGUpO1xuICAgICAgaWYgKGlzTm90TGVhZikge1xuICAgICAgICByb290ID0gbm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbW92ZVN1YnRyZWUod20sIHdwLCBzaGlmdCkge1xuICBjb25zdCBzdWJ0cmVlcyA9IHdwLm51bWJlciAtIHdtLm51bWJlcjtcbiAgY29uc3QgcmF0aW8yID0gc2hpZnQgLyBzdWJ0cmVlcztcbiAgd3AuY2hhbmdlIC09IHJhdGlvMjtcbiAgd3Auc2hpZnQgKz0gc2hpZnQ7XG4gIHdtLmNoYW5nZSArPSByYXRpbzI7XG4gIHdwLnByZWxpbSArPSBzaGlmdDtcbiAgd3AubW9kICs9IHNoaWZ0O1xufVxuZnVuY3Rpb24gYW5jZXN0b3IodmltLCB2LCBkZWZhdWx0QW5jZXN0b3IpIHtcbiAgcmV0dXJuIHYuZ2V0U2libGluZ3MoKS5pbmRleE9mKHZpbS5hbmNlc3RvcikgPj0gMCA/IHZpbS5hbmNlc3RvciA6IGRlZmF1bHRBbmNlc3Rvcjtcbn1cbmZ1bmN0aW9uIGV4ZWN1dGVTaGlmdHModikge1xuICBjb25zdCBjaGlsZHJlbiA9IHYuY2hpbGRyZW47XG4gIGlmIChjaGlsZHJlbikge1xuICAgIGxldCBzaGlmdCA9IDA7XG4gICAgbGV0IGNoYW5nZSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBjb25zdCB3ID0gY2hpbGRyZW5baV07XG4gICAgICB3LnByZWxpbSArPSBzaGlmdDtcbiAgICAgIHcubW9kICs9IHNoaWZ0O1xuICAgICAgY2hhbmdlICs9IHcuY2hhbmdlO1xuICAgICAgc2hpZnQgKz0gdy5zaGlmdCArIGNoYW5nZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcG9ydGlvbih2LCBkZWZhdWx0QW5jZXN0b3IsIGRpc3RhbmNlMykge1xuICBjb25zdCB3ID0gdi5nZXRMZWZ0U2libGluZygpO1xuICBpZiAodykge1xuICAgIGxldCB2b3AgPSB2O1xuICAgIGxldCB2aXAgPSB2O1xuICAgIGxldCB2aW0gPSB3O1xuICAgIGxldCB2b20gPSB2aXAuZ2V0TGVmdG1vc3RTaWJsaW5nKCk7XG4gICAgbGV0IHNpcCA9IHZpcC5tb2Q7XG4gICAgbGV0IHNvcCA9IHZvcC5tb2Q7XG4gICAgbGV0IHNpbSA9IHZpbS5tb2Q7XG4gICAgbGV0IHNvbSA9IHZvbS5tb2Q7XG4gICAgd2hpbGUgKHZpbS5uZXh0UmlnaHQoKSAmJiB2aXAubmV4dExlZnQoKSkge1xuICAgICAgdmltID0gdmltLm5leHRSaWdodCgpO1xuICAgICAgdmlwID0gdmlwLm5leHRMZWZ0KCk7XG4gICAgICB2b20gPSB2b20ubmV4dExlZnQoKTtcbiAgICAgIHZvcCA9IHZvcC5uZXh0UmlnaHQoKTtcbiAgICAgIHZvcC5hbmNlc3RvciA9IHY7XG4gICAgICBjb25zdCBzaGlmdCA9IHZpbS5wcmVsaW0gKyBzaW0gLSAodmlwLnByZWxpbSArIHNpcCkgKyBkaXN0YW5jZTM7XG4gICAgICBpZiAoc2hpZnQgPiAwKSB7XG4gICAgICAgIG1vdmVTdWJ0cmVlKGFuY2VzdG9yKHZpbSwgdiwgZGVmYXVsdEFuY2VzdG9yKSwgdiwgc2hpZnQpO1xuICAgICAgICBzaXAgKz0gc2hpZnQ7XG4gICAgICAgIHNvcCArPSBzaGlmdDtcbiAgICAgIH1cbiAgICAgIHNpbSArPSB2aW0ubW9kO1xuICAgICAgc2lwICs9IHZpcC5tb2Q7XG4gICAgICBzb20gKz0gdm9tLm1vZDtcbiAgICAgIHNvcCArPSB2b3AubW9kO1xuICAgIH1cbiAgICBpZiAodmltLm5leHRSaWdodCgpICYmICF2b3AubmV4dFJpZ2h0KCkpIHtcbiAgICAgIHZvcC50aHJlYWQgPSB2aW0ubmV4dFJpZ2h0KCk7XG4gICAgICB2b3AubW9kICs9IHNpbSAtIHNvcDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZpcC5uZXh0TGVmdCgpICYmICF2b20ubmV4dExlZnQoKSkge1xuICAgICAgICB2b20udGhyZWFkID0gdmlwLm5leHRMZWZ0KCk7XG4gICAgICAgIHZvbS5tb2QgKz0gc2lwIC0gc29tO1xuICAgICAgfVxuICAgICAgZGVmYXVsdEFuY2VzdG9yID0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRBbmNlc3Rvcjtcbn1cbmZ1bmN0aW9uIGZpcnN0V2Fsayhub2RlLCBkaXN0YW5jZTMpIHtcbiAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgbGV0IGRlZmF1bHRBbmNlc3RvciA9IGNoaWxkcmVuWzBdO1xuICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICBmaXJzdFdhbGsoY2hpbGQsIGRpc3RhbmNlMyk7XG4gICAgICBkZWZhdWx0QW5jZXN0b3IgPSBhcHBvcnRpb24oY2hpbGQsIGRlZmF1bHRBbmNlc3RvciwgZGlzdGFuY2UzKTtcbiAgICB9KTtcbiAgICBleGVjdXRlU2hpZnRzKG5vZGUpO1xuICAgIGNvbnN0IG1pZHBvaW50ID0gKGNoaWxkcmVuWzBdLnByZWxpbSArIGNoaWxkcmVuLmF0KC0xKS5wcmVsaW0pIC8gMjtcbiAgICBjb25zdCBsZWZ0U2libGluZyA9IG5vZGUuZ2V0TGVmdFNpYmxpbmcoKTtcbiAgICBpZiAobGVmdFNpYmxpbmcpIHtcbiAgICAgIG5vZGUucHJlbGltID0gbGVmdFNpYmxpbmcucHJlbGltICsgZGlzdGFuY2UzO1xuICAgICAgbm9kZS5tb2QgPSBub2RlLnByZWxpbSAtIG1pZHBvaW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnByZWxpbSA9IG1pZHBvaW50O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsZWZ0U2libGluZyA9IG5vZGUuZ2V0TGVmdFNpYmxpbmcoKTtcbiAgICBub2RlLnByZWxpbSA9IGxlZnRTaWJsaW5nID8gbGVmdFNpYmxpbmcucHJlbGltICsgZGlzdGFuY2UzIDogMDtcbiAgfVxufVxudmFyIERpbWVuc2lvbnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudG9wID0gSW5maW5pdHk7XG4gICAgdGhpcy5yaWdodCA9IC1JbmZpbml0eTtcbiAgICB0aGlzLmJvdHRvbSA9IC1JbmZpbml0eTtcbiAgICB0aGlzLmxlZnQgPSBJbmZpbml0eTtcbiAgfVxuICB1cGRhdGUobm9kZSwgeHkpIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHh5KG5vZGUpO1xuICAgIGlmICh4ID4gdGhpcy5yaWdodCkge1xuICAgICAgdGhpcy5yaWdodCA9IHg7XG4gICAgfVxuICAgIGlmICh4IDwgdGhpcy5sZWZ0KSB7XG4gICAgICB0aGlzLmxlZnQgPSB4O1xuICAgIH1cbiAgICBpZiAoeSA+IHRoaXMuYm90dG9tKSB7XG4gICAgICB0aGlzLmJvdHRvbSA9IHk7XG4gICAgfVxuICAgIGlmICh5IDwgdGhpcy50b3ApIHtcbiAgICAgIHRoaXMudG9wID0geTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBzZWNvbmRXYWxrKHYsIG0sIGxheW91dCkge1xuICB2LnggPSB2LnByZWxpbSArIG07XG4gIHYueSA9IHYuZGVwdGg7XG4gIGxheW91dC51cGRhdGUodik7XG4gIHYuY2hpbGRyZW4uZm9yRWFjaCgodykgPT4gc2Vjb25kV2Fsayh3LCBtICsgdi5tb2QsIGxheW91dCkpO1xufVxuZnVuY3Rpb24gdGhpcmRXYWxrKHYpIHtcbiAgY29uc3QgY2hpbGRyZW4gPSB2LmNoaWxkcmVuO1xuICBsZXQgbGVhZkNvdW50ID0gMDtcbiAgY2hpbGRyZW4uZm9yRWFjaCgodykgPT4ge1xuICAgIHRoaXJkV2Fsayh3KTtcbiAgICBpZiAody5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIGxlYWZDb3VudCArPSB3LmxlYWZDb3VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVhZkNvdW50Kys7XG4gICAgfVxuICB9KTtcbiAgdi5sZWFmQ291bnQgPSBsZWFmQ291bnQ7XG4gIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2LnN1YnRyZWVMZWZ0ID0gY2hpbGRyZW5bMF0uc3VidHJlZUxlZnQ7XG4gICAgdi5zdWJ0cmVlUmlnaHQgPSBjaGlsZHJlblt2LmNoaWxkcmVuLmxlbmd0aCAtIDFdLnN1YnRyZWVSaWdodDtcbiAgICB2LnggPSAodi5zdWJ0cmVlTGVmdCArIHYuc3VidHJlZVJpZ2h0KSAvIDI7XG4gIH0gZWxzZSB7XG4gICAgdi5zdWJ0cmVlTGVmdCA9IHYueDtcbiAgICB2LnN1YnRyZWVSaWdodCA9IHYueDtcbiAgfVxufVxuZnVuY3Rpb24gdHJlZUxheW91dChyb290KSB7XG4gIGNvbnN0IGxheW91dCA9IG5ldyBUcmVlTGF5b3V0KCk7XG4gIGZpcnN0V2Fsayhyb290LCAxKTtcbiAgc2Vjb25kV2Fsayhyb290LCAtcm9vdC5wcmVsaW0sIGxheW91dCk7XG4gIHRoaXJkV2Fsayhyb290KTtcbiAgcmV0dXJuIGxheW91dDtcbn1cbnZhciBUcmVlTGF5b3V0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRpbWVuc2lvbnMgPSBuZXcgRGltZW5zaW9ucygpO1xuICAgIHRoaXMubGVhZkNvdW50ID0gMDtcbiAgICB0aGlzLm5vZGVzID0gW107XG4gICAgLy8gT25lIG1pZ2h0IHdhbnQgdG8gcHJvY2VzcyBsZWFmIG5vZGVzIHNlcGFyYXRlbHkgZnJvbSB0aGUgcmVzdCBvZiB0aGUgdHJlZS5cbiAgICAvLyBGb3IgZXhhbXBsZSwgcG9zaXRpb24gbGFiZWxzIGNvcnJlc3BvbmRpbmcgdG8gbGVhZnMgdmVydGljYWxseSwgcmF0aGVyIHRoYW4gaG9yaXpvbnRhbGx5LlxuICAgIHRoaXMubGVhZk5vZGVzID0gW107XG4gICAgdGhpcy5ub25MZWFmTm9kZXMgPSBbXTtcbiAgICB0aGlzLmRlcHRoID0gMDtcbiAgfVxuICB1cGRhdGUobm9kZSkge1xuICAgIHRoaXMuZGltZW5zaW9ucy51cGRhdGUobm9kZSwgKG4pID0+ICh7IHg6IG4ueCwgeTogbi55IH0pKTtcbiAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHRoaXMubm9uTGVhZk5vZGVzLnB1c2gobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGVhZkNvdW50Kys7XG4gICAgICB0aGlzLmxlYWZOb2Rlcy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgICBpZiAobm9kZS5kZXB0aCA+IHRoaXMuZGVwdGgpIHtcbiAgICAgIHRoaXMuZGVwdGggPSBub2RlLmRlcHRoO1xuICAgIH1cbiAgICB0aGlzLm5vZGVzLnB1c2gobm9kZSk7XG4gIH1cbiAgcmVzaXplKHdpZHRoLCBoZWlnaHQsIHNoaWZ0WCA9IDAsIHNoaWZ0WSA9IDAsIGZsaXBYID0gZmFsc2UpIHtcbiAgICBjb25zdCB4U3RlcHMgPSB0aGlzLmxlYWZDb3VudCAtIDE7XG4gICAgY29uc3QgeVN0ZXBzID0gdGhpcy5kZXB0aDtcbiAgICBjb25zdCBkaW1lbnNpb25zID0gdGhpcy5kaW1lbnNpb25zO1xuICAgIGxldCBzY2FsaW5nWCA9IDE7XG4gICAgbGV0IHNjYWxpbmdZID0gMTtcbiAgICBpZiAod2lkdGggPiAwICYmIHhTdGVwcykge1xuICAgICAgY29uc3QgZXhpc3RpbmdTcGFjaW5nWCA9IChkaW1lbnNpb25zLnJpZ2h0IC0gZGltZW5zaW9ucy5sZWZ0KSAvIHhTdGVwcztcbiAgICAgIGNvbnN0IGRlc2lyZWRTcGFjaW5nWCA9IHdpZHRoIC8geFN0ZXBzO1xuICAgICAgc2NhbGluZ1ggPSBkZXNpcmVkU3BhY2luZ1ggLyBleGlzdGluZ1NwYWNpbmdYO1xuICAgICAgaWYgKGZsaXBYKSB7XG4gICAgICAgIHNjYWxpbmdYID0gLXNjYWxpbmdYO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGVpZ2h0ID4gMCAmJiB5U3RlcHMpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nU3BhY2luZ1kgPSAoZGltZW5zaW9ucy5ib3R0b20gLSBkaW1lbnNpb25zLnRvcCkgLyB5U3RlcHM7XG4gICAgICBjb25zdCBkZXNpcmVkU3BhY2luZ1kgPSBoZWlnaHQgLyB5U3RlcHM7XG4gICAgICBzY2FsaW5nWSA9IGRlc2lyZWRTcGFjaW5nWSAvIGV4aXN0aW5nU3BhY2luZ1k7XG4gICAgfVxuICAgIGNvbnN0IHNjcmVlbkRpbWVuc2lvbnMgPSBuZXcgRGltZW5zaW9ucygpO1xuICAgIHRoaXMubm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgbm9kZS5zY3JlZW5YID0gbm9kZS54ICogc2NhbGluZ1g7XG4gICAgICBub2RlLnNjcmVlblkgPSBub2RlLnkgKiBzY2FsaW5nWTtcbiAgICAgIHNjcmVlbkRpbWVuc2lvbnMudXBkYXRlKG5vZGUsIChuKSA9PiAoeyB4OiBuLnNjcmVlblgsIHk6IG4uc2NyZWVuWSB9KSk7XG4gICAgfSk7XG4gICAgY29uc3Qgb2Zmc2V0WCA9IC1zY3JlZW5EaW1lbnNpb25zLmxlZnQ7XG4gICAgY29uc3Qgb2Zmc2V0WSA9IC1zY3JlZW5EaW1lbnNpb25zLnRvcDtcbiAgICB0aGlzLm5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIG5vZGUuc2NyZWVuWCArPSBvZmZzZXRYICsgc2hpZnRYO1xuICAgICAgbm9kZS5zY3JlZW5ZICs9IG9mZnNldFkgKyBzaGlmdFk7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvZ3JvdXBlZENhdGVnb3J5QXhpcy50c1xudmFyIEdyb3VwZWRDYXRlZ29yeUF4aXNMYWJlbCA9IGNsYXNzIGV4dGVuZHMgQXhpc0xhYmVsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmdyaWQgPSBmYWxzZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBHcm91cGVkQ2F0ZWdvcnlBeGlzTGFiZWwucHJvdG90eXBlLCBcImdyaWRcIiwgMik7XG52YXIgR3JvdXBlZENhdGVnb3J5QXhpcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuQXhpcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIGNvbnN0IHNjYWxlMiA9IG5ldyBCYW5kU2NhbGUoKTtcbiAgICBzY2FsZTIucGFkZGluZ091dGVyID0gMC4xO1xuICAgIHNjYWxlMi5wYWRkaW5nSW5uZXIgPSBzY2FsZTIucGFkZGluZ091dGVyICogMjtcbiAgICBzdXBlcihtb2R1bGVDdHgsIHNjYWxlMik7XG4gICAgLy8gTGFiZWwgc2NhbGUgKGxhYmVscyBhcmUgcG9zaXRpb25lZCBiZXR3ZWVuIHRpY2tzLCB0aWNrIGNvdW50ID0gbGFiZWwgY291bnQgKyAxKS5cbiAgICAvLyBXZSBkb24ndCBjYWxsIGlzIGBsYWJlbFNjYWxlYCBmb3IgY29uc2lzdGVuY3kgd2l0aCBvdGhlciBheGVzLlxuICAgIHRoaXMudGlja1NjYWxlID0gbmV3IEJhbmRTY2FsZSgpO1xuICAgIHRoaXMubGluZSA9IG5ldyBBeGlzTGluZSgpO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgR3JvdXBlZENhdGVnb3J5QXhpc0xhYmVsKCk7XG4gICAgdGhpcy5sYWJlbENvbG9yID0gXCJyZ2JhKDg3LCA4NywgODcsIDEpXCI7XG4gICAgdGhpcy5pbmNsdWRlSW52aXNpYmxlRG9tYWlucyA9IHRydWU7XG4gICAgY29uc3QgeyB0aWNrTGluZUdyb3VwLCB0aWNrTGFiZWxHcm91cCwgZ3JpZExpbmVHcm91cCwgdGlja1NjYWxlIH0gPSB0aGlzO1xuICAgIHRpY2tTY2FsZS5wYWRkaW5nSW5uZXIgPSAxO1xuICAgIHRpY2tTY2FsZS5wYWRkaW5nT3V0ZXIgPSAwO1xuICAgIHRoaXMuZ3JpZExpbmVTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KGdyaWRMaW5lR3JvdXAsIExpbmUpO1xuICAgIHRoaXMuYXhpc0xpbmVTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRpY2tMaW5lR3JvdXAsIExpbmUpO1xuICAgIHRoaXMuc2VwYXJhdG9yU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdCh0aWNrTGluZUdyb3VwLCBMaW5lKTtcbiAgICB0aGlzLmxhYmVsU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdCh0aWNrTGFiZWxHcm91cCwgVGV4dCk7XG4gICAgdGhpcy5saW5lTm9kZS52aXNpYmxlID0gZmFsc2U7XG4gIH1cbiAgdXBkYXRlUmFuZ2UoKSB7XG4gICAgY29uc3QgeyByYW5nZTogcnIsIHZpc2libGVSYW5nZTogdnIsIHNjYWxlOiBzY2FsZTIgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3BhbiA9IChyclsxXSAtIHJyWzBdKSAvICh2clsxXSAtIHZyWzBdKTtcbiAgICBjb25zdCBzaGlmdCA9IHNwYW4gKiB2clswXTtcbiAgICBjb25zdCBzdGFydCA9IHJyWzBdIC0gc2hpZnQ7XG4gICAgdGhpcy50aWNrU2NhbGUucmFuZ2UgPSBzY2FsZTIucmFuZ2UgPSBbc3RhcnQsIHN0YXJ0ICsgc3Bhbl07XG4gICAgdGhpcy5yZXNpemVUaWNrVHJlZSgpO1xuICB9XG4gIHJlc2l6ZVRpY2tUcmVlKCkge1xuICAgIGNvbnN0IHMgPSB0aGlzLnNjYWxlO1xuICAgIGNvbnN0IHJhbmdlMyA9IHMuZG9tYWluLmxlbmd0aCA/IFtzLmNvbnZlcnQocy5kb21haW5bMF0pLCBzLmNvbnZlcnQocy5kb21haW5bcy5kb21haW4ubGVuZ3RoIC0gMV0pXSA6IHMucmFuZ2U7XG4gICAgY29uc3QgbGF5b3V0ID0gdGhpcy50aWNrVHJlZUxheW91dDtcbiAgICBjb25zdCBsaW5lSGVpZ2h0ID0gdGhpcy5saW5lSGVpZ2h0O1xuICAgIGlmIChsYXlvdXQpIHtcbiAgICAgIGxheW91dC5yZXNpemUoXG4gICAgICAgIE1hdGguYWJzKHJhbmdlM1sxXSAtIHJhbmdlM1swXSksXG4gICAgICAgIGxheW91dC5kZXB0aCAqIGxpbmVIZWlnaHQsXG4gICAgICAgIChNYXRoLm1pbihyYW5nZTNbMF0sIHJhbmdlM1sxXSkgfHwgMCkgKyAocy5iYW5kd2lkdGggPz8gMCkgLyAyLFxuICAgICAgICAtbGF5b3V0LmRlcHRoICogbGluZUhlaWdodCxcbiAgICAgICAgcmFuZ2UzWzFdIC0gcmFuZ2UzWzBdIDwgMFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGxpbmVIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMubGFiZWwuZm9udFNpemUgKiAxLjU7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBsZW5ndGggb2YgdGhlIGdyaWQuIFRoZSBncmlkIGlzIG9ubHkgdmlzaWJsZSBpbiBjYXNlIG9mIGEgbm9uLXplcm8gdmFsdWUuXG4gICAqL1xuICBvbkdyaWRWaXNpYmlsaXR5Q2hhbmdlKCkge1xuICAgIHRoaXMuZ3JpZExpbmVTZWxlY3Rpb24uY2xlYXIoKTtcbiAgICB0aGlzLmxhYmVsU2VsZWN0aW9uLmNsZWFyKCk7XG4gIH1cbiAgY2FsY3VsYXRlRG9tYWluKCkge1xuICAgIGNvbnN0IHsgZGlyZWN0aW9uIH0gPSB0aGlzO1xuICAgIGxldCBpc051bWVyaWNYID0gbnVsbDtcbiAgICBjb25zdCBmbGF0RG9tYWlucyA9IHRoaXMuYm91bmRTZXJpZXMuZmlsdGVyKChzKSA9PiBzLnZpc2libGUpLmZsYXRNYXAoKHNlcmllcykgPT4ge1xuICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLyB8fCBpc051bWVyaWNYKSB7XG4gICAgICAgIHJldHVybiBzZXJpZXMuZ2V0RG9tYWluKGRpcmVjdGlvbik7XG4gICAgICB9XG4gICAgICBpZiAoaXNOdW1lcmljWCA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBkb21haW4yID0gc2VyaWVzLmdldERvbWFpbihkaXJlY3Rpb24pO1xuICAgICAgICBpc051bWVyaWNYID0gaXNOdW1iZXIoZG9tYWluMlswXSk7XG4gICAgICAgIHJldHVybiBkb21haW4yO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtdO1xuICAgIH0pO1xuICAgIHRoaXMuc2V0RG9tYWluKGV4dGVudChmbGF0RG9tYWlucykgPz8gdW5pcXVlKGZsYXREb21haW5zKSk7XG4gICAgY29uc3QgeyBkb21haW4gfSA9IHRoaXMuZGF0YURvbWFpbjtcbiAgICB0aGlzLnRpY2tUcmVlTGF5b3V0ID0gdHJlZUxheW91dCh0aWNrc1RvVHJlZShkb21haW4pKTtcbiAgICB0aGlzLnRpY2tTY2FsZS5kb21haW4gPSBkb21haW4uY29uY2F0KFwiXCIpO1xuICAgIHRoaXMucmVzaXplVGlja1RyZWUoKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcy9yZW1vdmVzL3VwZGF0ZXMgdGhlIHNjZW5lIGdyYXBoIG5vZGVzIHRoYXQgY29uc3RpdHV0ZSB0aGUgYXhpcy5cbiAgICogU3VwcG9zZWQgdG8gYmUgY2FsbGVkIF9tYW51YWxseV8gYWZ0ZXIgY2hhbmdpbmcgX2FueV8gb2YgdGhlIGF4aXMgcHJvcGVydGllcy5cbiAgICogVGhpcyBhbGxvd3MgdG8gYnVsayBzZXQgYXhpcyBwcm9wZXJ0aWVzIGJlZm9yZSB1cGRhdGluZyB0aGUgbm9kZXMuXG4gICAqIFRoZSBub2RlIGNoYW5nZXMgbWFkZSBieSB0aGlzIG1ldGhvZCBhcmUgcmVuZGVyZWQgb24gdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lLlxuICAgKiBXZSBjb3VsZCBzY2hlZHVsZSB0aGlzIG1ldGhvZCBjYWxsIGF1dG9tYXRpY2FsbHkgb24gdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lXG4gICAqIHdoZW4gYW55IG9mIHRoZSBheGlzIHByb3BlcnRpZXMgY2hhbmdlICh0aGUgd2F5IHdlIGRvIHdoZW4gcHJvcGVydGllcyBvZiBzY2VuZSBncmFwaCdzXG4gICAqIG5vZGVzIGNoYW5nZSksIGJ1dCB0aGlzIHdpbGwgbWVhbiB0aGF0IHdlIGZpcnN0IHdhaXQgZm9yIHRoZSBuZXh0IGFuaW1hdGlvblxuICAgKiBmcmFtZSB0byBtYWtlIGNoYW5nZXMgdG8gdGhlIG5vZGVzIG9mIHRoZSBheGlzLCB0aGVuIHdhaXQgZm9yIGFub3RoZXIgYW5pbWF0aW9uXG4gICAqIGZyYW1lIHRvIHJlbmRlciB0aG9zZSBjaGFuZ2VzLiBJdCdzIG5pY2UgdG8gaGF2ZSBldmVyeXRoaW5nIHVwZGF0ZSBhdXRvbWF0aWNhbGx5LFxuICAgKiBidXQgdGhpcyBleHRyYSBsZXZlbCBvZiBhc3luYyBpbmRpcmVjdGlvbiB3aWxsIG5vdCBqdXN0IGludHJvZHVjZSBhbiB1bndhbnRlZCBkZWxheSxcbiAgICogaXQgd2lsbCBhbHNvIG1ha2UgaXQgaGFyZGVyIHRvIHJlYXNvbiBhYm91dCB0aGUgcHJvZ3JhbS5cbiAgICovXG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAoIXRoaXMuY29tcHV0ZWRMYXlvdXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVQb3NpdGlvbigpO1xuICAgIHRoaXMudXBkYXRlVGl0bGVDYXB0aW9uKCk7XG4gICAgdGhpcy51cGRhdGVDYXRlZ29yeUxhYmVscygpO1xuICAgIHRoaXMudXBkYXRlU2VwYXJhdG9ycygpO1xuICAgIHRoaXMudXBkYXRlQXhpc0xpbmVzKCk7XG4gICAgdGhpcy51cGRhdGVDYXRlZ29yeUdyaWRMaW5lcygpO1xuICAgIHRoaXMucmVzZXRTZWxlY3Rpb25Ob2RlcygpO1xuICB9XG4gIHVwZGF0ZVRpdGxlQ2FwdGlvbigpIHtcbiAgICBjb25zdCB7IF90aXRsZUNhcHRpb24gfSA9IHRoaXM7XG4gICAgX3RpdGxlQ2FwdGlvbi5ub2RlLnZpc2libGUgPSBmYWxzZTtcbiAgfVxuICB1cGRhdGVDYXRlZ29yeUxhYmVscygpIHtcbiAgICBpZiAoIXRoaXMuY29tcHV0ZWRMYXlvdXQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyB0aWNrTGFiZWxMYXlvdXQgfSA9IHRoaXMuY29tcHV0ZWRMYXlvdXQ7XG4gICAgY29uc3QgbGFiZWxTZWxlY3Rpb24gPSB0aGlzLmxhYmVsU2VsZWN0aW9uLnVwZGF0ZSh0aWNrTGFiZWxMYXlvdXQpO1xuICAgIGxhYmVsU2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtKSA9PiB7XG4gICAgICBub2RlLnNldFByb3BlcnRpZXMoZGF0dW0pO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVNlcGFyYXRvcnMoKSB7XG4gICAgaWYgKCF0aGlzLmNvbXB1dGVkTGF5b3V0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgc2VwYXJhdG9yTGF5b3V0IH0gPSB0aGlzLmNvbXB1dGVkTGF5b3V0O1xuICAgIGNvbnN0IHsgcmFuZ2U6IHJhbmdlMyB9ID0gdGhpcztcbiAgICBjb25zdCBlcHNpbG9uMiA9IDFlLTc7XG4gICAgY29uc3Qgc2VwYXJhdG9yU2VsZWN0aW9uID0gdGhpcy5zZXBhcmF0b3JTZWxlY3Rpb24udXBkYXRlKHNlcGFyYXRvckxheW91dCk7XG4gICAgc2VwYXJhdG9yU2VsZWN0aW9uLmVhY2goKGxpbmUsIGRhdHVtKSA9PiB7XG4gICAgICBsaW5lLngxID0gZGF0dW0ueDE7XG4gICAgICBsaW5lLngyID0gZGF0dW0ueDI7XG4gICAgICBsaW5lLnkxID0gZGF0dW0ueTtcbiAgICAgIGxpbmUueTIgPSBkYXR1bS55O1xuICAgICAgbGluZS52aXNpYmxlID0gdGhpcy50aWNrLmVuYWJsZWQgJiYgZGF0dW0ueSA+PSByYW5nZTNbMF0gLSBlcHNpbG9uMiAmJiBkYXR1bS55IDw9IHJhbmdlM1sxXSArIGVwc2lsb24yO1xuICAgICAgbGluZS5zdHJva2UgPSB0aGlzLnRpY2suc3Ryb2tlO1xuICAgICAgbGluZS5maWxsID0gdm9pZCAwO1xuICAgICAgbGluZS5zdHJva2VXaWR0aCA9IDE7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlQXhpc0xpbmVzKCkge1xuICAgIGlmICghdGhpcy5jb21wdXRlZExheW91dClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGF4aXNMaW5lTGF5b3V0IH0gPSB0aGlzLmNvbXB1dGVkTGF5b3V0O1xuICAgIGNvbnN0IGF4aXNMaW5lU2VsZWN0aW9uID0gdGhpcy5heGlzTGluZVNlbGVjdGlvbi51cGRhdGUoYXhpc0xpbmVMYXlvdXQpO1xuICAgIGF4aXNMaW5lU2VsZWN0aW9uLmVhY2goKGxpbmUsIGRhdHVtKSA9PiB7XG4gICAgICBsaW5lLnNldFByb3BlcnRpZXMoe1xuICAgICAgICAuLi5kYXR1bSxcbiAgICAgICAgc3Ryb2tlOiB0aGlzLmxpbmUuc3Ryb2tlLFxuICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5saW5lLndpZHRoXG4gICAgICB9KTtcbiAgICAgIGxpbmUueDEgPSBkYXR1bS54O1xuICAgICAgbGluZS54MiA9IGRhdHVtLng7XG4gICAgICBsaW5lLnkxID0gZGF0dW0ueTE7XG4gICAgICBsaW5lLnkyID0gZGF0dW0ueTI7XG4gICAgICBsaW5lLnN0cm9rZVdpZHRoID0gdGhpcy5saW5lLndpZHRoO1xuICAgICAgbGluZS5zdHJva2UgPSB0aGlzLmxpbmUuc3Ryb2tlO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUNhdGVnb3J5R3JpZExpbmVzKCkge1xuICAgIGNvbnN0IHsgZ3JpZExlbmd0aCwgZ3JpZExpbmUsIGxhYmVsLCByYW5nZTogcmFuZ2UzLCB0aWNrU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgdGlja3MgPSB0aWNrU2NhbGUudGlja3MoKTtcbiAgICBjb25zdCBzaWRlRmxhZyA9IGxhYmVsLmdldFNpZGVGbGFnKCk7XG4gICAgY29uc3QgZ3JpZFNlbGVjdGlvbiA9IHRoaXMuZ3JpZExpbmVTZWxlY3Rpb24udXBkYXRlKGdyaWRMZW5ndGggPyB0aWNrcyA6IFtdKTtcbiAgICBpZiAoZ3JpZExlbmd0aCkge1xuICAgICAgY29uc3QgeyB3aWR0aCwgc3R5bGUgfSA9IGdyaWRMaW5lO1xuICAgICAgY29uc3Qgc3R5bGVDb3VudCA9IHN0eWxlLmxlbmd0aDtcbiAgICAgIGdyaWRTZWxlY3Rpb24uZWFjaCgobGluZSwgZGF0dW0sIGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHkgPSBNYXRoLnJvdW5kKHRpY2tTY2FsZS5jb252ZXJ0KGRhdHVtKSk7XG4gICAgICAgIGxpbmUueDEgPSAwO1xuICAgICAgICBsaW5lLngyID0gLXNpZGVGbGFnICogZ3JpZExlbmd0aDtcbiAgICAgICAgbGluZS55MSA9IHk7XG4gICAgICAgIGxpbmUueTIgPSB5O1xuICAgICAgICBsaW5lLnZpc2libGUgPSBncmlkTGluZS5lbmFibGVkICYmIHkgPj0gcmFuZ2UzWzBdICYmIHkgPD0gcmFuZ2UzWzFdO1xuICAgICAgICBjb25zdCB7IHN0cm9rZSwgbGluZURhc2ggfSA9IHN0eWxlW2luZGV4ICUgc3R5bGVDb3VudF07XG4gICAgICAgIGxpbmUuc3Ryb2tlID0gc3Ryb2tlO1xuICAgICAgICBsaW5lLnN0cm9rZVdpZHRoID0gd2lkdGg7XG4gICAgICAgIGxpbmUubGluZURhc2ggPSBsaW5lRGFzaDtcbiAgICAgICAgbGluZS5maWxsID0gdm9pZCAwO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbXB1dGVMYXlvdXQoKSB7XG4gICAgdGhpcy51cGRhdGVEaXJlY3Rpb24oKTtcbiAgICB0aGlzLmNhbGN1bGF0ZURvbWFpbigpO1xuICAgIHRoaXMudXBkYXRlUmFuZ2UoKTtcbiAgICBjb25zdCB7XG4gICAgICBzY2FsZTogc2NhbGUyLFxuICAgICAgbGFiZWwsXG4gICAgICBsYWJlbDogeyBwYXJhbGxlbCB9LFxuICAgICAgbW9kdWxlQ3R4OiB7IGNhbGxiYWNrQ2FjaGUgfSxcbiAgICAgIHJhbmdlOiByYW5nZTMsXG4gICAgICB0aXRsZSxcbiAgICAgIHRpdGxlOiB7IGZvcm1hdHRlciA9IChwKSA9PiBwLmRlZmF1bHRWYWx1ZSB9ID0ge31cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCByYW5nZVN0YXJ0ID0gc2NhbGUyLnJhbmdlWzBdO1xuICAgIGNvbnN0IHJhbmdlRW5kID0gc2NhbGUyLnJhbmdlWzFdO1xuICAgIGNvbnN0IHJhbmdlTGVuZ3RoID0gTWF0aC5hYnMocmFuZ2VFbmQgLSByYW5nZVN0YXJ0KTtcbiAgICBjb25zdCBiYW5kd2lkdGggPSByYW5nZUxlbmd0aCAvIHNjYWxlMi5kb21haW4ubGVuZ3RoIHx8IDA7XG4gICAgY29uc3Qga2VlcEV2ZXJ5ID0gTWF0aC5jZWlsKGxhYmVsLmZvbnRTaXplIC8gYmFuZHdpZHRoKTtcbiAgICBjb25zdCByb3RhdGlvbiA9IHRvUmFkaWFucyh0aGlzLnJvdGF0aW9uKTtcbiAgICBjb25zdCBpc0hvcml6b250YWwgPSBNYXRoLmFicyhNYXRoLmNvcyhyb3RhdGlvbikpIDwgMWUtODtcbiAgICBjb25zdCBzaWRlRmxhZyA9IGxhYmVsLmdldFNpZGVGbGFnKCk7XG4gICAgY29uc3QgbGluZUhlaWdodCA9IHRoaXMubGluZUhlaWdodDtcbiAgICBjb25zdCB0aWNrVHJlZUxheW91dCA9IHRoaXMudGlja1RyZWVMYXlvdXQ7XG4gICAgY29uc3QgbGFiZWxzID0gc2NhbGUyLnRpY2tzKCk7XG4gICAgY29uc3QgdHJlZUxhYmVscyA9IHRpY2tUcmVlTGF5b3V0ID8gdGlja1RyZWVMYXlvdXQubm9kZXMgOiBbXTtcbiAgICBjb25zdCBpc0xhYmVsVHJlZSA9IHRpY2tUcmVlTGF5b3V0ID8gdGlja1RyZWVMYXlvdXQuZGVwdGggPiAxIDogZmFsc2U7XG4gICAgY29uc3QgeyBkZWZhdWx0Um90YXRpb24sIGNvbmZpZ3VyZWRSb3RhdGlvbiwgcGFyYWxsZWxGbGlwRmxhZyB9ID0gY2FsY3VsYXRlTGFiZWxSb3RhdGlvbih7XG4gICAgICByb3RhdGlvbjogbGFiZWwucm90YXRpb24sXG4gICAgICBwYXJhbGxlbCxcbiAgICAgIHJlZ3VsYXJGbGlwUm90YXRpb246IG5vcm1hbGl6ZUFuZ2xlMzYwKHJvdGF0aW9uIC0gTWF0aC5QSSAvIDIpLFxuICAgICAgcGFyYWxsZWxGbGlwUm90YXRpb246IG5vcm1hbGl6ZUFuZ2xlMzYwKHJvdGF0aW9uKVxuICAgIH0pO1xuICAgIGNvbnN0IHRpY2tMYWJlbExheW91dCA9IFtdO1xuICAgIGNvbnN0IGNvcHlMYWJlbFByb3BzID0gKG5vZGUpID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZpbGw6IG5vZGUuZmlsbCxcbiAgICAgICAgZm9udEZhbWlseTogbm9kZS5mb250RmFtaWx5LFxuICAgICAgICBmb250U2l6ZTogbm9kZS5mb250U2l6ZSxcbiAgICAgICAgZm9udFN0eWxlOiBub2RlLmZvbnRTdHlsZSxcbiAgICAgICAgZm9udFdlaWdodDogbm9kZS5mb250V2VpZ2h0LFxuICAgICAgICByb3RhdGlvbjogbm9kZS5yb3RhdGlvbixcbiAgICAgICAgcm90YXRpb25DZW50ZXJYOiBub2RlLnJvdGF0aW9uQ2VudGVyWCxcbiAgICAgICAgcm90YXRpb25DZW50ZXJZOiBub2RlLnJvdGF0aW9uQ2VudGVyWSxcbiAgICAgICAgdGV4dDogbm9kZS50ZXh0LFxuICAgICAgICB0ZXh0QWxpZ246IG5vZGUudGV4dEFsaWduLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6IG5vZGUudGV4dEJhc2VsaW5lLFxuICAgICAgICB0cmFuc2xhdGlvblg6IG5vZGUudHJhbnNsYXRpb25YLFxuICAgICAgICB0cmFuc2xhdGlvblk6IG5vZGUudHJhbnNsYXRpb25ZLFxuICAgICAgICB2aXNpYmxlOiBub2RlLnZpc2libGUsXG4gICAgICAgIHg6IG5vZGUueCxcbiAgICAgICAgeTogbm9kZS55XG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgbGFiZWxCQm94ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCBtYXhMZWFmTGFiZWxXaWR0aCA9IDA7XG4gICAgY29uc3QgdGVtcFRleHQgPSBuZXcgVGV4dCgpO1xuICAgIGNvbnN0IHNldExhYmVsUHJvcHMgPSAoZGF0dW0sIGluZGV4KSA9PiB7XG4gICAgICB0ZW1wVGV4dC5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgICAgZmlsbDogbGFiZWwuY29sb3IsXG4gICAgICAgIGZvbnRGYW1pbHk6IGxhYmVsLmZvbnRGYW1pbHksXG4gICAgICAgIGZvbnRTaXplOiBsYWJlbC5mb250U2l6ZSxcbiAgICAgICAgZm9udFN0eWxlOiBsYWJlbC5mb250U3R5bGUsXG4gICAgICAgIGZvbnRXZWlnaHQ6IGxhYmVsLmZvbnRXZWlnaHQsXG4gICAgICAgIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiBwYXJhbGxlbEZsaXBGbGFnID09PSAtMSA/IFwiYm90dG9tXCIgOiBcImhhbmdpbmdcIixcbiAgICAgICAgdHJhbnNsYXRpb25YOiBkYXR1bS5zY3JlZW5ZIC0gbGFiZWwuZm9udFNpemUgKiAwLjI1LFxuICAgICAgICB0cmFuc2xhdGlvblk6IGRhdHVtLnNjcmVlblhcbiAgICAgIH0pO1xuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIGNvbnN0IGlzQ2FwdGlvbkVuYWJsZWQgPSB0aXRsZT8uZW5hYmxlZCAmJiBsYWJlbHMubGVuZ3RoID4gMDtcbiAgICAgICAgaWYgKCFpc0NhcHRpb25FbmFibGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHQgPSBjYWxsYmFja0NhY2hlLmNhbGwoZm9ybWF0dGVyLCB0aGlzLmdldFRpdGxlRm9ybWF0dGVyUGFyYW1zKCkpO1xuICAgICAgICB0ZW1wVGV4dC5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgICAgICBmaWxsOiB0aXRsZS5jb2xvcixcbiAgICAgICAgICBmb250RmFtaWx5OiB0aXRsZS5mb250RmFtaWx5LFxuICAgICAgICAgIGZvbnRTaXplOiB0aXRsZS5mb250U2l6ZSxcbiAgICAgICAgICBmb250U3R5bGU6IHRpdGxlLmZvbnRTdHlsZSxcbiAgICAgICAgICBmb250V2VpZ2h0OiB0aXRsZS5mb250V2VpZ2h0LFxuICAgICAgICAgIHRleHQsXG4gICAgICAgICAgdGV4dEJhc2VsaW5lOiBcImhhbmdpbmdcIixcbiAgICAgICAgICB0cmFuc2xhdGlvblg6IGRhdHVtLnNjcmVlblkgLSBsYWJlbC5mb250U2l6ZSAqIDAuMjUsXG4gICAgICAgICAgdHJhbnNsYXRpb25ZOiBkYXR1bS5zY3JlZW5YXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChpbmRleCAlIGtlZXBFdmVyeSA9PT0gMCkge1xuICAgICAgICBjb25zdCBpc0luUmFuZ2UgPSBkYXR1bS5zY3JlZW5YID49IHJhbmdlM1swXSAmJiBkYXR1bS5zY3JlZW5YIDw9IHJhbmdlM1sxXTtcbiAgICAgICAgaWYgKCFpc0luUmFuZ2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhYmVsLmZvcm1hdHRlcikge1xuICAgICAgICAgIHRlbXBUZXh0LnRleHQgPSBjYWxsYmFja0NhY2hlLmNhbGwobGFiZWwuZm9ybWF0dGVyLCB7XG4gICAgICAgICAgICB2YWx1ZTogU3RyaW5nKGRhdHVtLmxhYmVsKSxcbiAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgfSkgPz8gU3RyaW5nKGRhdHVtLmxhYmVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZW1wVGV4dC50ZXh0ID0gU3RyaW5nKGRhdHVtLmxhYmVsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICB0cmVlTGFiZWxzLmZvckVhY2goKGRhdHVtLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgaXNWaXNpYmxlID0gc2V0TGFiZWxQcm9wcyhkYXR1bSwgaW5kZXgpO1xuICAgICAgaWYgKCFpc1Zpc2libGUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGJib3gyID0gdGVtcFRleHQuY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpO1xuICAgICAgaWYgKCFiYm94MilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGFiZWxCQm94ZXMuc2V0KGluZGV4LCBiYm94Mik7XG4gICAgICBjb25zdCBpc0xlYWYgPSAhZGF0dW0uY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgaWYgKGlzTGVhZiAmJiBiYm94Mi53aWR0aCA+IG1heExlYWZMYWJlbFdpZHRoKSB7XG4gICAgICAgIG1heExlYWZMYWJlbFdpZHRoID0gYmJveDIud2lkdGg7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgbGFiZWxYID0gc2lkZUZsYWcgKiBsYWJlbC5wYWRkaW5nO1xuICAgIGNvbnN0IGxhYmVsR3JpZCA9IHRoaXMubGFiZWwuZ3JpZDtcbiAgICBjb25zdCBzZXBhcmF0b3JEYXRhID0gW107XG4gICAgdHJlZUxhYmVscy5mb3JFYWNoKChkYXR1bSwgaW5kZXgpID0+IHtcbiAgICAgIGxldCB2aXNpYmxlID0gc2V0TGFiZWxQcm9wcyhkYXR1bSwgaW5kZXgpO1xuICAgICAgY29uc3QgaWQgPSBpbmRleDtcbiAgICAgIHRlbXBUZXh0LnggPSBsYWJlbFg7XG4gICAgICB0ZW1wVGV4dC5yb3RhdGlvbkNlbnRlclggPSBsYWJlbFg7XG4gICAgICBjb25zdCBpc0xlYWYgPSAhZGF0dW0uY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgaWYgKGlzTGVhZikge1xuICAgICAgICB0ZW1wVGV4dC5yb3RhdGlvbiA9IGNvbmZpZ3VyZWRSb3RhdGlvbjtcbiAgICAgICAgdGVtcFRleHQudGV4dEFsaWduID0gXCJlbmRcIjtcbiAgICAgICAgdGVtcFRleHQudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBUZXh0LnRyYW5zbGF0aW9uWCAtPSBtYXhMZWFmTGFiZWxXaWR0aCAtIGxpbmVIZWlnaHQgKyB0aGlzLmxhYmVsLnBhZGRpbmc7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZVJhbmdlID0gZGF0dW0ubGVhZkNvdW50ICogYmFuZHdpZHRoO1xuICAgICAgICBjb25zdCBiYm94MiA9IGxhYmVsQkJveGVzLmdldChpZCk7XG4gICAgICAgIGlmIChiYm94MiAmJiBiYm94Mi53aWR0aCA+IGF2YWlsYWJsZVJhbmdlKSB7XG4gICAgICAgICAgdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgIGxhYmVsQkJveGVzLmRlbGV0ZShpZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgdGVtcFRleHQucm90YXRpb24gPSBkZWZhdWx0Um90YXRpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGVtcFRleHQucm90YXRpb24gPSAtTWF0aC5QSSAvIDI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkYXR1bS5wYXJlbnQgJiYgaXNMYWJlbFRyZWUpIHtcbiAgICAgICAgY29uc3QgeSA9IGlzTGVhZiA/IGRhdHVtLnNjcmVlblggLSBiYW5kd2lkdGggLyAyIDogZGF0dW0uc2NyZWVuWCAtIGRhdHVtLmxlYWZDb3VudCAqIGJhbmR3aWR0aCAvIDI7XG4gICAgICAgIGlmIChpc0xlYWYpIHtcbiAgICAgICAgICBpZiAoZGF0dW0ubnVtYmVyICE9PSBkYXR1bS5jaGlsZHJlbi5sZW5ndGggLSAxIHx8IGxhYmVsR3JpZCkge1xuICAgICAgICAgICAgc2VwYXJhdG9yRGF0YS5wdXNoKHtcbiAgICAgICAgICAgICAgeSxcbiAgICAgICAgICAgICAgeDE6IDAsXG4gICAgICAgICAgICAgIHgyOiAtbWF4TGVhZkxhYmVsV2lkdGggLSB0aGlzLmxhYmVsLnBhZGRpbmcgKiAyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgeCA9IC1tYXhMZWFmTGFiZWxXaWR0aCAtIHRoaXMubGFiZWwucGFkZGluZyAqIDIgKyBkYXR1bS5zY3JlZW5ZO1xuICAgICAgICAgIHNlcGFyYXRvckRhdGEucHVzaCh7XG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgeDE6IHggKyBsaW5lSGVpZ2h0LFxuICAgICAgICAgICAgeDI6IHhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IHByb3BzO1xuICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgY29uc3QgYmJveDIgPSB0ZW1wVGV4dC5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XG4gICAgICAgIGlmIChiYm94Mikge1xuICAgICAgICAgIGxhYmVsQkJveGVzLnNldChpbmRleCwgYmJveDIpO1xuICAgICAgICB9XG4gICAgICAgIHByb3BzID0geyAuLi5jb3B5TGFiZWxQcm9wcyh0ZW1wVGV4dCksIHZpc2libGUgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhYmVsQkJveGVzLmRlbGV0ZShpbmRleCk7XG4gICAgICAgIHByb3BzID0geyB2aXNpYmxlIH07XG4gICAgICB9XG4gICAgICB0aWNrTGFiZWxMYXlvdXQucHVzaChwcm9wcyk7XG4gICAgfSk7XG4gICAgbGV0IG1pblggPSAwO1xuICAgIHNlcGFyYXRvckRhdGEuZm9yRWFjaCgoZCkgPT4gbWluWCA9IE1hdGgubWluKG1pblgsIGQueDIpKTtcbiAgICBzZXBhcmF0b3JEYXRhLnB1c2goe1xuICAgICAgeTogTWF0aC5tYXgocmFuZ2VTdGFydCwgcmFuZ2VFbmQpLFxuICAgICAgeDE6IDAsXG4gICAgICB4MjogbWluWFxuICAgIH0pO1xuICAgIGNvbnN0IHNlcGFyYXRvckxheW91dCA9IFtdO1xuICAgIGNvbnN0IHNlcGFyYXRvckJveGVzID0gW107XG4gICAgY29uc3QgZXBzaWxvbjIgPSAxZS03O1xuICAgIHNlcGFyYXRvckRhdGEuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgIGlmIChkYXR1bS55ID49IHJhbmdlM1swXSAtIGVwc2lsb24yICYmIGRhdHVtLnkgPD0gcmFuZ2UzWzFdICsgZXBzaWxvbjIpIHtcbiAgICAgICAgY29uc3QgeyB4MSwgeDIsIHkgfSA9IGRhdHVtO1xuICAgICAgICBjb25zdCBzZXBhcmF0b3JCb3ggPSBuZXcgQkJveChNYXRoLm1pbih4MSwgeDIpLCB5LCBNYXRoLmFicyh4MSAtIHgyKSwgMCk7XG4gICAgICAgIHNlcGFyYXRvckJveGVzLnB1c2goc2VwYXJhdG9yQm94KTtcbiAgICAgICAgc2VwYXJhdG9yTGF5b3V0LnB1c2goeyB4MSwgeDIsIHkgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgYXhpc0xpbmVMYXlvdXQgPSBbXTtcbiAgICBjb25zdCBheGlzTGluZUJveGVzID0gW107XG4gICAgY29uc3QgbGluZUNvdW50ID0gdGlja1RyZWVMYXlvdXQgPyB0aWNrVHJlZUxheW91dC5kZXB0aCArIDEgOiAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHZpc2libGUgPSBsYWJlbHMubGVuZ3RoID4gMCAmJiAoaSA9PT0gMCB8fCBsYWJlbEdyaWQgJiYgaXNMYWJlbFRyZWUpO1xuICAgICAgY29uc3QgeCA9IGkgPiAwID8gLW1heExlYWZMYWJlbFdpZHRoIC0gdGhpcy5sYWJlbC5wYWRkaW5nICogMiAtIChpIC0gMSkgKiBsaW5lSGVpZ2h0IDogMDtcbiAgICAgIGNvbnN0IGxpbmVCb3ggPSBuZXcgQkJveCh4LCBNYXRoLm1pbiguLi5yYW5nZTMpLCAwLCBNYXRoLmFicyhyYW5nZTNbMV0gLSByYW5nZTNbMF0pKTtcbiAgICAgIGF4aXNMaW5lQm94ZXMucHVzaChsaW5lQm94KTtcbiAgICAgIGF4aXNMaW5lTGF5b3V0LnB1c2goeyB4LCB5MTogcmFuZ2UzWzBdLCB5MjogcmFuZ2UzWzFdLCB2aXNpYmxlIH0pO1xuICAgIH1cbiAgICBjb25zdCBiYm94ID0gQkJveC5tZXJnZShbLi4ubGFiZWxCQm94ZXMudmFsdWVzKCksIC4uLnNlcGFyYXRvckJveGVzLCAuLi5heGlzTGluZUJveGVzXSk7XG4gICAgY29uc3QgdHJhbnNmb3JtZWRCQm94ID0gdGhpcy5nZXRUcmFuc2Zvcm1Cb3goYmJveCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJib3g6IHRyYW5zZm9ybWVkQkJveCxcbiAgICAgIHRpY2tMYWJlbExheW91dCxcbiAgICAgIHNlcGFyYXRvckxheW91dCxcbiAgICAgIGF4aXNMaW5lTGF5b3V0XG4gICAgfTtcbiAgfVxuICBjYWxjdWxhdGVMYXlvdXQoKSB7XG4gICAgY29uc3QgeyBheGlzTGluZUxheW91dCwgc2VwYXJhdG9yTGF5b3V0LCB0aWNrTGFiZWxMYXlvdXQsIGJib3ggfSA9IHRoaXMuY29tcHV0ZUxheW91dCgpO1xuICAgIHRoaXMuY29tcHV0ZWRMYXlvdXQgPSB7IGF4aXNMaW5lTGF5b3V0LCBzZXBhcmF0b3JMYXlvdXQsIHRpY2tMYWJlbExheW91dCB9O1xuICAgIHJldHVybiB7IGJib3gsIHByaW1hcnlUaWNrQ291bnQ6IHZvaWQgMCB9O1xuICB9XG59O1xuR3JvdXBlZENhdGVnb3J5QXhpcy5jbGFzc05hbWUgPSBcIkdyb3VwZWRDYXRlZ29yeUF4aXNcIjtcbkdyb3VwZWRDYXRlZ29yeUF4aXMudHlwZSA9IFwiZ3JvdXBlZC1jYXRlZ29yeVwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBHcm91cGVkQ2F0ZWdvcnlBeGlzLnByb3RvdHlwZSwgXCJsYWJlbENvbG9yXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb2R1bGUvbW9kdWxlLnRzXG52YXIgQmFzZU1vZHVsZUluc3RhbmNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAoY29uc3QgZGVzdHJveUZuIG9mIHRoaXMuZGVzdHJveUZucykge1xuICAgICAgZGVzdHJveUZuKCk7XG4gICAgfVxuICB9XG59O1xudmFyIE1vZHVsZVJlZ2lzdHJ5ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm1vZHVsZXMgPSBbXTtcbiAgICB0aGlzLmRlcGVuZGVuY2llcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5kZXBlbmRlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICByZWdpc3RlciguLi5tb2R1bGVzKSB7XG4gICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlcykge1xuICAgICAgdGhpcy5yZWdpc3RlckRlcGVuZGVuY2llcyhtb2R1bGUpO1xuICAgICAgY29uc3Qgb3RoZXJNb2R1bGUgPSB0aGlzLm1vZHVsZXMuZmluZChcbiAgICAgICAgKG90aGVyKSA9PiBtb2R1bGUudHlwZSA9PT0gb3RoZXIudHlwZSAmJiBtb2R1bGUub3B0aW9uc0tleSA9PT0gb3RoZXIub3B0aW9uc0tleSAmJiBtb2R1bGUuaWRlbnRpZmllciA9PT0gb3RoZXIuaWRlbnRpZmllclxuICAgICAgKTtcbiAgICAgIGlmIChvdGhlck1vZHVsZSkge1xuICAgICAgICBpZiAobW9kdWxlLnBhY2thZ2VUeXBlID09PSBcImVudGVycHJpc2VcIiAmJiBvdGhlck1vZHVsZS5wYWNrYWdlVHlwZSA9PT0gXCJjb21tdW5pdHlcIikge1xuICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5tb2R1bGVzLmluZGV4T2Yob3RoZXJNb2R1bGUpO1xuICAgICAgICAgIHRoaXMubW9kdWxlcy5zcGxpY2UoaW5kZXgsIDEsIG1vZHVsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubW9kdWxlcy5wdXNoKG1vZHVsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhc0VudGVycHJpc2VNb2R1bGVzKCkge1xuICAgIHJldHVybiB0aGlzLm1vZHVsZXMuc29tZSgobSkgPT4gbS5wYWNrYWdlVHlwZSA9PT0gXCJlbnRlcnByaXNlXCIpO1xuICB9XG4gICpieVR5cGUoLi4udHlwZXMpIHtcbiAgICBjb25zdCB7IGRlcGVuZGVudHMgfSA9IHRoaXM7XG4gICAgY29uc3QgeWllbGRlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBjb25zdCBtYXhDb3VudCA9IDM7XG4gICAgY29uc3QgbW9kdWxlc0J5VHlwZSA9IHRoaXMubW9kdWxlcy5maWx0ZXIoKG1vZHVsZSkgPT4gdHlwZXMuaW5jbHVkZXMobW9kdWxlLnR5cGUpKTtcbiAgICBkbyB7XG4gICAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVzQnlUeXBlKSB7XG4gICAgICAgIGlmICh5aWVsZGVkLmhhcyhtb2R1bGUub3B0aW9uc0tleSkgfHwgZGVwZW5kZW50cy5oYXMobW9kdWxlLm9wdGlvbnNLZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgbW9kdWxlO1xuICAgICAgICB5aWVsZGVkLmFkZChtb2R1bGUub3B0aW9uc0tleSk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgZGVwZW5kZW5jaWVzXSBvZiBkZXBlbmRlbnRzLmVudHJpZXMoKSkge1xuICAgICAgICAgIGRlcGVuZGVuY2llcy5kZWxldGUobW9kdWxlLm9wdGlvbnNLZXkpO1xuICAgICAgICAgIGlmIChkZXBlbmRlbmNpZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgZGVwZW5kZW50cy5kZWxldGUoa2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvdW50Kys7XG4gICAgfSB3aGlsZSAoeWllbGRlZC5zaXplIDwgbW9kdWxlc0J5VHlwZS5sZW5ndGggJiYgY291bnQgPCBtYXhDb3VudCk7XG4gICAgaWYgKGRlcGVuZGVudHMuc2l6ZSA+IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHJlc29sdmUgbW9kdWxlIGRlcGVuZGVuY2llczogWyR7Wy4uLmRlcGVuZGVudHMua2V5cygpXX1dYCk7XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyRGVwZW5kZW5jaWVzKG1vZHVsZSkge1xuICAgIGlmIChtb2R1bGUuZGVwZW5kZW5jaWVzID09IG51bGwgfHwgbW9kdWxlLmRlcGVuZGVuY2llcy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm47XG4gICAgZm9yIChjb25zdCBrZXkgb2YgbW9kdWxlLmRlcGVuZGVuY2llcykge1xuICAgICAgY29uc3QgZGVwZW5kZW5jaWVzID0gdGhpcy5kZXBlbmRlbmNpZXMuZ2V0KGtleSkgPz8gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGRlcGVuZGVuY2llcy5hZGQobW9kdWxlLm9wdGlvbnNLZXkpO1xuICAgICAgdGhpcy5kZXBlbmRlbmNpZXMuc2V0KGtleSwgZGVwZW5kZW5jaWVzKTtcbiAgICB9XG4gICAgdGhpcy5kZXBlbmRlbnRzLnNldChtb2R1bGUub3B0aW9uc0tleSwgbmV3IFNldChtb2R1bGUuZGVwZW5kZW5jaWVzKSk7XG4gIH1cbn07XG52YXIgbW9kdWxlUmVnaXN0cnkgPSBuZXcgTW9kdWxlUmVnaXN0cnkoKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9hc3luYy50c1xuZnVuY3Rpb24gc2xlZXAoc2xlZXBUaW1lb3V0TXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKHZvaWQgMCksIHNsZWVwVGltZW91dE1zKTtcbiAgfSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvbXV0ZXgudHNcbnZhciBNdXRleCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5hdmFpbGFibGUgPSB0cnVlO1xuICAgIHRoaXMuYWNxdWlyZVF1ZXVlID0gW107XG4gIH1cbiAgYWNxdWlyZShjYikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5hY3F1aXJlUXVldWUucHVzaChbY2IsIHJlc29sdmVdKTtcbiAgICAgIGlmICh0aGlzLmF2YWlsYWJsZSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV4dCgpLmNhdGNoKChlKSA9PiBMb2dnZXIuZXJyb3JPbmNlKGUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBhY3F1aXJlSW1tZWRpYXRlbHkoY2IpIHtcbiAgICBpZiAoIXRoaXMuYXZhaWxhYmxlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMuYWNxdWlyZShjYik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgYXN5bmMgd2FpdEZvckNsZWFyQWNxdWlyZVF1ZXVlKCkge1xuICAgIHJldHVybiB0aGlzLmFjcXVpcmUoYXN5bmMgKCkgPT4gdm9pZCAwKTtcbiAgfVxuICBhc3luYyBkaXNwYXRjaE5leHQoKSB7XG4gICAgdGhpcy5hdmFpbGFibGUgPSBmYWxzZTtcbiAgICBsZXQgW25leHQsIGRvbmVdID0gdGhpcy5hY3F1aXJlUXVldWUuc2hpZnQoKSA/PyBbXTtcbiAgICB3aGlsZSAobmV4dCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgbmV4dCgpO1xuICAgICAgICBkb25lPy4oKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIExvZ2dlci5lcnJvcihcIm11dGV4IGNhbGxiYWNrIGVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgZG9uZT8uKCk7XG4gICAgICB9XG4gICAgICBbbmV4dCwgZG9uZV0gPSB0aGlzLmFjcXVpcmVRdWV1ZS5zaGlmdCgpID8/IFtdO1xuICAgIH1cbiAgICB0aGlzLmF2YWlsYWJsZSA9IHRydWU7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvb2JzZXJ2YWJsZS50c1xudmFyIE9ic2VydmFibGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gbGlzdGVuZXIgbXVzdCBiZSBhIEZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBjb25zdCBldmVudFR5cGVMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50TGlzdGVuZXJzLmdldChldmVudFR5cGUpO1xuICAgIGlmIChldmVudFR5cGVMaXN0ZW5lcnMpIHtcbiAgICAgIGV2ZW50VHlwZUxpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLnNldChldmVudFR5cGUsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtsaXN0ZW5lcl0pKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuZ2V0KHR5cGUpPy5kZWxldGUobGlzdGVuZXIpO1xuICAgIGlmICh0aGlzLmV2ZW50TGlzdGVuZXJzLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuZGVsZXRlKHR5cGUpO1xuICAgIH1cbiAgfVxuICBoYXNFdmVudExpc3RlbmVyKHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5ldmVudExpc3RlbmVycy5oYXModHlwZSk7XG4gIH1cbiAgY2xlYXJFdmVudExpc3RlbmVycygpIHtcbiAgICB0aGlzLmV2ZW50TGlzdGVuZXJzLmNsZWFyKCk7XG4gIH1cbiAgZmlyZUV2ZW50KGV2ZW50KSB7XG4gICAgdGhpcy5ldmVudExpc3RlbmVycy5nZXQoZXZlbnQudHlwZSk/LmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihldmVudCkpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3BhZGRpbmcudHNcbnZhciBQYWRkaW5nID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKHRvcCA9IDAsIHJpZ2h0ID0gdG9wLCBib3R0b20gPSB0b3AsIGxlZnQgPSByaWdodCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy50b3AgPSB0b3A7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy50b3AgPSB0aGlzLnJpZ2h0ID0gdGhpcy5ib3R0b20gPSB0aGlzLmxlZnQgPSAwO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGFkZGluZy5wcm90b3R5cGUsIFwidG9wXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGFkZGluZy5wcm90b3R5cGUsIFwicmlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQYWRkaW5nLnByb3RvdHlwZSwgXCJib3R0b21cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQYWRkaW5nLnByb3RvdHlwZSwgXCJsZWZ0XCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3JlbmRlci50c1xuZnVuY3Rpb24gZGVib3VuY2VkQW5pbWF0aW9uRnJhbWUoY2IpIHtcbiAgcmV0dXJuIGJ1aWxkU2NoZWR1bGVyKChpbm5lckNiLCBfZGVsYXlNcykgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGlubmVyQ2IpLCBjYik7XG59XG5mdW5jdGlvbiBkZWJvdW5jZWRDYWxsYmFjayhjYikge1xuICByZXR1cm4gYnVpbGRTY2hlZHVsZXIoKGlubmVyQ2IsIGRlbGF5TXMgPSAwKSA9PiBzZXRUaW1lb3V0KGlubmVyQ2IsIGRlbGF5TXMpLCBjYik7XG59XG5mdW5jdGlvbiBidWlsZFNjaGVkdWxlcihzY2hlZHVsZUZuLCBjYikge1xuICBsZXQgc2NoZWR1bGVDb3VudCA9IDA7XG4gIGxldCBwcm9taXNlUnVubmluZyA9IGZhbHNlO1xuICBsZXQgYXdhaXRpbmdQcm9taXNlO1xuICBsZXQgYXdhaXRpbmdEb25lO1xuICBjb25zdCBidXN5ID0gKCkgPT4ge1xuICAgIHJldHVybiBwcm9taXNlUnVubmluZztcbiAgfTtcbiAgY29uc3QgZG9uZSA9ICgpID0+IHtcbiAgICBwcm9taXNlUnVubmluZyA9IGZhbHNlO1xuICAgIGF3YWl0aW5nRG9uZT8uKCk7XG4gICAgYXdhaXRpbmdEb25lID0gdm9pZCAwO1xuICAgIGF3YWl0aW5nUHJvbWlzZSA9IHZvaWQgMDtcbiAgICBpZiAoc2NoZWR1bGVDb3VudCA+IDApIHtcbiAgICAgIHNjaGVkdWxlRm4oc2NoZWR1bGVDYik7XG4gICAgfVxuICB9O1xuICBjb25zdCBzY2hlZHVsZUNiID0gKCkgPT4ge1xuICAgIGNvbnN0IGNvdW50ID0gc2NoZWR1bGVDb3VudDtcbiAgICBzY2hlZHVsZUNvdW50ID0gMDtcbiAgICBwcm9taXNlUnVubmluZyA9IHRydWU7XG4gICAgY29uc3QgbWF5YmVQcm9taXNlID0gY2IoeyBjb3VudCB9KTtcbiAgICBpZiAoIW1heWJlUHJvbWlzZSkge1xuICAgICAgZG9uZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtYXliZVByb21pc2UudGhlbihkb25lLCBkb25lKTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBzY2hlZHVsZShkZWxheU1zKSB7XG4gICAgICBpZiAoc2NoZWR1bGVDb3VudCA9PT0gMCAmJiAhYnVzeSgpKSB7XG4gICAgICAgIHNjaGVkdWxlRm4oc2NoZWR1bGVDYiwgZGVsYXlNcyk7XG4gICAgICB9XG4gICAgICBzY2hlZHVsZUNvdW50Kys7XG4gICAgfSxcbiAgICBhc3luYyBhd2FpdCgpIHtcbiAgICAgIGlmICghYnVzeSgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChhd2FpdGluZ1Byb21pc2UgPT0gbnVsbCkge1xuICAgICAgICBhd2FpdGluZ1Byb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIGF3YWl0aW5nRG9uZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGJ1c3koKSkge1xuICAgICAgICBhd2FpdCBhd2FpdGluZ1Byb21pc2U7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy92ZXJzaW9uLnRzXG52YXIgVkVSU0lPTiA9IFwiMTAuMS4wXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2FwaS9zdGF0ZS9tZW1lbnRvLnRzXG52YXIgTWVtZW50b0NhcmV0YWtlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IodmVyc2lvbikge1xuICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb24uc3BsaXQoXCItXCIpWzBdO1xuICB9XG4gIHNhdmUoLi4ub3JpZ2luYXRvcnMpIHtcbiAgICBjb25zdCBwYWNrZXQgPSB7IHZlcnNpb246IHRoaXMudmVyc2lvbiB9O1xuICAgIGZvciAoY29uc3Qgb3JpZ2luYXRvciBvZiBPYmplY3QudmFsdWVzKG9yaWdpbmF0b3JzKSkge1xuICAgICAgcGFja2V0W29yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXldID0gdGhpcy5lbmNvZGUob3JpZ2luYXRvciwgb3JpZ2luYXRvci5jcmVhdGVNZW1lbnRvKCkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFja2V0O1xuICB9XG4gIHJlc3RvcmUoYmxvYiwgLi4ub3JpZ2luYXRvcnMpIHtcbiAgICBpZiAodHlwZW9mIGJsb2IgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShgQ291bGQgbm90IHJlc3RvcmUgZGF0YSBvZiB0eXBlIFske3R5cGVvZiBibG9ifV0sIGV4cGVjdGluZyBhbiBvYmplY3QsIGlnbm9yaW5nLmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYmxvYiA9PSBudWxsKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoYENvdWxkIG5vdCByZXN0b3JlIGRhdGEgb2YgdHlwZSBbbnVsbF0sIGV4cGVjdGluZyBhbiBvYmplY3QsIGlnbm9yaW5nLmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIShcInZlcnNpb25cIiBpbiBibG9iKSB8fCB0eXBlb2YgYmxvYi52ZXJzaW9uICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoYENvdWxkIG5vdCByZXN0b3JlIGRhdGEsIG1pc3NpbmcgW3ZlcnNpb25dIHN0cmluZyBpbiBvYmplY3QsIGlnbm9yaW5nLmApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG9yaWdpbmF0b3Igb2Ygb3JpZ2luYXRvcnMpIHtcbiAgICAgIGlmICghKG9yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXkgaW4gYmxvYikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBtZW1lbnRvID0gdGhpcy5kZWNvZGUob3JpZ2luYXRvciwgYmxvYltvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5XSk7XG4gICAgICBpZiAoIW9yaWdpbmF0b3IuZ3VhcmRNZW1lbnRvKG1lbWVudG8pKSB7XG4gICAgICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgICAgICBgQ291bGQgbm90IHJlc3RvcmUgWyR7b3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleX1dIGRhdGEsIHZhbHVlIHdhcyBpbnZhbGlkLCBpZ25vcmluZy5gLFxuICAgICAgICAgIG1lbWVudG9cbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb3JpZ2luYXRvci5yZXN0b3JlTWVtZW50byh0aGlzLnZlcnNpb24sIGJsb2IudmVyc2lvbiwgbWVtZW50byk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBFbmNvZGUgYSBtZW1lbnRvIGFzIGEgc2VyaWFsaXphYmxlIG9iamVjdCwgZW5jb2RpbmcgYW55IG5vbi1zZXJpYWxpemJsZSB0eXBlcy5cbiAgICovXG4gIGVuY29kZShvcmlnaW5hdG9yLCBtZW1lbnRvKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1lbWVudG8sIHRoaXMuZW5jb2RlVHlwZXMpKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZW5jb2RlIFske29yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXl9XSB2YWx1ZSBbJHtlcnJvcn1dLmAsIHtcbiAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIERlY29kZSBhbiBlbmNvZGVkIG1lbWVudG8sIGRlY29kaW5nIGFueSBub24tc2VyaWFsaXphYmxlIHR5cGVzLlxuICAgKi9cbiAgZGVjb2RlKG9yaWdpbmF0b3IsIGVuY29kZWQpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZW5jb2RlZCksIHRoaXMuZGVjb2RlVHlwZXMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBkZWNvZGUgWyR7b3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleX1dIHZhbHVlIFske2Vycm9yfV0uYCwge1xuICAgICAgICBjYXVzZTogZXJyb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBlbmNvZGVUeXBlcyhrZXksIHZhbHVlKSB7XG4gICAgaWYgKGlzRGF0ZSh0aGlzW2tleV0pKSB7XG4gICAgICByZXR1cm4geyBfX3R5cGU6IFwiZGF0ZVwiLCB2YWx1ZTogU3RyaW5nKHRoaXNba2V5XSkgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGRlY29kZVR5cGVzKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoaXNPYmplY3QodGhpc1trZXldKSAmJiBcIl9fdHlwZVwiIGluIHRoaXNba2V5XSAmJiB0aGlzW2tleV0uX190eXBlID09PSBcImRhdGVcIikge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaXNba2V5XS52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvYXBpL3N0YXRlL3N0YXRlTWFuYWdlci50c1xudmFyIFN0YXRlTWFuYWdlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jYXJldGFrZXIgPSBuZXcgTWVtZW50b0NhcmV0YWtlcihWRVJTSU9OKTtcbiAgICB0aGlzLnN0YXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBzZXRTdGF0ZShvcmlnaW5hdG9yLCB2YWx1ZSkge1xuICAgIGlmIChqc29uRGlmZih0aGlzLnN0YXRlLmdldChvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5KSwgdmFsdWUpID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5zZXQob3JpZ2luYXRvci5tZW1lbnRvT3JpZ2luYXRvcktleSwgdmFsdWUpO1xuICAgIHRoaXMucmVzdG9yZVN0YXRlKG9yaWdpbmF0b3IpO1xuICB9XG4gIHJlc3RvcmVTdGF0ZShvcmlnaW5hdG9yKSB7XG4gICAgY29uc3QgeyBjYXJldGFrZXIsIHN0YXRlIH0gPSB0aGlzO1xuICAgIGlmICghc3RhdGUuaGFzKG9yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXkpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHZhbHVlID0gc3RhdGUuZ2V0KG9yaWdpbmF0b3IubWVtZW50b09yaWdpbmF0b3JLZXkpO1xuICAgIGNhcmV0YWtlci5yZXN0b3JlKHsgdmVyc2lvbjogY2FyZXRha2VyLnZlcnNpb24sIFtvcmlnaW5hdG9yLm1lbWVudG9PcmlnaW5hdG9yS2V5XTogdmFsdWUgfSwgb3JpZ2luYXRvcik7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdXNlckFnZW50LnRzXG5mdW5jdGlvbiBoYXNDb25zdHJhaW5lZENhbnZhc01lbW9yeSgpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgaVBob25lT1NNYXRjaCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL1xcKGlQaG9uZTsgQ1BVIGlQaG9uZSBPUyAoXFxkK19cXGQrX1xcZCspIGxpa2UgTWFjIE9TIFhcXCkvKTtcbiAgaWYgKGlQaG9uZU9TTWF0Y2ggPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBbbWFqb3IsIG1pbm9yXSA9IGlQaG9uZU9TTWF0Y2hbMV0uc3BsaXQoXCJfXCIpLm1hcChOdW1iZXIpO1xuICByZXR1cm4gbWFqb3IgPCAxNiB8fCBtYWpvciA9PT0gMTYgJiYgbWlub3IgPCA2O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9jYW52YXMvaGRwaUNhbnZhcy50c1xudmFyIF9IZHBpQ2FudmFzID0gY2xhc3MgX0hkcGlDYW52YXMge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLndpZHRoID0gNjAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gMzAwO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgcGl4ZWxSYXRpbywgY2FudmFzQ29uc3RydWN0b3IsIHdpbGxSZWFkRnJlcXVlbnRseSA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIHRoaXMucGl4ZWxSYXRpbyA9IGhhc0NvbnN0cmFpbmVkQ2FudmFzTWVtb3J5KCkgPyAxIDogcGl4ZWxSYXRpbyA/PyBnZXRXaW5kb3coXCJkZXZpY2VQaXhlbFJhdGlvXCIpO1xuICAgIHRoaXMuZWxlbWVudCA9IGNhbnZhc0NvbnN0cnVjdG9yPy4oKSA/PyBjcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9ICh3aWR0aCA/PyB0aGlzLndpZHRoKSArIFwicHhcIjtcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gKGhlaWdodCA/PyB0aGlzLmhlaWdodCkgKyBcInB4XCI7XG4gICAgdGhpcy5lbGVtZW50LndpZHRoID0gTWF0aC5yb3VuZCgod2lkdGggPz8gdGhpcy53aWR0aCkgKiB0aGlzLnBpeGVsUmF0aW8pO1xuICAgIHRoaXMuZWxlbWVudC5oZWlnaHQgPSBNYXRoLnJvdW5kKChoZWlnaHQgPz8gdGhpcy5oZWlnaHQpICogdGhpcy5waXhlbFJhdGlvKTtcbiAgICB0aGlzLmNvbnRleHQgPSB0aGlzLmVsZW1lbnQuZ2V0Q29udGV4dChcIjJkXCIsIHsgd2lsbFJlYWRGcmVxdWVudGx5IH0pO1xuICAgIHRoaXMub25FbmFibGVkQ2hhbmdlKCk7XG4gICAgdGhpcy5yZXNpemUod2lkdGggPz8gMCwgaGVpZ2h0ID8/IDApO1xuICAgIF9IZHBpQ2FudmFzLmRlYnVnQ29udGV4dCh0aGlzLmNvbnRleHQpO1xuICB9XG4gIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIF9IZHBpQ2FudmFzO1xuICB9XG4gIGRyYXdJbWFnZShjb250ZXh0LCBkeCA9IDAsIGR5ID0gMCkge1xuICAgIHJldHVybiBjb250ZXh0LmRyYXdJbWFnZSh0aGlzLmNvbnRleHQuY2FudmFzLCBkeCwgZHkpO1xuICB9XG4gIHRvRGF0YVVSTCh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC50b0RhdGFVUkwodHlwZSk7XG4gIH1cbiAgcmVzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoISh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBlbGVtZW50OiBlbGVtZW50MiwgY29udGV4dCwgcGl4ZWxSYXRpbyB9ID0gdGhpcztcbiAgICBlbGVtZW50Mi53aWR0aCA9IE1hdGgucm91bmQod2lkdGggKiBwaXhlbFJhdGlvKTtcbiAgICBlbGVtZW50Mi5oZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCAqIHBpeGVsUmF0aW8pO1xuICAgIGNvbnRleHQuc2V0VHJhbnNmb3JtKHBpeGVsUmF0aW8sIDAsIDAsIHBpeGVsUmF0aW8sIDAsIDApO1xuICAgIGVsZW1lbnQyLnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG4gICAgZWxlbWVudDIuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuICBzbmFwc2hvdCgpIHtcbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLmNvbnRleHQuc2F2ZSgpO1xuICAgIHRoaXMuY29udGV4dC5zZXRUcmFuc2Zvcm0odGhpcy5waXhlbFJhdGlvLCAwLCAwLCB0aGlzLnBpeGVsUmF0aW8sIDAsIDApO1xuICAgIHRoaXMuY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgIHRoaXMuY29udGV4dC5yZXN0b3JlKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlKCk7XG4gICAgdGhpcy5lbGVtZW50LndpZHRoID0gMDtcbiAgICB0aGlzLmVsZW1lbnQuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIDAsIDApO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gIH1cbiAgb25FbmFibGVkQ2hhbmdlKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gdGhpcy5lbmFibGVkID8gXCJcIiA6IFwibm9uZVwiO1xuICAgIH1cbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZHVuZGFudC10eXBlLWNvbnN0aXR1ZW50c1xuICBzdGF0aWMgZGVidWdDb250ZXh0KGN0eCkge1xuICAgIGlmIChEZWJ1Zy5jaGVjayhcImNhbnZhc1wiKSkge1xuICAgICAgY29uc3Qgc2F2ZSA9IGN0eC5zYXZlLmJpbmQoY3R4KTtcbiAgICAgIGNvbnN0IHJlc3RvcmUgPSBjdHgucmVzdG9yZS5iaW5kKGN0eCk7XG4gICAgICBsZXQgZGVwdGggPSAwO1xuICAgICAgT2JqZWN0LmFzc2lnbihjdHgsIHtcbiAgICAgICAgc2F2ZSgpIHtcbiAgICAgICAgICBzYXZlKCk7XG4gICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdG9yZSgpIHtcbiAgICAgICAgICBpZiAoZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIFVuYWJsZSB0byByZXN0b3JlKCkgcGFzdCBkZXB0aCAwXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN0b3JlKCk7XG4gICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgfSxcbiAgICAgICAgdmVyaWZ5RGVwdGhaZXJvKCkge1xuICAgICAgICAgIGlmIChkZXB0aCAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBTYXZlL3Jlc3RvcmUgZGVwdGggaXMgbm9uLXplcm86ICR7ZGVwdGh9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB0YXJnZXQub25FbmFibGVkQ2hhbmdlKCkpXG5dLCBfSGRwaUNhbnZhcy5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbnZhciBIZHBpQ2FudmFzID0gX0hkcGlDYW52YXM7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL2xheWVyc01hbmFnZXIudHNcbnZhciBMYXllcnNNYW5hZ2VyID0gY2xhc3MgX0xheWVyc01hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihjYW52YXMsIG1hcmtEaXJ0eSkge1xuICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMubWFya0RpcnR5ID0gbWFya0RpcnR5O1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJzY2VuZVwiKTtcbiAgICB0aGlzLmxheWVyc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5uZXh0WkluZGV4ID0gMDtcbiAgICB0aGlzLm5leHRMYXllcklkID0gMDtcbiAgfVxuICBzdGF0aWMgc29ydExheWVycyhhLCBiKSB7XG4gICAgcmV0dXJuIGNvbXBvdW5kQXNjZW5kaW5nKFxuICAgICAgW2EuekluZGV4LCAuLi5hLnpJbmRleFN1Yk9yZGVyID8/IFt2b2lkIDAsIHZvaWQgMF0sIGEuaWRdLFxuICAgICAgW2IuekluZGV4LCAuLi5iLnpJbmRleFN1Yk9yZGVyID8/IFt2b2lkIDAsIHZvaWQgMF0sIGIuaWRdLFxuICAgICAgYXNjZW5kaW5nU3RyaW5nTnVtYmVyVW5kZWZpbmVkXG4gICAgKTtcbiAgfVxuICBnZXQgc2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXllcnNNYXAuc2l6ZTtcbiAgfVxuICBmb3JFYWNoKGNhbGxiYWNrMikge1xuICAgIEFycmF5LmZyb20odGhpcy5sYXllcnNNYXAudmFsdWVzKCkpLnNvcnQoX0xheWVyc01hbmFnZXIuc29ydExheWVycykuZm9yRWFjaChjYWxsYmFjazIpO1xuICB9XG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5jYW52YXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMubGF5ZXJzTWFwLmZvckVhY2goKHsgY2FudmFzIH0pID0+IGNhbnZhcy5yZXNpemUod2lkdGgsIGhlaWdodCkpO1xuICB9XG4gIGFkZExheWVyKG9wdHMpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHBpeGVsUmF0aW8gfSA9IHRoaXMuY2FudmFzO1xuICAgIGNvbnN0IHsgekluZGV4ID0gdGhpcy5uZXh0WkluZGV4KyssIG5hbWUsIHpJbmRleFN1Yk9yZGVyLCBnZXRDb21wdXRlZE9wYWNpdHksIGdldFZpc2liaWxpdHkgfSA9IG9wdHM7XG4gICAgY29uc3QgY2FudmFzID0gbmV3IEhkcGlDYW52YXMoeyB3aWR0aCwgaGVpZ2h0LCBwaXhlbFJhdGlvIH0pO1xuICAgIGNvbnN0IG5ld0xheWVyID0ge1xuICAgICAgaWQ6IHRoaXMubmV4dExheWVySWQrKyxcbiAgICAgIG5hbWUsXG4gICAgICBjYW52YXMsXG4gICAgICB6SW5kZXgsXG4gICAgICB6SW5kZXhTdWJPcmRlcixcbiAgICAgIGdldENvbXB1dGVkT3BhY2l0eSxcbiAgICAgIGdldFZpc2liaWxpdHlcbiAgICB9O1xuICAgIGlmICh6SW5kZXggPj0gdGhpcy5uZXh0WkluZGV4KSB7XG4gICAgICB0aGlzLm5leHRaSW5kZXggPSB6SW5kZXggKyAxO1xuICAgIH1cbiAgICB0aGlzLmxheWVyc01hcC5zZXQoY2FudmFzLCBuZXdMYXllcik7XG4gICAgdGhpcy5kZWJ1ZyhcIlNjZW5lLmFkZExheWVyKCkgLSBsYXllcnNcIiwgdGhpcy5sYXllcnNNYXApO1xuICAgIHJldHVybiBuZXdMYXllci5jYW52YXM7XG4gIH1cbiAgcmVtb3ZlTGF5ZXIoY2FudmFzKSB7XG4gICAgaWYgKHRoaXMubGF5ZXJzTWFwLmhhcyhjYW52YXMpKSB7XG4gICAgICB0aGlzLmxheWVyc01hcC5kZWxldGUoY2FudmFzKTtcbiAgICAgIGNhbnZhcy5kZXN0cm95KCk7XG4gICAgICB0aGlzLm1hcmtEaXJ0eSgpO1xuICAgICAgdGhpcy5kZWJ1ZyhcIlNjZW5lLnJlbW92ZUxheWVyKCkgLSAgbGF5ZXJzXCIsIHRoaXMubGF5ZXJzTWFwKTtcbiAgICB9XG4gIH1cbiAgbW92ZUxheWVyKGNhbnZhcywgbmV3WkluZGV4LCBuZXdaSW5kZXhTdWJPcmRlcikge1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5sYXllcnNNYXAuZ2V0KGNhbnZhcyk7XG4gICAgaWYgKGxheWVyKSB7XG4gICAgICBsYXllci56SW5kZXggPSBuZXdaSW5kZXg7XG4gICAgICBsYXllci56SW5kZXhTdWJPcmRlciA9IG5ld1pJbmRleFN1Yk9yZGVyO1xuICAgICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICAgIHRoaXMuZGVidWcoXCJTY2VuZS5tb3ZlTGF5ZXIoKSAtICBsYXllcnNcIiwgdGhpcy5sYXllcnNNYXApO1xuICAgIH1cbiAgfVxuICBjbGVhcigpIHtcbiAgICB0aGlzLmxheWVyc01hcC5jbGVhcigpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zY2VuZURlYnVnLnRzXG5mdW5jdGlvbiBkZWJ1Z1N0YXRzKGxheWVyc01hbmFnZXIsIGRlYnVnU3BsaXRUaW1lcywgY3R4LCByZW5kZXJDdHhTdGF0cywgZXh0cmFEZWJ1Z1N0YXRzID0ge30sIHNlcmllc1JlY3QgPSBCQm94Lnplcm8pIHtcbiAgaWYgKCFEZWJ1Zy5jaGVjayhcInNjZW5lOnN0YXRzXCIgLyogU0NFTkVfU1RBVFMgKi8sIFwic2NlbmU6c3RhdHM6dmVyYm9zZVwiIC8qIFNDRU5FX1NUQVRTX1ZFUkJPU0UgKi8pKVxuICAgIHJldHVybjtcbiAgY29uc3QgeyBsYXllcnNSZW5kZXJlZCA9IDAsIGxheWVyc1NraXBwZWQgPSAwLCBub2Rlc1JlbmRlcmVkID0gMCwgbm9kZXNTa2lwcGVkID0gMCB9ID0gcmVuZGVyQ3R4U3RhdHMgPz8ge307XG4gIGNvbnN0IGVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICBjb25zdCB7IHN0YXJ0LCAuLi5kdXJhdGlvbnMgfSA9IGRlYnVnU3BsaXRUaW1lcztcbiAgY29uc3Qgc3BsaXRzID0gT2JqZWN0LmVudHJpZXMoZHVyYXRpb25zKS5tYXAoKFtuLCB0XSkgPT4ge1xuICAgIHJldHVybiB0aW1lKG4sIHQpO1xuICB9KS5maWx0ZXIoKHYpID0+IHYgIT0gbnVsbCkuam9pbihcIiArIFwiKTtcbiAgY29uc3QgZXh0cmFzID0gT2JqZWN0LmVudHJpZXMoZXh0cmFEZWJ1Z1N0YXRzKS5tYXAoKFtrLCB2XSkgPT4gYCR7a306ICR7dn1gKS5qb2luKFwiIDsgXCIpO1xuICBjb25zdCBkZXRhaWxlZFN0YXRzID0gRGVidWcuY2hlY2soXCJzY2VuZTpzdGF0czp2ZXJib3NlXCIgLyogU0NFTkVfU1RBVFNfVkVSQk9TRSAqLyk7XG4gIGNvbnN0IHN0YXRzID0gW1xuICAgIGAke3RpbWUoXCJcXHUyM0YxXFx1RkUwRlwiLCBzdGFydCwgZW5kKX0gKCR7c3BsaXRzfSlgLFxuICAgIGAke2V4dHJhc31gLFxuICAgIGBMYXllcnM6ICR7ZGV0YWlsZWRTdGF0cyA/IHBjdChsYXllcnNSZW5kZXJlZCwgbGF5ZXJzU2tpcHBlZCkgOiBsYXllcnNNYW5hZ2VyLnNpemV9YCxcbiAgICBkZXRhaWxlZFN0YXRzID8gYE5vZGVzOiAke3BjdChub2Rlc1JlbmRlcmVkLCBub2Rlc1NraXBwZWQpfWAgOiBudWxsXG4gIF0uZmlsdGVyKGlzU3RyaW5nKTtcbiAgY29uc3QgbWVhc3VyZXIgPSBuZXcgU2ltcGxlVGV4dE1lYXN1cmVyKCh0KSA9PiBjdHgubWVhc3VyZVRleHQodCkpO1xuICBjb25zdCBzdGF0c1NpemUgPSBuZXcgTWFwKHN0YXRzLm1hcCgodCkgPT4gW3QsIG1lYXN1cmVyLm1lYXN1cmVMaW5lcyh0KV0pKTtcbiAgY29uc3Qgd2lkdGggPSBNYXRoLm1heCguLi5BcnJheS5mcm9tKHN0YXRzU2l6ZS52YWx1ZXMoKSwgKHMpID0+IHMud2lkdGgpKTtcbiAgY29uc3QgaGVpZ2h0ID0gYWNjdW11bGF0ZShzdGF0c1NpemUudmFsdWVzKCksIChzKSA9PiBzLmhlaWdodCk7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XG4gIGN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgY3R4LmZpbGxTdHlsZSA9IFwiYmxhY2tcIjtcbiAgbGV0IHkgPSAwO1xuICBmb3IgKGNvbnN0IFtzdGF0LCBzaXplXSBvZiBzdGF0c1NpemUuZW50cmllcygpKSB7XG4gICAgeSArPSBzaXplLmhlaWdodDtcbiAgICBjdHguZmlsbFRleHQoc3RhdCwgMiArIHNlcmllc1JlY3QueCwgeSk7XG4gIH1cbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGRlYnVnU2NlbmVOb2RlSGlnaGxpZ2h0KGN0eCwgZGVidWdOb2Rlcykge1xuICBjdHguc2F2ZSgpO1xuICBmb3IgKGNvbnN0IFtuYW1lLCBub2RlXSBvZiBPYmplY3QuZW50cmllcyhkZWJ1Z05vZGVzKSkge1xuICAgIGNvbnN0IGJib3ggPSBub2RlLmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKTtcbiAgICBpZiAoIWJib3gpIHtcbiAgICAgIExvZ2dlci5sb2coYFNjZW5lLnJlbmRlcigpIC0gbm8gYmJveCBmb3IgZGVidWdnZWQgbm9kZSBbJHtuYW1lfV0uYCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gMC44O1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IFwicmVkXCI7XG4gICAgY3R4LmxpbmVXaWR0aCA9IDE7XG4gICAgY3R4LnN0cm9rZVJlY3QoYmJveC54LCBiYm94LnksIGJib3gud2lkdGgsIGJib3guaGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gXCJyZWRcIjtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgY3R4LmZvbnQgPSBcIjE2cHggc2Fucy1zZXJpZlwiO1xuICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBcInRvcFwiO1xuICAgIGN0eC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICBjdHguc3Ryb2tlVGV4dChuYW1lLCBiYm94LngsIGJib3gueSwgYmJveC53aWR0aCk7XG4gICAgY3R4LmZpbGxUZXh0KG5hbWUsIGJib3gueCwgYmJveC55LCBiYm94LndpZHRoKTtcbiAgfVxuICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gYnVpbGRUcmVlKG5vZGUpIHtcbiAgaWYgKCFEZWJ1Zy5jaGVjayh0cnVlLCBcInNjZW5lXCIgLyogU0NFTkUgKi8pKVxuICAgIHJldHVybiB7fTtcbiAgcmV0dXJuIHtcbiAgICBub2RlLFxuICAgIG5hbWU6IG5vZGUubmFtZSA/PyBub2RlLmlkLFxuICAgIGRpcnR5OiBSZWRyYXdUeXBlW25vZGUuZGlydHldLFxuICAgIC4uLm5vZGUucGFyZW50Py5pc1ZpcnR1YWwgPyB7XG4gICAgICB2aXJ0dWFsUGFyZW50RGlydHk6IFJlZHJhd1R5cGVbbm9kZS5wYXJlbnQuZGlydHldLFxuICAgICAgdmlydHVhbFBhcmVudDogbm9kZS5wYXJlbnRcbiAgICB9IDoge30sXG4gICAgLi4ubm9kZS5jaGlsZHJlbi5tYXAoKGMpID0+IGJ1aWxkVHJlZShjKSkucmVkdWNlKChyZXN1bHQsIGNoaWxkVHJlZSkgPT4ge1xuICAgICAgbGV0IHsgbmFtZTogdHJlZU5vZGVOYW1lIH0gPSBjaGlsZFRyZWU7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5vZGU6IHtcbiAgICAgICAgICB2aXNpYmxlLFxuICAgICAgICAgIG9wYWNpdHksXG4gICAgICAgICAgekluZGV4LFxuICAgICAgICAgIHpJbmRleFN1Yk9yZGVyLFxuICAgICAgICAgIHRyYW5zbGF0aW9uWCxcbiAgICAgICAgICB0cmFuc2xhdGlvblksXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgc2NhbGluZ1gsXG4gICAgICAgICAgc2NhbGluZ1lcbiAgICAgICAgfSxcbiAgICAgICAgbm9kZTogY2hpbGROb2RlLFxuICAgICAgICB2aXJ0dWFsUGFyZW50XG4gICAgICB9ID0gY2hpbGRUcmVlO1xuICAgICAgaWYgKCF2aXNpYmxlIHx8IG9wYWNpdHkgPD0gMCkge1xuICAgICAgICB0cmVlTm9kZU5hbWUgPSBgKCR7dHJlZU5vZGVOYW1lfSlgO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkTm9kZSBpbnN0YW5jZW9mIEdyb3VwICYmIGNoaWxkTm9kZS5pc0xheWVyKCkpIHtcbiAgICAgICAgdHJlZU5vZGVOYW1lID0gYCoke3RyZWVOb2RlTmFtZX0qYDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleSA9IFtcbiAgICAgICAgYCR7dHJlZU5vZGVOYW1lID8/IFwiPHVua25vd24+XCJ9YCxcbiAgICAgICAgYHo6ICR7ekluZGV4fWAsXG4gICAgICAgIHpJbmRleFN1Yk9yZGVyICYmIGB6bzogJHt6SW5kZXhTdWJPcmRlci5tYXAoKHYpID0+IHR5cGVvZiB2ID09PSBcImZ1bmN0aW9uXCIgPyBgJHt2KCl9IChmbilgIDogdikuam9pbihcIiAvIFwiKX1gLFxuICAgICAgICB2aXJ0dWFsUGFyZW50ICYmIGAodmlydHVhbCBwYXJlbnQpYCxcbiAgICAgICAgdHJhbnNsYXRpb25YICYmIGB4OiAke3RyYW5zbGF0aW9uWH1gLFxuICAgICAgICB0cmFuc2xhdGlvblkgJiYgYHk6ICR7dHJhbnNsYXRpb25ZfWAsXG4gICAgICAgIHJvdGF0aW9uICYmIGByOiAke3JvdGF0aW9ufWAsXG4gICAgICAgIHNjYWxpbmdYICE9PSAxICYmIGBzeDogJHtzY2FsaW5nWH1gLFxuICAgICAgICBzY2FsaW5nWSAhPT0gMSAmJiBgc3k6ICR7c2NhbGluZ1l9YFxuICAgICAgXS5maWx0ZXIoKHYpID0+ICEhdikuam9pbihcIiBcIik7XG4gICAgICBsZXQgc2VsZWN0ZWRLZXkgPSBrZXk7XG4gICAgICBsZXQgaW5kZXggPSAxO1xuICAgICAgd2hpbGUgKHJlc3VsdFtzZWxlY3RlZEtleV0gIT0gbnVsbCAmJiBpbmRleCA8IDEwMCkge1xuICAgICAgICBzZWxlY3RlZEtleSA9IGAke2tleX0gKCR7aW5kZXgrK30pYDtcbiAgICAgIH1cbiAgICAgIHJlc3VsdFtzZWxlY3RlZEtleV0gPSBjaGlsZFRyZWU7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sIHt9KVxuICB9O1xufVxuZnVuY3Rpb24gYnVpbGREaXJ0eVRyZWUobm9kZSkge1xuICBpZiAobm9kZS5kaXJ0eSA9PT0gMCAvKiBOT05FICovKSB7XG4gICAgcmV0dXJuIHsgZGlydHlUcmVlOiB7fSwgcGF0aHM6IFtdIH07XG4gIH1cbiAgY29uc3QgY2hpbGRyZW5EaXJ0eVRyZWUgPSBub2RlLmNoaWxkcmVuLm1hcCgoYykgPT4gYnVpbGREaXJ0eVRyZWUoYykpLmZpbHRlcigoYykgPT4gYy5wYXRocy5sZW5ndGggPiAwKTtcbiAgY29uc3QgbmFtZSA9IEdyb3VwLmlzKG5vZGUpID8gbm9kZS5uYW1lID8/IG5vZGUuaWQgOiBub2RlLmlkO1xuICBjb25zdCBwYXRocyA9IGNoaWxkcmVuRGlydHlUcmVlLmxlbmd0aCA/IGNoaWxkcmVuRGlydHlUcmVlLmZsYXRNYXAoKGMpID0+IGMucGF0aHMpLm1hcCgocCkgPT4gYCR7bmFtZX0uJHtwfWApIDogW25hbWVdO1xuICByZXR1cm4ge1xuICAgIGRpcnR5VHJlZToge1xuICAgICAgbmFtZSxcbiAgICAgIG5vZGUsXG4gICAgICBkaXJ0eTogUmVkcmF3VHlwZVtub2RlLmRpcnR5XSxcbiAgICAgIC4uLmNoaWxkcmVuRGlydHlUcmVlLm1hcCgoYykgPT4gYy5kaXJ0eVRyZWUpLmZpbHRlcigodCkgPT4gdC5kaXJ0eSAhPSBudWxsKS5yZWR1Y2UoKHJlc3VsdCwgY2hpbGRUcmVlKSA9PiB7XG4gICAgICAgIHJlc3VsdFtjaGlsZFRyZWUubmFtZSA/PyBcIjx1bmtub3duPlwiXSA9IGNoaWxkVHJlZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sIHt9KVxuICAgIH0sXG4gICAgcGF0aHNcbiAgfTtcbn1cbmZ1bmN0aW9uIHBjdChyZW5kZXJlZCwgc2tpcHBlZCkge1xuICBjb25zdCB0b3RhbCA9IHJlbmRlcmVkICsgc2tpcHBlZDtcbiAgcmV0dXJuIGAke3JlbmRlcmVkfSAvICR7dG90YWx9ICgke01hdGgucm91bmQoMTAwICogcmVuZGVyZWQgLyB0b3RhbCl9JSlgO1xufVxuZnVuY3Rpb24gdGltZShuYW1lLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGR1cmF0aW9uID0gZW5kICE9IG51bGwgPyBlbmQgLSBzdGFydCA6IHN0YXJ0O1xuICByZXR1cm4gYCR7bmFtZX06ICR7TWF0aC5yb3VuZChkdXJhdGlvbiAqIDEwMCkgLyAxMDB9bXNgO1xufVxuZnVuY3Rpb24gYWNjdW11bGF0ZShpdGVyYXRvciwgbWFwcGVyKSB7XG4gIGxldCBzdW0yID0gMDtcbiAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZXJhdG9yKSB7XG4gICAgc3VtMiArPSBtYXBwZXIoaXRlbSk7XG4gIH1cbiAgcmV0dXJuIHN1bTI7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NjZW5lLnRzXG52YXIgU2NlbmUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHsgd2lkdGgsIGhlaWdodCwgcGl4ZWxSYXRpbywgZG9tTWFuYWdlciB9KSB7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcInNjZW5lXCIgLyogU0NFTkUgKi8pO1xuICAgIHRoaXMuaWQgPSBjcmVhdGVJZCh0aGlzKTtcbiAgICB0aGlzLnJvb3QgPSBudWxsO1xuICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICAgIHRoaXMuZG9tTWFuYWdlciA9IGRvbU1hbmFnZXI7XG4gICAgY29uc3QgY2FudmFzT3B0cyA9IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgcGl4ZWxSYXRpb1xuICAgIH07XG4gICAgaWYgKGRvbU1hbmFnZXIpIHtcbiAgICAgIGNhbnZhc09wdHMuY2FudmFzQ29uc3RydWN0b3IgPSAoKSA9PiBkb21NYW5hZ2VyLmFkZENoaWxkKFwiY2FudmFzXCIsIFwic2NlbmUtY2FudmFzXCIpO1xuICAgIH1cbiAgICB0aGlzLmNhbnZhcyA9IG5ldyBIZHBpQ2FudmFzKGNhbnZhc09wdHMpO1xuICAgIHRoaXMubGF5ZXJzTWFuYWdlciA9IG5ldyBMYXllcnNNYW5hZ2VyKHRoaXMuY2FudmFzLCAoKSA9PiB7XG4gICAgICB0aGlzLmlzRGlydHkgPSB0cnVlO1xuICAgIH0pO1xuICB9XG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5wZW5kaW5nU2l6ZT8uWzBdID8/IHRoaXMuY2FudmFzLndpZHRoO1xuICB9XG4gIGdldCBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGVuZGluZ1NpemU/LlsxXSA/PyB0aGlzLmNhbnZhcy5oZWlnaHQ7XG4gIH1cbiAgc2V0Q29udGFpbmVyKHZhbHVlKSB7XG4gICAgY29uc3QgaXNFbGVtZW50ID0gKHYpID0+IHtcbiAgICAgIHJldHVybiB0eXBlb2Ygdi50YWdOYW1lICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIH07XG4gICAgaWYgKGlzRWxlbWVudCh2YWx1ZSkpIHtcbiAgICAgIGNvbnN0IHsgZWxlbWVudDogZWxlbWVudDIgfSA9IHRoaXMuY2FudmFzO1xuICAgICAgZWxlbWVudDIucGFyZW50RWxlbWVudD8ucmVtb3ZlQ2hpbGQoZWxlbWVudDIpO1xuICAgICAgdmFsdWUuYXBwZW5kQ2hpbGQoZWxlbWVudDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvbU1hbmFnZXIgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZG9tTWFuYWdlci5hZGRDaGlsZChcImNhbnZhc1wiLCBcInNjZW5lLWNhbnZhc1wiLCB0aGlzLmNhbnZhcy5lbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc2V0Um9vdChub2RlKSB7XG4gICAgaWYgKHRoaXMucm9vdCA9PT0gbm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5yb290Py5fc2V0TGF5ZXJNYW5hZ2VyKCk7XG4gICAgdGhpcy5yb290ID0gbm9kZTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIG5vZGUuX3NldExheWVyTWFuYWdlcih0aGlzLmxheWVyc01hbmFnZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBhdHRhY2hOb2RlKG5vZGUsIHJvb3RHcm91cE5hbWUpIHtcbiAgICBpZiAoIXJvb3RHcm91cE5hbWUpIHtcbiAgICAgIHRoaXMucm9vdD8uYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICByZXR1cm4gKCkgPT4gdGhpcy5yZW1vdmVDaGlsZChub2RlKTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50R3JvdXAgPSB0aGlzLnJvb3Q/LmNoaWxkcmVuLmZpbmQoKGcpID0+IGcgaW5zdGFuY2VvZiBHcm91cCAmJiBnLm5hbWUgPT09IHJvb3RHcm91cE5hbWUpO1xuICAgIGlmICghcGFyZW50R3JvdXApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSBVbnJlY29nbml6ZWQgcm9vdCBncm91cCBuYW1lOiBcIiArIHJvb3RHcm91cE5hbWUpO1xuICAgIHBhcmVudEdyb3VwLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIHJldHVybiAoKSA9PiBwYXJlbnRHcm91cC5yZW1vdmVDaGlsZChub2RlKTtcbiAgfVxuICBhcHBlbmRDaGlsZChub2RlKSB7XG4gICAgdGhpcy5yb290Py5hcHBlbmRDaGlsZChub2RlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByZW1vdmVDaGlsZChub2RlKSB7XG4gICAgdGhpcy5yb290Py5yZW1vdmVDaGlsZChub2RlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkb3dubG9hZChmaWxlTmFtZSwgZmlsZUZvcm1hdCkge1xuICAgIGRvd25sb2FkVXJsKHRoaXMuY2FudmFzLnRvRGF0YVVSTChmaWxlRm9ybWF0KSwgZmlsZU5hbWU/LnRyaW0oKSA/PyBcImltYWdlXCIpO1xuICB9XG4gIC8qKiBOT1RFOiBJbnRlZ3JhdGVkIENoYXJ0cyB1bmRvY3VtZW50ZWQgaW1hZ2UgZG93bmxvYWQgbWV0aG9kLiAqL1xuICBnZXREYXRhVVJMKGZpbGVGb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5jYW52YXMudG9EYXRhVVJMKGZpbGVGb3JtYXQpO1xuICB9XG4gIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgd2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoKTtcbiAgICBoZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCk7XG4gICAgaWYgKHdpZHRoID4gMCAmJiBoZWlnaHQgPiAwICYmICh3aWR0aCAhPT0gdGhpcy53aWR0aCB8fCBoZWlnaHQgIT09IHRoaXMuaGVpZ2h0KSkge1xuICAgICAgdGhpcy5wZW5kaW5nU2l6ZSA9IFt3aWR0aCwgaGVpZ2h0XTtcbiAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFzeW5jIHJlbmRlcihvcHRzKSB7XG4gICAgY29uc3QgeyBkZWJ1Z1NwbGl0VGltZXMgPSB7IHN0YXJ0OiBwZXJmb3JtYW5jZS5ub3coKSB9LCBleHRyYURlYnVnU3RhdHMsIHNlcmllc1JlY3QgfSA9IG9wdHMgPz8ge307XG4gICAgY29uc3QgeyBjYW52YXMsIGNhbnZhczogeyBjb250ZXh0OiBjdHggfSA9IHt9LCByb290LCBwZW5kaW5nU2l6ZSB9ID0gdGhpcztcbiAgICBpZiAoIWN0eCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByZW5kZXJTdGFydFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAocGVuZGluZ1NpemUpIHtcbiAgICAgIHRoaXMubGF5ZXJzTWFuYWdlci5yZXNpemUoLi4ucGVuZGluZ1NpemUpO1xuICAgICAgdGhpcy5wZW5kaW5nU2l6ZSA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHJvb3QgJiYgIXJvb3QudmlzaWJsZSkge1xuICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyb290ICYmICF0aGlzLmlzRGlydHkpIHtcbiAgICAgIGlmICh0aGlzLmRlYnVnLmNoZWNrKCkpIHtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcIlNjZW5lLnJlbmRlcigpIC0gbm8tb3BcIiwge1xuICAgICAgICAgIHJlZHJhd1R5cGU6IFJlZHJhd1R5cGVbcm9vdC5kaXJ0eV0sXG4gICAgICAgICAgdHJlZTogYnVpbGRUcmVlKHJvb3QpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGVidWdTdGF0cyh0aGlzLmxheWVyc01hbmFnZXIsIGRlYnVnU3BsaXRUaW1lcywgY3R4LCB2b2lkIDAsIGV4dHJhRGVidWdTdGF0cywgc2VyaWVzUmVjdCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlbmRlckN0eCA9IHtcbiAgICAgIGN0eCxcbiAgICAgIGRldmljZVBpeGVsUmF0aW86IHRoaXMuY2FudmFzLnBpeGVsUmF0aW8gPz8gMSxcbiAgICAgIGZvcmNlUmVuZGVyOiB0cnVlLFxuICAgICAgcmVzaXplZDogQm9vbGVhbihwZW5kaW5nU2l6ZSksXG4gICAgICBkZWJ1Z05vZGVzOiB7fVxuICAgIH07XG4gICAgaWYgKERlYnVnLmNoZWNrKFwic2NlbmU6c3RhdHM6dmVyYm9zZVwiIC8qIFNDRU5FX1NUQVRTX1ZFUkJPU0UgKi8pKSB7XG4gICAgICByZW5kZXJDdHguc3RhdHMgPSB7IGxheWVyc1JlbmRlcmVkOiAwLCBsYXllcnNTa2lwcGVkOiAwLCBub2Rlc1JlbmRlcmVkOiAwLCBub2Rlc1NraXBwZWQ6IDAgfTtcbiAgICB9XG4gICAgbGV0IGNhbnZhc0NsZWFyZWQgPSBmYWxzZTtcbiAgICBpZiAoIXJvb3QgfHwgcm9vdC5kaXJ0eSA+PSAxIC8qIFRSSVZJQUwgKi8pIHtcbiAgICAgIGNhbnZhc0NsZWFyZWQgPSB0cnVlO1xuICAgICAgY2FudmFzLmNsZWFyKCk7XG4gICAgfVxuICAgIGlmIChyb290ICYmIERlYnVnLmNoZWNrKFwic2NlbmU6ZGlydHlUcmVlXCIgLyogU0NFTkVfRElSVFlfVFJFRSAqLykpIHtcbiAgICAgIGNvbnN0IHsgZGlydHlUcmVlLCBwYXRocyB9ID0gYnVpbGREaXJ0eVRyZWUocm9vdCk7XG4gICAgICBEZWJ1Zy5jcmVhdGUoXCJzY2VuZTpkaXJ0eVRyZWVcIiAvKiBTQ0VORV9ESVJUWV9UUkVFICovKShcIlNjZW5lLnJlbmRlcigpIC0gZGlydHlUcmVlXCIsIHsgZGlydHlUcmVlLCBwYXRocyB9KTtcbiAgICB9XG4gICAgaWYgKHJvb3QgJiYgY2FudmFzQ2xlYXJlZCkge1xuICAgICAgdGhpcy5kZWJ1ZyhcIlNjZW5lLnJlbmRlcigpIC0gYmVmb3JlXCIsIHtcbiAgICAgICAgcmVkcmF3VHlwZTogUmVkcmF3VHlwZVtyb290LmRpcnR5XSxcbiAgICAgICAgY2FudmFzQ2xlYXJlZCxcbiAgICAgICAgdHJlZTogYnVpbGRUcmVlKHJvb3QpXG4gICAgICB9KTtcbiAgICAgIGlmIChyb290LnZpc2libGUpIHtcbiAgICAgICAgcm9vdC5wcmVSZW5kZXIoKTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgcm9vdC5yZW5kZXIocmVuZGVyQ3R4KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVidWdTcGxpdFRpbWVzW1wiXFx1MjcwRFxcdUZFMEZcIl0gPSBwZXJmb3JtYW5jZS5ub3coKSAtIHJlbmRlclN0YXJ0VGltZTtcbiAgICBpZiAodGhpcy5sYXllcnNNYW5hZ2VyLnNpemUgJiYgY2FudmFzQ2xlYXJlZCkge1xuICAgICAgY29uc3QgbGF5ZXJSZW5kZXJTdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5yZXNldFRyYW5zZm9ybSgpO1xuICAgICAgdGhpcy5sYXllcnNNYW5hZ2VyLmZvckVhY2goKGxheWVyKSA9PiB7XG4gICAgICAgIGlmIChsYXllci5jYW52YXMuZW5hYmxlZCAmJiBsYXllci5nZXRWaXNpYmlsaXR5KCkpIHtcbiAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBsYXllci5nZXRDb21wdXRlZE9wYWNpdHkoKTtcbiAgICAgICAgICBsYXllci5jYW52YXMuZHJhd0ltYWdlKGN0eCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIGRlYnVnU3BsaXRUaW1lc1tcIlxcdTI2RDlcIl0gPSBwZXJmb3JtYW5jZS5ub3coKSAtIGxheWVyUmVuZGVyU3RhcnQ7XG4gICAgfVxuICAgIGN0eC52ZXJpZnlEZXB0aFplcm8/LigpO1xuICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICAgIGRlYnVnU3RhdHModGhpcy5sYXllcnNNYW5hZ2VyLCBkZWJ1Z1NwbGl0VGltZXMsIGN0eCwgcmVuZGVyQ3R4LnN0YXRzLCBleHRyYURlYnVnU3RhdHMsIHNlcmllc1JlY3QpO1xuICAgIGRlYnVnU2NlbmVOb2RlSGlnaGxpZ2h0KGN0eCwgcmVuZGVyQ3R4LmRlYnVnTm9kZXMpO1xuICAgIGlmIChyb290ICYmIHRoaXMuZGVidWcuY2hlY2soKSkge1xuICAgICAgdGhpcy5kZWJ1ZyhcIlNjZW5lLnJlbmRlcigpIC0gYWZ0ZXJcIiwge1xuICAgICAgICByZWRyYXdUeXBlOiBSZWRyYXdUeXBlW3Jvb3QuZGlydHldLFxuICAgICAgICB0cmVlOiBidWlsZFRyZWUocm9vdCksXG4gICAgICAgIGNhbnZhc0NsZWFyZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKiogQWx0ZXJuYXRpdmUgdG8gZGVzdHJveSgpIHRoYXQgcHJlc2VydmVzIHJlLXVzYWJsZSByZXNvdXJjZXMuICovXG4gIHN0cmlwKCkge1xuICAgIGNvbnN0IHsgY29udGV4dCwgcGl4ZWxSYXRpbyB9ID0gdGhpcy5jYW52YXM7XG4gICAgY29udGV4dC5zZXRUcmFuc2Zvcm0ocGl4ZWxSYXRpbywgMCwgMCwgcGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgdGhpcy5sYXllcnNNYW5hZ2VyLmNsZWFyKCk7XG4gICAgdGhpcy5zZXRSb290KG51bGwpO1xuICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdHJpcCgpO1xuICAgIHRoaXMuY2FudmFzLmRlc3Ryb3koKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHsgY2FudmFzOiB2b2lkIDAgfSk7XG4gIH1cbn07XG5TY2VuZS5jbGFzc05hbWUgPSBcIlNjZW5lXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvY2FsbGJhY2tDYWNoZS50c1xudmFyIENhbGxiYWNrQ2FjaGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgfVxuICBjYWxsKGZuLCAuLi5wYXJhbXMpIHtcbiAgICBsZXQgc2VyaWFsaXNlZFBhcmFtcztcbiAgICBsZXQgcGFyYW1DYWNoZSA9IHRoaXMuY2FjaGUuZ2V0KGZuKTtcbiAgICB0cnkge1xuICAgICAgc2VyaWFsaXNlZFBhcmFtcyA9IEpTT04uc3RyaW5naWZ5KHBhcmFtcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRoaXMuaW52b2tlKGZuLCBwYXJhbXMsIHBhcmFtQ2FjaGUpO1xuICAgIH1cbiAgICBpZiAocGFyYW1DYWNoZSA9PSBudWxsKSB7XG4gICAgICBwYXJhbUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuY2FjaGUuc2V0KGZuLCBwYXJhbUNhY2hlKTtcbiAgICB9XG4gICAgaWYgKCFwYXJhbUNhY2hlLmhhcyhzZXJpYWxpc2VkUGFyYW1zKSkge1xuICAgICAgcmV0dXJuIHRoaXMuaW52b2tlKGZuLCBwYXJhbXMsIHBhcmFtQ2FjaGUsIHNlcmlhbGlzZWRQYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1DYWNoZS5nZXQoc2VyaWFsaXNlZFBhcmFtcyk7XG4gIH1cbiAgaW52b2tlKGZuLCBwYXJhbXMsIHBhcmFtQ2FjaGUsIHNlcmlhbGlzZWRQYXJhbXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzdWx0ID0gZm4oLi4ucGFyYW1zKTtcbiAgICAgIGlmIChwYXJhbUNhY2hlICYmIHNlcmlhbGlzZWRQYXJhbXMgIT0gbnVsbCkge1xuICAgICAgICBwYXJhbUNhY2hlLnNldChzZXJpYWxpc2VkUGFyYW1zLCByZXN1bHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoYFVzZXIgY2FsbGJhY2sgZXJyb3JlZCwgaWdub3JpbmdgLCBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaW52YWxpZGF0ZUNhY2hlKCkge1xuICAgIHRoaXMuY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9saXN0ZW5lcnMudHNcbnZhciBMaXN0ZW5lcnMgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgYWRkTGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgY29uc3QgcmVjb3JkID0geyBzeW1ib2w6IFN5bWJvbChldmVudFR5cGUpLCBoYW5kbGVyIH07XG4gICAgaWYgKHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycy5oYXMoZXZlbnRUeXBlKSkge1xuICAgICAgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzLmdldChldmVudFR5cGUpLnB1c2gocmVjb3JkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzLnNldChldmVudFR5cGUsIFtyZWNvcmRdKTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHRoaXMucmVtb3ZlTGlzdGVuZXIocmVjb3JkLnN5bWJvbCk7XG4gIH1cbiAgcmVtb3ZlTGlzdGVuZXIoZXZlbnRTeW1ib2wpIHtcbiAgICBmb3IgKGNvbnN0IFt0eXBlLCBsaXN0ZW5lcnNdIG9mIHRoaXMucmVnaXN0ZXJlZExpc3RlbmVycy5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IG1hdGNoSW5kZXggPSBsaXN0ZW5lcnMuZmluZEluZGV4KChsaXN0ZW5lcikgPT4gbGlzdGVuZXIuc3ltYm9sID09PSBldmVudFN5bWJvbCk7XG4gICAgICBpZiAobWF0Y2hJbmRleCA+PSAwKSB7XG4gICAgICAgIGxpc3RlbmVycy5zcGxpY2UobWF0Y2hJbmRleCwgMSk7XG4gICAgICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzLmRlbGV0ZSh0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGlzcGF0Y2goZXZlbnRUeXBlLCAuLi5wYXJhbXMpIHtcbiAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuZ2V0TGlzdGVuZXJzQnlUeXBlKGV2ZW50VHlwZSkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxpc3RlbmVyLmhhbmRsZXIoLi4ucGFyYW1zKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgTG9nZ2VyLmVycm9yT25jZShlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGlzcGF0Y2hXcmFwSGFuZGxlcnMoZXZlbnRUeXBlLCB3cmFwRm4sIC4uLnBhcmFtcykge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5nZXRMaXN0ZW5lcnNCeVR5cGUoZXZlbnRUeXBlKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgd3JhcEZuKGxpc3RlbmVyLmhhbmRsZXIsIC4uLnBhcmFtcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIExvZ2dlci5lcnJvck9uY2UoZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldExpc3RlbmVyc0J5VHlwZShldmVudFR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzLmdldChldmVudFR5cGUpID8/IFtdO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yZWdpc3RlcmVkTGlzdGVuZXJzLmNsZWFyKCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2Jhc2VNYW5hZ2VyLnRzXG52YXIgQmFzZU1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMubGlzdGVuZXJzID0gbmV3IExpc3RlbmVycygpO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICB9XG4gIGFkZExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMuYWRkTGlzdGVuZXIodHlwZSwgaGFuZGxlcik7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5kZXN0cm95KCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGZuKSA9PiBmbigpKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYW5ub3RhdGlvbi9hbm5vdGF0aW9uTWFuYWdlci50c1xudmFyIEFubm90YXRpb25NYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGFubm90YXRpb25Sb290KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmFubm90YXRpb25Sb290ID0gYW5ub3RhdGlvblJvb3Q7XG4gICAgdGhpcy5tZW1lbnRvT3JpZ2luYXRvcktleSA9IFwiYW5ub3RhdGlvbnNcIjtcbiAgICB0aGlzLmFubm90YXRpb25zID0gW107XG4gIH1cbiAgY3JlYXRlTWVtZW50bygpIHtcbiAgICByZXR1cm4gdGhpcy5hbm5vdGF0aW9ucztcbiAgfVxuICBndWFyZE1lbWVudG8oYmxvYikge1xuICAgIHJldHVybiBpc0FycmF5KGJsb2IpO1xuICB9XG4gIHJlc3RvcmVNZW1lbnRvKF92ZXJzaW9uLCBfbWVtZW50b1ZlcnNpb24sIG1lbWVudG8pIHtcbiAgICBjb25zdCBhbm5vdGF0aW9uczIgPSB0aGlzLmNsZWFuRGF0YShtZW1lbnRvKS5tYXAoKGFubm90YXRpb24pID0+IHtcbiAgICAgIGNvbnN0IGFubm90YXRpb25UaGVtZSA9IHRoaXMuZ2V0QW5ub3RhdGlvblR5cGVTdHlsZXMoYW5ub3RhdGlvbi50eXBlKTtcbiAgICAgIHJldHVybiBtZXJnZURlZmF1bHRzKGFubm90YXRpb24sIGFubm90YXRpb25UaGVtZSk7XG4gICAgfSk7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJyZXN0b3JlLWFubm90YXRpb25zXCIsIHtcbiAgICAgIHR5cGU6IFwicmVzdG9yZS1hbm5vdGF0aW9uc1wiLFxuICAgICAgYW5ub3RhdGlvbnM6IGFubm90YXRpb25zMlxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZURhdGEoYW5ub3RhdGlvbnMyKSB7XG4gICAgdGhpcy5hbm5vdGF0aW9ucyA9IHRoaXMuY2xlYW5EYXRhKGFubm90YXRpb25zMiA/PyBbXSk7XG4gIH1cbiAgYXR0YWNoTm9kZShub2RlKSB7XG4gICAgdGhpcy5hbm5vdGF0aW9uUm9vdC5hcHBlbmQobm9kZSk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblJvb3Q/LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfVxuICBzZXRBbm5vdGF0aW9uU3R5bGVzKHN0eWxlcykge1xuICAgIHRoaXMuc3R5bGVzID0gc3R5bGVzO1xuICB9XG4gIGdldEFubm90YXRpb25UeXBlU3R5bGVzKHR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5zdHlsZXM/Llt0eXBlXTtcbiAgfVxuICBjbGVhbkRhdGEoYW5ub3RhdGlvbnMyKSB7XG4gICAgZm9yIChjb25zdCBhbm5vdGF0aW9uIG9mIGFubm90YXRpb25zMikge1xuICAgICAgaWYgKFwidGV4dEFsaWduXCIgaW4gYW5ub3RhdGlvbilcbiAgICAgICAgZGVsZXRlIGFubm90YXRpb24udGV4dEFsaWduO1xuICAgIH1cbiAgICByZXR1cm4gYW5ub3RhdGlvbnMyO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2F4aXNNYW5hZ2VyLnRzXG52YXIgQXhpc01hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHNjZW5lUm9vdCkge1xuICAgIHRoaXMuc2NlbmVSb290ID0gc2NlbmVSb290O1xuICAgIHRoaXMuYXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5heGlzR3JpZEdyb3VwID0gbmV3IEdyb3VwKHsgbmFtZTogXCJBeGVzLUdyaWRzXCIsIGxheWVyOiB0cnVlLCB6SW5kZXg6IDEgLyogQVhJU19HUklEX1pJTkRFWCAqLyB9KTtcbiAgICB0aGlzLmF4aXNHcm91cCA9IG5ldyBHcm91cCh7IG5hbWU6IFwiQXhlc1wiLCBsYXllcjogdHJ1ZSwgekluZGV4OiAyIC8qIEFYSVNfWklOREVYICovIH0pO1xuICAgIHRoaXMuc2NlbmVSb290LmFwcGVuZENoaWxkKHRoaXMuYXhpc0dyb3VwKTtcbiAgICB0aGlzLnNjZW5lUm9vdC5hcHBlbmRDaGlsZCh0aGlzLmF4aXNHcmlkR3JvdXApO1xuICB9XG4gIHVwZGF0ZUF4ZXMob2xkQXhlcywgbmV3QXhlcykge1xuICAgIGZvciAoY29uc3QgYXhpcyBvZiBvbGRBeGVzKSB7XG4gICAgICBpZiAobmV3QXhlcy5pbmNsdWRlcyhheGlzKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBheGlzLmRldGFjaEF4aXModGhpcy5heGlzR3JvdXAsIHRoaXMuYXhpc0dyaWRHcm91cCk7XG4gICAgICBheGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBheGlzIG9mIG5ld0F4ZXMpIHtcbiAgICAgIGlmIChvbGRBeGVzPy5pbmNsdWRlcyhheGlzKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBheGlzLmF0dGFjaEF4aXModGhpcy5heGlzR3JvdXAsIHRoaXMuYXhpc0dyaWRHcm91cCk7XG4gICAgfVxuICAgIHRoaXMuYXhlcy5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgYXhpcyBvZiBuZXdBeGVzKSB7XG4gICAgICBjb25zdCBjdHggPSBheGlzLmNyZWF0ZUF4aXNDb250ZXh0KCk7XG4gICAgICBpZiAodGhpcy5heGVzLmhhcyhjdHguZGlyZWN0aW9uKSkge1xuICAgICAgICB0aGlzLmF4ZXMuZ2V0KGN0eC5kaXJlY3Rpb24pPy5wdXNoKGN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmF4ZXMuc2V0KGN0eC5kaXJlY3Rpb24sIFtjdHhdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0QXhpc0NvbnRleHQoZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmF4ZXMuZ2V0KGRpcmVjdGlvbikgPz8gW11dO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5heGVzLmNsZWFyKCk7XG4gICAgdGhpcy5zY2VuZVJvb3QucmVtb3ZlQ2hpbGQodGhpcy5heGlzR3JvdXApO1xuICAgIHRoaXMuc2NlbmVSb290LnJlbW92ZUNoaWxkKHRoaXMuYXhpc0dyaWRHcm91cCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2RhdGEvZGF0YVNlcnZpY2UudHNcbnZhciBEYXRhU2VydmljZSA9IGNsYXNzIGV4dGVuZHMgTGlzdGVuZXJzIHtcbiAgY29uc3RydWN0b3IoYW5pbWF0aW9uTWFuYWdlcikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyID0gYW5pbWF0aW9uTWFuYWdlcjtcbiAgICB0aGlzLmRpc3BhdGNoT25seUxhdGVzdCA9IHRydWU7XG4gICAgdGhpcy5kaXNwYXRjaFRocm90dGxlID0gMDtcbiAgICB0aGlzLnJlcXVlc3RUaHJvdHRsZSA9IDMwMDtcbiAgICB0aGlzLmlzTG9hZGluZ0luaXRpYWxEYXRhID0gZmFsc2U7XG4gICAgdGhpcy5pc0xvYWRpbmdEYXRhID0gZmFsc2U7XG4gICAgdGhpcy5mcmVzaFJlcXVlc3RzID0gW107XG4gICAgdGhpcy5yZXF1ZXN0Q291bnRlciA9IDA7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcImRhdGEtbW9kZWxcIiwgXCJkYXRhLXNvdXJjZVwiKTtcbiAgICB0aGlzLnRocm90dGxlZEZldGNoID0gdGhpcy5jcmVhdGVUaHJvdHRsZWRGZXRjaCh0aGlzLnJlcXVlc3RUaHJvdHRsZSk7XG4gICAgdGhpcy50aHJvdHRsZWREaXNwYXRjaCA9IHRoaXMuY3JlYXRlVGhyb3R0bGVkRGlzcGF0Y2godGhpcy5kaXNwYXRjaFRocm90dGxlKTtcbiAgfVxuICB1cGRhdGVDYWxsYmFjayhkYXRhU291cmNlQ2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGRhdGFTb3VyY2VDYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuZGVidWcoXCJEYXRhU2VydmljZSAtIHVwZGF0ZWQgZGF0YSBzb3VyY2UgY2FsbGJhY2tcIik7XG4gICAgdGhpcy5kYXRhU291cmNlQ2FsbGJhY2sgPSBkYXRhU291cmNlQ2FsbGJhY2s7XG4gICAgdGhpcy5pc0xvYWRpbmdJbml0aWFsRGF0YSA9IHRydWU7XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyLnNraXAoKTtcbiAgICB0aGlzLmRpc3BhdGNoKFwiZGF0YS1zb3VyY2UtY2hhbmdlXCIpO1xuICB9XG4gIGNsZWFyQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5kYXRhU291cmNlQ2FsbGJhY2sgPSB2b2lkIDA7XG4gIH1cbiAgbG9hZChwYXJhbXMpIHtcbiAgICB0aGlzLmlzTG9hZGluZ0RhdGEgPSB0cnVlO1xuICAgIHRoaXMudGhyb3R0bGVkRmV0Y2gocGFyYW1zKTtcbiAgfVxuICBpc0xhenkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZUNhbGxiYWNrICE9IG51bGw7XG4gIH1cbiAgaXNMb2FkaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmlzTGF6eSgpICYmICh0aGlzLmlzTG9hZGluZ0luaXRpYWxEYXRhIHx8IHRoaXMuaXNMb2FkaW5nRGF0YSk7XG4gIH1cbiAgY3JlYXRlVGhyb3R0bGVkRmV0Y2gocmVxdWVzdFRocm90dGxlKSB7XG4gICAgcmV0dXJuIHRocm90dGxlKChwYXJhbXMpID0+IHRoaXMuZmV0Y2gocGFyYW1zKSwgcmVxdWVzdFRocm90dGxlLCB7XG4gICAgICBsZWFkaW5nOiBmYWxzZSxcbiAgICAgIHRyYWlsaW5nOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlVGhyb3R0bGVkRGlzcGF0Y2goZGlzcGF0Y2hUaHJvdHRsZSkge1xuICAgIHJldHVybiB0aHJvdHRsZShcbiAgICAgIChpZCwgZGF0YSkgPT4ge1xuICAgICAgICB0aGlzLmRlYnVnKGBEYXRhU2VydmljZSAtIGRpc3BhdGNoaW5nICdkYXRhLWxvYWQnIHwgJHtpZH1gKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaChcImRhdGEtbG9hZFwiLCB7IHR5cGU6IFwiZGF0YS1sb2FkXCIsIGRhdGEgfSk7XG4gICAgICB9LFxuICAgICAgZGlzcGF0Y2hUaHJvdHRsZSxcbiAgICAgIHtcbiAgICAgICAgbGVhZGluZzogdHJ1ZSxcbiAgICAgICAgdHJhaWxpbmc6IHRydWVcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGZldGNoKHBhcmFtcykge1xuICAgIGlmICghdGhpcy5kYXRhU291cmNlQ2FsbGJhY2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGFTZXJ2aWNlIC0gW2RhdGFTb3VyY2UuZ2V0RGF0YV0gY2FsbGJhY2sgbm90IGluaXRpYWxpc2VkXCIpO1xuICAgIH1cbiAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IGlkID0gdGhpcy5yZXF1ZXN0Q291bnRlcisrO1xuICAgIHRoaXMuZGVidWcoYERhdGFTZXJ2aWNlIC0gcmVxdWVzdGluZyB8ICR7aWR9YCk7XG4gICAgdGhpcy5mcmVzaFJlcXVlc3RzLnB1c2goaWQpO1xuICAgIGxldCByZXNwb25zZTtcbiAgICB0cnkge1xuICAgICAgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmRhdGFTb3VyY2VDYWxsYmFjayhwYXJhbXMpO1xuICAgICAgdGhpcy5kZWJ1ZyhgRGF0YVNlcnZpY2UgLSByZXNwb25zZSB8ICR7cGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydH1tcyB8ICR7aWR9YCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZGVidWcoYERhdGFTZXJ2aWNlIC0gcmVxdWVzdCBmYWlsZWQgfCAke2lkfWApO1xuICAgICAgTG9nZ2VyLmVycm9yT25jZShgRGF0YVNlcnZpY2UgLSByZXF1ZXN0IGZhaWxlZCB8IFske2Vycm9yfV1gKTtcbiAgICB9XG4gICAgdGhpcy5pc0xvYWRpbmdJbml0aWFsRGF0YSA9IGZhbHNlO1xuICAgIGNvbnN0IHJlcXVlc3RJbmRleCA9IHRoaXMuZnJlc2hSZXF1ZXN0cy5maW5kSW5kZXgoKHJpZCkgPT4gcmlkID09PSBpZCk7XG4gICAgaWYgKHJlcXVlc3RJbmRleCA9PT0gLTEgfHwgdGhpcy5kaXNwYXRjaE9ubHlMYXRlc3QgJiYgcmVxdWVzdEluZGV4ICE9PSB0aGlzLmZyZXNoUmVxdWVzdHMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy5kZWJ1ZyhgRGF0YVNlcnZpY2UgLSBkaXNjYXJkaW5nIHN0YWxlIHJlcXVlc3QgfCAke2lkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZyZXNoUmVxdWVzdHMgPSB0aGlzLmZyZXNoUmVxdWVzdHMuc2xpY2UocmVxdWVzdEluZGV4ICsgMSk7XG4gICAgaWYgKHRoaXMuZnJlc2hSZXF1ZXN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuaXNMb2FkaW5nRGF0YSA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXNwb25zZSkpIHtcbiAgICAgIHRoaXMudGhyb3R0bGVkRGlzcGF0Y2goaWQsIHJlc3BvbnNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXNwYXRjaChcImRhdGEtZXJyb3JcIik7XG4gICAgfVxuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIG5ld1ZhbHVlKGRpc3BhdGNoVGhyb3R0bGUpIHtcbiAgICAgIHRoaXMudGhyb3R0bGVkRGlzcGF0Y2ggPSB0aGlzLmNyZWF0ZVRocm90dGxlZERpc3BhdGNoKGRpc3BhdGNoVGhyb3R0bGUpO1xuICAgIH1cbiAgfSlcbl0sIERhdGFTZXJ2aWNlLnByb3RvdHlwZSwgXCJkaXNwYXRjaFRocm90dGxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIG5ld1ZhbHVlKHJlcXVlc3RUaHJvdHRsZSkge1xuICAgICAgdGhpcy50aHJvdHRsZWRGZXRjaCA9IHRoaXMuY3JlYXRlVGhyb3R0bGVkRmV0Y2gocmVxdWVzdFRocm90dGxlKTtcbiAgICB9XG4gIH0pXG5dLCBEYXRhU2VydmljZS5wcm90b3R5cGUsIFwicmVxdWVzdFRocm90dGxlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zdHlsZXMuY3NzXG52YXIgc3R5bGVzX2RlZmF1bHQgPSAnLmFnLWNoYXJ0cy13cmFwcGVyLC5hZy1jaGFydHMtd3JhcHBlcjpmb2N1cywuYWctY2hhcnRzLXdyYXBwZXI6YWZ0ZXIsLmFnLWNoYXJ0cy13cmFwcGVyOmJlZm9yZSwuYWctY2hhcnRzLXdyYXBwZXIgKiwuYWctY2hhcnRzLXdyYXBwZXIgKjpmb2N1cywuYWctY2hhcnRzLXdyYXBwZXIgKjphZnRlciwuYWctY2hhcnRzLXdyYXBwZXIgKjpiZWZvcmV7Ym94LXNpemluZzpib3JkZXItYm94O291dGxpbmU6bm9uZX0uYWctY2hhcnRzLXdyYXBwZXJ7cG9zaXRpb246cmVsYXRpdmV9LmFnLWNoYXJ0cy1jYW52YXMtY2VudGVye3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7cG9zaXRpb246YWJzb2x1dGU7dG91Y2gtYWN0aW9uOmF1dG87ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOnZhcigtLWFnLWNoYXJ0cy1hbGlnbik7anVzdGlmeS1jb250ZW50OnZhcigtLWFnLWNoYXJ0cy1qdXN0aWZ5KX0uYWctY2hhcnRzLWNhbnZhcy1jb250YWluZXIsLmFnLWNoYXJ0cy1jYW52YXN7cG9zaXRpb246cmVsYXRpdmV9LmFnLWNoYXJ0cy1jYW52YXMtY29udGFpbmVyPiosLmFnLWNoYXJ0cy1jYW52YXM+KntkaXNwbGF5OmJsb2NrfS5hZy1jaGFydHMtY2FudmFzLXByb3h5e3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtvcGFjaXR5OjA7cG9pbnRlci1ldmVudHM6bm9uZX0uYWctY2hhcnRzLXRhYi1ndWFyZHt3aWR0aDowO2hlaWdodDowO29wYWNpdHk6MH0uYWctY2hhcnRzLWNhbnZhcy1vdmVybGF5e3BvaW50ZXItZXZlbnRzOm5vbmU7cG9zaXRpb246YWJzb2x1dGU7aW5zZXQ6MH0uYWctY2hhcnRzLWNhbnZhcy1vdmVybGF5Pip7cG9zaXRpb246YWJzb2x1dGU7cG9pbnRlci1ldmVudHM6YXV0b30uYWctY2hhcnRzLXRoZW1lLWRlZmF1bHQsLmFnLWNoYXJ0cy10aGVtZS1kZWZhdWx0LWRhcmt7LS1hZy1jaGFydHMtYWN0aXZlLWNvbG9yOiB2YXIoLS1hZy1hY3RpdmUtY29sb3IsICMyMTk2ZjMpOy0tYWctY2hhcnRzLWJhY2tncm91bmQtY29sb3I6IHZhcigtLWFnLWJhY2tncm91bmQtY29sb3IsICNmZmYpOy0tYWctY2hhcnRzLWZvcmVncm91bmQtY29sb3I6IHZhcigtLWFnLWZvcmVncm91bmQtY29sb3IsICMxODFkMWYpOy0tYWctY2hhcnRzLWJvcmRlci1jb2xvcjogdmFyKC0tYWctYm9yZGVyLWNvbG9yLCAjZGRkZGRkKTstLWFnLWNoYXJ0cy1mb250LWZhbWlseTogXCJWZXJkYW5hXCIsIHNhbnMtc2VyaWY7LS1hZy1jaGFydHMtZm9udC1zaXplOiB2YXIoLS1hZy1mb250LXNpemUsIDE0cHgpOy0tYWctY2hhcnRzLXNpemU6IHZhcigtLWFnLWdyaWQtc2l6ZSwgOHB4KTstLWFnLWNoYXJ0cy1ib3JkZXI6IHZhcigtLWFnLWNoYXJ0cy1ib3JkZXItY29sb3IpIHZhcigtLWFnLWJvcmRlcnMsIHNvbGlkIDFweCk7LS1hZy1jaGFydHMtYm9yZGVyLWNyaXRpY2FsOiB2YXIoLS1hZy1ib3JkZXJzLWNyaXRpY2FsLCBzb2xpZCAxcHgpOy0tYWctY2hhcnRzLWxheWVyLXVpLW92ZXJsYXk6IDU7LS1hZy1jaGFydHMtbGF5ZXItdG9vbHRpcDogNDstLWFnLWNoYXJ0cy1sYXllci10b29sYmFyOiAzOy0tYWctY2hhcnRzLWxheWVyLWNyb3NzaGFpcjogMjstLWFnLWNoYXJ0cy1sYXllci1hbm5vdGF0aW9uczogMTstLWFnLWNoYXJ0cy1hbGlnbjogY2VudGVyOy0tYWctY2hhcnRzLWp1c3RpZnk6IGNlbnRlcjstLWFnLWNoYXJ0cy1heGlzLWxhYmVsLWJhY2tncm91bmQtY29sb3I6ICM0NzQ3NDc7LS1hZy1jaGFydHMtYXhpcy1sYWJlbC1jb2xvcjogI2ZmZmZmZjstLWFnLWNoYXJ0cy10b29sYmFyLWZvcmVncm91bmQtY29sb3I6IHZhcigtLWFnLWhlYWRlci1mb3JlZ3JvdW5kLWNvbG9yLCB2YXIoLS1hZy1jaGFydHMtZm9yZWdyb3VuZC1jb2xvcikpOy0tYWctY2hhcnRzLXRvb2xiYXItYmFja2dyb3VuZC1jb2xvcjogdmFyKCAtLWFnLWhlYWRlci1iYWNrZ3JvdW5kLWNvbG9yLCBjb2xvci1taXgoaW4gc3JnYiwgdmFyKC0tYWctY2hhcnRzLWJhY2tncm91bmQtY29sb3IpLCB2YXIoLS1hZy1jaGFydHMtZm9yZWdyb3VuZC1jb2xvcikgMiUpICk7LS1hZy1jaGFydHMtdG9vbGJhci1zaXplOiAzNHB4Oy0tYWctY2hhcnRzLXRvb2xiYXItc2l6ZS1zbWFsbDogMjRweDstLWFnLWNoYXJ0cy10b29sYmFyLWJvcmRlcjogdmFyKC0tYWctY2hhcnRzLWJvcmRlci1jcml0aWNhbCwgc29saWQgMXB4KSB2YXIoLS1hZy1jaGFydHMtYm9yZGVyLWNvbG9yKTstLWFnLWNoYXJ0cy10b29sYmFyLWhvdmVyLWNvbG9yOiBjb2xvci1taXgoIGluIHNyZ2IsIHZhcigtLWFnLWNoYXJ0cy1iYWNrZ3JvdW5kLWNvbG9yKSwgdmFyKC0tYWctY2hhcnRzLWFjdGl2ZS1jb2xvcikgMTIlICk7LS1hZy1jaGFydHMtdG9vbGJhci1mb2N1cy1jb2xvcjogdmFyKC0tYWctY2hhcnRzLWFjdGl2ZS1jb2xvcik7LS1hZy1jaGFydHMtdG9vbGJhci1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItaG92ZXItY29sb3IpOy0tYWctY2hhcnRzLXRvb2xiYXItYWN0aXZlLWNvbG9yOiB2YXIoLS1hZy1jaGFydHMtYWN0aXZlLWNvbG9yKTstLWFnLWNoYXJ0cy10b29sYmFyLWRpc2FibGVkLWZvcmVncm91bmQtY29sb3I6IHZhciggLS1hZy1kaXNhYmxlZC1mb3JlZ3JvdW5kLWNvbG9yLCBjb2xvci1taXgoaW4gc3JnYiwgdHJhbnNwYXJlbnQsIHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWZvcmVncm91bmQtY29sb3IpIDUwJSkgKTstLWFnLWNoYXJ0cy10b29sYmFyLWRpc2FibGVkLWJhY2tncm91bmQtY29sb3I6IGNvbG9yLW1peCggaW4gc3JnYiwgdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYmFja2dyb3VuZC1jb2xvciksIHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWZvcmVncm91bmQtY29sb3IpIDYlICk7LS1hZy1jaGFydHMtdG9vbGJhci1nYXA6IHZhcigtLWFnLWNoYXJ0cy1zaXplKTstLWFnLWNoYXJ0cy10b29sYmFyLWZvbnQtc2l6ZTogMTNweDstLWFnLWNoYXJ0cy10b29sYmFyLWZvbnQtc2l6ZS1zbWFsbDogMTJweDstLWFnLWNoYXJ0cy10b29sYmFyLWJ1dHRvbi1wYWRkaW5nOiA2cHg7LS1hZy1jaGFydHMtdG9vbGJhci1idXR0b24tcGFkZGluZy1zbWFsbDogMXB4Oy0tYWctY2hhcnRzLXBvcG92ZXItYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYmFja2dyb3VuZC1jb2xvcik7LS1hZy1jaGFydHMtcG9wb3Zlci1mb3JlZ3JvdW5kLWNvbG9yOiB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1mb3JlZ3JvdW5kLWNvbG9yKTstLWFnLWNoYXJ0cy1wb3BvdmVyLWJvcmRlcjogdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYm9yZGVyKTstLWFnLWNoYXJ0cy1wb3BvdmVyLWFjdGl2ZS1jb2xvcjogdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYWN0aXZlLWNvbG9yKTstLWFnLWNoYXJ0cy1wb3BvdmVyLWhvdmVyLWNvbG9yOiB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1ob3Zlci1jb2xvcik7LS1hZy1jaGFydHMtcG9wb3Zlci1hY3RpdmUtYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYWN0aXZlLWJhY2tncm91bmQtY29sb3IpOy0tYWctY2hhcnRzLXBvcG92ZXItZm9udC1zaXplLXNtYWxsOiB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1mb250LXNpemUtc21hbGwpOy0tYWctY2hhcnRzLWJ1dHRvbi1yYWRpdXM6IHZhcigtLWFnLWJvcmRlci1yYWRpdXMsIDRweCk7LS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyLWNvbG9yOiB2YXIoLS1hZy1pbnB1dC1mb2N1cy1ib3JkZXItY29sb3IsIHZhcigtLWFnLWNoYXJ0cy1hY3RpdmUtY29sb3IpKTstLWFnLWNoYXJ0cy1mb2N1cy1ib3JkZXI6IHNvbGlkIDFweCB2YXIoLS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyLWNvbG9yKTstLWFnLWNoYXJ0cy1mb2N1cy1ib3JkZXItc2hhZG93OiB2YXIoIC0tYWctaW5wdXQtZm9jdXMtYm94LXNoYWRvdywgMCAwIDAgM3B4IGNvbG9yLW1peChpbiBzcmdiLCB0cmFuc3BhcmVudCwgdmFyKC0tYWctaW5wdXQtZm9jdXMtYm9yZGVyLWNvbG9yLCB2YXIoLS1hZy1jaGFydHMtYWN0aXZlLWNvbG9yKSkgMjAlKSApOy0tYWctY2hhcnRzLWljb24tZm9udC1mYW1pbHk6IFwiYWdDaGFydHNEZWZhdWx0XCI7LS1hZy1jaGFydHMtaWNvbi1mb250LXdlaWdodDogbm9ybWFsOy0tYWctY2hhcnRzLWljb24tZm9udC1jb2xvcjogY29sb3ItbWl4KGluIHNyZ2IsIHRyYW5zcGFyZW50LCB2YXIoLS1hZy1jaGFydHMtZm9yZWdyb3VuZC1jb2xvciksIDkwJSk7LS1hZy1jaGFydHMtaWNvbi1zaXplOiAyMHB4Oy0tYWctY2hhcnRzLXRleHQtYW5ub3RhdGlvbnMtcGxhY2Vob2xkZXI6ICM4ODg4ODh9LmFnLWNoYXJ0cy10aGVtZS1kZWZhdWx0LWRhcmt7LS1hZy1jaGFydHMtYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYWctYmFja2dyb3VuZC1jb2xvciwgY29sb3ItbWl4KGluIHNyZ2IsICNmZmYsICMxODIyMzAgOTclKSk7LS1hZy1jaGFydHMtZm9yZWdyb3VuZC1jb2xvcjogdmFyKC0tYWctZm9yZWdyb3VuZC1jb2xvciwgI2ZmZik7LS1hZy1jaGFydHMtYm9yZGVyLWNvbG9yOiB2YXIoLS1hZy1ib3JkZXItY29sb3IsIHJnYmEoMjU1LCAyNTUsIDI1NSwgLjE2KSk7LS1hZy1jaGFydHMtaG92ZXItY29sb3I6IHZhciggLS1hZy1yb3ctaG92ZXItY29sb3IsIGNvbG9yLW1peChpbiBzcmdiLCB0cmFuc3BhcmVudCwgdmFyKC0tYWctY2hhcnRzLWFjdGl2ZS1jb2xvcikgMjAlKSApOy0tYWctY2hhcnRzLWF4aXMtbGFiZWwtYmFja2dyb3VuZC1jb2xvcjogIzljYWViYjstLWFnLWNoYXJ0cy1heGlzLWxhYmVsLWNvbG9yOiAjMDAwMDAwOy0tYWctY2hhcnRzLXRvb2xiYXItYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tYWctaGVhZGVyLWJhY2tncm91bmQtY29sb3IsIGNvbG9yLW1peChpbiBzcmdiLCAjZmZmLCAjMTgyMjMwIDkzJSkpOy0tYWctY2hhcnRzLXRvb2xiYXItaG92ZXItY29sb3I6IGNvbG9yLW1peCggaW4gc3JnYiwgdmFyKC0tYWctY2hhcnRzLWJhY2tncm91bmQtY29sb3IpLCB2YXIoLS1hZy1jaGFydHMtYWN0aXZlLWNvbG9yKSAxOCUgKTstLWFnLWNoYXJ0cy1mb2N1cy1ib3JkZXItc2hhZG93OiB2YXIoIC0tYWctaW5wdXQtZm9jdXMtYm94LXNoYWRvdywgMCAwIDAgM3B4IGNvbG9yLW1peChpbiBzcmdiLCB0cmFuc3BhcmVudCwgdmFyKC0tYWctaW5wdXQtZm9jdXMtYm9yZGVyLWNvbG9yLCB2YXIoLS1hZy1jaGFydHMtYWN0aXZlLWNvbG9yKSkgMjAlKSApOy0tYWctY2hhcnRzLXRleHQtYW5ub3RhdGlvbnMtcGxhY2Vob2xkZXI6ICNhYWFhYWF9LmFnLWNoYXJ0cy1pY29ue2Rpc3BsYXk6YmxvY2s7d2lkdGg6dmFyKC0tYWctY2hhcnRzLWljb24tc2l6ZSk7aGVpZ2h0OnZhcigtLWFnLWNoYXJ0cy1pY29uLXNpemUpO3NwZWFrOm5vbmU7c3BlYWs6bmV2ZXI7bWFzazp2YXIoLS1pY29uKSBjZW50ZXIgLyBjb250YWluIG5vLXJlcGVhdDtiYWNrZ3JvdW5kLWNvbG9yOmN1cnJlbnRDb2xvcjt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjI1cyBlYXNlLWluLW91dH0uYWctY2hhcnRzLWljb24tY2FsbG91dC1hbm5vdGF0aW9uey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTXlBMExqVkJNUzQxSURFdU5TQXdJREFnTVNBMExqVWdNMmd4TVVFeExqVWdNUzQxSURBZ01DQXhJREUzSURRdU5YWTRZVEV1TlNBeExqVWdNQ0F3SURFdE1TNDFJREV1TldndE5DNDFNVFJoTWpZZ01qWWdNQ0F3SURBdE1pNHdNVGNnTVM0MU5Hd3RMak14TkM0eU5tTXRMalUxTGpRMU55MHhMakV4TlM0NU1qWXRNUzQzTmlBeExqUXRMalkyT1M0ME9URXRNUzQxTmpJdExqQXhNaTB4TGpVMk1pMHVPRll4TkVnMExqVkJNUzQxSURFdU5TQXdJREFnTVNBeklERXlMalY2VFRRdU5TQTBZUzQxTGpVZ01DQXdJREF0TGpVdU5YWTRZUzQxTGpVZ01DQXdJREFnTGpVdU5XZ3hMamd6TTNZekxqTTNNbUV6TmlBek5pQXdJREFnTUNBeExqWTNPQzB4TGpNek9Hd3VNekl0TGpJMk5XRXlOaUF5TmlBd0lEQWdNU0F5TGpJeU5TMHhMalk0Tld3dU1USTJMUzR3T0RSSU1UVXVOV0V1TlM0MUlEQWdNQ0F3SUM0MUxTNDFkaTA0WVM0MUxqVWdNQ0F3SURBdExqVXRMalY2SWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWNhbmRsZXN0aWNrLXNlcmllc3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5OeUF4ZGpOb01uWXhNa2czZGpOSU5uWXRNMGcwVmpSb01sWXhlazAxSURWb00zWXhNRWcxZWsweE1TQXhORlkyYURKV015NHlOV2d4Vmpab01uWTRhQzB5ZGpJdU56Vm9MVEZXTVRSNmJURXROMmd6ZGpab0xUTjZJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tY29tbWVudC1hbm5vdGF0aW9uey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTnk0MU1UTWdNeTQ1T1RWaE5pNDFJRFl1TlNBd0lEQWdNU0EyTGpBNU9DQXhNUzQwTVdNdExqVTRPQzR6T1RNdE1TNHlNVGN1TlRNMkxURXVPREk1TGpVNE5XRXhNeUF4TXlBd0lEQWdNUzB4TGpJM0xqQXhOMEV5TnlBeU55QXdJREFnTUNBeE1DQXhOa2cwTGpWaExqVXVOU0F3SURBZ01TMHVOUzB1TlZZeE1IRXdMUzR5TkRjdExqQXdOeTB1TlRFell5MHVNREE0TFM0ME1UWXRMakF4TmkwdU9EVTNMakF4TnkweExqSTJPUzR3TlMwdU5qRXlMakU1TWkweExqSTBMalU0TlMweExqZ3pZVFl1TlNBMkxqVWdNQ0F3SURFZ01pNDVNVGd0TWk0ek9UTnRNeTQxTmk0Mk1XRTFMalVnTlM0MUlEQWdNQ0F3TFRVdU5qUTJJREl1TXpSakxTNHlOall1TXprM0xTNHpOemt1T0RReUxTNDBNaUF4TGpNMU5DMHVNRE11TXpZdExqQXlNaTQzTVRndExqQXhOU0F4TGpFd09GRTFJRGt1TmpnNUlEVWdNVEIyTldnMWNTNHpNVEV1TURBeExqVTVNeTR3TURoakxqTTVMakF3Tnk0M05EY3VNREUxSURFdU1UQTRMUzR3TVRVdU5URXlMUzR3TkRFdU9UVTNMUzR4TlRRZ01TNHpOVFV0TGpReVlUVXVOU0ExTGpVZ01DQXdJREF0TVM0NU9ETXRPUzQ1TmpjaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1jcm9zc2hhaXItYWRkLWxpbmV7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWkQwaVRURXdJRFV1TldFdU5TNDFJREFnTUNBeElDNDFMalYyTXk0MWFETXVPRGMxWVM0MUxqVWdNQ0F3SURFZ01DQXhTREV3TGpWMk5DNHlOV0V1TlM0MUlEQWdNU0F4TFRFZ01GWXhNQzQxU0RVdU5qSTFZUzQxTGpVZ01DQXhJREVnTUMweFNEa3VOVlkyWVM0MUxqVWdNQ0F3SURFZ0xqVXRMalVpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tZGVsZXRley0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdaRDBpVFRndU5EazJJRGd1T1RrMlFTNDFMalVnTUNBd0lERWdPU0E1TGpRNU1uWTBZUzQxTGpVZ01DQXhJREV0TVNBdU1EQTRkaTAwWVM0MUxqVWdNQ0F3SURFZ0xqUTVOaTB1TlRBMFRURXlJRGt1TldFdU5TNDFJREFnTUNBd0xURWdNSFkwWVM0MUxqVWdNQ0F3SURBZ01TQXdlaUl2UGp4d1lYUm9JR1pwYkd3OUlpTXhNekUzTWpJaUlHWnBiR3d0Y25Wc1pUMGlaWFpsYm05a1pDSWdaRDBpVFRZZ05WWXpMalZCTWk0MUlESXVOU0F3SURBZ01TQTRMalVnTVdnelFUSXVOU0F5TGpVZ01DQXdJREVnTVRRZ015NDFWalZvTWk0NE16TmhMalV1TlNBd0lEQWdNU0F3SURGSU1UVjJNVEF1TWpWak1DQXVOREUxTFM0d05qWXVPRFl6TFM0eklERXVNakl4TFM0eU5UY3VNemswTFM0Mk56SXVOakV5TFRFdU1pNDJNVEpvTFRkakxTNDFNamdnTUMwdU9UUXpMUzR5TVRndE1TNHlMUzQyTVRJdExqSXpOQzB1TXpVNExTNHpMUzQ0TURZdExqTXRNUzR5TWpGV05rZ3pMak16TTJFdU5TNDFJREFnTUNBeElEQXRNWHB0TVMweExqVkJNUzQxSURFdU5TQXdJREFnTVNBNExqVWdNbWd6UVRFdU5TQXhMalVnTUNBd0lERWdNVE1nTXk0MVZqVklOM3BOTmlBeE5pNHlOVlkyYURoMk1UQXVNalZqTUNBdU16TTFMUzR3TlRrdU5UVTBMUzR4TXpndU5qYzFMUzR3TlRVdU1EZzFMUzR4TkM0eE5UZ3RMak0yTWk0eE5UaG9MVGRqTFM0eU1qSWdNQzB1TXpBM0xTNHdOek10TGpNMk1pMHVNVFU0TFM0d09DMHVNVEl4TFM0eE16Z3RMak0wTFM0eE16Z3RMalkzTlNJZ1kyeHBjQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLWRpc2pvaW50LWNoYW5uZWwsLmFnLWNoYXJ0cy1pY29uLWRpc2pvaW50LWNoYW5uZWwtZHJhd2luZ3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5NVGt1TURJNElERTNMalEyWVRJdU1qVWdNaTR5TlNBd0lEQWdNQzAwTGpBNU1pMHhMamcxYkMwNUxqVXhNUzB5TGpNM09HRXlMakkxSURJdU1qVWdNQ0F4SURBdExqSXlOUzQ1TnpSc09TNDBOelVnTWk0ek5qbGhNaTR5TlRFZ01pNHlOVEVnTUNBd0lEQWdOQzR6TlRNdU9EZzJiUzB4TGpZMk1pMHhMamsyTldFeExqSTFJREV1TWpVZ01DQXhJREV0TGpnNE5TQXlMak16T0NBeExqSTFJREV1TWpVZ01DQXdJREVnTGpnNE5TMHlMak16T0UwMExqTTBNeUF4TXk0Mk5qbGhNUzR5TlNBeExqSTFJREFnTVNBd0xUSXVNek00TFM0NE9EVWdNUzR5TlNBeExqSTFJREFnTUNBd0lESXVNek00TGpnNE5VMHpMamszSURndU56WTVZVEl1TWpVZ01pNHlOU0F3SURBZ01DQXhMalExTlMweUxqRXhiRGt1TlRFeExUSXVNemM0WVRJdU1qVWdNaTR5TlNBd0lERWdNQzB1TWpZdExqazJOVXcxTGpJZ05TNDJPRFZoTWk0eU5TQXlMakkxSURBZ01TQXdMVEV1TWpNZ015NHdPRFJ0TGpNM015MHlMalUwTjJFeExqSTFJREV1TWpVZ01DQXhJREV0TWk0ek16Z3VPRGcxSURFdU1qVWdNUzR5TlNBd0lEQWdNU0F5TGpNek9DMHVPRGcxYlRFekxqYzFMVE11TkRNNFlURXVNalVnTVM0eU5TQXdJREVnTVMweUxqTXpPQzQ0T0RVZ01TNHlOU0F4TGpJMUlEQWdNQ0F4SURJdU16TTRMUzQ0T0RVaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1ob2xsb3ctY2FuZGxlc3RpY2stc2VyaWVzey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxdmNHRmphWFI1UFNJdU1UVWlJR1E5SWswMUlEVm9NM1l4TUVnMWVpSXZQanh3WVhSb0lHWnBiR3c5SWlNeE16RTNNaklpSUdacGJHd3RjblZzWlQwaVpYWmxibTlrWkNJZ1pEMGlUVGNnTVhZemFESjJNVEpJTjNZelNEWjJMVE5JTkZZMGFESldNWHBOTlNBMWFETjJNVEJJTlhwdE55QXlhRE4yTm1ndE0zcHRMVEVnTjFZMmFESldNeTR5TldneFZqWm9Nblk0YUMweWRqSXVOelZvTFRGV01UUjZJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24taG9yaXpvbnRhbC1saW5lLC5hZy1jaGFydHMtaWNvbi1ob3Jpem9udGFsLWxpbmUtZHJhd2luZ3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5MalVnT1M0MWFEY3VNekEyWVRJdU1qVWdNaTR5TlNBd0lEQWdNU0EwTGpNNE9DQXdTREU1TGpWMk1XZ3ROeTR6TURaaE1pNHlOU0F5TGpJMUlEQWdNQ0F4TFRRdU16ZzRJREJJTGpWNmJUa3VOU0F4TGpjMVlURXVNalVnTVM0eU5TQXdJREVnTUNBd0xUSXVOU0F4TGpJMUlERXVNalVnTUNBd0lEQWdNQ0F5TGpVaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1saW5lLWNvbG9yey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTVRRdU1qUXlJREl1TnpJeVl5MHVOakV5SURBdE1TNHlMakkwTXkweExqWXpNaTQyTnpWc0xURXVNelF6SURFdU16UTBZUzQxTGpVZ01DQXdJREF0TGpFeE1pNHhNVEpNTkM0d05TQXhNUzQ1TlRsakxTNHlNRGN1TWpBM0xTNHpOaTQwTmkwdU5EUTJMamMwZGk0d01ERnNMUzQyT1NBeUxqYzJOM1l1TURBeVlTNDRNaTQ0TWlBd0lEQWdNQ0F4TGpBeU1pQXhMakF5TVdndU1EQXliREl1TmpNMExTNDRNakpqTGpJNExTNHdPRFV1TlRNMExTNHlNemN1TnpRdExqUTBNMnczTGpFd055MDNMakV3T0dFdU5TNDFJREFnTUNBd0lDNHhNVEl0TGpFeE1td3hMak0wTXkweExqTTBNMkV5TGpNd09DQXlMak13T0NBd0lEQWdNQzB4TGpZek1pMHpMamswVFRFMExqRXlNaUEzYkRFdU1EUTBMVEV1TURRMVlURXVNekE0SURFdU16QTRJREFnTVNBd0xURXVPRFE1TFRFdU9EVk1NVEl1TWpjeElEVXVNVFY2YlMweUxqVTFPQzB4TGpFME1pMDJMamd3TnlBMkxqZ3dPV0V1T0M0NElEQWdNQ0F3TFM0eE9UWXVNekkxYkMwdU56VWdNaTQwTmpnZ01pNDBOeTB1TnpRNVlTNDRMamdnTUNBd0lEQWdMak15TlMwdU1UazBiRFl1T0RBNExUWXVPREY2SWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWxpbmUtc2VyaWVzey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKdE1UY3VNell5SURRdU9EY3pMVFF1TlRrMElEWXVOalUwTFRRdU9EVXRNeTR6TVRjdE5DNHlOVEVnTmk0NU56Y3RMamcxTkMwdU5USk1OeTQyTVRJZ05pNDNPV3cwTGpnNU9TQXpMak0xSURRdU1ESTRMVFV1T0RNMmVpSWdZMnhwY0MxeWRXeGxQU0psZG1WdWIyUmtJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1saW5lLXdpdGgtbWFya2Vycy1zZXJpZXN7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0p0TVRndU1UazRJRFF1T0RnNExUTXVOVFUySURRdU9URTRZVEl1TWpVZ01pNHlOU0F3SURFZ01TMHpMamcyTmk0M05Xd3RNUzQwTXpJdExqbGhNaTR5TkNBeUxqSTBJREFnTUNBeExUSXVNREE1TGpRek5Xd3RNeTQ0TWpnZ05pNDBNamd0TGpnMkxTNDFNVEpNTmk0ME5TQTVMall5TTJFeUxqSTFJREl1TWpVZ01DQXhJREVnTXk0MU1TMHVOell4YkRFdU16STVMamd6TldFeUxqSTBJREl1TWpRZ01DQXdJREVnTWk0MU5UY3RMalE1TjJ3ekxqVTBNaTAwTGpnNU9IcHRMVFF1T1RZZ05TNHhOVE5oTVM0eU5TQXhMakkxSURBZ01TQXdMUzQyTkNBeUxqUXhPU0F4TGpJMUlERXVNalVnTUNBd0lEQWdMalkwTFRJdU5ERTVUVGt1TVNBNExqTXlNWEV1TURZMkxTNHhPVEl1TURZM0xTNDBNRFJoTVM0eU5TQXhMakkxSURBZ01TQXdMUzR3TmpjdU5EQTBJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tbG9jaywuYWctY2hhcnRzLWljb24tbG9ja2Vkey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTVRBdU1qQTNJRE11TnpZMFlUSXVPRGswSURJdU9EazBJREFnTUNBd0xUSXVPRGsxSURJdU9EazBWamxvTlM0M09EbFdOaTQyTlRoaE1pNDRPVFFnTWk0NE9UUWdNQ0F3SURBdE1pNDRPVFV0TWk0NE9UUk5NVFF1TVNBNVZqWXVOalU0WVRNdU9EazBJRE11T0RrMElEQWdNU0F3TFRjdU56ZzVJREIyTWk0ek5EbEJNaTQxSURJdU5TQXdJREFnTUNBMElERXhMalYyTTBFeUxqVWdNaTQxSURBZ01DQXdJRFl1TlNBeE4yZzRZVEl1TlNBeUxqVWdNQ0F3SURBZ01pNDFMVEl1TlhZdE0wRXlMalVnTWk0MUlEQWdNQ0F3SURFMExqVWdPWHBOTmk0MUlERXdRVEV1TlNBeExqVWdNQ0F3SURBZ05TQXhNUzQxZGpOQk1TNDFJREV1TlNBd0lEQWdNQ0EyTGpVZ01UWm9PR0V4TGpVZ01TNDFJREFnTUNBd0lERXVOUzB4TGpWMkxUTmhNUzQxSURFdU5TQXdJREFnTUMweExqVXRNUzQxZWlJZ1kyeHBjQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLW5vdGUtYW5ub3RhdGlvbnstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk15QTBMalZCTVM0MUlERXVOU0F3SURBZ01TQTBMalVnTTJneE1VRXhMalVnTVM0MUlEQWdNQ0F4SURFM0lEUXVOWFk0WVRFdU5TQXhMalVnTUNBd0lERXRNUzQxSURFdU5XZ3RNeTR5TVd3dE1TNDBOamtnTWk0MU4yRXhJREVnTUNBd0lERXRNUzQyT0RJdU1EZzFURGN1TWpReklERTBTRFF1TlVFeExqVWdNUzQxSURBZ01DQXhJRE1nTVRJdU5YcE5OQzQxSURSaExqVXVOU0F3SURBZ01DMHVOUzQxZGpoaExqVXVOU0F3SURBZ01DQXVOUzQxYURNdU1qVTNiREl1TVRrMklETXVNRGMwVERFeExqY3hJREV6YURNdU56bGhMalV1TlNBd0lEQWdNQ0F1TlMwdU5YWXRPR0V1TlM0MUlEQWdNQ0F3TFM0MUxTNDFlaUlnWTJ4cGNDMXlkV3hsUFNKbGRtVnViMlJrSWk4K1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTmk0MUlEWXVOVUV1TlM0MUlEQWdNQ0F4SURjZ05tZzJZUzQxTGpVZ01DQXdJREVnTUNBeFNEZGhMalV1TlNBd0lEQWdNUzB1TlMwdU5VMDJMalVnT1M0MVFTNDFMalVnTUNBd0lERWdOeUE1YURaaExqVXVOU0F3SURBZ01TQXdJREZJTjJFdU5TNDFJREFnTUNBeExTNDFMUzQxSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLW9obGMtc2VyaWVzey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdaRDBpVFRFeklERXhhQzB6ZGkweGFETldNMmd4ZGpKb05IWXhhQzAwZGpFeGFDMHhlazAySURFM2RpMHlhRE4yTFRGSU5sWTBTRFYyTVVneWRqRm9NM1l4TVhvaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWZpbGwtY29sb3J7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSnRPQzR3TnpFZ05DNHdOaTB1T1RJMExTNDVNalF1TnpBM0xTNDNNRGNnTnk0eU9EZ2dOeTR5T0RndE5DNDVOU0EwTGprMVlUTXVOU0F6TGpVZ01DQXdJREV0TkM0NU5TQXdiQzB4TGpReE5DMHhMalF4TkdFekxqVWdNeTQxSURBZ01DQXhJREF0TkM0NU5YcHRMamN3Tnk0M01EaE1OQzQxTXpZZ09TNHdNV0V5TGpVZ01pNDFJREFnTUNBd0lEQWdNeTQxTXpaTU5TNDVOU0F4TXk0NU5tRXlMalVnTWk0MUlEQWdNQ0F3SURNdU5UTTFJREJzTkM0eU5ETXROQzR5TkRONmJUWXVPU0EzTGpJd01pMHVNelExTGpNMk15MHVNelEwTFM0ek5qTmhMalV1TlNBd0lEQWdNU0F1TmpnNElEQnRMUzR6TkRVZ01TNHdPR0U0SURnZ01DQXdJREF0TGpJNExqTXlNeUEwTGpNZ05DNHpJREFnTUNBd0xTNDBNRGt1TlRneVl5MHVNVEV6TGpJd01TMHVNVFEwTGpNeU5pMHVNVFEwTGpNM09HRXVPRE16TGpnek15QXdJREFnTUNBeExqWTJOeUF3WXpBdExqQTFNaTB1TURNeExTNHhOemN0TGpFME5DMHVNemM0WVRRdU15QTBMak1nTUNBd0lEQXRMalF4TFM0MU9ESWdPQ0E0SURBZ01DQXdMUzR5T0MwdU16SXliUzB1TXpRMExURXVNRGd1TXpRMExqTTJNeTR6TkRRdExqTTJNeTR3TURJdU1EQXlMakF3TkM0d01EUXVNREV6TGpBeE1tRTJJRFlnTUNBd0lERWdMakl3Tmk0eU1EaGpMakV6TVM0eE16WXVNekE0TGpNeU55NDBPRFV1TlRRMUxqRTNOaTR5TVRVdU16WXpMalEyTnk0MU1EY3VOekkwTGpFek55NHlORE11TWpjekxqVTFNeTR5TnpNdU9EWTRZVEV1T0RNeklERXVPRE16SURBZ01TQXhMVE11TmpZM0lEQmpNQzB1TXpFMUxqRXpOaTB1TmpJMUxqSTNNeTB1T0RZNExqRTBOQzB1TWpVM0xqTXpMUzQxTURrdU5UQTNMUzQzTWpSaE9TQTVJREFnTUNBeElDNDJORFV0TGpjd09Hd3VNRFEyTFM0d05EVXVNREV6TFM0d01USXVNREEwTFM0d01EUjZJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tcGFuLWVuZHstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdaRDBpYlRZdU5qUTJJREV6TGpneE15MHVNelV6TGpNMU5DNDNNRGN1TnpBM0xqTTFOQzB1TXpVMGVrMHhNUzR4TmpZZ01UQnNMak0xTkM0ek5UUXVNelUwTFM0ek5UUXRMak0xTkMwdU16VTBlazAzTGpNMU5TQTFMalE0SURjZ05TNHhNalpzTFM0M01EY3VOekEzTGpNMU15NHpOVFI2YlRBZ09TNHdOQ0EwTGpFMk5pMDBMakUyTmkwdU56QTNMUzQzTURndE5DNHhOamNnTkM0eE5qZDZiVFF1TVRZMkxUUXVPRGMwVERjdU16VTBJRFV1TkRoc0xTNDNNRGd1TnpBM0lEUXVNVFkzSURRdU1UWTNlazB4TXk0d09ETWdOWFl4TUdneFZqVjZJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1wYW4tbGVmdHstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk1USXVOemtnTlM0NE16TWdPQzQyTWpVZ01UQnNOQzR4TmpZZ05DNHhOamN0TGpjd055NDNNRGRNTnk0eU1TQXhNR3cwTGpnM015MDBMamczTkhvaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1wYW4tcmlnaHR7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5OeTR5TVNBeE5DNHhOamNnTVRFdU16YzJJREV3SURjdU1qRWdOUzQ0TXpOc0xqY3dOeTB1TnpBM1RERXlMamM1SURFd2JDMDBMamczTXlBMExqZzNOSG9pSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXBhbi1zdGFydHstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdaRDBpVFRZZ05YWXhNR2d4VmpWNlRUa3VOakkwSURFd2JEUXVNVFkyTFRRdU1UWTNMUzQzTURjdExqY3dOMHc0TGpJeElERXdiRFF1T0RjMElEUXVPRGMwTGpjd055MHVOekEzZWlJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXBhcmFsbGVsLWNoYW5uZWwsLmFnLWNoYXJ0cy1pY29uLXBhcmFsbGVsLWNoYW5uZWwtZHJhd2luZ3stLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlNQ0lnYUdWcFoyaDBQU0l5TUNJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpFek1UY3lNaUlnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5NVGN1TnpJZ05TNHpNekZCTWk0eU5TQXlMakkxSURBZ01TQXdJREUwTGpjd05TQXpMalpzTFRrdU5Ea2dOQzQxTmpKaE1pNHlOU0F5TGpJMUlEQWdNU0F3SUM0eU1Ea2dNUzR3TVd3NUxqWTJNaTAwTGpZME5tRXlMakkxSURJdU1qVWdNQ0F3SURBZ01pNDJNelF1T0RBMWJTNHpOek10TWk0MU5EZGhNUzR5TlNBeExqSTFJREFnTVNBeExUSXVNek00TGpnNE5TQXhMakkxSURFdU1qVWdNQ0F3SURFZ01pNHpNemd0TGpnNE5VMDBMak0wTXlBNExqWTNZVEV1TWpVZ01TNHlOU0F3SURFZ01TMHlMak16T0M0NE9EVWdNUzR5TlNBeExqSTFJREFnTUNBeElESXVNek00TFM0NE9EVk5OUzR6TURjZ01UWXVOekk0WVRJdU1qVWdNaTR5TlNBd0lERWdNUzB1TlRJMUxTNDROVGhzT1M0NU1qTXROQzQzTjJFeUxqSTFJREl1TWpVZ01DQXhJREVnTGpNNE1TNDVNalo2YlMwdU9UWTBMakkzTkdFeExqSTFJREV1TWpVZ01DQXhJREV0TWk0ek16Z3VPRGcxSURFdU1qVWdNUzR5TlNBd0lEQWdNU0F5TGpNek9DMHVPRGcxYlRFekxqQXlNeTAxTGpFd05tRXhMakkxSURFdU1qVWdNQ0F4SURBdExqZzROUzB5TGpNek9TQXhMakkxSURFdU1qVWdNQ0F3SURBZ0xqZzROU0F5TGpNek9TSWdZMnhwY0MxeWRXeGxQU0psZG1WdWIyUmtJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1wcmljZS1sYWJlbC1hbm5vdGF0aW9uey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTkM0MUlETkJNUzQxSURFdU5TQXdJREFnTUNBeklEUXVOVll4TTJFeExqVWdNUzQxSURBZ01DQXdJREV1TlNBeExqVm9Mamd6TTNZdU1EVTNZeTR5TkRJdExqSTVPUzQxT1RjdExqVXdNeUF4TFM0MU5EaFdNVE11TlVnMExqVkJMalV1TlNBd0lEQWdNU0EwSURFelZqUXVOV0V1TlM0MUlEQWdNQ0F4SUM0MUxTNDFhREV4WVM0MUxqVWdNQ0F3SURFZ0xqVXVOWFk0WVM0MUxqVWdNQ0F3SURFdExqVXVOV2d0TkM0NE1UaHNMUzR4TWpZdU1EZzBZVEkySURJMklEQWdNQ0F3TFRJdU1qSTFJREV1TmpnMWJDMHVNekl1TWpZMUxTNHdOamd1TURVMllURXVOU0F4TGpVZ01DQXdJREV0TWk0Mk1Ea2dNUzR6TlRSakxqQXpNeTQzTmpNdU9UQTFJREV1TWpNNElERXVOVFl1TnpVMkxqWTBOaTB1TkRjMElERXVNakV0TGprME15QXhMamMyTVMweExqUnNMak14TXkwdU1qWkJNallnTWpZZ01DQXdJREVnTVRBdU9UZzJJREUwU0RFMUxqVmhNUzQxSURFdU5TQXdJREFnTUNBeExqVXRNUzQxZGkwNFFURXVOU0F4TGpVZ01DQXdJREFnTVRVdU5TQXplaUlnWTJ4cGNDMXlkV3hsUFNKbGRtVnViMlJrSWk4K1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk9DNDNNVFlnTVRRdU9ERTFZVEl1TWpVZ01pNHlOU0F3SURFZ01TMDBMakl4SURFdU5Ua3pJREl1TWpVZ01pNHlOU0F3SURBZ01TQTBMakl4TFRFdU5Ua3piUzB4TGpZMk1pQXhMamsyTm1FeExqSTFJREV1TWpVZ01DQXhJREF0TGpnNE5TMHlMak16T1NBeExqSTFJREV1TWpVZ01DQXdJREFnTGpnNE5TQXlMak16T1NJZ1kyeHBjQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLXJlc2V0ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTVRJdU1EUWdOQzQwTkRWaE5TNDRNU0ExTGpneElEQWdNQ0F3TFRjdU1qVTNJREl1TkRVekxqVXVOU0F3SURBZ01TMHVPRFkxTFM0MU1ESkJOaTQ0TVNBMkxqZ3hJREFnTVNBeElETWdPUzQ0TVROaExqVXVOU0F3SURBZ01TQXhJREFnTlM0NE1TQTFMamd4SURBZ01TQXdJRGd1TURRdE5TNHpOamdpSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqeHdZWFJvSUdacGJHdzlJaU13TURBaUlHWnBiR3d0Y25Wc1pUMGlaWFpsYm05a1pDSWdaRDBpVFRRdU1qZzVJRE11TURBeVlTNDFMalVnTUNBd0lERWdMalV1TlhZeUxqWTFOV2d5TGpZMU5XRXVOUzQxSURBZ01DQXhJREFnTVVnMExqSTVZUzQxTGpVZ01DQXdJREV0TGpVdExqVldNeTQxTURKaExqVXVOU0F3SURBZ01TQXVOUzB1TlNJZ1kyeHBjQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpOCtQQzl6ZG1jKyl9LmFnLWNoYXJ0cy1pY29uLXN0ZXAtbGluZS1zZXJpZXN7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RTRNVVF4UmlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTmlBMGFEVjJPR2d6Vmpob05YWXhhQzAwZGpSb0xUVldOVWczZGpFd1NESjJMVEZvTkhvaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi10ZXh0LWFubm90YXRpb257LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTWpBaUlHaGxhV2RvZEQwaU1qQWlJSFpwWlhkQ2IzZzlJakFnTUNBeU1DQXlNQ0lnWm1sc2JEMGlibTl1WlNJZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWo0S1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazAwSURSSU1UWldOMGd4TlZZMVNERXdMalZXTVRWSU1UUldNVFpJTmxZeE5VZzVMalZXTlVnMVZqZElORlkwV2lJZ1ptbHNiRDBpWW14aFkyc2lMejRLUEM5emRtYytDZz09KX0uYWctY2hhcnRzLWljb24tdHJlbmQtbGluZSwuYWctY2hhcnRzLWljb24tdHJlbmQtbGluZS1kcmF3aW5ney0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk5TNHpNVFFnTVRBdU9UTTRZVEl1TWpVZ01pNHlOU0F3SURFZ01TQXVNREV0TVdnNUxqTTFNbUV5TGpJMUlESXVNalVnTUNBeElERWdMakF4SURGNmJTMHlMakU0T1M0M01qbGhNUzR5TlNBeExqSTFJREFnTVNBd0lEQXRNaTQxSURFdU1qVWdNUzR5TlNBd0lEQWdNQ0F3SURJdU5XMHhNeTQzTlNBd1lURXVNalVnTVM0eU5TQXdJREVnTUNBd0xUSXVOU0F4TGpJMUlERXVNalVnTUNBd0lEQWdNQ0F5TGpVaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi11bmxvY2ssLmFnLWNoYXJ0cy1pY29uLXVubG9ja2Vkey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekF3TUNJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTVRBdU5qVXhJRE11TldFeUxqZzVOQ0F5TGpnNU5DQXdJREFnTUMweUxqZzVOQ0F5TGpnNU5GWTVTREUwTGpWaE1pNDFJREl1TlNBd0lEQWdNU0F5TGpVZ01pNDFkak5oTWk0MUlESXVOU0F3SURBZ01TMHlMalVnTWk0MWFDMDRRVEl1TlNBeUxqVWdNQ0F3SURFZ05DQXhOQzQxZGkwelFUSXVOU0F5TGpVZ01DQXdJREVnTmk0MUlEbG9MakkxTjFZMkxqTTVOR0V6TGpnNU5DQXpMamc1TkNBd0lERWdNU0EzTGpjNE9TQXdJQzQxTGpVZ01DQXdJREV0TVNBd1FUSXVPRGswSURJdU9EazBJREFnTUNBd0lERXdMalkxSURNdU5VMDJMalVnTVRCQk1TNDFJREV1TlNBd0lEQWdNQ0ExSURFeExqVjJNMEV4TGpVZ01TNDFJREFnTUNBd0lEWXVOU0F4Tm1nNFlURXVOU0F4TGpVZ01DQXdJREFnTVM0MUxURXVOWFl0TTJFeExqVWdNUzQxSURBZ01DQXdMVEV1TlMweExqVjZJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tdmVydGljYWwtbGluZSwuYWctY2hhcnRzLWljb24tdmVydGljYWwtbGluZS1kcmF3aW5ney0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU1DSWdhR1ZwWjJoMFBTSXlNQ0lnWm1sc2JEMGlibTl1WlNJK1BIQmhkR2dnWm1sc2JEMGlJekV6TVRjeU1pSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk1UQXVOU0EzTGpnd05tRXlMakkxSURJdU1qVWdNQ0F3SURFZ01DQTBMak00T0ZZeE9TNDFhQzB4ZGkwM0xqTXdObUV5TGpJMUlESXVNalVnTUNBd0lERWdNQzAwTGpNNE9GWXVOV2d4ZW0wdExqVXVPVFEwWVRFdU1qVWdNUzR5TlNBd0lERWdNU0F3SURJdU5TQXhMakkxSURFdU1qVWdNQ0F3SURFZ01DMHlMalVpSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXpvb20taW57LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWkQwaVRURXdJRFV1TldFdU5TNDFJREFnTUNBeElDNDFMalYyTXk0MWFETXVPRGMxWVM0MUxqVWdNQ0F3SURFZ01DQXhTREV3TGpWMk5DNHlOV0V1TlM0MUlEQWdNU0F4TFRFZ01GWXhNQzQxU0RVdU5qSTFZUzQxTGpVZ01DQXhJREVnTUMweFNEa3VOVlkyWVM0MUxqVWdNQ0F3SURFZ0xqVXRMalVpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tem9vbS1vdXR7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6QXdNQ0lnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCa1BTSk5OUzQxSURFd1lTNDFMalVnTUNBd0lERWdMalV0TGpWb09HRXVOUzQxSURBZ01DQXhJREFnTVVnMllTNDFMalVnTUNBd0lERXRMalV0TGpVaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQand2YzNablBnPT0pfS5hZy1jaGFydHMtaWNvbi1oaWdoLWxvdy1zZXJpZXN7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0pOTnlBMGFESjJNVEpJTkZZMGFETk5OU0ExYUROMk1UQklOWHBOTVRFZ01UUldObWcxZGpob0xUVnRNUzAzYUROMk5tZ3RNM29pSUdOc2FYQXRjblZzWlQwaVpYWmxibTlrWkNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLWhsYy1zZXJpZXN7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TUNJZ2FHVnBaMmgwUFNJeU1DSWdabWxzYkQwaWJtOXVaU0krUEhCaGRHZ2dabWxzYkQwaUl6RXpNVGN5TWlJZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmtQU0p0TVRndU1UWXpJREV1T0RNM0xUVXVNek0wSURFeExqWXlNVXcyTGprMU55QTRMakV5YkMwMExqRTVPU0E1TGpZeU1pMHVPVEUyTFM0MElEUXVOelUyTFRFd0xqbE1NVEl1TkRrZ01URXVPQ0F4Tnk0eU5UUWdNUzQwTW5vaUlHTnNhWEF0Y25Wc1pUMGlaWFpsYm05a1pDSXZQanh3WVhSb0lHWnBiR3c5SWlNd01EQWlJR1pwYkd3dGIzQmhZMmwwZVQwaUxqUWlJR1pwYkd3dGNuVnNaVDBpWlhabGJtOWtaQ0lnWkQwaVRUVXVPREkxSURJdU56QTBMalUxSURFekxqYzROV3d1T1RBeUxqUXpJRFF1TnpJMExUa3VPVEU1SURZdU1ETTBJRFV1TURJNUlETXVNalUxTFRndU1UUXRMamt5T0MwdU16Y3RNaTQzTkRVZ05pNDRObnB0Tnk0NE5USWdNVFF1TmpNMklEVXVOemd0TVRNdU1UTTVMUzQ1TVRVdExqUXdNaTAxTGpJeE9TQXhNUzQ0TmkwMkxqQXdOUzAxTGpVd05DMHpMakkzT0NBM0xqWTBPQzQ1TWk0ek9UUWdNaTQzTWpJdE5pNHpOVEo2SWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLXpvb20taW4tbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UWWlJR2hsYVdkb2REMGlNVFlpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazA0TGpjMUlEUXVOV0V1TnpVdU56VWdNQ0F3SURBdE1TNDFJREIyTWk0M05VZzBMalZoTGpjMUxqYzFJREFnTUNBd0lEQWdNUzQxYURJdU56VjJNaTQzTldFdU56VXVOelVnTUNBd0lEQWdNUzQxSURCV09DNDNOV2d5TGpjMVlTNDNOUzQzTlNBd0lEQWdNQ0F3TFRFdU5VZzRMamMxVmpRdU5Wb2lJR1pwYkd3OUlpTXdNREFpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tem9vbS1vdXQtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UWWlJR2hsYVdkb2REMGlNVFlpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazB6TGpjMUlEaGhMamMxTGpjMUlEQWdNQ0F4SUM0M05TMHVOelZvTjJFdU56VXVOelVnTUNBd0lERWdNQ0F4TGpWb0xUZEJMamMxTGpjMUlEQWdNQ0F4SURNdU56VWdPRm9pSUdacGJHdzlJaU13TURBaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLXpvb20taW4tYWx0LC5hZy1jaGFydHMtaWNvbi16b29tLWluLWFsdC1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJaUJtYVd4c1BTSnViMjVsSWlCemRISnZhMlU5SW1OMWNuSmxiblJEYjJ4dmNpSWdjM1J5YjJ0bExYZHBaSFJvUFNJeUlpQnpkSEp2YTJVdGJHbHVaV05oY0QwaWNtOTFibVFpSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlJR05zWVhOelBTSnNkV05wWkdVZ2JIVmphV1JsTFhwdmIyMHRhVzRpUGp4amFYSmpiR1VnWTNnOUlqRXhJaUJqZVQwaU1URWlJSEk5SWpnaUx6NDhiR2x1WlNCNE1UMGlNakVpSUhneVBTSXhOaTQyTlNJZ2VURTlJakl4SWlCNU1qMGlNVFl1TmpVaUx6NDhiR2x1WlNCNE1UMGlNVEVpSUhneVBTSXhNU0lnZVRFOUlqZ2lJSGt5UFNJeE5DSXZQanhzYVc1bElIZ3hQU0k0SWlCNE1qMGlNVFFpSUhreFBTSXhNU0lnZVRJOUlqRXhJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi16b29tLW91dC1hbHQsLmFnLWNoYXJ0cy1pY29uLXpvb20tb3V0LWFsdC1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJaUJtYVd4c1BTSnViMjVsSWlCemRISnZhMlU5SW1OMWNuSmxiblJEYjJ4dmNpSWdjM1J5YjJ0bExYZHBaSFJvUFNJeUlpQnpkSEp2YTJVdGJHbHVaV05oY0QwaWNtOTFibVFpSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlJR05zWVhOelBTSnNkV05wWkdVZ2JIVmphV1JsTFhwdmIyMHRiM1YwSWo0OFkybHlZMnhsSUdONFBTSXhNU0lnWTNrOUlqRXhJaUJ5UFNJNElpOCtQR3hwYm1VZ2VERTlJakl4SWlCNE1qMGlNVFl1TmpVaUlIa3hQU0l5TVNJZ2VUSTlJakUyTGpZMUlpOCtQR3hwYm1VZ2VERTlJamdpSUhneVBTSXhOQ0lnZVRFOUlqRXhJaUI1TWowaU1URWlMejQ4TDNOMlp6ND0pfS5hZy1jaGFydHMtaWNvbi1yZXNldC1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRZaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMDBMalF4TWlBMExqQTFPQ0F5TGpjMUlESXVNemsyVmpZdU56Vm9MamMwTkdFdU56WXVOellnTUNBd0lEQWdMakF4TWlBd2FETXVOVGs0VERVdU5EYzRJRFV1TVRJMVlUUXVNVEkxSURRdU1USTFJREFnTUNBeElESXVOVEl6TFM0NE56VWdNeTQzTlNBekxqYzFJREFnTVNBeExUTXVNVEU1SURVdU9ETXpMamMxTGpjMUlEQWdNQ0F3TFRFdU1qUTNMamd6TkVFMUxqSTFJRFV1TWpVZ01DQXhJREFnT0NBeUxqYzFhQzB1TURBellUVXVOakkxSURVdU5qSTFJREFnTUNBd0xUTXVOVGcxSURFdU16QTRXaUlnWm1sc2JEMGlJekF3TUNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXBhbi1sZWZ0LWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVFlpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWsweE1DNHdNeUEwTGpRM1lTNDNOUzQzTlNBd0lEQWdNU0F3SURFdU1EWk1OeTQxTmlBNGJESXVORGNnTWk0ME4yRXVOelV1TnpVZ01DQXhJREV0TVM0d05pQXhMakEyYkMwekxUTmhMamMxTGpjMUlEQWdNQ0F4SURBdE1TNHdObXd6TFROaExqYzFMamMxSURBZ01DQXhJREV1TURZZ01Gb2lJR1pwYkd3OUlpTXdNREFpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tcGFuLXJpZ2h0LWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVFlpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWswMUxqazNJREV4TGpVellTNDNOUzQzTlNBd0lEQWdNU0F3TFRFdU1EWk1PQzQwTkNBNElEVXVPVGNnTlM0MU0yRXVOelV1TnpVZ01DQXdJREVnTVM0d05pMHhMakEyYkRNZ00yRXVOelV1TnpVZ01DQXdJREVnTUNBeExqQTJiQzB6SUROaExqYzFMamMxSURBZ01DQXhMVEV1TURZZ01Gb2lJR1pwYkd3OUlpTXdNREFpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tcGFuLXN0YXJ0LWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXlOQ0lnYUdWcFoyaDBQU0l5TkNJZ2RtbGxkMEp2ZUQwaU1DQXdJREkwSURJMElpQm1hV3hzUFNKdWIyNWxJaUJ6ZEhKdmEyVTlJbU4xY25KbGJuUkRiMnh2Y2lJZ2MzUnliMnRsTFhkcFpIUm9QU0l5SWlCemRISnZhMlV0YkdsdVpXTmhjRDBpY205MWJtUWlJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUlHTnNZWE56UFNKc2RXTnBaR1VnYkhWamFXUmxMV05vWlhaeWIyNHRabWx5YzNRaVBqeHdZWFJvSUdROUltMHhOeUF4T0MwMkxUWWdOaTAySWk4K1BIQmhkR2dnWkQwaVRUY2dObll4TWlJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXBhbi1lbmQtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjRiV3h1Y3owaWFIUjBjRG92TDNkM2R5NTNNeTV2Y21jdk1qQXdNQzl6ZG1jaUlIZHBaSFJvUFNJeU5DSWdhR1ZwWjJoMFBTSXlOQ0lnZG1sbGQwSnZlRDBpTUNBd0lESTBJREkwSWlCbWFXeHNQU0p1YjI1bElpQnpkSEp2YTJVOUltTjFjbkpsYm5SRGIyeHZjaUlnYzNSeWIydGxMWGRwWkhSb1BTSXlJaUJ6ZEhKdmEyVXRiR2x1WldOaGNEMGljbTkxYm1RaUlITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpSUdOc1lYTnpQU0pzZFdOcFpHVWdiSFZqYVdSbExXTm9aWFp5YjI0dGJHRnpkQ0krUEhCaGRHZ2daRDBpYlRjZ01UZ2dOaTAyTFRZdE5pSXZQanh3WVhSb0lHUTlJazB4TnlBMmRqRXlJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi10cmVuZC1saW5lLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVFlpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQR05wY21Oc1pTQmplRDBpTWk0MUlpQmplVDBpT0NJZ2NqMGlNUzQzTlNJZ2MzUnliMnRsUFNJak1EQXdJaUJ6ZEhKdmEyVXRkMmxrZEdnOUlqRXVOU0l2UGp4amFYSmpiR1VnWTNnOUlqRXpMalVpSUdONVBTSTRJaUJ5UFNJeExqYzFJaUJ6ZEhKdmEyVTlJaU13TURBaUlITjBjbTlyWlMxM2FXUjBhRDBpTVM0MUlpOCtQSEJoZEdnZ2MzUnliMnRsUFNJak1EQXdJaUJ6ZEhKdmEyVXRkMmxrZEdnOUlqRXVOU0lnWkQwaVRUUWdPR2c0SWk4K1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24taG9yaXpvbnRhbC1saW5lLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVFlpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWsweE1DNHpPRFlnT0M0M05XRXlMalV3TVNBeUxqVXdNU0F3SURBZ01TMDBMamMzTWlBd1NDNDNOV0V1TnpVdU56VWdNQ0F3SURFZ01DMHhMalZvTkM0NE5qUmhNaTQxTURFZ01pNDFNREVnTUNBd0lERWdOQzQzTnpJZ01HZzBMamcyTkdFdU56VXVOelVnTUNBd0lERWdNQ0F4TGpWb0xUUXVPRFkwV2swNUlEaGhNU0F4SURBZ01TQXhMVElnTUNBeElERWdNQ0F3SURFZ01pQXdXaUlnWm1sc2JEMGlJekF3TUNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLXZlcnRpY2FsLWxpbmUtbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UWWlJR2hsYVdkb2REMGlNVFlpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazA0TGpjMUlEVXVOakUwWVRJdU5UQXhJREl1TlRBeElEQWdNQ0F4SURBZ05DNDNOekoyTkM0NE5qUmhMamMxTGpjMUlEQWdNQ0F4TFRFdU5TQXdkaTAwTGpnMk5HRXlMalV3TVNBeUxqVXdNU0F3SURBZ01TQXdMVFF1TnpjeVZpNDNOV0V1TnpVdU56VWdNQ0F3SURFZ01TNDFJREIyTkM0NE5qUmFUVGdnTjJFeElERWdNQ0F4SURFZ01DQXlJREVnTVNBd0lEQWdNU0F3TFRKYUlpQm1hV3hzUFNJak1EQXdJaTgrUEM5emRtYyspfS5hZy1jaGFydHMtaWNvbi1wYXJhbGxlbC1jaGFubmVsLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVGNpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWsweE5DNDBNalFnTkM0NU1tRXlMalVnTWk0MUlEQWdNU0F3TFRNdU16YzNMVEl1TVRSc0xUWXVOak1nTWk0NVlUSXVOVEF4SURJdU5UQXhJREFnTVNBd0lDNDJNRGNnTVM0ek56SnNOaTQxT0RVdE1pNDRPR0V5TGpVd01TQXlMalV3TVNBd0lEQWdNQ0F5TGpneE5TNDNORGhhYlM0d05TMHlMalk1TTJFeElERWdNQ0F4SURFdE1TNDROeTQzTURnZ01TQXhJREFnTUNBeElERXVPRGN0TGpjd09GcHRMVEV4SURRdU56VmhNU0F4SURBZ01TQXhMVEV1T0RjdU56QTRJREVnTVNBd0lEQWdNU0F4TGpnM0xTNDNNRGhhYlRFdU5UVWdOaTR3TnpWaE1pNDFNREVnTWk0MU1ERWdNQ0F4SURFdExqWXdOeTB4TGpNM01tdzJMall6TFRJdU9XRXlMalV3TVNBeUxqVXdNU0F3SURFZ01TQXVOVFl5SURFdU16a3hiQzAyTGpVNE5TQXlMamc0V20wdE1TNDFOUzB1TURjMVlURWdNU0F3SURFZ01TMHhMamczTGpjd09DQXhJREVnTUNBd0lERWdNUzQ0TnkwdU56QTRXbTB4TUM0ME1pMHpMalEyWVRFZ01TQXdJREVnTUMwdU56QTVMVEV1T0RjZ01TQXhJREFnTUNBd0lDNDNNRGdnTVM0NE4xb2lJR1pwYkd3OUlpTXdNREFpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tZGlzam9pbnQtY2hhbm5lbC1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCM2FXUjBhRDBpTVRjaUlHaGxhV2RvZEQwaU1UWWlJR1pwYkd3OUltNXZibVVpSUhodGJHNXpQU0pvZEhSd09pOHZkM2QzTG5jekxtOXlaeTh5TURBd0wzTjJaeUkrUEhCaGRHZ2dabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJqYkdsd0xYSjFiR1U5SW1WMlpXNXZaR1FpSUdROUlrMHhOQzQwTWpRZ05DNDVNbUV5TGpVZ01pNDFJREFnTVNBd0xUTXVNemd6TFRJdU5EVXpURFF1TmprZ05DNHdOVFZoTWk0MUlESXVOU0F3SURFZ01DQXVNelEwSURFdU5EWnNOaTR6T1RJdE1TNDFPVGhoTWk0MU1ERWdNaTQxTURFZ01DQXdJREFnTXlBeExqQXdNMXB0TGpBMUxUSXVOamt6WVRFZ01TQXdJREVnTVMweExqZzNMamN3T0NBeElERWdNQ0F3SURFZ01TNDROeTB1TnpBNFdtMHRNVEVnTWk0M05XRXhJREVnTUNBeElERXRNUzQ0Tnk0M01EZ2dNU0F4SURBZ01DQXhJREV1T0RjdExqY3dPRnB0TVM0MU5pQTFMalF5WVRJdU5TQXlMalVnTUNBeElEQXRMak0wTlNBeExqUTJNV3cyTGpNMU1pQXhMalU0T0dFeUxqVWdNaTQxSURBZ01TQXdJQzR6T0RRdE1TNDBOV3d0Tmk0ek9USXRNUzQxT1RoYWJTMHhMalUyTGpVek9HRXhJREVnTUNBeElEQXRNUzQ0TnkwdU56QTRJREVnTVNBd0lEQWdNQ0F4TGpnM0xqY3dPRnB0TVRBdU5ESWdNUzQwTmpGaE1TQXhJREFnTVNBeExTNDNNRGtnTVM0NE55QXhJREVnTUNBd0lERWdMamN3T0MweExqZzNXaUlnWm1sc2JEMGlJekF3TUNJdlBqd3ZjM1puUGc9PSl9LmFnLWNoYXJ0cy1pY29uLWxpbmUtY29sb3ItbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UWWlJR2hsYVdkb2REMGlNVFlpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BHY2dZMnhwY0Mxd1lYUm9QU0oxY213b0kyRXBJajQ4Y0dGMGFDQm1hV3hzTFhKMWJHVTlJbVYyWlc1dlpHUWlJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0lnWkQwaVRURXlMamM0T0M0MU9ETmhNaTQyTXlBeUxqWXpJREFnTUNBd0xURXVPRFl1TnpkTU9TNDFORFFnTWk0M016aGhMamMxTnk0M05UY2dNQ0F3SURBdExqRTBMakUwVERJdU1ETXlJREV3TGpJMWRpNHdNREZqTFM0eU5ESXVNalF4TFM0ME1pNDFNemd0TGpVeUxqZzJOR3d0TGpBd01pNHdNREl0TGpnNElESXVPVEF5TFM0d01ERXVNREF6WVRFdU1EZ3pJREV1TURneklEQWdNQ0F3SURFdU16VWdNUzR6TkRkb0xqQXdNV3d5TGprd01pMHVPRGhvTGpBd01XTXVNekkyTFM0eExqWXlNeTB1TWpjM0xqZzJOUzB1TlRFNGRpMHVNREF4YkRjdU16YzFMVGN1TXpjMllTNDNOak11TnpZeklEQWdNQ0F3SUM0eE16a3RMakV6T1d3eExqTTROQzB4TGpNNE5FRXlMall6SURJdU5qTWdNQ0F3SURBZ01USXVOemc0TGpVNE0xcHRMUzR4TWpZZ05DNHpOVEl1T1RJMExTNDVNalJoTVM0eE15QXhMakV6SURBZ01DQXdMVEV1TlRrM0xURXVOVGszYkMwdU9USTBMamt5TkNBeExqVTVOeUF4TGpVNU4xcHRMVEl1TmpVM0xTNDFNell0Tmk0NU1UTWdOaTQ1TVRSSU15NHdPV0V1TlRnekxqVTRNeUF3SURBZ01DMHVNVFEyTGpJME1td3RMalkxTXlBeUxqRTFNeUF5TGpFMU5TMHVOalUwWVM0MU9ETXVOVGd6SURBZ01DQXdJQzR5TkRFdExqRTBOR3cyTGpreE5DMDJMamt4TkMweExqVTVOeTB4TGpVNU4xb2lJR1pwYkd3OUlpTXdNREFpTHo0OEwyYytQR1JsWm5NK1BHTnNhWEJRWVhSb0lHbGtQU0poSWo0OGNHRjBhQ0JtYVd4c1BTSWpabVptSWlCa1BTSk5NQ0F3YURFMmRqRTJTREI2SWk4K1BDOWpiR2x3VUdGMGFENDhMMlJsWm5NK1BDOXpkbWMrKX0uYWctY2hhcnRzLWljb24tZGVsZXRlLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVFlpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWswMkxqQTRNeUF5TGpZMk4yTXdMUzR3T1M0d05UTXRMakkwTWk0eE9UY3RMak00Tnk0eE5EVXRMakUwTkM0eU9UY3RMakU1Tnk0ek9EY3RMakU1TjJneUxqWTJOMk11TURnNUlEQWdMakkwTVM0d05UTXVNemcyTGpFNU55NHhORFV1TVRRMUxqRTVOeTR5T1RjdU1UazNMak00TjNZdU5UZ3pTRFl1TURnMGRpMHVOVGd6V2swMUxqTXpJRFF1TnpWSU1URXVPVEUzZGpndU5UZ3pZekFnTGpBNUxTNHdOVEl1TWpReUxTNHhPVGN1TXpnM0xTNHhORFV1TVRRMExTNHlPVGN1TVRrM0xTNHpPRFl1TVRrM1NEUXVOalkzWXkwdU1Ea2dNQzB1TWpReUxTNHdOVE10TGpNNE55MHVNVGszTFM0eE5EUXRMakUwTlMwdU1UazNMUzR5T1RjdExqRTVOeTB1TXpnM1ZqUXVOelZJTlM0ek0xcHRMUzQzTkRVdE1TNDFkaTB1TlRnell6QXRMalUzT0M0eU9DMHhMakE1TWk0Mk16WXRNUzQwTkRjdU16VTFMUzR6TlRZdU9EY3RMall6TnlBeExqUTBOeTB1TmpNM2FESXVOalkzWXk0MU56Y2dNQ0F4TGpBNU1TNHlPREVnTVM0ME5EY3VOak0zTGpNMU5TNHpOVFV1TmpNMkxqZzNMall6TmlBeExqUTBOM1l1TlRnelNERTBZUzQzTlM0M05TQXdJREFnTVNBd0lERXVOV2d0TGpVNE0zWTRMalU0TTJNd0lDNDFOemd0TGpJNE1TQXhMakE1TWkwdU5qTTJJREV1TkRRM0xTNHpOVFl1TXpVMkxTNDROeTQyTXpjdE1TNDBORGN1TmpNM1NEUXVOalkzWXkwdU5UYzNJREF0TVM0d09USXRMakk0TVMweExqUTBOeTB1TmpNM0xTNHpOVFV0TGpNMU5TMHVOak0zTFM0NE55MHVOak0zTFRFdU5EUTNWalF1TnpWSU1tRXVOelV1TnpVZ01DQXdJREVnTUMweExqVm9NaTQxT0ROYWJUSXVNRGd6SURNdU16TXpZUzQzTlM0M05TQXdJREFnTVNBdU56VXVOelYyTkdFdU56VXVOelVnTUNBeElERXRNUzQxSURCMkxUUmhMamMxTGpjMUlEQWdNQ0F4SUM0M05TMHVOelZhYlRNdU5ERTNMamMxWVM0M05TNDNOU0F3SURBZ01DMHhMalVnTUhZMFlTNDNOUzQzTlNBd0lERWdNQ0F4TGpVZ01IWXRORm9pSUdacGJHdzlJaU13TURBaUx6NDhMM04yWno0PSl9LmFnLWNoYXJ0cy1pY29uLWxvY2stbGVnYWN5ey0taWNvbjogdXJsKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QjNhV1IwYUQwaU1UWWlJR2hsYVdkb2REMGlNVFlpSUdacGJHdzlJbTV2Ym1VaUlIaHRiRzV6UFNKb2RIUndPaTh2ZDNkM0xuY3pMbTl5Wnk4eU1EQXdMM04yWnlJK1BIQmhkR2dnWm1sc2JDMXlkV3hsUFNKbGRtVnViMlJrSWlCamJHbHdMWEoxYkdVOUltVjJaVzV2WkdRaUlHUTlJazAyTGpFM015QXlMamcwWVRJdU5UZ3pJREl1TlRneklEQWdNQ0F4SURRdU5ERWdNUzQ0TWpkMk1TNDVNVFpJTlM0ME1UWldOQzQyTmpkak1DMHVOamcxTGpJM015MHhMak0wTXk0M05UY3RNUzQ0TWpkYVRUTXVPVEUzSURZdU5UZ3pWalF1TmpZM1lUUXVNRGd6SURRdU1EZ3pJREFnTUNBeElEZ3VNVFkySURCMk1TNDVNVFpvTGpVNE5HTXhMakUxSURBZ01pNHdPRE11T1RNeklESXVNRGd6SURJdU1EZzBkalF1TmpZMll6QWdNUzR4TlMwdU9UTXpJREl1TURnMExUSXVNRGd6SURJdU1EZzBTRE11TXpNellUSXVNRGd6SURJdU1EZ3pJREFnTUNBeExUSXVNRGd6TFRJdU1EZzBWamd1TmpZM1l6QXRNUzR4TlRFdU9UTXpMVEl1TURnMElESXVNRGd6TFRJdU1EZzBhQzQxT0ROYWJUY3VOREUySURFdU5XZ3RPR0V1TlRnekxqVTRNeUF3SURBZ01DMHVOVGd6TGpVNE5IWTBMalkyTm1Nd0lDNHpNakl1TWpZeExqVTROQzQxT0RNdU5UZzBhRGt1TXpNMFlTNDFPRE11TlRneklEQWdNQ0F3SUM0MU9ETXRMalU0TkZZNExqWTJOMkV1TlRnekxqVTRNeUF3SURBZ01DMHVOVGd6TFM0MU9EUm9MVEV1TXpNMFdpSWdabWxzYkQwaUl6QXdNQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tdW5sb2NrLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNVGNpSUdobGFXZG9kRDBpTVRZaUlHWnBiR3c5SW01dmJtVWlJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQSEJoZEdnZ1ptbHNiQzF5ZFd4bFBTSmxkbVZ1YjJSa0lpQmpiR2x3TFhKMWJHVTlJbVYyWlc1dlpHUWlJR1E5SWswMkxqa3lNeUF5TGpnMFlUSXVOVGd6SURJdU5UZ3pJREFnTUNBeElETXVOalV6SURBZ015QXpJREFnTUNBeElDNDFOeTQzT1RoakxqRXpOQzR5TnpndU1UY3VORGMwTGpFM0xqVTBOV0V1TnpVdU56VWdNQ0F3SURBZ01TNDFJREJqTUMwdU16Z3hMUzR4TXpJdExqZ3dPUzB1TXpJdE1TNHhPVGhoTkM0MU1ERWdOQzQxTURFZ01DQXdJREF0TGpnMU9TMHhMakl3TmlBMExqQTRNeUEwTGpBNE15QXdJREFnTUMwMkxqazNJREl1T0RnNGRqRXVPVEUyYUMwdU5UZzBRekl1T1RNeklEWXVOVGd6SURJZ055NDFNVFlnTWlBNExqWTJOM1kwTGpZMk5tTXdJREV1TVRVdU9UTXpJREl1TURnMElESXVNRGd6SURJdU1EZzBhRGt1TXpNMFl6RXVNVFVnTUNBeUxqQTRNeTB1T1RNeklESXVNRGd6TFRJdU1EZzBWamd1TmpZM1l6QXRNUzR4TlRFdExqa3pNeTB5TGpBNE5DMHlMakE0TXkweUxqQTROR2d0Tnk0eU5WWTBMalkyTjJNd0xTNDJPRFV1TWpjeUxURXVNelF6TGpjMU5pMHhMamd5TjFwTk5TNDBNVGNnT0M0d09ETklOQzR3T0RKaExqVTRNeTQxT0RNZ01DQXdJREF0TGpVNE15NDFPRFIyTkM0Mk5qWmpNQ0F1TXpJeUxqSTJNUzQxT0RRdU5UZ3pMalU0TkdnNUxqTXpOR0V1TlRnekxqVTRNeUF3SURBZ01DQXVOVGd6TFM0MU9EUldPQzQyTmpkaExqVTRNeTQxT0RNZ01DQXdJREF0TGpVNE15MHVOVGcwYUMwNFdpSWdabWxzYkQwaUl6QXdNQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWljb24tcGx1cy1sZWdhY3l7LS1pY29uOiB1cmwoZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpSUhkcFpIUm9QU0l5TkNJZ2FHVnBaMmgwUFNJeU5DSWdkbWxsZDBKdmVEMGlNQ0F3SURJMElESTBJaUJtYVd4c1BTSnViMjVsSWlCemRISnZhMlU5SW1OMWNuSmxiblJEYjJ4dmNpSWdjM1J5YjJ0bExYZHBaSFJvUFNJeUlpQnpkSEp2YTJVdGJHbHVaV05oY0QwaWNtOTFibVFpSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlJR05zWVhOelBTSnNkV05wWkdVZ2JIVmphV1JsTFhCc2RYTWlQanh3WVhSb0lHUTlJazAxSURFeWFERTBJaTgrUEhCaGRHZ2daRDBpVFRFeUlEVjJNVFFpTHo0OEwzTjJaejQ9KX0uYWctY2hhcnRzLWljb24tY3Jvc3NsaW5lLWFkZC1saW5lLWxlZ2FjeXstLWljb246IHVybChkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUI0Yld4dWN6MGlhSFIwY0RvdkwzZDNkeTUzTXk1dmNtY3ZNakF3TUM5emRtY2lJSGRwWkhSb1BTSXhOaUlnYUdWcFoyaDBQU0l4TmlJZ1ptbHNiRDBpYm05dVpTSStQSEJoZEdnZ1ptbHNiRDBpSXpBd01DSWdabWxzYkMxeWRXeGxQU0psZG1WdWIyUmtJaUJrUFNKTk9DNDNOU0EwTGpWaExqYzFMamMxSURBZ01DQXdMVEV1TlNBd2RqSXVOelZJTkM0MVlTNDNOUzQzTlNBd0lEQWdNQ0F3SURFdU5XZ3lMamMxZGpJdU56VmhMamMxTGpjMUlEQWdNQ0F3SURFdU5TQXdWamd1TnpWb01pNDNOV0V1TnpVdU56VWdNQ0F3SURBZ01DMHhMalZJT0M0M05Yb2lJR05zYVhBdGNuVnNaVDBpWlhabGJtOWtaQ0l2UGp3dmMzWm5QZz09KX0uYWctY2hhcnRzLWZvY3VzLmFnLWNoYXJ0cy1mb2N1c19faW5kaWNhdG9ye3Bvc2l0aW9uOmFic29sdXRlO2Rpc3BsYXk6YmxvY2s7cG9pbnRlci1ldmVudHM6bm9uZTt1c2VyLXNlbGVjdDpub25lO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCV9LmFnLWNoYXJ0cy1mb2N1cy5hZy1jaGFydHMtZm9jdXNfX2luZGljYXRvcj5kaXZ7cG9zaXRpb246YWJzb2x1dGU7b3V0bGluZTp2YXIoLS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyKTtvdXRsaW5lLXdpZHRoOjJweDtib3gtc2hhZG93OnZhcigtLWFnLWNoYXJ0cy1mb2N1cy1ib3JkZXItc2hhZG93KX0uYWctY2hhcnRzLWZvY3VzLmFnLWNoYXJ0cy1mb2N1c19faW5kaWNhdG9yPnN2Z3t3aWR0aDoxMDAlO2hlaWdodDoxMDAlO2ZpbGw6bm9uZTtzdHJva2U6dmFyKC0tYWctY2hhcnRzLWZvY3VzLWJvcmRlci1jb2xvcik7c3Ryb2tlLXdpZHRoOjJweH0uYWctY2hhcnRzLWZvY3VzLS1oaWRkZW57dmlzaWJpbGl0eTpoaWRkZW59LmFnLWNoYXJ0cy10b29sYmFye2FsaWduLWl0ZW1zOmNlbnRlcjtiYWNrZ3JvdW5kOm5vbmU7Ym9yZGVyOm5vbmU7ZGlzcGxheTpmbGV4O2ZsZXgtd3JhcDpub3dyYXA7b3BhY2l0eToxO3Bvc2l0aW9uOmFic29sdXRlO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApO3RyYW5zaXRpb246b3BhY2l0eSAuMnMgZWFzZS1pbi1vdXQsdHJhbnNmb3JtIC4ycyBlYXNlLWluLW91dH0uYWctY2hhcnRzLXRvb2xiYXItLWhpZGRlbiwuYWctY2hhcnRzLXRvb2xiYXItLXByZXZlbnQtZmxhc2h7dmlzaWJpbGl0eTpoaWRkZW59LmFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZy1oaWRkZW57b3BhY2l0eTowO3RyYW5zaXRpb246b3BhY2l0eSAuNHMgZWFzZS1pbi1vdXR9LmFnLWNoYXJ0cy10b29sYmFyLS1zbWFsbHstLWFnLWNoYXJ0cy10b29sYmFyLXNpemU6IHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLXNpemUtc21hbGwpOy0tYWctY2hhcnRzLXRvb2xiYXItZm9udC1zaXplOiB2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1mb250LXNpemUtc21hbGwpOy0tYWctY2hhcnRzLXRvb2xiYXItYnV0dG9uLXBhZGRpbmc6IHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWJ1dHRvbi1wYWRkaW5nLXNtYWxsKX0uYWctY2hhcnRzLXRvb2xiYXItLXRvcCwuYWctY2hhcnRzLXRvb2xiYXItLWJvdHRvbXtmbGV4LWRpcmVjdGlvbjpyb3c7d2lkdGg6MTAwJX0uYWctY2hhcnRzLXRvb2xiYXItLWxlZnQsLmFnLWNoYXJ0cy10b29sYmFyLS1yaWdodHtmbGV4LWRpcmVjdGlvbjpjb2x1bW59LmFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZywuYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLXRvcCwuYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLWJvdHRvbXtiYWNrZ3JvdW5kOm5vbmU7Ym9yZGVyOm5vbmU7ZmxleC1kaXJlY3Rpb246cm93O3BvaW50ZXItZXZlbnRzOm5vbmU7d2lkdGg6MTAwJX0uYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5ne3BhZGRpbmc6MDt3aWR0aDphdXRvO3otaW5kZXg6dmFyKC0tYWctY2hhcnRzLWxheWVyLXRvb2xiYXIpfS5hZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmctdG9we2hlaWdodDpjYWxjKHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLXNpemUpICsgMTBweCk7cGFkZGluZy10b3A6MTBweH0uYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLWJvdHRvbXtoZWlnaHQ6Y2FsYyh2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1zaXplKSArIDEwcHgpO3BhZGRpbmctYm90dG9tOjEwcHg7b3ZlcmZsb3c6aGlkZGVufS5hZy1jaGFydHMtdG9vbGJhcl9fYWxpZ257ZGlzcGxheTpmbGV4O2ZsZXgtZGlyZWN0aW9uOmluaGVyaXQ7ZmxleC13cmFwOmluaGVyaXQ7Z2FwOnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWdhcCk7bWF4LXdpZHRoOjEwMCU7d2lkdGg6MTAwJX0uYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduLS1zdGFydHtqdXN0aWZ5LWNvbnRlbnQ6c3RhcnR9LmFnLWNoYXJ0cy10b29sYmFyX19hbGlnbi0tY2VudGVye2p1c3RpZnktY29udGVudDpjZW50ZXJ9LmFnLWNoYXJ0cy10b29sYmFyX19hbGlnbi0tZW5ke2p1c3RpZnktY29udGVudDplbmR9LmFnLWNoYXJ0cy10b29sYmFyX19hbGlnbi0tY2VudGVyLC5hZy1jaGFydHMtdG9vbGJhcl9fYWxpZ24tLWVuZHttYXJnaW4tbGVmdDphdXRvfS5hZy1jaGFydHMtdG9vbGJhci0tbGVmdCAuYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduLS1jZW50ZXIsLmFnLWNoYXJ0cy10b29sYmFyLS1sZWZ0IC5hZy1jaGFydHMtdG9vbGJhcl9fYWxpZ24tLWVuZCwuYWctY2hhcnRzLXRvb2xiYXItLXJpZ2h0IC5hZy1jaGFydHMtdG9vbGJhcl9fYWxpZ24tLWNlbnRlciwuYWctY2hhcnRzLXRvb2xiYXItLXJpZ2h0IC5hZy1jaGFydHMtdG9vbGJhcl9fYWxpZ24tLWVuZHttYXJnaW4tbGVmdDowO21hcmdpbi10b3A6YXV0b30uYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLXRvcCAuYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduLC5hZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmctYm90dG9tIC5hZy1jaGFydHMtdG9vbGJhcl9fYWxpZ257dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjRzIGVhc2UtaW4tb3V0O3dpZHRoOmF1dG99LmFnLWNoYXJ0cy10b29sYmFyX19zZWN0aW9ue2Rpc3BsYXk6aW5oZXJpdDtmbGV4LWRpcmVjdGlvbjppbmhlcml0O2ZsZXgtd3JhcDppbmhlcml0O2p1c3RpZnktY29udGVudDppbmhlcml0O21heC13aWR0aDppbmhlcml0O3dpZHRoOmluaGVyaXR9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b257LS10cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIC4yNXMgZWFzZS1pbi1vdXQsIGJvcmRlci1jb2xvciAuMjVzIGVhc2UtaW4tb3V0LCBjb2xvciAuMjVzIGVhc2UtaW4tb3V0O2FsaWduLWl0ZW1zOmNlbnRlcjtiYWNrZ3JvdW5kOnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWJhY2tncm91bmQtY29sb3IpO2JvcmRlcjp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1ib3JkZXIpO2NvbG9yOnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWZvcmVncm91bmQtY29sb3IpO2Rpc3BsYXk6ZmxleDtmb250OnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWZvbnQtc2l6ZSkgdmFyKC0tYWctY2hhcnRzLWZvbnQtZmFtaWx5KTtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO21hcmdpbjowIDAgMCAtMXB4O21pbi1oZWlnaHQ6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItc2l6ZSk7bWluLXdpZHRoOnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLXNpemUpO3BhZGRpbmc6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYnV0dG9uLXBhZGRpbmcpO3BvaW50ZXItZXZlbnRzOmFsbDtwb3NpdGlvbjpyZWxhdGl2ZTt0cmFuc2l0aW9uOnZhcigtLXRyYW5zaXRpb24pO3doaXRlLXNwYWNlOm5vd3JhcH0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbltkYXRhLXRvb2xiYXItZ3JvdXA9cmFuZ2VzXXtwYWRkaW5nOnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWJ1dHRvbi1wYWRkaW5nKSBjYWxjKHZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWJ1dHRvbi1wYWRkaW5nKSAqIDEuNSl9LmFnLWNoYXJ0cy10b29sYmFyLS10b3AsLmFnLWNoYXJ0cy10b29sYmFyLS1ib3R0b20sLmFnLWNoYXJ0cy10b29sYmFyLS1mbG9hdGluZywuYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLXRvcCwuYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLWJvdHRvbXsuYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbjpudGgtY2hpbGQoMSBvZjpub3QoLmFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWhpZGRlbi10b2dnbGVkKSl7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czp2YXIoLS1hZy1jaGFydHMtYnV0dG9uLXJhZGl1cyk7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czp2YXIoLS1hZy1jaGFydHMtYnV0dG9uLXJhZGl1cyk7bWFyZ2luOjB9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b246bnRoLWxhc3QtY2hpbGQoMSBvZjpub3QoLmFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWhpZGRlbi10b2dnbGVkKSl7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6dmFyKC0tYWctY2hhcnRzLWJ1dHRvbi1yYWRpdXMpO2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOnZhcigtLWFnLWNoYXJ0cy1idXR0b24tcmFkaXVzKX19LmFnLWNoYXJ0cy10b29sYmFyLS1sZWZ0LC5hZy1jaGFydHMtdG9vbGJhci0tcmlnaHR7LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b257Ym9yZGVyLXJhZGl1czowO21hcmdpbjotMXB4IDAgMDttYXgtd2lkdGg6MTAwJX0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbjpudGgtY2hpbGQoMSBvZjpub3QoLmFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWhpZGRlbi10b2dnbGVkKSl7Ym9yZGVyLXRvcC1sZWZ0LXJhZGl1czp2YXIoLS1hZy1jaGFydHMtYnV0dG9uLXJhZGl1cyk7Ym9yZGVyLXRvcC1yaWdodC1yYWRpdXM6dmFyKC0tYWctY2hhcnRzLWJ1dHRvbi1yYWRpdXMpO21hcmdpbjowfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uOm50aC1sYXN0LWNoaWxkKDEgb2Y6bm90KC5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1oaWRkZW4tdG9nZ2xlZCkpe2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6dmFyKC0tYWctY2hhcnRzLWJ1dHRvbi1yYWRpdXMpO2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOnZhcigtLWFnLWNoYXJ0cy1idXR0b24tcmFkaXVzKX19LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWhpZGRlbi12YWx1ZSwuYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0taGlkZGVuLXRvZ2dsZWR7ZGlzcGxheTpub25lfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uOmhvdmVye2JhY2tncm91bmQ6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItaG92ZXItY29sb3IpO3otaW5kZXg6MX0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbjpmb2N1cy12aXNpYmxle2JvcmRlci1jb2xvcjp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1mb2N1cy1jb2xvcik7Ym94LXNoYWRvdzp2YXIoLS1hZy1jaGFydHMtZm9jdXMtYm9yZGVyLXNoYWRvdyk7ei1pbmRleDozfS5hZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLmFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWFjdGl2ZXtiYWNrZ3JvdW5kOnZhcigtLWFnLWNoYXJ0cy10b29sYmFyLWFjdGl2ZS1iYWNrZ3JvdW5kLWNvbG9yKTtib3JkZXItY29sb3I6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItYWN0aXZlLWNvbG9yKTtjb2xvcjp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1hY3RpdmUtY29sb3IpO3otaW5kZXg6Mn0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvblthcmlhLWRpc2FibGVkPXRydWVde2JhY2tncm91bmQ6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItZGlzYWJsZWQtYmFja2dyb3VuZC1jb2xvcik7Y29sb3I6dmFyKC0tYWctY2hhcnRzLXRvb2xiYXItZGlzYWJsZWQtZm9yZWdyb3VuZC1jb2xvcil9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b246bm90KFthcmlhLWRpc2FibGVkPXRydWVdKXtjdXJzb3I6cG9pbnRlcn0uYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0tZmlsbC12aXNpYmxlOmFmdGVye2NvbnRlbnQ6XCJcIjtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO2JvdHRvbTozcHg7bGVmdDo1cHg7cmlnaHQ6NXB4O2hlaWdodDo0cHg7Ym9yZGVyLXJhZGl1czo5OXB4O2JveC1zaGFkb3c6aW5zZXQgMCAwIDAgMXB4IGNvbG9yLW1peChpbiBzcmdiLHZhcigtLWFnLWNoYXJ0cy1mb3JlZ3JvdW5kLWNvbG9yKSAxMCUsdHJhbnNwYXJlbnQpO2JhY2tncm91bmQ6dmFyKC0tZmlsbCl9LmFnLWNoYXJ0cy10b29sYmFyX19idXR0b24tLWZpbGwtdmlzaWJsZVthcmlhLWRpc2FibGVkPXRydWVdOmFmdGVye2ZpbHRlcjpncmF5c2NhbGUoMSk7b3BhY2l0eTouNX0uYWctY2hhcnRzLXRvb2xiYXJfX2ljb24rLmFnLWNoYXJ0cy10b29sYmFyX19sYWJlbHttYXJnaW4tbGVmdDp2YXIoLS1hZy1jaGFydHMtdG9vbGJhci1nYXApfS5hZy1jaGFydHMtdG9vbGJhcl9faWNvbiwuYWctY2hhcnRzLXRvb2xiYXJfX2xhYmVse3BvaW50ZXItZXZlbnRzOm5vbmV9LmFnLWNoYXJ0LW92ZXJsYXl7Y29sb3I6IzE4MWQxZjtwb2ludGVyLWV2ZW50czpub25lfS5hZy1jaGFydC1vdmVybGF5LmFnLWNoYXJ0LWRhcmstb3ZlcmxheXtjb2xvcjojZmZmfS5hZy1jaGFydC1vdmVybGF5LS1sb2FkaW5ne2NvbG9yOiM4YzhjOGN9LmFnLWNoYXJ0LW92ZXJsYXlfX2xvYWRpbmctYmFja2dyb3VuZHtiYWNrZ3JvdW5kOiNmZmY7cG9pbnRlci1ldmVudHM6bm9uZX0uYWctY2hhcnQtb3ZlcmxheS5hZy1jaGFydC1kYXJrLW92ZXJsYXkgLmFnLWNoYXJ0LW92ZXJsYXlfX2xvYWRpbmctYmFja2dyb3VuZHtiYWNrZ3JvdW5kOiMxOTIyMzJ9LmFnLWNoYXJ0LXRvb2x0aXB7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjFzIGVhc2U7d2lkdGg6bWF4LWNvbnRlbnQ7ei1pbmRleDo5OTk5OTtmb250OjEycHggVmVyZGFuYSxzYW5zLXNlcmlmO2NvbG9yOiM0NjQ2NDY7Ym94LXNoYWRvdzowIDRweCA4cHggIzAwMDAwMDE0fS5hZy1jaGFydC10b29sdGlwLXdyYXAtYWx3YXlze292ZXJmbG93LXdyYXA6YnJlYWstd29yZDt3b3JkLWJyZWFrOmJyZWFrLXdvcmQ7aHlwaGVuczpub25lfS5hZy1jaGFydC10b29sdGlwLXdyYXAtaHlwaGVuYXRle292ZXJmbG93LXdyYXA6YnJlYWstd29yZDt3b3JkLWJyZWFrOmJyZWFrLXdvcmQ7aHlwaGVuczphdXRvfS5hZy1jaGFydC10b29sdGlwLXdyYXAtb24tc3BhY2V7b3ZlcmZsb3ctd3JhcDpub3JtYWw7d29yZC1icmVhazpub3JtYWx9LmFnLWNoYXJ0LXRvb2x0aXAtd3JhcC1uZXZlcnt3aGl0ZS1zcGFjZTpwcmU7dGV4dC1vdmVyZmxvdzplbGxpcHNpc30uYWctY2hhcnQtdG9vbHRpcC1uby1pbnRlcmFjdGlvbntwb2ludGVyLWV2ZW50czpub25lO3VzZXItc2VsZWN0Om5vbmV9LmFnLWNoYXJ0LXRvb2x0aXAtbm8tYW5pbWF0aW9ue3RyYW5zaXRpb246bm9uZSFpbXBvcnRhbnR9LmFnLWNoYXJ0LXRvb2x0aXAtaGlkZGVue3Zpc2liaWxpdHk6aGlkZGVufS5hZy1jaGFydC10b29sdGlwLXRpdGxle292ZXJmbG93OmhpZGRlbjtwb3NpdGlvbjpyZWxhdGl2ZTtwYWRkaW5nOjhweCAxNHB4O2JvcmRlci10b3AtbGVmdC1yYWRpdXM6MnB4O2JvcmRlci10b3AtcmlnaHQtcmFkaXVzOjJweDtjb2xvcjojZmZmO2JhY2tncm91bmQtY29sb3I6Izg4ODt6LWluZGV4OjE7dGV4dC1vdmVyZmxvdzppbmhlcml0fS5hZy1jaGFydC10b29sdGlwLXRpdGxlOm9ubHktY2hpbGR7Ym9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czoycHg7Ym9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXM6MnB4fS5hZy1jaGFydC10b29sdGlwLWNvbnRlbnR7b3ZlcmZsb3c6aGlkZGVuO3BhZGRpbmc6NnB4IDE0cHg7bGluZS1oZWlnaHQ6MS43ZW07YmFja2dyb3VuZDojZmZmO2JvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6MnB4O2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOjJweDtib3JkZXI6MXB4IHNvbGlkIHJnYmEoMCwwLDAsLjE1KTt0ZXh0LW92ZXJmbG93OmluaGVyaXR9LmFnLWNoYXJ0LXRvb2x0aXAtYXJyb3c6YmVmb3Jle2NvbnRlbnQ6XCJcIjtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MTAwJTtsZWZ0OjUwJTt0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUpO2JvcmRlcjo1cHggc29saWQgI2Q5ZDlkOTtib3JkZXItbGVmdC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItcmlnaHQtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLWJvdHRvbS1jb2xvcjp0cmFuc3BhcmVudDt3aWR0aDowO2hlaWdodDowO21hcmdpbjowIGF1dG99LmFnLWNoYXJ0LXRvb2x0aXAtYXJyb3c6YWZ0ZXJ7Y29udGVudDpcIlwiO3Bvc2l0aW9uOmFic29sdXRlO3RvcDpjYWxjKDEwMCUgLSAxcHgpO2xlZnQ6NTAlO3RyYW5zZm9ybTp0cmFuc2xhdGUoLTUwJSk7Ym9yZGVyOjVweCBzb2xpZCB3aGl0ZTtib3JkZXItbGVmdC1jb2xvcjp0cmFuc3BhcmVudDtib3JkZXItcmlnaHQtY29sb3I6dHJhbnNwYXJlbnQ7Ym9yZGVyLWJvdHRvbS1jb2xvcjp0cmFuc3BhcmVudDt3aWR0aDowO2hlaWdodDowO21hcmdpbjowIGF1dG99XFxuJztcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9ndWFyZGVkRWxlbWVudC50c1xudmFyIEd1YXJkZWRFbGVtZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50MiwgdG9wVGFiR3VhcmQsIGJvdHRvbVRhYkd1YXJkKSB7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDI7XG4gICAgdGhpcy50b3BUYWJHdWFyZCA9IHRvcFRhYkd1YXJkO1xuICAgIHRoaXMuYm90dG9tVGFiR3VhcmQgPSBib3R0b21UYWJHdWFyZDtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLmd1YXJkVGFiSW5kZXggPSAwO1xuICAgIHRoaXMuZWxlbWVudC50YWJJbmRleCA9IC0xO1xuICAgIHRoaXMuaW5pdEV2ZW50TGlzdGVuZXIodGhpcy5lbGVtZW50LCBcImJsdXJcIiwgKCkgPT4gdGhpcy5vbkJsdXIoKSk7XG4gICAgdGhpcy5pbml0RXZlbnRMaXN0ZW5lcih0aGlzLmVsZW1lbnQsIFwiZm9jdXNcIiwgKCkgPT4gdGhpcy5vbkZvY3VzKCkpO1xuICAgIHRoaXMuaW5pdEV2ZW50TGlzdGVuZXIodGhpcy50b3BUYWJHdWFyZCwgXCJmb2N1c1wiLCAoZXYpID0+IHRoaXMub25UYWJTdGFydChldiwgdGhpcy50b3BUYWJHdWFyZCkpO1xuICAgIHRoaXMuaW5pdEV2ZW50TGlzdGVuZXIodGhpcy5ib3R0b21UYWJHdWFyZCwgXCJmb2N1c1wiLCAoZXYpID0+IHRoaXMub25UYWJTdGFydChldiwgdGhpcy5ib3R0b21UYWJHdWFyZCkpO1xuICB9XG4gIHNldCB0YWJJbmRleChpbmRleCkge1xuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLmd1YXJkVGFiSW5kZXggPSBpbmRleDtcbiAgICB9XG4gICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgdGhpcy50b3BUYWJHdWFyZC50YWJJbmRleCA9IGluZGV4O1xuICAgICAgdGhpcy5ib3R0b21UYWJHdWFyZC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudG9wVGFiR3VhcmQudGFiSW5kZXggPSBpbmRleDtcbiAgICAgIHRoaXMuYm90dG9tVGFiR3VhcmQudGFiSW5kZXggPSBpbmRleDtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IGZuIG9mIHRoaXMuZGVzdHJveUZucylcbiAgICAgIGZuKCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmxlbmd0aCA9IDA7XG4gIH1cbiAgaW5pdEV2ZW50TGlzdGVuZXIoZWxlbSwgdHlwZSwgaGFuZGxlcikge1xuICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaCgoKSA9PiBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcikpO1xuICB9XG4gIG9uQmx1cigpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50LnRhYkluZGV4ID09PSAtMSkge1xuICAgICAgdGhpcy50YWJJbmRleCA9IHRoaXMuZ3VhcmRUYWJJbmRleDtcbiAgICAgIHRoaXMuZ3VhcmRUYXJnZXQgPSB2b2lkIDA7XG4gICAgICB0aGlzLmd1ZXNzZWREZWx0YSA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgb25Gb2N1cygpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50LnRhYkluZGV4ID09PSAtMSkge1xuICAgICAgdGhpcy50YWJJbmRleCA9IC0xO1xuICAgIH1cbiAgfVxuICBvblRhYlN0YXJ0KGV2ZW50LCB0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0LnRhYkluZGV4ID4gMCkge1xuICAgICAgdGhpcy5ndWVzc2VkRGVsdGEgPSAwO1xuICAgICAgaWYgKGV2ZW50LnJlbGF0ZWRUYXJnZXQgIT0gbnVsbCAmJiBcInRhYkluZGV4XCIgaW4gZXZlbnQucmVsYXRlZFRhcmdldCkge1xuICAgICAgICBjb25zdCBwcmV2VGFiSW5kZXggPSBOdW1iZXIoZXZlbnQucmVsYXRlZFRhcmdldFtcInRhYkluZGV4XCJdKTtcbiAgICAgICAgaWYgKCFpc05hTihwcmV2VGFiSW5kZXgpICYmIHByZXZUYWJJbmRleCA+IDApIHtcbiAgICAgICAgICB0aGlzLmd1ZXNzZWREZWx0YSA9IHByZXZUYWJJbmRleCA8IHRhcmdldC50YWJJbmRleCA/IDEgOiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmd1YXJkVGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuZWxlbWVudC5mb2N1cygpO1xuICB9XG4gIGdldEJyb3dzZXJGb2N1c0RlbHRhKCkge1xuICAgIGNvbnN0IHsgZ3Vlc3NlZERlbHRhLCBndWFyZFRhcmdldCwgdG9wVGFiR3VhcmQsIGJvdHRvbVRhYkd1YXJkOiBib3RUYWJHdWFyZCB9ID0gdGhpcztcbiAgICBpZiAoZ3Vlc3NlZERlbHRhICE9PSB2b2lkIDApXG4gICAgICByZXR1cm4gZ3Vlc3NlZERlbHRhO1xuICAgIGlmIChndWFyZFRhcmdldCA9PT0gdG9wVGFiR3VhcmQpXG4gICAgICByZXR1cm4gMTtcbiAgICBpZiAoZ3VhcmRUYXJnZXQgPT09IGJvdFRhYkd1YXJkKVxuICAgICAgcmV0dXJuIC0xO1xuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3NpemVNb25pdG9yLnRzXG52YXIgU2l6ZU1vbml0b3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZWxlbWVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuZG9jdW1lbnRSZWFkeSA9IGZhbHNlO1xuICAgIHRoaXMucXVldWVkT2JzZXJ2ZVJlcXVlc3RzID0gW107XG4gICAgdGhpcy5vbkxvYWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmRvY3VtZW50UmVhZHkgPSB0cnVlO1xuICAgICAgdGhpcy5xdWV1ZWRPYnNlcnZlUmVxdWVzdHMuZm9yRWFjaCgoW2VsLCBjYl0pID0+IHRoaXMub2JzZXJ2ZShlbCwgY2IpKTtcbiAgICAgIHRoaXMucXVldWVkT2JzZXJ2ZVJlcXVlc3RzID0gW107XG4gICAgfTtcbiAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGNvbnRlbnRSZWN0OiB7IHdpZHRoLCBoZWlnaHQgfVxuICAgICAgfSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5lbGVtZW50cy5nZXQodGFyZ2V0KTtcbiAgICAgICAgdGhpcy5jaGVja1NpemUoZW50cnksIHRhcmdldCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5kb2N1bWVudFJlYWR5ID0gZ2V0RG9jdW1lbnQoXCJyZWFkeVN0YXRlXCIpID09PSBcImNvbXBsZXRlXCI7XG4gICAgaWYgKCF0aGlzLmRvY3VtZW50UmVhZHkpIHtcbiAgICAgIGdldFdpbmRvdygpPy5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCB0aGlzLm9uTG9hZCk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZ2V0V2luZG93KCk/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHRoaXMub25Mb2FkKTtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gICAgdGhpcy5yZXNpemVPYnNlcnZlciA9IG51bGw7XG4gIH1cbiAgY2hlY2tTaXplKGVudHJ5LCBlbGVtZW50Miwgd2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghZW50cnkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHdpZHRoICE9PSBlbnRyeS5zaXplPy53aWR0aCB8fCBoZWlnaHQgIT09IGVudHJ5LnNpemU/LmhlaWdodCkge1xuICAgICAgZW50cnkuc2l6ZSA9IHsgd2lkdGgsIGhlaWdodCB9O1xuICAgICAgZW50cnkuY2IoZW50cnkuc2l6ZSwgZWxlbWVudDIpO1xuICAgIH1cbiAgfVxuICAvLyBPbmx5IGEgc2luZ2xlIGNhbGxiYWNrIGlzIHN1cHBvcnRlZC5cbiAgb2JzZXJ2ZShlbGVtZW50MiwgY2IpIHtcbiAgICBpZiAoIXRoaXMuZG9jdW1lbnRSZWFkeSkge1xuICAgICAgdGhpcy5xdWV1ZWRPYnNlcnZlUmVxdWVzdHMucHVzaChbZWxlbWVudDIsIGNiXSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmVsZW1lbnRzLmhhcyhlbGVtZW50MikpIHtcbiAgICAgIHRoaXMucmVtb3ZlRnJvbVF1ZXVlKGVsZW1lbnQyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlcj8ub2JzZXJ2ZShlbGVtZW50Mik7XG4gICAgfVxuICAgIGNvbnN0IGVudHJ5ID0geyBjYiB9O1xuICAgIHRoaXMuZWxlbWVudHMuc2V0KGVsZW1lbnQyLCBlbnRyeSk7XG4gICAgdGhpcy5jaGVja1NpemUoZW50cnksIGVsZW1lbnQyLCBlbGVtZW50Mi5vZmZzZXRXaWR0aCwgZWxlbWVudDIub2Zmc2V0SGVpZ2h0KTtcbiAgfVxuICB1bm9ic2VydmUoZWxlbWVudDIpIHtcbiAgICB0aGlzLnJlc2l6ZU9ic2VydmVyPy51bm9ic2VydmUoZWxlbWVudDIpO1xuICAgIHRoaXMuZWxlbWVudHMuZGVsZXRlKGVsZW1lbnQyKTtcbiAgICB0aGlzLnJlbW92ZUZyb21RdWV1ZShlbGVtZW50Mik7XG4gICAgaWYgKCF0aGlzLmVsZW1lbnRzLnNpemUpIHtcbiAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxuICByZW1vdmVGcm9tUXVldWUoZWxlbWVudDIpIHtcbiAgICB0aGlzLnF1ZXVlZE9ic2VydmVSZXF1ZXN0cyA9IHRoaXMucXVldWVkT2JzZXJ2ZVJlcXVlc3RzLmZpbHRlcigoW2VsXSkgPT4gZWwgIT09IGVsZW1lbnQyKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZG9tL2RvbUxheW91dC5odG1sXG52YXIgZG9tTGF5b3V0X2RlZmF1bHQgPSAnPGRpdiByb2xlPVwicHJlc2VudGF0aW9uXCIgY2xhc3M9XCJhZy1jaGFydHMtd3JhcHBlciBhZy1jaGFydHMtc3R5bGVzXCIgZGF0YS1hZy1jaGFydHM+PGRpdiByb2xlPVwicHJlc2VudGF0aW9uXCIgY2xhc3M9XCJhZy1jaGFydHMtY2FudmFzLWNlbnRlclwiPjxkaXYgcm9sZT1cImZpZ3VyZVwiIGNsYXNzPVwiYWctY2hhcnRzLWNhbnZhcy1jb250YWluZXJcIj48ZGl2IHJvbGU9XCJwcmVzZW50YXRpb25cIiBjbGFzcz1cImFnLWNoYXJ0cy10YWItZ3VhcmRcIj48L2Rpdj48ZGl2IHJvbGU9XCJwcmVzZW50YXRpb25cIiBjbGFzcz1cImFnLWNoYXJ0cy1jYW52YXNcIj48L2Rpdj48ZGl2IHJvbGU9XCJwcmVzZW50YXRpb25cIiBjbGFzcz1cImFnLWNoYXJ0cy1jYW52YXMtcHJveHlcIj48L2Rpdj48ZGl2IHJvbGU9XCJwcmVzZW50YXRpb25cIiBjbGFzcz1cImFnLWNoYXJ0cy10YWItZ3VhcmRcIj48L2Rpdj48ZGl2IHJvbGU9XCJwcmVzZW50YXRpb25cIiBjbGFzcz1cImFnLWNoYXJ0cy1jYW52YXMtb3ZlcmxheVwiPjwvZGl2PjwvZGl2PjwvZGl2PjwvZGl2Pic7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2RvbS9kb21NYW5hZ2VyLnRzXG52YXIgQ0FOVkFTX0NFTlRFUl9DTEFTUyA9IFwiY2FudmFzLWNlbnRlclwiO1xudmFyIERPTV9FTEVNRU5UX0NMQVNTRVMgPSBbXCJzdHlsZXNcIiwgQ0FOVkFTX0NFTlRFUl9DTEFTUywgXCJjYW52YXNcIiwgXCJjYW52YXMtcHJveHlcIiwgXCJjYW52YXMtb3ZlcmxheVwiXTtcbnZhciBkb21FbGVtZW50Q29uZmlnID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoW1xuICBbXCJzdHlsZXNcIiwgeyBjaGlsZEVsZW1lbnRUeXBlOiBcInN0eWxlXCIgfV0sXG4gIFtcImNhbnZhc1wiLCB7IGNoaWxkRWxlbWVudFR5cGU6IFwiY2FudmFzXCIsIGV2ZW50VHlwZXM6IFtcImZvY3VzXCIsIFwiYmx1clwiXSB9XSxcbiAgW1wiY2FudmFzLXByb3h5XCIsIHsgY2hpbGRFbGVtZW50VHlwZTogXCJkaXZcIiB9XSxcbiAgW1wiY2FudmFzLW92ZXJsYXlcIiwgeyBjaGlsZEVsZW1lbnRUeXBlOiBcImRpdlwiIH1dLFxuICBbQ0FOVkFTX0NFTlRFUl9DTEFTUywgeyBjaGlsZEVsZW1lbnRUeXBlOiBcImRpdlwiIH1dXG5dKTtcbmZ1bmN0aW9uIHNldHVwT2JzZXJ2ZXIoZWxlbWVudDIsIGNiKSB7XG4gIGlmICh0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgcmV0dXJuO1xuICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcbiAgICAoZW50cmllcykgPT4ge1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XG4gICAgICAgIGlmIChlbnRyeS50YXJnZXQgPT09IGVsZW1lbnQyKSB7XG4gICAgICAgICAgY2IoZW50cnkuaW50ZXJzZWN0aW9uUmF0aW8pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB7IHJvb3Q6IGVsZW1lbnQyIH1cbiAgKTtcbiAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50Mik7XG4gIHJldHVybiBvYnNlcnZlcjtcbn1cbnZhciBOVUxMX0RPTVJFQ1QgPSB7XG4gIHg6IDAsXG4gIHk6IDAsXG4gIHdpZHRoOiAwLFxuICBoZWlnaHQ6IDAsXG4gIHRvcDogMCxcbiAgYm90dG9tOiAwLFxuICBsZWZ0OiAwLFxuICByaWdodDogMCxcbiAgdG9KU09OKCkge1xuICAgIHJldHVybiBOVUxMX0RPTVJFQ1Q7XG4gIH1cbn07XG52YXIgRE9NTWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcihjb250YWluZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc3R5bGVzID0ge307XG4gICAgdGhpcy5jb250YWluZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb250YWluZXJTaXplID0gdm9pZCAwO1xuICAgIHRoaXMuc2l6ZU1vbml0b3IgPSBuZXcgU2l6ZU1vbml0b3IoKTtcbiAgICBjb25zdCB0ZW1wbGF0ZUVsID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0ZW1wbGF0ZUVsLmlubmVySFRNTCA9IGRvbUxheW91dF9kZWZhdWx0O1xuICAgIHRoaXMuZWxlbWVudCA9IHRlbXBsYXRlRWwuY2hpbGRyZW4uaXRlbSgwKTtcbiAgICB0aGlzLnJvb3RFbGVtZW50cyA9IERPTV9FTEVNRU5UX0NMQVNTRVMucmVkdWNlKFxuICAgICAgKHIsIGMpID0+IHtcbiAgICAgICAgY29uc3QgY3NzQ2xhc3MgPSBgYWctY2hhcnRzLSR7Y31gO1xuICAgICAgICBjb25zdCBlbCA9IHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoY3NzQ2xhc3MpID8gdGhpcy5lbGVtZW50IDogdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoYC4ke2Nzc0NsYXNzfWApO1xuICAgICAgICBpZiAoIWVsKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gdW5hYmxlIHRvIGZpbmQgRE9NIGVsZW1lbnQgJHtjc3NDbGFzc31gKTtcbiAgICAgICAgcltjXSA9IHsgZWxlbWVudDogZWwsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBsaXN0ZW5lcnM6IFtdIH07XG4gICAgICAgIHJldHVybiByO1xuICAgICAgfSxcbiAgICAgIHt9XG4gICAgKTtcbiAgICBsZXQgaGlkZGVuID0gZmFsc2U7XG4gICAgdGhpcy5vYnNlcnZlciA9IHNldHVwT2JzZXJ2ZXIodGhpcy5lbGVtZW50LCAoaW50ZXJzZWN0aW9uUmF0aW8pID0+IHtcbiAgICAgIGlmIChpbnRlcnNlY3Rpb25SYXRpbyA9PT0gMCAmJiAhaGlkZGVuKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiaGlkZGVuXCIsIHsgdHlwZTogXCJoaWRkZW5cIiB9KTtcbiAgICAgIH1cbiAgICAgIGhpZGRlbiA9IGludGVyc2VjdGlvblJhdGlvID09PSAwO1xuICAgIH0pO1xuICAgIHRoaXMuc2V0U2l6ZU9wdGlvbnMoKTtcbiAgICB0aGlzLmFkZFN0eWxlcyhcImFnLWNoYXJ0cy1jb21tdW5pdHlcIiwgc3R5bGVzX2RlZmF1bHQpO1xuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIHRoaXMuc2V0Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIHRoaXMub2JzZXJ2ZXI/LnVub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xuICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xuICAgICAgdGhpcy5zaXplTW9uaXRvci51bm9ic2VydmUodGhpcy5jb250YWluZXIpO1xuICAgIH1cbiAgICBPYmplY3QudmFsdWVzKHRoaXMucm9vdEVsZW1lbnRzKS5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgZWwuY2hpbGRyZW4uZm9yRWFjaCgoYykgPT4gYy5yZW1vdmUoKSk7XG4gICAgICBlbC5lbGVtZW50LnJlbW92ZSgpO1xuICAgIH0pO1xuICAgIHRoaXMuZ3VhcmRlZEVsZW1lbnQ/LmRlc3Ryb3koKTtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlKCk7XG4gIH1cbiAgc2V0U2l6ZU9wdGlvbnMobWluV2lkdGggPSAzMDAsIG1pbkhlaWdodCA9IDMwMCwgb3B0aW9uc1dpZHRoLCBvcHRpb25zSGVpZ2h0KSB7XG4gICAgY29uc3QgeyBzdHlsZSB9ID0gdGhpcy5lbGVtZW50O1xuICAgIHN0eWxlLndpZHRoID0gYCR7b3B0aW9uc1dpZHRoID8/IG1pbldpZHRofXB4YDtcbiAgICBzdHlsZS5oZWlnaHQgPSBgJHtvcHRpb25zSGVpZ2h0ID8/IG1pbkhlaWdodH1weGA7XG4gIH1cbiAgdXBkYXRlQ29udGFpbmVyU2l6ZSgpIHtcbiAgICBjb25zdCB7IHN0eWxlOiBjZW50ZXJTdHlsZSB9ID0gdGhpcy5yb290RWxlbWVudHNbQ0FOVkFTX0NFTlRFUl9DTEFTU10uZWxlbWVudDtcbiAgICBjZW50ZXJTdHlsZS53aWR0aCA9IGAke3RoaXMuY29udGFpbmVyU2l6ZT8ud2lkdGggPz8gMH1weGA7XG4gICAgY2VudGVyU3R5bGUuaGVpZ2h0ID0gYCR7dGhpcy5jb250YWluZXJTaXplPy5oZWlnaHQgPz8gMH1weGA7XG4gIH1cbiAgc2V0Q29udGFpbmVyKG5ld0NvbnRhaW5lcikge1xuICAgIGlmIChuZXdDb250YWluZXIgPT09IHRoaXMuY29udGFpbmVyKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xuICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICAgIHRoaXMuc2l6ZU1vbml0b3IudW5vYnNlcnZlKHRoaXMuY29udGFpbmVyKTtcbiAgICB9XG4gICAgY29uc3QgaXNTaGFkb3dEb20gPSB0aGlzLmdldERvY3VtZW50Um9vdChuZXdDb250YWluZXIpICE9IG51bGw7XG4gICAgaWYgKCFpc1NoYWRvd0RvbSkge1xuICAgICAgZm9yIChjb25zdCBpZCBvZiB0aGlzLnJvb3RFbGVtZW50c1tcInN0eWxlc1wiXS5jaGlsZHJlbi5rZXlzKCkpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChcInN0eWxlc1wiLCBpZCk7XG4gICAgICB9XG4gICAgfVxuICAgIG5ld0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICAgIHRoaXMuc2l6ZU1vbml0b3Iub2JzZXJ2ZShuZXdDb250YWluZXIsIChzaXplKSA9PiB7XG4gICAgICB0aGlzLmNvbnRhaW5lclNpemUgPSBzaXplO1xuICAgICAgdGhpcy51cGRhdGVDb250YWluZXJTaXplKCk7XG4gICAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcInJlc2l6ZVwiLCB7IHR5cGU6IFwicmVzaXplXCIgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5jb250YWluZXIgPSBuZXdDb250YWluZXI7XG4gICAgZm9yIChjb25zdCBbaWQsIHN0eWxlc10gb2YgT2JqZWN0LmVudHJpZXModGhpcy5zdHlsZXMpKSB7XG4gICAgICB0aGlzLmFkZFN0eWxlcyhpZCwgc3R5bGVzKTtcbiAgICB9XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJjb250YWluZXItY2hhbmdlZFwiLCB7IHR5cGU6IFwiY29udGFpbmVyLWNoYW5nZWRcIiB9KTtcbiAgfVxuICBzZXRUaGVtZUNsYXNzKHRoZW1lQ2xhc3NOYW1lKSB7XG4gICAgY29uc3QgdGhlbWVDbGFzc05hbWVQcmVmaXggPSBcImFnLWNoYXJ0cy10aGVtZS1cIjtcbiAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmZvckVhY2goKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgaWYgKGNsYXNzTmFtZS5zdGFydHNXaXRoKHRoZW1lQ2xhc3NOYW1lUHJlZml4KSAmJiBjbGFzc05hbWUgIT09IHRoZW1lQ2xhc3NOYW1lKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQodGhlbWVDbGFzc05hbWUpO1xuICB9XG4gIGNyZWF0ZVRhYkd1YXJkcygpIHtcbiAgICBjb25zdCBjYW52YXNFbGVtZW50ID0gdGhpcy5yb290RWxlbWVudHNbXCJjYW52YXNcIl0uZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiY2FudmFzXCIpO1xuICAgIGNvbnN0IHRhYkd1YXJkcyA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmFnLWNoYXJ0cy10YWItZ3VhcmRcIik7XG4gICAgaWYgKGNhbnZhc0VsZW1lbnQgPT0gbnVsbCB8fCB0YWJHdWFyZHNbMF0gPT0gbnVsbCB8fCB0YWJHdWFyZHNbMV0gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gZXJyb3IgaW5pdGlhbGlzaW5nIGNhbnZhcyB0YWIgZ3VhcmRzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEd1YXJkZWRFbGVtZW50KGNhbnZhc0VsZW1lbnQsIHRhYkd1YXJkc1swXSwgdGFiR3VhcmRzWzFdKTtcbiAgfVxuICBzZXRUYWJJbmRleCh0YWJJbmRleCkge1xuICAgIHRoaXMuZ3VhcmRlZEVsZW1lbnQgPz8gKHRoaXMuZ3VhcmRlZEVsZW1lbnQgPSB0aGlzLmNyZWF0ZVRhYkd1YXJkcygpKTtcbiAgICB0aGlzLmd1YXJkZWRFbGVtZW50LnRhYkluZGV4ID0gdGFiSW5kZXg7XG4gIH1cbiAgZ2V0QnJvd3NlckZvY3VzRGVsdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ3VhcmRlZEVsZW1lbnQ/LmdldEJyb3dzZXJGb2N1c0RlbHRhKCkgPz8gMDtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyT25FbGVtZW50KGVsZW1lbnRUeXBlLCB0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgZWxlbWVudDogZWxlbWVudDIgfSA9IHRoaXMucm9vdEVsZW1lbnRzW2VsZW1lbnRUeXBlXTtcbiAgICBlbGVtZW50Mi5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZWxlbWVudDIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgfTtcbiAgfVxuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKSB7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIGRvbUVsZW1lbnRDb25maWcuZm9yRWFjaCgoY29uZmlnLCBlbFR5cGUpID0+IHtcbiAgICAgIGlmICghY29uZmlnLmV2ZW50VHlwZXM/LmluY2x1ZGVzKHR5cGUpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBlbHMgPSB0aGlzLnJvb3RFbGVtZW50c1tlbFR5cGVdO1xuICAgICAgZWxzLmxpc3RlbmVycy5wdXNoKFt0eXBlLCBsaXN0ZW5lciwgb3B0aW9uc10pO1xuICAgICAgZWxzLmNoaWxkcmVuLmZvckVhY2goKGVsKSA9PiB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICBkb21FbGVtZW50Q29uZmlnLmZvckVhY2goKGNvbmZpZywgZWxUeXBlKSA9PiB7XG4gICAgICBpZiAoIWNvbmZpZy5ldmVudFR5cGVzPy5pbmNsdWRlcyh0eXBlKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgZWxzID0gdGhpcy5yb290RWxlbWVudHNbZWxUeXBlXTtcbiAgICAgIGVscy5saXN0ZW5lcnMgPSBlbHMubGlzdGVuZXJzLmZpbHRlcigoW3QsIGxdKSA9PiB0ICE9PSB0eXBlICYmIGwgIT09IGxpc3RlbmVyKTtcbiAgICAgIGVscy5jaGlsZHJlbi5mb3JFYWNoKChlbCkgPT4ge1xuICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKiBHZXQgdGhlIG1haW4gY2hhcnQgYXJlYSBjbGllbnQgYm91bmQgcmVjdC4gKi9cbiAgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkge1xuICAgIHJldHVybiB0aGlzLnJvb3RFbGVtZW50c1tcImNhbnZhc1wiXS5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGNsaWVudCBib3VuZGluZyByZWN0IGZvciBvdmVybGF5IGVsZW1lbnRzIHRoYXQgbWlnaHQgZmxvYXQgb3V0c2lkZSB0aGUgYm91bmRzIG9mIHRoZVxuICAgKiBtYWluIGNoYXJ0IGFyZWEuXG4gICAqL1xuICBnZXRPdmVybGF5Q2xpZW50UmVjdCgpIHtcbiAgICBjb25zdCB3aW5kb3cyID0gZ2V0V2luZG93KCk7XG4gICAgY29uc3Qgd2luZG93QkJveCA9IG5ldyBCQm94KDAsIDAsIHdpbmRvdzIuaW5uZXJXaWR0aCwgd2luZG93Mi5pbm5lckhlaWdodCk7XG4gICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5nZXRSYXdPdmVybGF5Q2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGNvbnRhaW5lckJCb3ggPSBCQm94LmZyb21ET01SZWN0KGNvbnRhaW5lciA/PyB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKTtcbiAgICByZXR1cm4gd2luZG93QkJveC5pbnRlcnNlY3Rpb24oY29udGFpbmVyQkJveCk/LnRvRE9NUmVjdCgpID8/IE5VTExfRE9NUkVDVDtcbiAgfVxuICBnZXRSYXdPdmVybGF5Q2xpZW50UmVjdCgpIHtcbiAgICBsZXQgZWxlbWVudDIgPSB0aGlzLmVsZW1lbnQ7XG4gICAgd2hpbGUgKGVsZW1lbnQyICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHN0eWxlTWFwID0gZWxlbWVudDIuY29tcHV0ZWRTdHlsZU1hcD8uKCk7XG4gICAgICBjb25zdCBvdmVyZmxvd1ggPSBzdHlsZU1hcD8uZ2V0KFwib3ZlcmZsb3cteFwiKT8udG9TdHJpbmcoKTtcbiAgICAgIGNvbnN0IG92ZXJmbG93WSA9IHN0eWxlTWFwPy5nZXQoXCJvdmVyZmxvdy15XCIpPy50b1N0cmluZygpO1xuICAgICAgaWYgKG92ZXJmbG93WCAhPSBudWxsICYmIG92ZXJmbG93WCAhPT0gXCJ2aXNpYmxlXCIgfHwgb3ZlcmZsb3dZICYmIG92ZXJmbG93WSAhPT0gXCJ2aXNpYmxlXCIpIHtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgfVxuICAgICAgZWxlbWVudDIgPSBlbGVtZW50Mi5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgICBjb25zdCBkb2NSb290ID0gdGhpcy5nZXREb2N1bWVudFJvb3QoKTtcbiAgICBpZiAoZG9jUm9vdCkge1xuICAgICAgcmV0dXJuIGRvY1Jvb3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICB9XG4gIGdldERvY3VtZW50Um9vdChjdXJyZW50ID0gdGhpcy5jb250YWluZXIpIHtcbiAgICBjb25zdCBkb2NSb290ID0gY3VycmVudD8ub3duZXJEb2N1bWVudD8uYm9keSA/PyBnZXREb2N1bWVudChcImJvZHlcIik7XG4gICAgd2hpbGUgKGN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgaWYgKGN1cnJlbnQgPT09IGRvY1Jvb3QpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50LnBhcmVudE5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBnZXRDaGlsZEJvdW5kaW5nQ2xpZW50UmVjdCh0eXBlKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGhpcy5yb290RWxlbWVudHNbdHlwZV07XG4gICAgY29uc3QgY2hpbGRSZWN0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgY2hpbGRyZW4udmFsdWVzKCkpIHtcbiAgICAgIGNoaWxkUmVjdHMucHVzaChCQm94LmZyb21ET01SZWN0KGNoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSk7XG4gICAgfVxuICAgIHJldHVybiBCQm94Lm1lcmdlKGNoaWxkUmVjdHMpO1xuICB9XG4gIGNhbGN1bGF0ZUNhbnZhc1Bvc2l0aW9uKGVsKSB7XG4gICAgbGV0IHggPSAwO1xuICAgIGxldCB5ID0gMDtcbiAgICBjb25zdCB7IHg6IGN4ID0gMCwgeTogY3kgPSAwIH0gPSB0aGlzLmdldENoaWxkQm91bmRpbmdDbGllbnRSZWN0KFwiY2FudmFzXCIpID8/IHt9O1xuICAgIGNvbnN0IGVsUmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHggPSBlbFJlY3QueCAtIGN4O1xuICAgIHkgPSBlbFJlY3QueSAtIGN5O1xuICAgIHJldHVybiB7IHgsIHkgfTtcbiAgfVxuICBpc01hbmFnZWRDaGlsZERPTUVsZW1lbnQoZWwsIGRvbUVsZW1lbnRDbGFzcywgaWQpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSB0aGlzLnJvb3RFbGVtZW50c1tkb21FbGVtZW50Q2xhc3NdO1xuICAgIGNvbnN0IHNlYXJjaCA9IGNoaWxkcmVuPy5nZXQoaWQpO1xuICAgIHJldHVybiBzZWFyY2ggIT0gbnVsbCAmJiBlbC5jb250YWlucyhzZWFyY2gpO1xuICB9XG4gIGlzRXZlbnRPdmVyRWxlbWVudChldmVudCkge1xuICAgIGNvbnN0IGVsZW1lbnQyID0gZXZlbnQudGFyZ2V0O1xuICAgIHJldHVybiBlbGVtZW50MiAhPSBudWxsICYmIHRoaXMuZWxlbWVudC5jb250YWlucyhlbGVtZW50Mik7XG4gIH1cbiAgYWRkU3R5bGVzKGlkLCBzdHlsZXMpIHtcbiAgICB0aGlzLnN0eWxlc1tpZF0gPSBzdHlsZXM7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZGF0YUF0dHJpYnV0ZSA9IFwiZGF0YS1hZy1jaGFydHNcIjtcbiAgICBjb25zdCBkb2N1bWVudFJvb3QgPSB0aGlzLmdldERvY3VtZW50Um9vdCgpO1xuICAgIGxldCBzdHlsZUVsZW1lbnQ7XG4gICAgaWYgKGRvY3VtZW50Um9vdCAhPSBudWxsKSB7XG4gICAgICBzdHlsZUVsZW1lbnQgPSB0aGlzLmFkZENoaWxkKFwic3R5bGVzXCIsIGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaGVhZCA9IGdldERvY3VtZW50KFwiaGVhZFwiKTtcbiAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgaGVhZC5jaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGQuZ2V0QXR0cmlidXRlKGRhdGFBdHRyaWJ1dGUpID09PSBpZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzdHlsZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XG4gICAgfVxuICAgIGlmIChzdHlsZUVsZW1lbnQuZ2V0QXR0cmlidXRlKGRhdGFBdHRyaWJ1dGUpID09PSBpZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKGRhdGFBdHRyaWJ1dGUsIGlkKTtcbiAgICBzdHlsZUVsZW1lbnQuaW5uZXJIVE1MID0gc3R5bGVzO1xuICB9XG4gIHJlbW92ZVN0eWxlcyhpZCkge1xuICAgIHRoaXMucmVtb3ZlQ2hpbGQoXCJzdHlsZXNcIiwgaWQpO1xuICB9XG4gIHVwZGF0ZUN1cnNvcihzdHlsZSkge1xuICAgIHRoaXMuZWxlbWVudC5zdHlsZS5jdXJzb3IgPSBzdHlsZTtcbiAgfVxuICBnZXRDdXJzb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5zdHlsZS5jdXJzb3I7XG4gIH1cbiAgYWRkQ2hpbGQoZG9tRWxlbWVudENsYXNzLCBpZCwgY2hpbGQpIHtcbiAgICBjb25zdCB7IGVsZW1lbnQ6IGVsZW1lbnQyLCBjaGlsZHJlbiwgbGlzdGVuZXJzIH0gPSB0aGlzLnJvb3RFbGVtZW50c1tkb21FbGVtZW50Q2xhc3NdO1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIHVuYWJsZSB0byBjcmVhdGUgRE9NIGVsZW1lbnRzIGFmdGVyIGRlc3Ryb3koKVwiKTtcbiAgICB9XG4gICAgY29uc3QgZXhpc3RpbmcgPSBjaGlsZHJlbi5nZXQoaWQpO1xuICAgIGlmIChleGlzdGluZyAhPSBudWxsKVxuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIGNvbnN0IHsgY2hpbGRFbGVtZW50VHlwZSA9IFwiZGl2XCIgfSA9IGRvbUVsZW1lbnRDb25maWcuZ2V0KGRvbUVsZW1lbnRDbGFzcykgPz8ge307XG4gICAgaWYgKGNoaWxkICYmIGNoaWxkLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gY2hpbGRFbGVtZW50VHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSBtaXNtYXRjaGluZyBET00gZWxlbWVudCB0eXBlXCIpO1xuICAgIH1cbiAgICBjb25zdCBuZXdDaGlsZCA9IGNoaWxkID8/IGNyZWF0ZUVsZW1lbnQoY2hpbGRFbGVtZW50VHlwZSk7XG4gICAgZm9yIChjb25zdCBbdHlwZSwgZm4sIG9wdHNdIG9mIGxpc3RlbmVycykge1xuICAgICAgbmV3Q2hpbGQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgb3B0cyk7XG4gICAgfVxuICAgIGNoaWxkcmVuLnNldChpZCwgbmV3Q2hpbGQpO1xuICAgIGVsZW1lbnQyPy5hcHBlbmRDaGlsZChuZXdDaGlsZCk7XG4gICAgcmV0dXJuIG5ld0NoaWxkO1xuICB9XG4gIHJlbW92ZUNoaWxkKGRvbUVsZW1lbnRDbGFzcywgaWQpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSB0aGlzLnJvb3RFbGVtZW50c1tkb21FbGVtZW50Q2xhc3NdO1xuICAgIGlmICghY2hpbGRyZW4pXG4gICAgICByZXR1cm47XG4gICAgY2hpbGRyZW4uZ2V0KGlkKT8ucmVtb3ZlKCk7XG4gICAgY2hpbGRyZW4uZGVsZXRlKGlkKTtcbiAgfVxuICBpbmNyZW1lbnREYXRhQ291bnRlcihuYW1lKSB7XG4gICAgY29uc3QgeyBkYXRhc2V0IH0gPSB0aGlzLmVsZW1lbnQ7XG4gICAgZGF0YXNldFtuYW1lXSA/PyAoZGF0YXNldFtuYW1lXSA9IFwiMFwiKTtcbiAgICBkYXRhc2V0W25hbWVdID0gU3RyaW5nKE51bWJlcihkYXRhc2V0W25hbWVdKSArIDEpO1xuICB9XG4gIGdldEljb25DbGFzc05hbWVzKGljb24pIHtcbiAgICByZXR1cm4gYGFnLWNoYXJ0cy1pY29uIGFnLWNoYXJ0cy1pY29uLSR7aWNvbn1gO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9wb2x5Um9vdHMudHNcbmZ1bmN0aW9uIGxpbmVhclJvb3QoYSwgYikge1xuICBjb25zdCB0ID0gLWIgLyBhO1xuICByZXR1cm4gYSAhPT0gMCAmJiB0ID49IDAgJiYgdCA8PSAxID8gW3RdIDogW107XG59XG5mdW5jdGlvbiBxdWFkcmF0aWNSb290cyhhLCBiLCBjKSB7XG4gIGlmIChhID09PSAwKSB7XG4gICAgcmV0dXJuIGxpbmVhclJvb3QoYiwgYyk7XG4gIH1cbiAgY29uc3QgRCA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICBjb25zdCByb290cyA9IFtdO1xuICBpZiAoRCA9PT0gMCkge1xuICAgIGNvbnN0IHQgPSAtYiAvICgyICogYSk7XG4gICAgaWYgKHQgPj0gMCAmJiB0IDw9IDEpIHtcbiAgICAgIHJvb3RzLnB1c2godCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKEQgPiAwKSB7XG4gICAgY29uc3QgckQgPSBNYXRoLnNxcnQoRCk7XG4gICAgY29uc3QgdDEgPSAoLWIgLSByRCkgLyAoMiAqIGEpO1xuICAgIGNvbnN0IHQyID0gKC1iICsgckQpIC8gKDIgKiBhKTtcbiAgICBpZiAodDEgPj0gMCAmJiB0MSA8PSAxKSB7XG4gICAgICByb290cy5wdXNoKHQxKTtcbiAgICB9XG4gICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgcm9vdHMucHVzaCh0Mik7XG4gICAgfVxuICB9XG4gIHJldHVybiByb290cztcbn1cbmZ1bmN0aW9uIGN1YmljUm9vdHMoYSwgYiwgYywgZCkge1xuICBpZiAoYSA9PT0gMCkge1xuICAgIHJldHVybiBxdWFkcmF0aWNSb290cyhiLCBjLCBkKTtcbiAgfVxuICBjb25zdCBBID0gYiAvIGE7XG4gIGNvbnN0IEIgPSBjIC8gYTtcbiAgY29uc3QgQyA9IGQgLyBhO1xuICBjb25zdCBRID0gKDMgKiBCIC0gQSAqIEEpIC8gOTtcbiAgY29uc3QgUiA9ICg5ICogQSAqIEIgLSAyNyAqIEMgLSAyICogQSAqIEEgKiBBKSAvIDU0O1xuICBjb25zdCBEID0gUSAqIFEgKiBRICsgUiAqIFI7XG4gIGNvbnN0IHRoaXJkID0gMSAvIDM7XG4gIGNvbnN0IHJvb3RzID0gW107XG4gIGlmIChEID49IDApIHtcbiAgICBjb25zdCByRCA9IE1hdGguc3FydChEKTtcbiAgICBjb25zdCBTID0gTWF0aC5zaWduKFIgKyByRCkgKiBNYXRoLnBvdyhNYXRoLmFicyhSICsgckQpLCB0aGlyZCk7XG4gICAgY29uc3QgVCA9IE1hdGguc2lnbihSIC0gckQpICogTWF0aC5wb3coTWF0aC5hYnMoUiAtIHJEKSwgdGhpcmQpO1xuICAgIGNvbnN0IEltID0gTWF0aC5hYnMoTWF0aC5zcXJ0KDMpICogKFMgLSBUKSAvIDIpO1xuICAgIGNvbnN0IHQgPSAtdGhpcmQgKiBBICsgKFMgKyBUKTtcbiAgICBpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuICAgICAgcm9vdHMucHVzaCh0KTtcbiAgICB9XG4gICAgaWYgKEltID09PSAwKSB7XG4gICAgICBjb25zdCB0MiA9IC10aGlyZCAqIEEgLSAoUyArIFQpIC8gMjtcbiAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgcm9vdHMucHVzaCh0Mik7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IHRoZXRhID0gTWF0aC5hY29zKFIgLyBNYXRoLnNxcnQoLVEgKiBRICogUSkpO1xuICAgIGNvbnN0IHRoaXJkQSA9IHRoaXJkICogQTtcbiAgICBjb25zdCB0d29TcXJ0USA9IDIgKiBNYXRoLnNxcnQoLVEpO1xuICAgIGNvbnN0IHQxID0gdHdvU3FydFEgKiBNYXRoLmNvcyh0aGlyZCAqIHRoZXRhKSAtIHRoaXJkQTtcbiAgICBjb25zdCB0MiA9IHR3b1NxcnRRICogTWF0aC5jb3ModGhpcmQgKiAodGhldGEgKyAyICogTWF0aC5QSSkpIC0gdGhpcmRBO1xuICAgIGNvbnN0IHQzID0gdHdvU3FydFEgKiBNYXRoLmNvcyh0aGlyZCAqICh0aGV0YSArIDQgKiBNYXRoLlBJKSkgLSB0aGlyZEE7XG4gICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgcm9vdHMucHVzaCh0MSk7XG4gICAgfVxuICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgIHJvb3RzLnB1c2godDIpO1xuICAgIH1cbiAgICBpZiAodDMgPj0gMCAmJiB0MyA8PSAxKSB7XG4gICAgICByb290cy5wdXNoKHQzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJvb3RzO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9pbnRlcnNlY3Rpb24udHNcbmZ1bmN0aW9uIHNlZ21lbnRJbnRlcnNlY3Rpb24oYXgxLCBheTEsIGF4MiwgYXkyLCBieDEsIGJ5MSwgYngyLCBieTIpIHtcbiAgY29uc3QgZCA9IChheDIgLSBheDEpICogKGJ5MiAtIGJ5MSkgLSAoYXkyIC0gYXkxKSAqIChieDIgLSBieDEpO1xuICBpZiAoZCA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGNvbnN0IHVhID0gKChieDIgLSBieDEpICogKGF5MSAtIGJ5MSkgLSAoYXgxIC0gYngxKSAqIChieTIgLSBieTEpKSAvIGQ7XG4gIGNvbnN0IHViID0gKChheDIgLSBheDEpICogKGF5MSAtIGJ5MSkgLSAoYXkyIC0gYXkxKSAqIChheDEgLSBieDEpKSAvIGQ7XG4gIGlmICh1YSA+PSAwICYmIHVhIDw9IDEgJiYgdWIgPj0gMCAmJiB1YiA8PSAxKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBjdWJpY1NlZ21lbnRJbnRlcnNlY3Rpb25zKHB4MSwgcHkxLCBweDIsIHB5MiwgcHgzLCBweTMsIHB4NCwgcHk0LCB4MSwgeTEsIHgyLCB5Mikge1xuICBsZXQgaW50ZXJzZWN0aW9ucyA9IDA7XG4gIGNvbnN0IEEgPSB5MSAtIHkyO1xuICBjb25zdCBCID0geDIgLSB4MTtcbiAgY29uc3QgQyA9IHgxICogKHkyIC0geTEpIC0geTEgKiAoeDIgLSB4MSk7XG4gIGNvbnN0IGJ4ID0gYmV6aWVyQ29lZmZpY2llbnRzKHB4MSwgcHgyLCBweDMsIHB4NCk7XG4gIGNvbnN0IGJ5ID0gYmV6aWVyQ29lZmZpY2llbnRzKHB5MSwgcHkyLCBweTMsIHB5NCk7XG4gIGNvbnN0IGEgPSBBICogYnhbMF0gKyBCICogYnlbMF07XG4gIGNvbnN0IGIgPSBBICogYnhbMV0gKyBCICogYnlbMV07XG4gIGNvbnN0IGMgPSBBICogYnhbMl0gKyBCICogYnlbMl07XG4gIGNvbnN0IGQgPSBBICogYnhbM10gKyBCICogYnlbM10gKyBDO1xuICBjb25zdCByb290cyA9IGN1YmljUm9vdHMoYSwgYiwgYywgZCk7XG4gIGZvciAoY29uc3QgdCBvZiByb290cykge1xuICAgIGNvbnN0IHR0ID0gdCAqIHQ7XG4gICAgY29uc3QgdHR0ID0gdCAqIHR0O1xuICAgIGNvbnN0IHggPSBieFswXSAqIHR0dCArIGJ4WzFdICogdHQgKyBieFsyXSAqIHQgKyBieFszXTtcbiAgICBjb25zdCB5ID0gYnlbMF0gKiB0dHQgKyBieVsxXSAqIHR0ICsgYnlbMl0gKiB0ICsgYnlbM107XG4gICAgbGV0IHM7XG4gICAgaWYgKHgxID09PSB4Mikge1xuICAgICAgcyA9ICh5IC0geTEpIC8gKHkyIC0geTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gKHggLSB4MSkgLyAoeDIgLSB4MSk7XG4gICAgfVxuICAgIGlmIChzID49IDAgJiYgcyA8PSAxKSB7XG4gICAgICBpbnRlcnNlY3Rpb25zKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbnRlcnNlY3Rpb25zO1xufVxuZnVuY3Rpb24gYmV6aWVyQ29lZmZpY2llbnRzKFAxLCBQMiwgUDMsIFA0KSB7XG4gIHJldHVybiBbXG4gICAgLy8gQsOpemllciBleHByZXNzZWQgYXMgbWF0cml4IG9wZXJhdGlvbnM6XG4gICAgLVAxICsgMyAqIFAyIC0gMyAqIFAzICsgUDQsXG4gICAgLy8gICAgICAgICAgICAgICAgIHwtMSAgMyAtMyAgMXwgfFAxfFxuICAgIDMgKiBQMSAtIDYgKiBQMiArIDMgKiBQMyxcbiAgICAvLyAgIFt0XjMgdF4yIHQgMV0gfCAzIC02ICAzICAwfCB8UDJ8XG4gICAgLTMgKiBQMSArIDMgKiBQMixcbiAgICAvLyAgICAgICAgICAgICAgICAgfC0zICAzICAwICAwfCB8UDN8XG4gICAgUDFcbiAgICAvLyAgICAgICAgICAgICAgICAgfCAxICAwICAwICAwfCB8UDR8XG4gIF07XG59XG5mdW5jdGlvbiBhcmNJbnRlcnNlY3Rpb25zKGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNvdW50ZXJDbG9ja3dpc2UsIHgxLCB5MSwgeDIsIHkyKSB7XG4gIGlmIChpc05hTihjeCkgfHwgaXNOYU4oY3kpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGNvdW50ZXJDbG9ja3dpc2UpIHtcbiAgICBbZW5kQW5nbGUsIHN0YXJ0QW5nbGVdID0gW3N0YXJ0QW5nbGUsIGVuZEFuZ2xlXTtcbiAgfVxuICBjb25zdCBrID0gKHkyIC0geTEpIC8gKHgyIC0geDEpO1xuICBjb25zdCB5MCA9IHkxIC0gayAqIHgxO1xuICBjb25zdCBhID0gTWF0aC5wb3coaywgMikgKyAxO1xuICBjb25zdCBiID0gMiAqIChrICogKHkwIC0gY3kpIC0gY3gpO1xuICBjb25zdCBjID0gTWF0aC5wb3coY3gsIDIpICsgTWF0aC5wb3coeTAgLSBjeSwgMikgLSBNYXRoLnBvdyhyLCAyKTtcbiAgY29uc3QgZCA9IE1hdGgucG93KGIsIDIpIC0gNCAqIGEgKiBjO1xuICBpZiAoZCA8IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBjb25zdCBpMXggPSAoLWIgKyBNYXRoLnNxcnQoZCkpIC8gMiAvIGE7XG4gIGNvbnN0IGkyeCA9ICgtYiAtIE1hdGguc3FydChkKSkgLyAyIC8gYTtcbiAgbGV0IGludGVyc2VjdGlvbnMgPSAwO1xuICBbaTF4LCBpMnhdLmZvckVhY2goKHgpID0+IHtcbiAgICBjb25zdCBpc1hJbnNpZGVMaW5lID0geCA+PSBNYXRoLm1pbih4MSwgeDIpICYmIHggPD0gTWF0aC5tYXgoeDEsIHgyKTtcbiAgICBpZiAoIWlzWEluc2lkZUxpbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeSA9IGsgKiB4ICsgeTA7XG4gICAgY29uc3QgYWRqYWNlbnQgPSB4IC0gY3g7XG4gICAgY29uc3Qgb3Bwb3NpdGUgPSB5IC0gY3k7XG4gICAgY29uc3QgYW5nbGUyID0gTWF0aC5hdGFuMihvcHBvc2l0ZSwgYWRqYWNlbnQpO1xuICAgIGlmIChpc0JldHdlZW5BbmdsZXMoYW5nbGUyLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICAgIGludGVyc2VjdGlvbnMrKztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaW50ZXJzZWN0aW9ucztcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvZXh0ZW5kZWRQYXRoMkQudHNcbnZhciBFeHRlbmRlZFBhdGgyRCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLy8gVGhlIG1ldGhvZHMgb2YgdGhpcyBjbGFzcyB3aWxsIGxpa2VseSBiZSBjYWxsZWQgbWFueSB0aW1lcyBwZXIgYW5pbWF0aW9uIGZyYW1lLFxuICAgIC8vIGFuZCBhbnkgYWxsb2NhdGlvbiBjYW4gdHJpZ2dlciBhIEdDIGN5Y2xlIGR1cmluZyBhbmltYXRpb24sIHNvIHdlIGF0dGVtcHRcbiAgICAvLyB0byBtaW5pbWl6ZSB0aGUgbnVtYmVyIG9mIGFsbG9jYXRpb25zLlxuICAgIHRoaXMucGF0aDJkID0gbmV3IFBhdGgyRCgpO1xuICAgIHRoaXMucHJldmlvdXNDb21tYW5kcyA9IFtdO1xuICAgIHRoaXMucHJldmlvdXNQYXJhbXMgPSBbXTtcbiAgICB0aGlzLnByZXZpb3VzQ2xvc2VkUGF0aCA9IGZhbHNlO1xuICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICB0aGlzLnBhcmFtcyA9IFtdO1xuICAgIHRoaXMub3BlbmVkUGF0aCA9IGZhbHNlO1xuICAgIHRoaXMuY2xvc2VkUGF0aCA9IGZhbHNlO1xuICB9XG4gIGlzRGlydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvc2VkUGF0aCAhPT0gdGhpcy5wcmV2aW91c0Nsb3NlZFBhdGggfHwgdGhpcy5wcmV2aW91c0NvbW1hbmRzLmxlbmd0aCAhPT0gdGhpcy5jb21tYW5kcy5sZW5ndGggfHwgdGhpcy5wcmV2aW91c1BhcmFtcy5sZW5ndGggIT09IHRoaXMucGFyYW1zLmxlbmd0aCB8fCB0aGlzLnByZXZpb3VzQ29tbWFuZHMudG9TdHJpbmcoKSAhPT0gdGhpcy5jb21tYW5kcy50b1N0cmluZygpIHx8IHRoaXMucHJldmlvdXNQYXJhbXMudG9TdHJpbmcoKSAhPT0gdGhpcy5wYXJhbXMudG9TdHJpbmcoKTtcbiAgfVxuICBnZXRQYXRoMkQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aDJkO1xuICB9XG4gIG1vdmVUbyh4LCB5KSB7XG4gICAgdGhpcy5vcGVuZWRQYXRoID0gdHJ1ZTtcbiAgICB0aGlzLnBhdGgyZC5tb3ZlVG8oeCwgeSk7XG4gICAgdGhpcy5jb21tYW5kcy5wdXNoKDAgLyogTW92ZSAqLyk7XG4gICAgdGhpcy5wYXJhbXMucHVzaCh4LCB5KTtcbiAgfVxuICBsaW5lVG8oeCwgeSkge1xuICAgIGlmICh0aGlzLm9wZW5lZFBhdGgpIHtcbiAgICAgIHRoaXMucGF0aDJkLmxpbmVUbyh4LCB5KTtcbiAgICAgIHRoaXMuY29tbWFuZHMucHVzaCgxIC8qIExpbmUgKi8pO1xuICAgICAgdGhpcy5wYXJhbXMucHVzaCh4LCB5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tb3ZlVG8oeCwgeSk7XG4gICAgfVxuICB9XG4gIHJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMubW92ZVRvKHgsIHkpO1xuICAgIHRoaXMubGluZVRvKHggKyB3aWR0aCwgeSk7XG4gICAgdGhpcy5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICB0aGlzLmxpbmVUbyh4LCB5ICsgaGVpZ2h0KTtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICB9XG4gIHJvdW5kUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpaSkge1xuICAgIHJhZGlpID0gTWF0aC5taW4ocmFkaWksIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgdGhpcy5tb3ZlVG8oeCwgeSArIHJhZGlpKTtcbiAgICB0aGlzLmFyYyh4ICsgcmFkaWksIHkgKyByYWRpaSwgcmFkaWksIE1hdGguUEksIDEuNSAqIE1hdGguUEkpO1xuICAgIHRoaXMubGluZVRvKHggKyByYWRpaSwgeSk7XG4gICAgdGhpcy5saW5lVG8oeCArIHdpZHRoIC0gcmFkaWksIHkpO1xuICAgIHRoaXMuYXJjKHggKyB3aWR0aCAtIHJhZGlpLCB5ICsgcmFkaWksIHJhZGlpLCAxLjUgKiBNYXRoLlBJLCAyICogTWF0aC5QSSk7XG4gICAgdGhpcy5saW5lVG8oeCArIHdpZHRoLCB5ICsgcmFkaWkpO1xuICAgIHRoaXMubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGlpKTtcbiAgICB0aGlzLmFyYyh4ICsgd2lkdGggLSByYWRpaSwgeSArIGhlaWdodCAtIHJhZGlpLCByYWRpaSwgMCwgTWF0aC5QSSAvIDIpO1xuICAgIHRoaXMubGluZVRvKHggKyB3aWR0aCAtIHJhZGlpLCB5ICsgaGVpZ2h0KTtcbiAgICB0aGlzLmxpbmVUbyh4ICsgcmFkaWksIHkgKyBoZWlnaHQpO1xuICAgIHRoaXMuYXJjKHggKyArcmFkaWksIHkgKyBoZWlnaHQgLSByYWRpaSwgcmFkaWksIE1hdGguUEkgLyAyLCBNYXRoLlBJKTtcbiAgICB0aGlzLmxpbmVUbyh4LCB5ICsgaGVpZ2h0IC0gcmFkaWkpO1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gIH1cbiAgYXJjKHgsIHksIHIsIHNBbmdsZSwgZUFuZ2xlLCBjb3VudGVyQ2xvY2t3aXNlKSB7XG4gICAgdGhpcy5vcGVuZWRQYXRoID0gdHJ1ZTtcbiAgICB0aGlzLnBhdGgyZC5hcmMoeCwgeSwgciwgc0FuZ2xlLCBlQW5nbGUsIGNvdW50ZXJDbG9ja3dpc2UpO1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCgyIC8qIEFyYyAqLyk7XG4gICAgdGhpcy5wYXJhbXMucHVzaCh4LCB5LCByLCBzQW5nbGUsIGVBbmdsZSwgY291bnRlckNsb2Nrd2lzZSA/IDEgOiAwKTtcbiAgfVxuICBjdWJpY0N1cnZlVG8oY3gxLCBjeTEsIGN4MiwgY3kyLCB4LCB5KSB7XG4gICAgaWYgKCF0aGlzLm9wZW5lZFBhdGgpIHtcbiAgICAgIHRoaXMubW92ZVRvKGN4MSwgY3kxKTtcbiAgICB9XG4gICAgdGhpcy5wYXRoMmQuYmV6aWVyQ3VydmVUbyhjeDEsIGN5MSwgY3gyLCBjeTIsIHgsIHkpO1xuICAgIHRoaXMuY29tbWFuZHMucHVzaCgzIC8qIEN1cnZlICovKTtcbiAgICB0aGlzLnBhcmFtcy5wdXNoKGN4MSwgY3kxLCBjeDIsIGN5MiwgeCwgeSk7XG4gIH1cbiAgY2xvc2VQYXRoKCkge1xuICAgIGlmICh0aGlzLm9wZW5lZFBhdGgpIHtcbiAgICAgIHRoaXMucGF0aDJkLmNsb3NlUGF0aCgpO1xuICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKDQgLyogQ2xvc2VQYXRoICovKTtcbiAgICAgIHRoaXMub3BlbmVkUGF0aCA9IGZhbHNlO1xuICAgICAgdGhpcy5jbG9zZWRQYXRoID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgY2xlYXIodHJhY2tDaGFuZ2VzKSB7XG4gICAgaWYgKHRyYWNrQ2hhbmdlcykge1xuICAgICAgdGhpcy5wcmV2aW91c0NvbW1hbmRzID0gdGhpcy5jb21tYW5kcztcbiAgICAgIHRoaXMucHJldmlvdXNQYXJhbXMgPSB0aGlzLnBhcmFtcztcbiAgICAgIHRoaXMucHJldmlvdXNDbG9zZWRQYXRoID0gdGhpcy5jbG9zZWRQYXRoO1xuICAgIH1cbiAgICB0aGlzLnBhdGgyZCA9IG5ldyBQYXRoMkQoKTtcbiAgICB0aGlzLm9wZW5lZFBhdGggPSBmYWxzZTtcbiAgICB0aGlzLmNsb3NlZFBhdGggPSBmYWxzZTtcbiAgICB0aGlzLmNvbW1hbmRzID0gW107XG4gICAgdGhpcy5wYXJhbXMgPSBbXTtcbiAgfVxuICBpc1BvaW50SW5QYXRoKHgsIHkpIHtcbiAgICBjb25zdCBjb21tYW5kcyA9IHRoaXMuY29tbWFuZHM7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgY29uc3QgY24gPSBjb21tYW5kcy5sZW5ndGg7XG4gICAgY29uc3Qgb3ggPSAtMWU0O1xuICAgIGNvbnN0IG95ID0gLTFlNDtcbiAgICBsZXQgc3ggPSBOYU47XG4gICAgbGV0IHN5ID0gTmFOO1xuICAgIGxldCBweCA9IDA7XG4gICAgbGV0IHB5ID0gMDtcbiAgICBsZXQgaW50ZXJzZWN0aW9uQ291bnQgPSAwO1xuICAgIGZvciAobGV0IGNpID0gMCwgcGkgPSAwOyBjaSA8IGNuOyBjaSsrKSB7XG4gICAgICBzd2l0Y2ggKGNvbW1hbmRzW2NpXSkge1xuICAgICAgICBjYXNlIDAgLyogTW92ZSAqLzpcbiAgICAgICAgICBpbnRlcnNlY3Rpb25Db3VudCArPSBzZWdtZW50SW50ZXJzZWN0aW9uKHN4LCBzeSwgcHgsIHB5LCBveCwgb3ksIHgsIHkpO1xuICAgICAgICAgIHB4ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIHN4ID0gcHg7XG4gICAgICAgICAgcHkgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgc3kgPSBweTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxIC8qIExpbmUgKi86XG4gICAgICAgICAgaW50ZXJzZWN0aW9uQ291bnQgKz0gc2VnbWVudEludGVyc2VjdGlvbihweCwgcHksIHBhcmFtc1twaSsrXSwgcGFyYW1zW3BpKytdLCBveCwgb3ksIHgsIHkpO1xuICAgICAgICAgIHB4ID0gcGFyYW1zW3BpIC0gMl07XG4gICAgICAgICAgcHkgPSBwYXJhbXNbcGkgLSAxXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzIC8qIEN1cnZlICovOlxuICAgICAgICAgIGludGVyc2VjdGlvbkNvdW50ICs9IGN1YmljU2VnbWVudEludGVyc2VjdGlvbnMoXG4gICAgICAgICAgICBweCxcbiAgICAgICAgICAgIHB5LFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgb3gsXG4gICAgICAgICAgICBveSxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5XG4gICAgICAgICAgKTtcbiAgICAgICAgICBweCA9IHBhcmFtc1twaSAtIDJdO1xuICAgICAgICAgIHB5ID0gcGFyYW1zW3BpIC0gMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMiAvKiBBcmMgKi86XG4gICAgICAgICAgY29uc3QgY3ggPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgY3kgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgciA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBzdGFydEFuZ2xlID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IGVuZEFuZ2xlID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IGNvdW50ZXJDbG9ja3dpc2UgPSBCb29sZWFuKHBhcmFtc1twaSsrXSk7XG4gICAgICAgICAgaW50ZXJzZWN0aW9uQ291bnQgKz0gYXJjSW50ZXJzZWN0aW9ucyhcbiAgICAgICAgICAgIGN4LFxuICAgICAgICAgICAgY3ksXG4gICAgICAgICAgICByLFxuICAgICAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgICAgIGVuZEFuZ2xlLFxuICAgICAgICAgICAgY291bnRlckNsb2Nrd2lzZSxcbiAgICAgICAgICAgIG94LFxuICAgICAgICAgICAgb3ksXG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCFpc05hTihzeCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0WCA9IGN4ICsgTWF0aC5jb3Moc3RhcnRBbmdsZSkgKiByO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRZID0gY3kgKyBNYXRoLnNpbihzdGFydEFuZ2xlKSAqIHI7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25Db3VudCArPSBzZWdtZW50SW50ZXJzZWN0aW9uKHB4LCBweSwgc3RhcnRYLCBzdGFydFksIG94LCBveSwgeCwgeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHB4ID0gY3ggKyBNYXRoLmNvcyhlbmRBbmdsZSkgKiByO1xuICAgICAgICAgIHB5ID0gY3kgKyBNYXRoLnNpbihlbmRBbmdsZSkgKiByO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQgLyogQ2xvc2VQYXRoICovOlxuICAgICAgICAgIGludGVyc2VjdGlvbkNvdW50ICs9IHNlZ21lbnRJbnRlcnNlY3Rpb24oc3gsIHN5LCBweCwgcHksIG94LCBveSwgeCwgeSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25Db3VudCAlIDIgPT09IDE7XG4gIH1cbiAgZGlzdGFuY2VTcXVhcmVkKHgsIHkpIHtcbiAgICBsZXQgYmVzdCA9IEluZmluaXR5O1xuICAgIGNvbnN0IGNvbW1hbmRzID0gdGhpcy5jb21tYW5kcztcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnBhcmFtcztcbiAgICBjb25zdCBjbiA9IGNvbW1hbmRzLmxlbmd0aDtcbiAgICBsZXQgc3ggPSBOYU47XG4gICAgbGV0IHN5ID0gTmFOO1xuICAgIGxldCBweCA9IDA7XG4gICAgbGV0IHB5ID0gMDtcbiAgICBmb3IgKGxldCBjaSA9IDAsIHBpID0gMDsgY2kgPCBjbjsgY2krKykge1xuICAgICAgc3dpdGNoIChjb21tYW5kc1tjaV0pIHtcbiAgICAgICAgY2FzZSAwIC8qIE1vdmUgKi86XG4gICAgICAgICAgcHggPSBzeCA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBweSA9IHN5ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEgLyogTGluZSAqLzoge1xuICAgICAgICAgIGNvbnN0IG54ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IG55ID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGJlc3QgPSBsaW5lRGlzdGFuY2VTcXVhcmVkKHgsIHksIHB4LCBweSwgbngsIG55LCBiZXN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDMgLyogQ3VydmUgKi86XG4gICAgICAgICAgTG9nZ2VyLmVycm9yKFwiQ29tbWFuZC5DdXJ2ZSBkaXN0YW5jZVNxdWFyZSBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMiAvKiBBcmMgKi86IHtcbiAgICAgICAgICBjb25zdCBjeCA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCBjeSA9IHBhcmFtc1twaSsrXTtcbiAgICAgICAgICBjb25zdCByID0gcGFyYW1zW3BpKytdO1xuICAgICAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3QgZW5kQW5nbGUgPSBwYXJhbXNbcGkrK107XG4gICAgICAgICAgY29uc3Qgc3RhcnRYID0gY3ggKyBNYXRoLmNvcyhzdGFydEFuZ2xlKSAqIHI7XG4gICAgICAgICAgY29uc3Qgc3RhcnRZID0gY3kgKyBNYXRoLnNpbihzdGFydEFuZ2xlKSAqIHI7XG4gICAgICAgICAgY29uc3QgY291bnRlckNsb2Nrd2lzZSA9IEJvb2xlYW4ocGFyYW1zW3BpKytdKTtcbiAgICAgICAgICBiZXN0ID0gbGluZURpc3RhbmNlU3F1YXJlZCh4LCB5LCBweCwgcHksIHN0YXJ0WCwgc3RhcnRZLCBiZXN0KTtcbiAgICAgICAgICBiZXN0ID0gYXJjRGlzdGFuY2VTcXVhcmVkKHgsIHksIGN4LCBjeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNvdW50ZXJDbG9ja3dpc2UsIGJlc3QpO1xuICAgICAgICAgIHB4ID0gY3ggKyBNYXRoLmNvcyhlbmRBbmdsZSkgKiByO1xuICAgICAgICAgIHB5ID0gY3kgKyBNYXRoLnNpbihlbmRBbmdsZSkgKiByO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNCAvKiBDbG9zZVBhdGggKi86XG4gICAgICAgICAgYmVzdCA9IGxpbmVEaXN0YW5jZVNxdWFyZWQoeCwgeSwgcHgsIHB5LCBzeCwgc3ksIGJlc3QpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmVzdDtcbiAgfVxuICBnZXRQb2ludHMoKSB7XG4gICAgY29uc3QgeyBjb21tYW5kcywgcGFyYW1zIH0gPSB0aGlzO1xuICAgIGNvbnN0IGNvb3JkcyA9IFtdO1xuICAgIGxldCBwaSA9IDA7XG4gICAgZm9yIChsZXQgY2kgPSAwOyBjaSA8IGNvbW1hbmRzLmxlbmd0aDsgY2krKykge1xuICAgICAgc3dpdGNoIChjb21tYW5kc1tjaV0pIHtcbiAgICAgICAgY2FzZSAwIC8qIE1vdmUgKi86XG4gICAgICAgIGNhc2UgMSAvKiBMaW5lICovOlxuICAgICAgICAgIGNvb3Jkcy5wdXNoKHsgeDogcGFyYW1zW3BpKytdLCB5OiBwYXJhbXNbcGkrK10gfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMyAvKiBDdXJ2ZSAqLzpcbiAgICAgICAgICBwaSArPSA0O1xuICAgICAgICAgIGNvb3Jkcy5wdXNoKHsgeDogcGFyYW1zW3BpKytdLCB5OiBwYXJhbXNbcGkrK10gfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMiAvKiBBcmMgKi86XG4gICAgICAgICAgY29vcmRzLnB1c2goeyB4OiBwYXJhbXNbcGkrK10sIHk6IHBhcmFtc1twaSsrXSB9KTtcbiAgICAgICAgICBwaSArPSA0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQgLyogQ2xvc2VQYXRoICovOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29vcmRzO1xuICB9XG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1NWRy9BdHRyaWJ1dGUvZFxuICBjb21wdXRlU1ZHRGF0YVBhdGgob3gsIG95KSB7XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgY29uc3QgeyBjb21tYW5kcywgcGFyYW1zIH0gPSB0aGlzO1xuICAgIGxldCBwaSA9IDA7XG4gICAgZm9yIChsZXQgY2kgPSAwOyBjaSA8IGNvbW1hbmRzLmxlbmd0aDsgY2krKykge1xuICAgICAgc3dpdGNoIChjb21tYW5kc1tjaV0pIHtcbiAgICAgICAgY2FzZSAwIC8qIE1vdmUgKi86XG4gICAgICAgICAgYnVmZmVyLnB1c2goXCJNXCIsIG94ICsgcGFyYW1zW3BpKytdLCBveSArIHBhcmFtc1twaSsrXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMSAvKiBMaW5lICovOlxuICAgICAgICAgIGJ1ZmZlci5wdXNoKFwiTFwiLCBveCArIHBhcmFtc1twaSsrXSwgb3kgKyBwYXJhbXNbcGkrK10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDMgLyogQ3VydmUgKi86XG4gICAgICAgICAgYnVmZmVyLnB1c2goXG4gICAgICAgICAgICBcIkNcIixcbiAgICAgICAgICAgIG94ICsgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgb3kgKyBwYXJhbXNbcGkrK10sXG4gICAgICAgICAgICBveCArIHBhcmFtc1twaSsrXSxcbiAgICAgICAgICAgIG95ICsgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgb3ggKyBwYXJhbXNbcGkrK10sXG4gICAgICAgICAgICBveSArIHBhcmFtc1twaSsrXVxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMiAvKiBBcmMgKi86XG4gICAgICAgICAgY29uc3QgW2N4LCBjeSwgciwgYTAsIGExLCBjY3ddID0gW1xuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdLFxuICAgICAgICAgICAgcGFyYW1zW3BpKytdXG4gICAgICAgICAgXTtcbiAgICAgICAgICBjb25zdCB4MCA9IG94ICsgY3ggKyBNYXRoLmNvcyhhMCkgKiByO1xuICAgICAgICAgIGNvbnN0IHkwID0gb3kgKyBjeSArIE1hdGguc2luKGEwKSAqIHI7XG4gICAgICAgICAgY29uc3QgeDEgPSBveCArIGN4ICsgTWF0aC5jb3MoYTEpICogcjtcbiAgICAgICAgICBjb25zdCB5MSA9IG95ICsgY3kgKyBNYXRoLnNpbihhMSkgKiByO1xuICAgICAgICAgIGNvbnN0IGxhcmdlQXJjRmxhZyA9IGFuZ2xlRGlmZihhMCwgYTEsICEhY2N3KSA+IE1hdGguUEkgPyAxIDogMDtcbiAgICAgICAgICBjb25zdCBzd2VlcEZsYWcgPSAoY2N3ICsgMSkgJSAyO1xuICAgICAgICAgIGNvbnN0IG1vdmUgPSBidWZmZXIubGVuZ3RoID09PSAwID8gXCJNXCIgOiBcIkxcIjtcbiAgICAgICAgICBidWZmZXIucHVzaChtb3ZlLCB4MCwgeTAsIFwiQVwiLCByLCByLCAwLCBsYXJnZUFyY0ZsYWcsIHN3ZWVwRmxhZywgeDEsIHkxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0IC8qIENsb3NlUGF0aCAqLzpcbiAgICAgICAgICBidWZmZXIucHVzaChcIlpcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIuam9pbihcIiBcIik7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NoYXBlL3BhdGgudHNcbmZ1bmN0aW9uIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbihvcHRzKSB7XG4gIGNvbnN0IHsgcmVkcmF3ID0gMyAvKiBNQUpPUiAqLywgY2hhbmdlQ2IsIGNvbnZlcnRvciB9ID0gb3B0cyA/PyB7fTtcbiAgcmV0dXJuIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3LCB0eXBlOiBcInBhdGhcIiwgY29udmVydG9yLCBjaGFuZ2VDYiB9KTtcbn1cbnZhciBQYXRoID0gY2xhc3MgZXh0ZW5kcyBTaGFwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgLyoqXG4gICAgICogRGVjbGFyZSBhIHBhdGggdG8gcmV0YWluIGZvciBsYXRlciByZW5kZXJpbmcgYW5kIGhpdCB0ZXN0aW5nXG4gICAgICogdXNpbmcgY3VzdG9tIFBhdGgyRCBjbGFzcy4gVGhpbmsgb2YgaXQgYXMgYSBUeXBlU2NyaXB0IHZlcnNpb25cbiAgICAgKiBvZiB0aGUgbmF0aXZlIFBhdGgyRCAod2l0aCBzb21lIGRpZmZlcmVuY2VzKSB0aGF0IHdvcmtzIGluIGFsbCBicm93c2Vycy5cbiAgICAgKi9cbiAgICB0aGlzLnBhdGggPSBuZXcgRXh0ZW5kZWRQYXRoMkQoKTtcbiAgICB0aGlzLl9jbGlwWCA9IE5hTjtcbiAgICB0aGlzLl9jbGlwWSA9IE5hTjtcbiAgICAvKipcbiAgICAgKiBUaGUgcGF0aCBvbmx5IGhhcyB0byBiZSB1cGRhdGVkIHdoZW4gY2VydGFpbiBhdHRyaWJ1dGVzIGNoYW5nZS5cbiAgICAgKiBGb3IgZXhhbXBsZSwgaWYgdHJhbnNmb3JtIGF0dHJpYnV0ZXMgKHN1Y2ggYXMgYHRyYW5zbGF0aW9uWGApXG4gICAgICogYXJlIGNoYW5nZWQsIHdlIGRvbid0IGhhdmUgdG8gdXBkYXRlIHRoZSBwYXRoLiBUaGUgYGRpcnR5UGF0aGAgZmxhZ1xuICAgICAqIGlzIGhvdyB3ZSBrZWVwIHRyYWNrIGlmIHRoZSBwYXRoIGhhcyB0byBiZSB1cGRhdGVkIG9yIG5vdC5cbiAgICAgKi9cbiAgICB0aGlzLl9kaXJ0eVBhdGggPSB0cnVlO1xuICB9XG4gIHNldCBjbGlwWCh2YWx1ZSkge1xuICAgIHRoaXMuX2NsaXBYID0gdmFsdWU7XG4gICAgdGhpcy5kaXJ0eVBhdGggPSB0cnVlO1xuICB9XG4gIHNldCBjbGlwWSh2YWx1ZSkge1xuICAgIHRoaXMuX2NsaXBZID0gdmFsdWU7XG4gICAgdGhpcy5kaXJ0eVBhdGggPSB0cnVlO1xuICB9XG4gIHNldCBkaXJ0eVBhdGgodmFsdWUpIHtcbiAgICBpZiAodGhpcy5fZGlydHlQYXRoICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5fZGlydHlQYXRoID0gdmFsdWU7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXJrRGlydHkodGhpcywgMyAvKiBNQUpPUiAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBkaXJ0eVBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RpcnR5UGF0aDtcbiAgfVxuICBjaGVja1BhdGhEaXJ0eSgpIHtcbiAgICBpZiAodGhpcy5fZGlydHlQYXRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGlydHlQYXRoID0gdGhpcy5wYXRoLmlzRGlydHkoKSB8fCAodGhpcy5maWxsU2hhZG93Py5pc0RpcnR5KCkgPz8gZmFsc2UpIHx8ICh0aGlzLl9jbGlwUGF0aD8uaXNEaXJ0eSgpID8/IGZhbHNlKTtcbiAgfVxuICBpc1BvaW50SW5QYXRoKHgsIHkpIHtcbiAgICBjb25zdCBwb2ludCA9IHRoaXMudHJhbnNmb3JtUG9pbnQoeCwgeSk7XG4gICAgcmV0dXJuIHRoaXMucGF0aC5jbG9zZWRQYXRoICYmIHRoaXMucGF0aC5pc1BvaW50SW5QYXRoKHBvaW50LngsIHBvaW50LnkpO1xuICB9XG4gIGRpc3RhbmNlU3F1YXJlZCh4LCB5KSB7XG4gICAgY29uc3QgcG9pbnQgPSB0aGlzLnRyYW5zZm9ybVBvaW50KHgsIHkpO1xuICAgIHJldHVybiB0aGlzLmRpc3RhbmNlU3F1YXJlZFRyYW5zZm9ybWVkUG9pbnQocG9pbnQueCwgcG9pbnQueSk7XG4gIH1cbiAgY29tcHV0ZVNWR0RhdGFQYXRoKCkge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy5pbnZlcnNlVHJhbnNmb3JtUG9pbnQoMCwgMCk7XG4gICAgaWYgKHRoaXMuZGlydHlQYXRoKSB7XG4gICAgICB0aGlzLnVwZGF0ZVBhdGgoKTtcbiAgICAgIHRoaXMuZGlydHlQYXRoID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhdGguY29tcHV0ZVNWR0RhdGFQYXRoKHgsIHkpO1xuICB9XG4gIGRpc3RhbmNlU3F1YXJlZFRyYW5zZm9ybWVkUG9pbnQoeCwgeSkge1xuICAgIGlmICh0aGlzLnBhdGguY2xvc2VkUGF0aCAmJiB0aGlzLnBhdGguaXNQb2ludEluUGF0aCh4LCB5KSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBhdGguZGlzdGFuY2VTcXVhcmVkKHgsIHkpO1xuICB9XG4gIGlzRGlydHlQYXRoKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB1cGRhdGVQYXRoKCkge1xuICB9XG4gIHJlbmRlcihyZW5kZXJDdHgpIHtcbiAgICBjb25zdCB7IGN0eCwgZm9yY2VSZW5kZXIsIHN0YXRzIH0gPSByZW5kZXJDdHg7XG4gICAgaWYgKHRoaXMuZGlydHkgPT09IDAgLyogTk9ORSAqLyAmJiAhZm9yY2VSZW5kZXIpIHtcbiAgICAgIGlmIChzdGF0cylcbiAgICAgICAgc3RhdHMubm9kZXNTa2lwcGVkICs9IHRoaXMubm9kZUNvdW50LmNvdW50O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnRyYW5zZm9ybVJlbmRlckNvbnRleHQocmVuZGVyQ3R4KTtcbiAgICBpZiAodGhpcy5kaXJ0eVBhdGggfHwgdGhpcy5pc0RpcnR5UGF0aCgpKSB7XG4gICAgICB0aGlzLnVwZGF0ZVBhdGgoKTtcbiAgICAgIHRoaXMuZGlydHlQYXRoID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNOYU4odGhpcy5fY2xpcFgpICYmICFpc05hTih0aGlzLl9jbGlwWSkgJiYgdGhpcy5jbGlwTW9kZSAhPSBudWxsKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY29uc3QgbWFyZ2luID0gdGhpcy5zdHJva2VXaWR0aCAvIDI7XG4gICAgICB0aGlzLl9jbGlwUGF0aCA/PyAodGhpcy5fY2xpcFBhdGggPSBuZXcgRXh0ZW5kZWRQYXRoMkQoKSk7XG4gICAgICB0aGlzLl9jbGlwUGF0aC5jbGVhcigpO1xuICAgICAgdGhpcy5fY2xpcFBhdGgucmVjdCgtbWFyZ2luLCAtbWFyZ2luLCB0aGlzLl9jbGlwWCArIG1hcmdpbiwgdGhpcy5fY2xpcFkgKyBtYXJnaW4gKyBtYXJnaW4pO1xuICAgICAgaWYgKHRoaXMuY2xpcE1vZGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgY3R4LmNsaXAodGhpcy5fY2xpcFBhdGg/LmdldFBhdGgyRCgpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9jbGlwWCA+IDAgJiYgdGhpcy5fY2xpcFkgPiAwKSB7XG4gICAgICAgIHRoaXMuZHJhd1BhdGgoY3R4KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNsaXBNb2RlID09PSBcInB1bmNoLW91dFwiKSB7XG4gICAgICAgIGN0eC5jbGlwKHRoaXMuX2NsaXBQYXRoPy5nZXRQYXRoMkQoKSk7XG4gICAgICAgIGNvbnN0IHsgeCA9IC0xZTQsIHkgPSAtMWU0LCB3aWR0aCA9IDJlNCwgaGVpZ2h0ID0gMmU0IH0gPSB0aGlzLmdldEJCb3goKSA/PyB7fTtcbiAgICAgICAgY3R4LmNsZWFyUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZHJhd1BhdGgoY3R4KTtcbiAgICB9XG4gICAgdGhpcy5maWxsU2hhZG93Py5tYXJrQ2xlYW4oKTtcbiAgICBzdXBlci5yZW5kZXIocmVuZGVyQ3R4KTtcbiAgfVxuICBkcmF3UGF0aChjdHgpIHtcbiAgICB0aGlzLmZpbGxTdHJva2UoY3R4LCB0aGlzLnBhdGguZ2V0UGF0aDJEKCkpO1xuICB9XG59O1xuUGF0aC5jbGFzc05hbWUgPSBcIlBhdGhcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBQYXRoLnByb3RvdHlwZSwgXCJjbGlwTW9kZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBQYXRoLnByb3RvdHlwZSwgXCJjbGlwWFwiLCAxKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBQYXRoLnByb3RvdHlwZSwgXCJjbGlwWVwiLCAxKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZG9tL2ZvY3VzU3R5bGVzLnRzXG52YXIgZm9jdXNTdHlsZXNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZm9jdXNTdHlsZXNfZXhwb3J0cywge1xuICBibG9jazogKCkgPT4gYmxvY2ssXG4gIGVsZW1lbnRzOiAoKSA9PiBlbGVtZW50cyxcbiAgbW9kaWZpZXJzOiAoKSA9PiBtb2RpZmllcnNcbn0pO1xudmFyIGJsb2NrID0gXCJhZy1jaGFydHMtZm9jdXNcIjtcbnZhciBlbGVtZW50cyA9IHsgaW5kaWNhdG9yOiBcImFnLWNoYXJ0cy1mb2N1c19faW5kaWNhdG9yXCIsIHN2ZzogXCJhZy1jaGFydHMtZm9jdXNfX3N2Z1wiIH07XG52YXIgbW9kaWZpZXJzID0geyBoaWRkZW46IFwiYWctY2hhcnRzLWZvY3VzLS1oaWRkZW5cIiB9O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kb20vZm9jdXNJbmRpY2F0b3IudHNcbnZhciBGb2N1c0luZGljYXRvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZG9tTWFuYWdlcikge1xuICAgIHRoaXMuZG9tTWFuYWdlciA9IGRvbU1hbmFnZXI7XG4gICAgY29uc3QgeyBibG9jazogYmxvY2szLCBlbGVtZW50czogZWxlbWVudHMzLCBtb2RpZmllcnM6IG1vZGlmaWVyczMgfSA9IGZvY3VzU3R5bGVzX2V4cG9ydHM7XG4gICAgdGhpcy5kaXYgPSBnZXREb2N1bWVudCgpLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5zdmcgPSBnZXREb2N1bWVudCgpLmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwic3ZnXCIpO1xuICAgIHRoaXMucGF0aCA9IGdldERvY3VtZW50KCkuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgXCJwYXRoXCIpO1xuICAgIHRoaXMuc3ZnLmFwcGVuZCh0aGlzLnBhdGgpO1xuICAgIHRoaXMuZWxlbWVudCA9IGRvbU1hbmFnZXIuYWRkQ2hpbGQoXCJjYW52YXMtb3ZlcmxheVwiLCBibG9jazMpO1xuICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKGJsb2NrMywgZWxlbWVudHMzLmluZGljYXRvciwgbW9kaWZpZXJzMy5oaWRkZW4pO1xuICAgIHRoaXMuZWxlbWVudC5hcmlhSGlkZGVuID0gXCJ0cnVlXCI7XG4gICAgdGhpcy5lbGVtZW50LmFwcGVuZCh0aGlzLnN2Zyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRvbU1hbmFnZXIucmVtb3ZlU3R5bGVzKGJsb2NrKTtcbiAgICB0aGlzLmRvbU1hbmFnZXIucmVtb3ZlQ2hpbGQoXCJjYW52YXMtb3ZlcmxheVwiLCBibG9jayk7XG4gIH1cbiAgdXBkYXRlQm91bmRzKGJvdW5kcykge1xuICAgIGlmIChib3VuZHMgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQobW9kaWZpZXJzLmhpZGRlbik7XG4gICAgfSBlbHNlIGlmIChib3VuZHMgaW5zdGFuY2VvZiBQYXRoKSB7XG4gICAgICB0aGlzLnBhdGguc2V0QXR0cmlidXRlKFwiZFwiLCBib3VuZHMuY29tcHV0ZVNWR0RhdGFQYXRoKCkpO1xuICAgICAgdGhpcy5zaG93KHRoaXMuc3ZnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RWxlbWVudEJCb3godGhpcy5kaXYsIGJvdW5kcyk7XG4gICAgICB0aGlzLnNob3codGhpcy5kaXYpO1xuICAgIH1cbiAgfVxuICBzaG93KGNoaWxkKSB7XG4gICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUobW9kaWZpZXJzLmhpZGRlbik7XG4gICAgdGhpcy5lbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG4gICAgdGhpcy5lbGVtZW50LmFwcGVuZChjaGlsZCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2RvbS9ib3VuZGVkVGV4dC50c1xudmFyIEJvdW5kZWRUZXh0ID0gY2xhc3Mge1xuICBzZXQgdGV4dENvbnRlbnQodGV4dCkge1xuICAgIHRoaXMudGV4dEVsZW1lbnQudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgIGNvbnN0IGJib3hDYWxjdWxhdG9yID0gdGhpcy50ZXh0RWxlbWVudDtcbiAgICBjb25zdCBiYm94ID0gYmJveENhbGN1bGF0b3IuZ2V0QkJveD8uKCk7XG4gICAgaWYgKGJib3gpIHtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIGAke2Jib3gueH0gJHtiYm94Lnl9ICR7YmJveC53aWR0aH0gJHtiYm94LmhlaWdodH1gKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHRleHRDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLnRleHRFbGVtZW50LnRleHRDb250ZW50O1xuICB9XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudGV4dEVsZW1lbnQgPSBjcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInRleHRcIik7XG4gICAgdGhpcy50ZXh0RWxlbWVudC5yb2xlID0gXCJwcmVzZW50YXRpb25cIjtcbiAgICB0aGlzLnN2Z0VsZW1lbnQgPSBjcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcInN2Z1wiKTtcbiAgICB0aGlzLnN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy50ZXh0RWxlbWVudCk7XG4gICAgdGhpcy5zdmdFbGVtZW50LnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgdGhpcy5zdmdFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSBcIjBcIjtcbiAgICB0aGlzLnN2Z0VsZW1lbnQucm9sZSA9IFwicHJlc2VudGF0aW9uXCI7XG4gICAgdGhpcy5ib3VuZGVkQ29udGFpbmVyID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLmJvdW5kZWRDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zdmdFbGVtZW50KTtcbiAgICB0aGlzLmJvdW5kZWRDb250YWluZXIucm9sZSA9IFwicHJlc2VudGF0aW9uXCI7XG4gIH1cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMuYm91bmRlZENvbnRhaW5lci5yZW1vdmUoKTtcbiAgfVxuICBnZXRDb250YWluZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm91bmRlZENvbnRhaW5lcjtcbiAgfVxuICB1cGRhdGVCb3VuZHMoYm91bmRzKSB7XG4gICAgc2V0RWxlbWVudEJCb3godGhpcy5ib3VuZGVkQ29udGFpbmVyLCBib3VuZHMpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kb20vcHJveHlJbnRlcmFjdGlvblNlcnZpY2UudHNcbmZ1bmN0aW9uIGNoZWNrVHlwZSh0eXBlLCBtZXRhKSB7XG4gIHJldHVybiBtZXRhLnBhcmFtcz8udHlwZSA9PT0gdHlwZTtcbn1cbmZ1bmN0aW9uIGFsbG9jYXRlUmVzdWx0KHR5cGUpIHtcbiAgaWYgKFwiYnV0dG9uXCIgPT09IHR5cGUpIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgfSBlbHNlIGlmIChcInNsaWRlclwiID09PSB0eXBlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgfSBlbHNlIGlmIChcInRvb2xiYXJcIiA9PT0gdHlwZSB8fCBcImdyb3VwXCIgPT09IHR5cGUpIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgfSBlbHNlIGlmIChcInRleHRcIiA9PT0gdHlwZSkge1xuICAgIHJldHVybiBuZXcgQm91bmRlZFRleHQoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBFcnJvcihcIkFHIENoYXJ0cyAtIGVycm9yIGFsbG9jYXRpbmcgbWV0YVwiKTtcbiAgfVxufVxuZnVuY3Rpb24gYWxsb2NhdGVNZXRhKHBhcmFtcykge1xuICBjb25zdCBtZXRhID0geyBwYXJhbXMsIHJlc3VsdDogdm9pZCAwIH07XG4gIG1ldGEucmVzdWx0ID0gYWxsb2NhdGVSZXN1bHQobWV0YS5wYXJhbXMudHlwZSk7XG4gIHJldHVybiBtZXRhO1xufVxudmFyIFByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih1cGRhdGVTZXJ2aWNlLCBsb2NhbGVNYW5hZ2VyLCBkb21NYW5hZ2VyLCBmb2N1c0luZGljYXRvcikge1xuICAgIHRoaXMubG9jYWxlTWFuYWdlciA9IGxvY2FsZU1hbmFnZXI7XG4gICAgdGhpcy5kb21NYW5hZ2VyID0gZG9tTWFuYWdlcjtcbiAgICB0aGlzLmZvY3VzSW5kaWNhdG9yID0gZm9jdXNJbmRpY2F0b3I7XG4gICAgLy8gVGhpcyBkZWJ1ZyBvcHRpb24gbWFrZSB0aGUgcHJveGllcyBidXR0b24gcGFydGlhbGx5IHRyYW5zcGFyZW50IGluc3RlYWQgb2YgZnVsbHkgdHJhbnNwYXJlbnQuXG4gICAgLy8gVG8gZW5hYmxlZCB0aGlzIG9wdGlvbiwgc2V0IHdpbmRvdy5hZ0NoYXJ0c0RlYnVnID0gWydzaG93RE9NUHJveGllcyddLlxuICAgIHRoaXMuZGVidWdTaG93RE9NUHJveGllcyA9IERlYnVnLmNoZWNrKFwic2hvd0RPTVByb3hpZXNcIik7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2godXBkYXRlU2VydmljZS5hZGRMaXN0ZW5lcihcInVwZGF0ZS1jb21wbGV0ZVwiLCAoKSA9PiB0aGlzLnVwZGF0ZSgpKSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICBpZiAodGhpcy5mb2N1c2FibGUpIHtcbiAgICAgIHRoaXMuZm9jdXNJbmRpY2F0b3IudXBkYXRlQm91bmRzKHRoaXMuZm9jdXNhYmxlLmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKSk7XG4gICAgfVxuICB9XG4gIGFkZExvY2FsaXNhdGlvbihmbikge1xuICAgIGZuKCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2godGhpcy5sb2NhbGVNYW5hZ2VyLmFkZExpc3RlbmVyKFwibG9jYWxlLWNoYW5nZWRcIiwgZm4pKTtcbiAgfVxuICBjcmVhdGVQcm94eUNvbnRhaW5lcihhcmdzKSB7XG4gICAgY29uc3QgbWV0YSA9IGFsbG9jYXRlTWV0YShhcmdzKTtcbiAgICBjb25zdCB7IHBhcmFtcywgcmVzdWx0OiBkaXYgfSA9IG1ldGE7XG4gICAgdGhpcy5kb21NYW5hZ2VyLmFkZENoaWxkKFwiY2FudmFzLW92ZXJsYXlcIiwgcGFyYW1zLmlkLCBkaXYpO1xuICAgIGRpdi5jbGFzc0xpc3QuYWRkKC4uLnBhcmFtcy5jbGFzc0xpc3QpO1xuICAgIGRpdi5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgZGl2LnJvbGUgPSBwYXJhbXMudHlwZTtcbiAgICBkaXYuYXJpYU9yaWVudGF0aW9uID0gcGFyYW1zLmFyaWFPcmllbnRhdGlvbjtcbiAgICBpZiAodHlwZW9mIHBhcmFtcy5hcmlhSGlkZGVuID09PSBcImJvb2xlYW5cIikge1xuICAgICAgZGl2LmFyaWFIaWRkZW4gPSBwYXJhbXMuYXJpYUhpZGRlbi50b1N0cmluZygpO1xuICAgIH1cbiAgICB0aGlzLmFkZExvY2FsaXNhdGlvbigoKSA9PiB7XG4gICAgICBkaXYuYXJpYUxhYmVsID0gdGhpcy5sb2NhbGVNYW5hZ2VyLnQocGFyYW1zLmFyaWFMYWJlbC5pZCwgcGFyYW1zLmFyaWFMYWJlbC5wYXJhbXMpO1xuICAgIH0pO1xuICAgIHJldHVybiBkaXY7XG4gIH1cbiAgY3JlYXRlUHJveHlFbGVtZW50KGFyZ3MpIHtcbiAgICBjb25zdCBtZXRhID0gYWxsb2NhdGVNZXRhKGFyZ3MpO1xuICAgIGlmIChjaGVja1R5cGUoXCJidXR0b25cIiwgbWV0YSkpIHtcbiAgICAgIGNvbnN0IHsgcGFyYW1zLCByZXN1bHQ6IGJ1dHRvbiB9ID0gbWV0YTtcbiAgICAgIHRoaXMuaW5pdEludGVyYWN0KHBhcmFtcywgYnV0dG9uKTtcbiAgICAgIGlmICh0eXBlb2YgcGFyYW1zLnRleHRDb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9IHBhcmFtcy50ZXh0Q29udGVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgdGV4dENvbnRlbnQgfSA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5hZGRMb2NhbGlzYXRpb24oKCkgPT4ge1xuICAgICAgICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9IHRoaXMubG9jYWxlTWFuYWdlci50KHRleHRDb250ZW50LmlkLCB0ZXh0Q29udGVudC5wYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNoZWNrVHlwZShcInNsaWRlclwiLCBtZXRhKSkge1xuICAgICAgY29uc3QgeyBwYXJhbXMsIHJlc3VsdDogc2xpZGVyIH0gPSBtZXRhO1xuICAgICAgdGhpcy5pbml0SW50ZXJhY3QocGFyYW1zLCBzbGlkZXIpO1xuICAgICAgc2xpZGVyLnR5cGUgPSBcInJhbmdlXCI7XG4gICAgICBzbGlkZXIucm9sZSA9IFwicHJlc2VudGF0aW9uXCI7XG4gICAgICBzbGlkZXIuc3R5bGUubWFyZ2luID0gXCIwcHhcIjtcbiAgICAgIHNsaWRlci5hcmlhT3JpZW50YXRpb24gPSBwYXJhbXMuYXJpYU9yaWVudGF0aW9uO1xuICAgICAgdGhpcy5hZGRMb2NhbGlzYXRpb24oKCkgPT4ge1xuICAgICAgICBzbGlkZXIuYXJpYUxhYmVsID0gdGhpcy5sb2NhbGVNYW5hZ2VyLnQocGFyYW1zLmFyaWFMYWJlbC5pZCwgcGFyYW1zLmFyaWFMYWJlbC5wYXJhbXMpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChjaGVja1R5cGUoXCJ0ZXh0XCIsIG1ldGEpKSB7XG4gICAgICBjb25zdCB7IHBhcmFtcywgcmVzdWx0OiB0ZXh0IH0gPSBtZXRhO1xuICAgICAgdGhpcy5pbml0RWxlbWVudChwYXJhbXMsIHRleHQuZ2V0Q29udGFpbmVyKCkpO1xuICAgIH1cbiAgICByZXR1cm4gbWV0YS5yZXN1bHQ7XG4gIH1cbiAgaW5pdEVsZW1lbnQocGFyYW1zLCBlbGVtZW50Mikge1xuICAgIGNvbnN0IHsgaWQsIHBhcmVudCB9ID0gcGFyYW1zO1xuICAgIGVsZW1lbnQyLmlkID0gaWQ7XG4gICAgZWxlbWVudDIuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgIGVsZW1lbnQyLnN0eWxlLm9wYWNpdHkgPSB0aGlzLmRlYnVnU2hvd0RPTVByb3hpZXMgPyBcIjAuMjVcIiA6IFwiMFwiO1xuICAgIGVsZW1lbnQyLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIGVsZW1lbnQyLnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICBpZiAodHlwZW9mIHBhcmVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhpcy5kb21NYW5hZ2VyLmFkZENoaWxkKHBhcmVudCwgaWQsIGVsZW1lbnQyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50LmFwcGVuZENoaWxkKGVsZW1lbnQyKTtcbiAgICB9XG4gIH1cbiAgaW5pdEludGVyYWN0KHBhcmFtcywgZWxlbWVudDIpIHtcbiAgICBjb25zdCB7IGZvY3VzYWJsZSwgb25jbGljaywgb25jaGFuZ2UsIG9uZm9jdXMsIG9uYmx1ciwgdGFiSW5kZXggfSA9IHBhcmFtcztcbiAgICB0aGlzLmluaXRFbGVtZW50KHBhcmFtcywgZWxlbWVudDIpO1xuICAgIGlmICh0YWJJbmRleCAhPT0gdm9pZCAwKSB7XG4gICAgICBlbGVtZW50Mi50YWJJbmRleCA9IHRhYkluZGV4O1xuICAgIH1cbiAgICBlbGVtZW50Mi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgKF9ldmVudCkgPT4ge1xuICAgICAgdGhpcy5mb2N1c2FibGUgPSBmb2N1c2FibGU7XG4gICAgICBlbGVtZW50Mi5zdHlsZS5zZXRQcm9wZXJ0eShcInBvaW50ZXJFdmVudHNcIiwgbnVsbCk7XG4gICAgICB0aGlzLmZvY3VzSW5kaWNhdG9yLnVwZGF0ZUJvdW5kcyhmb2N1c2FibGUuY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpKTtcbiAgICB9KTtcbiAgICBlbGVtZW50Mi5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCAoX2V2ZW50KSA9PiB7XG4gICAgICB0aGlzLmZvY3VzYWJsZSA9IHZvaWQgMDtcbiAgICAgIGVsZW1lbnQyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICAgIHRoaXMuZm9jdXNJbmRpY2F0b3IudXBkYXRlQm91bmRzKHZvaWQgMCk7XG4gICAgfSk7XG4gICAgaWYgKG9uY2xpY2spIHtcbiAgICAgIGVsZW1lbnQyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBvbmNsaWNrKTtcbiAgICB9XG4gICAgaWYgKG9uZm9jdXMpIHtcbiAgICAgIGVsZW1lbnQyLmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBvbmZvY3VzKTtcbiAgICB9XG4gICAgaWYgKG9uYmx1cikge1xuICAgICAgZWxlbWVudDIuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgb25ibHVyKTtcbiAgICB9XG4gICAgaWYgKG9uY2hhbmdlKSB7XG4gICAgICBlbGVtZW50Mi5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIG9uY2hhbmdlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL2FuaW1hdGlvbkJhdGNoLnRzXG52YXIgQW5pbWF0aW9uQmF0Y2ggPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG1heEFuaW1hdGlvblRpbWUpIHtcbiAgICB0aGlzLm1heEFuaW1hdGlvblRpbWUgPSBtYXhBbmltYXRpb25UaW1lO1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJhbmltYXRpb25cIik7XG4gICAgdGhpcy5jb250cm9sbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5zdG9wcGVkQ2JzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLmN1cnJlbnRQaGFzZSA9IDA7XG4gICAgdGhpcy5waGFzZXMgPSBuZXcgTWFwKFBIQVNFX09SREVSLm1hcCgocCkgPT4gW3AsIFtdXSkpO1xuICAgIHRoaXMuc2tpcEFuaW1hdGlvbnMgPSBmYWxzZTtcbiAgICB0aGlzLmFuaW1hdGlvblRpbWVDb25zdW1lZCA9IDA7XG4gICAgLyoqIEd1YXJkIGFnYWluc3QgcHJlbWF0dXJlIGFuaW1hdGlvbiBleGVjdXRpb24uICovXG4gICAgdGhpcy5pc1JlYWR5ID0gZmFsc2U7XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbGxlcnMuc2l6ZTtcbiAgfVxuICBnZXQgY29uc3VtZWRUaW1lTXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uVGltZUNvbnN1bWVkO1xuICB9XG4gIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXJzLnNpemUgPiAwO1xuICB9XG4gIGdldEFjdGl2ZUNvbnRyb2xsZXJzKCkge1xuICAgIHJldHVybiB0aGlzLnBoYXNlcy5nZXQoUEhBU0VfT1JERVJbdGhpcy5jdXJyZW50UGhhc2VdKSA/PyBbXTtcbiAgfVxuICBjaGVja092ZXJsYXBwaW5nSWQoaWQpIHtcbiAgICBpZiAoaWQgIT0gbnVsbCAmJiB0aGlzLmNvbnRyb2xsZXJzLmhhcyhpZCkpIHtcbiAgICAgIHRoaXMuY29udHJvbGxlcnMuZ2V0KGlkKS5zdG9wKCk7XG4gICAgICB0aGlzLmRlYnVnKGBTa2lwcGluZyBhbmltYXRpb24gYmF0Y2ggZHVlIHRvIHVwZGF0ZSBvZiBleGlzdGluZyBhbmltYXRpb246ICR7aWR9YCk7XG4gICAgICB0aGlzLnNraXAoKTtcbiAgICB9XG4gIH1cbiAgYWRkQW5pbWF0aW9uKGFuaW1hdGlvbikge1xuICAgIGlmIChhbmltYXRpb24uaXNDb21wbGV0ZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBhbmltYXRpb25QaGFzZUlkeCA9IFBIQVNFX09SREVSLmluZGV4T2YoYW5pbWF0aW9uLnBoYXNlKTtcbiAgICBpZiAoYW5pbWF0aW9uUGhhc2VJZHggPCB0aGlzLmN1cnJlbnRQaGFzZSkge1xuICAgICAgdGhpcy5kZWJ1ZyhgU2tpcHBpbmcgYW5pbWF0aW9uIGR1ZSB0byBiZWluZyBmb3IgYW4gZWFybGllciBwaGFzZWAsIGFuaW1hdGlvbi5pZCk7XG4gICAgICBhbmltYXRpb24uc3RvcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmNvbnRyb2xsZXJzLnNldChhbmltYXRpb24uaWQsIGFuaW1hdGlvbik7XG4gICAgdGhpcy5waGFzZXMuZ2V0KGFuaW1hdGlvbi5waGFzZSk/LnB1c2goYW5pbWF0aW9uKTtcbiAgfVxuICByZW1vdmVBbmltYXRpb24oYW5pbWF0aW9uKSB7XG4gICAgdGhpcy5jb250cm9sbGVycy5kZWxldGUoYW5pbWF0aW9uLmlkKTtcbiAgICBjb25zdCBwaGFzZSA9IHRoaXMucGhhc2VzLmdldChhbmltYXRpb24ucGhhc2UpO1xuICAgIGNvbnN0IGluZGV4ID0gcGhhc2U/LmluZGV4T2YoYW5pbWF0aW9uKTtcbiAgICBpZiAoaW5kZXggIT0gbnVsbCAmJiBpbmRleCA+PSAwKSB7XG4gICAgICBwaGFzZT8uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gIH1cbiAgcHJvZ3Jlc3MoZGVsdGFUaW1lKSB7XG4gICAgaWYgKCF0aGlzLmlzUmVhZHkpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHVudXNlZFRpbWUgPSBkZWx0YVRpbWUgPT09IDAgPyAwLjAxIDogZGVsdGFUaW1lO1xuICAgIGNvbnN0IHJlZnJlc2ggPSAoKSA9PiB7XG4gICAgICBjb25zdCBwaGFzZTIgPSBQSEFTRV9PUkRFUlt0aGlzLmN1cnJlbnRQaGFzZV07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwaGFzZUNvbnRyb2xsZXJzOiBbLi4udGhpcy5nZXRBY3RpdmVDb250cm9sbGVycygpXSxcbiAgICAgICAgcGhhc2U6IHBoYXNlMixcbiAgICAgICAgcGhhc2VNZXRhOiBQSEFTRV9NRVRBREFUQVtwaGFzZTJdXG4gICAgICB9O1xuICAgIH07XG4gICAgbGV0IHsgcGhhc2UsIHBoYXNlQ29udHJvbGxlcnMsIHBoYXNlTWV0YSB9ID0gcmVmcmVzaCgpO1xuICAgIGNvbnN0IGFyZVBoYXNlc0NvbXBsZXRlID0gKCkgPT4gUEhBU0VfT1JERVJbdGhpcy5jdXJyZW50UGhhc2VdID09IG51bGw7XG4gICAgY29uc3QgcHJvZ3Jlc3NQaGFzZSA9ICgpID0+IHtcbiAgICAgICh7IHBoYXNlLCBwaGFzZUNvbnRyb2xsZXJzLCBwaGFzZU1ldGEgfSA9IHJlZnJlc2goKSk7XG4gICAgICB3aGlsZSAoIWFyZVBoYXNlc0NvbXBsZXRlKCkgJiYgcGhhc2VDb250cm9sbGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5jdXJyZW50UGhhc2UrKztcbiAgICAgICAgKHsgcGhhc2UsIHBoYXNlQ29udHJvbGxlcnMsIHBoYXNlTWV0YSB9ID0gcmVmcmVzaCgpKTtcbiAgICAgICAgdGhpcy5kZWJ1ZyhgQW5pbWF0aW9uQmF0Y2ggLSBwaGFzZSBjaGFuZ2luZyB0byAke3BoYXNlfWAsIHsgdW51c2VkVGltZSB9LCBwaGFzZUNvbnRyb2xsZXJzKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHRvdGFsID0gdGhpcy5jb250cm9sbGVycy5zaXplO1xuICAgIHRoaXMuZGVidWcoYEFuaW1hdGlvbkJhdGNoIC0gJHtkZWx0YVRpbWV9bXM7IHBoYXNlICR7cGhhc2V9IHdpdGggJHtwaGFzZUNvbnRyb2xsZXJzPy5sZW5ndGh9IG9mICR7dG90YWx9YCk7XG4gICAgZG8ge1xuICAgICAgY29uc3QgcGhhc2VEZWx0YVRpbWUgPSB1bnVzZWRUaW1lO1xuICAgICAgY29uc3Qgc2tpcFBoYXNlID0gcGhhc2VNZXRhLnNraXBJZk5vRWFybGllckFuaW1hdGlvbnMgJiYgdGhpcy5hbmltYXRpb25UaW1lQ29uc3VtZWQgPT09IDA7XG4gICAgICBsZXQgY29tcGxldGVDb3VudCA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGNvbnRyb2xsZXIgb2YgcGhhc2VDb250cm9sbGVycykge1xuICAgICAgICBpZiAoc2tpcFBoYXNlKSB7XG4gICAgICAgICAgY29udHJvbGxlci5zdG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW51c2VkVGltZSA9IE1hdGgubWluKGNvbnRyb2xsZXIudXBkYXRlKHBoYXNlRGVsdGFUaW1lKSwgdW51c2VkVGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuaXNDb21wbGV0ZSkge1xuICAgICAgICAgIGNvbXBsZXRlQ291bnQrKztcbiAgICAgICAgICB0aGlzLnJlbW92ZUFuaW1hdGlvbihjb250cm9sbGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5hbmltYXRpb25UaW1lQ29uc3VtZWQgKz0gcGhhc2VEZWx0YVRpbWUgLSB1bnVzZWRUaW1lO1xuICAgICAgdGhpcy5kZWJ1ZyhgQW5pbWF0aW9uQmF0Y2ggLSB1cGRhdGVkICR7cGhhc2VDb250cm9sbGVycy5sZW5ndGh9IGNvbnRyb2xsZXJzOyAke2NvbXBsZXRlQ291bnR9IGNvbXBsZXRlZGApO1xuICAgICAgdGhpcy5kZWJ1ZyhgQW5pbWF0aW9uQmF0Y2ggLSBhbmltYXRpb25UaW1lQ29uc3VtZWQ6ICR7dGhpcy5hbmltYXRpb25UaW1lQ29uc3VtZWR9YCk7XG4gICAgICBwcm9ncmVzc1BoYXNlKCk7XG4gICAgfSB3aGlsZSAodW51c2VkVGltZSA+IDAgJiYgIWFyZVBoYXNlc0NvbXBsZXRlKCkpO1xuICAgIGlmICh0aGlzLmFuaW1hdGlvblRpbWVDb25zdW1lZCA+IHRoaXMubWF4QW5pbWF0aW9uVGltZSkge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgICBcIkFuaW1hdGlvbiBiYXRjaCBleGNlZWRlZCBtYXggYW5pbWF0aW9uIHRpbWUsIHNraXBwaW5nLlwiLFxuICAgICAgICBuZXcgTWFwKHRoaXMuY29udHJvbGxlcnMuZW50cmllcygpKVxuICAgICAgKTtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH1cbiAgfVxuICByZWFkeSgpIHtcbiAgICBpZiAodGhpcy5pc1JlYWR5KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuaXNSZWFkeSA9IHRydWU7XG4gICAgdGhpcy5kZWJ1ZyhgQW5pbWF0aW9uQmF0Y2ggLSByZWFkeTsgc2tpcHBlZDogJHt0aGlzLnNraXBBbmltYXRpb25zfWAsIFsuLi50aGlzLmNvbnRyb2xsZXJzXSk7XG4gICAgbGV0IHNraXBBbGwgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgWywgY29udHJvbGxlcl0gb2YgdGhpcy5jb250cm9sbGVycykge1xuICAgICAgaWYgKGNvbnRyb2xsZXIuZHVyYXRpb24gPiAwICYmIFBIQVNFX01FVEFEQVRBW2NvbnRyb2xsZXIucGhhc2VdLnNraXBJZk5vRWFybGllckFuaW1hdGlvbnMgIT09IHRydWUpIHtcbiAgICAgICAgc2tpcEFsbCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFza2lwQWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IFssIGNvbnRyb2xsZXJdIG9mIHRoaXMuY29udHJvbGxlcnMpIHtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuYXV0b3BsYXkpIHtcbiAgICAgICAgICBjb250cm9sbGVyLnBsYXkodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc2tpcChza2lwID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLnNraXBBbmltYXRpb25zID09PSBmYWxzZSAmJiBza2lwID09PSB0cnVlKSB7XG4gICAgICBmb3IgKGNvbnN0IGNvbnRyb2xsZXIgb2YgdGhpcy5jb250cm9sbGVycy52YWx1ZXMoKSkge1xuICAgICAgICBjb250cm9sbGVyLnN0b3AoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udHJvbGxlcnMuY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy5za2lwQW5pbWF0aW9ucyA9IHNraXA7XG4gIH1cbiAgcGxheSgpIHtcbiAgICBmb3IgKGNvbnN0IGNvbnRyb2xsZXIgb2YgdGhpcy5jb250cm9sbGVycy52YWx1ZXMoKSkge1xuICAgICAgY29udHJvbGxlci5wbGF5KCk7XG4gICAgfVxuICB9XG4gIHBhdXNlKCkge1xuICAgIGZvciAoY29uc3QgY29udHJvbGxlciBvZiB0aGlzLmNvbnRyb2xsZXJzLnZhbHVlcygpKSB7XG4gICAgICBjb250cm9sbGVyLnBhdXNlKCk7XG4gICAgfVxuICB9XG4gIHN0b3AoKSB7XG4gICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIHRoaXMuY29udHJvbGxlcnMudmFsdWVzKCkpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnRyb2xsZXIuc3RvcCgpO1xuICAgICAgICB0aGlzLnJlbW92ZUFuaW1hdGlvbihjb250cm9sbGVyKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIExvZ2dlci5lcnJvcihcIkVycm9yIGR1cmluZyBhbmltYXRpb24gc3RvcFwiLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZGlzcGF0Y2hTdG9wcGVkKCk7XG4gIH1cbiAgc3RvcEJ5QW5pbWF0aW9uSWQoaWQpIHtcbiAgICBpZiAoaWQgIT0gbnVsbCAmJiB0aGlzLmNvbnRyb2xsZXJzLmhhcyhpZCkpIHtcbiAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB0aGlzLmNvbnRyb2xsZXJzLmdldChpZCk7XG4gICAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLnN0b3AoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVBbmltYXRpb24oY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0b3BCeUFuaW1hdGlvbkdyb3VwSWQoaWQpIHtcbiAgICBmb3IgKGNvbnN0IGNvbnRyb2xsZXIgb2YgdGhpcy5jb250cm9sbGVycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKGNvbnRyb2xsZXIuZ3JvdXBJZCA9PT0gaWQpIHtcbiAgICAgICAgdGhpcy5zdG9wQnlBbmltYXRpb25JZChjb250cm9sbGVyLmlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGlzcGF0Y2hTdG9wcGVkKCkge1xuICAgIHRoaXMuc3RvcHBlZENicy5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgdGhpcy5zdG9wcGVkQ2JzLmNsZWFyKCk7XG4gIH1cbiAgaXNTa2lwcGVkKCkge1xuICAgIHJldHVybiB0aGlzLnNraXBBbmltYXRpb25zO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdG9wKCk7XG4gICAgdGhpcy5jb250cm9sbGVycy5jbGVhcigpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9wcmV2ZW50YWJsZUV2ZW50LnRzXG5mdW5jdGlvbiBidWlsZFByZXZlbnRhYmxlKG9iaikge1xuICBjb25zdCBzZWxmID0ge1xuICAgIC4uLm9iaixcbiAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgIHNlbGYuc291cmNlRXZlbnQ/LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gc2VsZjtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoVHlwZWRFdmVudChsaXN0ZW5lcnMsIGV2ZW50KSB7XG4gIGxpc3RlbmVycy5kaXNwYXRjaFdyYXBIYW5kbGVycyhldmVudC50eXBlLCAoaGFuZGxlciwgZSkgPT4gaGFuZGxlcihlKSwgYnVpbGRQcmV2ZW50YWJsZShldmVudCkpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9pbnRlcmFjdGlvbk1hbmFnZXIudHNcbnZhciBQT0lOVEVSX0lOVEVSQUNUSU9OX1RZUEVTID0gW1xuICBcImNsaWNrXCIsXG4gIFwiZGJsY2xpY2tcIixcbiAgXCJjb250ZXh0bWVudVwiLFxuICBcImhvdmVyXCIsXG4gIFwiZHJhZy1zdGFydFwiLFxuICBcImRyYWdcIixcbiAgXCJkcmFnLWVuZFwiLFxuICBcImxlYXZlXCIsXG4gIFwiZW50ZXJcIixcbiAgXCJwYWdlLWxlZnRcIixcbiAgXCJ3aGVlbFwiXG5dO1xudmFyIEZPQ1VTX0lOVEVSQUNUSU9OX1RZUEVTID0gW1wiYmx1clwiLCBcImZvY3VzXCJdO1xudmFyIEtFWV9JTlRFUkFDVElPTl9UWVBFUyA9IFtcImtleWRvd25cIiwgXCJrZXl1cFwiXTtcbnZhciBTSEFET1dfRE9NX0hBTkRMRVJTID0gW1wibW91c2Vtb3ZlXCIsIFwibW91c2V1cFwiXTtcbnZhciBXSU5ET1dfRVZFTlRfSEFORExFUlMgPSBbXCJwYWdlaGlkZVwiLCBcIm1vdXNlbW92ZVwiLCBcIm1vdXNldXBcIl07XG52YXIgRVZFTlRfSEFORExFUlMgPSBbXG4gIFwiY2xpY2tcIixcbiAgXCJkYmxjbGlja1wiLFxuICBcImNvbnRleHRtZW51XCIsXG4gIFwibW91c2Vkb3duXCIsXG4gIFwibW91c2VsZWF2ZVwiLFxuICBcIm1vdXNlZW50ZXJcIixcbiAgXCJ0b3VjaHN0YXJ0XCIsXG4gIFwidG91Y2htb3ZlXCIsXG4gIFwidG91Y2hlbmRcIixcbiAgXCJ0b3VjaGNhbmNlbFwiLFxuICBcIndoZWVsXCIsXG4gIFwiYmx1clwiLFxuICBcImZvY3VzXCIsXG4gIFwia2V5ZG93blwiLFxuICBcImtleXVwXCJcbl07XG52YXIgSW50ZXJhY3Rpb25TdGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKEludGVyYWN0aW9uU3RhdGUyKSA9PiB7XG4gIEludGVyYWN0aW9uU3RhdGUyW0ludGVyYWN0aW9uU3RhdGUyW1wiRGVmYXVsdFwiXSA9IDE2XSA9IFwiRGVmYXVsdFwiO1xuICBJbnRlcmFjdGlvblN0YXRlMltJbnRlcmFjdGlvblN0YXRlMltcIlpvb21EcmFnXCJdID0gOF0gPSBcIlpvb21EcmFnXCI7XG4gIEludGVyYWN0aW9uU3RhdGUyW0ludGVyYWN0aW9uU3RhdGUyW1wiQW5ub3RhdGlvbnNcIl0gPSA0XSA9IFwiQW5ub3RhdGlvbnNcIjtcbiAgSW50ZXJhY3Rpb25TdGF0ZTJbSW50ZXJhY3Rpb25TdGF0ZTJbXCJDb250ZXh0TWVudVwiXSA9IDJdID0gXCJDb250ZXh0TWVudVwiO1xuICBJbnRlcmFjdGlvblN0YXRlMltJbnRlcmFjdGlvblN0YXRlMltcIkFuaW1hdGlvblwiXSA9IDFdID0gXCJBbmltYXRpb25cIjtcbiAgSW50ZXJhY3Rpb25TdGF0ZTJbSW50ZXJhY3Rpb25TdGF0ZTJbXCJBbGxcIl0gPSAzMV0gPSBcIkFsbFwiO1xuICByZXR1cm4gSW50ZXJhY3Rpb25TdGF0ZTI7XG59KShJbnRlcmFjdGlvblN0YXRlIHx8IHt9KTtcbnZhciBQb2ludGVyQ2FwdHVyZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFBvaW50ZXJDYXB0dXJlMikgPT4ge1xuICBQb2ludGVyQ2FwdHVyZTJbXCJSZXRhaW5cIl0gPSBcInJldGFpblwiO1xuICBQb2ludGVyQ2FwdHVyZTJbXCJFeGNsdXNpdmVcIl0gPSBcImV4Y2x1c2l2ZVwiO1xuICByZXR1cm4gUG9pbnRlckNhcHR1cmUyO1xufSkoUG9pbnRlckNhcHR1cmUgfHwge30pO1xudmFyIHBvaW50ZXJDYXB0dXJlcyA9IG5ldyBTZXQoT2JqZWN0LnZhbHVlcyhQb2ludGVyQ2FwdHVyZSkpO1xuZnVuY3Rpb24gaXNQb2ludGVyRXZlbnQodHlwZSkge1xuICByZXR1cm4gUE9JTlRFUl9JTlRFUkFDVElPTl9UWVBFUy5pbmNsdWRlcyh0eXBlKTtcbn1cbmZ1bmN0aW9uIGlzRm9jdXNFdmVudCh0eXBlKSB7XG4gIHJldHVybiBGT0NVU19JTlRFUkFDVElPTl9UWVBFUy5pbmNsdWRlcyh0eXBlKTtcbn1cbmZ1bmN0aW9uIGlzS2V5RXZlbnQodHlwZSkge1xuICByZXR1cm4gS0VZX0lOVEVSQUNUSU9OX1RZUEVTLmluY2x1ZGVzKHR5cGUpO1xufVxudmFyIF9JbnRlcmFjdGlvbk1hbmFnZXIgPSBjbGFzcyBfSW50ZXJhY3Rpb25NYW5hZ2VyIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihrZXlib2FyZE9wdGlvbnMsIGRvbU1hbmFnZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMua2V5Ym9hcmRPcHRpb25zID0ga2V5Ym9hcmRPcHRpb25zO1xuICAgIHRoaXMuZG9tTWFuYWdlciA9IGRvbU1hbmFnZXI7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcImludGVyYWN0aW9uXCIpO1xuICAgIHRoaXMuZXZlbnRIYW5kbGVyID0gKGV2ZW50KSA9PiB0aGlzLnByb2Nlc3NFdmVudChldmVudCk7XG4gICAgdGhpcy5vdmVybGF5RXZlbnRIYW5kbGVyID0gKGV2ZW50KSA9PiB0aGlzLnByb2Nlc3NDYW52YXNPdmVybGF5RXZlbnQoZXZlbnQpO1xuICAgIHRoaXMubW91c2VEb3duID0gZmFsc2U7XG4gICAgdGhpcy50b3VjaERvd24gPSBmYWxzZTtcbiAgICB0aGlzLnBvaW50ZXJDYXB0dXJlQ2FudmFzRWxlbWVudCA9IHZvaWQgMDtcbiAgICB0aGlzLmNsaWNrSGlzdG9yeSA9IFt7IG9mZnNldFg6IE5hTiwgb2Zmc2V0WTogTmFOLCB0eXBlOiBcIm1vdXNlZG93blwiIH1dO1xuICAgIHRoaXMuZGJsY2xpY2tIaXN0b3J5ID0gW1xuICAgICAgeyBvZmZzZXRYOiBOYU4sIG9mZnNldFk6IE5hTiwgdHlwZTogXCJtb3VzZWRvd25cIiB9LFxuICAgICAgeyBvZmZzZXRYOiBOYU4sIG9mZnNldFk6IE5hTiwgdHlwZTogXCJtb3VzZXVwXCIgfSxcbiAgICAgIHsgb2Zmc2V0WDogTmFOLCBvZmZzZXRZOiBOYU4sIHR5cGU6IFwibW91c2Vkb3duXCIgfVxuICAgIF07XG4gICAgdGhpcy5zdGF0ZVF1ZXVlID0gMTYgLyogRGVmYXVsdCAqLyB8IDEgLyogQW5pbWF0aW9uICovO1xuICAgIHRoaXMucm9vdEVsZW1lbnQgPSB0aGlzLmRvbU1hbmFnZXIuZ2V0RG9jdW1lbnRSb290KCk7XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIEVWRU5UX0hBTkRMRVJTKSB7XG4gICAgICBpZiAodHlwZS5zdGFydHNXaXRoKFwidG91Y2hcIikgfHwgdHlwZSA9PT0gXCJ3aGVlbFwiKSB7XG4gICAgICAgIHRoaXMuZG9tTWFuYWdlci5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuZXZlbnRIYW5kbGVyLCB7IHBhc3NpdmU6IGZhbHNlIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kb21NYW5hZ2VyLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5ldmVudEhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgV0lORE9XX0VWRU5UX0hBTkRMRVJTKSB7XG4gICAgICBnZXRXaW5kb3coKS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuZXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICB0aGlzLmRvbU1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lck9uRWxlbWVudChcImNhbnZhcy1vdmVybGF5XCIsIFwibW91c2VvdmVyXCIsIHRoaXMub3ZlcmxheUV2ZW50SGFuZGxlciksXG4gICAgICB0aGlzLmRvbU1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lck9uRWxlbWVudChcImNhbnZhcy1vdmVybGF5XCIsIFwibW91c2VvdXRcIiwgdGhpcy5vdmVybGF5RXZlbnRIYW5kbGVyKVxuICAgICk7XG4gICAgdGhpcy5jb250YWluZXJDaGFuZ2VkKHRydWUpO1xuICAgIHRoaXMuZG9tTWFuYWdlci5hZGRMaXN0ZW5lcihcImNvbnRhaW5lci1jaGFuZ2VkXCIsICgpID0+IHRoaXMuY29udGFpbmVyQ2hhbmdlZCgpKTtcbiAgfVxuICBjb250YWluZXJDaGFuZ2VkKGZvcmNlID0gZmFsc2UpIHtcbiAgICBjb25zdCBuZXdSb290ID0gdGhpcy5kb21NYW5hZ2VyLmdldERvY3VtZW50Um9vdCgpO1xuICAgIGlmICghZm9yY2UgJiYgbmV3Um9vdCA9PT0gdGhpcy5yb290RWxlbWVudClcbiAgICAgIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgU0hBRE9XX0RPTV9IQU5ETEVSUykge1xuICAgICAgdGhpcy5yb290RWxlbWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmV2ZW50SGFuZGxlcik7XG4gICAgfVxuICAgIHRoaXMucm9vdEVsZW1lbnQgPSBuZXdSb290O1xuICAgIHRoaXMuZGVidWcoXCJbSW50ZXJhY3Rpb25NYW5hZ2VyXSBTd2l0Y2hpbmcgcm9vdEVsZW1lbnQgdG86XCIsIHRoaXMucm9vdEVsZW1lbnQpO1xuICAgIGZvciAoY29uc3QgdHlwZSBvZiBTSEFET1dfRE9NX0hBTkRMRVJTKSB7XG4gICAgICB0aGlzLnJvb3RFbGVtZW50Py5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuZXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIFdJTkRPV19FVkVOVF9IQU5ETEVSUykge1xuICAgICAgZ2V0V2luZG93KCkucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmV2ZW50SGFuZGxlcik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdHlwZSBvZiBTSEFET1dfRE9NX0hBTkRMRVJTKSB7XG4gICAgICB0aGlzLnJvb3RFbGVtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHRoaXMuZXZlbnRIYW5kbGVyKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIEVWRU5UX0hBTkRMRVJTKSB7XG4gICAgICB0aGlzLmRvbU1hbmFnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB0aGlzLmV2ZW50SGFuZGxlcik7XG4gICAgfVxuICAgIHRoaXMuZG9tTWFuYWdlci5yZW1vdmVTdHlsZXMoXCJpbnRlcmFjdGlvbk1hbmFnZXJcIik7XG4gIH1cbiAgLy8gV3JhcHBlciB0byBvbmx5IGJyb2FkY2FzdCBldmVudHMgd2hlbiB0aGUgSW50ZXJhY3Rpb25NYW5hZ2VyIGlzIGEgZ2l2ZW4gc3RhdGUuXG4gIGFkZExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIHRyaWdnZXJpbmdTdGF0ZXMgPSAxNiAvKiBEZWZhdWx0ICovKSB7XG4gICAgcmV0dXJuIHN1cGVyLmFkZExpc3RlbmVyKHR5cGUsIChlKSA9PiB7XG4gICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICBpZiAoY3VycmVudFN0YXRlICYgdHJpZ2dlcmluZ1N0YXRlcykge1xuICAgICAgICBoYW5kbGVyKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHB1c2hTdGF0ZShzdGF0ZSkge1xuICAgIHRoaXMuc3RhdGVRdWV1ZSB8PSBzdGF0ZTtcbiAgfVxuICBwb3BTdGF0ZShzdGF0ZSkge1xuICAgIHRoaXMuc3RhdGVRdWV1ZSAmPSB+c3RhdGU7XG4gIH1cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVRdWV1ZSAmIC10aGlzLnN0YXRlUXVldWU7XG4gIH1cbiAgcHJvY2Vzc0NhbnZhc092ZXJsYXlFdmVudChldmVudCkge1xuICAgIGNvbnN0IGNvb3JkcyA9IHRoaXMuY2FsY3VsYXRlQ29vcmRpbmF0ZXMoZXZlbnQpO1xuICAgIGlmIChjb29yZHMgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBsZXQgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIGxldCBwb2ludGVyQ2FwdHVyZSA9IG51bGw7XG4gICAgd2hpbGUgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgICBwb2ludGVyQ2FwdHVyZSA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBvaW50ZXItY2FwdHVyZVwiKTtcbiAgICAgIGlmIChwb2ludGVyQ2FwdHVyZSA9PSBudWxsKSB7XG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5wYXJlbnRFbGVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0YXJnZXQgPT0gbnVsbCB8fCBwb2ludGVyQ2FwdHVyZSA9PSBudWxsIHx8ICFwb2ludGVyQ2FwdHVyZXMuaGFzKHBvaW50ZXJDYXB0dXJlKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpc092ZXJDYW52YXNPdmVybGF5ID0gZXZlbnQudHlwZSA9PT0gXCJtb3VzZW92ZXJcIjtcbiAgICBjb25zdCBwb2ludGVyQ2FwdHVyZUNhbnZhc0VsZW1lbnQgPSBpc092ZXJDYW52YXNPdmVybGF5ID8gdGFyZ2V0IDogdm9pZCAwO1xuICAgIGlmICh0aGlzLnBvaW50ZXJDYXB0dXJlQ2FudmFzRWxlbWVudCA9PT0gcG9pbnRlckNhcHR1cmVDYW52YXNFbGVtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMucG9pbnRlckNhcHR1cmVDYW52YXNFbGVtZW50ID0gcG9pbnRlckNhcHR1cmVDYW52YXNFbGVtZW50O1xuICAgIGlmIChwb2ludGVyQ2FwdHVyZSA9PT0gXCJleGNsdXNpdmVcIiAvKiBFeGNsdXNpdmUgKi8pIHtcbiAgICAgIGRpc3BhdGNoVHlwZWRFdmVudChcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMsXG4gICAgICAgIHRoaXMuYnVpbGRQb2ludGVyRXZlbnQoeyB0eXBlOiBpc092ZXJDYW52YXNPdmVybGF5ID8gXCJsZWF2ZVwiIDogXCJlbnRlclwiLCBldmVudCwgLi4uY29vcmRzIH0pXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBwcm9jZXNzRXZlbnQoZXZlbnQpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5kZWNpZGVJbnRlcmFjdGlvbkV2ZW50VHlwZXMoZXZlbnQpO1xuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIHRhcmdldD8uYXJpYURpc2FibGVkID09PSBcInRydWVcIikge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgIT0gbnVsbCkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50LCB0eXBlKS5jYXRjaCgoZSkgPT4gTG9nZ2VyLmVycm9yT25jZShlKSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGRpc3BhdGNoRXZlbnQoZXZlbnQsIHR5cGUpIHtcbiAgICBpZiAoaXNQb2ludGVyRXZlbnQodHlwZSkpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hQb2ludGVyRXZlbnQoZXZlbnQsIHR5cGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHJlbGF0ZWRFbGVtZW50LCB0YXJnZXRFbGVtZW50IH0gPSB0aGlzLmV4dHJhY3RFbGVtZW50cyhldmVudCk7XG4gICAgaWYgKGlzRm9jdXNFdmVudCh0eXBlKSkge1xuICAgICAgY29uc3Qgc291cmNlRXZlbnQgPSBldmVudDtcbiAgICAgIGRpc3BhdGNoVHlwZWRFdmVudCh0aGlzLmxpc3RlbmVycywgeyB0eXBlLCBzb3VyY2VFdmVudCwgcmVsYXRlZEVsZW1lbnQsIHRhcmdldEVsZW1lbnQgfSk7XG4gICAgfSBlbHNlIGlmIChpc0tleUV2ZW50KHR5cGUpKSB7XG4gICAgICBjb25zdCBzb3VyY2VFdmVudCA9IGV2ZW50O1xuICAgICAgZGlzcGF0Y2hUeXBlZEV2ZW50KHRoaXMubGlzdGVuZXJzLCB7IHR5cGUsIHNvdXJjZUV2ZW50LCByZWxhdGVkRWxlbWVudCwgdGFyZ2V0RWxlbWVudCB9KTtcbiAgICB9XG4gIH1cbiAgZXh0cmFjdEVsZW1lbnRzKGV2ZW50KSB7XG4gICAgbGV0IHJlbGF0ZWRFbGVtZW50O1xuICAgIGxldCB0YXJnZXRFbGVtZW50O1xuICAgIGlmIChcInJlbGF0ZWRUYXJnZXRcIiBpbiBldmVudCAmJiBldmVudFtcInJlbGF0ZWRUYXJnZXRcIl0gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgcmVsYXRlZEVsZW1lbnQgPSBldmVudFtcInJlbGF0ZWRUYXJnZXRcIl07XG4gICAgfVxuICAgIGlmIChcInRhcmdldFwiIGluIGV2ZW50ICYmIGV2ZW50W1widGFyZ2V0XCJdIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIHRhcmdldEVsZW1lbnQgPSBldmVudFtcInRhcmdldFwiXTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcmVsYXRlZEVsZW1lbnQsIHRhcmdldEVsZW1lbnQgfTtcbiAgfVxuICBkaXNwYXRjaFBvaW50ZXJFdmVudChldmVudCwgdHlwZSkge1xuICAgIGNvbnN0IGNvb3JkcyA9IHRoaXMuY2FsY3VsYXRlQ29vcmRpbmF0ZXMoZXZlbnQpO1xuICAgIGlmIChjb29yZHMgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBkaXNwYXRjaFR5cGVkRXZlbnQodGhpcy5saXN0ZW5lcnMsIHRoaXMuYnVpbGRQb2ludGVyRXZlbnQoeyB0eXBlLCBldmVudCwgLi4uY29vcmRzIH0pKTtcbiAgfVxuICBnZXRFdmVudEhUTUxUYXJnZXQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBldmVudC50YXJnZXQ7XG4gICAgfSBlbHNlIGlmIChldmVudC5jdXJyZW50VGFyZ2V0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJlY29yZERvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KSB7XG4gICAgICBwYXJ0aWFsQXNzaWduKFtcIm9mZnNldFhcIiwgXCJvZmZzZXRZXCJdLCB0aGlzLmNsaWNrSGlzdG9yeVswXSwgZXZlbnQpO1xuICAgICAgcGFydGlhbEFzc2lnbihbXCJvZmZzZXRYXCIsIFwib2Zmc2V0WVwiXSwgdGhpcy5kYmxjbGlja0hpc3RvcnlbMl0sIHRoaXMuZGJsY2xpY2tIaXN0b3J5WzBdKTtcbiAgICAgIHBhcnRpYWxBc3NpZ24oW1wib2Zmc2V0WFwiLCBcIm9mZnNldFlcIl0sIHRoaXMuZGJsY2xpY2tIaXN0b3J5WzBdLCBldmVudCk7XG4gICAgfVxuICAgIHRoaXMuZHJhZ1N0YXJ0RWxlbWVudCA9IHRoaXMuZ2V0RXZlbnRIVE1MVGFyZ2V0KGV2ZW50KTtcbiAgfVxuICByZWNvcmRVcChldmVudCkge1xuICAgIGlmIChldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQpIHtcbiAgICAgIHBhcnRpYWxBc3NpZ24oW1wib2Zmc2V0WFwiLCBcIm9mZnNldFlcIl0sIHRoaXMuZGJsY2xpY2tIaXN0b3J5WzFdLCBldmVudCk7XG4gICAgfVxuICAgIHRoaXMuZHJhZ1N0YXJ0RWxlbWVudCA9IHZvaWQgMDtcbiAgfVxuICBkZWNpZGVJbnRlcmFjdGlvbkV2ZW50VHlwZXMoZXZlbnQpIHtcbiAgICBjb25zdCBkcmFnU3RhcnQgPSBcImRyYWctc3RhcnRcIjtcbiAgICBpZiAodGhpcy5wb2ludGVyQ2FwdHVyZUNhbnZhc0VsZW1lbnQ/LmlzQ29ubmVjdGVkID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5wb2ludGVyQ2FwdHVyZUNhbnZhc0VsZW1lbnQgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmICh0aGlzLnBvaW50ZXJDYXB0dXJlQ2FudmFzRWxlbWVudCAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAoZXZlbnQudHlwZSkge1xuICAgICAgY2FzZSBcImJsdXJcIjpcbiAgICAgIGNhc2UgXCJmb2N1c1wiOlxuICAgICAgY2FzZSBcImtleWRvd25cIjpcbiAgICAgIGNhc2UgXCJrZXl1cFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5rZXlib2FyZE9wdGlvbnMuZW5hYmxlZCA/IGV2ZW50LnR5cGUgOiB2b2lkIDA7XG4gICAgICBjYXNlIFwiY2xpY2tcIjpcbiAgICAgIGNhc2UgXCJkYmxjbGlja1wiOlxuICAgICAgY2FzZSBcImNvbnRleHRtZW51XCI6XG4gICAgICBjYXNlIFwid2hlZWxcIjpcbiAgICAgICAgcmV0dXJuIGV2ZW50LnR5cGU7XG4gICAgICBjYXNlIFwibW91c2Vkb3duXCI6XG4gICAgICAgIGlmICghdGhpcy5pc0V2ZW50T3ZlckVsZW1lbnQoZXZlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWNvcmREb3duKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIGRyYWdTdGFydDtcbiAgICAgIGNhc2UgXCJ0b3VjaHN0YXJ0XCI6XG4gICAgICAgIGlmICghdGhpcy5pc0V2ZW50T3ZlckVsZW1lbnQoZXZlbnQpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG91Y2hEb3duID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWNvcmREb3duKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIGRyYWdTdGFydDtcbiAgICAgIGNhc2UgXCJ0b3VjaG1vdmVcIjpcbiAgICAgIGNhc2UgXCJtb3VzZW1vdmVcIjpcbiAgICAgICAgaWYgKCF0aGlzLm1vdXNlRG93biAmJiAhdGhpcy50b3VjaERvd24gJiYgIXRoaXMuaXNFdmVudE92ZXJFbGVtZW50KGV2ZW50KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZURvd24gfHwgdGhpcy50b3VjaERvd24gPyBcImRyYWdcIiA6IFwiaG92ZXJcIjtcbiAgICAgIGNhc2UgXCJtb3VzZXVwXCI6XG4gICAgICAgIGlmICghdGhpcy5tb3VzZURvd24gJiYgIXRoaXMuaXNFdmVudE92ZXJFbGVtZW50KGV2ZW50KSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlY29yZFVwKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIFwiZHJhZy1lbmRcIjtcbiAgICAgIGNhc2UgXCJ0b3VjaGVuZFwiOlxuICAgICAgICBpZiAoIXRoaXMudG91Y2hEb3duICYmICF0aGlzLmlzRXZlbnRPdmVyRWxlbWVudChldmVudCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3VjaERvd24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWNvcmRVcChldmVudCk7XG4gICAgICAgIHJldHVybiBcImRyYWctZW5kXCI7XG4gICAgICBjYXNlIFwibW91c2VsZWF2ZVwiOlxuICAgICAgY2FzZSBcInRvdWNoY2FuY2VsXCI6XG4gICAgICAgIHJldHVybiBcImxlYXZlXCI7XG4gICAgICBjYXNlIFwibW91c2VlbnRlclwiOlxuICAgICAgICByZXR1cm4gXCJlbnRlclwiO1xuICAgICAgY2FzZSBcInBhZ2VoaWRlXCI6XG4gICAgICAgIHJldHVybiBcInBhZ2UtbGVmdFwiO1xuICAgIH1cbiAgfVxuICBpc0V2ZW50T3ZlckVsZW1lbnQoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5kb21NYW5hZ2VyLmlzRXZlbnRPdmVyRWxlbWVudChldmVudCk7XG4gIH1cbiAgY2FsY3VsYXRlQ29vcmRpbmF0ZXMoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRNb3VzZUV2ZW50Q29vcmRzKGV2ZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBUb3VjaEV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIGV2ZW50IGluc3RhbmNlb2YgVG91Y2hFdmVudCkge1xuICAgICAgY29uc3QgbGFzdFRvdWNoID0gZXZlbnQudG91Y2hlc1swXSA/PyBldmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSwgcGFnZVgsIHBhZ2VZIH0gPSBsYXN0VG91Y2g7XG4gICAgICByZXR1cm4geyAuLi5fSW50ZXJhY3Rpb25NYW5hZ2VyLk5VTExfQ09PUkRTLCBjbGllbnRYLCBjbGllbnRZLCBwYWdlWCwgcGFnZVkgfTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50IGluc3RhbmNlb2YgUGFnZVRyYW5zaXRpb25FdmVudCkge1xuICAgICAgaWYgKGV2ZW50LnBlcnNpc3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gX0ludGVyYWN0aW9uTWFuYWdlci5OVUxMX0NPT1JEUztcbiAgICB9XG4gIH1cbiAgZ2V0TW91c2VFdmVudENvb3JkcyhldmVudCkge1xuICAgIGNvbnN0IHsgY2xpZW50WCwgY2xpZW50WSwgcGFnZVgsIHBhZ2VZIH0gPSBldmVudDtcbiAgICBsZXQgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmdldEV2ZW50SFRNTFRhcmdldChldmVudCk7XG4gICAgY29uc3QgeyB4ID0gMCwgeSA9IDAgfSA9IHRhcmdldCA/IHRoaXMuZG9tTWFuYWdlci5jYWxjdWxhdGVDYW52YXNQb3NpdGlvbih0YXJnZXQpIDoge307XG4gICAgaWYgKHRoaXMuZHJhZ1N0YXJ0RWxlbWVudCAhPSBudWxsICYmIGV2ZW50LnRhcmdldCAhPT0gdGhpcy5kcmFnU3RhcnRFbGVtZW50KSB7XG4gICAgICBjb25zdCBvZmZzZXREcmFnU3RhcnQgPSB0aGlzLmRvbU1hbmFnZXIuY2FsY3VsYXRlQ2FudmFzUG9zaXRpb24odGhpcy5kcmFnU3RhcnRFbGVtZW50KTtcbiAgICAgIG9mZnNldFggLT0gb2Zmc2V0RHJhZ1N0YXJ0LnggLSB4O1xuICAgICAgb2Zmc2V0WSAtPSBvZmZzZXREcmFnU3RhcnQueSAtIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldFggKz0geDtcbiAgICAgIG9mZnNldFkgKz0geTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY2xpZW50WCwgY2xpZW50WSwgcGFnZVgsIHBhZ2VZLCBvZmZzZXRYLCBvZmZzZXRZIH07XG4gIH1cbiAgaXNXaGVlbEV2ZW50KGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnR5cGUgPT09IFwid2hlZWxcIjtcbiAgfVxuICBidWlsZFBvaW50ZXJFdmVudChvcHRzKSB7XG4gICAgY29uc3QgeyB0eXBlLCBldmVudCwgY2xpZW50WCwgY2xpZW50WSB9ID0gb3B0cztcbiAgICBsZXQgeyBvZmZzZXRYLCBvZmZzZXRZLCBwYWdlWCwgcGFnZVkgfSA9IG9wdHM7XG4gICAgaWYgKCFpc0Zpbml0ZU51bWJlcihvZmZzZXRYKSB8fCAhaXNGaW5pdGVOdW1iZXIob2Zmc2V0WSkpIHtcbiAgICAgIGNvbnN0IHJlY3QgPSB0aGlzLmRvbU1hbmFnZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBvZmZzZXRYID0gY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICAgIG9mZnNldFkgPSBjbGllbnRZIC0gcmVjdC50b3A7XG4gICAgfVxuICAgIGlmICghaXNGaW5pdGVOdW1iZXIocGFnZVgpIHx8ICFpc0Zpbml0ZU51bWJlcihwYWdlWSkpIHtcbiAgICAgIGNvbnN0IHBhZ2VSZWN0ID0gdGhpcy5yb290RWxlbWVudD8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBwYWdlWCA9IGNsaWVudFggLSAocGFnZVJlY3Q/LmxlZnQgPz8gMCk7XG4gICAgICBwYWdlWSA9IGNsaWVudFkgLSAocGFnZVJlY3Q/LnRvcCA/PyAwKTtcbiAgICB9XG4gICAgbGV0IFtkZWx0YVgsIGRlbHRhWV0gPSBbTmFOLCBOYU5dO1xuICAgIGlmICh0aGlzLmlzV2hlZWxFdmVudChldmVudCkpIHtcbiAgICAgIGNvbnN0IGZhY3RvciA9IGV2ZW50LmRlbHRhTW9kZSA9PT0gMCA/IDAuMDEgOiAxO1xuICAgICAgZGVsdGFYID0gZXZlbnQuZGVsdGFYICogZmFjdG9yO1xuICAgICAgZGVsdGFZID0gZXZlbnQuZGVsdGFZICogZmFjdG9yO1xuICAgIH1cbiAgICBsZXQgcG9pbnRlckhpc3RvcnkgPSBbXTtcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiKSB7XG4gICAgICBwb2ludGVySGlzdG9yeSA9IHRoaXMuY2xpY2tIaXN0b3J5O1xuICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gXCJkYmxjbGlja1wiKSB7XG4gICAgICBwb2ludGVySGlzdG9yeSA9IHRoaXMuZGJsY2xpY2tIaXN0b3J5O1xuICAgIH1cbiAgICBjb25zdCB7IHJlbGF0ZWRFbGVtZW50LCB0YXJnZXRFbGVtZW50IH0gPSB0aGlzLmV4dHJhY3RFbGVtZW50cyhldmVudCk7XG4gICAgY29uc3QgYnV0dG9uID0gXCJidXR0b25cIiBpbiBldmVudCA/IE51bWJlcihldmVudC5idXR0b24pIDogMDtcbiAgICBjb25zdCBidWlsdEV2ZW50ID0ge1xuICAgICAgdHlwZSxcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZLFxuICAgICAgcGFnZVgsXG4gICAgICBwYWdlWSxcbiAgICAgIGRlbHRhWCxcbiAgICAgIGRlbHRhWSxcbiAgICAgIGJ1dHRvbixcbiAgICAgIHBvaW50ZXJIaXN0b3J5LFxuICAgICAgc291cmNlRXZlbnQ6IGV2ZW50LFxuICAgICAgcmVsYXRlZEVsZW1lbnQsXG4gICAgICB0YXJnZXRFbGVtZW50XG4gICAgfTtcbiAgICB0aGlzLmRlYnVnKFwiSW50ZXJhY3Rpb25NYW5hZ2VyIC0gYnVpbHRFdmVudDogXCIsIGJ1aWx0RXZlbnQpO1xuICAgIHJldHVybiBidWlsdEV2ZW50O1xuICB9XG59O1xuX0ludGVyYWN0aW9uTWFuYWdlci5OVUxMX0NPT1JEUyA9IHtcbiAgY2xpZW50WDogLUluZmluaXR5LFxuICBjbGllbnRZOiAtSW5maW5pdHksXG4gIHBhZ2VYOiAtSW5maW5pdHksXG4gIHBhZ2VZOiAtSW5maW5pdHksXG4gIG9mZnNldFg6IC1JbmZpbml0eSxcbiAgb2Zmc2V0WTogLUluZmluaXR5XG59O1xudmFyIEludGVyYWN0aW9uTWFuYWdlciA9IF9JbnRlcmFjdGlvbk1hbmFnZXI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL2FuaW1hdGlvbk1hbmFnZXIudHNcbmZ1bmN0aW9uIHZhbGlkQW5pbWF0aW9uRHVyYXRpb24odGVzdGVlKSB7XG4gIGlmICh0ZXN0ZWUgPT0gbnVsbClcbiAgICByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuICFpc05hTih0ZXN0ZWUpICYmIHRlc3RlZSA+PSAwICYmIHRlc3RlZSA8PSAyO1xufVxudmFyIEFuaW1hdGlvbk1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoaW50ZXJhY3Rpb25NYW5hZ2VyLCBjaGFydFVwZGF0ZU11dGV4KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmludGVyYWN0aW9uTWFuYWdlciA9IGludGVyYWN0aW9uTWFuYWdlcjtcbiAgICB0aGlzLmNoYXJ0VXBkYXRlTXV0ZXggPSBjaGFydFVwZGF0ZU11dGV4O1xuICAgIHRoaXMuZGVmYXVsdER1cmF0aW9uID0gMWUzO1xuICAgIHRoaXMuYmF0Y2ggPSBuZXcgQW5pbWF0aW9uQmF0Y2godGhpcy5kZWZhdWx0RHVyYXRpb24gKiAxLjUpO1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJhbmltYXRpb25cIik7XG4gICAgdGhpcy5yYWZBdmFpbGFibGUgPSB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpcy5yZXF1ZXN0SWQgPSBudWxsO1xuICAgIHRoaXMuc2tpcEFuaW1hdGlvbnMgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRBbm9ueW1vdXNBbmltYXRpb25JZCA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBhbmltYXRpb24gdG8gdHdlZW4gYSB2YWx1ZSBiZXR3ZWVuIHRoZSBgZnJvbWAgYW5kIGB0b2AgcHJvcGVydGllcy4gSWYgYW4gYW5pbWF0aW9uIGFscmVhZHkgZXhpc3RzXG4gICAqIHdpdGggdGhlIHNhbWUgYGlkYCwgaW1tZWRpYXRlbHkgc3RvcCBpdC5cbiAgICovXG4gIGFuaW1hdGUoeyAuLi5vcHRzIH0pIHtcbiAgICBjb25zdCBiYXRjaCA9IHRoaXMuYmF0Y2g7XG4gICAgdHJ5IHtcbiAgICAgIGJhdGNoLmNoZWNrT3ZlcmxhcHBpbmdJZChvcHRzLmlkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5mYWlsc2FmZU9uRXJyb3IoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgeyBpZCB9ID0gb3B0cztcbiAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgaWQgPSBgX18ke3RoaXMuY3VycmVudEFub255bW91c0FuaW1hdGlvbklkfWA7XG4gICAgICB0aGlzLmN1cnJlbnRBbm9ueW1vdXNBbmltYXRpb25JZCArPSAxO1xuICAgIH1cbiAgICBjb25zdCBza2lwID0gdGhpcy5pc1NraXBwZWQoKSB8fCBvcHRzLnBoYXNlID09PSBcIm5vbmVcIjtcbiAgICBpZiAoc2tpcCkge1xuICAgICAgdGhpcy5kZWJ1ZyhcIkFuaW1hdGlvbk1hbmFnZXIgLSBza2lwcGluZyBhbmltYXRpb25cIik7XG4gICAgfVxuICAgIGNvbnN0IHsgZGVsYXksIGR1cmF0aW9uIH0gPSBvcHRzO1xuICAgIGlmICghdmFsaWRBbmltYXRpb25EdXJhdGlvbihkZWxheSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQW5pbWF0aW9uIGRlbGF5IG9mICR7ZGVsYXl9IGlzIHVuc3VwcG9ydGVkICgke2lkfSlgKTtcbiAgICB9XG4gICAgaWYgKCF2YWxpZEFuaW1hdGlvbkR1cmF0aW9uKGR1cmF0aW9uKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbmltYXRpb24gZHVyYXRpb24gb2YgJHtkdXJhdGlvbn0gaXMgdW5zdXBwb3J0ZWQgKCR7aWR9KWApO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKHtcbiAgICAgIC4uLm9wdHMsXG4gICAgICBpZCxcbiAgICAgIHNraXAsXG4gICAgICBhdXRvcGxheTogdGhpcy5pc1BsYXlpbmcgPyBvcHRzLmF1dG9wbGF5IDogZmFsc2UsXG4gICAgICBwaGFzZTogb3B0cy5waGFzZSxcbiAgICAgIGRlZmF1bHREdXJhdGlvbjogdGhpcy5kZWZhdWx0RHVyYXRpb25cbiAgICB9KTtcbiAgICBpZiAodGhpcy5mb3JjZVRpbWVKdW1wKGFuaW1hdGlvbiwgdGhpcy5kZWZhdWx0RHVyYXRpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYmF0Y2guYWRkQW5pbWF0aW9uKGFuaW1hdGlvbik7XG4gICAgcmV0dXJuIGFuaW1hdGlvbjtcbiAgfVxuICBwbGF5KCkge1xuICAgIGlmICh0aGlzLmlzUGxheWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG4gICAgdGhpcy5kZWJ1ZyhcIkFuaW1hdGlvbk1hbmFnZXIucGxheSgpXCIpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmJhdGNoLnBsYXkoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5mYWlsc2FmZU9uRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLnJlcXVlc3RBbmltYXRpb24oKTtcbiAgfVxuICBwYXVzZSgpIHtcbiAgICBpZiAoIXRoaXMuaXNQbGF5aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpcy5jYW5jZWxBbmltYXRpb24oKTtcbiAgICB0aGlzLmRlYnVnKFwiQW5pbWF0aW9uTWFuYWdlci5wYXVzZSgpXCIpO1xuICAgIHRyeSB7XG4gICAgICB0aGlzLmJhdGNoLnBhdXNlKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuZmFpbHNhZmVPbkVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cbiAgc3RvcCgpIHtcbiAgICB0aGlzLmlzUGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uKCk7XG4gICAgdGhpcy5kZWJ1ZyhcIkFuaW1hdGlvbk1hbmFnZXIuc3RvcCgpXCIpO1xuICAgIHRoaXMuYmF0Y2guc3RvcCgpO1xuICB9XG4gIHN0b3BCeUFuaW1hdGlvbklkKGlkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMuYmF0Y2guc3RvcEJ5QW5pbWF0aW9uSWQoaWQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLmZhaWxzYWZlT25FcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG4gIHN0b3BCeUFuaW1hdGlvbkdyb3VwSWQoaWQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5iYXRjaC5zdG9wQnlBbmltYXRpb25Hcm91cElkKGlkKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5mYWlsc2FmZU9uRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICByZXNldCgpIHtcbiAgICBpZiAodGhpcy5pc1BsYXlpbmcpIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RvcCgpO1xuICAgIH1cbiAgfVxuICBza2lwKHNraXAgPSB0cnVlKSB7XG4gICAgdGhpcy5za2lwQW5pbWF0aW9ucyA9IHNraXA7XG4gIH1cbiAgaXNTa2lwcGVkKCkge1xuICAgIHJldHVybiAhdGhpcy5yYWZBdmFpbGFibGUgfHwgdGhpcy5za2lwQW5pbWF0aW9ucyB8fCB0aGlzLmJhdGNoLmlzU2tpcHBlZCgpO1xuICB9XG4gIGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmlzUGxheWluZyAmJiB0aGlzLmJhdGNoLmlzQWN0aXZlKCk7XG4gIH1cbiAgc2tpcEN1cnJlbnRCYXRjaCgpIHtcbiAgICBpZiAodGhpcy5kZWJ1Zy5jaGVjaygpKSB7XG4gICAgICB0aGlzLmRlYnVnKGBBbmltYXRpb25NYW5hZ2VyIC0gc2tpcEN1cnJlbnRCYXRjaCgpYCwgeyBzdGFjazogbmV3IEVycm9yKCkuc3RhY2sgfSk7XG4gICAgfVxuICAgIHRoaXMuYmF0Y2guc2tpcCgpO1xuICB9XG4gIC8qKiBNb2NraW5nIHBvaW50IGZvciB0ZXN0cyB0byBndWFyYW50ZWUgdGhhdCBhbmltYXRpb24gdXBkYXRlcyBoYXBwZW4uICovXG4gIGlzU2tpcHBpbmdGcmFtZXMoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqIE1vY2tpbmcgcG9pbnQgZm9yIHRlc3RzIHRvIGNhcHR1cmUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGNhbGxiYWNrcy4gKi9cbiAgc2NoZWR1bGVBbmltYXRpb25GcmFtZShjYikge1xuICAgIHRoaXMucmVxdWVzdElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKTtcbiAgfVxuICAvKiogTW9ja2luZyBwb2ludCBmb3IgdGVzdHMgdG8gc2tpcCBhbmltYXRpb25zIHRvIGEgc3BlY2lmaWMgcG9pbnQgaW4gdGltZS4gKi9cbiAgZm9yY2VUaW1lSnVtcChfYW5pbWF0aW9uLCBfZGVmYXVsdER1cmF0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJlcXVlc3RBbmltYXRpb24oKSB7XG4gICAgaWYgKCF0aGlzLnJhZkF2YWlsYWJsZSlcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIXRoaXMuYmF0Y2guaXNBY3RpdmUoKSB8fCB0aGlzLnJlcXVlc3RJZCAhPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBsZXQgcHJldlRpbWU7XG4gICAgY29uc3Qgb25BbmltYXRpb25GcmFtZSA9IGFzeW5jICh0aW1lMikgPT4ge1xuICAgICAgY29uc3QgZXhlY3V0ZUFuaW1hdGlvbkZyYW1lID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBkZWx0YVRpbWUgPSB0aW1lMiAtIChwcmV2VGltZSA/PyB0aW1lMik7XG4gICAgICAgIHByZXZUaW1lID0gdGltZTI7XG4gICAgICAgIHRoaXMuZGVidWcoXCJBbmltYXRpb25NYW5hZ2VyIC0gb25BbmltYXRpb25GcmFtZSgpXCIsIHtcbiAgICAgICAgICBjb250cm9sbGVyc0NvdW50OiB0aGlzLmJhdGNoLnNpemUsXG4gICAgICAgICAgZGVsdGFUaW1lXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmludGVyYWN0aW9uTWFuYWdlci5wdXNoU3RhdGUoMSAvKiBBbmltYXRpb24gKi8pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuYmF0Y2gucHJvZ3Jlc3MoZGVsdGFUaW1lKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICB0aGlzLmZhaWxzYWZlT25FcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJhbmltYXRpb24tZnJhbWVcIiwge1xuICAgICAgICAgIHR5cGU6IFwiYW5pbWF0aW9uLWZyYW1lXCIsXG4gICAgICAgICAgZGVsdGFNczogZGVsdGFUaW1lXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmlzU2tpcHBpbmdGcmFtZXMoKSkge1xuICAgICAgICBhd2FpdCB0aGlzLmNoYXJ0VXBkYXRlTXV0ZXguYWNxdWlyZUltbWVkaWF0ZWx5KGV4ZWN1dGVBbmltYXRpb25GcmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCB0aGlzLmNoYXJ0VXBkYXRlTXV0ZXguYWNxdWlyZShleGVjdXRlQW5pbWF0aW9uRnJhbWUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYmF0Y2guaXNBY3RpdmUoKSkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlQW5pbWF0aW9uRnJhbWUob25BbmltYXRpb25GcmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJhdGNoLnN0b3AoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJhbmltYXRpb24tc3RvcFwiLCB7XG4gICAgICAgICAgdHlwZTogXCJhbmltYXRpb24tc3RvcFwiLFxuICAgICAgICAgIGRlbHRhTXM6IHRoaXMuYmF0Y2guY29uc3VtZWRUaW1lTXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImFuaW1hdGlvbi1zdGFydFwiLCB7XG4gICAgICB0eXBlOiBcImFuaW1hdGlvbi1zdGFydFwiLFxuICAgICAgZGVsdGFNczogMFxuICAgIH0pO1xuICAgIHRoaXMuc2NoZWR1bGVBbmltYXRpb25GcmFtZShvbkFuaW1hdGlvbkZyYW1lKTtcbiAgfVxuICBjYW5jZWxBbmltYXRpb24oKSB7XG4gICAgaWYgKHRoaXMucmVxdWVzdElkID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmVxdWVzdElkKTtcbiAgICB0aGlzLnJlcXVlc3RJZCA9IG51bGw7XG4gICAgdGhpcy5zdGFydEJhdGNoKCk7XG4gIH1cbiAgZmFpbHNhZmVPbkVycm9yKGVycm9yLCBjYW5jZWxBbmltYXRpb24gPSB0cnVlKSB7XG4gICAgTG9nZ2VyLmVycm9yKFwiRXJyb3IgZHVyaW5nIGFuaW1hdGlvbiwgc2tpcHBpbmcgYW5pbWF0aW9uc1wiLCBlcnJvcik7XG4gICAgaWYgKGNhbmNlbEFuaW1hdGlvbikge1xuICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb24oKTtcbiAgICB9XG4gIH1cbiAgc3RhcnRCYXRjaChza2lwQW5pbWF0aW9ucykge1xuICAgIHRoaXMuZGVidWcoYEFuaW1hdGlvbk1hbmFnZXIgLSBzdGFydEJhdGNoKCkgd2l0aCBza2lwQW5pbWF0aW9ucz0ke3NraXBBbmltYXRpb25zfS5gKTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgdGhpcy5iYXRjaC5zdG9wKCk7XG4gICAgdGhpcy5iYXRjaC5kZXN0cm95KCk7XG4gICAgdGhpcy5iYXRjaCA9IG5ldyBBbmltYXRpb25CYXRjaCh0aGlzLmRlZmF1bHREdXJhdGlvbiAqIDEuNSk7XG4gICAgaWYgKHNraXBBbmltYXRpb25zID09PSB0cnVlKSB7XG4gICAgICB0aGlzLmJhdGNoLnNraXAoKTtcbiAgICB9XG4gIH1cbiAgZW5kQmF0Y2goKSB7XG4gICAgaWYgKHRoaXMuYmF0Y2guaXNBY3RpdmUoKSkge1xuICAgICAgdGhpcy5iYXRjaC5yZWFkeSgpO1xuICAgICAgdGhpcy5yZXF1ZXN0QW5pbWF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyLnBvcFN0YXRlKDEgLyogQW5pbWF0aW9uICovKTtcbiAgICAgIGlmICh0aGlzLmJhdGNoLmlzU2tpcHBlZCgpKSB7XG4gICAgICAgIHRoaXMuYmF0Y2guc2tpcChmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uQmF0Y2hTdG9wKGNiKSB7XG4gICAgdGhpcy5iYXRjaC5zdG9wcGVkQ2JzLmFkZChjYik7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL2FyaWFBbm5vdW5jZW1lbnRTZXJ2aWNlcy50c1xudmFyIEFyaWFBbm5vdW5jZW1lbnRTZXJ2aWNlID0gY2xhc3MgX0FyaWFBbm5vdW5jZW1lbnRTZXJ2aWNlIHtcbiAgY29uc3RydWN0b3IobG9jYWxlTWFuYWdlciwgZG9tTWFuYWdlciwgbGF5b3V0U2VydmljZSkge1xuICAgIHRoaXMubG9jYWxlTWFuYWdlciA9IGxvY2FsZU1hbmFnZXI7XG4gICAgdGhpcy5kb21NYW5hZ2VyID0gZG9tTWFuYWdlcjtcbiAgICB0aGlzLmxheW91dFNlcnZpY2UgPSBsYXlvdXRTZXJ2aWNlO1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJhcmlhXCIpO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICAgIHRoaXMubGl2ZUVsZW0gPSBfQXJpYUFubm91bmNlbWVudFNlcnZpY2UuY3JlYXRlQW5ub3VuY2VyKCk7XG4gICAgdGhpcy5kb21NYW5hZ2VyLmFkZENoaWxkKFwiY2FudmFzLXByb3h5XCIsIFwiYWctY2hhcnRzLWNhbnZhcy1wcm94eVwiLCB0aGlzLmxpdmVFbGVtKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIHRoaXMubGF5b3V0U2VydmljZS5hZGRMaXN0ZW5lcihcImxheW91dC1jb21wbGV0ZVwiLCAoZXYpID0+IHRoaXMub25SZXNpemUoZXYpKSxcbiAgICAgICgpID0+IHRoaXMuZG9tTWFuYWdlci5yZW1vdmVDaGlsZChcImNhbnZhcy1wcm94eVwiLCBcImFnLWNoYXJ0cy1jYW52YXMtcHJveHlcIilcbiAgICApO1xuICB9XG4gIHN0YXRpYyBjcmVhdGVBbm5vdW5jZXIoKSB7XG4gICAgY29uc3QgZSA9IGdldERvY3VtZW50KCkuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBlLmNsYXNzTGlzdC5hZGQoXCJhZy1jaGFydHMtYXJpYS1hbm5vdW5jZXJcIik7XG4gICAgc2V0QXR0cmlidXRlKGUsIFwicm9sZVwiLCBcInN0YXR1c1wiKTtcbiAgICBzZXRBdHRyaWJ1dGUoZSwgXCJhcmlhLWxpdmVcIiwgXCJhc3NlcnRpdmVcIik7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICB9XG4gIG9uUmVzaXplKGV2ZW50KSB7XG4gICAgdGhpcy5saXZlRWxlbS5zdHlsZS53aWR0aCA9IGAke2V2ZW50LmNoYXJ0LndpZHRofXB4YDtcbiAgICB0aGlzLmxpdmVFbGVtLnN0eWxlLmhlaWdodCA9IGAke2V2ZW50LmNoYXJ0LmhlaWdodH1weGA7XG4gIH1cbiAgYW5ub3VuY2VWYWx1ZShpZCwgcGFyYW1zKSB7XG4gICAgY29uc3QgeyBsb2NhbGVNYW5hZ2VyLCBsaXZlRWxlbSB9ID0gdGhpcztcbiAgICBjb25zdCB2YWx1ZSA9IGxvY2FsZU1hbmFnZXIudChpZCwgcGFyYW1zKTtcbiAgICB0aGlzLmRlYnVnKGBBcmlhQW5ub3VuY2VtZW50U2VydmljZSAtIGFubm91bmNlVmFsdWU6ICR7dmFsdWV9YCk7XG4gICAgbGl2ZUVsZW0udGV4dENvbnRlbnQgPSBcIlxceEEwXCI7XG4gICAgc2V0VGltZW91dCgoKSA9PiBsaXZlRWxlbS5pbm5lclRleHQgPSB2YWx1ZSwgMTYpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9jaGFydEV2ZW50TWFuYWdlci50c1xudmFyIENoYXJ0RXZlbnRNYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGxlZ2VuZEl0ZW1DbGljayhzZXJpZXMsIGl0ZW1JZCwgZW5hYmxlZCwgbGVnZW5kSXRlbU5hbWUpIHtcbiAgICBjb25zdCBldmVudCA9IHtcbiAgICAgIHR5cGU6IFwibGVnZW5kLWl0ZW0tY2xpY2tcIixcbiAgICAgIHNlcmllcyxcbiAgICAgIGl0ZW1JZCxcbiAgICAgIGVuYWJsZWQsXG4gICAgICBsZWdlbmRJdGVtTmFtZVxuICAgIH07XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJsZWdlbmQtaXRlbS1jbGlja1wiLCBldmVudCk7XG4gIH1cbiAgbGVnZW5kSXRlbURvdWJsZUNsaWNrKHNlcmllcywgaXRlbUlkLCBlbmFibGVkLCBudW1WaXNpYmxlSXRlbXMsIGxlZ2VuZEl0ZW1OYW1lKSB7XG4gICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICB0eXBlOiBcImxlZ2VuZC1pdGVtLWRvdWJsZS1jbGlja1wiLFxuICAgICAgc2VyaWVzLFxuICAgICAgaXRlbUlkLFxuICAgICAgZW5hYmxlZCxcbiAgICAgIGxlZ2VuZEl0ZW1OYW1lLFxuICAgICAgbnVtVmlzaWJsZUl0ZW1zXG4gICAgfTtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImxlZ2VuZC1pdGVtLWRvdWJsZS1jbGlja1wiLCBldmVudCk7XG4gIH1cbiAgYXhpc0hvdmVyKGF4aXNJZCwgZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICB0eXBlOiBcImF4aXMtaG92ZXJcIixcbiAgICAgIGF4aXNJZCxcbiAgICAgIGRpcmVjdGlvblxuICAgIH07XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJheGlzLWhvdmVyXCIsIGV2ZW50KTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vY29udGV4dE1lbnVSZWdpc3RyeS50c1xudmFyIENvbnRleHRNZW51UmVnaXN0cnkgPSBjbGFzcyBfQ29udGV4dE1lbnVSZWdpc3RyeSB7XG4gIGNvbnN0cnVjdG9yKHJlZ2lvbk1hbmFnZXIpIHtcbiAgICB0aGlzLmRlZmF1bHRBY3Rpb25zID0gW107XG4gICAgdGhpcy5kaXNhYmxlZEFjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuaGlkZGVuQWN0aW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBuZXcgTGlzdGVuZXJzKCk7XG4gICAgY29uc3QgeyBEZWZhdWx0OiBEZWZhdWx0MiwgQ29udGV4dE1lbnUgfSA9IEludGVyYWN0aW9uU3RhdGU7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW3JlZ2lvbk1hbmFnZXIubGlzdGVuQWxsKFwiY29udGV4dG1lbnVcIiwgKGUpID0+IHRoaXMub25Db250ZXh0TWVudShlKSwgRGVmYXVsdDIgfCBDb250ZXh0TWVudSldO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGQpID0+IGQoKSk7XG4gIH1cbiAgb25Db250ZXh0TWVudShldmVudCkge1xuICAgIGNvbnN0IHR5cGUgPSBfQ29udGV4dE1lbnVSZWdpc3RyeS50b0NvbnRleHRUeXBlKGV2ZW50LnJlZ2lvbik7XG4gICAgaWYgKHR5cGUgPT09IFwiYWxsXCIpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hDb250ZXh0KFwiYWxsXCIsIGV2ZW50LCB7fSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyB0b0NvbnRleHRUeXBlKHJlZ2lvbikge1xuICAgIGlmIChyZWdpb24gPT09IFwibGVnZW5kXCIgfHwgcmVnaW9uID09PSBcInNlcmllc1wiKSB7XG4gICAgICByZXR1cm4gcmVnaW9uO1xuICAgIH1cbiAgICByZXR1cm4gXCJhbGxcIjtcbiAgfVxuICBzdGF0aWMgY2hlY2sodHlwZSwgZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudHlwZSA9PT0gdHlwZTtcbiAgfVxuICBzdGF0aWMgY2hlY2tDYWxsYmFjayhkZXNpcmVkVHlwZSwgdHlwZSwgX2NhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGRlc2lyZWRUeXBlID09PSB0eXBlO1xuICB9XG4gIGRpc3BhdGNoQ29udGV4dCh0eXBlLCBwb2ludGVyRXZlbnQsIGNvbnRleHQpIHtcbiAgICBjb25zdCB7IG9mZnNldFg6IHgsIG9mZnNldFk6IHksIHNvdXJjZUV2ZW50IH0gPSBwb2ludGVyRXZlbnQ7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJcIiwgYnVpbGRQcmV2ZW50YWJsZSh7IHR5cGUsIHgsIHksIGNvbnRleHQsIHNvdXJjZUV2ZW50IH0pKTtcbiAgfVxuICBhZGRMaXN0ZW5lcihoYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXJzLmFkZExpc3RlbmVyKFwiXCIsIGhhbmRsZXIpO1xuICB9XG4gIGZpbHRlckFjdGlvbnModHlwZSkge1xuICAgIHJldHVybiB0aGlzLmRlZmF1bHRBY3Rpb25zLmZpbHRlcigoYWN0aW9uKSA9PiB7XG4gICAgICByZXR1cm4gYWN0aW9uLmlkICYmICF0aGlzLmhpZGRlbkFjdGlvbnMuaGFzKGFjdGlvbi5pZCkgJiYgW1wiYWxsXCIsIHR5cGVdLmluY2x1ZGVzKGFjdGlvbi50eXBlKTtcbiAgICB9KTtcbiAgfVxuICByZWdpc3RlckRlZmF1bHRBY3Rpb24oYWN0aW9uKSB7XG4gICAgaWYgKGFjdGlvbi5pZCAmJiB0aGlzLmRlZmF1bHRBY3Rpb25zLmZpbmQoKHsgaWQgfSkgPT4gaWQgPT09IGFjdGlvbi5pZCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kZWZhdWx0QWN0aW9ucy5wdXNoKGFjdGlvbik7XG4gIH1cbiAgZW5hYmxlQWN0aW9uKGFjdGlvbklkKSB7XG4gICAgdGhpcy5kaXNhYmxlZEFjdGlvbnMuZGVsZXRlKGFjdGlvbklkKTtcbiAgfVxuICBkaXNhYmxlQWN0aW9uKGFjdGlvbklkKSB7XG4gICAgdGhpcy5kaXNhYmxlZEFjdGlvbnMuYWRkKGFjdGlvbklkKTtcbiAgfVxuICBzZXRBY3Rpb25WaXNpYmxpdHkoYWN0aW9uSWQsIHZpc2libGUpIHtcbiAgICBpZiAodmlzaWJsZSkge1xuICAgICAgdGhpcy5oaWRkZW5BY3Rpb25zLmRlbGV0ZShhY3Rpb25JZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGlkZGVuQWN0aW9ucy5hZGQoYWN0aW9uSWQpO1xuICAgIH1cbiAgfVxuICBpc0Rpc2FibGVkKGFjdGlvbklkKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzYWJsZWRBY3Rpb25zLmhhcyhhY3Rpb25JZCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvc3RhdGVUcmFja2VyLnRzXG52YXIgU3RhdGVUcmFja2VyID0gY2xhc3MgZXh0ZW5kcyBNYXAge1xuICBjb25zdHJ1Y3RvcihkZWZhdWx0VmFsdWUsIGRlZmF1bHRTdGF0ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gICAgdGhpcy5kZWZhdWx0U3RhdGUgPSBkZWZhdWx0U3RhdGU7XG4gIH1cbiAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLmRlbGV0ZShrZXkpO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHN1cGVyLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RhdGVJZCgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmtleXMoKSkucG9wKCkgPz8gdGhpcy5kZWZhdWx0U3RhdGU7XG4gIH1cbiAgc3RhdGVWYWx1ZSgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnZhbHVlcygpKS5wb3AoKSA/PyB0aGlzLmRlZmF1bHRWYWx1ZTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vY3Vyc29yTWFuYWdlci50c1xudmFyIEN1cnNvciA9IC8qIEBfX1BVUkVfXyAqLyAoKEN1cnNvcjIpID0+IHtcbiAgQ3Vyc29yMltcIkF1dG9cIl0gPSBcImF1dG9cIjtcbiAgQ3Vyc29yMltcIkRlZmF1bHRcIl0gPSBcImRlZmF1bHRcIjtcbiAgQ3Vyc29yMltcIkdyYWJcIl0gPSBcImdyYWJcIjtcbiAgQ3Vyc29yMltcIkdyYWJiaW5nXCJdID0gXCJncmFiYmluZ1wiO1xuICBDdXJzb3IyW1wiTW92ZVwiXSA9IFwibW92ZVwiO1xuICBDdXJzb3IyW1wiTm90QWxsb3dlZFwiXSA9IFwibm90LWFsbG93ZWRcIjtcbiAgQ3Vyc29yMltcIlBvaW50ZXJcIl0gPSBcInBvaW50ZXJcIjtcbiAgQ3Vyc29yMltcIkVXUmVzaXplXCJdID0gXCJldy1yZXNpemVcIjtcbiAgQ3Vyc29yMltcIk5TUmVzaXplXCJdID0gXCJucy1yZXNpemVcIjtcbiAgQ3Vyc29yMltcIlpvb21JblwiXSA9IFwiem9vbS1pblwiO1xuICBDdXJzb3IyW1wiWm9vbU91dFwiXSA9IFwiem9vbS1vdXRcIjtcbiAgcmV0dXJuIEN1cnNvcjI7XG59KShDdXJzb3IgfHwge30pO1xudmFyIEN1cnNvck1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRvbU1hbmFnZXIpIHtcbiAgICB0aGlzLmRvbU1hbmFnZXIgPSBkb21NYW5hZ2VyO1xuICAgIHRoaXMuc3RhdGVUcmFja2VyID0gbmV3IFN0YXRlVHJhY2tlcihcImRlZmF1bHRcIik7XG4gIH1cbiAgdXBkYXRlQ3Vyc29yKGNhbGxlcklkLCBzdHlsZSkge1xuICAgIHRoaXMuc3RhdGVUcmFja2VyLnNldChjYWxsZXJJZCwgc3R5bGUpO1xuICAgIHRoaXMuZG9tTWFuYWdlci51cGRhdGVDdXJzb3IodGhpcy5zdGF0ZVRyYWNrZXIuc3RhdGVWYWx1ZSgpKTtcbiAgfVxuICBnZXRDdXJzb3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9tTWFuYWdlci5nZXRDdXJzb3IoKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vZ2VzdHVyZURldGVjdG9yLnRzXG5mdW5jdGlvbiBkaXN0YW5jZVNxdWFyZWQoZmluZ2VyMSwgZmluZ2VyMikge1xuICBjb25zdCBkeCA9IGZpbmdlcjEuc2NyZWVuWCAtIGZpbmdlcjIuc2NyZWVuWDtcbiAgY29uc3QgZHkgPSBmaW5nZXIxLnNjcmVlblkgLSBmaW5nZXIyLnNjcmVlblk7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cbmZ1bmN0aW9uIGRpc3RhbmNlKGZpbmdlcjEsIGZpbmdlcjIpIHtcbiAgcmV0dXJuIE1hdGguc3FydChkaXN0YW5jZVNxdWFyZWQoZmluZ2VyMSwgZmluZ2VyMikpO1xufVxudmFyIE1JTl9ESVNUQU5DRV9UT19TVEFSVF9QSU5DSCA9IDE7XG52YXIgR2VzdHVyZURldGVjdG9yID0gY2xhc3MgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGRvbU1hbmFnZXIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZG9tTWFuYWdlciA9IGRvbU1hbmFnZXI7XG4gICAgdGhpcy50b3VjaHN0YXJ0ID0gKGV2ZW50KSA9PiB0aGlzLm9uVG91Y2hTdGFydChldmVudCk7XG4gICAgdGhpcy50b3VjaG1vdmUgPSAoZXZlbnQpID0+IHRoaXMub25Ub3VjaE1vdmUoZXZlbnQpO1xuICAgIHRoaXMudG91Y2hlbmQgPSAoZXZlbnQpID0+IHRoaXMub25Ub3VjaEVuZChldmVudCk7XG4gICAgdGhpcy50b3VjaGNhbmNlbCA9IChldmVudCkgPT4gdGhpcy5vblRvdWNoQ2FuY2VsKGV2ZW50KTtcbiAgICB0aGlzLnBpbmNoID0ge1xuICAgICAgZmluZ2VyMTogeyBpZGVudGlmaWVyOiBOYU4sIHNjcmVlblg6IE5hTiwgc2NyZWVuWTogTmFOIH0sXG4gICAgICBmaW5nZXIyOiB7IGlkZW50aWZpZXI6IE5hTiwgc2NyZWVuWDogTmFOLCBzY3JlZW5ZOiBOYU4gfSxcbiAgICAgIG9yaWdpbjogeyB4OiBOYU4sIHk6IE5hTiB9LFxuICAgICAgZGlzdGFuY2U6IE5hTixcbiAgICAgIHN0YXR1czogMCAvKiBPZmYgKi9cbiAgICB9O1xuICAgIHRoaXMuZG9tTWFuYWdlci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLnRvdWNoc3RhcnQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICB0aGlzLmRvbU1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLnRvdWNobW92ZSwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICB0aGlzLmRvbU1hbmFnZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMudG91Y2hlbmQpO1xuICAgIHRoaXMuZG9tTWFuYWdlci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgdGhpcy50b3VjaGNhbmNlbCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRvbU1hbmFnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy50b3VjaHN0YXJ0KTtcbiAgICB0aGlzLmRvbU1hbmFnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLnRvdWNobW92ZSk7XG4gICAgdGhpcy5kb21NYW5hZ2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLnRvdWNoZW5kKTtcbiAgICB0aGlzLmRvbU1hbmFnZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIHRoaXMudG91Y2hjYW5jZWwpO1xuICB9XG4gIGZpbmRQaW5jaFRvdWNoZXMobW92ZUV2ZW50KSB7XG4gICAgY29uc3QgeyB0b3VjaGVzIH0gPSBtb3ZlRXZlbnQ7XG4gICAgY29uc3QgeyBmaW5nZXIxLCBmaW5nZXIyIH0gPSB0aGlzLnBpbmNoO1xuICAgIGlmICh0aGlzLnBpbmNoLnN0YXR1cyAhPT0gMCAvKiBPZmYgKi8gJiYgdG91Y2hlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGlmICh0b3VjaGVzWzBdLmlkZW50aWZpZXIgPT09IGZpbmdlcjEuaWRlbnRpZmllciAmJiB0b3VjaGVzWzFdLmlkZW50aWZpZXIgPT09IGZpbmdlcjIuaWRlbnRpZmllcikge1xuICAgICAgICByZXR1cm4gW3RvdWNoZXNbMF0sIHRvdWNoZXNbMV1dO1xuICAgICAgfVxuICAgICAgaWYgKHRvdWNoZXNbMF0uaWRlbnRpZmllciA9PT0gZmluZ2VyMi5pZGVudGlmaWVyICYmIHRvdWNoZXNbMV0uaWRlbnRpZmllciA9PT0gZmluZ2VyMS5pZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiBbdG91Y2hlc1sxXSwgdG91Y2hlc1swXV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvcHlUb3VjaERhdGEoZXZlbnQpIHtcbiAgICBjb25zdCBrZXlzID0gW1wiaWRlbnRpZmllclwiLCBcInNjcmVlblhcIiwgXCJzY3JlZW5ZXCJdO1xuICAgIHBhcnRpYWxBc3NpZ24oa2V5cywgdGhpcy5waW5jaC5maW5nZXIxLCBldmVudC50b3VjaGVzWzBdKTtcbiAgICBwYXJ0aWFsQXNzaWduKGtleXMsIHRoaXMucGluY2guZmluZ2VyMiwgZXZlbnQudG91Y2hlc1sxXSk7XG4gICAgdGhpcy5waW5jaC5kaXN0YW5jZSA9IGRpc3RhbmNlKHRoaXMucGluY2guZmluZ2VyMSwgdGhpcy5waW5jaC5maW5nZXIyKTtcbiAgfVxuICBkaXNwYXRjaFBpbmNoRXZlbnQodHlwZSwgZGVsdGFEaXN0YW5jZSwgc291cmNlRXZlbnQpIHtcbiAgICBjb25zdCB7IGZpbmdlcjEsIGZpbmdlcjIsIG9yaWdpbiB9ID0gdGhpcy5waW5jaDtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaCh0eXBlLCBidWlsZFByZXZlbnRhYmxlKHsgc291cmNlRXZlbnQsIHR5cGUsIGZpbmdlcjEsIGZpbmdlcjIsIGRlbHRhRGlzdGFuY2UsIG9yaWdpbiB9KSk7XG4gIH1cbiAgb25Ub3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgdGhpcy5zdG9wUGluY2hUcmFja2luZyhldmVudCk7XG4gICAgY29uc3QgeyBwaW5jaCB9ID0gdGhpcztcbiAgICBpZiAoZXZlbnQudG91Y2hlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHBpbmNoLnN0YXR1cyA9IDEgLyogSW5pdGlhbGl6ZWQgKi87XG4gICAgICB0aGlzLmNvcHlUb3VjaERhdGEoZXZlbnQpO1xuICAgICAgcGluY2gub3JpZ2luLnggPSAoZXZlbnQudG91Y2hlc1swXS5jbGllbnRYICsgZXZlbnQudG91Y2hlc1sxXS5jbGllbnRYKSAvIDI7XG4gICAgICBwaW5jaC5vcmlnaW4ueSA9IChldmVudC50b3VjaGVzWzBdLmNsaWVudFkgKyBldmVudC50b3VjaGVzWzFdLmNsaWVudFkpIC8gMjtcbiAgICB9XG4gIH1cbiAgb25Ub3VjaE1vdmUoZXZlbnQpIHtcbiAgICBjb25zdCBwaW5jaFRvdWNoZXMgPSB0aGlzLmZpbmRQaW5jaFRvdWNoZXMoZXZlbnQpO1xuICAgIGlmIChwaW5jaFRvdWNoZXMgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgW3RvdWNoMSwgdG91Y2gyXSA9IHBpbmNoVG91Y2hlcztcbiAgICAgIGNvbnN0IHsgcGluY2ggfSA9IHRoaXM7XG4gICAgICBjb25zdCBuZXdEaXN0YW5jZSA9IGRpc3RhbmNlKHRvdWNoMSwgdG91Y2gyKTtcbiAgICAgIGNvbnN0IGRlbHRhRGlzdGFuY2UgPSBuZXdEaXN0YW5jZSAtIHBpbmNoLmRpc3RhbmNlO1xuICAgICAgaWYgKHBpbmNoLnN0YXR1cyA9PT0gMSAvKiBJbml0aWFsaXplZCAqLykge1xuICAgICAgICBpZiAoTWF0aC5hYnMoZGVsdGFEaXN0YW5jZSkgPiBNSU5fRElTVEFOQ0VfVE9fU1RBUlRfUElOQ0gpIHtcbiAgICAgICAgICBwaW5jaC5zdGF0dXMgPSAyIC8qIFJ1bm5pbmcgKi87XG4gICAgICAgICAgdGhpcy5jb3B5VG91Y2hEYXRhKGV2ZW50KTtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoUGluY2hFdmVudChcInBpbmNoLXN0YXJ0XCIsIDAsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwaW5jaC5zdGF0dXMgPT09IDIgLyogUnVubmluZyAqLykge1xuICAgICAgICBwaW5jaC5kaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICB0aGlzLmNvcHlUb3VjaERhdGEoZXZlbnQpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoUGluY2hFdmVudChcInBpbmNoLW1vdmVcIiwgZGVsdGFEaXN0YW5jZSwgZXZlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgTG9nZ2VyLmVycm9yKGB1bmV4cGVjdGVkIHBpbmNoLnN0YXR1czogJHtwaW5jaC5zdGF0dXN9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uVG91Y2hFbmQoZXZlbnQpIHtcbiAgICB0aGlzLnN0b3BQaW5jaFRyYWNraW5nKGV2ZW50KTtcbiAgfVxuICBvblRvdWNoQ2FuY2VsKGV2ZW50KSB7XG4gICAgdGhpcy5zdG9wUGluY2hUcmFja2luZyhldmVudCk7XG4gIH1cbiAgc3RvcFBpbmNoVHJhY2tpbmcoZXZlbnQpIHtcbiAgICBjb25zdCB7IHBpbmNoIH0gPSB0aGlzO1xuICAgIGlmIChwaW5jaC5zdGF0dXMgPT09IDIgLyogUnVubmluZyAqLykge1xuICAgICAgdGhpcy5kaXNwYXRjaFBpbmNoRXZlbnQoXCJwaW5jaC1lbmRcIiwgMCwgZXZlbnQpO1xuICAgIH1cbiAgICB0aGlzLnBpbmNoLnN0YXR1cyA9IDAgLyogT2ZmICovO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi9oaWdobGlnaHRNYW5hZ2VyLnRzXG52YXIgSGlnaGxpZ2h0TWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuaGlnaGxpZ2h0U3RhdGVzID0gbmV3IFN0YXRlVHJhY2tlcigpO1xuICB9XG4gIHVwZGF0ZUhpZ2hsaWdodChjYWxsZXJJZCwgaGlnaGxpZ2h0ZWREYXR1bSkge1xuICAgIGNvbnN0IHsgYWN0aXZlSGlnaGxpZ2h0OiBwcmV2aW91c0hpZ2hsaWdodCB9ID0gdGhpcztcbiAgICB0aGlzLmhpZ2hsaWdodFN0YXRlcy5zZXQoY2FsbGVySWQsIGhpZ2hsaWdodGVkRGF0dW0pO1xuICAgIHRoaXMuYWN0aXZlSGlnaGxpZ2h0ID0gdGhpcy5oaWdobGlnaHRTdGF0ZXMuc3RhdGVWYWx1ZSgpO1xuICAgIGlmICghdGhpcy5pc0VxdWFsKHRoaXMuYWN0aXZlSGlnaGxpZ2h0LCBwcmV2aW91c0hpZ2hsaWdodCkpIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiaGlnaGxpZ2h0LWNoYW5nZVwiLCB7XG4gICAgICAgIHR5cGU6IFwiaGlnaGxpZ2h0LWNoYW5nZVwiLFxuICAgICAgICBjdXJyZW50SGlnaGxpZ2h0OiB0aGlzLmFjdGl2ZUhpZ2hsaWdodCxcbiAgICAgICAgcHJldmlvdXNIaWdobGlnaHQsXG4gICAgICAgIGNhbGxlcklkXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0QWN0aXZlSGlnaGxpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZUhpZ2hsaWdodDtcbiAgfVxuICBpc0VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYSA9PT0gYiB8fCBhICE9IG51bGwgJiYgYiAhPSBudWxsICYmIGE/LnNlcmllcyA9PT0gYj8uc2VyaWVzICYmIGE/Lml0ZW1JZCA9PT0gYj8uaXRlbUlkICYmIGE/LmRhdHVtID09PSBiPy5kYXR1bTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24va2V5TmF2TWFuYWdlci50c1xudmFyIEtleU5hdk1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoaW50ZXJhY3Rpb25NYW5hZ2VyLCBkb21NYW5hZ2VyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRvbU1hbmFnZXIgPSBkb21NYW5hZ2VyO1xuICAgIHRoaXMuaGFzQnJvd3NlckZvY3VzID0gZmFsc2U7XG4gICAgdGhpcy5pc01vdXNlQmx1cnJlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNDbGlja2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwiZHJhZy1zdGFydFwiLCAoZSkgPT4gdGhpcy5vbkNsaWNrU3RhcnQoZSksIDMxIC8qIEFsbCAqLyksXG4gICAgICBpbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4gdGhpcy5vbkNsaWNrU3RvcChlKSwgMzEgLyogQWxsICovKSxcbiAgICAgIGludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImRyYWctZW5kXCIsIChlKSA9PiB0aGlzLm9uQ2xpY2tTdG9wKGUpLCAzMSAvKiBBbGwgKi8pLFxuICAgICAgaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwid2hlZWxcIiwgKGUpID0+IHRoaXMubW91c2VCbHVyKGUpKSxcbiAgICAgIGludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImhvdmVyXCIsIChlKSA9PiB0aGlzLm1vdXNlQmx1cihlKSksXG4gICAgICBpbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJkcmFnXCIsIChlKSA9PiB0aGlzLm1vdXNlQmx1cihlKSksXG4gICAgICBpbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJibHVyXCIsIChlKSA9PiB0aGlzLm9uQmx1cihlKSwgMzEgLyogQWxsICovKSxcbiAgICAgIGludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImZvY3VzXCIsIChlKSA9PiB0aGlzLm9uRm9jdXMoZSksIDMxIC8qIEFsbCAqLyksXG4gICAgICBpbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJrZXlkb3duXCIsIChlKSA9PiB0aGlzLm9uS2V5RG93bihlKSwgMzEgLyogQWxsICovKVxuICAgICk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gIH1cbiAgb25DbGlja1N0YXJ0KGV2ZW50KSB7XG4gICAgdGhpcy5pc0NsaWNraW5nID0gdHJ1ZTtcbiAgICB0aGlzLm1vdXNlQmx1cihldmVudCk7XG4gIH1cbiAgb25DbGlja1N0b3AoZXZlbnQpIHtcbiAgICB0aGlzLm1vdXNlQmx1cihldmVudCk7XG4gICAgdGhpcy5pc0NsaWNraW5nID0gZmFsc2U7XG4gIH1cbiAgbW91c2VCbHVyKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmhhc0Jyb3dzZXJGb2N1cylcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIXRoaXMuaXNNb3VzZUJsdXJyZWQpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2goXCJibHVyXCIsIDAsIGV2ZW50KTtcbiAgICAgIHRoaXMuaXNNb3VzZUJsdXJyZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBvbkJsdXIoZXZlbnQpIHtcbiAgICB0aGlzLmhhc0Jyb3dzZXJGb2N1cyA9IGZhbHNlO1xuICAgIHRoaXMuaXNNb3VzZUJsdXJyZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRpc3BhdGNoKFwiYmx1clwiLCAwLCBldmVudCk7XG4gIH1cbiAgb25Gb2N1cyhldmVudCkge1xuICAgIGNvbnN0IGRlbHRhMyA9IHRoaXMuZG9tTWFuYWdlci5nZXRCcm93c2VyRm9jdXNEZWx0YSgpO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJicm93c2VyZm9jdXNcIiwgZGVsdGEzLCBldmVudCk7XG4gICAgdGhpcy5oYXNCcm93c2VyRm9jdXMgPSB0cnVlO1xuICAgIGNvbnN0IHRhYkZvY3VzRnJvbUNsaWNrID0gZXZlbnQucmVsYXRlZEVsZW1lbnQgPT0gbnVsbCAmJiBldmVudC50YXJnZXRFbGVtZW50Py50YWdOYW1lID09PSBcIkNBTlZBU1wiO1xuICAgIGlmICh0aGlzLmlzQ2xpY2tpbmcgfHwgdGFiRm9jdXNGcm9tQ2xpY2spIHtcbiAgICAgIHRoaXMuaXNNb3VzZUJsdXJyZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoKFwidGFiXCIsIGRlbHRhMywgZXZlbnQpO1xuICB9XG4gIG9uS2V5RG93bihldmVudCkge1xuICAgIGlmICghdGhpcy5oYXNCcm93c2VyRm9jdXMpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5pc01vdXNlQmx1cnJlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHsgY29kZSwgYWx0S2V5LCBzaGlmdEtleSwgbWV0YUtleSwgY3RybEtleSB9ID0gZXZlbnQuc291cmNlRXZlbnQ7XG4gICAgaWYgKGNvZGUgPT09IFwiVGFiXCIpIHtcbiAgICAgIGlmIChzaGlmdEtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcInRhYlwiLCAtMSwgZXZlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJ0YWJcIiwgMSwgZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWx0S2V5IHx8IHNoaWZ0S2V5IHx8IG1ldGFLZXkgfHwgY3RybEtleSlcbiAgICAgIHJldHVybjtcbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJuYXYtdmVydFwiLCAxLCBldmVudCk7XG4gICAgICBjYXNlIFwiQXJyb3dVcFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcIm5hdi12ZXJ0XCIsIC0xLCBldmVudCk7XG4gICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwibmF2LWhvcmlcIiwgLTEsIGV2ZW50KTtcbiAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwibmF2LWhvcmlcIiwgMSwgZXZlbnQpO1xuICAgICAgY2FzZSBcIlpvb21JblwiOlxuICAgICAgY2FzZSBcIkFkZFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcIm5hdi16b29tXCIsIDEsIGV2ZW50KTtcbiAgICAgIGNhc2UgXCJab29tT3V0XCI6XG4gICAgICBjYXNlIFwiU3Vic3RyYWN0XCI6XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwibmF2LXpvb21cIiwgLTEsIGV2ZW50KTtcbiAgICAgIGNhc2UgXCJTcGFjZVwiOlxuICAgICAgY2FzZSBcIkVudGVyXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwic3VibWl0XCIsIDAsIGV2ZW50KTtcbiAgICAgIGNhc2UgXCJFc2NhcGVcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goXCJjYW5jZWxcIiwgMCwgZXZlbnQpO1xuICAgICAgY2FzZSBcIkJhY2tzcGFjZVwiOlxuICAgICAgY2FzZSBcIkRlbGV0ZVwiOlxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcImRlbGV0ZVwiLCAwLCBldmVudCk7XG4gICAgfVxuICAgIHN3aXRjaCAoZXZlbnQuc291cmNlRXZlbnQua2V5KSB7XG4gICAgICBjYXNlIFwiK1wiOlxuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaChcIm5hdi16b29tXCIsIDEsIGV2ZW50KTtcbiAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKFwibmF2LXpvb21cIiwgLTEsIGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgZGlzcGF0Y2godHlwZSwgZGVsdGEzLCBzb3VyY2VFdmVudCkge1xuICAgIGRpc3BhdGNoVHlwZWRFdmVudCh0aGlzLmxpc3RlbmVycywgeyB0eXBlLCBkZWx0YTogZGVsdGEzLCBzb3VyY2VFdmVudCB9KTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vcmVnaW9uTWFuYWdlci50c1xudmFyIFJFR0lPTl9UQUJfT1JERVJJTkcgPSBbXCJzZXJpZXNcIl07XG52YXIgUmVnaW9uTGlzdGVuZXJzID0gY2xhc3MgZXh0ZW5kcyBMaXN0ZW5lcnMge1xufTtcbmZ1bmN0aW9uIGFkZEhhbmRsZXIobGlzdGVuZXJzLCBpbnRlcmFjdGlvbk1hbmFnZXIsIHR5cGUsIGhhbmRsZXIsIHRyaWdnZXJpbmdTdGF0ZXMgPSAxNiAvKiBEZWZhdWx0ICovKSB7XG4gIHJldHVybiBsaXN0ZW5lcnM/LmFkZExpc3RlbmVyKHR5cGUsIChlKSA9PiB7XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gaW50ZXJhY3Rpb25NYW5hZ2VyLmdldFN0YXRlKCk7XG4gICAgaWYgKGN1cnJlbnRTdGF0ZSAmIHRyaWdnZXJpbmdTdGF0ZXMpIHtcbiAgICAgIGhhbmRsZXIoZSk7XG4gICAgfVxuICB9KSA/PyAoKCkgPT4ge1xuICB9KTtcbn1cbnZhciBSZWdpb25NYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihpbnRlcmFjdGlvbk1hbmFnZXIsIGtleU5hdk1hbmFnZXIsIGZvY3VzSW5kaWNhdG9yKSB7XG4gICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIgPSBpbnRlcmFjdGlvbk1hbmFnZXI7XG4gICAgdGhpcy5rZXlOYXZNYW5hZ2VyID0ga2V5TmF2TWFuYWdlcjtcbiAgICB0aGlzLmZvY3VzSW5kaWNhdG9yID0gZm9jdXNJbmRpY2F0b3I7XG4gICAgdGhpcy5jdXJyZW50VGFiSW5kZXggPSAwO1xuICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgIHRoaXMubGVmdENhbnZhcyA9IGZhbHNlO1xuICAgIHRoaXMucmVnaW9ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy5hbGxSZWdpb25zTGlzdGVuZXJzID0gbmV3IFJlZ2lvbkxpc3RlbmVycygpO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgLi4uUE9JTlRFUl9JTlRFUkFDVElPTl9UWVBFUy5tYXAoXG4gICAgICAgIChldmVudE5hbWUpID0+IGludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihldmVudE5hbWUsIHRoaXMucHJvY2Vzc1BvaW50ZXJFdmVudC5iaW5kKHRoaXMpLCAzMSAvKiBBbGwgKi8pXG4gICAgICApLFxuICAgICAgdGhpcy5rZXlOYXZNYW5hZ2VyLmFkZExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLm9uTmF2LmJpbmQodGhpcykpLFxuICAgICAgdGhpcy5rZXlOYXZNYW5hZ2VyLmFkZExpc3RlbmVyKFwiYnJvd3NlcmZvY3VzXCIsIHRoaXMub25Ccm93c2VyRm9jdXMuYmluZCh0aGlzKSksXG4gICAgICB0aGlzLmtleU5hdk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJ0YWJcIiwgdGhpcy5vblRhYi5iaW5kKHRoaXMpKSxcbiAgICAgIHRoaXMua2V5TmF2TWFuYWdlci5hZGRMaXN0ZW5lcihcIm5hdi12ZXJ0XCIsIHRoaXMub25OYXYuYmluZCh0aGlzKSksXG4gICAgICB0aGlzLmtleU5hdk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJuYXYtaG9yaVwiLCB0aGlzLm9uTmF2LmJpbmQodGhpcykpLFxuICAgICAgdGhpcy5rZXlOYXZNYW5hZ2VyLmFkZExpc3RlbmVyKFwibmF2LXpvb21cIiwgdGhpcy5vbk5hdi5iaW5kKHRoaXMpKSxcbiAgICAgIHRoaXMua2V5TmF2TWFuYWdlci5hZGRMaXN0ZW5lcihcInN1Ym1pdFwiLCB0aGlzLm9uTmF2LmJpbmQodGhpcykpLFxuICAgICAgdGhpcy5rZXlOYXZNYW5hZ2VyLmFkZExpc3RlbmVyKFwiY2FuY2VsXCIsIHRoaXMub25OYXYuYmluZCh0aGlzKSksXG4gICAgICB0aGlzLmtleU5hdk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJkZWxldGVcIiwgdGhpcy5vbk5hdi5iaW5kKHRoaXMpKVxuICAgICk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZm4pID0+IGZuKCkpO1xuICAgIHRoaXMuY3VycmVudFJlZ2lvbiA9IHZvaWQgMDtcbiAgICBmb3IgKGNvbnN0IHJlZ2lvbiBvZiB0aGlzLnJlZ2lvbnMudmFsdWVzKCkpIHtcbiAgICAgIHJlZ2lvbi5saXN0ZW5lcnMuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmZvY3VzSW5kaWNhdG9yLmRlc3Ryb3koKTtcbiAgICB0aGlzLnJlZ2lvbnMuY2xlYXIoKTtcbiAgfVxuICBhZGRSZWdpb24obmFtZSwgLi4uYmJveHByb3ZpZGVycykge1xuICAgIGlmICh0aGlzLnJlZ2lvbnMuaGFzKG5hbWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIFJlZ2lvbjogJHtuYW1lfSBhbHJlYWR5IGV4aXN0c2ApO1xuICAgIH1cbiAgICBjb25zdCByZWdpb24gPSB7XG4gICAgICBwcm9wZXJ0aWVzOiB7IG5hbWUsIGJib3hwcm92aWRlcnM6IFsuLi5iYm94cHJvdmlkZXJzXSB9LFxuICAgICAgbGlzdGVuZXJzOiBuZXcgUmVnaW9uTGlzdGVuZXJzKClcbiAgICB9O1xuICAgIHRoaXMucmVnaW9ucy5zZXQobmFtZSwgcmVnaW9uKTtcbiAgICByZXR1cm4gdGhpcy5tYWtlT2JzZXJ2ZXIocmVnaW9uKTtcbiAgfVxuICB1cGRhdGVSZWdpb24obmFtZSwgLi4uYmJveHByb3ZpZGVyKSB7XG4gICAgY29uc3QgcmVnaW9uID0gdGhpcy5yZWdpb25zLmdldChuYW1lKTtcbiAgICBpZiAocmVnaW9uKSB7XG4gICAgICByZWdpb24ucHJvcGVydGllcy5iYm94cHJvdmlkZXJzID0gWy4uLmJib3hwcm92aWRlcl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIHVua25vd24gcmVnaW9uOiBcIiArIG5hbWUpO1xuICAgIH1cbiAgfVxuICBnZXRSZWdpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1ha2VPYnNlcnZlcih0aGlzLnJlZ2lvbnMuZ2V0KG5hbWUpKTtcbiAgfVxuICBsaXN0ZW5BbGwodHlwZSwgaGFuZGxlciwgdHJpZ2dlcmluZ1N0YXRlcyA9IDE2IC8qIERlZmF1bHQgKi8pIHtcbiAgICByZXR1cm4gYWRkSGFuZGxlcih0aGlzLmFsbFJlZ2lvbnNMaXN0ZW5lcnMsIHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyLCB0eXBlLCBoYW5kbGVyLCB0cmlnZ2VyaW5nU3RhdGVzKTtcbiAgfVxuICAvLyBUaGlzIG1ldGhvZCByZXR1cm4gYSB3cmFwcGVyIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIGludGVyZmFjZSBvZiBJbnRlcmFjdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIuXG4gIC8vIFRoZSBpbnRlbnQgaXMgdG8gYWxsb3cgdGhlIEludGVyYWN0aW9uTWFuYWdlciBhbmQgUmVnaW9uTWFuYWdlciB0byBiZSB1c2VkIGFsbW9zdCBpbnRlcmNoYW5nZWFibHkuXG4gIG1ha2VPYnNlcnZlcihyZWdpb24pIHtcbiAgICBjb25zdCB7IGludGVyYWN0aW9uTWFuYWdlciB9ID0gdGhpcztcbiAgICBjbGFzcyBPYnNlcnZhYmxlUmVnaW9uSW1wbGVtZW50YXRpb24ge1xuICAgICAgYWRkTGlzdGVuZXIodHlwZSwgaGFuZGxlciwgdHJpZ2dlcmluZ1N0YXRlcyA9IDE2IC8qIERlZmF1bHQgKi8pIHtcbiAgICAgICAgcmV0dXJuIGFkZEhhbmRsZXIocmVnaW9uPy5saXN0ZW5lcnMsIGludGVyYWN0aW9uTWFuYWdlciwgdHlwZSwgaGFuZGxlciwgdHJpZ2dlcmluZ1N0YXRlcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgT2JzZXJ2YWJsZVJlZ2lvbkltcGxlbWVudGF0aW9uKCk7XG4gIH1cbiAgY2hlY2tQb2ludGVySGlzdG9yeSh0YXJnZXRSZWdpb24sIGV2ZW50KSB7XG4gICAgZm9yIChjb25zdCBoaXN0b3J5RXZlbnQgb2YgZXZlbnQucG9pbnRlckhpc3RvcnkpIHtcbiAgICAgIGNvbnN0IHsgcmVnaW9uOiBoaXN0b3J5UmVnaW9uIH0gPSB0aGlzLnBpY2tSZWdpb24oaGlzdG9yeUV2ZW50Lm9mZnNldFgsIGhpc3RvcnlFdmVudC5vZmZzZXRZKTtcbiAgICAgIGlmICh0YXJnZXRSZWdpb24ucHJvcGVydGllcy5uYW1lICE9PSBoaXN0b3J5UmVnaW9uPy5wcm9wZXJ0aWVzLm5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBDcmVhdGUgYW5kIGRpc3BhdGNoIGEgY29weSBvZiB0aGUgSW50ZXJhY3Rpb25FdmVudC5cbiAgZGlzcGF0Y2gocmVnaW9uLCBwYXJ0aWFsRXZlbnQsIGJib3hQcm92aWRlcklkKSB7XG4gICAgaWYgKHJlZ2lvbiA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGV2ZW50ID0gYnVpbGRQcmV2ZW50YWJsZSh7XG4gICAgICAuLi5wYXJ0aWFsRXZlbnQsXG4gICAgICByZWdpb246IHJlZ2lvbi5wcm9wZXJ0aWVzLm5hbWUsXG4gICAgICBiYm94UHJvdmlkZXJJZFxuICAgIH0pO1xuICAgIHRoaXMuYWxsUmVnaW9uc0xpc3RlbmVycy5kaXNwYXRjaChldmVudC50eXBlLCBldmVudCk7XG4gICAgcmVnaW9uLmxpc3RlbmVycy5kaXNwYXRjaChldmVudC50eXBlLCBldmVudCk7XG4gIH1cbiAgLy8gUHJvY2VzcyBldmVudHMgZHVyaW5nIGEgZHJhZyBhY3Rpb24uIFJldHVybnMgZmFsc2UgaWYgdGhpcyBldmVudCBzaG91bGQgZm9sbG93IHRoZSBzdGFuZGFyZFxuICAvLyBSZWdpb25NYW5hZ2VyLnByb2Nlc3NFdmVudCBmbG93LCBvciB0cnVlIGlmIHRoaXMgZXZlbnQgYWxyZWFkeSBwcm9jZXNzZWQgYnkgdGhpcyBmdW5jdGlvbi5cbiAgaGFuZGxlRHJhZ2dpbmcoZXZlbnQpIHtcbiAgICBjb25zdCB7IGN1cnJlbnRSZWdpb24gfSA9IHRoaXM7XG4gICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICBjYXNlIFwiZHJhZy1zdGFydFwiOlxuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmxlZnRDYW52YXMgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibGVhdmVcIjpcbiAgICAgICAgdGhpcy5sZWZ0Q2FudmFzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNEcmFnZ2luZztcbiAgICAgIGNhc2UgXCJlbnRlclwiOlxuICAgICAgICB0aGlzLmxlZnRDYW52YXMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNEcmFnZ2luZztcbiAgICAgIGNhc2UgXCJkcmFnXCI6XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoKGN1cnJlbnRSZWdpb24sIGV2ZW50KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJkcmFnLWVuZFwiOlxuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaChjdXJyZW50UmVnaW9uLCBldmVudCk7XG4gICAgICAgICAgaWYgKHRoaXMubGVmdENhbnZhcykge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaChjdXJyZW50UmVnaW9uLCB7IC4uLmV2ZW50LCB0eXBlOiBcImxlYXZlXCIgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcHJvY2Vzc1BvaW50ZXJFdmVudChldmVudCkge1xuICAgIGlmICh0aGlzLmhhbmRsZURyYWdnaW5nKGV2ZW50KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IGN1cnJlbnRSZWdpb24gfSA9IHRoaXM7XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09IFwibGVhdmVcIikge1xuICAgICAgdGhpcy5kaXNwYXRjaChjdXJyZW50UmVnaW9uLCB7IC4uLmV2ZW50LCB0eXBlOiBcImxlYXZlXCIgfSk7XG4gICAgICB0aGlzLmN1cnJlbnRSZWdpb24gPSB2b2lkIDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgcmVnaW9uOiBuZXdSZWdpb24sIGJib3hQcm92aWRlcklkIH0gPSB0aGlzLnBpY2tSZWdpb24oZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gICAgaWYgKGN1cnJlbnRSZWdpb24gIT09IHZvaWQgMCAmJiBuZXdSZWdpb24/LnByb3BlcnRpZXMubmFtZSAhPT0gY3VycmVudFJlZ2lvbi5wcm9wZXJ0aWVzLm5hbWUpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2goY3VycmVudFJlZ2lvbiwgeyAuLi5ldmVudCwgdHlwZTogXCJsZWF2ZVwiIH0sIHRoaXMuY3VycmVudEJCb3hQcm92aWRlcklkKTtcbiAgICB9XG4gICAgaWYgKG5ld1JlZ2lvbiAhPT0gdm9pZCAwICYmIG5ld1JlZ2lvbi5wcm9wZXJ0aWVzLm5hbWUgIT09IGN1cnJlbnRSZWdpb24/LnByb3BlcnRpZXMubmFtZSkge1xuICAgICAgdGhpcy5kaXNwYXRjaChuZXdSZWdpb24sIHsgLi4uZXZlbnQsIHR5cGU6IFwiZW50ZXJcIiB9LCBiYm94UHJvdmlkZXJJZCk7XG4gICAgfVxuICAgIGlmIChuZXdSZWdpb24gIT09IHZvaWQgMCAmJiB0aGlzLmNoZWNrUG9pbnRlckhpc3RvcnkobmV3UmVnaW9uLCBldmVudCkpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2gobmV3UmVnaW9uLCBldmVudCwgYmJveFByb3ZpZGVySWQpO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRSZWdpb24gPSBuZXdSZWdpb247XG4gICAgdGhpcy5jdXJyZW50QkJveFByb3ZpZGVySWQgPSBiYm94UHJvdmlkZXJJZDtcbiAgfVxuICBwaWNrUmVnaW9uKHgsIHkpIHtcbiAgICBsZXQgY3VycmVudEFyZWEgPSBJbmZpbml0eTtcbiAgICBsZXQgY3VycmVudFJlZ2lvbjtcbiAgICBsZXQgY3VycmVudEJCb3hQcm92aWRlcklkO1xuICAgIGZvciAoY29uc3QgcmVnaW9uIG9mIHRoaXMucmVnaW9ucy52YWx1ZXMoKSkge1xuICAgICAgZm9yIChjb25zdCBwcm92aWRlciBvZiByZWdpb24ucHJvcGVydGllcy5iYm94cHJvdmlkZXJzKSB7XG4gICAgICAgIGlmIChwcm92aWRlci52aXNpYmxlID09PSBmYWxzZSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgYmJveCA9IHByb3ZpZGVyLmNvbXB1dGVUcmFuc2Zvcm1lZFJlZ2lvbkJCb3g/LigpID8/IHByb3ZpZGVyLmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKTtcbiAgICAgICAgY29uc3QgYXJlYTIgPSBiYm94LndpZHRoICogYmJveC5oZWlnaHQ7XG4gICAgICAgIGlmIChhcmVhMiA8IGN1cnJlbnRBcmVhICYmIGJib3guY29udGFpbnNQb2ludCh4LCB5KSkge1xuICAgICAgICAgIGN1cnJlbnRBcmVhID0gYXJlYTI7XG4gICAgICAgICAgY3VycmVudFJlZ2lvbiA9IHJlZ2lvbjtcbiAgICAgICAgICBjdXJyZW50QkJveFByb3ZpZGVySWQgPSBwcm92aWRlci5pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyByZWdpb246IGN1cnJlbnRSZWdpb24sIGJib3hQcm92aWRlcklkOiBjdXJyZW50QkJveFByb3ZpZGVySWQgfTtcbiAgfVxuICBnZXRUYWJSZWdpb24odGFiSW5kZXgpIHtcbiAgICBpZiAodGFiSW5kZXggIT09IHZvaWQgMCAmJiB0YWJJbmRleCA+PSAwICYmIHRhYkluZGV4IDwgUkVHSU9OX1RBQl9PUkRFUklORy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZ2lvbnMuZ2V0KFJFR0lPTl9UQUJfT1JERVJJTkdbdGFiSW5kZXhdKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBnZXROZXh0SW50ZXJhY3RhYmxlVGFiSW5kZXgoY3VycmVudEluZGV4LCBkZWx0YTMpIHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSBkZWx0YTMgPCAwID8gLTEgOiAxO1xuICAgIGxldCBpID0gY3VycmVudEluZGV4O1xuICAgIHdoaWxlIChkZWx0YTMgIT09IDApIHtcbiAgICAgIGNvbnN0IHJlZ2lvbiA9IHRoaXMuZ2V0VGFiUmVnaW9uKGkgKyBkaXJlY3Rpb24pO1xuICAgICAgaWYgKHJlZ2lvbiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWx0YTMgPSBkZWx0YTMgLSBkaXJlY3Rpb247XG4gICAgICB9XG4gICAgICBpID0gaSArIGRpcmVjdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgdmFsaWRhdGVDdXJyZW50VGFiSW5kZXgoKSB7XG4gICAgY29uc3QgZm9jdXNlZFJlZ2lvbiA9IHRoaXMuZ2V0VGFiUmVnaW9uKHRoaXMuY3VycmVudFRhYkluZGV4KTtcbiAgICBpZiAoZm9jdXNlZFJlZ2lvbiAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmN1cnJlbnRUYWJJbmRleCA9IHRoaXMuZ2V0TmV4dEludGVyYWN0YWJsZVRhYkluZGV4KC0xLCAxKSA/PyAwO1xuICAgIH1cbiAgfVxuICBvbkJyb3dzZXJGb2N1cyhldmVudCkge1xuICAgIGlmIChldmVudC5kZWx0YSA+IDApIHtcbiAgICAgIHRoaXMuY3VycmVudFRhYkluZGV4ID0gLTE7XG4gICAgfSBlbHNlIGlmIChldmVudC5kZWx0YSA8IDApIHtcbiAgICAgIHRoaXMuY3VycmVudFRhYkluZGV4ID0gUkVHSU9OX1RBQl9PUkRFUklORy5sZW5ndGg7XG4gICAgfVxuICB9XG4gIG9uVGFiKGV2ZW50KSB7XG4gICAgdGhpcy52YWxpZGF0ZUN1cnJlbnRUYWJJbmRleCgpO1xuICAgIGNvbnN0IG5ld1RhYkluZGV4ID0gdGhpcy5nZXROZXh0SW50ZXJhY3RhYmxlVGFiSW5kZXgodGhpcy5jdXJyZW50VGFiSW5kZXgsIGV2ZW50LmRlbHRhKTtcbiAgICBjb25zdCBuZXdSZWdpb24gPSB0aGlzLmdldFRhYlJlZ2lvbihuZXdUYWJJbmRleCk7XG4gICAgY29uc3QgZm9jdXNlZFJlZ2lvbiA9IHRoaXMuZ2V0VGFiUmVnaW9uKHRoaXMuY3VycmVudFRhYkluZGV4KTtcbiAgICBpZiAobmV3VGFiSW5kZXggIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5jdXJyZW50VGFiSW5kZXggPSBuZXdUYWJJbmRleDtcbiAgICB9XG4gICAgaWYgKGZvY3VzZWRSZWdpb24gIT09IHZvaWQgMCAmJiBuZXdSZWdpb24/LnByb3BlcnRpZXMubmFtZSAhPT0gZm9jdXNlZFJlZ2lvbi5wcm9wZXJ0aWVzLm5hbWUpIHtcbiAgICAgIGNvbnN0IHsgZGVsdGE6IGRlbHRhMywgc291cmNlRXZlbnQgfSA9IGV2ZW50O1xuICAgICAgY29uc3QgYmx1ckV2ZW50ID0gYnVpbGRQcmV2ZW50YWJsZSh7IHR5cGU6IFwiYmx1clwiLCBkZWx0YTogZGVsdGEzLCBzb3VyY2VFdmVudCB9KTtcbiAgICAgIHRoaXMuZGlzcGF0Y2goZm9jdXNlZFJlZ2lvbiwgYmx1ckV2ZW50KTtcbiAgICB9XG4gICAgaWYgKG5ld1JlZ2lvbiA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmZvY3VzSW5kaWNhdG9yLnVwZGF0ZUJvdW5kcyh2b2lkIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRpc3BhdGNoKG5ld1JlZ2lvbiwgZXZlbnQpO1xuICAgIH1cbiAgfVxuICBvbk5hdihldmVudCkge1xuICAgIGNvbnN0IGZvY3VzZWRSZWdpb24gPSB0aGlzLmdldFRhYlJlZ2lvbih0aGlzLmN1cnJlbnRUYWJJbmRleCk7XG4gICAgdGhpcy5kaXNwYXRjaChmb2N1c2VkUmVnaW9uLCBldmVudCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Rvb2xiYXIvdG9vbGJhclR5cGVzLnRzXG52YXIgVE9PTEJBUl9BTElHTk1FTlRTID0gW1wic3RhcnRcIiwgXCJjZW50ZXJcIiwgXCJlbmRcIl07XG52YXIgVE9PTEJBUl9HUk9VUFMgPSBbXCJzZXJpZXNUeXBlXCIsIFwiYW5ub3RhdGlvbnNcIiwgXCJhbm5vdGF0aW9uT3B0aW9uc1wiLCBcInJhbmdlc1wiLCBcInpvb21cIl07XG52YXIgVE9PTEJBUl9HUk9VUF9PUkRFUklORyA9IHtcbiAgc2VyaWVzVHlwZTogMCxcbiAgYW5ub3RhdGlvbnM6IDEsXG4gIGFubm90YXRpb25PcHRpb25zOiAyLFxuICByYW5nZXM6IDMsXG4gIHpvb206IDRcbn07XG52YXIgVG9vbGJhclBvc2l0aW9uID0gLyogQF9fUFVSRV9fICovICgoVG9vbGJhclBvc2l0aW9uMikgPT4ge1xuICBUb29sYmFyUG9zaXRpb24yW1wiVG9wXCJdID0gXCJ0b3BcIjtcbiAgVG9vbGJhclBvc2l0aW9uMltcIlJpZ2h0XCJdID0gXCJyaWdodFwiO1xuICBUb29sYmFyUG9zaXRpb24yW1wiQm90dG9tXCJdID0gXCJib3R0b21cIjtcbiAgVG9vbGJhclBvc2l0aW9uMltcIkxlZnRcIl0gPSBcImxlZnRcIjtcbiAgVG9vbGJhclBvc2l0aW9uMltcIkZsb2F0aW5nXCJdID0gXCJmbG9hdGluZ1wiO1xuICBUb29sYmFyUG9zaXRpb24yW1wiRmxvYXRpbmdUb3BcIl0gPSBcImZsb2F0aW5nLXRvcFwiO1xuICBUb29sYmFyUG9zaXRpb24yW1wiRmxvYXRpbmdCb3R0b21cIl0gPSBcImZsb2F0aW5nLWJvdHRvbVwiO1xuICByZXR1cm4gVG9vbGJhclBvc2l0aW9uMjtcbn0pKFRvb2xiYXJQb3NpdGlvbiB8fCB7fSk7XG52YXIgVE9PTEJBUl9QT1NJVElPTlMgPSBPYmplY3QudmFsdWVzKFRvb2xiYXJQb3NpdGlvbik7XG5mdW5jdGlvbiBpc0FuaW1hdGluZ0Zsb2F0aW5nUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgcmV0dXJuIFtcImZsb2F0aW5nLXRvcFwiIC8qIEZsb2F0aW5nVG9wICovLCBcImZsb2F0aW5nLWJvdHRvbVwiIC8qIEZsb2F0aW5nQm90dG9tICovXS5pbmNsdWRlcyhwb3NpdGlvbik7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL3Rvb2xiYXJNYW5hZ2VyLnRzXG52YXIgVG9vbGJhck1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgc3RhdGljIGlzR3JvdXAoZ3JvdXAsIGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50Lmdyb3VwID09PSBncm91cDtcbiAgfVxuICBzdGF0aWMgaXNDaGlsZEVsZW1lbnQoZG9tTWFuYWdlciwgZWxlbWVudDIpIHtcbiAgICBmb3IgKGNvbnN0IHBvc2l0aW9uIG9mIFRPT0xCQVJfUE9TSVRJT05TKSB7XG4gICAgICBpZiAoZG9tTWFuYWdlci5pc01hbmFnZWRDaGlsZERPTUVsZW1lbnQoZWxlbWVudDIsIFwiY2FudmFzLW92ZXJsYXlcIiwgYHRvb2xiYXItJHtwb3NpdGlvbn1gKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHByZXNzQnV0dG9uKGdyb3VwLCBpZCwgdmFsdWUsIHJlY3QpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImJ1dHRvbi1wcmVzc2VkXCIsIHsgdHlwZTogXCJidXR0b24tcHJlc3NlZFwiLCBncm91cCwgaWQsIHZhbHVlLCByZWN0IH0pO1xuICB9XG4gIGNhbmNlbChncm91cCkge1xuICAgIHRoaXMubGlzdGVuZXJzLmRpc3BhdGNoKFwiY2FuY2VsbGVkXCIsIHsgdHlwZTogXCJjYW5jZWxsZWRcIiwgZ3JvdXAgfSk7XG4gIH1cbiAgdG9nZ2xlQnV0dG9uKGdyb3VwLCBpZCwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgYWN0aXZlID0gZmFsc2UsIGVuYWJsZWQgPSB0cnVlLCB2aXNpYmxlID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImJ1dHRvbi10b2dnbGVkXCIsIHsgdHlwZTogXCJidXR0b24tdG9nZ2xlZFwiLCBncm91cCwgaWQsIGFjdGl2ZSwgZW5hYmxlZCwgdmlzaWJsZSB9KTtcbiAgfVxuICB1cGRhdGVCdXR0b24oZ3JvdXAsIGlkLCBvcHRpb25zKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJidXR0b24tdXBkYXRlZFwiLCB7IHR5cGU6IFwiYnV0dG9uLXVwZGF0ZWRcIiwgZ3JvdXAsIGlkLCAuLi5vcHRpb25zIH0pO1xuICB9XG4gIHRvZ2dsZUdyb3VwKGNhbGxlciwgZ3JvdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGFjdGl2ZSwgdmlzaWJsZSB9ID0gb3B0aW9ucztcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImdyb3VwLXRvZ2dsZWRcIiwgeyB0eXBlOiBcImdyb3VwLXRvZ2dsZWRcIiwgY2FsbGVyLCBncm91cCwgYWN0aXZlLCB2aXNpYmxlIH0pO1xuICB9XG4gIGNoYW5nZUZsb2F0aW5nQW5jaG9yKGdyb3VwLCBhbmNob3IpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcImZsb2F0aW5nLWFuY2hvci1jaGFuZ2VkXCIsIHsgdHlwZTogXCJmbG9hdGluZy1hbmNob3ItY2hhbmdlZFwiLCBncm91cCwgYW5jaG9yIH0pO1xuICB9XG4gIGJ1dHRvbk1vdmVkKGdyb3VwLCB2YWx1ZSwgcmVjdCwgZ3JvdXBSZWN0KSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJidXR0b24tbW92ZWRcIiwgeyB0eXBlOiBcImJ1dHRvbi1tb3ZlZFwiLCBncm91cCwgdmFsdWUsIHJlY3QsIGdyb3VwUmVjdCB9KTtcbiAgfVxuICBwcm94eUdyb3VwT3B0aW9ucyhjYWxsZXIsIGdyb3VwLCBvcHRpb25zKSB7XG4gICAgdGhpcy5saXN0ZW5lcnMuZGlzcGF0Y2goXCJwcm94eS1ncm91cC1vcHRpb25zXCIsIHsgdHlwZTogXCJwcm94eS1ncm91cC1vcHRpb25zXCIsIGNhbGxlciwgZ3JvdXAsIG9wdGlvbnMgfSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ludGVyYWN0aW9uL3Rvb2x0aXBNYW5hZ2VyLnRzXG52YXIgVG9vbHRpcE1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRvbU1hbmFnZXIsIHRvb2x0aXApIHtcbiAgICB0aGlzLmRvbU1hbmFnZXIgPSBkb21NYW5hZ2VyO1xuICAgIHRoaXMudG9vbHRpcCA9IHRvb2x0aXA7XG4gICAgdGhpcy5zdGF0ZVRyYWNrZXIgPSBuZXcgU3RhdGVUcmFja2VyKCk7XG4gICAgdGhpcy5zdXBwcmVzc1N0YXRlID0gbmV3IFN0YXRlVHJhY2tlcihmYWxzZSk7XG4gICAgdGhpcy5hcHBsaWVkU3RhdGUgPSBudWxsO1xuICAgIHRvb2x0aXAuc2V0dXAoZG9tTWFuYWdlcik7XG4gICAgZG9tTWFuYWdlci5hZGRMaXN0ZW5lcihcImhpZGRlblwiLCAoKSA9PiB0aGlzLnRvb2x0aXAudG9nZ2xlKGZhbHNlKSk7XG4gIH1cbiAgdXBkYXRlVG9vbHRpcChjYWxsZXJJZCwgbWV0YSwgY29udGVudCkge1xuICAgIGlmICghdGhpcy50b29sdGlwLmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgY29udGVudCA/PyAoY29udGVudCA9IHRoaXMuc3RhdGVUcmFja2VyLmdldChjYWxsZXJJZCk/LmNvbnRlbnQpO1xuICAgIHRoaXMuc3RhdGVUcmFja2VyLnNldChjYWxsZXJJZCwgeyBjb250ZW50LCBtZXRhIH0pO1xuICAgIHRoaXMuYXBwbHlTdGF0ZXMoKTtcbiAgfVxuICByZW1vdmVUb29sdGlwKGNhbGxlcklkKSB7XG4gICAgaWYgKCF0aGlzLnRvb2x0aXAuZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnN0YXRlVHJhY2tlci5kZWxldGUoY2FsbGVySWQpO1xuICAgIHRoaXMuYXBwbHlTdGF0ZXMoKTtcbiAgfVxuICBzdXBwcmVzc1Rvb2x0aXAoY2FsbGVySWQpIHtcbiAgICB0aGlzLnN1cHByZXNzU3RhdGUuc2V0KGNhbGxlcklkLCB0cnVlKTtcbiAgfVxuICB1bnN1cHByZXNzVG9vbHRpcChjYWxsZXJJZCkge1xuICAgIHRoaXMuc3VwcHJlc3NTdGF0ZS5kZWxldGUoY2FsbGVySWQpO1xuICB9XG4gIGdldFRvb2x0aXBNZXRhKGNhbGxlcklkKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVUcmFja2VyLmdldChjYWxsZXJJZCk/Lm1ldGE7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRvbU1hbmFnZXIucmVtb3ZlU3R5bGVzKFwidG9vbHRpcFwiKTtcbiAgfVxuICBhcHBseVN0YXRlcygpIHtcbiAgICBjb25zdCBpZCA9IHRoaXMuc3RhdGVUcmFja2VyLnN0YXRlSWQoKTtcbiAgICBjb25zdCBzdGF0ZSA9IGlkID8gdGhpcy5zdGF0ZVRyYWNrZXIuZ2V0KGlkKSA6IG51bGw7XG4gICAgaWYgKHRoaXMuc3VwcHJlc3NTdGF0ZS5zdGF0ZVZhbHVlKCkgfHwgc3RhdGU/Lm1ldGEgPT0gbnVsbCB8fCBzdGF0ZT8uY29udGVudCA9PSBudWxsKSB7XG4gICAgICB0aGlzLmFwcGxpZWRTdGF0ZSA9IG51bGw7XG4gICAgICB0aGlzLnRvb2x0aXAudG9nZ2xlKGZhbHNlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2FudmFzUmVjdCA9IHRoaXMuZG9tTWFuYWdlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBib3VuZGluZ1JlY3QgPSB0aGlzLnRvb2x0aXAuYm91bmRzID09PSBcImV4dGVuZGVkXCIgPyB0aGlzLmRvbU1hbmFnZXIuZ2V0T3ZlcmxheUNsaWVudFJlY3QoKSA6IGNhbnZhc1JlY3Q7XG4gICAgaWYgKHRoaXMuYXBwbGllZFN0YXRlPy5jb250ZW50ID09PSBzdGF0ZT8uY29udGVudCkge1xuICAgICAgY29uc3QgcmVuZGVySW5zdGFudGx5ID0gdGhpcy50b29sdGlwLmlzVmlzaWJsZSgpO1xuICAgICAgdGhpcy50b29sdGlwLnNob3coYm91bmRpbmdSZWN0LCBjYW52YXNSZWN0LCBzdGF0ZT8ubWV0YSwgbnVsbCwgcmVuZGVySW5zdGFudGx5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50b29sdGlwLnNob3coYm91bmRpbmdSZWN0LCBjYW52YXNSZWN0LCBzdGF0ZT8ubWV0YSwgc3RhdGU/LmNvbnRlbnQpO1xuICAgIH1cbiAgICB0aGlzLmFwcGxpZWRTdGF0ZSA9IHN0YXRlO1xuICB9XG4gIHN0YXRpYyBtYWtlVG9vbHRpcE1ldGEoZXZlbnQsIGRhdHVtKSB7XG4gICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcbiAgICBjb25zdCB7IHRvb2x0aXAgfSA9IGRhdHVtLnNlcmllcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IG1ldGEgPSB7XG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WSxcbiAgICAgIGVuYWJsZUludGVyYWN0aW9uOiB0b29sdGlwLmludGVyYWN0aW9uPy5lbmFibGVkID8/IGZhbHNlLFxuICAgICAgbGFzdFBvaW50ZXJFdmVudDogeyB0eXBlOiBldmVudC50eXBlLCBvZmZzZXRYLCBvZmZzZXRZIH0sXG4gICAgICBzaG93QXJyb3c6IHRvb2x0aXAuc2hvd0Fycm93LFxuICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgdHlwZTogdG9vbHRpcC5wb3NpdGlvbi50eXBlLFxuICAgICAgICB4T2Zmc2V0OiB0b29sdGlwLnBvc2l0aW9uLnhPZmZzZXQsXG4gICAgICAgIHlPZmZzZXQ6IHRvb2x0aXAucG9zaXRpb24ueU9mZnNldFxuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVmUG9pbnQgPSBkYXR1bS55QmFyPy51cHBlclBvaW50ID8/IGRhdHVtLm1pZFBvaW50ID8/IGRhdHVtLnNlcmllcy5kYXR1bU1pZFBvaW50Py4oZGF0dW0pO1xuICAgIGlmICh0b29sdGlwLnBvc2l0aW9uLnR5cGUgPT09IFwibm9kZVwiICYmIHJlZlBvaW50KSB7XG4gICAgICBjb25zdCB7IHgsIHkgfSA9IHJlZlBvaW50O1xuICAgICAgY29uc3QgcG9pbnQgPSBkYXR1bS5zZXJpZXMuY29udGVudEdyb3VwLmludmVyc2VUcmFuc2Zvcm1Qb2ludCh4LCB5KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGEsXG4gICAgICAgIG9mZnNldFg6IE1hdGgucm91bmQocG9pbnQueCksXG4gICAgICAgIG9mZnNldFk6IE1hdGgucm91bmQocG9pbnQueSlcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBtZXRhO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9sYXlvdXQvbGF5b3V0U2VydmljZS50c1xudmFyIExheW91dFNlcnZpY2UgPSBjbGFzcyBleHRlbmRzIExpc3RlbmVycyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5sYXlvdXRDb21wbGV0ZSA9IFwibGF5b3V0LWNvbXBsZXRlXCI7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcImxheW91dFwiKTtcbiAgfVxuICBhZGRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIpIHtcbiAgICBpZiAodGhpcy5pc0xheW91dFN0YWdlKGV2ZW50VHlwZSkgfHwgdGhpcy5pc0xheW91dENvbXBsZXRlKGV2ZW50VHlwZSkpIHtcbiAgICAgIHJldHVybiBzdXBlci5hZGRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIHVuc3VwcG9ydGVkIGxpc3RlbmVyIHR5cGU6ICR7ZXZlbnRUeXBlfWApO1xuICB9XG4gIGRpc3BhdGNoUGVyZm9ybUxheW91dChzdGFnZSwgY3R4KSB7XG4gICAgaWYgKHRoaXMuaXNMYXlvdXRTdGFnZShzdGFnZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldExpc3RlbmVyc0J5VHlwZShzdGFnZSkucmVkdWNlKChyZXN1bHQsIGxpc3RlbmVyKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgbmV3Q3R4ID0gbGlzdGVuZXIuaGFuZGxlcihyZXN1bHQpO1xuICAgICAgICAgIHRoaXMuZGVidWcoXCJbTGF5b3V0U2VydmljZV0gQ29udGV4dCB1cGRhdGVkIHRvOiBcIiwgeyAuLi5uZXdDdHggfSwgbGlzdGVuZXIpO1xuICAgICAgICAgIHJldHVybiBuZXdDdHg7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBMb2dnZXIuZXJyb3JPbmNlKGUpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH0sIGN0eCk7XG4gICAgfVxuICAgIHJldHVybiBjdHg7XG4gIH1cbiAgZGlzcGF0Y2hMYXlvdXRDb21wbGV0ZShldmVudCkge1xuICAgIHRoaXMuZGlzcGF0Y2godGhpcy5sYXlvdXRDb21wbGV0ZSwgZXZlbnQpO1xuICB9XG4gIGlzTGF5b3V0U3RhZ2UoZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIGV2ZW50VHlwZSAhPT0gdGhpcy5sYXlvdXRDb21wbGV0ZTtcbiAgfVxuICBpc0xheW91dENvbXBsZXRlKGV2ZW50VHlwZSkge1xuICAgIHJldHVybiBldmVudFR5cGUgPT09IHRoaXMubGF5b3V0Q29tcGxldGU7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2xvY2FsZS9kZWZhdWx0TWVzc2FnZUZvcm1hdHRlci50c1xudmFyIG1lc3NhZ2VSZWdFeHAgPSAvXFwkXFx7KFxcdyspfSg/OlxcWyhcXHcrKV0pPy9naTtcbnZhciBmb3JtYXR0ZXJzID0ge1xuICBudW1iZXI6IG5ldyBJbnRsLk51bWJlckZvcm1hdChcImVuLVVTXCIpLFxuICBwZXJjZW50OiBuZXcgSW50bC5OdW1iZXJGb3JtYXQoXCJlbi1VU1wiLCB7IHN0eWxlOiBcInBlcmNlbnRcIiB9KSxcbiAgZGF0ZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoXCJlbi1VU1wiLCB7IGRhdGVTdHlsZTogXCJmdWxsXCIgfSksXG4gIHRpbWU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KFwiZW4tVVNcIiwgeyB0aW1lU3R5bGU6IFwiZnVsbFwiIH0pLFxuICBkYXRldGltZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoXCJlbi1VU1wiLCB7IGRhdGVTdHlsZTogXCJmdWxsXCIsIHRpbWVTdHlsZTogXCJmdWxsXCIgfSlcbn07XG52YXIgZGVmYXVsdE1lc3NhZ2VGb3JtYXR0ZXIgPSAoeyBkZWZhdWx0VmFsdWUsIHZhcmlhYmxlcyB9KSA9PiB7XG4gIHJldHVybiBkZWZhdWx0VmFsdWU/LnJlcGxhY2VBbGwobWVzc2FnZVJlZ0V4cCwgKF8sIG1hdGNoLCBmb3JtYXQpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHZhcmlhYmxlc1ttYXRjaF07XG4gICAgY29uc3QgZm9ybWF0dGVyID0gZm9ybWF0ICE9IG51bGwgPyBmb3JtYXR0ZXJzW2Zvcm1hdF0gOiB2b2lkIDA7XG4gICAgaWYgKGZvcm1hdCAhPSBudWxsICYmIGZvcm1hdHRlciA9PSBudWxsKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoYEZvcm1hdCBzdHlsZSBbJHtmb3JtYXR9XSBpcyBub3Qgc3VwcG9ydGVkYCk7XG4gICAgfVxuICAgIGlmIChmb3JtYXR0ZXIgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQodmFsdWUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICByZXR1cm4gZm9ybWF0dGVycy5udW1iZXIuZm9ybWF0KHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIGZvcm1hdHRlcnMuZGF0ZXRpbWUuZm9ybWF0KHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gIH0pO1xufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbG9jYWxlL2xvY2FsZU1hbmFnZXIudHNcbnZhciBMb2NhbGVNYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBMaXN0ZW5lcnMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubG9jYWxlVGV4dCA9IHZvaWQgMDtcbiAgICB0aGlzLmdldExvY2FsZVRleHQgPSB2b2lkIDA7XG4gIH1cbiAgc2V0TG9jYWxlVGV4dChsb2NhbGVUZXh0KSB7XG4gICAgaWYgKHRoaXMubG9jYWxlVGV4dCAhPT0gbG9jYWxlVGV4dCkge1xuICAgICAgdGhpcy5sb2NhbGVUZXh0ID0gbG9jYWxlVGV4dDtcbiAgICAgIHRoaXMuZGlzcGF0Y2goXCJsb2NhbGUtY2hhbmdlZFwiKTtcbiAgICB9XG4gIH1cbiAgc2V0TG9jYWxlVGV4dEZvcm1hdHRlcihnZXRMb2NhbGVUZXh0KSB7XG4gICAgdGhpcy5nZXRMb2NhbGVUZXh0ID0gZ2V0TG9jYWxlVGV4dDtcbiAgICBpZiAodGhpcy5nZXRMb2NhbGVUZXh0ICE9PSBnZXRMb2NhbGVUZXh0KSB7XG4gICAgICB0aGlzLmdldExvY2FsZVRleHQgPSBnZXRMb2NhbGVUZXh0O1xuICAgICAgdGhpcy5kaXNwYXRjaChcImxvY2FsZS1jaGFuZ2VkXCIpO1xuICAgIH1cbiAgfVxuICB0KGtleSwgdmFyaWFibGVzID0ge30pIHtcbiAgICBjb25zdCB7IGxvY2FsZVRleHQgPSBBR19DSEFSVFNfTE9DQUxFX0VOX1VTLCBnZXRMb2NhbGVUZXh0IH0gPSB0aGlzO1xuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGxvY2FsZVRleHRba2V5XTtcbiAgICByZXR1cm4gZ2V0TG9jYWxlVGV4dD8uKHsga2V5LCBkZWZhdWx0VmFsdWUsIHZhcmlhYmxlcyB9KSA/PyBkZWZhdWx0TWVzc2FnZUZvcm1hdHRlcih7IGtleSwgZGVmYXVsdFZhbHVlLCB2YXJpYWJsZXMgfSkgPz8ga2V5O1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvc2VyaWVzU3RhdGVNYW5hZ2VyLnRzXG52YXIgU2VyaWVzU3RhdGVNYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICB9XG4gIHJlZ2lzdGVyU2VyaWVzKHtcbiAgICBpZCxcbiAgICBzZXJpZXNHcm91cGluZyxcbiAgICB2aXNpYmxlLFxuICAgIHR5cGVcbiAgfSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXNlcmllc0dyb3VwaW5nKVxuICAgICAgcmV0dXJuO1xuICAgIChfYSA9IHRoaXMuZ3JvdXBzKVt0eXBlXSA/PyAoX2FbdHlwZV0gPSB7fSk7XG4gICAgdGhpcy5ncm91cHNbdHlwZV1baWRdID0geyBncm91cGluZzogc2VyaWVzR3JvdXBpbmcsIHZpc2libGUgfTtcbiAgfVxuICBkZXJlZ2lzdGVyU2VyaWVzKHsgaWQsIHR5cGUgfSkge1xuICAgIGlmICh0aGlzLmdyb3Vwc1t0eXBlXSkge1xuICAgICAgZGVsZXRlIHRoaXMuZ3JvdXBzW3R5cGVdW2lkXTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZ3JvdXBzW3R5cGVdICYmIE9iamVjdC5rZXlzKHRoaXMuZ3JvdXBzW3R5cGVdKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmdyb3Vwc1t0eXBlXTtcbiAgICB9XG4gIH1cbiAgZ2V0VmlzaWJsZVBlZXJHcm91cEluZGV4KHtcbiAgICB0eXBlLFxuICAgIHNlcmllc0dyb3VwaW5nLFxuICAgIHZpc2libGVcbiAgfSkge1xuICAgIGlmICghc2VyaWVzR3JvdXBpbmcpXG4gICAgICByZXR1cm4geyB2aXNpYmxlR3JvdXBDb3VudDogdmlzaWJsZSA/IDEgOiAwLCB2aXNpYmxlU2FtZVN0YWNrQ291bnQ6IHZpc2libGUgPyAxIDogMCwgaW5kZXg6IDAgfTtcbiAgICBjb25zdCB2aXNpYmxlR3JvdXBzU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCB2aXNpYmxlU2FtZVN0YWNrU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIE9iamVjdC52YWx1ZXModGhpcy5ncm91cHNbdHlwZV0gPz8ge30pKSB7XG4gICAgICBpZiAoIWVudHJ5LnZpc2libGUpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmlzaWJsZUdyb3Vwc1NldC5hZGQoZW50cnkuZ3JvdXBpbmcuZ3JvdXBJbmRleCk7XG4gICAgICBpZiAoZW50cnkuZ3JvdXBpbmcuZ3JvdXBJbmRleCA9PT0gc2VyaWVzR3JvdXBpbmcuZ3JvdXBJbmRleCkge1xuICAgICAgICB2aXNpYmxlU2FtZVN0YWNrU2V0LmFkZChlbnRyeS5ncm91cGluZy5zdGFja0luZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdmlzaWJsZUdyb3VwcyA9IEFycmF5LmZyb20odmlzaWJsZUdyb3Vwc1NldCk7XG4gICAgdmlzaWJsZUdyb3Vwcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZpc2libGVHcm91cENvdW50OiB2aXNpYmxlR3JvdXBzLmxlbmd0aCxcbiAgICAgIHZpc2libGVTYW1lU3RhY2tDb3VudDogdmlzaWJsZVNhbWVTdGFja1NldC5zaXplLFxuICAgICAgaW5kZXg6IHZpc2libGVHcm91cHMuaW5kZXhPZihzZXJpZXNHcm91cGluZy5ncm91cEluZGV4KVxuICAgIH07XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2NoYXJ0VXBkYXRlVHlwZS50c1xudmFyIENoYXJ0VXBkYXRlVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAoKENoYXJ0VXBkYXRlVHlwZTMpID0+IHtcbiAgQ2hhcnRVcGRhdGVUeXBlM1tDaGFydFVwZGF0ZVR5cGUzW1wiRlVMTFwiXSA9IDBdID0gXCJGVUxMXCI7XG4gIENoYXJ0VXBkYXRlVHlwZTNbQ2hhcnRVcGRhdGVUeXBlM1tcIlVQREFURV9EQVRBXCJdID0gMV0gPSBcIlVQREFURV9EQVRBXCI7XG4gIENoYXJ0VXBkYXRlVHlwZTNbQ2hhcnRVcGRhdGVUeXBlM1tcIlBST0NFU1NfREFUQVwiXSA9IDJdID0gXCJQUk9DRVNTX0RBVEFcIjtcbiAgQ2hhcnRVcGRhdGVUeXBlM1tDaGFydFVwZGF0ZVR5cGUzW1wiUEVSRk9STV9MQVlPVVRcIl0gPSAzXSA9IFwiUEVSRk9STV9MQVlPVVRcIjtcbiAgQ2hhcnRVcGRhdGVUeXBlM1tDaGFydFVwZGF0ZVR5cGUzW1wiU0VSSUVTX1VQREFURVwiXSA9IDRdID0gXCJTRVJJRVNfVVBEQVRFXCI7XG4gIENoYXJ0VXBkYXRlVHlwZTNbQ2hhcnRVcGRhdGVUeXBlM1tcIlBSRV9TQ0VORV9SRU5ERVJcIl0gPSA1XSA9IFwiUFJFX1NDRU5FX1JFTkRFUlwiO1xuICBDaGFydFVwZGF0ZVR5cGUzW0NoYXJ0VXBkYXRlVHlwZTNbXCJTQ0VORV9SRU5ERVJcIl0gPSA2XSA9IFwiU0NFTkVfUkVOREVSXCI7XG4gIENoYXJ0VXBkYXRlVHlwZTNbQ2hhcnRVcGRhdGVUeXBlM1tcIk5PTkVcIl0gPSA3XSA9IFwiTk9ORVwiO1xuICByZXR1cm4gQ2hhcnRVcGRhdGVUeXBlMztcbn0pKENoYXJ0VXBkYXRlVHlwZSB8fCB7fSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3VwZGF0ZVNlcnZpY2UudHNcbnZhciBVcGRhdGVTZXJ2aWNlID0gY2xhc3MgZXh0ZW5kcyBMaXN0ZW5lcnMge1xuICBjb25zdHJ1Y3Rvcih1cGRhdGVDYWxsYmFjaykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy51cGRhdGVDYWxsYmFjayA9IHVwZGF0ZUNhbGxiYWNrO1xuICB9XG4gIHVwZGF0ZSh0eXBlID0gMCAvKiBGVUxMICovLCBvcHRpb25zKSB7XG4gICAgdGhpcy51cGRhdGVDYWxsYmFjayh0eXBlLCBvcHRpb25zKTtcbiAgfVxuICBkaXNwYXRjaFVwZGF0ZUNvbXBsZXRlKHJlY3RzKSB7XG4gICAgdGhpcy5kaXNwYXRjaChcInVwZGF0ZS1jb21wbGV0ZVwiLCB7XG4gICAgICB0eXBlOiBcInVwZGF0ZS1jb21wbGV0ZVwiLFxuICAgICAgbWluUmVjdDogcmVjdHM/Lm1pblJlY3QsXG4gICAgICBtaW5WaXNpYmxlUmVjdDogcmVjdHM/Lm1pblZpc2libGVSZWN0XG4gICAgfSk7XG4gIH1cbiAgZGlzcGF0Y2hQcmVTY2VuZVJlbmRlcihyZWN0cykge1xuICAgIHRoaXMuZGlzcGF0Y2goXCJwcmUtc2NlbmUtcmVuZGVyXCIsIHsgdHlwZTogXCJwcmUtc2NlbmUtcmVuZGVyXCIsIC4uLnJlY3RzIH0pO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jaGFydENvbnRleHQudHNcbnZhciBDaGFydENvbnRleHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCB2YXJzKSB7XG4gICAgY29uc3QgeyBzY2VuZSwgcm9vdCwgc3luY01hbmFnZXIsIGNvbnRhaW5lciwgdXBkYXRlQ2FsbGJhY2ssIHVwZGF0ZU11dGV4LCBvdmVycmlkZURldmljZVBpeGVsUmF0aW8gfSA9IHZhcnM7XG4gICAgdGhpcy5jaGFydFNlcnZpY2UgPSBjaGFydDtcbiAgICB0aGlzLnN5bmNNYW5hZ2VyID0gc3luY01hbmFnZXI7XG4gICAgdGhpcy56b29tTWFuYWdlciA9IGNoYXJ0Lnpvb21NYW5hZ2VyO1xuICAgIHRoaXMuZG9tTWFuYWdlciA9IG5ldyBET01NYW5hZ2VyKGNvbnRhaW5lcik7XG4gICAgc2NlbmU/LnNldENvbnRhaW5lcih0aGlzLmRvbU1hbmFnZXIpO1xuICAgIHRoaXMuc2NlbmUgPSBzY2VuZSA/PyBuZXcgU2NlbmUoeyBwaXhlbFJhdGlvOiBvdmVycmlkZURldmljZVBpeGVsUmF0aW8sIGRvbU1hbmFnZXI6IHRoaXMuZG9tTWFuYWdlciB9KTtcbiAgICB0aGlzLnNjZW5lLnNldFJvb3Qocm9vdCk7XG4gICAgdGhpcy5heGlzTWFuYWdlciA9IG5ldyBBeGlzTWFuYWdlcihyb290KTtcbiAgICB0aGlzLmxvY2FsZU1hbmFnZXIgPSBuZXcgTG9jYWxlTWFuYWdlcigpO1xuICAgIHRoaXMuYW5ub3RhdGlvbk1hbmFnZXIgPSBuZXcgQW5ub3RhdGlvbk1hbmFnZXIoY2hhcnQuYW5ub3RhdGlvblJvb3QpO1xuICAgIHRoaXMuY2hhcnRFdmVudE1hbmFnZXIgPSBuZXcgQ2hhcnRFdmVudE1hbmFnZXIoKTtcbiAgICB0aGlzLmN1cnNvck1hbmFnZXIgPSBuZXcgQ3Vyc29yTWFuYWdlcih0aGlzLmRvbU1hbmFnZXIpO1xuICAgIHRoaXMuaGlnaGxpZ2h0TWFuYWdlciA9IG5ldyBIaWdobGlnaHRNYW5hZ2VyKCk7XG4gICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIgPSBuZXcgSW50ZXJhY3Rpb25NYW5hZ2VyKGNoYXJ0LmtleWJvYXJkLCB0aGlzLmRvbU1hbmFnZXIpO1xuICAgIHRoaXMua2V5TmF2TWFuYWdlciA9IG5ldyBLZXlOYXZNYW5hZ2VyKHRoaXMuaW50ZXJhY3Rpb25NYW5hZ2VyLCB0aGlzLmRvbU1hbmFnZXIpO1xuICAgIHRoaXMuZm9jdXNJbmRpY2F0b3IgPSBuZXcgRm9jdXNJbmRpY2F0b3IodGhpcy5kb21NYW5hZ2VyKTtcbiAgICB0aGlzLnJlZ2lvbk1hbmFnZXIgPSBuZXcgUmVnaW9uTWFuYWdlcih0aGlzLmludGVyYWN0aW9uTWFuYWdlciwgdGhpcy5rZXlOYXZNYW5hZ2VyLCB0aGlzLmZvY3VzSW5kaWNhdG9yKTtcbiAgICB0aGlzLmNvbnRleHRNZW51UmVnaXN0cnkgPSBuZXcgQ29udGV4dE1lbnVSZWdpc3RyeSh0aGlzLnJlZ2lvbk1hbmFnZXIpO1xuICAgIHRoaXMudG9vbGJhck1hbmFnZXIgPSBuZXcgVG9vbGJhck1hbmFnZXIoKTtcbiAgICB0aGlzLmdlc3R1cmVEZXRlY3RvciA9IG5ldyBHZXN0dXJlRGV0ZWN0b3IodGhpcy5kb21NYW5hZ2VyKTtcbiAgICB0aGlzLmxheW91dFNlcnZpY2UgPSBuZXcgTGF5b3V0U2VydmljZSgpO1xuICAgIHRoaXMuYXJpYUFubm91bmNlbWVudFNlcnZpY2UgPSBuZXcgQXJpYUFubm91bmNlbWVudFNlcnZpY2UoXG4gICAgICB0aGlzLmxvY2FsZU1hbmFnZXIsXG4gICAgICB0aGlzLmRvbU1hbmFnZXIsXG4gICAgICB0aGlzLmxheW91dFNlcnZpY2VcbiAgICApO1xuICAgIHRoaXMudXBkYXRlU2VydmljZSA9IG5ldyBVcGRhdGVTZXJ2aWNlKHVwZGF0ZUNhbGxiYWNrKTtcbiAgICB0aGlzLnByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlID0gbmV3IFByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlKFxuICAgICAgdGhpcy51cGRhdGVTZXJ2aWNlLFxuICAgICAgdGhpcy5sb2NhbGVNYW5hZ2VyLFxuICAgICAgdGhpcy5kb21NYW5hZ2VyLFxuICAgICAgdGhpcy5mb2N1c0luZGljYXRvclxuICAgICk7XG4gICAgdGhpcy5zZXJpZXNTdGF0ZU1hbmFnZXIgPSBuZXcgU2VyaWVzU3RhdGVNYW5hZ2VyKCk7XG4gICAgdGhpcy5zdGF0ZU1hbmFnZXIgPSBuZXcgU3RhdGVNYW5hZ2VyKCk7XG4gICAgdGhpcy5jYWxsYmFja0NhY2hlID0gbmV3IENhbGxiYWNrQ2FjaGUoKTtcbiAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIgPSBuZXcgQW5pbWF0aW9uTWFuYWdlcih0aGlzLmludGVyYWN0aW9uTWFuYWdlciwgdXBkYXRlTXV0ZXgpO1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlci5za2lwKCk7XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyLnBsYXkoKTtcbiAgICB0aGlzLmRhdGFTZXJ2aWNlID0gbmV3IERhdGFTZXJ2aWNlKHRoaXMuYW5pbWF0aW9uTWFuYWdlcik7XG4gICAgdGhpcy50b29sdGlwTWFuYWdlciA9IG5ldyBUb29sdGlwTWFuYWdlcih0aGlzLmRvbU1hbmFnZXIsIGNoYXJ0LnRvb2x0aXApO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy50b29sdGlwTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5jb250ZXh0TWVudVJlZ2lzdHJ5LmRlc3Ryb3koKTtcbiAgICB0aGlzLnJlZ2lvbk1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMucHJveHlJbnRlcmFjdGlvblNlcnZpY2UuZGVzdHJveSgpO1xuICAgIHRoaXMuZm9jdXNJbmRpY2F0b3IuZGVzdHJveSgpO1xuICAgIHRoaXMua2V5TmF2TWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5pbnRlcmFjdGlvbk1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuYW5pbWF0aW9uTWFuYWdlci5zdG9wKCk7XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmFyaWFBbm5vdW5jZW1lbnRTZXJ2aWNlLmRlc3Ryb3koKTtcbiAgICB0aGlzLmNoYXJ0RXZlbnRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmhpZ2hsaWdodE1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuY2FsbGJhY2tDYWNoZS5pbnZhbGlkYXRlQ2FjaGUoKTtcbiAgICB0aGlzLmFuaW1hdGlvbk1hbmFnZXIucmVzZXQoKTtcbiAgICB0aGlzLnN5bmNNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmRvbU1hbmFnZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuYXhpc01hbmFnZXIuZGVzdHJveSgpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jaGFydEhpZ2hsaWdodC50c1xudmFyIENoYXJ0SGlnaGxpZ2h0ID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5yYW5nZSA9IFwidG9vbHRpcFwiO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVU5JT04oW1widG9vbHRpcFwiLCBcIm5vZGVcIl0sIFwiYSByYW5nZVwiKSlcbl0sIENoYXJ0SGlnaGxpZ2h0LnByb3RvdHlwZSwgXCJyYW5nZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZGF0YS9kYXRhRG9tYWluLnRzXG52YXIgRGlzY3JldGVEb21haW4gPSBjbGFzcyBfRGlzY3JldGVEb21haW4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmRvbWFpbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIH1cbiAgc3RhdGljIGlzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgX0Rpc2NyZXRlRG9tYWluO1xuICB9XG4gIGV4dGVuZCh2YWwpIHtcbiAgICB0aGlzLmRvbWFpbi5hZGQodmFsKTtcbiAgfVxuICBnZXREb21haW4oKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5kb21haW4pO1xuICB9XG59O1xudmFyIENvbnRpbnVvdXNEb21haW4gPSBjbGFzcyBfQ29udGludW91c0RvbWFpbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZG9tYWluID0gW0luZmluaXR5LCAtSW5maW5pdHldO1xuICB9XG4gIHN0YXRpYyBpcyh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIF9Db250aW51b3VzRG9tYWluO1xuICB9XG4gIHN0YXRpYyBleHRlbmREb21haW4odmFsdWVzLCBkb21haW4gPSBbSW5maW5pdHksIC1JbmZpbml0eV0pIHtcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkb21haW5bMF0gPiB2YWx1ZSkge1xuICAgICAgICBkb21haW5bMF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChkb21haW5bMV0gPCB2YWx1ZSkge1xuICAgICAgICBkb21haW5bMV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRvbWFpbjtcbiAgfVxuICBleHRlbmQodmFsdWUpIHtcbiAgICBpZiAodGhpcy5kb21haW5bMF0gPiB2YWx1ZSkge1xuICAgICAgdGhpcy5kb21haW5bMF0gPSB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZG9tYWluWzFdIDwgdmFsdWUpIHtcbiAgICAgIHRoaXMuZG9tYWluWzFdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIGdldERvbWFpbigpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuZG9tYWluXTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZGF0YS9kYXRhTW9kZWwudHNcbmZ1bmN0aW9uIHRvS2V5U3RyaW5nKGtleXMpIHtcbiAgcmV0dXJuIGtleXMubWFwKChrZXkpID0+IGlzT2JqZWN0KGtleSkgPyBKU09OLnN0cmluZ2lmeShrZXkpIDoga2V5KS5qb2luKFwiLVwiKTtcbn1cbmZ1bmN0aW9uIHJvdW5kMih2YWwpIHtcbiAgY29uc3QgYWNjdXJhY3kgPSAxZTQ7XG4gIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbCkpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9IGVsc2UgaWYgKE1hdGguYWJzKHZhbCkgPiBhY2N1cmFjeSkge1xuICAgIHJldHVybiBNYXRoLnRydW5jKHZhbCk7XG4gIH1cbiAgcmV0dXJuIE1hdGgucm91bmQodmFsICogYWNjdXJhY3kpIC8gYWNjdXJhY3k7XG59XG5mdW5jdGlvbiBmaXhOdW1lcmljRXh0ZW50SW50ZXJuYWwoZXh0ZW50Mikge1xuICBpZiAoZXh0ZW50MiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGxldCBbbWluLCBtYXhdID0gZXh0ZW50Mi5tYXAoTnVtYmVyKTtcbiAgaWYgKG1pbiA9PT0gMCAmJiBtYXggPT09IDApIHtcbiAgICByZXR1cm4gWzAsIDFdO1xuICB9XG4gIGlmIChtaW4gPT09IEluZmluaXR5ICYmIG1heCA9PT0gLUluZmluaXR5KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IGVsc2UgaWYgKG1pbiA9PT0gSW5maW5pdHkpIHtcbiAgICBtaW4gPSAwO1xuICB9IGVsc2UgaWYgKG1heCA9PT0gLUluZmluaXR5KSB7XG4gICAgbWF4ID0gMDtcbiAgfVxuICByZXR1cm4gaXNGaW5pdGVOdW1iZXIobWluKSAmJiBpc0Zpbml0ZU51bWJlcihtYXgpID8gW21pbiwgbWF4XSA6IFtdO1xufVxuZnVuY3Rpb24gZml4TnVtZXJpY0V4dGVudChleHRlbnQyLCBheGlzKSB7XG4gIGNvbnN0IGZpeGVkRXh0ZW50ID0gZml4TnVtZXJpY0V4dGVudEludGVybmFsKGV4dGVudDIpO1xuICBpZiAoZml4ZWRFeHRlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZpeGVkRXh0ZW50O1xuICB9XG4gIGxldCBbbWluLCBtYXhdID0gZml4ZWRFeHRlbnQ7XG4gIGlmIChtaW4gPT09IG1heCkge1xuICAgIGNvbnN0IFtwYWRkaW5nTWluLCBwYWRkaW5nTWF4XSA9IGF4aXM/LmNhbGN1bGF0ZVBhZGRpbmcobWluLCBtYXgpID8/IFsxLCAxXTtcbiAgICBtaW4gLT0gcGFkZGluZ01pbjtcbiAgICBtYXggKz0gcGFkZGluZ01heDtcbiAgfVxuICByZXR1cm4gW21pbiwgbWF4XTtcbn1cbmZ1bmN0aW9uIGdldE1pc3NDb3VudChzY29wZVByb3ZpZGVyLCBtaXNzTWFwKSB7XG4gIHJldHVybiBtaXNzTWFwPy5nZXQoc2NvcGVQcm92aWRlci5pZCkgPz8gMDtcbn1cbnZhciBJTlZBTElEX1ZBTFVFID0gU3ltYm9sKFwiaW52YWxpZFwiKTtcbmZ1bmN0aW9uIGdldFBhdGhDb21wb25lbnRzKHBhdGgpIHtcbiAgY29uc3QgY29tcG9uZW50cyA9IFtdO1xuICBsZXQgbWF0Y2hJbmRleCA9IDA7XG4gIGxldCBtYXRjaEdyb3VwO1xuICBjb25zdCByZWdFeHAgPSAvKCg/Oig/Ol58XFwuKVxccypcXHcrfFxcW1xccyooPzonKD86W14nXXxcXFxcJykqJ3xcIig/OlteXCJdfFxcXFxcIikqXCJ8LT9cXGQrKVxccypcXF0pXFxzKikvZztcbiAgd2hpbGUgKG1hdGNoR3JvdXAgPSByZWdFeHAuZXhlYyhwYXRoKSkge1xuICAgIGlmIChtYXRjaEdyb3VwLmluZGV4ICE9PSBtYXRjaEluZGV4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1hdGNoSW5kZXggPSBtYXRjaEdyb3VwLmluZGV4ICsgbWF0Y2hHcm91cFswXS5sZW5ndGg7XG4gICAgY29uc3QgbWF0Y2ggPSBtYXRjaEdyb3VwWzFdLnRyaW0oKTtcbiAgICBpZiAobWF0Y2guc3RhcnRzV2l0aChcIi5cIikpIHtcbiAgICAgIGNvbXBvbmVudHMucHVzaChtYXRjaC5zbGljZSgxKS50cmltKCkpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2guc3RhcnRzV2l0aChcIltcIikpIHtcbiAgICAgIGNvbnN0IGFjY2Vzc29yID0gbWF0Y2guc2xpY2UoMSwgLTEpLnRyaW0oKTtcbiAgICAgIGlmIChhY2Nlc3Nvci5zdGFydHNXaXRoKGAnYCkpIHtcbiAgICAgICAgY29tcG9uZW50cy5wdXNoKGFjY2Vzc29yLnNsaWNlKDEsIC0xKS5yZXBsYWNlKC8oPzwhXFxcXClcXFxcJy9nLCBgJ2ApKTtcbiAgICAgIH0gZWxzZSBpZiAoYWNjZXNzb3Iuc3RhcnRzV2l0aChgXCJgKSkge1xuICAgICAgICBjb21wb25lbnRzLnB1c2goYWNjZXNzb3Iuc2xpY2UoMSwgLTEpLnJlcGxhY2UoLyg/PCFcXFxcKVxcXFxcIi9nLCBgXCJgKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wb25lbnRzLnB1c2goYWNjZXNzb3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnRzLnB1c2gobWF0Y2gpO1xuICAgIH1cbiAgfVxuICBpZiAobWF0Y2hJbmRleCAhPT0gcGF0aC5sZW5ndGgpXG4gICAgcmV0dXJuO1xuICByZXR1cm4gY29tcG9uZW50cztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhdGhBY2Nlc3Nvcihjb21wb25lbnRzKSB7XG4gIHJldHVybiAoZGF0dW0pID0+IHtcbiAgICBsZXQgY3VycmVudCA9IGRhdHVtO1xuICAgIGZvciAoY29uc3QgY29tcG9uZW50IG9mIGNvbXBvbmVudHMpIHtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50W2NvbXBvbmVudF07XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50O1xuICB9O1xufVxudmFyIERhdGFNb2RlbCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0cywgbW9kZSA9IFwic3RhbmRhbG9uZVwiKSB7XG4gICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJkYXRhLW1vZGVsXCIpO1xuICAgIHRoaXMuc2NvcGVDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5rZXlzID0gW107XG4gICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICB0aGlzLmFnZ3JlZ2F0ZXMgPSBbXTtcbiAgICB0aGlzLmdyb3VwUHJvY2Vzc29ycyA9IFtdO1xuICAgIHRoaXMucHJvcGVydHlQcm9jZXNzb3JzID0gW107XG4gICAgdGhpcy5yZWR1Y2VycyA9IFtdO1xuICAgIHRoaXMucHJvY2Vzc29ycyA9IFtdO1xuICAgIGxldCBrZXlzID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IG5leHQgb2Ygb3B0cy5wcm9wcykge1xuICAgICAgaWYgKG5leHQudHlwZSA9PT0gXCJrZXlcIiAmJiAha2V5cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSBpbnRlcm5hbCBjb25maWcgZXJyb3I6IGtleXMgbXVzdCBjb21lIGJlZm9yZSB2YWx1ZXMuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKG5leHQudHlwZSA9PT0gXCJ2YWx1ZVwiICYmIGtleXMpIHtcbiAgICAgICAga2V5cyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2ZXJpZnlNYXRjaEdyb3VwSWQgPSAoeyBtYXRjaEdyb3VwSWRzID0gW10gfSkgPT4ge1xuICAgICAgZm9yIChjb25zdCBtYXRjaEdyb3VwSWQgb2YgbWF0Y2hHcm91cElkcykge1xuICAgICAgICBpZiAodGhpcy52YWx1ZXMuZXZlcnkoKGRlZikgPT4gZGVmLmdyb3VwSWQgIT09IG1hdGNoR3JvdXBJZCkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQUcgQ2hhcnRzIC0gaW50ZXJuYWwgY29uZmlnIGVycm9yOiBtYXRjaEdyb3VwSWRzIHByb3BlcnRpZXMgbXVzdCBtYXRjaCBkZWZpbmVkIGdyb3VwcyAoJHttYXRjaEdyb3VwSWR9KS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgZm9yIChjb25zdCBkZWYgb2Ygb3B0cy5wcm9wcykge1xuICAgICAgc3dpdGNoIChkZWYudHlwZSkge1xuICAgICAgICBjYXNlIFwia2V5XCI6XG4gICAgICAgICAgdGhpcy5rZXlzLnB1c2goeyAuLi5kZWYsIGluZGV4OiB0aGlzLmtleXMubGVuZ3RoLCBtaXNzaW5nOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgICBpZiAoZGVmLnByb3BlcnR5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYEFHIENoYXJ0cyAtIGludGVybmFsIGNvbmZpZyBlcnJvcjogbm8gcHJvcGVydGllcyBzcGVjaWZpZWQgZm9yIHZhbHVlIGRlZmluaXRpb25zOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgIGRlZlxuICAgICAgICAgICAgICApfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudmFsdWVzLnB1c2goeyAuLi5kZWYsIGluZGV4OiB0aGlzLnZhbHVlcy5sZW5ndGgsIG1pc3Npbmc6IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhZ2dyZWdhdGVcIjpcbiAgICAgICAgICB2ZXJpZnlNYXRjaEdyb3VwSWQoZGVmKTtcbiAgICAgICAgICB0aGlzLmFnZ3JlZ2F0ZXMucHVzaCh7IC4uLmRlZiwgaW5kZXg6IHRoaXMuYWdncmVnYXRlcy5sZW5ndGggfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJncm91cC12YWx1ZS1wcm9jZXNzb3JcIjpcbiAgICAgICAgICB2ZXJpZnlNYXRjaEdyb3VwSWQoZGVmKTtcbiAgICAgICAgICB0aGlzLmdyb3VwUHJvY2Vzc29ycy5wdXNoKHsgLi4uZGVmLCBpbmRleDogdGhpcy5ncm91cFByb2Nlc3NvcnMubGVuZ3RoIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwicHJvcGVydHktdmFsdWUtcHJvY2Vzc29yXCI6XG4gICAgICAgICAgdGhpcy5wcm9wZXJ0eVByb2Nlc3NvcnMucHVzaCh7IC4uLmRlZiwgaW5kZXg6IHRoaXMucHJvcGVydHlQcm9jZXNzb3JzLmxlbmd0aCB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlZHVjZXJcIjpcbiAgICAgICAgICB0aGlzLnJlZHVjZXJzLnB1c2goeyAuLi5kZWYsIGluZGV4OiB0aGlzLnJlZHVjZXJzLmxlbmd0aCB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInByb2Nlc3NvclwiOlxuICAgICAgICAgIHRoaXMucHJvY2Vzc29ycy5wdXNoKHsgLi4uZGVmLCBpbmRleDogdGhpcy5wcm9jZXNzb3JzLmxlbmd0aCB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZCeUlkKHNjb3BlLCBzZWFyY2hJZCkge1xuICAgIGNvbnN0IGRlZiA9IHRoaXMuc2NvcGVDYWNoZS5nZXQoc2NvcGUuaWQpPy5nZXQoc2VhcmNoSWQpO1xuICAgIGlmICghZGVmKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIGRpZG4ndCBmaW5kIHByb3BlcnR5IGRlZmluaXRpb24gZm9yIFske3NlYXJjaElkfSwgJHtzY29wZS5pZH1dYCk7XG4gICAgfVxuICAgIHJldHVybiB7IGluZGV4OiBkZWYuaW5kZXgsIGRlZiB9O1xuICB9XG4gIHJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHNjb3BlLCBzZWFyY2hJZCkge1xuICAgIHJldHVybiB0aGlzLnJlc29sdmVQcm9jZXNzZWREYXRhRGVmQnlJZChzY29wZSwgc2VhcmNoSWQpLmluZGV4O1xuICB9XG4gIHJlc29sdmVQcm9jZXNzZWREYXRhRGVmc0J5SWRzKHNjb3BlLCBzZWFyY2hJZHMpIHtcbiAgICByZXR1cm4gc2VhcmNoSWRzLm1hcCgoc2VhcmNoSWQpID0+IFtzZWFyY2hJZCwgdGhpcy5yZXNvbHZlUHJvY2Vzc2VkRGF0YURlZkJ5SWQoc2NvcGUsIHNlYXJjaElkKV0pO1xuICB9XG4gIHJlc29sdmVQcm9jZXNzZWREYXRhRGVmc1ZhbHVlcyhkZWZzLCB7IGtleXMsIHZhbHVlcyB9KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBbc2VhcmNoSWQsIHsgaW5kZXgsIGRlZiB9XSBvZiBkZWZzKSB7XG4gICAgICBjb25zdCBwcm9jZXNzZWREYXRhID0gZGVmLnR5cGUgPT09IFwia2V5XCIgPyBrZXlzIDogdmFsdWVzO1xuICAgICAgcmVzdWx0W3NlYXJjaElkXSA9IHByb2Nlc3NlZERhdGFbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGdldERvbWFpbihzY29wZSwgc2VhcmNoSWQsIHR5cGUgPSBcInZhbHVlXCIsIHByb2Nlc3NlZERhdGEpIHtcbiAgICBjb25zdCBkb21haW5zID0gdGhpcy5nZXREb21haW5zQnlUeXBlKHR5cGUsIHByb2Nlc3NlZERhdGEpO1xuICAgIHJldHVybiBkb21haW5zPy5bdGhpcy5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZChzY29wZSwgc2VhcmNoSWQpXSA/PyBbXTtcbiAgfVxuICBnZXREb21haW5zQnlUeXBlKHR5cGUsIHByb2Nlc3NlZERhdGEpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgXCJrZXlcIjpcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZERhdGEuZG9tYWluLmtleXM7XG4gICAgICBjYXNlIFwidmFsdWVcIjpcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZERhdGEuZG9tYWluLnZhbHVlcztcbiAgICAgIGNhc2UgXCJhZ2dyZWdhdGVcIjpcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZERhdGEuZG9tYWluLmFnZ1ZhbHVlcztcbiAgICAgIGNhc2UgXCJncm91cC12YWx1ZS1wcm9jZXNzb3JcIjpcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZERhdGEuZG9tYWluLmdyb3VwcztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBwcm9jZXNzRGF0YShkYXRhLCBzb3VyY2VzKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3B0czogeyBncm91cEJ5S2V5cywgZ3JvdXBCeUZuIH0sXG4gICAgICBhZ2dyZWdhdGVzLFxuICAgICAgZ3JvdXBQcm9jZXNzb3JzLFxuICAgICAgcmVkdWNlcnMsXG4gICAgICBwcm9jZXNzb3JzLFxuICAgICAgcHJvcGVydHlQcm9jZXNzb3JzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAoZ3JvdXBCeUtleXMgJiYgdGhpcy5rZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcHJvY2Vzc2VkRGF0YSA9IHRoaXMuZXh0cmFjdERhdGEoZGF0YSwgc291cmNlcyk7XG4gICAgaWYgKGdyb3VwQnlLZXlzKSB7XG4gICAgICBwcm9jZXNzZWREYXRhID0gdGhpcy5ncm91cERhdGEocHJvY2Vzc2VkRGF0YSk7XG4gICAgfSBlbHNlIGlmIChncm91cEJ5Rm4pIHtcbiAgICAgIHByb2Nlc3NlZERhdGEgPSB0aGlzLmdyb3VwRGF0YShwcm9jZXNzZWREYXRhLCBncm91cEJ5Rm4ocHJvY2Vzc2VkRGF0YSkpO1xuICAgIH1cbiAgICBpZiAoZ3JvdXBQcm9jZXNzb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucG9zdFByb2Nlc3NHcm91cHMocHJvY2Vzc2VkRGF0YSk7XG4gICAgfVxuICAgIGlmIChhZ2dyZWdhdGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuYWdncmVnYXRlRGF0YShwcm9jZXNzZWREYXRhKTtcbiAgICB9XG4gICAgaWYgKHByb3BlcnR5UHJvY2Vzc29ycy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnBvc3RQcm9jZXNzUHJvcGVydGllcyhwcm9jZXNzZWREYXRhKTtcbiAgICB9XG4gICAgaWYgKHJlZHVjZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMucmVkdWNlRGF0YShwcm9jZXNzZWREYXRhKTtcbiAgICB9XG4gICAgaWYgKHByb2Nlc3NvcnMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5wb3N0UHJvY2Vzc0RhdGEocHJvY2Vzc2VkRGF0YSk7XG4gICAgfVxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAoY29uc3QgZGVmIG9mIGl0ZXJhdGUodGhpcy5rZXlzLCB0aGlzLnZhbHVlcykpIHtcbiAgICAgICAgZm9yIChjb25zdCBbc2NvcGUsIG1pc3NDb3VudF0gb2YgZGVmLm1pc3NpbmcpIHtcbiAgICAgICAgICBpZiAobWlzc0NvdW50ID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBzY29wZUhpbnQgPSBzY29wZSA9PSBudWxsID8gXCJcIiA6IGAgZm9yICR7c2NvcGV9YDtcbiAgICAgICAgICAgIExvZ2dlci53YXJuT25jZShgdGhlIGtleSAnJHtkZWYucHJvcGVydHl9JyB3YXMgbm90IGZvdW5kIGluIGFueSBkYXRhIGVsZW1lbnQke3Njb3BlSGludH0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHByb2Nlc3NlZERhdGEudGltZSA9IGVuZCAtIHN0YXJ0O1xuICAgIGlmICh0aGlzLmRlYnVnLmNoZWNrKCkpIHtcbiAgICAgIGxvZ1Byb2Nlc3NlZERhdGEocHJvY2Vzc2VkRGF0YSk7XG4gICAgfVxuICAgIHRoaXMuc2NvcGVDYWNoZS5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgZGVmIG9mIGl0ZXJhdGUodGhpcy5rZXlzLCB0aGlzLnZhbHVlcywgdGhpcy5hZ2dyZWdhdGVzKSkge1xuICAgICAgaWYgKCFkZWYuaWRzTWFwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGZvciAoY29uc3QgW3Njb3BlLCBpZHNdIG9mIGRlZi5pZHNNYXApIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBpZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuc2NvcGVDYWNoZS5oYXMoc2NvcGUpKSB7XG4gICAgICAgICAgICB0aGlzLnNjb3BlQ2FjaGUuc2V0KHNjb3BlLCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbW2lkLCBkZWZdXSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zY29wZUNhY2hlLmdldChzY29wZSk/LmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImR1cGxpY2F0ZSBkZWZpbml0aW9uIGlkcyBvbiB0aGUgc2FtZSBzY29wZSBhcmUgbm90IGFsbG93ZWQuXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNjb3BlQ2FjaGUuZ2V0KHNjb3BlKS5zZXQoaWQsIGRlZik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzZWREYXRhO1xuICB9XG4gIHZhbHVlR3JvdXBJZHhMb29rdXAoeyBtYXRjaEdyb3VwSWRzIH0pIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgZGVmXSBvZiB0aGlzLnZhbHVlcy5lbnRyaWVzKCkpIHtcbiAgICAgIGlmICghbWF0Y2hHcm91cElkcyB8fCBkZWYuZ3JvdXBJZCAmJiBtYXRjaEdyb3VwSWRzLmluY2x1ZGVzKGRlZi5ncm91cElkKSkge1xuICAgICAgICByZXN1bHQucHVzaChpbmRleCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdmFsdWVJZHhMb29rdXAoc2NvcGVzLCBwcm9wKSB7XG4gICAgY29uc3Qgbm9TY29wZXNUb01hdGNoID0gc2NvcGVzID09IG51bGwgfHwgc2NvcGVzLmxlbmd0aCA9PT0gMDtcbiAgICBjb25zdCBwcm9wSWQgPSB0eXBlb2YgcHJvcCA9PT0gXCJzdHJpbmdcIiA/IHByb3AgOiBwcm9wLmlkO1xuICAgIGNvbnN0IGhhc01hdGNoaW5nU2NvcGVJZCA9IChkZWYpID0+IHtcbiAgICAgIGlmIChkZWYuaWRzTWFwKSB7XG4gICAgICAgIGZvciAoY29uc3QgW3Njb3BlLCBpZHNdIG9mIGRlZi5pZHNNYXApIHtcbiAgICAgICAgICBpZiAoc2NvcGVzPy5pbmNsdWRlcyhzY29wZSkgJiYgaWRzLmhhcyhwcm9wSWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudmFsdWVzLmZpbmRJbmRleCgoZGVmKSA9PiB7XG4gICAgICBjb25zdCB2YWxpZERlZlNjb3BlcyA9IGRlZi5zY29wZXMgPT0gbnVsbCB8fCBub1Njb3Blc1RvTWF0Y2ggJiYgIWRlZi5zY29wZXMubGVuZ3RoIHx8IGRlZi5zY29wZXMuc29tZSgocykgPT4gc2NvcGVzPy5pbmNsdWRlcyhzKSk7XG4gICAgICByZXR1cm4gdmFsaWREZWZTY29wZXMgJiYgKGRlZi5wcm9wZXJ0eSA9PT0gcHJvcElkIHx8IGRlZi5pZCA9PT0gcHJvcElkIHx8IGhhc01hdGNoaW5nU2NvcGVJZChkZWYpKTtcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQUcgQ2hhcnRzIC0gY29uZmlndXJhdGlvbiBlcnJvciwgdW5rbm93biBwcm9wZXJ0eSAke0pTT04uc3RyaW5naWZ5KHByb3ApfSBpbiBzY29wZShzKSAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgIHNjb3Blc1xuICAgICAgICApfWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZXh0cmFjdERhdGEoZGF0YSwgc291cmNlcykge1xuICAgIGNvbnN0IHsgZGF0YURvbWFpbiwgcHJvY2Vzc1ZhbHVlLCBzY29wZXMsIGFsbFNjb3Blc0hhdmVTYW1lRGVmcyB9ID0gdGhpcy5pbml0RGF0YURvbWFpblByb2Nlc3NvcigpO1xuICAgIGNvbnN0IHNvdXJjZXNCeUlkID0gbmV3IE1hcChzb3VyY2VzPy5tYXAoKHMpID0+IFtzLmlkLCBzXSkpO1xuICAgIGNvbnN0IHsga2V5czoga2V5RGVmcywgdmFsdWVzOiB2YWx1ZURlZnMgfSA9IHRoaXM7XG4gICAgY29uc3QgcmVzdWx0RGF0YSA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgbGV0IHJlc3VsdERhdGFJZHggPSAwO1xuICAgIGxldCBwYXJ0aWFsVmFsaWREYXRhQ291bnQgPSAwO1xuICAgIGZvciAoY29uc3QgW2RhdHVtSWR4LCBkYXR1bV0gb2YgZGF0YS5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZURhdHVtcyA9IHt9O1xuICAgICAgY29uc3QgdmFsaWRTY29wZXMgPSBzY29wZXMuc2l6ZSA+IDAgPyBuZXcgU2V0KHNjb3BlcykgOiB2b2lkIDA7XG4gICAgICBjb25zdCBrZXlzID0gbmV3IEFycmF5KGtleURlZnMubGVuZ3RoKTtcbiAgICAgIGxldCBrZXlJZHggPSAwO1xuICAgICAgbGV0IGtleTtcbiAgICAgIGZvciAoY29uc3QgZGVmIG9mIGtleURlZnMpIHtcbiAgICAgICAga2V5ID0gcHJvY2Vzc1ZhbHVlKGRlZiwgZGF0dW0sIGtleSk7XG4gICAgICAgIGlmIChrZXkgPT09IElOVkFMSURfVkFMVUUpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChrZXlzKSB7XG4gICAgICAgICAga2V5c1trZXlJZHgrK10gPSBrZXk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09IElOVkFMSURfVkFMVUUpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgdmFsdWVzID0gdmFsdWVEZWZzLmxlbmd0aCA+IDAgPyBuZXcgQXJyYXkodmFsdWVEZWZzLmxlbmd0aCkgOiB2b2lkIDA7XG4gICAgICBsZXQgdmFsdWU7XG4gICAgICBmb3IgKGNvbnN0IFt2YWx1ZURlZklkeCwgZGVmXSBvZiB2YWx1ZURlZnMuZW50cmllcygpKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NvcGUgb2YgZGVmLnNjb3BlcyA/PyBzY29wZXMpIHtcbiAgICAgICAgICBjb25zdCBzb3VyY2UgPSBzb3VyY2VzQnlJZC5nZXQoc2NvcGUpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlRGF0dW0gPSBzb3VyY2U/LmRhdGFbZGF0dW1JZHhdID8/IGRhdHVtO1xuICAgICAgICAgIHZhbHVlID0gcHJvY2Vzc1ZhbHVlKGRlZiwgdmFsdWVEYXR1bSwgdmFsdWUsIHNjb3BlKTtcbiAgICAgICAgICBpZiAodmFsdWUgPT09IElOVkFMSURfVkFMVUUgfHwgIXZhbHVlcylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBkZWYuaW5jbHVkZVByb3BlcnR5ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBkZWYuaW5jbHVkZVByb3BlcnR5ICYmIGRlZi5pZCAhPSBudWxsID8gZGVmLmlkIDogZGVmLnByb3BlcnR5O1xuICAgICAgICAgICAgc291cmNlRGF0dW1zW3Njb3BlXSA/PyAoc291cmNlRGF0dW1zW3Njb3BlXSA9IHt9KTtcbiAgICAgICAgICAgIHNvdXJjZURhdHVtc1tzY29wZV1bcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlc1t2YWx1ZURlZklkeF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09IElOVkFMSURfVkFMVUUpIHtcbiAgICAgICAgICBpZiAoYWxsU2NvcGVzSGF2ZVNhbWVEZWZzKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZm9yIChjb25zdCBzY29wZSBvZiBkZWYuc2NvcGVzID8/IHNjb3Blcykge1xuICAgICAgICAgICAgdmFsaWRTY29wZXM/LmRlbGV0ZShzY29wZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWxpZFNjb3Blcz8uc2l6ZSA9PT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT09IElOVkFMSURfVkFMVUUgJiYgYWxsU2NvcGVzSGF2ZVNhbWVEZWZzKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmICh2YWxpZFNjb3Blcz8uc2l6ZSA9PT0gMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCByZXN1bHQgPSB7IGRhdHVtOiB7IC4uLmRhdHVtLCAuLi5zb3VyY2VEYXR1bXMgfSwga2V5cywgdmFsdWVzIH07XG4gICAgICBpZiAoIWFsbFNjb3Blc0hhdmVTYW1lRGVmcyAmJiB2YWxpZFNjb3BlcyAmJiB2YWxpZFNjb3Blcy5zaXplIDwgc2NvcGVzLnNpemUpIHtcbiAgICAgICAgcGFydGlhbFZhbGlkRGF0YUNvdW50Kys7XG4gICAgICAgIHJlc3VsdC52YWxpZFNjb3BlcyA9IG5ldyBTZXQodmFsaWRTY29wZXMpO1xuICAgICAgfVxuICAgICAgcmVzdWx0RGF0YVtyZXN1bHREYXRhSWR4KytdID0gcmVzdWx0O1xuICAgIH1cbiAgICByZXN1bHREYXRhLmxlbmd0aCA9IHJlc3VsdERhdGFJZHg7XG4gICAgY29uc3QgcHJvcGVydHlEb21haW4gPSAoZGVmKSA9PiB7XG4gICAgICBjb25zdCBkZWZEb21haW4gPSBkYXRhRG9tYWluLmdldChkZWYpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gZGVmRG9tYWluLmdldERvbWFpbigpO1xuICAgICAgaWYgKENvbnRpbnVvdXNEb21haW4uaXMoZGVmRG9tYWluKSAmJiByZXN1bHRbMF0gPiByZXN1bHRbMV0pIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInVuZ3JvdXBlZFwiLFxuICAgICAgaW5wdXQ6IHsgY291bnQ6IGRhdGEubGVuZ3RoIH0sXG4gICAgICBkYXRhOiByZXN1bHREYXRhLFxuICAgICAgZG9tYWluOiB7XG4gICAgICAgIGtleXM6IGtleURlZnMubWFwKHByb3BlcnR5RG9tYWluKSxcbiAgICAgICAgdmFsdWVzOiB2YWx1ZURlZnMubWFwKHByb3BlcnR5RG9tYWluKVxuICAgICAgfSxcbiAgICAgIGRlZnM6IHtcbiAgICAgICAgYWxsU2NvcGVzSGF2ZVNhbWVEZWZzLFxuICAgICAgICBrZXlzOiBrZXlEZWZzLFxuICAgICAgICB2YWx1ZXM6IHZhbHVlRGVmc1xuICAgICAgfSxcbiAgICAgIHBhcnRpYWxWYWxpZERhdGFDb3VudCxcbiAgICAgIHRpbWU6IDBcbiAgICB9O1xuICB9XG4gIGdyb3VwRGF0YShkYXRhLCBncm91cGluZ0ZuKSB7XG4gICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBkYXRhRW50cnkgb2YgZGF0YS5kYXRhKSB7XG4gICAgICBjb25zdCB7IGtleXMsIHZhbHVlcywgZGF0dW0sIHZhbGlkU2NvcGVzIH0gPSBkYXRhRW50cnk7XG4gICAgICBjb25zdCBncm91cCA9IGdyb3VwaW5nRm4/LihkYXRhRW50cnkpID8/IGtleXM7XG4gICAgICBjb25zdCBncm91cFN0ciA9IHRvS2V5U3RyaW5nKGdyb3VwKTtcbiAgICAgIGlmIChwcm9jZXNzZWREYXRhLmhhcyhncm91cFN0cikpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdEYXRhID0gcHJvY2Vzc2VkRGF0YS5nZXQoZ3JvdXBTdHIpO1xuICAgICAgICBleGlzdGluZ0RhdGEudmFsdWVzLnB1c2godmFsdWVzKTtcbiAgICAgICAgZXhpc3RpbmdEYXRhLmRhdHVtLnB1c2goZGF0dW0pO1xuICAgICAgICBpZiAodmFsaWRTY29wZXMgIT0gbnVsbCAmJiBleGlzdGluZ0RhdGEudmFsaWRTY29wZXMgIT0gbnVsbCkge1xuICAgICAgICAgIGZvciAoY29uc3Qgc2NvcGUgb2YgZXhpc3RpbmdEYXRhLnZhbGlkU2NvcGVzKSB7XG4gICAgICAgICAgICBpZiAoIXZhbGlkU2NvcGVzLmhhcyhzY29wZSkpIHtcbiAgICAgICAgICAgICAgZXhpc3RpbmdEYXRhLnZhbGlkU2NvcGVzLmRlbGV0ZShzY29wZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzZWREYXRhLnNldChncm91cFN0ciwge1xuICAgICAgICAgIGtleXM6IGdyb3VwLFxuICAgICAgICAgIHZhbHVlczogW3ZhbHVlc10sXG4gICAgICAgICAgZGF0dW06IFtkYXR1bV0sXG4gICAgICAgICAgdmFsaWRTY29wZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdERhdGEgPSBuZXcgQXJyYXkocHJvY2Vzc2VkRGF0YS5zaXplKTtcbiAgICBjb25zdCByZXN1bHRHcm91cHMgPSBuZXcgQXJyYXkocHJvY2Vzc2VkRGF0YS5zaXplKTtcbiAgICBsZXQgZGF0YUluZGV4ID0gMDtcbiAgICBmb3IgKGNvbnN0IHsga2V5cywgdmFsdWVzLCBkYXR1bSwgdmFsaWRTY29wZXMgfSBvZiBwcm9jZXNzZWREYXRhLnZhbHVlcygpKSB7XG4gICAgICBpZiAodmFsaWRTY29wZXM/LnNpemUgPT09IDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgcmVzdWx0R3JvdXBzW2RhdGFJbmRleF0gPSBrZXlzO1xuICAgICAgcmVzdWx0RGF0YVtkYXRhSW5kZXgrK10gPSB7XG4gICAgICAgIGtleXMsXG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHZhbGlkU2NvcGVzXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGF0YSxcbiAgICAgIHR5cGU6IFwiZ3JvdXBlZFwiLFxuICAgICAgZGF0YTogcmVzdWx0RGF0YSxcbiAgICAgIGRvbWFpbjoge1xuICAgICAgICAuLi5kYXRhLmRvbWFpbixcbiAgICAgICAgZ3JvdXBzOiByZXN1bHRHcm91cHNcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGFnZ3JlZ2F0ZURhdGEocHJvY2Vzc2VkRGF0YSkge1xuICAgIGNvbnN0IGlzVW5ncm91cGVkID0gcHJvY2Vzc2VkRGF0YS50eXBlID09PSBcInVuZ3JvdXBlZFwiO1xuICAgIHByb2Nlc3NlZERhdGEuZG9tYWluLmFnZ1ZhbHVlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2luZGV4LCBkZWZdIG9mIHRoaXMuYWdncmVnYXRlcy5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IGluZGljZXMgPSB0aGlzLnZhbHVlR3JvdXBJZHhMb29rdXAoZGVmKTtcbiAgICAgIGNvbnN0IGRvbWFpbiA9IFtJbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICAgIGZvciAoY29uc3QgZGF0dW0gb2YgcHJvY2Vzc2VkRGF0YS5kYXRhKSB7XG4gICAgICAgIGRhdHVtLmFnZ1ZhbHVlcyA/PyAoZGF0dW0uYWdnVmFsdWVzID0gbmV3IEFycmF5KHRoaXMuYWdncmVnYXRlcy5sZW5ndGgpKTtcbiAgICAgICAgaWYgKGRhdHVtLnZhbGlkU2NvcGVzKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBpc1VuZ3JvdXBlZCA/IFtkYXR1bS52YWx1ZXNdIDogZGF0dW0udmFsdWVzO1xuICAgICAgICBsZXQgZ3JvdXBBZ2dWYWx1ZXMgPSBkZWYuZ3JvdXBBZ2dyZWdhdGVGdW5jdGlvbj8uKCkgPz8gW0luZmluaXR5LCAtSW5maW5pdHldO1xuICAgICAgICBmb3IgKGNvbnN0IGRpc3RpbmN0VmFsdWVzIG9mIHZhbHVlcykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlc1RvQWdnID0gaW5kaWNlcy5tYXAoKHZhbHVlSWR4KSA9PiBkaXN0aW5jdFZhbHVlc1t2YWx1ZUlkeF0pO1xuICAgICAgICAgIGNvbnN0IHZhbHVlc0FnZyA9IGRlZi5hZ2dyZWdhdGVGdW5jdGlvbih2YWx1ZXNUb0FnZywgZGF0dW0ua2V5cyk7XG4gICAgICAgICAgaWYgKHZhbHVlc0FnZykge1xuICAgICAgICAgICAgZ3JvdXBBZ2dWYWx1ZXMgPSBkZWYuZ3JvdXBBZ2dyZWdhdGVGdW5jdGlvbj8uKHZhbHVlc0FnZywgZ3JvdXBBZ2dWYWx1ZXMpID8/IENvbnRpbnVvdXNEb21haW4uZXh0ZW5kRG9tYWluKHZhbHVlc0FnZywgZ3JvdXBBZ2dWYWx1ZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaW5hbFZhbHVlcyA9IChkZWYuZmluYWxGdW5jdGlvbj8uKGdyb3VwQWdnVmFsdWVzKSA/PyBncm91cEFnZ1ZhbHVlcykubWFwKCh2KSA9PiByb3VuZDIodikpO1xuICAgICAgICBkYXR1bS5hZ2dWYWx1ZXNbaW5kZXhdID0gZmluYWxWYWx1ZXM7XG4gICAgICAgIENvbnRpbnVvdXNEb21haW4uZXh0ZW5kRG9tYWluKGZpbmFsVmFsdWVzLCBkb21haW4pO1xuICAgICAgfVxuICAgICAgcHJvY2Vzc2VkRGF0YS5kb21haW4uYWdnVmFsdWVzLnB1c2goZG9tYWluKTtcbiAgICB9XG4gIH1cbiAgcG9zdFByb2Nlc3NHcm91cHMocHJvY2Vzc2VkRGF0YSkge1xuICAgIGNvbnN0IHsgZ3JvdXBQcm9jZXNzb3JzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGFmZmVjdGVkSW5kaWNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgY29uc3QgdXBkYXRlZERvbWFpbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGdyb3VwUHJvY2Vzc29ySW5kaWNlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgZ3JvdXBQcm9jZXNzb3JJbml0Rm5zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IHByb2Nlc3NvciBvZiBncm91cFByb2Nlc3NvcnMpIHtcbiAgICAgIGNvbnN0IGluZGljZXMgPSB0aGlzLnZhbHVlR3JvdXBJZHhMb29rdXAocHJvY2Vzc29yKTtcbiAgICAgIGdyb3VwUHJvY2Vzc29ySW5kaWNlcy5zZXQocHJvY2Vzc29yLCBpbmRpY2VzKTtcbiAgICAgIGdyb3VwUHJvY2Vzc29ySW5pdEZucy5zZXQocHJvY2Vzc29yLCBwcm9jZXNzb3IuYWRqdXN0KCkpO1xuICAgICAgZm9yIChjb25zdCBpZHggb2YgaW5kaWNlcykge1xuICAgICAgICBjb25zdCB2YWx1ZURlZiA9IHRoaXMudmFsdWVzW2lkeF07XG4gICAgICAgIGNvbnN0IGlzRGlzY3JldGUgPSB2YWx1ZURlZi52YWx1ZVR5cGUgPT09IFwiY2F0ZWdvcnlcIjtcbiAgICAgICAgYWZmZWN0ZWRJbmRpY2VzLmFkZChpZHgpO1xuICAgICAgICB1cGRhdGVkRG9tYWlucy5zZXQoaWR4LCBpc0Rpc2NyZXRlID8gbmV3IERpc2NyZXRlRG9tYWluKCkgOiBuZXcgQ29udGludW91c0RvbWFpbigpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXBkYXRlRG9tYWlucyA9ICh2YWx1ZXMpID0+IHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWVJbmRleCBvZiBhZmZlY3RlZEluZGljZXMpIHtcbiAgICAgICAgdXBkYXRlZERvbWFpbnMuZ2V0KHZhbHVlSW5kZXgpPy5leHRlbmQodmFsdWVzW3ZhbHVlSW5kZXhdKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgcHJvY2Vzc2VkRGF0YS5kYXRhKSB7XG4gICAgICBmb3IgKGNvbnN0IHByb2Nlc3NvciBvZiBncm91cFByb2Nlc3NvcnMpIHtcbiAgICAgICAgaWYgKGdyb3VwLnZhbGlkU2NvcGVzKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCB2YWx1ZUluZGV4ZXMgPSBncm91cFByb2Nlc3NvckluZGljZXMuZ2V0KHByb2Nlc3NvcikgPz8gW107XG4gICAgICAgIGNvbnN0IGFkanVzdEZuID0gZ3JvdXBQcm9jZXNzb3JJbml0Rm5zLmdldChwcm9jZXNzb3IpPy4oKTtcbiAgICAgICAgaWYgKCFhZGp1c3RGbilcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHByb2Nlc3NlZERhdGEudHlwZSA9PT0gXCJncm91cGVkXCIpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlcyBvZiBncm91cC52YWx1ZXMpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgYWRqdXN0Rm4odmFsdWVzLCB2YWx1ZUluZGV4ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChncm91cC52YWx1ZXMpIHtcbiAgICAgICAgICBhZGp1c3RGbihncm91cC52YWx1ZXMsIHZhbHVlSW5kZXhlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzZWREYXRhLnR5cGUgPT09IFwiZ3JvdXBlZFwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWVzIG9mIGdyb3VwLnZhbHVlcykge1xuICAgICAgICAgIHVwZGF0ZURvbWFpbnModmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlRG9tYWlucyhncm91cC52YWx1ZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtpZHgsIGRhdGFEb21haW5dIG9mIHVwZGF0ZWREb21haW5zKSB7XG4gICAgICBwcm9jZXNzZWREYXRhLmRvbWFpbi52YWx1ZXNbaWR4XSA9IGRhdGFEb21haW4uZ2V0RG9tYWluKCk7XG4gICAgfVxuICB9XG4gIHBvc3RQcm9jZXNzUHJvcGVydGllcyhwcm9jZXNzZWREYXRhKSB7XG4gICAgZm9yIChjb25zdCB7IGFkanVzdCwgcHJvcGVydHksIHNjb3BlcyB9IG9mIHRoaXMucHJvcGVydHlQcm9jZXNzb3JzKSB7XG4gICAgICBhZGp1c3QoKShwcm9jZXNzZWREYXRhLCB0aGlzLnZhbHVlSWR4TG9va3VwKHNjb3BlcywgcHJvcGVydHkpKTtcbiAgICB9XG4gIH1cbiAgcmVkdWNlRGF0YShwcm9jZXNzZWREYXRhKSB7XG4gICAgcHJvY2Vzc2VkRGF0YS5yZWR1Y2VkID8/IChwcm9jZXNzZWREYXRhLnJlZHVjZWQgPSB7fSk7XG4gICAgZm9yIChjb25zdCBkZWYgb2YgdGhpcy5yZWR1Y2Vycykge1xuICAgICAgY29uc3QgcmVkdWNlciA9IGRlZi5yZWR1Y2VyKCk7XG4gICAgICBsZXQgYWNjVmFsdWUgPSBkZWYuaW5pdGlhbFZhbHVlO1xuICAgICAgZm9yIChjb25zdCBkYXR1bSBvZiBwcm9jZXNzZWREYXRhLmRhdGEpIHtcbiAgICAgICAgaWYgKCFkYXR1bS52YWxpZFNjb3BlcyB8fCBkZWYuc2NvcGVzPy5zb21lKChzKSA9PiBkYXR1bS52YWxpZFNjb3Blcz8uaGFzKHMpKSkge1xuICAgICAgICAgIGFjY1ZhbHVlID0gcmVkdWNlcihhY2NWYWx1ZSwgZGF0dW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcm9jZXNzZWREYXRhLnJlZHVjZWRbZGVmLnByb3BlcnR5XSA9IGFjY1ZhbHVlO1xuICAgIH1cbiAgfVxuICBwb3N0UHJvY2Vzc0RhdGEocHJvY2Vzc2VkRGF0YSkge1xuICAgIHByb2Nlc3NlZERhdGEucmVkdWNlZCA/PyAocHJvY2Vzc2VkRGF0YS5yZWR1Y2VkID0ge30pO1xuICAgIGZvciAoY29uc3QgZGVmIG9mIHRoaXMucHJvY2Vzc29ycykge1xuICAgICAgcHJvY2Vzc2VkRGF0YS5yZWR1Y2VkW2RlZi5wcm9wZXJ0eV0gPSBkZWYuY2FsY3VsYXRlKHByb2Nlc3NlZERhdGEpO1xuICAgIH1cbiAgfVxuICBpbml0RGF0YURvbWFpblByb2Nlc3NvcigpIHtcbiAgICBjb25zdCB7IGtleXM6IGtleURlZnMsIHZhbHVlczogdmFsdWVEZWZzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNjb3BlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCB2YWx1ZURlZiBvZiB2YWx1ZURlZnMpIHtcbiAgICAgIGlmICghdmFsdWVEZWYuc2NvcGVzKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGZvciAoY29uc3Qgc2NvcGUgb2YgdmFsdWVEZWYuc2NvcGVzKSB7XG4gICAgICAgIHNjb3Blcy5hZGQoc2NvcGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkYXRhRG9tYWluID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBwcm9jZXNzb3JGbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGxldCBhbGxTY29wZXNIYXZlU2FtZURlZnMgPSB0cnVlO1xuICAgIGNvbnN0IGluaXREYXRhRG9tYWluID0gKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBkZWYgb2YgaXRlcmF0ZShrZXlEZWZzLCB2YWx1ZURlZnMpKSB7XG4gICAgICAgIGlmIChkZWYudmFsdWVUeXBlID09PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgICAgICBkYXRhRG9tYWluLnNldChkZWYsIG5ldyBEaXNjcmV0ZURvbWFpbigpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhRG9tYWluLnNldChkZWYsIG5ldyBDb250aW51b3VzRG9tYWluKCkpO1xuICAgICAgICAgIGFsbFNjb3Blc0hhdmVTYW1lRGVmcyAmJiAoYWxsU2NvcGVzSGF2ZVNhbWVEZWZzID0gKGRlZi5zY29wZXMgPz8gW10pLmxlbmd0aCA9PT0gc2NvcGVzLnNpemUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBpbml0RGF0YURvbWFpbigpO1xuICAgIGNvbnN0IGFjY2Vzc29ycyA9IHRoaXMuYnVpbGRBY2Nlc3NvcnMoaXRlcmF0ZShrZXlEZWZzLCB2YWx1ZURlZnMpKTtcbiAgICBjb25zdCBwcm9jZXNzVmFsdWUgPSAoZGVmLCBkYXR1bSwgcHJldmlvdXNEYXR1bSwgc2NvcGUpID0+IHtcbiAgICAgIGxldCB2YWx1ZUluRGF0dW07XG4gICAgICBsZXQgdmFsdWU7XG4gICAgICBpZiAoYWNjZXNzb3JzLmhhcyhkZWYucHJvcGVydHkpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFsdWUgPSBhY2Nlc3NvcnMuZ2V0KGRlZi5wcm9wZXJ0eSkoZGF0dW0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlSW5EYXR1bSA9IHZhbHVlICE9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZUluRGF0dW0gPSBkZWYucHJvcGVydHkgaW4gZGF0dW07XG4gICAgICAgIHZhbHVlID0gdmFsdWVJbkRhdHVtID8gZGF0dW1bZGVmLnByb3BlcnR5XSA6IGRlZi5taXNzaW5nVmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoZGVmLmZvcmNlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCB2YWx1ZU5lZ2F0aXZlID0gdmFsdWVJbkRhdHVtICYmIGlzTmVnYXRpdmUodmFsdWUpO1xuICAgICAgICB2YWx1ZSA9IHZhbHVlTmVnYXRpdmUgPyAtMSAqIGRlZi5mb3JjZVZhbHVlIDogZGVmLmZvcmNlVmFsdWU7XG4gICAgICAgIHZhbHVlSW5EYXR1bSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBtaXNzaW5nVmFsdWVEZWYgPSBcIm1pc3NpbmdWYWx1ZVwiIGluIGRlZjtcbiAgICAgIGlmICghdmFsdWVJbkRhdHVtICYmICFtaXNzaW5nVmFsdWVEZWYpIHtcbiAgICAgICAgY29uc3QgbWlzc0NvdW50ID0gZGVmLm1pc3NpbmcuZ2V0KHNjb3BlKSA/PyAwO1xuICAgICAgICBkZWYubWlzc2luZy5zZXQoc2NvcGUsIG1pc3NDb3VudCArIDEpO1xuICAgICAgfVxuICAgICAgaWYgKCFkYXRhRG9tYWluLmhhcyhkZWYpKSB7XG4gICAgICAgIGluaXREYXRhRG9tYWluKCk7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWVJbkRhdHVtICYmIGRlZi52YWxpZGF0aW9uPy4odmFsdWUsIGRhdHVtKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKFwiaW52YWxpZFZhbHVlXCIgaW4gZGVmKSB7XG4gICAgICAgICAgdmFsdWUgPSBkZWYuaW52YWxpZFZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLm1vZGUgIT09IFwiaW50ZWdyYXRlZFwiKSB7XG4gICAgICAgICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgICAgICAgIGBpbnZhbGlkIHZhbHVlIG9mIHR5cGUgWyR7dHlwZW9mIHZhbHVlfV0gZm9yIFske2RlZi5zY29wZXN9IC8gJHtkZWYuaWR9XSBpZ25vcmVkOmAsXG4gICAgICAgICAgICAgIGBbJHt2YWx1ZX1dYFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIElOVkFMSURfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkZWYucHJvY2Vzc29yKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc29yRm5zLmhhcyhkZWYpKSB7XG4gICAgICAgICAgcHJvY2Vzc29yRm5zLnNldChkZWYsIGRlZi5wcm9jZXNzb3IoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSBwcm9jZXNzb3JGbnMuZ2V0KGRlZik/Lih2YWx1ZSwgcHJldmlvdXNEYXR1bSA9PT0gSU5WQUxJRF9WQUxVRSA/IHZvaWQgMCA6IHByZXZpb3VzRGF0dW0pO1xuICAgICAgfVxuICAgICAgZGF0YURvbWFpbi5nZXQoZGVmKT8uZXh0ZW5kKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIHJldHVybiB7IGRhdGFEb21haW4sIHByb2Nlc3NWYWx1ZSwgaW5pdERhdGFEb21haW4sIHNjb3BlcywgYWxsU2NvcGVzSGF2ZVNhbWVEZWZzIH07XG4gIH1cbiAgYnVpbGRBY2Nlc3NvcnMoZGVmcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgaWYgKHRoaXMubW9kZSA9PT0gXCJpbnRlZ3JhdGVkXCIpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZGVmIG9mIGRlZnMpIHtcbiAgICAgIGNvbnN0IGlzUGF0aCA9IGRlZi5wcm9wZXJ0eS5pbmNsdWRlcyhcIi5cIikgfHwgZGVmLnByb3BlcnR5LmluY2x1ZGVzKFwiW1wiKTtcbiAgICAgIGlmICghaXNQYXRoKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IGNvbXBvbmVudHMgPSBnZXRQYXRoQ29tcG9uZW50cyhkZWYucHJvcGVydHkpO1xuICAgICAgaWYgKGNvbXBvbmVudHMgPT0gbnVsbCkge1xuICAgICAgICBMb2dnZXIud2Fybk9uY2UoXCJJbnZhbGlkIHByb3BlcnR5IHBhdGggWyVzXVwiLCBkZWYucHJvcGVydHkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjY2Vzc29yID0gY3JlYXRlUGF0aEFjY2Vzc29yKGNvbXBvbmVudHMpO1xuICAgICAgcmVzdWx0LnNldChkZWYucHJvcGVydHksIGFjY2Vzc29yKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcbmZ1bmN0aW9uIGxvZ1Byb2Nlc3NlZERhdGEocHJvY2Vzc2VkRGF0YSkge1xuICBjb25zdCBsb2dWYWx1ZXMgPSAobmFtZSwgZGF0YSkgPT4ge1xuICAgIGlmIChkYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIExvZ2dlci5sb2coYERhdGFNb2RlbC5wcm9jZXNzRGF0YSgpIC0gJHtuYW1lfWApO1xuICAgICAgTG9nZ2VyLnRhYmxlKGRhdGEpO1xuICAgIH1cbiAgfTtcbiAgTG9nZ2VyLmxvZyhcIkRhdGFNb2RlbC5wcm9jZXNzRGF0YSgpIC0gcHJvY2Vzc2VkRGF0YVwiLCBwcm9jZXNzZWREYXRhKTtcbiAgbG9nVmFsdWVzKFwiS2V5IERvbWFpbnNcIiwgcHJvY2Vzc2VkRGF0YS5kb21haW4ua2V5cyk7XG4gIGxvZ1ZhbHVlcyhcIkdyb3VwIERvbWFpbnNcIiwgcHJvY2Vzc2VkRGF0YS5kb21haW4uZ3JvdXBzID8/IFtdKTtcbiAgbG9nVmFsdWVzKFwiVmFsdWUgRG9tYWluc1wiLCBwcm9jZXNzZWREYXRhLmRvbWFpbi52YWx1ZXMpO1xuICBsb2dWYWx1ZXMoXCJBZ2dyZWdhdGUgRG9tYWluc1wiLCBwcm9jZXNzZWREYXRhLmRvbWFpbi5hZ2dWYWx1ZXMgPz8gW10pO1xuICBpZiAocHJvY2Vzc2VkRGF0YS50eXBlID09PSBcImdyb3VwZWRcIikge1xuICAgIGNvbnN0IGZsYXR0ZW5lZFZhbHVlcyA9IHByb2Nlc3NlZERhdGEuZGF0YS5yZWR1Y2UoKGFjYywgbmV4dCkgPT4ge1xuICAgICAgY29uc3Qga2V5cyA9IG5leHQua2V5cyA/PyBbXTtcbiAgICAgIGNvbnN0IGFnZ1ZhbHVlcyA9IG5leHQuYWdnVmFsdWVzID8/IFtdO1xuICAgICAgY29uc3Qgc2tpcEtleXMgPSBuZXh0LmtleXMubWFwKCgpID0+IHZvaWQgMCk7XG4gICAgICBjb25zdCBza2lwQWdnVmFsdWVzID0gYWdnVmFsdWVzPy5tYXAoKCkgPT4gdm9pZCAwKTtcbiAgICAgIGFjYy5wdXNoKFxuICAgICAgICAuLi5uZXh0LnZhbHVlcy5tYXAoKHYsIGkpID0+IFtcbiAgICAgICAgICAuLi5pID09PSAwID8ga2V5cyA6IHNraXBLZXlzLFxuICAgICAgICAgIC4uLnYgPz8gW10sXG4gICAgICAgICAgLi4uaSA9PSAwID8gYWdnVmFsdWVzIDogc2tpcEFnZ1ZhbHVlc1xuICAgICAgICBdKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuICAgIGxvZ1ZhbHVlcyhcIlZhbHVlc1wiLCBmbGF0dGVuZWRWYWx1ZXMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGZsYXR0ZW5lZFZhbHVlcyA9IHByb2Nlc3NlZERhdGEuZGF0YS5yZWR1Y2UoKGFjYywgbmV4dCkgPT4ge1xuICAgICAgY29uc3QgYWdnVmFsdWVzID0gbmV4dC5hZ2dWYWx1ZXMgPz8gW107XG4gICAgICBhY2MucHVzaChbLi4ubmV4dC5rZXlzLCAuLi5uZXh0LnZhbHVlcywgLi4uYWdnVmFsdWVzXSk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgICBsb2dWYWx1ZXMoXCJWYWx1ZXNcIiwgZmxhdHRlbmVkVmFsdWVzKTtcbiAgfVxufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9kYXRhL2RhdGFDb250cm9sbGVyLnRzXG52YXIgX0RhdGFDb250cm9sbGVyID0gY2xhc3MgX0RhdGFDb250cm9sbGVyIHtcbiAgY29uc3RydWN0b3IobW9kZSkge1xuICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgdGhpcy5kZWJ1ZyA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcImRhdGEtbW9kZWxcIik7XG4gICAgdGhpcy5yZXF1ZXN0ZWQgPSBbXTtcbiAgICB0aGlzLnN0YXR1cyA9IFwic2V0dXBcIjtcbiAgfVxuICBhc3luYyByZXF1ZXN0KGlkLCBkYXRhLCBvcHRzKSB7XG4gICAgaWYgKHRoaXMuc3RhdHVzICE9PSBcInNldHVwXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gZGF0YSByZXF1ZXN0IGFmdGVyIGRhdGEgc2V0dXAgcGhhc2UuYCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlcXVlc3RlZC5wdXNoKHsgaWQsIG9wdHMsIGRhdGEsIHJlc29sdmUsIHJlamVjdCB9KTtcbiAgICB9KTtcbiAgfVxuICBleGVjdXRlKCkge1xuICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gXCJzZXR1cFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIGRhdGEgcmVxdWVzdCBhZnRlciBkYXRhIHNldHVwIHBoYXNlLmApO1xuICAgIH1cbiAgICB0aGlzLnN0YXR1cyA9IFwiZXhlY3V0ZWRcIjtcbiAgICB0aGlzLmRlYnVnKFwiRGF0YUNvbnRyb2xsZXIuZXhlY3V0ZSgpIC0gcmVxdWVzdGVkXCIsIHRoaXMucmVxdWVzdGVkKTtcbiAgICBjb25zdCB2YWxpZCA9IHRoaXMudmFsaWRhdGVSZXF1ZXN0cyh0aGlzLnJlcXVlc3RlZCk7XG4gICAgdGhpcy5kZWJ1ZyhcIkRhdGFDb250cm9sbGVyLmV4ZWN1dGUoKSAtIHZhbGlkYXRlZFwiLCB2YWxpZCk7XG4gICAgY29uc3QgbWVyZ2VkID0gdGhpcy5tZXJnZVJlcXVlc3RlZCh2YWxpZCk7XG4gICAgdGhpcy5kZWJ1ZyhcIkRhdGFDb250cm9sbGVyLmV4ZWN1dGUoKSAtIG1lcmdlZFwiLCBtZXJnZWQpO1xuICAgIGlmICh0aGlzLmRlYnVnLmNoZWNrKCkpIHtcbiAgICAgIGdldFdpbmRvdygpLnByb2Nlc3NlZERhdGEgPSBbXTtcbiAgICB9XG4gICAgY29uc3Qgc2NvcGVzID0gdGhpcy5yZXF1ZXN0ZWQubWFwKCh7IGlkIH0pID0+IGlkKTtcbiAgICBjb25zdCBuZWVkc1ZhbHVlRXh0cmFjdGlvbiA9IHRoaXMuaGFzTXVsdGlwbGVEYXRhU291cmNlcyh2YWxpZCk7XG4gICAgZm9yIChjb25zdCB7IG9wdHMsIGRhdGEsIHJlc29sdmVzLCByZWplY3RzLCBpZHMgfSBvZiBtZXJnZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGFNb2RlbCA9IG5ldyBEYXRhTW9kZWwob3B0cywgdGhpcy5tb2RlKTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkRGF0YSA9IGRhdGFNb2RlbC5wcm9jZXNzRGF0YShkYXRhLCB2YWxpZCk7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnLmNoZWNrKCkpIHtcbiAgICAgICAgICBnZXRXaW5kb3coXCJwcm9jZXNzZWREYXRhXCIpLnB1c2gocHJvY2Vzc2VkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2Nlc3NlZERhdGE/LnBhcnRpYWxWYWxpZERhdGFDb3VudCA9PT0gMCkge1xuICAgICAgICAgIHJlc29sdmVzLmZvckVhY2goXG4gICAgICAgICAgICAocmVzb2x2ZSwgcmVxdWVzdElkeCkgPT4gcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIGRhdGFNb2RlbCxcbiAgICAgICAgICAgICAgcHJvY2Vzc2VkRGF0YTogdGhpcy5wcm9jZXNzU2NvcGVkRGF0YShcbiAgICAgICAgICAgICAgICBpZHNbcmVxdWVzdElkeF0sXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkRGF0YSxcbiAgICAgICAgICAgICAgICBzY29wZXMsXG4gICAgICAgICAgICAgICAgbmVlZHNWYWx1ZUV4dHJhY3Rpb25cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3NlZERhdGEpIHtcbiAgICAgICAgICB0aGlzLnNwbGl0UmVzdWx0KGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSwgaWRzLCByZXNvbHZlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVqZWN0cy5mb3JFYWNoKChjYikgPT4gY2IobmV3IEVycm9yKGBBRyBDaGFydHMgLSBubyBwcm9jZXNzZWQgZGF0YSBnZW5lcmF0ZWRgKSkpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3RzLmZvckVhY2goKGNiKSA9PiBjYihlcnJvcikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYXNNdWx0aXBsZURhdGFTb3VyY2VzKHZhbGlkUmVxdWVzdHMpIHtcbiAgICBpZiAodmFsaWRSZXF1ZXN0cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IFt7IGRhdGEgfSwgLi4ucmVzdFJlcXVlc3RzXSA9IHZhbGlkUmVxdWVzdHM7XG4gICAgICByZXR1cm4gcmVzdFJlcXVlc3RzLnNvbWUoKHYpID0+IGRhdGEgIT09IHYuZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBwcm9jZXNzU2NvcGVkRGF0YShpZCwgcHJvY2Vzc2VkRGF0YSwgaWRzLCBuZWVkc1ZhbHVlRXh0cmFjdGlvbikge1xuICAgIGNvbnN0IGV4dHJhY3REYXR1bSA9IChkYXR1bSkgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0dW0pKSB7XG4gICAgICAgIHJldHVybiBkYXR1bS5tYXAoZXh0cmFjdERhdHVtKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGV4dHJhY3RlZCA9IG5lZWRzVmFsdWVFeHRyYWN0aW9uID8geyAuLi5kYXR1bSwgLi4uZGF0dW1baWRdIH0gOiBkYXR1bTtcbiAgICAgIGZvciAoY29uc3Qgb3RoZXJJZCBvZiBpZHMpIHtcbiAgICAgICAgZGVsZXRlIGV4dHJhY3RlZFtvdGhlcklkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleHRyYWN0ZWQ7XG4gICAgfTtcbiAgICBjb25zdCBleHRyYWN0VmFsdWVzID0gKHZhbHVlcykgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICByZXR1cm4gdmFsdWVzLm1hcChleHRyYWN0VmFsdWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZXM/LltpZF0gPz8gdmFsdWVzO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnByb2Nlc3NlZERhdGEsXG4gICAgICBkYXRhOiBwcm9jZXNzZWREYXRhLmRhdGEubWFwKChkYXR1bSkgPT4gKHtcbiAgICAgICAgLi4uZGF0dW0sXG4gICAgICAgIGRhdHVtOiBleHRyYWN0RGF0dW0oZGF0dW0uZGF0dW0pLFxuICAgICAgICB2YWx1ZXM6IG5lZWRzVmFsdWVFeHRyYWN0aW9uID8gZGF0dW0udmFsdWVzPy5tYXAoZXh0cmFjdFZhbHVlcykgOiBkYXR1bS52YWx1ZXNcbiAgICAgIH0pKVxuICAgIH07XG4gIH1cbiAgdmFsaWRhdGVSZXF1ZXN0cyhyZXF1ZXN0ZWQpIHtcbiAgICBjb25zdCB2YWxpZCA9IFtdO1xuICAgIGZvciAoY29uc3QgW2luZGV4LCByZXF1ZXN0XSBvZiByZXF1ZXN0ZWQuZW50cmllcygpKSB7XG4gICAgICBpZiAoaW5kZXggPiAwICYmIHJlcXVlc3QuZGF0YS5sZW5ndGggIT09IHJlcXVlc3RlZFswXS5kYXRhLmxlbmd0aCAmJiByZXF1ZXN0Lm9wdHMuZ3JvdXBCeURhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgIHJlcXVlc3QucmVqZWN0KFxuICAgICAgICAgIG5ldyBFcnJvcihcImFsbCBzZXJpZXNbXS5kYXRhIGFycmF5cyBtdXN0IGJlIG9mIHRoZSBzYW1lIGxlbmd0aCBhbmQgaGF2ZSBtYXRjaGluZyBrZXlzLlwiKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWQucHVzaChyZXF1ZXN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkO1xuICB9XG4gIG1lcmdlUmVxdWVzdGVkKHJlcXVlc3RlZCkge1xuICAgIGNvbnN0IGdyb3VwZWQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3Qgb2YgcmVxdWVzdGVkKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IGdyb3VwZWQuZmluZChfRGF0YUNvbnRyb2xsZXIuZ3JvdXBNYXRjaChyZXF1ZXN0KSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbWF0Y2gucHVzaChyZXF1ZXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyb3VwZWQucHVzaChbcmVxdWVzdF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ3JvdXBlZC5tYXAoX0RhdGFDb250cm9sbGVyLm1lcmdlUmVxdWVzdHMpO1xuICB9XG4gIHNwbGl0UmVzdWx0KGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSwgc2NvcGVzLCByZXNvbHZlcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NvcGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzY29wZSA9IHNjb3Blc1tpXTtcbiAgICAgIGNvbnN0IHJlc29sdmUgPSByZXNvbHZlc1tpXTtcbiAgICAgIHJlc29sdmUoe1xuICAgICAgICBkYXRhTW9kZWwsXG4gICAgICAgIHByb2Nlc3NlZERhdGE6IHtcbiAgICAgICAgICAuLi5wcm9jZXNzZWREYXRhLFxuICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZERhdGEuZGF0YS5maWx0ZXIoKHsgdmFsaWRTY29wZXMgfSkgPT4gdmFsaWRTY29wZXM/LmhhcyhzY29wZSkgPz8gdHJ1ZSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBncm91cE1hdGNoKHsgZGF0YSwgb3B0cyB9KSB7XG4gICAgZnVuY3Rpb24ga2V5cyhwcm9wcykge1xuICAgICAgcmV0dXJuIHByb3BzLmZpbHRlcigocCkgPT4gcC50eXBlID09PSBcImtleVwiKS5tYXAoKHApID0+IHAucHJvcGVydHkpLmpvaW4oXCI7XCIpO1xuICAgIH1cbiAgICByZXR1cm4gKFtncm91cF0pID0+IChvcHRzLmdyb3VwQnlEYXRhID09PSBmYWxzZSB8fCBncm91cC5kYXRhID09PSBkYXRhKSAmJiBncm91cC5vcHRzLmdyb3VwQnlLZXlzID09PSBvcHRzLmdyb3VwQnlLZXlzICYmIGdyb3VwLm9wdHMuZ3JvdXBCeUZuID09PSBvcHRzLmdyb3VwQnlGbiAmJiBrZXlzKGdyb3VwLm9wdHMucHJvcHMpID09PSBrZXlzKG9wdHMucHJvcHMpO1xuICB9XG4gIHN0YXRpYyBtZXJnZVJlcXVlc3RzKHJlcXVlc3RzKSB7XG4gICAgcmV0dXJuIHJlcXVlc3RzLnJlZHVjZShcbiAgICAgIChyZXN1bHQsIHsgaWQsIGRhdGEsIHJlc29sdmUsIHJlamVjdCwgb3B0czogeyBwcm9wcywgLi4ub3B0cyB9IH0pID0+IHtcbiAgICAgICAgcmVzdWx0Lmlkcy5wdXNoKGlkKTtcbiAgICAgICAgcmVzdWx0LnJlamVjdHMucHVzaChyZWplY3QpO1xuICAgICAgICByZXN1bHQucmVzb2x2ZXMucHVzaChyZXNvbHZlKTtcbiAgICAgICAgcmVzdWx0LmRhdGEgPz8gKHJlc3VsdC5kYXRhID0gZGF0YSk7XG4gICAgICAgIHJlc3VsdC5vcHRzID8/IChyZXN1bHQub3B0cyA9IHsgLi4ub3B0cywgcHJvcHM6IFtdIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcHMpIHtcbiAgICAgICAgICBjb25zdCBjbG9uZSA9IHsgLi4ucHJvcCwgc2NvcGVzOiBbaWRdIH07XG4gICAgICAgICAgX0RhdGFDb250cm9sbGVyLmNyZWF0ZUlkc01hcChpZCwgY2xvbmUpO1xuICAgICAgICAgIGNvbnN0IG1hdGNoID0gcmVzdWx0Lm9wdHMucHJvcHMuZmluZChcbiAgICAgICAgICAgIChleGlzdGluZykgPT4gZXhpc3RpbmcudHlwZSA9PT0gY2xvbmUudHlwZSAmJiBfRGF0YUNvbnRyb2xsZXIuZGVlcEVxdWFsKGV4aXN0aW5nLCBjbG9uZSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHJlc3VsdC5vcHRzLnByb3BzLnB1c2goY2xvbmUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hdGNoLnNjb3BlcyA/PyAobWF0Y2guc2NvcGVzID0gW10pO1xuICAgICAgICAgIG1hdGNoLnNjb3Blcy5wdXNoKC4uLmNsb25lLnNjb3BlcyA/PyBbXSk7XG4gICAgICAgICAgaWYgKChtYXRjaC50eXBlID09PSBcImtleVwiIHx8IG1hdGNoLnR5cGUgPT09IFwidmFsdWVcIikgJiYgY2xvbmUuaWRzTWFwPy5zaXplKSB7XG4gICAgICAgICAgICBfRGF0YUNvbnRyb2xsZXIubWVyZ2VJZHNNYXAoY2xvbmUuaWRzTWFwLCBtYXRjaC5pZHNNYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfSxcbiAgICAgIHsgaWRzOiBbXSwgcmVqZWN0czogW10sIHJlc29sdmVzOiBbXSwgZGF0YTogbnVsbCwgb3B0czogbnVsbCB9XG4gICAgKTtcbiAgfVxuICBzdGF0aWMgbWVyZ2VJZHNNYXAoZnJvbU1hcCwgdG9NYXApIHtcbiAgICBmb3IgKGNvbnN0IFtzY29wZSwgaWRzXSBvZiBmcm9tTWFwKSB7XG4gICAgICBjb25zdCB0b01hcFZhbHVlID0gdG9NYXAuZ2V0KHNjb3BlKTtcbiAgICAgIGlmICh0b01hcFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBpZHMpIHtcbiAgICAgICAgICB0b01hcFZhbHVlLmFkZChpZCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvTWFwLnNldChzY29wZSwgbmV3IFNldChpZHMpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUlkc01hcChzY29wZSwgcHJvcCkge1xuICAgIGlmIChwcm9wLmlkID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgcHJvcC5pZHNNYXAgPz8gKHByb3AuaWRzTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gICAgaWYgKHByb3AuaWRzTWFwLmhhcyhzY29wZSkpIHtcbiAgICAgIHByb3AuaWRzTWFwLmdldChzY29wZSkuYWRkKHByb3AuaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wLmlkc01hcC5zZXQoc2NvcGUsIC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtwcm9wLmlkXSkpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZGVlcEVxdWFsKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgYiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3Rvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBsZXQgaSwgbGVuZ3RoMjtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIGxlbmd0aDIgPSBhLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aDIgIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IGxlbmd0aDIgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmICghX0RhdGFDb250cm9sbGVyLmRlZXBFcXVhbChhW2ldLCBiW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICAgIGxlbmd0aDIgPSBrZXlzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGgyICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gbGVuZ3RoMiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICghX0RhdGFDb250cm9sbGVyLnNraXBLZXlzLmhhcyhrZXkpICYmICghT2JqZWN0Lmhhc093bihiLCBrZXkpIHx8ICFfRGF0YUNvbnRyb2xsZXIuZGVlcEVxdWFsKGFba2V5XSwgYltrZXldKSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG4vLyBvcHRpbWl6ZWQgdmVyc2lvbiBvZiBkZWVwIGVxdWFsaXR5IGZvciBgbWVyZ2VSZXF1ZXN0c2Agd2hpY2ggY2FuIHBvdGVudGlhbGx5IGxvb3Agb3ZlciAxTSB0aW1lc1xuX0RhdGFDb250cm9sbGVyLnNraXBLZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiaWRcIiwgXCJpZHNNYXBcIiwgXCJ0eXBlXCIsIFwic2NvcGVzXCJdKTtcbnZhciBEYXRhQ29udHJvbGxlciA9IF9EYXRhQ29udHJvbGxlcjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZmFjdG9yeS9heGlzUmVnaXN0cnkudHNcbnZhciBBeGlzUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYXhlc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgdGhpcy5oaWRkZW4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMudGhlbWVUZW1wbGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIHJlZ2lzdGVyKGF4aXNUeXBlLCBtb2R1bGUpIHtcbiAgICB0aGlzLmF4ZXNNYXAuc2V0KGF4aXNUeXBlLCBtb2R1bGUubW9kdWxlRmFjdG9yeSk7XG4gICAgaWYgKG1vZHVsZS50aGVtZVRlbXBsYXRlKSB7XG4gICAgICB0aGlzLnNldFRoZW1lVGVtcGxhdGUoYXhpc1R5cGUsIG1vZHVsZS50aGVtZVRlbXBsYXRlKTtcbiAgICB9XG4gICAgaWYgKG1vZHVsZS5oaWRkZW4pIHtcbiAgICAgIHRoaXMuaGlkZGVuLmFkZChheGlzVHlwZSk7XG4gICAgfVxuICB9XG4gIGNyZWF0ZShheGlzVHlwZSwgbW9kdWxlQ29udGV4dCkge1xuICAgIGNvbnN0IGF4aXNGYWN0b3J5ID0gdGhpcy5heGVzTWFwLmdldChheGlzVHlwZSk7XG4gICAgaWYgKGF4aXNGYWN0b3J5KSB7XG4gICAgICByZXR1cm4gYXhpc0ZhY3RvcnkobW9kdWxlQ29udGV4dCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQUcgQ2hhcnRzIC0gdW5rbm93biBheGlzIHR5cGU6ICR7YXhpc1R5cGV9YCk7XG4gIH1cbiAgaGFzKGF4aXNUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuYXhlc01hcC5oYXMoYXhpc1R5cGUpO1xuICB9XG4gIGtleXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXhlc01hcC5rZXlzKCk7XG4gIH1cbiAgcHVibGljS2V5cygpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMua2V5cygpXS5maWx0ZXIoKGspID0+ICF0aGlzLmhpZGRlbi5oYXMoaykpO1xuICB9XG4gIHNldFRoZW1lVGVtcGxhdGUoYXhpc1R5cGUsIHRoZW1lVGVtcGxhdGUpIHtcbiAgICB0aGlzLnRoZW1lVGVtcGxhdGVzLnNldChheGlzVHlwZSwgdGhlbWVUZW1wbGF0ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ2V0VGhlbWVUZW1wbGF0ZShheGlzVHlwZSkge1xuICAgIHJldHVybiB0aGlzLnRoZW1lVGVtcGxhdGVzLmdldChheGlzVHlwZSk7XG4gIH1cbn07XG52YXIgYXhpc1JlZ2lzdHJ5ID0gbmV3IEF4aXNSZWdpc3RyeSgpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9mYWN0b3J5L2V4cGVjdGVkRW50ZXJwcmlzZU1vZHVsZXMudHNcbnZhciBFWFBFQ1RFRF9FTlRFUlBSSVNFX01PRFVMRVMgPSBbXG4gIHtcbiAgICB0eXBlOiBcInJvb3RcIixcbiAgICBvcHRpb25zS2V5OiBcImFuaW1hdGlvblwiLFxuICAgIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInBvbGFyXCIsIFwiaGllcmFyY2h5XCIsIFwidG9wb2xvZ3lcIiwgXCJmbG93LXByb3BvcnRpb25cIl1cbiAgfSxcbiAgeyB0eXBlOiBcInJvb3RcIiwgb3B0aW9uc0tleTogXCJhbm5vdGF0aW9uc1wiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0gfSxcbiAge1xuICAgIHR5cGU6IFwicm9vdFwiLFxuICAgIG9wdGlvbnNLZXk6IFwiYmFja2dyb3VuZFwiLFxuICAgIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInBvbGFyXCIsIFwiaGllcmFyY2h5XCIsIFwidG9wb2xvZ3lcIiwgXCJmbG93LXByb3BvcnRpb25cIl0sXG4gICAgb3B0aW9uc0lubmVyS2V5OiBcImltYWdlXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwicm9vdFwiLFxuICAgIG9wdGlvbnNLZXk6IFwiZm9yZWdyb3VuZFwiLFxuICAgIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInBvbGFyXCIsIFwiaGllcmFyY2h5XCIsIFwidG9wb2xvZ3lcIiwgXCJmbG93LXByb3BvcnRpb25cIl0sXG4gICAgb3B0aW9uc0lubmVyS2V5OiBcImltYWdlXCJcbiAgfSxcbiAge1xuICAgIHR5cGU6IFwicm9vdFwiLFxuICAgIG9wdGlvbnNLZXk6IFwiY2hhcnRUb29sYmFyXCIsXG4gICAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdXG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcInJvb3RcIixcbiAgICBvcHRpb25zS2V5OiBcImNvbnRleHRNZW51XCIsXG4gICAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCIsIFwicG9sYXJcIiwgXCJoaWVyYXJjaHlcIiwgXCJ0b3BvbG9neVwiLCBcImZsb3ctcHJvcG9ydGlvblwiXVxuICB9LFxuICB7IHR5cGU6IFwicm9vdFwiLCBvcHRpb25zS2V5OiBcInN0YXR1c0JhclwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwic3RhdHVzLWJhclwiIH0sXG4gIHtcbiAgICB0eXBlOiBcInJvb3RcIixcbiAgICBvcHRpb25zS2V5OiBcImRhdGFTb3VyY2VcIixcbiAgICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIiwgXCJwb2xhclwiLCBcImhpZXJhcmNoeVwiLCBcInRvcG9sb2d5XCIsIFwiZmxvdy1wcm9wb3J0aW9uXCJdXG4gIH0sXG4gIHsgdHlwZTogXCJyb290XCIsIG9wdGlvbnNLZXk6IFwic3luY1wiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0gfSxcbiAgeyB0eXBlOiBcInJvb3RcIiwgb3B0aW9uc0tleTogXCJ6b29tXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInRvcG9sb2d5XCJdIH0sXG4gIHtcbiAgICB0eXBlOiBcImxlZ2VuZFwiLFxuICAgIG9wdGlvbnNLZXk6IFwiZ3JhZGllbnRMZWdlbmRcIixcbiAgICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIiwgXCJwb2xhclwiLCBcImhpZXJhcmNoeVwiLCBcInRvcG9sb2d5XCIsIFwiZmxvdy1wcm9wb3J0aW9uXCJdLFxuICAgIGlkZW50aWZpZXI6IFwiZ3JhZGllbnRcIlxuICB9LFxuICB7IHR5cGU6IFwicm9vdFwiLCBvcHRpb25zS2V5OiBcIm5hdmlnYXRvclwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIG9wdGlvbnNJbm5lcktleTogXCJtaW5pQ2hhcnRcIiB9LFxuICB7IHR5cGU6IFwiYXhpc1wiLCBvcHRpb25zS2V5OiBcImF4ZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJwb2xhclwiXSwgaWRlbnRpZmllcjogXCJhbmdsZS1jYXRlZ29yeVwiIH0sXG4gIHsgdHlwZTogXCJheGlzXCIsIG9wdGlvbnNLZXk6IFwiYXhlc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInBvbGFyXCJdLCBpZGVudGlmaWVyOiBcImFuZ2xlLW51bWJlclwiIH0sXG4gIHsgdHlwZTogXCJheGlzXCIsIG9wdGlvbnNLZXk6IFwiYXhlc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInBvbGFyXCJdLCBpZGVudGlmaWVyOiBcInJhZGl1cy1jYXRlZ29yeVwiIH0sXG4gIHsgdHlwZTogXCJheGlzXCIsIG9wdGlvbnNLZXk6IFwiYXhlc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInBvbGFyXCJdLCBpZGVudGlmaWVyOiBcInJhZGl1cy1udW1iZXJcIiB9LFxuICB7IHR5cGU6IFwiYXhpc1wiLCBvcHRpb25zS2V5OiBcImF4ZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwib3JkaW5hbC10aW1lXCIgfSxcbiAgeyB0eXBlOiBcImF4aXMtb3B0aW9uXCIsIG9wdGlvbnNLZXk6IFwiY3Jvc3NoYWlyXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLCBpZGVudGlmaWVyOiBcImJveC1wbG90XCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJjYW5kbGVzdGlja1wiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwib2hsY1wiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwiYnVsbGV0XCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJoZWF0bWFwXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJyYW5nZS1hcmVhXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSwgaWRlbnRpZmllcjogXCJyYW5nZS1iYXJcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLCBpZGVudGlmaWVyOiBcIndhdGVyZmFsbFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJwb2xhclwiXSwgaWRlbnRpZmllcjogXCJuaWdodGluZ2FsZVwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJwb2xhclwiXSwgaWRlbnRpZmllcjogXCJyYWRhci1hcmVhXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcInBvbGFyXCJdLCBpZGVudGlmaWVyOiBcInJhZGFyLWxpbmVcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sIGlkZW50aWZpZXI6IFwicmFkaWFsLWJhclwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJwb2xhclwiXSwgaWRlbnRpZmllcjogXCJyYWRpYWwtY29sdW1uXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImhpZXJhcmNoeVwiXSwgaWRlbnRpZmllcjogXCJzdW5idXJzdFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJoaWVyYXJjaHlcIl0sIGlkZW50aWZpZXI6IFwidHJlZW1hcFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJ0b3BvbG9neVwiXSwgaWRlbnRpZmllcjogXCJtYXAtc2hhcGVcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1widG9wb2xvZ3lcIl0sIGlkZW50aWZpZXI6IFwibWFwLWxpbmVcIiB9LFxuICB7IHR5cGU6IFwic2VyaWVzXCIsIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIiwgY2hhcnRUeXBlczogW1widG9wb2xvZ3lcIl0sIGlkZW50aWZpZXI6IFwibWFwLW1hcmtlclwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJ0b3BvbG9neVwiXSwgaWRlbnRpZmllcjogXCJtYXAtc2hhcGUtYmFja2dyb3VuZFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJ0b3BvbG9neVwiXSwgaWRlbnRpZmllcjogXCJtYXAtbGluZS1iYWNrZ3JvdW5kXCIgfSxcbiAgeyB0eXBlOiBcInNlcmllc1wiLCBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsIGNoYXJ0VHlwZXM6IFtcImZsb3ctcHJvcG9ydGlvblwiXSwgaWRlbnRpZmllcjogXCJjaG9yZFwiIH0sXG4gIHsgdHlwZTogXCJzZXJpZXNcIiwgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLCBjaGFydFR5cGVzOiBbXCJmbG93LXByb3BvcnRpb25cIl0sIGlkZW50aWZpZXI6IFwic2Fua2V5XCIgfSxcbiAgeyB0eXBlOiBcInNlcmllcy1vcHRpb25cIiwgb3B0aW9uc0tleTogXCJlcnJvckJhclwiLCBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sIGlkZW50aWZpZXI6IFwiZXJyb3ItYmFyc1wiIH1cbl07XG5mdW5jdGlvbiBpc0VudGVycHJpc2VTZXJpZXNUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIEVYUEVDVEVEX0VOVEVSUFJJU0VfTU9EVUxFUy5zb21lKChzKSA9PiBzLnR5cGUgPT09IFwic2VyaWVzXCIgJiYgcy5pZGVudGlmaWVyID09PSB0eXBlKTtcbn1cbmZ1bmN0aW9uIGdldEVudGVycHJpc2VTZXJpZXNDaGFydFR5cGVzKHR5cGUpIHtcbiAgcmV0dXJuIEVYUEVDVEVEX0VOVEVSUFJJU0VfTU9EVUxFUy5maW5kKChzKSA9PiBzLnR5cGUgPT09IFwic2VyaWVzXCIgJiYgcy5pZGVudGlmaWVyID09PSB0eXBlKT8uY2hhcnRUeXBlcztcbn1cbmZ1bmN0aW9uIGlzRW50ZXJwcmlzZUNhcnRlc2lhbihzZXJpZXNUeXBlMikge1xuICBjb25zdCB0eXBlID0gZ2V0RW50ZXJwcmlzZVNlcmllc0NoYXJ0VHlwZXMoc2VyaWVzVHlwZTIpPy5maW5kKCh2KSA9PiB2ID09PSBcImNhcnRlc2lhblwiKTtcbiAgcmV0dXJuIHR5cGUgPT09IFwiY2FydGVzaWFuXCI7XG59XG5mdW5jdGlvbiBpc0VudGVycHJpc2VQb2xhcihzZXJpZXNUeXBlMikge1xuICBjb25zdCB0eXBlID0gZ2V0RW50ZXJwcmlzZVNlcmllc0NoYXJ0VHlwZXMoc2VyaWVzVHlwZTIpPy5maW5kKCh2KSA9PiB2ID09PSBcInBvbGFyXCIpO1xuICByZXR1cm4gdHlwZSA9PT0gXCJwb2xhclwiO1xufVxuZnVuY3Rpb24gaXNFbnRlcnByaXNlSGllcmFyY2h5KHNlcmllc1R5cGUyKSB7XG4gIGNvbnN0IHR5cGUgPSBnZXRFbnRlcnByaXNlU2VyaWVzQ2hhcnRUeXBlcyhzZXJpZXNUeXBlMik/LmZpbmQoKHYpID0+IHYgPT09IFwiaGllcmFyY2h5XCIpO1xuICByZXR1cm4gdHlwZSA9PT0gXCJoaWVyYXJjaHlcIjtcbn1cbmZ1bmN0aW9uIGlzRW50ZXJwcmlzZVRvcG9sb2d5KHNlcmllc1R5cGUyKSB7XG4gIGNvbnN0IHR5cGUgPSBnZXRFbnRlcnByaXNlU2VyaWVzQ2hhcnRUeXBlcyhzZXJpZXNUeXBlMik/LmZpbmQoKHYpID0+IHYgPT09IFwidG9wb2xvZ3lcIik7XG4gIHJldHVybiB0eXBlID09PSBcInRvcG9sb2d5XCI7XG59XG5mdW5jdGlvbiBpc0VudGVycHJpc2VGbG93UHJvcG9ydGlvbihzZXJpZXNUeXBlMikge1xuICBjb25zdCB0eXBlID0gZ2V0RW50ZXJwcmlzZVNlcmllc0NoYXJ0VHlwZXMoc2VyaWVzVHlwZTIpPy5maW5kKCh2KSA9PiB2ID09PSBcImZsb3ctcHJvcG9ydGlvblwiKTtcbiAgcmV0dXJuIHR5cGUgPT09IFwiZmxvdy1wcm9wb3J0aW9uXCI7XG59XG5mdW5jdGlvbiBpc0VudGVycHJpc2VNb2R1bGUobW9kdWxlKSB7XG4gIHJldHVybiBtb2R1bGUucGFja2FnZVR5cGUgPT09IFwiZW50ZXJwcmlzZVwiO1xufVxuZnVuY3Rpb24gdmVyaWZ5SWZNb2R1bGVFeHBlY3RlZChtb2R1bGUpIHtcbiAgaWYgKCFpc0VudGVycHJpc2VNb2R1bGUobW9kdWxlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIGludGVybmFsIGNvbmZpZ3VyYXRpb24gZXJyb3IsIG9ubHkgZW50ZXJwcmlzZSBtb2R1bGVzIG5lZWQgdmVyaWZpY2F0aW9uLlwiKTtcbiAgfVxuICBjb25zdCBzdHViID0gRVhQRUNURURfRU5URVJQUklTRV9NT0RVTEVTLmZpbmQoKHMpID0+IHtcbiAgICByZXR1cm4gcy50eXBlID09PSBtb2R1bGUudHlwZSAmJiBzLm9wdGlvbnNLZXkgPT09IG1vZHVsZS5vcHRpb25zS2V5ICYmIHMuaWRlbnRpZmllciA9PT0gbW9kdWxlLmlkZW50aWZpZXIgJiYgbW9kdWxlLmNoYXJ0VHlwZXMuZXZlcnkoKHQpID0+IHMuY2hhcnRUeXBlcy5pbmNsdWRlcyh0KSk7XG4gIH0pO1xuICBpZiAoc3R1Yikge1xuICAgIHN0dWIudXNlQ291bnQgPz8gKHN0dWIudXNlQ291bnQgPSAwKTtcbiAgICBzdHViLnVzZUNvdW50Kys7XG4gIH1cbiAgcmV0dXJuIHN0dWIgIT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFVudXNlZEV4cGVjdGVkTW9kdWxlcygpIHtcbiAgcmV0dXJuIEVYUEVDVEVEX0VOVEVSUFJJU0VfTU9EVUxFUy5maWx0ZXIoKHsgdXNlQ291bnQgfSkgPT4gdXNlQ291bnQgPT0gbnVsbCB8fCB1c2VDb3VudCA9PT0gMCk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ZhY3RvcnkvbGVnZW5kUmVnaXN0cnkudHNcbnZhciBMZWdlbmRSZWdpc3RyeSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5sZWdlbmRNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMudGhlbWVUZW1wbGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIHJlZ2lzdGVyKGxlZ2VuZFR5cGUsIHsgb3B0aW9uc0tleSwgbW9kdWxlRmFjdG9yeSwgdGhlbWVUZW1wbGF0ZSB9KSB7XG4gICAgdGhpcy5sZWdlbmRNYXAuc2V0KGxlZ2VuZFR5cGUsIHsgb3B0aW9uc0tleSwgbW9kdWxlRmFjdG9yeSB9KTtcbiAgICB0aGlzLnRoZW1lVGVtcGxhdGVzLnNldChvcHRpb25zS2V5LCB0aGVtZVRlbXBsYXRlKTtcbiAgfVxuICBjcmVhdGUobGVnZW5kVHlwZSwgbW9kdWxlQ29udGV4dCkge1xuICAgIGNvbnN0IGxlZ2VuZEZhY3RvcnkgPSB0aGlzLmxlZ2VuZE1hcC5nZXQobGVnZW5kVHlwZSk/Lm1vZHVsZUZhY3Rvcnk7XG4gICAgaWYgKGxlZ2VuZEZhY3RvcnkpIHtcbiAgICAgIHJldHVybiBsZWdlbmRGYWN0b3J5KG1vZHVsZUNvbnRleHQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIHVua25vd24gbGVnZW5kIHR5cGU6ICR7bGVnZW5kVHlwZX1gKTtcbiAgfVxuICBnZXRUaGVtZVRlbXBsYXRlcygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMudGhlbWVUZW1wbGF0ZXMpO1xuICB9XG4gIGdldEtleXMoKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5sZWdlbmRNYXAuZW50cmllcygpKS5yZWR1Y2UoXG4gICAgICAocmVzdWx0LCBbbGVnZW5kVHlwZSwgcmVjb3JkXSkgPT4ge1xuICAgICAgICByZXN1bHRbbGVnZW5kVHlwZV0gPSByZWNvcmQub3B0aW9uc0tleTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICB7fVxuICAgICk7XG4gIH1cbn07XG52YXIgbGVnZW5kUmVnaXN0cnkgPSBuZXcgTGVnZW5kUmVnaXN0cnkoKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZmFjdG9yeS9jaGFydFR5cGVzLnRzXG52YXIgQ2hhcnRUeXBlcyA9IGNsYXNzIGV4dGVuZHMgTWFwIHtcbiAgZ2V0KHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldChzZXJpZXNUeXBlMikgPz8gXCJ1bmtub3duXCI7XG4gIH1cbiAgaXNDYXJ0ZXNpYW4oc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoc2VyaWVzVHlwZTIpID09PSBcImNhcnRlc2lhblwiO1xuICB9XG4gIGlzUG9sYXIoc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoc2VyaWVzVHlwZTIpID09PSBcInBvbGFyXCI7XG4gIH1cbiAgaXNIaWVyYXJjaHkoc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoc2VyaWVzVHlwZTIpID09PSBcImhpZXJhcmNoeVwiO1xuICB9XG4gIGlzVG9wb2xvZ3koc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoc2VyaWVzVHlwZTIpID09PSBcInRvcG9sb2d5XCI7XG4gIH1cbiAgaXNGbG93UHJvcG9ydGlvbihzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB0aGlzLmdldChzZXJpZXNUeXBlMikgPT09IFwiZmxvdy1wcm9wb3J0aW9uXCI7XG4gIH1cbiAgZ2V0IHNlcmllc1R5cGVzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMua2V5cygpKTtcbiAgfVxuICBnZXQgY2FydGVzaWFuVHlwZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzVHlwZXMuZmlsdGVyKCh0KSA9PiB0aGlzLmlzQ2FydGVzaWFuKHQpKTtcbiAgfVxuICBnZXQgcG9sYXJUeXBlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNUeXBlcy5maWx0ZXIoKHQpID0+IHRoaXMuaXNQb2xhcih0KSk7XG4gIH1cbiAgZ2V0IGhpZXJhcmNoeVR5cGVzKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmllc1R5cGVzLmZpbHRlcigodCkgPT4gdGhpcy5pc0hpZXJhcmNoeSh0KSk7XG4gIH1cbiAgZ2V0IHRvcG9sb2d5VHlwZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzVHlwZXMuZmlsdGVyKCh0KSA9PiB0aGlzLmlzVG9wb2xvZ3kodCkpO1xuICB9XG4gIGdldCBmbG93UHJvcG9ydGlvblR5cGVzKCkge1xuICAgIHJldHVybiB0aGlzLnNlcmllc1R5cGVzLmZpbHRlcigodCkgPT4gdGhpcy5pc0Zsb3dQcm9wb3J0aW9uKHQpKTtcbiAgfVxufTtcbnZhciBDaGFydERlZmF1bHRzID0gY2xhc3MgZXh0ZW5kcyBNYXAge1xuICBzZXQoY2hhcnRUeXBlMiwgZGVmYXVsdHMpIHtcbiAgICByZXR1cm4gc3VwZXIuc2V0KGNoYXJ0VHlwZTIsIG1lcmdlRGVmYXVsdHMoZGVmYXVsdHMsIHRoaXMuZ2V0KGNoYXJ0VHlwZTIpKSk7XG4gIH1cbn07XG52YXIgY2hhcnRUeXBlcyA9IG5ldyBDaGFydFR5cGVzKCk7XG52YXIgcHVibGljQ2hhcnRUeXBlcyA9IG5ldyBDaGFydFR5cGVzKCk7XG52YXIgY2hhcnREZWZhdWx0cyA9IG5ldyBDaGFydERlZmF1bHRzKCk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ZhY3Rvcnkvc2VyaWVzUmVnaXN0cnkudHNcbnZhciBTZXJpZXNSZWdpc3RyeSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zZXJpZXNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMudGhlbWVUZW1wbGF0ZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIHJlZ2lzdGVyKHNlcmllc1R5cGUyLCB7XG4gICAgY2hhcnRUeXBlczogW2NoYXJ0VHlwZTJdLFxuICAgIG1vZHVsZUZhY3RvcnksXG4gICAgdG9vbHRpcERlZmF1bHRzLFxuICAgIGRlZmF1bHRBeGVzLFxuICAgIHRoZW1lVGVtcGxhdGUsXG4gICAgcGFsZXR0ZUZhY3RvcnksXG4gICAgc29sbyxcbiAgICBzdGFja2FibGUsXG4gICAgZ3JvdXBhYmxlLFxuICAgIHN0YWNrZWRCeURlZmF1bHQsXG4gICAgc3dhcERlZmF1bHRBeGVzQ29uZGl0aW9uLFxuICAgIGhpZGRlblxuICB9KSB7XG4gICAgdGhpcy5zZXRUaGVtZVRlbXBsYXRlKHNlcmllc1R5cGUyLCB0aGVtZVRlbXBsYXRlKTtcbiAgICB0aGlzLnNlcmllc01hcC5zZXQoc2VyaWVzVHlwZTIsIHtcbiAgICAgIG1vZHVsZUZhY3RvcnksXG4gICAgICB0b29sdGlwRGVmYXVsdHMsXG4gICAgICBkZWZhdWx0QXhlcyxcbiAgICAgIHBhbGV0dGVGYWN0b3J5LFxuICAgICAgc29sbyxcbiAgICAgIHN0YWNrYWJsZSxcbiAgICAgIGdyb3VwYWJsZSxcbiAgICAgIHN0YWNrZWRCeURlZmF1bHQsXG4gICAgICBzd2FwRGVmYXVsdEF4ZXNDb25kaXRpb25cbiAgICB9KTtcbiAgICBjaGFydFR5cGVzLnNldChzZXJpZXNUeXBlMiwgY2hhcnRUeXBlMik7XG4gICAgaWYgKCFoaWRkZW4pIHtcbiAgICAgIHB1YmxpY0NoYXJ0VHlwZXMuc2V0KHNlcmllc1R5cGUyLCBjaGFydFR5cGUyKTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlKHNlcmllc1R5cGUyLCBtb2R1bGVDb250ZXh0KSB7XG4gICAgY29uc3Qgc2VyaWVzRmFjdG9yeSA9IHRoaXMuc2VyaWVzTWFwLmdldChzZXJpZXNUeXBlMik/Lm1vZHVsZUZhY3Rvcnk7XG4gICAgaWYgKHNlcmllc0ZhY3RvcnkpIHtcbiAgICAgIHJldHVybiBzZXJpZXNGYWN0b3J5KG1vZHVsZUNvbnRleHQpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIHVua25vd24gc2VyaWVzIHR5cGU6ICR7c2VyaWVzVHlwZTJ9YCk7XG4gIH1cbiAgY2xvbmVEZWZhdWx0QXhlcyhzZXJpZXNUeXBlMikge1xuICAgIGNvbnN0IGRlZmF1bHRBeGVzID0gdGhpcy5zZXJpZXNNYXAuZ2V0KHNlcmllc1R5cGUyKT8uZGVmYXVsdEF4ZXM7XG4gICAgcmV0dXJuIGRlZmF1bHRBeGVzID8geyBheGVzOiBkZWVwQ2xvbmUoZGVmYXVsdEF4ZXMpIH0gOiBudWxsO1xuICB9XG4gIHNldFRoZW1lVGVtcGxhdGUoc2VyaWVzVHlwZTIsIHRoZW1lVGVtcGxhdGUpIHtcbiAgICBjb25zdCBjdXJyZW50VGVtcGxhdGUgPSB0aGlzLnRoZW1lVGVtcGxhdGVzLmdldChzZXJpZXNUeXBlMik7XG4gICAgdGhpcy50aGVtZVRlbXBsYXRlcy5zZXQoc2VyaWVzVHlwZTIsIG1lcmdlRGVmYXVsdHModGhlbWVUZW1wbGF0ZSwgY3VycmVudFRlbXBsYXRlKSk7XG4gIH1cbiAgZ2V0VGhlbWVUZW1wbGF0ZShzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB0aGlzLnRoZW1lVGVtcGxhdGVzLmdldChzZXJpZXNUeXBlMik7XG4gIH1cbiAgZ2V0UGFsZXR0ZUZhY3Rvcnkoc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNNYXAuZ2V0KHNlcmllc1R5cGUyKT8ucGFsZXR0ZUZhY3Rvcnk7XG4gIH1cbiAgZ2V0VG9vbHRpcERlZmF1bHMoc2VyaWVzVHlwZTIpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJpZXNNYXAuZ2V0KHNlcmllc1R5cGUyKT8udG9vbHRpcERlZmF1bHRzO1xuICB9XG4gIGlzU29sbyhzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB0aGlzLnNlcmllc01hcC5nZXQoc2VyaWVzVHlwZTIpPy5zb2xvID8/IGZhbHNlO1xuICB9XG4gIGlzR3JvdXBhYmxlKHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzTWFwLmdldChzZXJpZXNUeXBlMik/Lmdyb3VwYWJsZSA/PyBmYWxzZTtcbiAgfVxuICBpc1N0YWNrYWJsZShzZXJpZXNUeXBlMikge1xuICAgIHJldHVybiB0aGlzLnNlcmllc01hcC5nZXQoc2VyaWVzVHlwZTIpPy5zdGFja2FibGUgPz8gZmFsc2U7XG4gIH1cbiAgaXNTdGFja2VkQnlEZWZhdWx0KHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzTWFwLmdldChzZXJpZXNUeXBlMik/LnN0YWNrZWRCeURlZmF1bHQgPz8gZmFsc2U7XG4gIH1cbiAgaXNEZWZhdWx0QXhpc1N3YXBOZWVkZWQob3B0aW9ucykge1xuICAgIGxldCByZXN1bHQ7XG4gICAgZm9yIChjb25zdCBzZXJpZXMgb2Ygb3B0aW9ucy5zZXJpZXMgPz8gW10pIHtcbiAgICAgIGNvbnN0IHsgdHlwZSA9IFwibGluZVwiIH0gPSBzZXJpZXM7XG4gICAgICBjb25zdCBpc0RlZmF1bHRBeGlzU3dhcHBlZCA9IHRoaXMuc2VyaWVzTWFwLmdldCh0eXBlKT8uc3dhcERlZmF1bHRBeGVzQ29uZGl0aW9uPy4oc2VyaWVzKTtcbiAgICAgIGlmIChpc0RlZmF1bHRBeGlzU3dhcHBlZCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChyZXN1bHQgIT0gbnVsbCAmJiByZXN1bHQgIT0gaXNEZWZhdWx0QXhpc1N3YXBwZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBRyBDaGFydHMgLSBUaGUgcHJvdmlkZWQgc2VyaWVzIGhhdmUgaW5jb21wYXRpYmxlIGRpcmVjdGlvbnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gaXNEZWZhdWx0QXhpc1N3YXBwZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG52YXIgc2VyaWVzUmVnaXN0cnkgPSBuZXcgU2VyaWVzUmVnaXN0cnkoKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvaW50ZXJhY3Rpb24vc3luY01hbmFnZXIudHNcbnZhciBfU3luY01hbmFnZXIgPSBjbGFzcyBfU3luY01hbmFnZXIgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNoYXJ0ID0gY2hhcnQ7XG4gIH1cbiAgc3Vic2NyaWJlKGdyb3VwSWQgPSBfU3luY01hbmFnZXIuREVGQVVMVF9HUk9VUCkge1xuICAgIGxldCBzeW5jR3JvdXAgPSB0aGlzLmdldChncm91cElkKTtcbiAgICBpZiAoIXN5bmNHcm91cCkge1xuICAgICAgc3luY0dyb3VwID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIF9TeW5jTWFuYWdlci5jaGFydHNHcm91cHMuc2V0KGdyb3VwSWQsIHN5bmNHcm91cCk7XG4gICAgfVxuICAgIHN5bmNHcm91cC5hZGQodGhpcy5jaGFydCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdW5zdWJzY3JpYmUoZ3JvdXBJZCA9IF9TeW5jTWFuYWdlci5ERUZBVUxUX0dST1VQKSB7XG4gICAgdGhpcy5nZXQoZ3JvdXBJZCk/LmRlbGV0ZSh0aGlzLmNoYXJ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXRDaGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydDtcbiAgfVxuICBnZXRHcm91cChncm91cElkID0gX1N5bmNNYW5hZ2VyLkRFRkFVTFRfR1JPVVApIHtcbiAgICBjb25zdCBzeW5jR3JvdXAgPSB0aGlzLmdldChncm91cElkKTtcbiAgICByZXR1cm4gc3luY0dyb3VwID8gQXJyYXkuZnJvbShzeW5jR3JvdXApIDogW107XG4gIH1cbiAgZ2V0R3JvdXBTaWJsaW5ncyhncm91cElkID0gX1N5bmNNYW5hZ2VyLkRFRkFVTFRfR1JPVVApIHtcbiAgICByZXR1cm4gdGhpcy5nZXRHcm91cChncm91cElkKS5maWx0ZXIoKGNoYXJ0KSA9PiBjaGFydCAhPT0gdGhpcy5jaGFydCk7XG4gIH1cbiAgZ2V0KGdyb3VwSWQpIHtcbiAgICByZXR1cm4gX1N5bmNNYW5hZ2VyLmNoYXJ0c0dyb3Vwcy5nZXQoZ3JvdXBJZCk7XG4gIH1cbn07XG5fU3luY01hbmFnZXIuY2hhcnRzR3JvdXBzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbl9TeW5jTWFuYWdlci5ERUZBVUxUX0dST1VQID0gU3ltYm9sKFwic3luYy1ncm91cC1kZWZhdWx0XCIpO1xudmFyIFN5bmNNYW5hZ2VyID0gX1N5bmNNYW5hZ2VyO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9pbnRlcmFjdGlvbi96b29tTWFuYWdlci50c1xudmFyIFpvb21NYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5heGlzWm9vbU1hbmFnZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLnN0YXRlID0gbmV3IFN0YXRlVHJhY2tlcih2b2lkIDAsIFwiaW5pdGlhbFwiKTtcbiAgICB0aGlzLnJlamVjdENhbGxiYWNrcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIH1cbiAgdXBkYXRlQXhlcyhheGVzKSB7XG4gICAgY29uc3Qgem9vbU1hbmFnZXJzID0gbmV3IE1hcChheGVzLm1hcCgoYXhpcykgPT4gW2F4aXMuaWQsIHRoaXMuYXhpc1pvb21NYW5hZ2Vycy5nZXQoYXhpcy5pZCldKSk7XG4gICAgdGhpcy5heGlzWm9vbU1hbmFnZXJzLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBheGlzIG9mIGF4ZXMpIHtcbiAgICAgIHRoaXMuYXhpc1pvb21NYW5hZ2Vycy5zZXQoYXhpcy5pZCwgem9vbU1hbmFnZXJzLmdldChheGlzLmlkKSA/PyBuZXcgQXhpc1pvb21NYW5hZ2VyKGF4aXMpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUuc2l6ZSA+IDAgJiYgYXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLnVwZGF0ZVpvb20odGhpcy5zdGF0ZS5zdGF0ZUlkKCksIHRoaXMuc3RhdGUuc3RhdGVWYWx1ZSgpKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlWm9vbShjYWxsZXJJZCwgbmV3Wm9vbSwgY2FuQ2hhbmdlSW5pdGlhbCA9IHRydWUsIHJlamVjdENhbGxiYWNrKSB7XG4gICAgaWYgKHJlamVjdENhbGxiYWNrKSB7XG4gICAgICB0aGlzLnJlamVjdENhbGxiYWNrcy5zZXQoY2FsbGVySWQsIHJlamVjdENhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXhpc1pvb21NYW5hZ2Vycy5zaXplID09PSAwKSB7XG4gICAgICBjb25zdCBzdGF0ZUlkID0gdGhpcy5zdGF0ZS5zdGF0ZUlkKCk7XG4gICAgICBpZiAoc3RhdGVJZCA9PT0gXCJpbml0aWFsXCIgfHwgc3RhdGVJZCA9PT0gY2FsbGVySWQgfHwgY2FuQ2hhbmdlSW5pdGlhbCkge1xuICAgICAgICB0aGlzLnN0YXRlLnNldChjYWxsZXJJZCwgbmV3Wm9vbSk7XG4gICAgICAgIGlmIChzdGF0ZUlkICE9PSBjYWxsZXJJZCkge1xuICAgICAgICAgIHRoaXMucmVqZWN0Q2FsbGJhY2tzLmdldChzdGF0ZUlkKT8uKGNhbGxlcklkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0Q2FsbGJhY2s/LihzdGF0ZUlkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zdGF0ZS5zZXQoY2FsbGVySWQsIG5ld1pvb20pO1xuICAgIHRoaXMuYXhpc1pvb21NYW5hZ2Vycy5mb3JFYWNoKChheGlzKSA9PiB7XG4gICAgICBheGlzLnVwZGF0ZVpvb20oY2FsbGVySWQsIG5ld1pvb20/LltheGlzLmdldERpcmVjdGlvbigpXSk7XG4gICAgfSk7XG4gICAgdGhpcy5hcHBseUNoYW5nZXMoY2FsbGVySWQpO1xuICB9XG4gIHVwZGF0ZUF4aXNab29tKGNhbGxlcklkLCBheGlzSWQsIG5ld1pvb20pIHtcbiAgICB0aGlzLmF4aXNab29tTWFuYWdlcnMuZ2V0KGF4aXNJZCk/LnVwZGF0ZVpvb20oY2FsbGVySWQsIG5ld1pvb20pO1xuICAgIHRoaXMuYXBwbHlDaGFuZ2VzKGNhbGxlcklkKTtcbiAgfVxuICAvLyBGaXJlIHRoaXMgZXZlbnQgdG8gc2lnbmFsIHRvIGxpc3RlbmVycyB0aGF0IHRoZSB2aWV3IGlzIGNoYW5naW5nIHRocm91Z2ggYSB6b29tIGFuZC9vciBwYW4gY2hhbmdlLlxuICBmaXJlWm9vbVBhblN0YXJ0RXZlbnQoY2FsbGVySWQpIHtcbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcInpvb20tcGFuLXN0YXJ0XCIsIHsgdHlwZTogXCJ6b29tLXBhbi1zdGFydFwiLCBjYWxsZXJJZCB9KTtcbiAgfVxuICBnZXRab29tKCkge1xuICAgIGxldCB4O1xuICAgIGxldCB5O1xuICAgIHRoaXMuYXhpc1pvb21NYW5hZ2Vycy5mb3JFYWNoKChheGlzKSA9PiB7XG4gICAgICBpZiAoYXhpcy5nZXREaXJlY3Rpb24oKSA9PT0gXCJ4XCIgLyogWCAqLykge1xuICAgICAgICB4ID8/ICh4ID0gYXhpcy5nZXRab29tKCkpO1xuICAgICAgfSBlbHNlIGlmIChheGlzLmdldERpcmVjdGlvbigpID09PSBcInlcIiAvKiBZICovKSB7XG4gICAgICAgIHkgPz8gKHkgPSBheGlzLmdldFpvb20oKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHggfHwgeSkge1xuICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH1cbiAgfVxuICBnZXRBeGlzWm9vbShheGlzSWQpIHtcbiAgICByZXR1cm4gdGhpcy5heGlzWm9vbU1hbmFnZXJzLmdldChheGlzSWQpPy5nZXRab29tKCkgPz8geyBtaW46IDAsIG1heDogMSB9O1xuICB9XG4gIGdldEF4aXNab29tcygpIHtcbiAgICBjb25zdCBheGVzID0ge307XG4gICAgZm9yIChjb25zdCBbYXhpc0lkLCBheGlzXSBvZiB0aGlzLmF4aXNab29tTWFuYWdlcnMuZW50cmllcygpKSB7XG4gICAgICBheGVzW2F4aXNJZF0gPSB7XG4gICAgICAgIGRpcmVjdGlvbjogYXhpcy5nZXREaXJlY3Rpb24oKSxcbiAgICAgICAgem9vbTogYXhpcy5nZXRab29tKClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBheGVzO1xuICB9XG4gIGFwcGx5Q2hhbmdlcyhjYWxsZXJJZCkge1xuICAgIGNvbnN0IGNoYW5nZWQgPSBBcnJheS5mcm9tKHRoaXMuYXhpc1pvb21NYW5hZ2Vycy52YWx1ZXMoKSwgKGF4aXMpID0+IGF4aXMuYXBwbHlDaGFuZ2VzKCkpLnNvbWUoQm9vbGVhbik7XG4gICAgaWYgKCFjaGFuZ2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGF4ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IFtheGlzSWQsIGF4aXNdIG9mIHRoaXMuYXhpc1pvb21NYW5hZ2Vycy5lbnRyaWVzKCkpIHtcbiAgICAgIGF4ZXNbYXhpc0lkXSA9IGF4aXMuZ2V0Wm9vbSgpO1xuICAgIH1cbiAgICB0aGlzLmxpc3RlbmVycy5kaXNwYXRjaChcInpvb20tY2hhbmdlXCIsIHsgdHlwZTogXCJ6b29tLWNoYW5nZVwiLCAuLi50aGlzLmdldFpvb20oKSwgYXhlcywgY2FsbGVySWQgfSk7XG4gIH1cbn07XG52YXIgQXhpc1pvb21NYW5hZ2VyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihheGlzKSB7XG4gICAgdGhpcy5heGlzID0gYXhpcztcbiAgICBjb25zdCBbbWluID0gMCwgbWF4ID0gMV0gPSBheGlzLnZpc2libGVSYW5nZTtcbiAgICB0aGlzLnN0YXRlID0gbmV3IFN0YXRlVHJhY2tlcih7IG1pbiwgbWF4IH0pO1xuICAgIHRoaXMuY3VycmVudFpvb20gPSB0aGlzLnN0YXRlLnN0YXRlVmFsdWUoKTtcbiAgfVxuICBnZXREaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXhpcy5kaXJlY3Rpb247XG4gIH1cbiAgdXBkYXRlWm9vbShjYWxsZXJJZCwgbmV3Wm9vbSkge1xuICAgIHRoaXMuc3RhdGUuc2V0KGNhbGxlcklkLCBuZXdab29tKTtcbiAgfVxuICBnZXRab29tKCkge1xuICAgIHJldHVybiBkZWVwQ2xvbmUodGhpcy5zdGF0ZS5zdGF0ZVZhbHVlKCkpO1xuICB9XG4gIGFwcGx5Q2hhbmdlcygpIHtcbiAgICBjb25zdCBwcmV2Wm9vbSA9IHRoaXMuY3VycmVudFpvb207XG4gICAgdGhpcy5jdXJyZW50Wm9vbSA9IHRoaXMuc3RhdGUuc3RhdGVWYWx1ZSgpO1xuICAgIHJldHVybiBwcmV2Wm9vbS5taW4gIT09IHRoaXMuY3VycmVudFpvb20ubWluIHx8IHByZXZab29tLm1heCAhPT0gdGhpcy5jdXJyZW50Wm9vbS5tYXg7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2tleWJvYXJkLnRzXG52YXIgS2V5Ym9hcmQgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBLZXlib2FyZC5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIEtleWJvYXJkLnByb3RvdHlwZSwgXCJ0YWJJbmRleFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFwcGluZy9wcmVwYXJlQXhpcy50c1xudmFyIENhcnRlc2lhbkF4aXNQb3NpdGlvbnMgPSBbXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIl07XG5mdW5jdGlvbiBpc0F4aXNQb3NpdGlvbihwb3NpdGlvbikge1xuICByZXR1cm4gdHlwZW9mIHBvc2l0aW9uID09PSBcInN0cmluZ1wiICYmIENhcnRlc2lhbkF4aXNQb3NpdGlvbnMuaW5jbHVkZXMocG9zaXRpb24pO1xufVxuZnVuY3Rpb24gZ3Vlc3NJbnZhbGlkUG9zaXRpb25zKGF4ZXMpIHtcbiAgY29uc3QgaW52YWxpZEF4ZXMgPSBbXTtcbiAgY29uc3QgdXNlZFBvc2l0aW9ucyA9IFtdO1xuICBjb25zdCBndWVzc2VzID0gWy4uLkNhcnRlc2lhbkF4aXNQb3NpdGlvbnNdO1xuICBmb3IgKGNvbnN0IGF4aXMgb2YgYXhlcykge1xuICAgIGlmIChheGlzIGluc3RhbmNlb2YgQ2FydGVzaWFuQXhpcykge1xuICAgICAgaWYgKGlzQXhpc1Bvc2l0aW9uKGF4aXMucG9zaXRpb24pKSB7XG4gICAgICAgIHVzZWRQb3NpdGlvbnMucHVzaChheGlzLnBvc2l0aW9uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGludmFsaWRBeGVzLnB1c2goYXhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgYXhpcyBvZiBpbnZhbGlkQXhlcykge1xuICAgIGxldCBuZXh0R3Vlc3M7XG4gICAgZG8ge1xuICAgICAgbmV4dEd1ZXNzID0gZ3Vlc3Nlcy5wb3AoKTtcbiAgICB9IHdoaWxlIChuZXh0R3Vlc3MgJiYgdXNlZFBvc2l0aW9ucy5pbmNsdWRlcyhuZXh0R3Vlc3MpKTtcbiAgICBpZiAobmV4dEd1ZXNzID09IG51bGwpXG4gICAgICBicmVhaztcbiAgICBheGlzLnBvc2l0aW9uID0gbmV4dEd1ZXNzO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcHBpbmcvcHJlcGFyZVNlcmllcy50c1xudmFyIE1BVENISU5HX0tFWVMgPSBbXCJkaXJlY3Rpb25cIiwgXCJ4S2V5XCIsIFwieUtleVwiLCBcInNpemVLZXlcIiwgXCJhbmdsZUtleVwiLCBcInJhZGl1c0tleVwiLCBcIm5vcm1hbGl6ZWRUb1wiXTtcbmZ1bmN0aW9uIG1hdGNoU2VyaWVzT3B0aW9ucyhzZXJpZXMsIG9wdFNlcmllcywgb2xkT3B0c1Nlcmllcykge1xuICBjb25zdCBnZW5lcmF0ZUtleSA9ICh0eXBlLCBpLCBvcHRzKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gW3R5cGVdO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE1BVENISU5HX0tFWVMpIHtcbiAgICAgIGlmIChrZXkgaW4gaSAmJiBpW2tleV0gIT0gbnVsbClcbiAgICAgICAgcmVzdWx0LnB1c2goYCR7a2V5fT0ke2lba2V5XX1gKTtcbiAgICB9XG4gICAgaWYgKG9wdHM/LnNlcmllc0dyb3VwaW5nKSB7XG4gICAgICByZXN1bHQucHVzaChgc2VyaWVzR3JvdXBpbmcuZ3JvdXBJZD0ke29wdHM/LnNlcmllc0dyb3VwaW5nLmdyb3VwSWR9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuam9pbihcIjtcIik7XG4gIH07XG4gIGNvbnN0IHNlcmllc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGxldCBpZHggPSAwO1xuICBmb3IgKGNvbnN0IHMgb2Ygc2VyaWVzKSB7XG4gICAgY29uc3Qga2V5ID0gZ2VuZXJhdGVLZXkocy50eXBlLCBzLnByb3BlcnRpZXMsIG9sZE9wdHNTZXJpZXM/LltpZHhdKTtcbiAgICBpZiAoIXNlcmllc01hcC5oYXMoa2V5KSkge1xuICAgICAgc2VyaWVzTWFwLnNldChrZXksIFtdKTtcbiAgICB9XG4gICAgc2VyaWVzTWFwLmdldChrZXkpPy5wdXNoKFtzLCBpZHgrK10pO1xuICB9XG4gIGNvbnN0IG9wdHNNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmb3IgKGNvbnN0IG8gb2Ygb3B0U2VyaWVzKSB7XG4gICAgY29uc3Qga2V5ID0gZ2VuZXJhdGVLZXkoby50eXBlLCBvLCBvKTtcbiAgICBpZiAoIW9wdHNNYXAuaGFzKGtleSkpIHtcbiAgICAgIG9wdHNNYXAuc2V0KGtleSwgW10pO1xuICAgIH1cbiAgICBvcHRzTWFwLmdldChrZXkpPy5wdXNoKG8pO1xuICB9XG4gIGNvbnN0IG92ZXJsYXAgPSBbLi4uc2VyaWVzTWFwLmtleXMoKV0uc29tZSgoaykgPT4gb3B0c01hcC5oYXMoaykpO1xuICBpZiAoIW92ZXJsYXApIHtcbiAgICByZXR1cm4geyBzdGF0dXM6IFwibm8tb3ZlcmxhcFwiLCBvbGRLZXlzOiBzZXJpZXNNYXAua2V5cygpLCBuZXdLZXlzOiBvcHRzTWFwLmtleXMoKSB9O1xuICB9XG4gIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgbGV0IHRhcmdldElkeCA9IC0xO1xuICBmb3IgKGNvbnN0IFtrZXksIG9wdEFycmF5XSBvZiBvcHRzTWFwLmVudHJpZXMoKSkge1xuICAgIGZvciAoY29uc3Qgb3B0cyBvZiBvcHRBcnJheSkge1xuICAgICAgdGFyZ2V0SWR4Kys7XG4gICAgICBjb25zdCBzZXJpZXNBcnJheSA9IHNlcmllc01hcC5nZXQoa2V5KTtcbiAgICAgIGlmIChzZXJpZXNBcnJheSA9PSBudWxsIHx8IHNlcmllc0FycmF5Lmxlbmd0aCA8IDEpIHtcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgb3B0cywgaWR4OiB0YXJnZXRJZHgsIHN0YXR1czogXCJhZGRcIiB9KTtcbiAgICAgICAgc2VyaWVzTWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFtvdXRwdXRTZXJpZXMsIG91dHB1dElkeF0gPSBzZXJpZXNBcnJheS5zaGlmdCgpO1xuICAgICAgY29uc3QgcHJldmlvdXNPcHRzID0gb2xkT3B0c1Nlcmllcz8uW291dHB1dElkeF0gPz8ge307XG4gICAgICBjb25zdCBkaWZmMiA9IGpzb25EaWZmKHByZXZpb3VzT3B0cywgb3B0cyA/PyB7fSk7XG4gICAgICBjb25zdCB7IGdyb3VwSW5kZXgsIHN0YWNrSW5kZXggfSA9IGRpZmYyPy5zZXJpZXNHcm91cGluZyA/PyB7fTtcbiAgICAgIGlmIChncm91cEluZGV4ICE9IG51bGwgfHwgc3RhY2tJbmRleCAhPSBudWxsKSB7XG4gICAgICAgIGNoYW5nZXMucHVzaCh7IG9wdHMsIHNlcmllczogb3V0cHV0U2VyaWVzLCBkaWZmOiBkaWZmMiwgaWR4OiBvdXRwdXRJZHgsIHN0YXR1czogXCJzZXJpZXMtZ3JvdXBpbmdcIiB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZGlmZjIpIHtcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgb3B0cywgc2VyaWVzOiBvdXRwdXRTZXJpZXMsIGRpZmY6IGRpZmYyLCBpZHg6IG91dHB1dElkeCwgc3RhdHVzOiBcInVwZGF0ZVwiIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hhbmdlcy5wdXNoKHsgb3B0cywgc2VyaWVzOiBvdXRwdXRTZXJpZXMsIGlkeDogb3V0cHV0SWR4LCBzdGF0dXM6IFwibm8tb3BcIiB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXJpZXNBcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2VyaWVzTWFwLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IHNlcmllc0FycmF5IG9mIHNlcmllc01hcC52YWx1ZXMoKSkge1xuICAgIGZvciAoY29uc3QgW291dHB1dFNlcmllcywgb3V0cHV0SWR4XSBvZiBzZXJpZXNBcnJheSkge1xuICAgICAgY2hhbmdlcy5wdXNoKHsgc2VyaWVzOiBvdXRwdXRTZXJpZXMsIGlkeDogb3V0cHV0SWR4LCBzdGF0dXM6IFwicmVtb3ZlXCIgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHN0YXR1czogXCJvdmVybGFwXCIsIGNoYW5nZXMgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFwcGluZy90eXBlcy50c1xuZnVuY3Rpb24gb3B0aW9uc1R5cGUoaW5wdXQpIHtcbiAgcmV0dXJuIGlucHV0LnNlcmllcz8uWzBdPy50eXBlID8/IFwibGluZVwiO1xufVxuZnVuY3Rpb24gaXNBZ0NhcnRlc2lhbkNoYXJ0T3B0aW9ucyhpbnB1dCkge1xuICBjb25zdCBzcGVjaWZpZWRUeXBlID0gb3B0aW9uc1R5cGUoaW5wdXQpO1xuICBpZiAoc3BlY2lmaWVkVHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHNwZWNpZmllZFR5cGUgPT09IFwiY2FydGVzaWFuXCIpIHtcbiAgICBMb2dnZXIud2Fybk9uY2UoYHR5cGUgJyR7c3BlY2lmaWVkVHlwZX0nIGlzIGRlcHJlY2F0ZWQsIHVzZSBhIHNlcmllcyB0eXBlIGluc3RlYWRgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gY2hhcnRUeXBlcy5pc0NhcnRlc2lhbihzcGVjaWZpZWRUeXBlKSB8fCBpc0VudGVycHJpc2VDYXJ0ZXNpYW4oc3BlY2lmaWVkVHlwZSk7XG59XG5mdW5jdGlvbiBpc0FnUG9sYXJDaGFydE9wdGlvbnMoaW5wdXQpIHtcbiAgY29uc3Qgc3BlY2lmaWVkVHlwZSA9IG9wdGlvbnNUeXBlKGlucHV0KTtcbiAgaWYgKHNwZWNpZmllZFR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoc3BlY2lmaWVkVHlwZSA9PT0gXCJwb2xhclwiKSB7XG4gICAgTG9nZ2VyLndhcm5PbmNlKGB0eXBlICcke3NwZWNpZmllZFR5cGV9JyBpcyBkZXByZWNhdGVkLCB1c2UgYSBzZXJpZXMgdHlwZSBpbnN0ZWFkYCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGNoYXJ0VHlwZXMuaXNQb2xhcihzcGVjaWZpZWRUeXBlKSB8fCBpc0VudGVycHJpc2VQb2xhcihzcGVjaWZpZWRUeXBlKTtcbn1cbmZ1bmN0aW9uIGlzQWdIaWVyYXJjaHlDaGFydE9wdGlvbnMoaW5wdXQpIHtcbiAgY29uc3Qgc3BlY2lmaWVkVHlwZSA9IG9wdGlvbnNUeXBlKGlucHV0KTtcbiAgaWYgKHNwZWNpZmllZFR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoc3BlY2lmaWVkVHlwZSA9PT0gXCJoaWVyYXJjaHlcIikge1xuICAgIExvZ2dlci53YXJuT25jZShgdHlwZSAnJHtzcGVjaWZpZWRUeXBlfScgaXMgZGVwcmVjYXRlZCwgdXNlIGEgc2VyaWVzIHR5cGUgaW5zdGVhZGApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBjaGFydFR5cGVzLmlzSGllcmFyY2h5KHNwZWNpZmllZFR5cGUpIHx8IGlzRW50ZXJwcmlzZUhpZXJhcmNoeShzcGVjaWZpZWRUeXBlKTtcbn1cbmZ1bmN0aW9uIGlzQWdUb3BvbG9neUNoYXJ0T3B0aW9ucyhpbnB1dCkge1xuICBjb25zdCBzcGVjaWZpZWRUeXBlID0gb3B0aW9uc1R5cGUoaW5wdXQpO1xuICBpZiAoc3BlY2lmaWVkVHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChzcGVjaWZpZWRUeXBlID09PSBcInRvcG9sb2d5XCIpIHtcbiAgICBMb2dnZXIud2Fybk9uY2UoYHR5cGUgJyR7c3BlY2lmaWVkVHlwZX0nIGlzIGRlcHJlY2F0ZWQsIHVzZSBhIHNlcmllcyB0eXBlIGluc3RlYWRgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gY2hhcnRUeXBlcy5pc1RvcG9sb2d5KHNwZWNpZmllZFR5cGUpIHx8IGlzRW50ZXJwcmlzZVRvcG9sb2d5KHNwZWNpZmllZFR5cGUpO1xufVxuZnVuY3Rpb24gaXNBZ0Zsb3dQcm9wb3J0aW9uQ2hhcnRPcHRpb25zKGlucHV0KSB7XG4gIGNvbnN0IHNwZWNpZmllZFR5cGUgPSBvcHRpb25zVHlwZShpbnB1dCk7XG4gIGlmIChzcGVjaWZpZWRUeXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKHNwZWNpZmllZFR5cGUgPT09IFwiZmxvdy1wcm9wb3J0aW9uXCIpIHtcbiAgICBMb2dnZXIud2Fybk9uY2UoYHR5cGUgJyR7c3BlY2lmaWVkVHlwZX0nIGlzIGRlcHJlY2F0ZWQsIHVzZSBhIHNlcmllcyB0eXBlIGluc3RlYWRgKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gY2hhcnRUeXBlcy5pc0Zsb3dQcm9wb3J0aW9uKHNwZWNpZmllZFR5cGUpIHx8IGlzRW50ZXJwcmlzZUZsb3dQcm9wb3J0aW9uKHNwZWNpZmllZFR5cGUpO1xufVxuZnVuY3Rpb24gaXNBZ1BvbGFyQ2hhcnRPcHRpb25zV2l0aFNlcmllc0Jhc2VkTGVnZW5kKGlucHV0KSB7XG4gIGNvbnN0IHNwZWNpZmllZFR5cGUgPSBvcHRpb25zVHlwZShpbnB1dCk7XG4gIHJldHVybiBpc0FnUG9sYXJDaGFydE9wdGlvbnMoaW5wdXQpICYmIHNwZWNpZmllZFR5cGUgIT09IFwicGllXCIgJiYgc3BlY2lmaWVkVHlwZSAhPT0gXCJkb251dFwiO1xufVxuZnVuY3Rpb24gaXNTZXJpZXNPcHRpb25UeXBlKGlucHV0KSB7XG4gIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBjaGFydFR5cGVzLmhhcyhpbnB1dCk7XG59XG5mdW5jdGlvbiBpc0F4aXNPcHRpb25UeXBlKGlucHV0KSB7XG4gIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBheGlzUmVnaXN0cnkuaGFzKGlucHV0KTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbW9kdWxlc01hbmFnZXIudHNcbnZhciBNb2R1bGVzTWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgTW9kdWxlTWFwIHtcbiAgYXBwbHlPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBmb3IgKGNvbnN0IG0gb2YgdGhpcy5tb2R1bGVNYXAudmFsdWVzKCkpIHtcbiAgICAgIGlmIChtLm1vZHVsZS5vcHRpb25zS2V5IGluIG9wdGlvbnMgJiYgaXNQcm9wZXJ0aWVzKG0ubW9kdWxlSW5zdGFuY2UpKSB7XG4gICAgICAgIG0ubW9kdWxlSW5zdGFuY2Uuc2V0KG9wdGlvbnNbbS5tb2R1bGUub3B0aW9uc0tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAqbGVnZW5kcygpIHtcbiAgICBmb3IgKGNvbnN0IHsgbW9kdWxlLCBtb2R1bGVJbnN0YW5jZSB9IG9mIHRoaXMubW9kdWxlTWFwLnZhbHVlcygpKSB7XG4gICAgICBpZiAobW9kdWxlLnR5cGUgIT09IFwibGVnZW5kXCIpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgeWllbGQge1xuICAgICAgICBsZWdlbmRUeXBlOiBtb2R1bGUuaWRlbnRpZmllcixcbiAgICAgICAgbGVnZW5kOiBtb2R1bGVJbnN0YW5jZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L292ZXJsYXkvb3ZlcmxheS50c1xudmFyIERFRkFVTFRfT1ZFUkxBWV9DTEFTUyA9IFwiYWctY2hhcnQtb3ZlcmxheVwiO1xudmFyIERFRkFVTFRfT1ZFUkxBWV9EQVJLX0NMQVNTID0gXCJhZy1jaGFydC1kYXJrLW92ZXJsYXlcIjtcbnZhciBPdmVybGF5ID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKGNsYXNzTmFtZSwgZGVmYXVsdE1lc3NhZ2VJZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgdGhpcy5kZWZhdWx0TWVzc2FnZUlkID0gZGVmYXVsdE1lc3NhZ2VJZDtcbiAgfVxuICBnZXRUZXh0KGxvY2FsZU1hbmFnZXIpIHtcbiAgICByZXR1cm4gbG9jYWxlTWFuYWdlci50KHRoaXMudGV4dCA/PyB0aGlzLmRlZmF1bHRNZXNzYWdlSWQpO1xuICB9XG4gIGdldEVsZW1lbnQoYW5pbWF0aW9uTWFuYWdlciwgbG9jYWxlTWFuYWdlciwgcmVjdCkge1xuICAgIHRoaXMuY29udGVudD8ucmVtb3ZlKCk7XG4gICAgdGhpcy5mb2N1c0JveCA9IHJlY3Q7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIpIHtcbiAgICAgIGNvbnN0IGh0bWxDb250ZW50ID0gdGhpcy5yZW5kZXJlcigpO1xuICAgICAgaWYgKGh0bWxDb250ZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gaHRtbENvbnRlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZW1wRGl2ID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGVtcERpdi5pbm5lckhUTUwgPSBodG1sQ29udGVudDtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gdGVtcERpdi5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29udGVudCA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICAgICAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gICAgICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIG1hcmdpbjogXCI4cHhcIixcbiAgICAgICAgZm9udDogXCIxMnB4IFZlcmRhbmEsIHNhbnMtc2VyaWZcIlxuICAgICAgfSk7XG4gICAgICBjb250ZW50LmlubmVyVGV4dCA9IHRoaXMuZ2V0VGV4dChsb2NhbGVNYW5hZ2VyKTtcbiAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICBhbmltYXRpb25NYW5hZ2VyPy5hbmltYXRlKHtcbiAgICAgICAgZnJvbTogMCxcbiAgICAgICAgdG86IDEsXG4gICAgICAgIGlkOiBcIm92ZXJsYXlcIixcbiAgICAgICAgcGhhc2U6IFwiYWRkXCIsXG4gICAgICAgIGdyb3VwSWQ6IFwib3BhY2l0eVwiLFxuICAgICAgICBvblVwZGF0ZSh2YWx1ZSkge1xuICAgICAgICAgIGNvbnRlbnQuc3R5bGUub3BhY2l0eSA9IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU3RvcCgpIHtcbiAgICAgICAgICBjb250ZW50LnN0eWxlLm9wYWNpdHkgPSBcIjFcIjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRlbnQ7XG4gIH1cbiAgcmVtb3ZlRWxlbWVudChjbGVhbnVwID0gKCkgPT4gdGhpcy5jb250ZW50Py5yZW1vdmUoKSwgYW5pbWF0aW9uTWFuYWdlcikge1xuICAgIGlmICghdGhpcy5jb250ZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChhbmltYXRpb25NYW5hZ2VyKSB7XG4gICAgICBjb25zdCB7IGNvbnRlbnQgfSA9IHRoaXM7XG4gICAgICBhbmltYXRpb25NYW5hZ2VyLmFuaW1hdGUoe1xuICAgICAgICBmcm9tOiAxLFxuICAgICAgICB0bzogMCxcbiAgICAgICAgcGhhc2U6IFwicmVtb3ZlXCIsXG4gICAgICAgIGlkOiBcIm92ZXJsYXlcIixcbiAgICAgICAgZ3JvdXBJZDogXCJvcGFjaXR5XCIsXG4gICAgICAgIG9uVXBkYXRlKHZhbHVlKSB7XG4gICAgICAgICAgY29udGVudC5zdHlsZS5vcGFjaXR5ID0gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TdG9wKCkge1xuICAgICAgICAgIGNsZWFudXA/LigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xlYW51cD8uKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGVudCA9IHZvaWQgMDtcbiAgICB0aGlzLmZvY3VzQm94ID0gdm9pZCAwO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBPdmVybGF5LnByb3RvdHlwZSwgXCJ0ZXh0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIE92ZXJsYXkucHJvdG90eXBlLCBcInJlbmRlcmVyXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9vdmVybGF5L2NoYXJ0T3ZlcmxheXMudHNcbnZhciBDaGFydE92ZXJsYXlzID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5kYXJrVGhlbWUgPSBmYWxzZTtcbiAgICB0aGlzLmxvYWRpbmcgPSBuZXcgT3ZlcmxheShcImFnLWNoYXJ0LWxvYWRpbmctb3ZlcmxheVwiLCBcIm92ZXJsYXlMb2FkaW5nRGF0YVwiKTtcbiAgICB0aGlzLm5vRGF0YSA9IG5ldyBPdmVybGF5KFwiYWctY2hhcnQtbm8tZGF0YS1vdmVybGF5XCIsIFwib3ZlcmxheU5vRGF0YVwiKTtcbiAgICB0aGlzLm5vVmlzaWJsZVNlcmllcyA9IG5ldyBPdmVybGF5KFwiYWctY2hhcnQtbm8tdmlzaWJsZS1zZXJpZXNcIiwgXCJvdmVybGF5Tm9WaXNpYmxlU2VyaWVzXCIpO1xuICB9XG4gIGdldEZvY3VzSW5mbyhsb2NhbGVNYW5hZ2VyKSB7XG4gICAgZm9yIChjb25zdCBvdmVybGF5IG9mIFt0aGlzLmxvYWRpbmcsIHRoaXMubm9EYXRhLCB0aGlzLm5vVmlzaWJsZVNlcmllc10pIHtcbiAgICAgIGlmIChvdmVybGF5LmZvY3VzQm94ICE9PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHsgdGV4dDogb3ZlcmxheS5nZXRUZXh0KGxvY2FsZU1hbmFnZXIpLCByZWN0OiBvdmVybGF5LmZvY3VzQm94IH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmxvYWRpbmcucmVtb3ZlRWxlbWVudCgpO1xuICAgIHRoaXMubm9EYXRhLnJlbW92ZUVsZW1lbnQoKTtcbiAgICB0aGlzLm5vVmlzaWJsZVNlcmllcy5yZW1vdmVFbGVtZW50KCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgQ2hhcnRPdmVybGF5cy5wcm90b3R5cGUsIFwiZGFya1RoZW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQ2hhcnRPdmVybGF5cy5wcm90b3R5cGUsIFwibG9hZGluZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIENoYXJ0T3ZlcmxheXMucHJvdG90eXBlLCBcIm5vRGF0YVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIENoYXJ0T3ZlcmxheXMucHJvdG90eXBlLCBcIm5vVmlzaWJsZVNlcmllc1wiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvb3ZlcmxheS9sb2FkaW5nU3Bpbm5lci50c1xuZnVuY3Rpb24gZ2V0TG9hZGluZ1NwaW5uZXIodGV4dCwgZGVmYXVsdER1cmF0aW9uKSB7XG4gIGNvbnN0IHsgYW5pbWF0aW9uRHVyYXRpb24gfSA9IFBIQVNFX01FVEFEQVRBW1wiYWRkXCJdO1xuICBjb25zdCBkdXJhdGlvbiA9IGFuaW1hdGlvbkR1cmF0aW9uICogZGVmYXVsdER1cmF0aW9uO1xuICBjb25zdCBjb250YWluZXIgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIGAke0RFRkFVTFRfT1ZFUkxBWV9DTEFTU30tLWxvYWRpbmdgLCB7XG4gICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICBqdXN0aWZ5Q29udGVudDogXCJjZW50ZXJcIixcbiAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICBmb250OiBcIjEzcHggVmVyZGFuYSwgc2Fucy1zZXJpZlwiLFxuICAgIC8vIEZPTlRfU0laRS5NRURJVU1cbiAgICB1c2VyU2VsZWN0OiBcIm5vbmVcIixcbiAgICBhbmltYXRpb246IGBhZy1jaGFydHMtbG9hZGluZyAke2R1cmF0aW9ufW1zIGxpbmVhciA1MG1zIGJvdGhgXG4gIH0pO1xuICBjb25zdCBtYXRyaXggPSBjcmVhdGVFbGVtZW50KFwic3BhblwiLCB7XG4gICAgd2lkdGg6IFwiNDVweFwiLFxuICAgIGhlaWdodDogXCI0MHB4XCIsXG4gICAgYmFja2dyb3VuZEltYWdlOiBbXG4gICAgICBcImxpbmVhci1ncmFkaWVudCgjMDAwMCBjYWxjKDEgKiAxMDAlIC8gNiksICNjY2MgMCBjYWxjKDMgKiAxMDAlIC8gNiksICMwMDAwIDApLCBcIixcbiAgICAgIFwibGluZWFyLWdyYWRpZW50KCMwMDAwIGNhbGMoMiAqIDEwMCUgLyA2KSwgI2NjYyAwIGNhbGMoNCAqIDEwMCUgLyA2KSwgIzAwMDAgMCksIFwiLFxuICAgICAgXCJsaW5lYXItZ3JhZGllbnQoIzAwMDAgY2FsYygzICogMTAwJSAvIDYpLCAjY2NjIDAgY2FsYyg1ICogMTAwJSAvIDYpLCAjMDAwMCAwKVwiXG4gICAgXS5qb2luKFwiXCIpLFxuICAgIGJhY2tncm91bmRTaXplOiBcIjEwcHggNDAwJVwiLFxuICAgIGJhY2tncm91bmRSZXBlYXQ6IFwibm8tcmVwZWF0XCIsXG4gICAgYW5pbWF0aW9uOiBcImFnLWNoYXJ0cy1sb2FkaW5nLW1hdHJpeCAxcyBpbmZpbml0ZSBsaW5lYXJcIlxuICB9KTtcbiAgY29uc3QgbGFiZWwgPSBjcmVhdGVFbGVtZW50KFwicFwiLCB7IG1hcmdpblRvcDogXCIxZW1cIiB9KTtcbiAgbGFiZWwuaW5uZXJUZXh0ID0gdGV4dDtcbiAgY29uc3QgYmFja2dyb3VuZCA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgYCR7REVGQVVMVF9PVkVSTEFZX0NMQVNTfV9fbG9hZGluZy1iYWNrZ3JvdW5kYCwge1xuICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgaW5zZXQ6IFwiMFwiLFxuICAgIG9wYWNpdHk6IFwiMC41XCIsXG4gICAgekluZGV4OiBcIi0xXCJcbiAgfSk7XG4gIGNvbnN0IGFuaW1hdGlvblN0eWxlcyA9IGNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgYW5pbWF0aW9uU3R5bGVzLmlubmVyVGV4dCA9IFtcbiAgICBcIkBrZXlmcmFtZXMgYWctY2hhcnRzLWxvYWRpbmcgeyBmcm9tIHsgb3BhY2l0eTogMCB9IHRvIHsgb3BhY2l0eTogMSB9IH1cIixcbiAgICBcIkBrZXlmcmFtZXMgYWctY2hhcnRzLWxvYWRpbmctbWF0cml4IHtcIixcbiAgICBcIjAlIHsgYmFja2dyb3VuZC1wb3NpdGlvbjogMCUgMCUsIDUwJSAwJSwgMTAwJSAwJTsgfVwiLFxuICAgIFwiMTAwJSB7IGJhY2tncm91bmQtcG9zaXRpb246IDAlIDEwMCUsIDUwJSAxMDAlLCAxMDAlIDEwMCU7IH1cIixcbiAgICBcIn1cIlxuICBdLmpvaW4oXCIgXCIpO1xuICBjb250YWluZXIucmVwbGFjZUNoaWxkcmVuKGFuaW1hdGlvblN0eWxlcywgbWF0cml4LCBsYWJlbCwgYmFja2dyb3VuZCk7XG4gIHJldHVybiBjb250YWluZXI7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2RhdGEvYWdncmVnYXRlRnVuY3Rpb25zLnRzXG5mdW5jdGlvbiBzdW1WYWx1ZXModmFsdWVzLCBhY2N1bXVsYXRvciA9IFswLCAwXSkge1xuICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICBhY2N1bXVsYXRvclswXSArPSB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID4gMCkge1xuICAgICAgYWNjdW11bGF0b3JbMV0gKz0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cbmZ1bmN0aW9uIHN1bShpZCwgbWF0Y2hHcm91cElkKSB7XG4gIGNvbnN0IHJlc3VsdCA9IHtcbiAgICBpZCxcbiAgICBtYXRjaEdyb3VwSWRzOiBbbWF0Y2hHcm91cElkXSxcbiAgICB0eXBlOiBcImFnZ3JlZ2F0ZVwiLFxuICAgIGFnZ3JlZ2F0ZUZ1bmN0aW9uOiAodmFsdWVzKSA9PiBzdW1WYWx1ZXModmFsdWVzKVxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ3JvdXBTdW0oaWQsIG1hdGNoR3JvdXBJZCkge1xuICByZXR1cm4ge1xuICAgIGlkLFxuICAgIHR5cGU6IFwiYWdncmVnYXRlXCIsXG4gICAgbWF0Y2hHcm91cElkczogbWF0Y2hHcm91cElkID8gW21hdGNoR3JvdXBJZF0gOiB2b2lkIDAsXG4gICAgYWdncmVnYXRlRnVuY3Rpb246ICh2YWx1ZXMpID0+IHN1bVZhbHVlcyh2YWx1ZXMpLFxuICAgIGdyb3VwQWdncmVnYXRlRnVuY3Rpb246IChuZXh0LCBhY2MgPSBbMCwgMF0pID0+IHtcbiAgICAgIGFjY1swXSArPSBuZXh0Py5bMF0gPz8gMDtcbiAgICAgIGFjY1sxXSArPSBuZXh0Py5bMV0gPz8gMDtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gcmFuZ2UyKGlkLCBtYXRjaEdyb3VwSWQpIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIGlkLFxuICAgIG1hdGNoR3JvdXBJZHM6IFttYXRjaEdyb3VwSWRdLFxuICAgIHR5cGU6IFwiYWdncmVnYXRlXCIsXG4gICAgYWdncmVnYXRlRnVuY3Rpb246ICh2YWx1ZXMpID0+IENvbnRpbnVvdXNEb21haW4uZXh0ZW5kRG9tYWluKHZhbHVlcylcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGdyb3VwQ291bnQoaWQpIHtcbiAgcmV0dXJuIHtcbiAgICBpZCxcbiAgICB0eXBlOiBcImFnZ3JlZ2F0ZVwiLFxuICAgIGFnZ3JlZ2F0ZUZ1bmN0aW9uOiAoKSA9PiBbMCwgMV0sXG4gICAgZ3JvdXBBZ2dyZWdhdGVGdW5jdGlvbjogKG5leHQsIGFjYyA9IFswLCAwXSkgPT4ge1xuICAgICAgYWNjWzBdICs9IG5leHQ/LlswXSA/PyAwO1xuICAgICAgYWNjWzFdICs9IG5leHQ/LlsxXSA/PyAwO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBncm91cEF2ZXJhZ2UoaWQsIG1hdGNoR3JvdXBJZCkge1xuICBjb25zdCBkZWYgPSB7XG4gICAgaWQsXG4gICAgbWF0Y2hHcm91cElkczogbWF0Y2hHcm91cElkID8gW21hdGNoR3JvdXBJZF0gOiB2b2lkIDAsXG4gICAgdHlwZTogXCJhZ2dyZWdhdGVcIixcbiAgICBhZ2dyZWdhdGVGdW5jdGlvbjogKHZhbHVlcykgPT4gc3VtVmFsdWVzKHZhbHVlcyksXG4gICAgZ3JvdXBBZ2dyZWdhdGVGdW5jdGlvbjogKG5leHQsIGFjYyA9IFswLCAwLCAtMV0pID0+IHtcbiAgICAgIGFjY1swXSArPSBuZXh0Py5bMF0gPz8gMDtcbiAgICAgIGFjY1sxXSArPSBuZXh0Py5bMV0gPz8gMDtcbiAgICAgIGFjY1syXSsrO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LFxuICAgIGZpbmFsRnVuY3Rpb246IChhY2MgPSBbMCwgMCwgMF0pID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGFjY1swXSArIGFjY1sxXTtcbiAgICAgIGlmIChyZXN1bHQgPj0gMCkge1xuICAgICAgICByZXR1cm4gWzAsIHJlc3VsdCAvIGFjY1syXV07XG4gICAgICB9XG4gICAgICByZXR1cm4gW3Jlc3VsdCAvIGFjY1syXSwgMF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gZGVmO1xufVxuZnVuY3Rpb24gYXJlYShpZCwgYWdnRm4sIG1hdGNoR3JvdXBJZCkge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgaWQsXG4gICAgbWF0Y2hHcm91cElkczogbWF0Y2hHcm91cElkID8gW21hdGNoR3JvdXBJZF0gOiB2b2lkIDAsXG4gICAgdHlwZTogXCJhZ2dyZWdhdGVcIixcbiAgICBhZ2dyZWdhdGVGdW5jdGlvbjogKHZhbHVlcywga2V5UmFuZ2UgPSBbXSkgPT4ge1xuICAgICAgY29uc3Qga2V5V2lkdGggPSBrZXlSYW5nZVsxXSAtIGtleVJhbmdlWzBdO1xuICAgICAgcmV0dXJuIGFnZ0ZuLmFnZ3JlZ2F0ZUZ1bmN0aW9uKHZhbHVlcykubWFwKCh2KSA9PiB2IC8ga2V5V2lkdGgpO1xuICAgIH1cbiAgfTtcbiAgaWYgKGFnZ0ZuLmdyb3VwQWdncmVnYXRlRnVuY3Rpb24pIHtcbiAgICByZXN1bHQuZ3JvdXBBZ2dyZWdhdGVGdW5jdGlvbiA9IGFnZ0ZuLmdyb3VwQWdncmVnYXRlRnVuY3Rpb247XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFjY3VtdWxhdGVkVmFsdWUob25seVBvc2l0aXZlKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGV0IHZhbHVlID0gMDtcbiAgICByZXR1cm4gKGRhdHVtKSA9PiB7XG4gICAgICBpZiAoIWlzRmluaXRlTnVtYmVyKGRhdHVtKSkge1xuICAgICAgICByZXR1cm4gZGF0dW07XG4gICAgICB9XG4gICAgICB2YWx1ZSArPSBvbmx5UG9zaXRpdmUgPyBNYXRoLm1heCgwLCBkYXR1bSkgOiBkYXR1bTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gdHJhaWxpbmdBY2N1bXVsYXRlZFZhbHVlKCkge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgcmV0dXJuIChkYXR1bSkgPT4ge1xuICAgICAgaWYgKCFpc0Zpbml0ZU51bWJlcihkYXR1bSkpIHtcbiAgICAgICAgcmV0dXJuIGRhdHVtO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhaWxpbmdWYWx1ZSA9IHZhbHVlO1xuICAgICAgdmFsdWUgKz0gZGF0dW07XG4gICAgICByZXR1cm4gdHJhaWxpbmdWYWx1ZTtcbiAgICB9O1xuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL21lbW8udHNcbnZhciBtZW1vcml6ZWRGbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIG1lbW8ocGFyYW1zLCBmbkdlbmVyYXRvcikge1xuICBjb25zdCBzZXJpYWxpc2VkUGFyYW1zID0gSlNPTi5zdHJpbmdpZnkocGFyYW1zLCBudWxsLCAwKTtcbiAgaWYgKCFtZW1vcml6ZWRGbnMuaGFzKGZuR2VuZXJhdG9yKSkge1xuICAgIG1lbW9yaXplZEZucy5zZXQoZm5HZW5lcmF0b3IsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICB9XG4gIGlmICghbWVtb3JpemVkRm5zLmdldChmbkdlbmVyYXRvcik/LmhhcyhzZXJpYWxpc2VkUGFyYW1zKSkge1xuICAgIG1lbW9yaXplZEZucy5nZXQoZm5HZW5lcmF0b3IpPy5zZXQoc2VyaWFsaXNlZFBhcmFtcywgZm5HZW5lcmF0b3IocGFyYW1zKSk7XG4gIH1cbiAgcmV0dXJuIG1lbW9yaXplZEZucy5nZXQoZm5HZW5lcmF0b3IpPy5nZXQoc2VyaWFsaXNlZFBhcmFtcyk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2RhdGEvcHJvY2Vzc29ycy50c1xudmFyIFNNQUxMRVNUX0tFWV9JTlRFUlZBTCA9IHtcbiAgdHlwZTogXCJyZWR1Y2VyXCIsXG4gIHByb3BlcnR5OiBcInNtYWxsZXN0S2V5SW50ZXJ2YWxcIixcbiAgaW5pdGlhbFZhbHVlOiBJbmZpbml0eSxcbiAgcmVkdWNlcjogKCkgPT4ge1xuICAgIGxldCBwcmV2WCA9IE5hTjtcbiAgICByZXR1cm4gKHNtYWxsZXN0U29GYXIgPSBJbmZpbml0eSwgbmV4dCkgPT4ge1xuICAgICAgY29uc3QgbmV4dFggPSBuZXh0LmtleXNbMF07XG4gICAgICBjb25zdCBpbnRlcnZhbCA9IE1hdGguYWJzKG5leHRYIC0gcHJldlgpO1xuICAgICAgcHJldlggPSBuZXh0WDtcbiAgICAgIGlmICghaXNOYU4oaW50ZXJ2YWwpICYmIGludGVydmFsID4gMCAmJiBpbnRlcnZhbCA8IHNtYWxsZXN0U29GYXIpIHtcbiAgICAgICAgcmV0dXJuIGludGVydmFsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNtYWxsZXN0U29GYXI7XG4gICAgfTtcbiAgfVxufTtcbnZhciBMQVJHRVNUX0tFWV9JTlRFUlZBTCA9IHtcbiAgdHlwZTogXCJyZWR1Y2VyXCIsXG4gIHByb3BlcnR5OiBcImxhcmdlc3RLZXlJbnRlcnZhbFwiLFxuICBpbml0aWFsVmFsdWU6IC1JbmZpbml0eSxcbiAgcmVkdWNlcjogKCkgPT4ge1xuICAgIGxldCBwcmV2WCA9IE5hTjtcbiAgICByZXR1cm4gKGxhcmdlc3RTb0ZhciA9IC1JbmZpbml0eSwgbmV4dCkgPT4ge1xuICAgICAgY29uc3QgbmV4dFggPSBuZXh0LmtleXNbMF07XG4gICAgICBjb25zdCBpbnRlcnZhbCA9IE1hdGguYWJzKG5leHRYIC0gcHJldlgpO1xuICAgICAgcHJldlggPSBuZXh0WDtcbiAgICAgIGlmICghaXNOYU4oaW50ZXJ2YWwpICYmIGludGVydmFsID4gMCAmJiBpbnRlcnZhbCA+IGxhcmdlc3RTb0Zhcikge1xuICAgICAgICByZXR1cm4gaW50ZXJ2YWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFyZ2VzdFNvRmFyO1xuICAgIH07XG4gIH1cbn07XG52YXIgU09SVF9ET01BSU5fR1JPVVBTID0ge1xuICB0eXBlOiBcInByb2Nlc3NvclwiLFxuICBwcm9wZXJ0eTogXCJzb3J0ZWRHcm91cERvbWFpblwiLFxuICBjYWxjdWxhdGU6ICh7IGRvbWFpbjogeyBncm91cHMgfSB9KSA9PiBncm91cHM/LnNsaWNlKCkuc29ydCgoYSwgYikgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYVtpXSAtIGJbaV07XG4gICAgICBpZiAocmVzdWx0ICE9PSAwKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9KVxufTtcbmZ1bmN0aW9uIG5vcm1hbGlzZUZuQnVpbGRlcih7IG5vcm1hbGlzZVRvLCBtb2RlIH0pIHtcbiAgY29uc3Qgbm9ybWFsaXNlID0gKHZhbCwgZXh0ZW50MikgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHZhbCAqIG5vcm1hbGlzZVRvIC8gZXh0ZW50MjtcbiAgICBpZiAocmVzdWx0ID49IDApIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihub3JtYWxpc2VUbywgcmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWF4KC1ub3JtYWxpc2VUbywgcmVzdWx0KTtcbiAgfTtcbiAgcmV0dXJuICgpID0+ICgpID0+ICh2YWx1ZXMsIHZhbHVlSW5kZXhlcykgPT4ge1xuICAgIGNvbnN0IHZhbHVlc0V4dGVudCA9IFswLCAwXTtcbiAgICBmb3IgKGNvbnN0IHZhbHVlSWR4IG9mIHZhbHVlSW5kZXhlcykge1xuICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbdmFsdWVJZHhdO1xuICAgICAgY29uc3QgdmFsdWVFeHRlbnQgPSB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgPyB2YWx1ZSA6IE1hdGgubWF4KC4uLnZhbHVlKTtcbiAgICAgIGNvbnN0IHZhbElkeCA9IHZhbHVlRXh0ZW50IDwgMCA/IDAgOiAxO1xuICAgICAgaWYgKG1vZGUgPT09IFwic3VtXCIpIHtcbiAgICAgICAgdmFsdWVzRXh0ZW50W3ZhbElkeF0gKz0gdmFsdWVFeHRlbnQ7XG4gICAgICB9IGVsc2UgaWYgKHZhbElkeCA9PT0gMCkge1xuICAgICAgICB2YWx1ZXNFeHRlbnRbdmFsSWR4XSA9IE1hdGgubWluKHZhbHVlc0V4dGVudFt2YWxJZHhdLCB2YWx1ZUV4dGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXNFeHRlbnRbdmFsSWR4XSA9IE1hdGgubWF4KHZhbHVlc0V4dGVudFt2YWxJZHhdLCB2YWx1ZUV4dGVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGV4dGVudDIgPSBNYXRoLm1heChNYXRoLmFicyh2YWx1ZXNFeHRlbnRbMF0pLCB2YWx1ZXNFeHRlbnRbMV0pO1xuICAgIGZvciAoY29uc3QgdmFsdWVJZHggb2YgdmFsdWVJbmRleGVzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1t2YWx1ZUlkeF07XG4gICAgICB2YWx1ZXNbdmFsdWVJZHhdID0gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiID8gbm9ybWFsaXNlKHZhbHVlLCBleHRlbnQyKSA6IHZhbHVlLm1hcCgodikgPT4gbm9ybWFsaXNlKHYsIGV4dGVudDIpKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBub3JtYWxpc2VHcm91cFRvKG1hdGNoR3JvdXBJZHMsIG5vcm1hbGlzZVRvLCBtb2RlID0gXCJzdW1cIikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiZ3JvdXAtdmFsdWUtcHJvY2Vzc29yXCIsXG4gICAgbWF0Y2hHcm91cElkcyxcbiAgICBhZGp1c3Q6IG1lbW8oeyBub3JtYWxpc2VUbywgbW9kZSB9LCBub3JtYWxpc2VGbkJ1aWxkZXIpXG4gIH07XG59XG5mdW5jdGlvbiBub3JtYWxpc2VQcm9wZXJ0eUZuQnVpbGRlcih7XG4gIG5vcm1hbGlzZVRvLFxuICB6ZXJvRG9tYWluLFxuICByYW5nZU1pbixcbiAgcmFuZ2VNYXhcbn0pIHtcbiAgY29uc3Qgbm9ybWFsaXNlU3BhbiA9IG5vcm1hbGlzZVRvWzFdIC0gbm9ybWFsaXNlVG9bMF07XG4gIGNvbnN0IG5vcm1hbGlzZSA9ICh2YWwsIHN0YXJ0LCBzcGFuKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gbm9ybWFsaXNlVG9bMF0gKyAodmFsIC0gc3RhcnQpIC8gc3BhbiAqIG5vcm1hbGlzZVNwYW47XG4gICAgaWYgKHNwYW4gPT09IDApIHtcbiAgICAgIHJldHVybiB6ZXJvRG9tYWluO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0ID49IG5vcm1hbGlzZVRvWzFdKSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXNlVG9bMV07XG4gICAgfSBlbHNlIGlmIChyZXN1bHQgPCBub3JtYWxpc2VUb1swXSkge1xuICAgICAgcmV0dXJuIG5vcm1hbGlzZVRvWzBdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICByZXR1cm4gKCkgPT4gKHBEYXRhLCBwSWR4KSA9PiB7XG4gICAgbGV0IFtzdGFydCwgZW5kXSA9IHBEYXRhLmRvbWFpbi52YWx1ZXNbcElkeF07XG4gICAgaWYgKHJhbmdlTWluICE9IG51bGwpXG4gICAgICBzdGFydCA9IHJhbmdlTWluO1xuICAgIGlmIChyYW5nZU1heCAhPSBudWxsKVxuICAgICAgZW5kID0gcmFuZ2VNYXg7XG4gICAgY29uc3Qgc3BhbiA9IGVuZCAtIHN0YXJ0O1xuICAgIHBEYXRhLmRvbWFpbi52YWx1ZXNbcElkeF0gPSBbbm9ybWFsaXNlVG9bMF0sIG5vcm1hbGlzZVRvWzFdXTtcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIHBEYXRhLmRhdGEpIHtcbiAgICAgIGxldCBncm91cFZhbHVlcyA9IGdyb3VwLnZhbHVlcztcbiAgICAgIGlmIChwRGF0YS50eXBlID09PSBcInVuZ3JvdXBlZFwiKSB7XG4gICAgICAgIGdyb3VwVmFsdWVzID0gW2dyb3VwVmFsdWVzXTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgdmFsdWVzIG9mIGdyb3VwVmFsdWVzKSB7XG4gICAgICAgIHZhbHVlc1twSWR4XSA9IG5vcm1hbGlzZSh2YWx1ZXNbcElkeF0sIHN0YXJ0LCBzcGFuKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBub3JtYWxpc2VQcm9wZXJ0eVRvKHByb3BlcnR5LCBub3JtYWxpc2VUbywgemVyb0RvbWFpbiwgcmFuZ2VNaW4sIHJhbmdlTWF4KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJwcm9wZXJ0eS12YWx1ZS1wcm9jZXNzb3JcIixcbiAgICBwcm9wZXJ0eSxcbiAgICBhZGp1c3Q6IG1lbW8oeyBub3JtYWxpc2VUbywgcmFuZ2VNaW4sIHJhbmdlTWF4LCB6ZXJvRG9tYWluIH0sIG5vcm1hbGlzZVByb3BlcnR5Rm5CdWlsZGVyKVxuICB9O1xufVxuZnVuY3Rpb24gYW5pbWF0aW9uVmFsaWRhdGlvbih2YWx1ZUtleUlkcykge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwicHJvY2Vzc29yXCIsXG4gICAgcHJvcGVydHk6IFwiYW5pbWF0aW9uVmFsaWRhdGlvblwiLFxuICAgIGNhbGN1bGF0ZShyZXN1bHQpIHtcbiAgICAgIGNvbnN0IHsga2V5cywgdmFsdWVzIH0gPSByZXN1bHQuZGVmcztcbiAgICAgIGNvbnN0IHsgaW5wdXQsIGRhdGEgfSA9IHJlc3VsdDtcbiAgICAgIGxldCB1bmlxdWVLZXlzID0gdHJ1ZTtcbiAgICAgIGxldCBvcmRlcmVkS2V5cyA9IHRydWU7XG4gICAgICBjb25zdCB2YWx1ZUtleXMgPSBbXTtcbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdmFsdWVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGlmICghdmFsdWVLZXlJZHM/LmluY2x1ZGVzKHZhbHVlc1trXS5pZCkpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHZhbHVlS2V5cy5wdXNoKFtrLCB2YWx1ZXNba11dKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByb2Nlc3NLZXkgPSAoaWR4LCBkZWYsIHR5cGUpID0+IHtcbiAgICAgICAgaWYgKGRlZi52YWx1ZVR5cGUgPT09IFwiY2F0ZWdvcnlcIikge1xuICAgICAgICAgIGNvbnN0IGtleVZhbHVlcyA9IHJlc3VsdC5kb21haW5bdHlwZV1baWR4XTtcbiAgICAgICAgICB1bmlxdWVLZXlzICYmICh1bmlxdWVLZXlzID0ga2V5VmFsdWVzLmxlbmd0aCA9PT0gaW5wdXQuY291bnQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbGFzdFZhbHVlID0gZGF0YVswXT8uW3R5cGVdW2lkeF07XG4gICAgICAgIGZvciAobGV0IGQgPSAxOyAodW5pcXVlS2V5cyB8fCBvcmRlcmVkS2V5cykgJiYgZCA8IGRhdGEubGVuZ3RoOyBkKyspIHtcbiAgICAgICAgICBjb25zdCBrZXlWYWx1ZSA9IGRhdGFbZF1bdHlwZV1baWR4XTtcbiAgICAgICAgICBvcmRlcmVkS2V5cyAmJiAob3JkZXJlZEtleXMgPSBsYXN0VmFsdWUgPD0ga2V5VmFsdWUpO1xuICAgICAgICAgIHVuaXF1ZUtleXMgJiYgKHVuaXF1ZUtleXMgPSBsYXN0VmFsdWUgIT09IGtleVZhbHVlKTtcbiAgICAgICAgICBsYXN0VmFsdWUgPSBrZXlWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGZvciAobGV0IGsgPSAwOyAodW5pcXVlS2V5cyB8fCBvcmRlcmVkS2V5cykgJiYgayA8IGtleXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgcHJvY2Vzc0tleShrLCBrZXlzW2tdLCBcImtleXNcIik7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBrID0gMDsgKHVuaXF1ZUtleXMgfHwgb3JkZXJlZEtleXMpICYmIGsgPCB2YWx1ZUtleXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgY29uc3QgW2lkeCwga2V5XSA9IHZhbHVlS2V5c1trXTtcbiAgICAgICAgcHJvY2Vzc0tleShpZHgsIGtleSwgXCJ2YWx1ZXNcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4geyB1bmlxdWVLZXlzLCBvcmRlcmVkS2V5cyB9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkR3JvdXBBY2NGbih7IG1vZGUsIHNlcGFyYXRlTmVnYXRpdmUgfSkge1xuICByZXR1cm4gKCkgPT4gKCkgPT4gKHZhbHVlcywgdmFsdWVJbmRleGVzKSA9PiB7XG4gICAgY29uc3QgYWNjID0gWzAsIDBdO1xuICAgIGZvciAoY29uc3QgdmFsdWVJZHggb2YgdmFsdWVJbmRleGVzKSB7XG4gICAgICBjb25zdCBjdXJyZW50VmFsID0gdmFsdWVzW3ZhbHVlSWR4XTtcbiAgICAgIGNvbnN0IGFjY0luZGV4ID0gaXNOZWdhdGl2ZShjdXJyZW50VmFsKSAmJiBzZXBhcmF0ZU5lZ2F0aXZlID8gMCA6IDE7XG4gICAgICBpZiAoIWlzRmluaXRlTnVtYmVyKGN1cnJlbnRWYWwpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChtb2RlID09PSBcIm5vcm1hbFwiKVxuICAgICAgICBhY2NbYWNjSW5kZXhdICs9IGN1cnJlbnRWYWw7XG4gICAgICB2YWx1ZXNbdmFsdWVJZHhdID0gYWNjW2FjY0luZGV4XTtcbiAgICAgIGlmIChtb2RlID09PSBcInRyYWlsaW5nXCIpXG4gICAgICAgIGFjY1thY2NJbmRleF0gKz0gY3VycmVudFZhbDtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBidWlsZEdyb3VwV2luZG93QWNjRm4oeyBtb2RlLCBzdW06IHN1bTIgfSkge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGNvbnN0IGxhc3RWYWx1ZXMgPSBbXTtcbiAgICBsZXQgZmlyc3RSb3cgPSB0cnVlO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICByZXR1cm4gKHZhbHVlcywgdmFsdWVJbmRleGVzKSA9PiB7XG4gICAgICAgIGxldCBhY2MgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlSWR4IG9mIHZhbHVlSW5kZXhlcykge1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWwgPSB2YWx1ZXNbdmFsdWVJZHhdO1xuICAgICAgICAgIGNvbnN0IGxhc3RWYWx1ZSA9IGZpcnN0Um93ICYmIHN1bTIgPT09IFwiY3VycmVudFwiID8gMCA6IGxhc3RWYWx1ZXNbdmFsdWVJZHhdO1xuICAgICAgICAgIGxhc3RWYWx1ZXNbdmFsdWVJZHhdID0gY3VycmVudFZhbDtcbiAgICAgICAgICBjb25zdCBzdW1WYWx1ZSA9IHN1bTIgPT09IFwiY3VycmVudFwiID8gY3VycmVudFZhbCA6IGxhc3RWYWx1ZTtcbiAgICAgICAgICBpZiAoIWlzRmluaXRlTnVtYmVyKGN1cnJlbnRWYWwpIHx8ICFpc0Zpbml0ZU51bWJlcihsYXN0VmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZXNbdmFsdWVJZHhdID0gYWNjO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtb2RlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgICBhY2MgKz0gc3VtVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlc1t2YWx1ZUlkeF0gPSBhY2M7XG4gICAgICAgICAgaWYgKG1vZGUgPT09IFwidHJhaWxpbmdcIikge1xuICAgICAgICAgICAgYWNjICs9IHN1bVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaXJzdFJvdyA9IGZhbHNlO1xuICAgICAgfTtcbiAgICB9O1xuICB9O1xufVxuZnVuY3Rpb24gYWNjdW11bGF0ZUdyb3VwKG1hdGNoR3JvdXBJZCwgbW9kZSwgc3VtMiwgc2VwYXJhdGVOZWdhdGl2ZSA9IGZhbHNlKSB7XG4gIGxldCBhZGp1c3Q7XG4gIGlmIChtb2RlLnN0YXJ0c1dpdGgoXCJ3aW5kb3dcIikpIHtcbiAgICBjb25zdCBtb2RlUGFyYW0gPSBtb2RlLmVuZHNXaXRoKFwiLXRyYWlsaW5nXCIpID8gXCJ0cmFpbGluZ1wiIDogXCJub3JtYWxcIjtcbiAgICBhZGp1c3QgPSBtZW1vKHsgbW9kZTogbW9kZVBhcmFtLCBzdW06IHN1bTIgfSwgYnVpbGRHcm91cFdpbmRvd0FjY0ZuKTtcbiAgfSBlbHNlIHtcbiAgICBhZGp1c3QgPSBtZW1vKHsgbW9kZSwgc2VwYXJhdGVOZWdhdGl2ZSB9LCBidWlsZEdyb3VwQWNjRm4pO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJncm91cC12YWx1ZS1wcm9jZXNzb3JcIixcbiAgICBtYXRjaEdyb3VwSWRzOiBbbWF0Y2hHcm91cElkXSxcbiAgICBhZGp1c3RcbiAgfTtcbn1cbmZ1bmN0aW9uIGdyb3VwU3RhY2tBY2NGbigpIHtcbiAgcmV0dXJuICgpID0+ICh2YWx1ZXMsIHZhbHVlSW5kZXhlcykgPT4ge1xuICAgIGNvbnN0IGFjYyA9IG5ldyBGbG9hdDY0QXJyYXkoMzIpO1xuICAgIGxldCBzdGFja0NvdW50ID0gMDtcbiAgICBmb3IgKGNvbnN0IHZhbHVlSWR4IG9mIHZhbHVlSW5kZXhlcykge1xuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdmFsdWVzW3ZhbHVlSWR4XTtcbiAgICAgIGFjY1tzdGFja0NvdW50XSA9IE51bWJlci5pc0Zpbml0ZShjdXJyZW50VmFsdWUpID8gY3VycmVudFZhbHVlIDogTmFOO1xuICAgICAgc3RhY2tDb3VudCArPSAxO1xuICAgICAgdmFsdWVzW3ZhbHVlSWR4XSA9IGFjYy5zdWJhcnJheSgwLCBzdGFja0NvdW50KTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBhY2N1bXVsYXRlU3RhY2sobWF0Y2hHcm91cElkKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJncm91cC12YWx1ZS1wcm9jZXNzb3JcIixcbiAgICBtYXRjaEdyb3VwSWRzOiBbbWF0Y2hHcm91cElkXSxcbiAgICBhZGp1c3Q6IGdyb3VwU3RhY2tBY2NGblxuICB9O1xufVxuZnVuY3Rpb24gZGlmZihwcmV2aW91c0RhdGEsIHVwZGF0ZU1vdmVkRGF0YSA9IHRydWUpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInByb2Nlc3NvclwiLFxuICAgIHByb3BlcnR5OiBcImRpZmZcIixcbiAgICBjYWxjdWxhdGU6IChwcm9jZXNzZWREYXRhKSA9PiB7XG4gICAgICBjb25zdCBtb3ZlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBjb25zdCBhZGRlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBjb25zdCB1cGRhdGVkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IHJlbW92ZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgICAgY29uc3QgbGVuZ3RoMiA9IE1hdGgubWF4KHByZXZpb3VzRGF0YS5kYXRhLmxlbmd0aCwgcHJvY2Vzc2VkRGF0YS5kYXRhLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDI7IGkrKykge1xuICAgICAgICBjb25zdCBwcmV2ID0gcHJldmlvdXNEYXRhLmRhdGFbaV07XG4gICAgICAgIGNvbnN0IGRhdHVtID0gcHJvY2Vzc2VkRGF0YS5kYXRhW2ldO1xuICAgICAgICBjb25zdCBwcmV2SWQgPSBwcmV2ID8gY3JlYXRlRGF0dW1JZChwcmV2LmtleXMpIDogXCJcIjtcbiAgICAgICAgY29uc3QgZGF0dW1JZCA9IGRhdHVtID8gY3JlYXRlRGF0dW1JZChkYXR1bS5rZXlzKSA6IFwiXCI7XG4gICAgICAgIGlmIChkYXR1bSAmJiBwcmV2ICYmIHByZXZJZCA9PT0gZGF0dW1JZCkge1xuICAgICAgICAgIGlmICghYXJyYXlzRXF1YWwocHJldi52YWx1ZXMsIGRhdHVtLnZhbHVlcykpIHtcbiAgICAgICAgICAgIHVwZGF0ZWQuc2V0KGRhdHVtSWQsIGRhdHVtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbW92ZWQuaGFzKGRhdHVtSWQpKSB7XG4gICAgICAgICAgaWYgKHVwZGF0ZU1vdmVkRGF0YSB8fCAhYXJyYXlzRXF1YWwocmVtb3ZlZC5nZXQoZGF0dW1JZCkudmFsdWVzLCBkYXR1bS52YWx1ZXMpKSB7XG4gICAgICAgICAgICB1cGRhdGVkLnNldChkYXR1bUlkLCBkYXR1bSk7XG4gICAgICAgICAgICBtb3ZlZC5zZXQoZGF0dW1JZCwgZGF0dW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZW1vdmVkLmRlbGV0ZShkYXR1bUlkKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXR1bSkge1xuICAgICAgICAgIGFkZGVkLnNldChkYXR1bUlkLCBkYXR1bSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZGVkLmhhcyhwcmV2SWQpKSB7XG4gICAgICAgICAgaWYgKHVwZGF0ZU1vdmVkRGF0YSB8fCAhYXJyYXlzRXF1YWwoYWRkZWQuZ2V0KHByZXZJZCkudmFsdWVzLCBwcmV2LnZhbHVlcykpIHtcbiAgICAgICAgICAgIHVwZGF0ZWQuc2V0KHByZXZJZCwgcHJldik7XG4gICAgICAgICAgICBtb3ZlZC5zZXQocHJldklkLCBwcmV2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkZWQuZGVsZXRlKHByZXZJZCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJldikge1xuICAgICAgICAgIHVwZGF0ZWQuZGVsZXRlKHByZXZJZCk7XG4gICAgICAgICAgcmVtb3ZlZC5zZXQocHJldklkLCBwcmV2KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY2hhbmdlZCA9IGFkZGVkLnNpemUgPiAwIHx8IHVwZGF0ZWQuc2l6ZSA+IDAgfHwgcmVtb3ZlZC5zaXplID4gMDtcbiAgICAgIHJldHVybiB7IGNoYW5nZWQsIGFkZGVkLCB1cGRhdGVkLCByZW1vdmVkLCBtb3ZlZCB9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURhdHVtSWQoa2V5cywgLi4uZXh0cmFLZXlzKSB7XG4gIGxldCByZXN1bHQ7XG4gIGlmIChpc0FycmF5KGtleXMpKSB7XG4gICAgcmVzdWx0ID0ga2V5cy5tYXAoKGtleSkgPT4gdHJhbnNmb3JtSW50ZWdyYXRlZENhdGVnb3J5VmFsdWUoa2V5KSkuam9pbihcIl9fX1wiKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSB0cmFuc2Zvcm1JbnRlZ3JhdGVkQ2F0ZWdvcnlWYWx1ZShrZXlzKTtcbiAgfVxuICBjb25zdCBwcmltaXRpdmVUeXBlID0gdHlwZW9mIHJlc3VsdCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgcmVzdWx0ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiByZXN1bHQgPT09IFwiYm9vbGVhblwiIHx8IHJlc3VsdCBpbnN0YW5jZW9mIERhdGU7XG4gIGlmIChwcmltaXRpdmVUeXBlICYmIGV4dHJhS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgcmVzdWx0ICs9IGBfX18ke2V4dHJhS2V5cy5qb2luKFwiX19fXCIpfWA7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3Nlcmllcy50c1xudmFyIFNlcmllc05vZGVQaWNrTW9kZSA9IC8qIEBfX1BVUkVfXyAqLyAoKFNlcmllc05vZGVQaWNrTW9kZTIpID0+IHtcbiAgU2VyaWVzTm9kZVBpY2tNb2RlMltTZXJpZXNOb2RlUGlja01vZGUyW1wiRVhBQ1RfU0hBUEVfTUFUQ0hcIl0gPSAwXSA9IFwiRVhBQ1RfU0hBUEVfTUFUQ0hcIjtcbiAgU2VyaWVzTm9kZVBpY2tNb2RlMltTZXJpZXNOb2RlUGlja01vZGUyW1wiTkVBUkVTVF9CWV9NQUlOX0FYSVNfRklSU1RcIl0gPSAxXSA9IFwiTkVBUkVTVF9CWV9NQUlOX0FYSVNfRklSU1RcIjtcbiAgU2VyaWVzTm9kZVBpY2tNb2RlMltTZXJpZXNOb2RlUGlja01vZGUyW1wiTkVBUkVTVF9CWV9NQUlOX0NBVEVHT1JZX0FYSVNfRklSU1RcIl0gPSAyXSA9IFwiTkVBUkVTVF9CWV9NQUlOX0NBVEVHT1JZX0FYSVNfRklSU1RcIjtcbiAgU2VyaWVzTm9kZVBpY2tNb2RlMltTZXJpZXNOb2RlUGlja01vZGUyW1wiTkVBUkVTVF9OT0RFXCJdID0gM10gPSBcIk5FQVJFU1RfTk9ERVwiO1xuICByZXR1cm4gU2VyaWVzTm9kZVBpY2tNb2RlMjtcbn0pKFNlcmllc05vZGVQaWNrTW9kZSB8fCB7fSk7XG5mdW5jdGlvbiBiYXNpY0NvbnRpbnVvdXNDaGVja0RhdHVtVmFsaWRhdGlvbih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0NvbnRpbnVvdXModmFsdWUpO1xufVxuZnVuY3Rpb24gYmFzaWNEaXNjcmV0ZUNoZWNrRGF0dW1WYWxpZGF0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsO1xufVxuZnVuY3Rpb24gZ2V0VmFsaWRhdGlvbkZuKHNjYWxlVHlwZSkge1xuICBzd2l0Y2ggKHNjYWxlVHlwZSkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICBjYXNlIFwibG9nXCI6XG4gICAgY2FzZSBcIm9yZGluYWwtdGltZVwiOlxuICAgIGNhc2UgXCJ0aW1lXCI6XG4gICAgY2FzZSBcImNvbG9yXCI6XG4gICAgICByZXR1cm4gYmFzaWNDb250aW51b3VzQ2hlY2tEYXR1bVZhbGlkYXRpb247XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBiYXNpY0Rpc2NyZXRlQ2hlY2tEYXR1bVZhbGlkYXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFZhbHVlVHlwZShzY2FsZVR5cGUpIHtcbiAgc3dpdGNoIChzY2FsZVR5cGUpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgY2FzZSBcImxvZ1wiOlxuICAgIGNhc2UgXCJ0aW1lXCI6XG4gICAgY2FzZSBcImNvbG9yXCI6XG4gICAgICByZXR1cm4gXCJyYW5nZVwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gXCJjYXRlZ29yeVwiO1xuICB9XG59XG5mdW5jdGlvbiBrZXlQcm9wZXJ0eShwcm9wTmFtZSwgc2NhbGVUeXBlLCBvcHRzID0ge30pIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHByb3BlcnR5OiBwcm9wTmFtZSxcbiAgICB0eXBlOiBcImtleVwiLFxuICAgIHZhbHVlVHlwZTogZ2V0VmFsdWVUeXBlKHNjYWxlVHlwZSksXG4gICAgdmFsaWRhdGlvbjogZ2V0VmFsaWRhdGlvbkZuKHNjYWxlVHlwZSksXG4gICAgLi4ub3B0c1xuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdmFsdWVQcm9wZXJ0eShwcm9wTmFtZSwgc2NhbGVUeXBlLCBvcHRzID0ge30pIHtcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIHByb3BlcnR5OiBwcm9wTmFtZSxcbiAgICB0eXBlOiBcInZhbHVlXCIsXG4gICAgdmFsdWVUeXBlOiBnZXRWYWx1ZVR5cGUoc2NhbGVUeXBlKSxcbiAgICB2YWxpZGF0aW9uOiBnZXRWYWxpZGF0aW9uRm4oc2NhbGVUeXBlKSxcbiAgICAuLi5vcHRzXG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiByYW5nZWRWYWx1ZVByb3BlcnR5KHByb3BOYW1lLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBtaW4gPSAtSW5maW5pdHksIG1heCA9IEluZmluaXR5LCAuLi5kZWZPcHRzIH0gPSBvcHRzO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwidmFsdWVcIixcbiAgICBwcm9wZXJ0eTogcHJvcE5hbWUsXG4gICAgdmFsdWVUeXBlOiBcInJhbmdlXCIsXG4gICAgdmFsaWRhdGlvbjogYmFzaWNDb250aW51b3VzQ2hlY2tEYXR1bVZhbGlkYXRpb24sXG4gICAgcHJvY2Vzc29yOiAoKSA9PiAoZGF0dW0pID0+IGlzRmluaXRlTnVtYmVyKGRhdHVtKSA/IGNsYW1wKG1pbiwgZGF0dW0sIG1heCkgOiBkYXR1bSxcbiAgICAuLi5kZWZPcHRzXG4gIH07XG59XG5mdW5jdGlvbiBhY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KHByb3BOYW1lLCBzY2FsZVR5cGUsIG9wdHMgPSB7fSkge1xuICBjb25zdCB7IG9ubHlQb3NpdGl2ZSwgLi4uZGVmT3B0cyB9ID0gb3B0cztcbiAgY29uc3QgcmVzdWx0ID0ge1xuICAgIC4uLnZhbHVlUHJvcGVydHkocHJvcE5hbWUsIHNjYWxlVHlwZSwgZGVmT3B0cyksXG4gICAgcHJvY2Vzc29yOiBhY2N1bXVsYXRlZFZhbHVlKG9ubHlQb3NpdGl2ZSlcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRyYWlsaW5nQWNjdW11bGF0ZWRWYWx1ZVByb3BlcnR5KHByb3BOYW1lLCBzY2FsZVR5cGUsIG9wdHMgPSB7fSkge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgLi4udmFsdWVQcm9wZXJ0eShwcm9wTmFtZSwgc2NhbGVUeXBlLCBvcHRzKSxcbiAgICBwcm9jZXNzb3I6IHRyYWlsaW5nQWNjdW11bGF0ZWRWYWx1ZSgpXG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkocHJvcE5hbWUsIG1vZGUsIHN1bTIgPSBcImN1cnJlbnRcIiwgb3B0cywgc2NhbGVUeXBlKSB7XG4gIHJldHVybiBbXG4gICAgdmFsdWVQcm9wZXJ0eShwcm9wTmFtZSwgc2NhbGVUeXBlLCBvcHRzKSxcbiAgICBhY2N1bXVsYXRlR3JvdXAob3B0cy5ncm91cElkLCBtb2RlLCBzdW0yLCBvcHRzLnNlcGFyYXRlTmVnYXRpdmUpLFxuICAgIC4uLm9wdHMucmFuZ2VJZCAhPSBudWxsID8gW3JhbmdlMihvcHRzLnJhbmdlSWQsIG9wdHMuZ3JvdXBJZCldIDogW11cbiAgXTtcbn1cbmZ1bmN0aW9uIGdyb3VwU3RhY2tWYWx1ZVByb3BlcnR5KHByb3BOYW1lLCBzY2FsZVR5cGUsIG9wdHMpIHtcbiAgcmV0dXJuIFt2YWx1ZVByb3BlcnR5KHByb3BOYW1lLCBzY2FsZVR5cGUsIG9wdHMpLCBhY2N1bXVsYXRlU3RhY2sob3B0cy5ncm91cElkKV07XG59XG52YXIgU2VyaWVzTm9kZUV2ZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBldmVudCwgeyBkYXR1bSB9LCBzZXJpZXMpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgICB0aGlzLmRhdHVtID0gZGF0dW07XG4gICAgdGhpcy5zZXJpZXNJZCA9IHNlcmllcy5pZDtcbiAgfVxufTtcbnZhciBTZXJpZXNHcm91cGluZ0NoYW5nZWRFdmVudCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Ioc2VyaWVzLCBzZXJpZXNHcm91cGluZywgb2xkR3JvdXBpbmcpIHtcbiAgICB0aGlzLnNlcmllcyA9IHNlcmllcztcbiAgICB0aGlzLnNlcmllc0dyb3VwaW5nID0gc2VyaWVzR3JvdXBpbmc7XG4gICAgdGhpcy5vbGRHcm91cGluZyA9IG9sZEdyb3VwaW5nO1xuICAgIHRoaXMudHlwZSA9IFwiZ3JvdXBpbmdDaGFuZ2VkXCI7XG4gIH1cbn07XG52YXIgU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgY29uc3RydWN0b3Ioc2VyaWVzT3B0cykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy5zZXJpZXNHcm91cGluZyA9IHZvaWQgMDtcbiAgICB0aGlzLk5vZGVFdmVudCA9IFNlcmllc05vZGVFdmVudDtcbiAgICB0aGlzLmludGVybmFsSWQgPSBjcmVhdGVJZCh0aGlzKTtcbiAgICAvLyBUaGUgZ3JvdXAgbm9kZSB0aGF0IGNvbnRhaW5zIGFsbCB0aGUgbm9kZXMgdXNlZCB0byByZW5kZXIgdGhpcyBzZXJpZXMuXG4gICAgdGhpcy5yb290R3JvdXAgPSBuZXcgR3JvdXAoeyBuYW1lOiBcInNlcmllc1Jvb3RcIiwgaXNWaXJ0dWFsOiB0cnVlIH0pO1xuICAgIHRoaXMuYXhlcyA9IHtcbiAgICAgIFtcInhcIiAvKiBYICovXTogdm9pZCAwLFxuICAgICAgW1wieVwiIC8qIFkgKi9dOiB2b2lkIDBcbiAgICB9O1xuICAgIHRoaXMuZGlyZWN0aW9ucyA9IFtcInhcIiAvKiBYICovLCBcInlcIiAvKiBZICovXTtcbiAgICAvLyBGbGFnIHRvIGRldGVybWluZSBpZiB3ZSBzaG91bGQgcmVjYWxjdWxhdGUgbm9kZSBkYXRhLlxuICAgIHRoaXMubm9kZURhdGFSZWZyZXNoID0gdHJ1ZTtcbiAgICB0aGlzLm1vZHVsZU1hcCA9IG5ldyBNb2R1bGVNYXAoKTtcbiAgICB0aGlzLl9kZWNsYXJhdGlvbk9yZGVyID0gLTE7XG4gICAgdGhpcy5zZXJpZXNMaXN0ZW5lcnMgPSBuZXcgTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fcGlja05vZGVDYWNoZSA9IG5ldyBMUlVDYWNoZSgpO1xuICAgIGNvbnN0IHtcbiAgICAgIG1vZHVsZUN0eCxcbiAgICAgIHBpY2tNb2RlcyA9IFsxIC8qIE5FQVJFU1RfQllfTUFJTl9BWElTX0ZJUlNUICovXSxcbiAgICAgIGRpcmVjdGlvbktleXMgPSB7fSxcbiAgICAgIGRpcmVjdGlvbk5hbWVzID0ge30sXG4gICAgICBjb250ZW50R3JvdXBWaXJ0dWFsID0gdHJ1ZSxcbiAgICAgIGNhbkhhdmVBeGVzID0gZmFsc2VcbiAgICB9ID0gc2VyaWVzT3B0cztcbiAgICB0aGlzLmN0eCA9IG1vZHVsZUN0eDtcbiAgICB0aGlzLmRpcmVjdGlvbktleXMgPSBkaXJlY3Rpb25LZXlzO1xuICAgIHRoaXMuZGlyZWN0aW9uTmFtZXMgPSBkaXJlY3Rpb25OYW1lcztcbiAgICB0aGlzLmNhbkhhdmVBeGVzID0gY2FuSGF2ZUF4ZXM7XG4gICAgdGhpcy5jb250ZW50R3JvdXAgPSB0aGlzLnJvb3RHcm91cC5hcHBlbmRDaGlsZChcbiAgICAgIG5ldyBHcm91cCh7XG4gICAgICAgIG5hbWU6IGAke3RoaXMuaW50ZXJuYWxJZH0tY29udGVudGAsXG4gICAgICAgIGlzVmlydHVhbDogY29udGVudEdyb3VwVmlydHVhbCxcbiAgICAgICAgekluZGV4OiA0IC8qIFNFUklFU19MQVlFUl9aSU5ERVggKi8sXG4gICAgICAgIHpJbmRleFN1Yk9yZGVyOiB0aGlzLmdldEdyb3VwWkluZGV4U3ViT3JkZXIoXCJkYXRhXCIpXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5oaWdobGlnaHRHcm91cCA9IG5ldyBHcm91cCh7XG4gICAgICBuYW1lOiBgJHt0aGlzLmludGVybmFsSWR9LWhpZ2hsaWdodGAsXG4gICAgICBpc1ZpcnR1YWw6IGNvbnRlbnRHcm91cFZpcnR1YWwsXG4gICAgICB6SW5kZXg6IDQgLyogU0VSSUVTX0xBWUVSX1pJTkRFWCAqLyxcbiAgICAgIHpJbmRleFN1Yk9yZGVyOiB0aGlzLmdldEdyb3VwWkluZGV4U3ViT3JkZXIoXCJoaWdobGlnaHRcIilcbiAgICB9KTtcbiAgICB0aGlzLmhpZ2hsaWdodE5vZGUgPSB0aGlzLmhpZ2hsaWdodEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCh7IG5hbWU6IFwiaGlnaGxpZ2h0Tm9kZVwiLCB6SW5kZXg6IDAgfSkpO1xuICAgIHRoaXMuaGlnaGxpZ2h0TGFiZWwgPSB0aGlzLmhpZ2hsaWdodEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCh7IG5hbWU6IFwiaGlnaGxpZ2h0TGFiZWxcIiwgekluZGV4OiAxMCB9KSk7XG4gICAgdGhpcy5waWNrTW9kZXMgPSBwaWNrTW9kZXM7XG4gICAgdGhpcy5sYWJlbEdyb3VwID0gdGhpcy5yb290R3JvdXAuYXBwZW5kQ2hpbGQoXG4gICAgICBuZXcgR3JvdXAoe1xuICAgICAgICBuYW1lOiBgJHt0aGlzLmludGVybmFsSWR9LXNlcmllcy1sYWJlbHNgLFxuICAgICAgICB6SW5kZXg6IDggLyogU0VSSUVTX0xBQkVMX1pJTkRFWCAqL1xuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuYW5ub3RhdGlvbkdyb3VwID0gbmV3IEdyb3VwKHtcbiAgICAgIG5hbWU6IGAke3RoaXMuaWR9LWFubm90YXRpb25gLFxuICAgICAgaXNWaXJ0dWFsOiBjb250ZW50R3JvdXBWaXJ0dWFsLFxuICAgICAgekluZGV4OiA0IC8qIFNFUklFU19MQVlFUl9aSU5ERVggKi8sXG4gICAgICB6SW5kZXhTdWJPcmRlcjogdGhpcy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwiYW5ub3RhdGlvblwiKVxuICAgIH0pO1xuICB9XG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzPy5pZCA/PyB0aGlzLmludGVybmFsSWQ7XG4gIH1cbiAgZ2V0IHR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IudHlwZSA/PyBcIlwiO1xuICB9XG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhID8/IHRoaXMuX2NoYXJ0RGF0YTtcbiAgfVxuICBzZXQgdmlzaWJsZSh2YWx1ZSkge1xuICAgIHRoaXMucHJvcGVydGllcy52aXNpYmxlID0gdmFsdWU7XG4gICAgdGhpcy52aXNpYmxlTWF5YmVDaGFuZ2VkKCk7XG4gIH1cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy52aXNpYmxlO1xuICB9XG4gIGdldCBoYXNEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEgIT0gbnVsbCAmJiB0aGlzLmRhdGEubGVuZ3RoID4gMDtcbiAgfVxuICBnZXQgdG9vbHRpcEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy50b29sdGlwPy5lbmFibGVkID8/IGZhbHNlO1xuICB9XG4gIG9uRGF0YUNoYW5nZSgpIHtcbiAgICB0aGlzLm5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XG4gICAgdGhpcy5fcGlja05vZGVDYWNoZS5jbGVhcigpO1xuICB9XG4gIHNldE9wdGlvbnNEYXRhKGlucHV0KSB7XG4gICAgdGhpcy5fZGF0YSA9IGlucHV0O1xuICAgIHRoaXMub25EYXRhQ2hhbmdlKCk7XG4gIH1cbiAgc2V0Q2hhcnREYXRhKGlucHV0KSB7XG4gICAgdGhpcy5fY2hhcnREYXRhID0gaW5wdXQ7XG4gICAgaWYgKHRoaXMuZGF0YSA9PT0gaW5wdXQpIHtcbiAgICAgIHRoaXMub25EYXRhQ2hhbmdlKCk7XG4gICAgfVxuICB9XG4gIG9uU2VyaWVzR3JvdXBpbmdDaGFuZ2UocHJldiwgbmV4dCkge1xuICAgIGNvbnN0IHsgaW50ZXJuYWxJZCwgdHlwZSwgdmlzaWJsZSB9ID0gdGhpcztcbiAgICBpZiAocHJldikge1xuICAgICAgdGhpcy5jdHguc2VyaWVzU3RhdGVNYW5hZ2VyLmRlcmVnaXN0ZXJTZXJpZXMoeyBpZDogaW50ZXJuYWxJZCwgdHlwZSB9KTtcbiAgICB9XG4gICAgaWYgKG5leHQpIHtcbiAgICAgIHRoaXMuY3R4LnNlcmllc1N0YXRlTWFuYWdlci5yZWdpc3RlclNlcmllcyh7IGlkOiBpbnRlcm5hbElkLCB0eXBlLCB2aXNpYmxlLCBzZXJpZXNHcm91cGluZzogbmV4dCB9KTtcbiAgICB9XG4gICAgdGhpcy5maXJlRXZlbnQobmV3IFNlcmllc0dyb3VwaW5nQ2hhbmdlZEV2ZW50KHRoaXMsIG5leHQsIHByZXYpKTtcbiAgfVxuICBnZXRCYW5kU2NhbGVQYWRkaW5nKCkge1xuICAgIHJldHVybiB7IGlubmVyOiAxLCBvdXRlcjogMCB9O1xuICB9XG4gIGdldEdyb3VwWkluZGV4U3ViT3JkZXIodHlwZSwgc3ViSW5kZXggPSAwKSB7XG4gICAgbGV0IG1haW5BZGp1c3QgPSAwO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgIGNhc2UgXCJwYXRoc1wiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsYWJlbHNcIjpcbiAgICAgICAgbWFpbkFkanVzdCArPSAyZTQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1hcmtlclwiOlxuICAgICAgICBtYWluQWRqdXN0ICs9IDFlNDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiaGlnaGxpZ2h0XCI6XG4gICAgICAgIHN1YkluZGV4ICs9IDE1ZTM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImFubm90YXRpb25cIjpcbiAgICAgICAgbWFpbkFkanVzdCArPSAxNWUzO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgbWFpbiA9ICgpID0+IHRoaXMuX2RlY2xhcmF0aW9uT3JkZXIgKyBtYWluQWRqdXN0O1xuICAgIHJldHVybiBbbWFpbiwgc3ViSW5kZXhdO1xuICB9XG4gIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWVzTGlzdGVuZXJzLmFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuICBkaXNwYXRjaCh0eXBlLCBldmVudCkge1xuICAgIHRoaXMuc2VyaWVzTGlzdGVuZXJzLmRpc3BhdGNoKHR5cGUsIGV2ZW50KTtcbiAgfVxuICBhZGRDaGFydEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHJldHVybjtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChmKSA9PiBmKCkpO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICAgIHRoaXMuY3R4LnNlcmllc1N0YXRlTWFuYWdlci5kZXJlZ2lzdGVyU2VyaWVzKHRoaXMpO1xuICB9XG4gIGdldERpcmVjdGlvblZhbHVlcyhkaXJlY3Rpb24sIHByb3BlcnRpZXMpIHtcbiAgICBjb25zdCByZXNvbHZlZERpcmVjdGlvbiA9IHRoaXMucmVzb2x2ZUtleURpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgIGNvbnN0IGtleXMgPSBwcm9wZXJ0aWVzPy5bcmVzb2x2ZWREaXJlY3Rpb25dO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGlmICgha2V5cykge1xuICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG4gICAgY29uc3QgYWRkVmFsdWVzID0gKC4uLml0ZW1zKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGl0ZW1zKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGFkZFZhbHVlcyguLi52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgYWRkVmFsdWVzKC4uLk9iamVjdC52YWx1ZXModmFsdWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGFkZFZhbHVlcyguLi5rZXlzLm1hcCgoa2V5KSA9PiB0aGlzLnByb3BlcnRpZXNba2V5XSkpO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbiAgZ2V0S2V5cyhkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5nZXREaXJlY3Rpb25WYWx1ZXMoZGlyZWN0aW9uLCB0aGlzLmRpcmVjdGlvbktleXMpO1xuICB9XG4gIGdldEtleVByb3BlcnRpZXMoZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlyZWN0aW9uS2V5c1t0aGlzLnJlc29sdmVLZXlEaXJlY3Rpb24oZGlyZWN0aW9uKV0gPz8gW107XG4gIH1cbiAgZ2V0TmFtZXMoZGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGlyZWN0aW9uVmFsdWVzKGRpcmVjdGlvbiwgdGhpcy5kaXJlY3Rpb25OYW1lcyk7XG4gIH1cbiAgcmVzb2x2ZUtleURpcmVjdGlvbihkaXJlY3Rpb24pIHtcbiAgICByZXR1cm4gZGlyZWN0aW9uO1xuICB9XG4gIC8vIFRoZSB1bmlvbiBvZiB0aGUgc2VyaWVzIGRvbWFpbiAoJ2NvbW11bml0eScpIGFuZCBzZXJpZXMtb3B0aW9uIGRvbWFpbnMgKCdlbnRlcnByaXNlJykuXG4gIGdldERvbWFpbihkaXJlY3Rpb24pIHtcbiAgICBjb25zdCBzZXJpZXNEb21haW4gPSB0aGlzLmdldFNlcmllc0RvbWFpbihkaXJlY3Rpb24pO1xuICAgIGNvbnN0IG1vZHVsZURvbWFpbnMgPSB0aGlzLm1vZHVsZU1hcC5tYXBNb2R1bGVzKChtb2R1bGUpID0+IG1vZHVsZS5nZXREb21haW4oZGlyZWN0aW9uKSk7XG4gICAgcmV0dXJuIHNlcmllc0RvbWFpbi5jb25jYXQobW9kdWxlRG9tYWlucy5mbGF0KCkpO1xuICB9XG4gIC8vIEluZGljYXRlIHRoYXQgc29tZXRoaW5nIGV4dGVybmFsIGNoYW5nZWQgYW5kIHdlIHNob3VsZCByZWNhbGN1bGF0ZSBub2RlRGF0YS5cbiAgbWFya05vZGVEYXRhRGlydHkoKSB7XG4gICAgdGhpcy5ub2RlRGF0YVJlZnJlc2ggPSB0cnVlO1xuICAgIHRoaXMuX3BpY2tOb2RlQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLnZpc2libGVNYXliZUNoYW5nZWQoKTtcbiAgfVxuICB2aXNpYmxlTWF5YmVDaGFuZ2VkKCkge1xuICAgIHRoaXMuY3R4LnNlcmllc1N0YXRlTWFuYWdlci5yZWdpc3RlclNlcmllcyh0aGlzKTtcbiAgfVxuICBnZXRPcGFjaXR5KCkge1xuICAgIGNvbnN0IGRlZmF1bHRPcGFjaXR5ID0gMTtcbiAgICBjb25zdCB7IGRpbU9wYWNpdHkgPSAxLCBlbmFibGVkID0gdHJ1ZSB9ID0gdGhpcy5wcm9wZXJ0aWVzLmhpZ2hsaWdodFN0eWxlLnNlcmllcztcbiAgICBpZiAoIWVuYWJsZWQgfHwgZGltT3BhY2l0eSA9PT0gZGVmYXVsdE9wYWNpdHkpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0T3BhY2l0eTtcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLmlzSXRlbUlkSGlnaGxpZ2h0ZWQoKSkge1xuICAgICAgY2FzZSAwIC8qIE5vbmUgKi86XG4gICAgICBjYXNlIDEgLyogVGhpcyAqLzpcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRPcGFjaXR5O1xuICAgICAgY2FzZSAyIC8qIE90aGVyICovOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGRpbU9wYWNpdHk7XG4gICAgfVxuICB9XG4gIGdldFN0cm9rZVdpZHRoKGRlZmF1bHRTdHJva2VXaWR0aCkge1xuICAgIGNvbnN0IHsgc3Ryb2tlV2lkdGgsIGVuYWJsZWQgPSB0cnVlIH0gPSB0aGlzLnByb3BlcnRpZXMuaGlnaGxpZ2h0U3R5bGUuc2VyaWVzO1xuICAgIGlmICghZW5hYmxlZCB8fCBzdHJva2VXaWR0aCA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdFN0cm9rZVdpZHRoO1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMuaXNJdGVtSWRIaWdobGlnaHRlZCgpKSB7XG4gICAgICBjYXNlIDEgLyogVGhpcyAqLzpcbiAgICAgICAgcmV0dXJuIHN0cm9rZVdpZHRoO1xuICAgICAgY2FzZSAwIC8qIE5vbmUgKi86XG4gICAgICBjYXNlIDIgLyogT3RoZXIgKi86XG4gICAgICAgIHJldHVybiBkZWZhdWx0U3Ryb2tlV2lkdGg7XG4gICAgfVxuICB9XG4gIGlzSXRlbUlkSGlnaGxpZ2h0ZWQoKSB7XG4gICAgY29uc3Qgc2VyaWVzID0gdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlcj8uZ2V0QWN0aXZlSGlnaGxpZ2h0KCk/LnNlcmllcztcbiAgICBpZiAoc2VyaWVzID09IG51bGwpIHtcbiAgICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gICAgfVxuICAgIGlmIChzZXJpZXMgIT09IHRoaXMpIHtcbiAgICAgIHJldHVybiAyIC8qIE90aGVyICovO1xuICAgIH1cbiAgICByZXR1cm4gMSAvKiBUaGlzICovO1xuICB9XG4gIGdldE1vZHVsZVRvb2x0aXBQYXJhbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlTWFwLm1hcE1vZHVsZXMoKG1vZHVsZSkgPT4gbW9kdWxlLmdldFRvb2x0aXBQYXJhbXMoKSkucmVkdWNlKCh0b3RhbCwgY3VycmVudCkgPT4gT2JqZWN0LmFzc2lnbih0b3RhbCwgY3VycmVudCksIHt9KTtcbiAgfVxuICBwaWNrTm9kZShwb2ludCwgaW50ZW50LCBleGFjdE1hdGNoT25seSA9IGZhbHNlKSB7XG4gICAgY29uc3QgeyBwaWNrTW9kZXMsIHZpc2libGUsIHJvb3RHcm91cCB9ID0gdGhpcztcbiAgICBpZiAoIXZpc2libGUgfHwgIXJvb3RHcm91cC52aXNpYmxlKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChpbnRlbnQgPT09IFwiaGlnaGxpZ2h0XCIgJiYgIXRoaXMucHJvcGVydGllcy5oaWdobGlnaHQuZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoaW50ZW50ID09PSBcImhpZ2hsaWdodC10b29sdGlwXCIgJiYgIXRoaXMucHJvcGVydGllcy5oaWdobGlnaHQuZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoaW50ZW50ID09PSBcImhpZ2hsaWdodFwiICYmICF0aGlzLnByb3BlcnRpZXMuaGlnaGxpZ2h0LmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgbGV0IG1heERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgaWYgKGludGVudCA9PT0gXCJ0b29sdGlwXCIgfHwgaW50ZW50ID09PSBcImhpZ2hsaWdodC10b29sdGlwXCIpIHtcbiAgICAgIGNvbnN0IHsgdG9vbHRpcCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgbWF4RGlzdGFuY2UgPSB0eXBlb2YgdG9vbHRpcC5yYW5nZSA9PT0gXCJudW1iZXJcIiA/IHRvb2x0aXAucmFuZ2UgOiBJbmZpbml0eTtcbiAgICAgIGV4YWN0TWF0Y2hPbmx5IHx8IChleGFjdE1hdGNoT25seSA9IHRvb2x0aXAucmFuZ2UgPT09IFwiZXhhY3RcIik7XG4gICAgfSBlbHNlIGlmIChpbnRlbnQgPT09IFwiZXZlbnRcIikge1xuICAgICAgY29uc3QgeyBub2RlQ2xpY2tSYW5nZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgICAgbWF4RGlzdGFuY2UgPSB0eXBlb2Ygbm9kZUNsaWNrUmFuZ2UgPT09IFwibnVtYmVyXCIgPyBub2RlQ2xpY2tSYW5nZSA6IEluZmluaXR5O1xuICAgICAgZXhhY3RNYXRjaE9ubHkgfHwgKGV4YWN0TWF0Y2hPbmx5ID0gbm9kZUNsaWNrUmFuZ2UgPT09IFwiZXhhY3RcIik7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGVkUGlja01vZGVzID0gcGlja01vZGVzLmZpbHRlcihcbiAgICAgIChtKSA9PiAhZXhhY3RNYXRjaE9ubHkgfHwgbSA9PT0gMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqL1xuICAgICk7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBwb2ludDtcbiAgICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeSh7IHgsIHksIG1heERpc3RhbmNlLCBzZWxlY3RlZFBpY2tNb2RlcyB9KTtcbiAgICBpZiAodGhpcy5fcGlja05vZGVDYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BpY2tOb2RlQ2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcGlja01vZGUgb2Ygc2VsZWN0ZWRQaWNrTW9kZXMpIHtcbiAgICAgIGxldCBtYXRjaDtcbiAgICAgIHN3aXRjaCAocGlja01vZGUpIHtcbiAgICAgICAgY2FzZSAwIC8qIEVYQUNUX1NIQVBFX01BVENIICovOlxuICAgICAgICAgIG1hdGNoID0gdGhpcy5waWNrTm9kZUV4YWN0U2hhcGUocG9pbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEgLyogTkVBUkVTVF9CWV9NQUlOX0FYSVNfRklSU1QgKi86XG4gICAgICAgIGNhc2UgMiAvKiBORUFSRVNUX0JZX01BSU5fQ0FURUdPUllfQVhJU19GSVJTVCAqLzpcbiAgICAgICAgICBtYXRjaCA9IHRoaXMucGlja05vZGVNYWluQXhpc0ZpcnN0KFxuICAgICAgICAgICAgcG9pbnQsXG4gICAgICAgICAgICBwaWNrTW9kZSA9PT0gMiAvKiBORUFSRVNUX0JZX01BSU5fQ0FURUdPUllfQVhJU19GSVJTVCAqL1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMyAvKiBORUFSRVNUX05PREUgKi86XG4gICAgICAgICAgbWF0Y2ggPSB0aGlzLnBpY2tOb2RlQ2xvc2VzdERhdHVtKHBvaW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5kaXN0YW5jZSA8PSBtYXhEaXN0YW5jZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGlja05vZGVDYWNoZS5zZXQoa2V5LCB7IHBpY2tNb2RlLCBtYXRjaDogbWF0Y2guZGF0dW0sIGRpc3RhbmNlOiBtYXRjaC5kaXN0YW5jZSB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BpY2tOb2RlQ2FjaGUuc2V0KGtleSwgdm9pZCAwKTtcbiAgfVxuICBwaWNrTm9kZUV4YWN0U2hhcGUocG9pbnQpIHtcbiAgICBjb25zdCBtYXRjaCA9IHRoaXMuY29udGVudEdyb3VwLnBpY2tOb2RlKHBvaW50LngsIHBvaW50LnkpO1xuICAgIGlmIChtYXRjaCAmJiBtYXRjaC5kYXR1bS5taXNzaW5nICE9PSB0cnVlKSB7XG4gICAgICByZXR1cm4geyBkYXR1bTogbWF0Y2guZGF0dW0sIGRpc3RhbmNlOiAwIH07XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcGlja05vZGVDbG9zZXN0RGF0dW0oX3BvaW50KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gU2VyaWVzLnBpY2tOb2RlQ2xvc2VzdERhdHVtKCkgbm90IGltcGxlbWVudGVkXCIpO1xuICB9XG4gIHBpY2tOb2RlTmVhcmVzdERpc3RhbnRPYmplY3QocG9pbnQsIGl0ZW1zKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBuZWFyZXN0U3F1YXJlZChwb2ludC54LCBwb2ludC55LCBpdGVtcyk7XG4gICAgaWYgKG1hdGNoLm5lYXJlc3QgIT09IHZvaWQgMCAmJiBtYXRjaC5uZWFyZXN0LmRhdHVtLm1pc3NpbmcgIT09IHRydWUpIHtcbiAgICAgIHJldHVybiB7IGRhdHVtOiBtYXRjaC5uZWFyZXN0LmRhdHVtLCBkaXN0YW5jZTogTWF0aC5zcXJ0KG1hdGNoLmRpc3RhbmNlU3F1YXJlZCkgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBwaWNrTm9kZU1haW5BeGlzRmlyc3QoX3BvaW50LCBfcmVxdWlyZUNhdGVnb3J5QXhpcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIFNlcmllcy5waWNrTm9kZU1haW5BeGlzRmlyc3QoKSBub3QgaW1wbGVtZW50ZWRcIik7XG4gIH1cbiAgZmlyZU5vZGVDbGlja0V2ZW50KGV2ZW50LCBkYXR1bSkge1xuICAgIHRoaXMuZmlyZUV2ZW50KG5ldyB0aGlzLk5vZGVFdmVudChcIm5vZGVDbGlja1wiLCBldmVudCwgZGF0dW0sIHRoaXMpKTtcbiAgfVxuICBmaXJlTm9kZURvdWJsZUNsaWNrRXZlbnQoZXZlbnQsIGRhdHVtKSB7XG4gICAgdGhpcy5maXJlRXZlbnQobmV3IHRoaXMuTm9kZUV2ZW50KFwibm9kZURvdWJsZUNsaWNrXCIsIGV2ZW50LCBkYXR1bSwgdGhpcykpO1xuICB9XG4gIGNyZWF0ZU5vZGVDb250ZXh0TWVudUFjdGlvbkV2ZW50KGV2ZW50LCBkYXR1bSkge1xuICAgIHJldHVybiBuZXcgdGhpcy5Ob2RlRXZlbnQoXCJub2RlQ29udGV4dE1lbnVBY3Rpb25cIiwgZXZlbnQsIGRhdHVtLCB0aGlzKTtcbiAgfVxuICB0b2dnbGVTZXJpZXNJdGVtKGl0ZW1JZCwgZW5hYmxlZCkge1xuICAgIHRoaXMudmlzaWJsZSA9IGVuYWJsZWQ7XG4gICAgdGhpcy5ub2RlRGF0YVJlZnJlc2ggPSB0cnVlO1xuICAgIHRoaXMuX3BpY2tOb2RlQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLmRpc3BhdGNoKFwidmlzaWJpbGl0eS1jaGFuZ2VkXCIsIHsgaXRlbUlkLCBlbmFibGVkIH0pO1xuICB9XG4gIGlzRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy52aXNpYmxlO1xuICB9XG4gIGdldE1vZHVsZU1hcCgpIHtcbiAgICByZXR1cm4gdGhpcy5tb2R1bGVNYXA7XG4gIH1cbiAgY3JlYXRlTW9kdWxlQ29udGV4dCgpIHtcbiAgICByZXR1cm4geyAuLi50aGlzLmN0eCwgc2VyaWVzOiB0aGlzIH07XG4gIH1cbiAgZ2V0TGFiZWxUZXh0KGxhYmVsLCBwYXJhbXMsIGRlZmF1bHRGb3JtYXR0ZXIgPSBTdHJpbmcpIHtcbiAgICBpZiAobGFiZWwuZm9ybWF0dGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5jdHguY2FsbGJhY2tDYWNoZS5jYWxsKGxhYmVsLmZvcm1hdHRlciwgeyBzZXJpZXNJZDogdGhpcy5pZCwgLi4ucGFyYW1zIH0pID8/IGRlZmF1bHRGb3JtYXR0ZXIocGFyYW1zLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmF1bHRGb3JtYXR0ZXIocGFyYW1zLnZhbHVlKTtcbiAgfVxuICBnZXRNYXJrZXJTdHlsZShtYXJrZXIsIHBhcmFtcywgZGVmYXVsdFN0eWxlID0gbWFya2VyLmdldFN0eWxlKCkpIHtcbiAgICBjb25zdCBkZWZhdWx0U2l6ZSA9IHsgc2l6ZTogcGFyYW1zLmRhdHVtLnBvaW50Py5zaXplID8/IDAgfTtcbiAgICBjb25zdCBtYXJrZXJTdHlsZSA9IG1lcmdlRGVmYXVsdHMoZGVmYXVsdFNpemUsIGRlZmF1bHRTdHlsZSk7XG4gICAgaWYgKG1hcmtlci5pdGVtU3R5bGVyKSB7XG4gICAgICBjb25zdCBzdHlsZSA9IHRoaXMuY3R4LmNhbGxiYWNrQ2FjaGUuY2FsbChtYXJrZXIuaXRlbVN0eWxlciwge1xuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgLi4ubWFya2VyU3R5bGUsXG4gICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgZGF0dW06IHBhcmFtcy5kYXR1bS5kYXR1bVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWVyZ2VEZWZhdWx0cyhzdHlsZSwgbWFya2VyU3R5bGUpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya2VyU3R5bGU7XG4gIH1cbiAgdXBkYXRlTWFya2VyU3R5bGUobWFya2VyTm9kZSwgbWFya2VyLCBwYXJhbXMsIGRlZmF1bHRTdHlsZSA9IG1hcmtlci5nZXRTdHlsZSgpLCB7IGFwcGx5VHJhbnNsYXRpb24gPSB0cnVlIH0gPSB7fSkge1xuICAgIGNvbnN0IHsgcG9pbnQgfSA9IHBhcmFtcy5kYXR1bTtcbiAgICBjb25zdCBhY3RpdmVTdHlsZSA9IHRoaXMuZ2V0TWFya2VyU3R5bGUobWFya2VyLCBwYXJhbXMsIGRlZmF1bHRTdHlsZSk7XG4gICAgY29uc3QgdmlzaWJsZSA9IHRoaXMudmlzaWJsZSAmJiBhY3RpdmVTdHlsZS5zaXplID4gMCAmJiBwb2ludCAmJiAhaXNOYU4ocG9pbnQueCkgJiYgIWlzTmFOKHBvaW50LnkpO1xuICAgIGlmIChhcHBseVRyYW5zbGF0aW9uKSB7XG4gICAgICBtYXJrZXJOb2RlLnNldFByb3BlcnRpZXMoeyB2aXNpYmxlLCAuLi5hY3RpdmVTdHlsZSwgdHJhbnNsYXRpb25YOiBwb2ludD8ueCwgdHJhbnNsYXRpb25ZOiBwb2ludD8ueSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWFya2VyTm9kZS5zZXRQcm9wZXJ0aWVzKHsgdmlzaWJsZSwgLi4uYWN0aXZlU3R5bGUgfSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWFya2VyLnNoYXBlID09PSBcImZ1bmN0aW9uXCIgJiYgIW1hcmtlck5vZGUuZGlydHlQYXRoKSB7XG4gICAgICBtYXJrZXJOb2RlLnBhdGguY2xlYXIodHJ1ZSk7XG4gICAgICBtYXJrZXJOb2RlLnVwZGF0ZVBhdGgoKTtcbiAgICAgIG1hcmtlck5vZGUuY2hlY2tQYXRoRGlydHkoKTtcbiAgICB9XG4gIH1cbiAgZ2V0TWluUmVjdHMoX3dpZHRoLCBfaGVpZ2h0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGdldCBub2RlRGF0YURlcGVuZGVuY2llcygpIHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZURhdGFEZXBlbmRlbmNpZXMgPz8geyBzZXJpZXNSZWN0V2lkdGg6IE5hTiwgc2VyaWVzUmVjdEhlaWdodDogTmFOIH07XG4gIH1cbiAgY2hlY2tSZXNpemUobmV3U2VyaWVzUmVjdCkge1xuICAgIGNvbnN0IHsgd2lkdGg6IHNlcmllc1JlY3RXaWR0aCwgaGVpZ2h0OiBzZXJpZXNSZWN0SGVpZ2h0IH0gPSBuZXdTZXJpZXNSZWN0ID8/IHsgd2lkdGg6IE5hTiwgaGVpZ2h0OiBOYU4gfTtcbiAgICBjb25zdCBuZXdOb2RlRGF0YURlcGVuZGVuY2llcyA9IG5ld1Nlcmllc1JlY3QgPyB7IHNlcmllc1JlY3RXaWR0aCwgc2VyaWVzUmVjdEhlaWdodCB9IDogdm9pZCAwO1xuICAgIGNvbnN0IHJlc2l6ZSA9IGpzb25EaWZmKHRoaXMubm9kZURhdGFEZXBlbmRlbmNpZXMsIG5ld05vZGVEYXRhRGVwZW5kZW5jaWVzKSAhPSBudWxsO1xuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHRoaXMuX25vZGVEYXRhRGVwZW5kZW5jaWVzID0gbmV3Tm9kZURhdGFEZXBlbmRlbmNpZXM7XG4gICAgICB0aGlzLm1hcmtOb2RlRGF0YURpcnR5KCk7XG4gICAgfVxuICAgIHJldHVybiByZXNpemU7XG4gIH1cbiAgcGlja0ZvY3VzKF9vcHRzKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufTtcblNlcmllcy5oaWdobGlnaHRlZFpJbmRleCA9IDFlMTI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgY2hhbmdlVmFsdWU6IGZ1bmN0aW9uKG5ld1ZhbCwgb2xkVmFsKSB7XG4gICAgICB0aGlzLm9uU2VyaWVzR3JvdXBpbmdDaGFuZ2Uob2xkVmFsLCBuZXdWYWwpO1xuICAgIH1cbiAgfSlcbl0sIFNlcmllcy5wcm90b3R5cGUsIFwic2VyaWVzR3JvdXBpbmdcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy91dGlsLnRzXG5mdW5jdGlvbiBjb252ZXJ0VmFsdWVzVG9TY2FsZUJ5RGVmcyh7XG4gIGRlZnMsXG4gIHZhbHVlcyxcbiAgeEF4aXMsXG4gIHlBeGlzXG59KSB7XG4gIGlmICghKHhBeGlzICYmIHlBeGlzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkF4ZXMgbXVzdCBiZSBkZWZpbmVkXCIpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHt9O1xuICBmb3IgKGNvbnN0IFtzZWFyY2hJZCwgeyBkZWYgfV0gb2YgZGVmcykge1xuICAgIGlmIChPYmplY3QuaGFzT3duKHZhbHVlcywgc2VhcmNoSWQpKSB7XG4gICAgICBjb25zdCB7IHNjYWxlOiBzY2FsZTIgfSA9IGRlZi50eXBlID09PSBcImtleVwiID8geEF4aXMgOiB5QXhpcztcbiAgICAgIHJlc3VsdFtzZWFyY2hJZF0gPSBNYXRoLnJvdW5kKHNjYWxlMi5jb252ZXJ0KHZhbHVlc1tzZWFyY2hJZF0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBpY2tOb2RlKGlucHV0U2VyaWVzLCBwb2ludCwgaW50ZW50LCBleGFjdE1hdGNoT25seSkge1xuICBjb25zdCByZXZlcnNlU2VyaWVzID0gWy4uLmlucHV0U2VyaWVzXS5yZXZlcnNlKCk7XG4gIGxldCByZXN1bHQ7XG4gIGZvciAoY29uc3Qgc2VyaWVzIG9mIHJldmVyc2VTZXJpZXMpIHtcbiAgICBpZiAoIXNlcmllcy52aXNpYmxlIHx8ICFzZXJpZXMucm9vdEdyb3VwLnZpc2libGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB7IG1hdGNoLCBkaXN0YW5jZTogZGlzdGFuY2UzIH0gPSBzZXJpZXMucGlja05vZGUocG9pbnQsIGludGVudCwgZXhhY3RNYXRjaE9ubHkpID8/IHt9O1xuICAgIGlmICghbWF0Y2ggfHwgZGlzdGFuY2UzID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoIXJlc3VsdCB8fCByZXN1bHQuZGlzdGFuY2UgPiBkaXN0YW5jZTMpIHtcbiAgICAgIHJlc3VsdCA9IHsgc2VyaWVzLCBkaXN0YW5jZTogZGlzdGFuY2UzLCBkYXR1bTogbWF0Y2ggfTtcbiAgICB9XG4gICAgaWYgKGRpc3RhbmNlMyA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXNBcmVhQ2xpY2tNYW5hZ2VyLnRzXG52YXIgU2VyaWVzQXJlYUNsaWNrTWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihpZCwgY2hhcnQsIGN0eCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLnNlcmllcyA9IFtdO1xuICAgIGNvbnN0IHNlcmllc1JlZ2lvbiA9IHRoaXMuY3R4LnJlZ2lvbk1hbmFnZXIuZ2V0UmVnaW9uKFwic2VyaWVzXCIgLyogU0VSSUVTICovKTtcbiAgICBjb25zdCBob3Jpem9udGFsQXhlc1JlZ2lvbiA9IHRoaXMuY3R4LnJlZ2lvbk1hbmFnZXIuZ2V0UmVnaW9uKFwiaG9yaXpvbnRhbC1heGVzXCIgLyogSE9SSVpPTlRBTF9BWEVTICovKTtcbiAgICBjb25zdCB2ZXJ0aWNhbEF4ZXNSZWdpb24gPSB0aGlzLmN0eC5yZWdpb25NYW5hZ2VyLmdldFJlZ2lvbihcInZlcnRpY2FsLWF4ZXNcIiAvKiBWRVJUSUNBTF9BWEVTICovKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIHRoaXMuY3R4LnJlZ2lvbk1hbmFnZXIubGlzdGVuQWxsKFwiY2xpY2tcIiwgKGV2ZW50KSA9PiB0aGlzLm9uQ2xpY2soZXZlbnQpKSxcbiAgICAgIHRoaXMuY3R4LnJlZ2lvbk1hbmFnZXIubGlzdGVuQWxsKFwiZGJsY2xpY2tcIiwgKGV2ZW50KSA9PiB0aGlzLm9uQ2xpY2soZXZlbnQpKSxcbiAgICAgIHRoaXMuY3R4LmxheW91dFNlcnZpY2UuYWRkTGlzdGVuZXIoXCJsYXlvdXQtY29tcGxldGVcIiwgKGV2ZW50KSA9PiB0aGlzLmxheW91dENvbXBsZXRlKGV2ZW50KSksXG4gICAgICBzZXJpZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJob3ZlclwiLCAoZXZlbnQpID0+IHRoaXMub25Ib3ZlcihldmVudCkpLFxuICAgICAgc2VyaWVzUmVnaW9uLmFkZExpc3RlbmVyKFwibGVhdmVcIiwgKCkgPT4gdGhpcy5vbkxlYXZlKCkpLFxuICAgICAgaG9yaXpvbnRhbEF4ZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJsZWF2ZVwiLCAoKSA9PiB0aGlzLm9uTGVhdmUoKSksXG4gICAgICB2ZXJ0aWNhbEF4ZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJsZWF2ZVwiLCAoKSA9PiB0aGlzLm9uTGVhdmUoKSlcbiAgICApO1xuICB9XG4gIHNlcmllc0NoYW5nZWQoc2VyaWVzKSB7XG4gICAgdGhpcy5zZXJpZXMgPSBzZXJpZXM7XG4gIH1cbiAgZGF0YUNoYW5nZWQoKSB7XG4gICAgdGhpcy5sYXN0SG92ZXIgPSB2b2lkIDA7XG4gIH1cbiAgcHJlU2NlbmVSZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMubGFzdEhvdmVyKSB7XG4gICAgICB0aGlzLm9uSG92ZXIodGhpcy5sYXN0SG92ZXIpO1xuICAgIH1cbiAgfVxuICB1cGRhdGUodHlwZSwgb3B0cykge1xuICAgIHRoaXMuY3R4LnVwZGF0ZVNlcnZpY2UudXBkYXRlKHR5cGUsIG9wdHMpO1xuICB9XG4gIGxheW91dENvbXBsZXRlKGV2ZW50KSB7XG4gICAgdGhpcy5zZXJpZXNSZWN0ID0gZXZlbnQuc2VyaWVzLnBhZGRlZFJlY3Q7XG4gIH1cbiAgb25MZWF2ZSgpIHtcbiAgICB0aGlzLmxhc3RIb3ZlciA9IHZvaWQgMDtcbiAgICB0aGlzLmN0eC5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcih0aGlzLmlkKTtcbiAgfVxuICBvbkhvdmVyKHsgb2Zmc2V0WCwgb2Zmc2V0WSB9KSB7XG4gICAgY29uc3QgZm91bmQgPSBwaWNrTm9kZSh0aGlzLnNlcmllcywgeyB4OiBvZmZzZXRYLCB5OiBvZmZzZXRZIH0sIFwiZXZlbnRcIik7XG4gICAgaWYgKGZvdW5kPy5zZXJpZXMuaGFzRXZlbnRMaXN0ZW5lcihcIm5vZGVDbGlja1wiKSB8fCBmb3VuZD8uc2VyaWVzLmhhc0V2ZW50TGlzdGVuZXIoXCJub2RlRG91YmxlQ2xpY2tcIikpIHtcbiAgICAgIHRoaXMuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKHRoaXMuaWQsIFwicG9pbnRlclwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IodGhpcy5pZCk7XG4gICAgfVxuICB9XG4gIG9uQ2xpY2soZXZlbnQpIHtcbiAgICBpZiAodGhpcy5zZXJpZXNSZWN0Py5jb250YWluc1BvaW50KGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpICYmIHRoaXMuY2hlY2tTZXJpZXNOb2RlQ2xpY2soZXZlbnQpKSB7XG4gICAgICB0aGlzLnVwZGF0ZSg0IC8qIFNFUklFU19VUERBVEUgKi8pO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmV3RXZlbnQgPSB7IHR5cGU6IGV2ZW50LnR5cGUgPT09IFwiY2xpY2tcIiA/IFwiY2xpY2tcIiA6IFwiZG91YmxlQ2xpY2tcIiwgZXZlbnQ6IGV2ZW50LnNvdXJjZUV2ZW50IH07XG4gICAgdGhpcy5jaGFydC5maXJlRXZlbnQobmV3RXZlbnQpO1xuICB9XG4gIGNoZWNrU2VyaWVzTm9kZUNsaWNrKGV2ZW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gcGlja05vZGUodGhpcy5zZXJpZXMsIHsgeDogZXZlbnQub2Zmc2V0WCwgeTogZXZlbnQub2Zmc2V0WSB9LCBcImV2ZW50XCIpO1xuICAgIGlmIChyZXN1bHQgPT0gbnVsbClcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiKSB7XG4gICAgICByZXN1bHQuc2VyaWVzLmZpcmVOb2RlQ2xpY2tFdmVudChldmVudC5zb3VyY2VFdmVudCwgcmVzdWx0LmRhdHVtKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gXCJkYmxjbGlja1wiKSB7XG4gICAgICBldmVudC5wcmV2ZW50Wm9vbURibENsaWNrID0gcmVzdWx0LmRpc3RhbmNlID09PSAwO1xuICAgICAgcmVzdWx0LnNlcmllcy5maXJlTm9kZURvdWJsZUNsaWNrRXZlbnQoZXZlbnQuc291cmNlRXZlbnQsIHJlc3VsdC5kYXR1bSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9rZXlib2FyZFV0aWwudHNcbmZ1bmN0aW9uIGNvbXB1dGVDZW50ZXIoYmJveE9yUGF0aCkge1xuICBpZiAoYmJveE9yUGF0aCBpbnN0YW5jZW9mIEJCb3gpIHtcbiAgICByZXR1cm4gYmJveE9yUGF0aC5jb21wdXRlQ2VudGVyKCk7XG4gIH1cbiAgcmV0dXJuIGJib3hPclBhdGg/LmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKT8uY29tcHV0ZUNlbnRlcigpO1xufVxuZnVuY3Rpb24gZHJhd1BpY2tlZEZvY3VzKGZvY3VzSW5kaWNhdG9yLCBwaWNrKSB7XG4gIGNvbnN0IHsgYm91bmRzLCBzaG93Rm9jdXNCb3ggfSA9IHBpY2s7XG4gIGlmIChzaG93Rm9jdXNCb3gpIHtcbiAgICBmb2N1c0luZGljYXRvcj8udXBkYXRlQm91bmRzKGJvdW5kcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1ha2VLZXlib2FyZFBvaW50ZXJFdmVudChmb2N1c0luZGljYXRvciwgcGljaykge1xuICBkcmF3UGlja2VkRm9jdXMoZm9jdXNJbmRpY2F0b3IsIHBpY2spO1xuICBjb25zdCB7IHg6IG9mZnNldFgsIHk6IG9mZnNldFkgfSA9IGNvbXB1dGVDZW50ZXIocGljay5ib3VuZHMpID8/IHt9O1xuICBpZiAob2Zmc2V0WCAhPT0gdm9pZCAwICYmIG9mZnNldFkgIT09IHZvaWQgMCkge1xuICAgIHJldHVybiB7IHR5cGU6IFwia2V5Ym9hcmRcIiwgb2Zmc2V0WCwgb2Zmc2V0WSB9O1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXNBcmVhRm9jdXNNYW5hZ2VyLnRzXG52YXIgU2VyaWVzQXJlYUZvY3VzTWFuYWdlciA9IGNsYXNzIGV4dGVuZHMgQmFzZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihpZCwgY2hhcnQsIGN0eCwgY2hhcnRUeXBlMiwgb3ZlcmxheXMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmNoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5jaGFydFR5cGUgPSBjaGFydFR5cGUyO1xuICAgIHRoaXMub3ZlcmxheXMgPSBvdmVybGF5cztcbiAgICB0aGlzLnNlcmllcyA9IFtdO1xuICAgIHRoaXMuZm9jdXMgPSB7XG4gICAgICBoYXNGb2N1czogZmFsc2UsXG4gICAgICBzZXJpZXM6IHZvaWQgMCxcbiAgICAgIHNlcmllc0luZGV4OiAwLFxuICAgICAgZGF0dW1JbmRleDogMCxcbiAgICAgIGRhdHVtOiB2b2lkIDBcbiAgICB9O1xuICAgIGNvbnN0IHNlcmllc1JlZ2lvbiA9IHRoaXMuY3R4LnJlZ2lvbk1hbmFnZXIuZ2V0UmVnaW9uKFwic2VyaWVzXCIgLyogU0VSSUVTICovKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIHRoaXMuY3R4LmxheW91dFNlcnZpY2UuYWRkTGlzdGVuZXIoXCJsYXlvdXQtY29tcGxldGVcIiwgKGV2ZW50KSA9PiB0aGlzLmxheW91dENvbXBsZXRlKGV2ZW50KSksXG4gICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwiYW5pbWF0aW9uLXN0YXJ0XCIsICgpID0+IHRoaXMub25BbmltYXRpb25TdGFydCgpKSxcbiAgICAgIHNlcmllc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImJsdXJcIiwgKCkgPT4gdGhpcy5vbkJsdXIoKSksXG4gICAgICBzZXJpZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJ0YWJcIiwgKGV2ZW50KSA9PiB0aGlzLm9uVGFiKGV2ZW50KSksXG4gICAgICBzZXJpZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJuYXYtdmVydFwiLCAoZXZlbnQpID0+IHRoaXMub25OYXZWZXJ0KGV2ZW50KSksXG4gICAgICBzZXJpZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJuYXYtaG9yaVwiLCAoZXZlbnQpID0+IHRoaXMub25OYXZIb3JpKGV2ZW50KSksXG4gICAgICBzZXJpZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJzdWJtaXRcIiwgKGV2ZW50KSA9PiB0aGlzLm9uU3VibWl0KGV2ZW50KSksXG4gICAgICB0aGlzLmN0eC5rZXlOYXZNYW5hZ2VyLmFkZExpc3RlbmVyKFwiYnJvd3NlcmZvY3VzXCIsIChldmVudCkgPT4gdGhpcy5vbkJyb3dzZXJGb2N1cyhldmVudCkpLFxuICAgICAgdGhpcy5jdHguem9vbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJ6b29tLWNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY3R4LmZvY3VzSW5kaWNhdG9yLnVwZGF0ZUJvdW5kcyh2b2lkIDApO1xuICAgICAgfSlcbiAgICApO1xuICB9XG4gIHNlcmllc0NoYW5nZWQoc2VyaWVzKSB7XG4gICAgdGhpcy5zZXJpZXMgPSBzZXJpZXM7XG4gICAgdGhpcy5vbkJsdXIoKTtcbiAgfVxuICBkYXRhQ2hhbmdlZCgpIHtcbiAgICB0aGlzLmN0eC5mb2N1c0luZGljYXRvci51cGRhdGVCb3VuZHModm9pZCAwKTtcbiAgfVxuICBwcmVTY2VuZVJlbmRlcigpIHtcbiAgICB0aGlzLnJlZnJlc2hGb2N1cygpO1xuICB9XG4gIGxheW91dENvbXBsZXRlKGV2ZW50KSB7XG4gICAgdGhpcy5zZXJpZXNSZWN0ID0gZXZlbnQuc2VyaWVzLnJlY3Q7XG4gIH1cbiAgcmVmcmVzaEZvY3VzKCkge1xuICAgIGlmICh0aGlzLmZvY3VzLmhhc0ZvY3VzKSB7XG4gICAgICB0aGlzLmhhbmRsZVNlcmllc0ZvY3VzKDAsIDApO1xuICAgIH1cbiAgfVxuICBvblRhYihldmVudCkge1xuICAgIHRoaXMuaGFuZGxlRm9jdXMoMCwgMCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmZvY3VzLmhhc0ZvY3VzID0gdHJ1ZTtcbiAgfVxuICBvbk5hdlZlcnQoZXZlbnQpIHtcbiAgICB0aGlzLmZvY3VzLnNlcmllc0luZGV4ICs9IGV2ZW50LmRlbHRhO1xuICAgIHRoaXMuaGFuZGxlRm9jdXMoZXZlbnQuZGVsdGEsIDApO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgb25OYXZIb3JpKGV2ZW50KSB7XG4gICAgdGhpcy5mb2N1cy5kYXR1bUluZGV4ICs9IGV2ZW50LmRlbHRhO1xuICAgIHRoaXMuaGFuZGxlRm9jdXMoMCwgZXZlbnQuZGVsdGEpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgb25Ccm93c2VyRm9jdXMoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuZGVsdGEgPiAwKSB7XG4gICAgICB0aGlzLmZvY3VzLmRhdHVtID0gdm9pZCAwO1xuICAgICAgdGhpcy5mb2N1cy5zZXJpZXMgPSB2b2lkIDA7XG4gICAgICB0aGlzLmZvY3VzLmRhdHVtSW5kZXggPSAwO1xuICAgICAgdGhpcy5mb2N1cy5zZXJpZXNJbmRleCA9IDA7XG4gICAgfSBlbHNlIGlmIChldmVudC5kZWx0YSA8IDApIHtcbiAgICAgIHRoaXMuZm9jdXMuZGF0dW0gPSB2b2lkIDA7XG4gICAgICB0aGlzLmZvY3VzLnNlcmllcyA9IHZvaWQgMDtcbiAgICAgIHRoaXMuZm9jdXMuZGF0dW1JbmRleCA9IEluZmluaXR5O1xuICAgICAgdGhpcy5mb2N1cy5zZXJpZXNJbmRleCA9IEluZmluaXR5O1xuICAgIH1cbiAgfVxuICBvbkFuaW1hdGlvblN0YXJ0KCkge1xuICAgIGlmICh0aGlzLmZvY3VzLmhhc0ZvY3VzKSB7XG4gICAgICB0aGlzLm9uQmx1cigpO1xuICAgIH1cbiAgfVxuICBvbkJsdXIoKSB7XG4gICAgdGhpcy5jdHguZm9jdXNJbmRpY2F0b3IudXBkYXRlQm91bmRzKHZvaWQgMCk7XG4gICAgdGhpcy5mb2N1cy5oYXNGb2N1cyA9IGZhbHNlO1xuICB9XG4gIGhhbmRsZUZvY3VzKHNlcmllc0luZGV4RGVsdGEsIGRhdHVtSW5kZXhEZWx0YSkge1xuICAgIHRoaXMuZm9jdXMuaGFzRm9jdXMgPSB0cnVlO1xuICAgIGNvbnN0IG92ZXJsYXlGb2N1cyA9IHRoaXMub3ZlcmxheXMuZ2V0Rm9jdXNJbmZvKHRoaXMuY3R4LmxvY2FsZU1hbmFnZXIpO1xuICAgIGlmIChvdmVybGF5Rm9jdXMgPT0gbnVsbCkge1xuICAgICAgdGhpcy5oYW5kbGVTZXJpZXNGb2N1cyhzZXJpZXNJbmRleERlbHRhLCBkYXR1bUluZGV4RGVsdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5mb2N1c0luZGljYXRvci51cGRhdGVCb3VuZHMob3ZlcmxheUZvY3VzLnJlY3QpO1xuICAgICAgdGhpcy5jdHguYXJpYUFubm91bmNlbWVudFNlcnZpY2UuYW5ub3VuY2VWYWx1ZShvdmVybGF5Rm9jdXMudGV4dCk7XG4gICAgfVxuICB9XG4gIGhhbmRsZVNlcmllc0ZvY3VzKG90aGVySW5kZXhEZWx0YSwgZGF0dW1JbmRleERlbHRhKSB7XG4gICAgaWYgKHRoaXMuY2hhcnRUeXBlID09PSBcImhpZXJhcmNoeVwiKSB7XG4gICAgICB0aGlzLmhhbmRsZUhpZXJhcmNoeVNlcmllc0ZvY3VzKG90aGVySW5kZXhEZWx0YSwgZGF0dW1JbmRleERlbHRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBmb2N1cywgc2VyaWVzUmVjdCwgc2VyaWVzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHZpc2libGVTZXJpZXMgPSBzZXJpZXMuZmlsdGVyKChzKSA9PiBzLnZpc2libGUpO1xuICAgIGlmICh2aXNpYmxlU2VyaWVzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBmb2N1cy5zZXJpZXNJbmRleCA9IGNsYW1wKDAsIGZvY3VzLnNlcmllc0luZGV4LCB2aXNpYmxlU2VyaWVzLmxlbmd0aCAtIDEpO1xuICAgIGZvY3VzLnNlcmllcyA9IHZpc2libGVTZXJpZXNbZm9jdXMuc2VyaWVzSW5kZXhdO1xuICAgIGNvbnN0IHsgZGF0dW1JbmRleCwgc2VyaWVzSW5kZXg6IG90aGVySW5kZXggfSA9IGZvY3VzO1xuICAgIGNvbnN0IHBpY2sgPSBmb2N1cy5zZXJpZXMucGlja0ZvY3VzKHsgZGF0dW1JbmRleCwgZGF0dW1JbmRleERlbHRhLCBvdGhlckluZGV4LCBvdGhlckluZGV4RGVsdGEsIHNlcmllc1JlY3QgfSk7XG4gICAgdGhpcy51cGRhdGVQaWNrZWRGb2N1cyhwaWNrKTtcbiAgfVxuICBoYW5kbGVIaWVyYXJjaHlTZXJpZXNGb2N1cyhvdGhlckluZGV4RGVsdGEsIGRhdHVtSW5kZXhEZWx0YSkge1xuICAgIHRoaXMuZm9jdXMuc2VyaWVzID0gdGhpcy5zZXJpZXNbMF07XG4gICAgY29uc3Qge1xuICAgICAgZm9jdXM6IHsgc2VyaWVzLCBzZXJpZXNJbmRleDogb3RoZXJJbmRleCwgZGF0dW1JbmRleCB9LFxuICAgICAgc2VyaWVzUmVjdFxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChzZXJpZXMgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBwaWNrID0gc2VyaWVzLnBpY2tGb2N1cyh7IGRhdHVtSW5kZXgsIGRhdHVtSW5kZXhEZWx0YSwgb3RoZXJJbmRleCwgb3RoZXJJbmRleERlbHRhLCBzZXJpZXNSZWN0IH0pO1xuICAgIHRoaXMudXBkYXRlUGlja2VkRm9jdXMocGljayk7XG4gIH1cbiAgdXBkYXRlUGlja2VkRm9jdXMocGljaykge1xuICAgIGNvbnN0IHsgZm9jdXMgfSA9IHRoaXM7XG4gICAgaWYgKHBpY2sgPT09IHZvaWQgMCB8fCBmb2N1cy5zZXJpZXMgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGRhdHVtLCBkYXR1bUluZGV4IH0gPSBwaWNrO1xuICAgIGZvY3VzLmRhdHVtSW5kZXggPSBkYXR1bUluZGV4O1xuICAgIGZvY3VzLmRhdHVtID0gZGF0dW07XG4gICAgY29uc3Qga2V5Ym9hcmRFdmVudCA9IG1ha2VLZXlib2FyZFBvaW50ZXJFdmVudCh0aGlzLmN0eC5mb2N1c0luZGljYXRvciwgcGljayk7XG4gICAgaWYgKGtleWJvYXJkRXZlbnQgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgaHRtbCA9IGZvY3VzLnNlcmllcy5nZXRUb29sdGlwSHRtbChkYXR1bSk7XG4gICAgICBjb25zdCBtZXRhID0gVG9vbHRpcE1hbmFnZXIubWFrZVRvb2x0aXBNZXRhKGtleWJvYXJkRXZlbnQsIGRhdHVtKTtcbiAgICAgIGNvbnN0IGFyaWEgPSB0aGlzLmdldERhdHVtQXJpYVRleHQoZGF0dW0sIGh0bWwpO1xuICAgICAgdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVIaWdobGlnaHQodGhpcy5pZCwgZGF0dW0pO1xuICAgICAgdGhpcy5jdHgudG9vbHRpcE1hbmFnZXIudXBkYXRlVG9vbHRpcCh0aGlzLmlkLCBtZXRhLCBodG1sKTtcbiAgICAgIHRoaXMuY3R4LmFyaWFBbm5vdW5jZW1lbnRTZXJ2aWNlLmFubm91bmNlVmFsdWUoXCJhcmlhQW5ub3VuY2VIb3ZlckRhdHVtXCIsIHsgZGF0dW06IGFyaWEgfSk7XG4gICAgfVxuICB9XG4gIG9uU3VibWl0KGV2ZW50KSB7XG4gICAgY29uc3QgeyBzZXJpZXMsIGRhdHVtIH0gPSB0aGlzLmZvY3VzO1xuICAgIGNvbnN0IHNvdXJjZUV2ZW50ID0gZXZlbnQuc291cmNlRXZlbnQuc291cmNlRXZlbnQ7XG4gICAgaWYgKHNlcmllcyAhPT0gdm9pZCAwICYmIGRhdHVtICE9PSB2b2lkIDApIHtcbiAgICAgIHNlcmllcy5maXJlTm9kZUNsaWNrRXZlbnQoc291cmNlRXZlbnQsIGRhdHVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaGFydC5maXJlRXZlbnQoe1xuICAgICAgICB0eXBlOiBcImNsaWNrXCIsXG4gICAgICAgIGV2ZW50OiBzb3VyY2VFdmVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cbiAgZ2V0RGF0dW1BcmlhVGV4dChkYXR1bSwgaHRtbCkge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gaHRtbC5hcmlhTGFiZWw7XG4gICAgcmV0dXJuIGRhdHVtLnNlcmllcy5nZXREYXR1bUFyaWFUZXh0Py4oZGF0dW0sIGRlc2NyaXB0aW9uKSA/PyBkZXNjcmlwdGlvbjtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3Nlcmllc0FyZWFIaWdobGlnaHRNYW5hZ2VyLnRzXG52YXIgU2VyaWVzQXJlYUhpZ2hsaWdodE1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoaWQsIGNoYXJ0LCBjdHgsIGhpZ2hsaWdodCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmhpZ2hsaWdodCA9IGhpZ2hsaWdodDtcbiAgICB0aGlzLnNlcmllcyA9IFtdO1xuICAgIHRoaXMuaG92ZXJTY2hlZHVsZXIgPSBkZWJvdW5jZWRBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMucGVuZGluZ0hvdmVyRXZlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmNoYXJ0LnBlcmZvcm1VcGRhdGVUeXBlIDw9IDQgLyogU0VSSUVTX1VQREFURSAqLykge1xuICAgICAgICB0aGlzLmhvdmVyU2NoZWR1bGVyLnNjaGVkdWxlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGFuZGxlSG92ZXIoZmFsc2UpO1xuICAgIH0pO1xuICAgIGNvbnN0IHNlcmllc1JlZ2lvbiA9IHRoaXMuY3R4LnJlZ2lvbk1hbmFnZXIuZ2V0UmVnaW9uKFwic2VyaWVzXCIgLyogU0VSSUVTICovKTtcbiAgICBjb25zdCBob3Jpem9udGFsQXhlc1JlZ2lvbiA9IHRoaXMuY3R4LnJlZ2lvbk1hbmFnZXIuZ2V0UmVnaW9uKFwiaG9yaXpvbnRhbC1heGVzXCIgLyogSE9SSVpPTlRBTF9BWEVTICovKTtcbiAgICBjb25zdCB2ZXJ0aWNhbEF4ZXNSZWdpb24gPSB0aGlzLmN0eC5yZWdpb25NYW5hZ2VyLmdldFJlZ2lvbihcInZlcnRpY2FsLWF4ZXNcIiAvKiBWRVJUSUNBTF9BWEVTICovKTtcbiAgICBjb25zdCBtb3VzZU1vdmVTdGF0ZXMgPSAxNiAvKiBEZWZhdWx0ICovIHwgNCAvKiBBbm5vdGF0aW9ucyAqLztcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIHRoaXMuY3R4LmxheW91dFNlcnZpY2UuYWRkTGlzdGVuZXIoXCJsYXlvdXQtY29tcGxldGVcIiwgKGV2ZW50KSA9PiB0aGlzLmxheW91dENvbXBsZXRlKGV2ZW50KSksXG4gICAgICB0aGlzLmN0eC5oaWdobGlnaHRNYW5hZ2VyLmFkZExpc3RlbmVyKFwiaGlnaGxpZ2h0LWNoYW5nZVwiLCAoZXZlbnQpID0+IHRoaXMuY2hhbmdlSGlnaGxpZ2h0RGF0dW0oZXZlbnQpKSxcbiAgICAgIHNlcmllc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImhvdmVyXCIsIChldmVudCkgPT4gdGhpcy5vbkhvdmVyKGV2ZW50KSwgbW91c2VNb3ZlU3RhdGVzKSxcbiAgICAgIHNlcmllc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImRyYWdcIiwgKGV2ZW50KSA9PiB0aGlzLm9uSG92ZXIoZXZlbnQpLCBtb3VzZU1vdmVTdGF0ZXMpLFxuICAgICAgaG9yaXpvbnRhbEF4ZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJob3ZlclwiLCAoZXZlbnQpID0+IHRoaXMub25Ib3ZlcihldmVudCkpLFxuICAgICAgdmVydGljYWxBeGVzUmVnaW9uLmFkZExpc3RlbmVyKFwiaG92ZXJcIiwgKGV2ZW50KSA9PiB0aGlzLm9uSG92ZXIoZXZlbnQpKSxcbiAgICAgIC8vIENhc2VzIHdoZXJlIGhpZ2hsaWdodCBzaG91bGQgYmUgY2xlYXJlZC5cbiAgICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJyZXNpemVcIiwgKCkgPT4gdGhpcy5jbGVhckhpZ2hsaWdodCgpKSxcbiAgICAgIHNlcmllc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImxlYXZlXCIsICgpID0+IHRoaXMuY2xlYXJIaWdobGlnaHQoKSwgbW91c2VNb3ZlU3RhdGVzKSxcbiAgICAgIHNlcmllc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImJsdXJcIiwgKCkgPT4gdGhpcy5jbGVhckhpZ2hsaWdodCgpKSxcbiAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuYWRkTGlzdGVuZXIoXCJhbmltYXRpb24tc3RhcnRcIiwgKCkgPT4gdGhpcy5jbGVhckhpZ2hsaWdodCgpKSxcbiAgICAgIHRoaXMuY3R4Lnpvb21NYW5hZ2VyLmFkZExpc3RlbmVyKFwiem9vbS1wYW4tc3RhcnRcIiwgKCkgPT4gdGhpcy5jbGVhckhpZ2hsaWdodCgpKSxcbiAgICAgIHRoaXMuY3R4Lnpvb21NYW5hZ2VyLmFkZExpc3RlbmVyKFwiem9vbS1jaGFuZ2VcIiwgKCkgPT4gdGhpcy5jbGVhckhpZ2hsaWdodCgpKVxuICAgICk7XG4gIH1cbiAgc2VyaWVzQ2hhbmdlZChzZXJpZXMpIHtcbiAgICB0aGlzLnNlcmllcyA9IHNlcmllcztcbiAgfVxuICBkYXRhQ2hhbmdlZCgpIHtcbiAgICB0aGlzLnN0YXNoZWRIb3ZlckV2ZW50ID8/ICh0aGlzLnN0YXNoZWRIb3ZlckV2ZW50ID0gdGhpcy5hcHBsaWVkSG92ZXJFdmVudCk7XG4gICAgdGhpcy5jbGVhckhpZ2hsaWdodCgpO1xuICB9XG4gIHByZVNjZW5lUmVuZGVyKCkge1xuICAgIGlmICh0aGlzLnN0YXNoZWRIb3ZlckV2ZW50ICE9IG51bGwpIHtcbiAgICAgIHRoaXMucGVuZGluZ0hvdmVyRXZlbnQgPSB0aGlzLnN0YXNoZWRIb3ZlckV2ZW50O1xuICAgICAgdGhpcy5zdGFzaGVkSG92ZXJFdmVudCA9IHZvaWQgMDtcbiAgICAgIHRoaXMuaGFuZGxlSG92ZXIodHJ1ZSk7XG4gICAgfVxuICB9XG4gIHVwZGF0ZSh0eXBlLCBvcHRzKSB7XG4gICAgdGhpcy5jdHgudXBkYXRlU2VydmljZS51cGRhdGUodHlwZSwgb3B0cyk7XG4gIH1cbiAgbGF5b3V0Q29tcGxldGUoZXZlbnQpIHtcbiAgICB0aGlzLmhvdmVyUmVjdCA9IGV2ZW50LnNlcmllcy5wYWRkZWRSZWN0O1xuICB9XG4gIGNsZWFySGlnaGxpZ2h0KCkge1xuICAgIHRoaXMucGVuZGluZ0hvdmVyRXZlbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5hcHBsaWVkSG92ZXJFdmVudCA9IHZvaWQgMDtcbiAgICB0aGlzLmN0eC5oaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkKTtcbiAgfVxuICBvbkhvdmVyKGV2ZW50KSB7XG4gICAgdGhpcy5wZW5kaW5nSG92ZXJFdmVudCA9IGV2ZW50O1xuICAgIHRoaXMuaG92ZXJTY2hlZHVsZXIuc2NoZWR1bGUoKTtcbiAgfVxuICBoYW5kbGVIb3ZlcihyZWRpc3BsYXkpIHtcbiAgICB0aGlzLmFwcGxpZWRIb3ZlckV2ZW50ID0gdGhpcy5wZW5kaW5nSG92ZXJFdmVudDtcbiAgICB0aGlzLnBlbmRpbmdIb3ZlckV2ZW50ID0gdm9pZCAwO1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5hcHBsaWVkSG92ZXJFdmVudDtcbiAgICBpZiAoIWV2ZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5jdHguaW50ZXJhY3Rpb25NYW5hZ2VyLmdldFN0YXRlKCk7XG4gICAgaWYgKHN0YXRlICE9PSAxNiAvKiBEZWZhdWx0ICovICYmIHN0YXRlICE9PSA0IC8qIEFubm90YXRpb25zICovKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnQ7XG4gICAgaWYgKHJlZGlzcGxheSA/IHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNBY3RpdmUoKSA6ICF0aGlzLmhvdmVyUmVjdD8uY29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSkge1xuICAgICAgdGhpcy5jbGVhckhpZ2hsaWdodCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHJhbmdlOiByYW5nZTMgfSA9IHRoaXMuaGlnaGxpZ2h0O1xuICAgIGNvbnN0IGludGVudCA9IHJhbmdlMyA9PT0gXCJ0b29sdGlwXCIgPyBcImhpZ2hsaWdodC10b29sdGlwXCIgOiBcImhpZ2hsaWdodFwiO1xuICAgIGNvbnN0IGZvdW5kID0gcGlja05vZGUodGhpcy5zZXJpZXMsIHsgeDogZXZlbnQub2Zmc2V0WCwgeTogZXZlbnQub2Zmc2V0WSB9LCBpbnRlbnQpO1xuICAgIGlmIChmb3VuZCkge1xuICAgICAgdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVIaWdobGlnaHQodGhpcy5pZCwgZm91bmQuZGF0dW0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmN0eC5oaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkKTtcbiAgfVxuICBjaGFuZ2VIaWdobGlnaHREYXR1bShldmVudCkge1xuICAgIGNvbnN0IHNlcmllc1RvVXBkYXRlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjb25zdCB7IHNlcmllczogbmV3U2VyaWVzID0gdm9pZCAwLCBkYXR1bTogbmV3RGF0dW0gfSA9IGV2ZW50LmN1cnJlbnRIaWdobGlnaHQgPz8ge307XG4gICAgY29uc3QgeyBzZXJpZXM6IGxhc3RTZXJpZXMgPSB2b2lkIDAsIGRhdHVtOiBsYXN0RGF0dW0gfSA9IGV2ZW50LnByZXZpb3VzSGlnaGxpZ2h0ID8/IHt9O1xuICAgIGlmIChsYXN0U2VyaWVzKSB7XG4gICAgICBzZXJpZXNUb1VwZGF0ZS5hZGQobGFzdFNlcmllcyk7XG4gICAgfVxuICAgIGlmIChuZXdTZXJpZXMpIHtcbiAgICAgIHNlcmllc1RvVXBkYXRlLmFkZChuZXdTZXJpZXMpO1xuICAgIH1cbiAgICBpZiAobGFzdFNlcmllcz8ucHJvcGVydGllcy5jdXJzb3IgJiYgbGFzdERhdHVtKSB7XG4gICAgICB0aGlzLmN0eC5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcihsYXN0U2VyaWVzLmlkKTtcbiAgICB9XG4gICAgaWYgKG5ld1Nlcmllcz8ucHJvcGVydGllcy5jdXJzb3IgJiYgbmV3U2VyaWVzPy5wcm9wZXJ0aWVzLmN1cnNvciAhPT0gXCJkZWZhdWx0XCIgJiYgbmV3RGF0dW0pIHtcbiAgICAgIHRoaXMuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKG5ld1Nlcmllcy5pZCwgbmV3U2VyaWVzLnByb3BlcnRpZXMuY3Vyc29yKTtcbiAgICB9XG4gICAgY29uc3QgdXBkYXRlQWxsID0gbmV3U2VyaWVzID09IG51bGwgfHwgbGFzdFNlcmllcyA9PSBudWxsO1xuICAgIGlmICh1cGRhdGVBbGwpIHtcbiAgICAgIHRoaXMudXBkYXRlKDQgLyogU0VSSUVTX1VQREFURSAqLyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBkYXRlKDQgLyogU0VSSUVTX1VQREFURSAqLywgeyBzZXJpZXNUb1VwZGF0ZSB9KTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXNBcmVhVG9vbHRpcE1hbmFnZXIudHNcbnZhciBTZXJpZXNBcmVhVG9vbHRpcE1hbmFnZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VNYW5hZ2VyIHtcbiAgY29uc3RydWN0b3IoaWQsIGNoYXJ0LCBjdHgsIHRvb2x0aXApIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmNoYXJ0ID0gY2hhcnQ7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy50b29sdGlwID0gdG9vbHRpcDtcbiAgICB0aGlzLnNlcmllcyA9IFtdO1xuICAgIHRoaXMuaG92ZXJTY2hlZHVsZXIgPSBkZWJvdW5jZWRBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMubGFzdEhvdmVyKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodGhpcy5jaGFydC5wZXJmb3JtVXBkYXRlVHlwZSA8PSA0IC8qIFNFUklFU19VUERBVEUgKi8pIHtcbiAgICAgICAgdGhpcy5ob3ZlclNjaGVkdWxlci5zY2hlZHVsZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmhhbmRsZUhvdmVyKHRoaXMubGFzdEhvdmVyLCBmYWxzZSk7XG4gICAgfSk7XG4gICAgY29uc3Qgc2VyaWVzUmVnaW9uID0gdGhpcy5jdHgucmVnaW9uTWFuYWdlci5nZXRSZWdpb24oXCJzZXJpZXNcIiAvKiBTRVJJRVMgKi8pO1xuICAgIGNvbnN0IGhvcml6b250YWxBeGVzUmVnaW9uID0gdGhpcy5jdHgucmVnaW9uTWFuYWdlci5nZXRSZWdpb24oXCJob3Jpem9udGFsLWF4ZXNcIiAvKiBIT1JJWk9OVEFMX0FYRVMgKi8pO1xuICAgIGNvbnN0IHZlcnRpY2FsQXhlc1JlZ2lvbiA9IHRoaXMuY3R4LnJlZ2lvbk1hbmFnZXIuZ2V0UmVnaW9uKFwidmVydGljYWwtYXhlc1wiIC8qIFZFUlRJQ0FMX0FYRVMgKi8pO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgdGhpcy5jdHgubGF5b3V0U2VydmljZS5hZGRMaXN0ZW5lcihcImxheW91dC1jb21wbGV0ZVwiLCAoZXZlbnQpID0+IHRoaXMubGF5b3V0Q29tcGxldGUoZXZlbnQpKSxcbiAgICAgIHNlcmllc1JlZ2lvbi5hZGRMaXN0ZW5lcihcbiAgICAgICAgXCJob3ZlclwiLFxuICAgICAgICAoZXZlbnQpID0+IHRoaXMub25Ib3ZlcihldmVudCksXG4gICAgICAgIDE2IC8qIERlZmF1bHQgKi8gfCA0IC8qIEFubm90YXRpb25zICovXG4gICAgICApLFxuICAgICAgaG9yaXpvbnRhbEF4ZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJob3ZlclwiLCAoZXZlbnQpID0+IHRoaXMub25Ib3ZlcihldmVudCkpLFxuICAgICAgdmVydGljYWxBeGVzUmVnaW9uLmFkZExpc3RlbmVyKFwiaG92ZXJcIiwgKGV2ZW50KSA9PiB0aGlzLm9uSG92ZXIoZXZlbnQpKSxcbiAgICAgIC8vIEV2ZW50cyB0aGF0IGNsZWFyIHRvb2x0aXAuXG4gICAgICBzZXJpZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJsZWF2ZVwiLCAoKSA9PiB0aGlzLmNsZWFyVG9vbHRpcCgpKSxcbiAgICAgIHNlcmllc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImJsdXJcIiwgKCkgPT4gdGhpcy5jbGVhclRvb2x0aXAoKSksXG4gICAgICBzZXJpZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCAoKSA9PiB0aGlzLmNsZWFyVG9vbHRpcCgpLCAzMSAvKiBBbGwgKi8pLFxuICAgICAgaG9yaXpvbnRhbEF4ZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJsZWF2ZVwiLCAoKSA9PiB0aGlzLmNsZWFyVG9vbHRpcCgpKSxcbiAgICAgIHZlcnRpY2FsQXhlc1JlZ2lvbi5hZGRMaXN0ZW5lcihcImxlYXZlXCIsICgpID0+IHRoaXMuY2xlYXJUb29sdGlwKCkpLFxuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImFuaW1hdGlvbi1zdGFydFwiLCAoKSA9PiB0aGlzLmNsZWFyVG9vbHRpcCgpKSxcbiAgICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJyZXNpemVcIiwgKCkgPT4gdGhpcy5jbGVhclRvb2x0aXAoKSksXG4gICAgICB0aGlzLmN0eC56b29tTWFuYWdlci5hZGRMaXN0ZW5lcihcInpvb20tcGFuLXN0YXJ0XCIsICgpID0+IHRoaXMuY2xlYXJUb29sdGlwKCkpLFxuICAgICAgdGhpcy5jdHguem9vbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJ6b29tLWNoYW5nZVwiLCAoKSA9PiB0aGlzLmNsZWFyVG9vbHRpcCgpKVxuICAgICk7XG4gIH1cbiAgc2VyaWVzQ2hhbmdlZChzZXJpZXMpIHtcbiAgICB0aGlzLnNlcmllcyA9IHNlcmllcztcbiAgfVxuICBkYXRhQ2hhbmdlZCgpIHtcbiAgICB0aGlzLmN0eC50b29sdGlwTWFuYWdlci5yZW1vdmVUb29sdGlwKHRoaXMuaWQpO1xuICB9XG4gIHByZVNjZW5lUmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmxhc3RIb3ZlciAhPSBudWxsKSB7XG4gICAgICB0aGlzLmhhbmRsZUhvdmVyKHRoaXMubGFzdEhvdmVyLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgbGF5b3V0Q29tcGxldGUoZXZlbnQpIHtcbiAgICB0aGlzLmhvdmVyUmVjdCA9IGV2ZW50LnNlcmllcy5wYWRkZWRSZWN0O1xuICB9XG4gIG9uSG92ZXIoZXZlbnQpIHtcbiAgICB0aGlzLmxhc3RIb3ZlciA9IGV2ZW50O1xuICAgIHRoaXMuaG92ZXJTY2hlZHVsZXIuc2NoZWR1bGUoKTtcbiAgfVxuICBjbGVhclRvb2x0aXAoKSB7XG4gICAgdGhpcy5jdHgudG9vbHRpcE1hbmFnZXIucmVtb3ZlVG9vbHRpcCh0aGlzLmlkKTtcbiAgICB0aGlzLmxhc3RIb3ZlciA9IHZvaWQgMDtcbiAgfVxuICBoYW5kbGVIb3ZlcihldmVudCwgcmVkaXNwbGF5KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmN0eC5pbnRlcmFjdGlvbk1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUgIT09IDE2IC8qIERlZmF1bHQgKi8gJiYgc3RhdGUgIT09IDQgLyogQW5ub3RhdGlvbnMgKi8pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZLCB0YXJnZXRFbGVtZW50IH0gPSBldmVudDtcbiAgICBpZiAocmVkaXNwbGF5ID8gdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc0FjdGl2ZSgpIDogIXRoaXMuaG92ZXJSZWN0Py5jb250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpKSB7XG4gICAgICB0aGlzLmNsZWFyVG9vbHRpcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0RWxlbWVudCAmJiB0aGlzLnRvb2x0aXAuaW50ZXJhY3RpdmUgJiYgdGhpcy5jdHguZG9tTWFuYWdlci5pc01hbmFnZWRDaGlsZERPTUVsZW1lbnQodGFyZ2V0RWxlbWVudCwgXCJjYW52YXMtb3ZlcmxheVwiLCBERUZBVUxUX1RPT0xUSVBfQ0xBU1MpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHBpY2sgPSBwaWNrTm9kZSh0aGlzLnNlcmllcywgeyB4OiBvZmZzZXRYLCB5OiBvZmZzZXRZIH0sIFwidG9vbHRpcFwiKTtcbiAgICBpZiAoIXBpY2spIHtcbiAgICAgIHRoaXMuY2xlYXJUb29sdGlwKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGh0bWwgPSBwaWNrLnNlcmllcy5nZXRUb29sdGlwSHRtbChwaWNrLmRhdHVtKTtcbiAgICBjb25zdCB0b29sdGlwRW5hYmxlZCA9IHRoaXMudG9vbHRpcC5lbmFibGVkICYmIHBpY2suc2VyaWVzLnRvb2x0aXBFbmFibGVkO1xuICAgIGNvbnN0IHNob3VsZFVwZGF0ZVRvb2x0aXAgPSB0b29sdGlwRW5hYmxlZCAmJiBodG1sICE9IG51bGw7XG4gICAgaWYgKHNob3VsZFVwZGF0ZVRvb2x0aXApIHtcbiAgICAgIGNvbnN0IG1ldGEgPSBUb29sdGlwTWFuYWdlci5tYWtlVG9vbHRpcE1ldGEoZXZlbnQsIHBpY2suZGF0dW0pO1xuICAgICAgdGhpcy5jdHgudG9vbHRpcE1hbmFnZXIudXBkYXRlVG9vbHRpcCh0aGlzLmlkLCBtZXRhLCBodG1sKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXNBcmVhTWFuYWdlci50c1xudmFyIFNlcmllc0FyZWFNYW5hZ2VyID0gY2xhc3MgZXh0ZW5kcyBCYXNlTWFuYWdlciB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0LCBjdHgsIGNoYXJ0VHlwZTIsIHRvb2x0aXAsIGhpZ2hsaWdodCwgb3ZlcmxheXMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuaWQgPSBjcmVhdGVJZCh0aGlzKTtcbiAgICB0aGlzLnNlcmllcyA9IFtdO1xuICAgIHRoaXMuc3ViTWFuYWdlcnMgPSBbXG4gICAgICBuZXcgU2VyaWVzQXJlYUZvY3VzTWFuYWdlcih0aGlzLmlkLCBjaGFydCwgY3R4LCBjaGFydFR5cGUyLCBvdmVybGF5cyksXG4gICAgICBuZXcgU2VyaWVzQXJlYUhpZ2hsaWdodE1hbmFnZXIodGhpcy5pZCwgY2hhcnQsIGN0eCwgaGlnaGxpZ2h0KSxcbiAgICAgIG5ldyBTZXJpZXNBcmVhVG9vbHRpcE1hbmFnZXIodGhpcy5pZCwgY2hhcnQsIGN0eCwgdG9vbHRpcCksXG4gICAgICBuZXcgU2VyaWVzQXJlYUNsaWNrTWFuYWdlcih0aGlzLmlkLCBjaGFydCwgY3R4KVxuICAgIF07XG4gICAgY29uc3Qgc2VyaWVzUmVnaW9uID0gdGhpcy5jdHgucmVnaW9uTWFuYWdlci5nZXRSZWdpb24oXCJzZXJpZXNcIiAvKiBTRVJJRVMgKi8pO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgKCkgPT4gdGhpcy5zdWJNYW5hZ2Vycy5mb3JFYWNoKChzKSA9PiBzLmRlc3Ryb3koKSksXG4gICAgICBzZXJpZXNSZWdpb24uYWRkTGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCAoZXZlbnQpID0+IHRoaXMub25Db250ZXh0TWVudShldmVudCksIDMxIC8qIEFsbCAqLyksXG4gICAgICB0aGlzLmN0eC51cGRhdGVTZXJ2aWNlLmFkZExpc3RlbmVyKFwicHJlLXNjZW5lLXJlbmRlclwiLCAoKSA9PiB0aGlzLnByZVNjZW5lUmVuZGVyKCkpXG4gICAgKTtcbiAgfVxuICBkYXRhQ2hhbmdlZCgpIHtcbiAgICBmb3IgKGNvbnN0IG1hbmFnZXIgb2YgdGhpcy5zdWJNYW5hZ2Vycykge1xuICAgICAgbWFuYWdlci5kYXRhQ2hhbmdlZD8uKCk7XG4gICAgfVxuICB9XG4gIHByZVNjZW5lUmVuZGVyKCkge1xuICAgIGZvciAoY29uc3QgbWFuYWdlciBvZiB0aGlzLnN1Yk1hbmFnZXJzKSB7XG4gICAgICBtYW5hZ2VyLnByZVNjZW5lUmVuZGVyPy4oKTtcbiAgICB9XG4gIH1cbiAgc2VyaWVzQ2hhbmdlZChzZXJpZXMpIHtcbiAgICB0aGlzLnNlcmllcyA9IHNlcmllcztcbiAgICBmb3IgKGNvbnN0IG1hbmFnZXIgb2YgdGhpcy5zdWJNYW5hZ2Vycykge1xuICAgICAgbWFuYWdlci5zZXJpZXNDaGFuZ2VkKHNlcmllcyk7XG4gICAgfVxuICB9XG4gIG9uQ29udGV4dE1lbnUoZXZlbnQpIHtcbiAgICBjb25zdCB7IERlZmF1bHQ6IERlZmF1bHQyLCBDb250ZXh0TWVudSB9ID0gSW50ZXJhY3Rpb25TdGF0ZTtcbiAgICBsZXQgcGlja2VkTm9kZTtcbiAgICBpZiAodGhpcy5jdHguaW50ZXJhY3Rpb25NYW5hZ2VyLmdldFN0YXRlKCkgJiAoRGVmYXVsdDIgfCBDb250ZXh0TWVudSkpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gcGlja05vZGUodGhpcy5zZXJpZXMsIHsgeDogZXZlbnQub2Zmc2V0WCwgeTogZXZlbnQub2Zmc2V0WSB9LCBcImNvbnRleHQtbWVudVwiKTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB0aGlzLmN0eC5oaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkKTtcbiAgICAgICAgcGlja2VkTm9kZSA9IG1hdGNoLmRhdHVtO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmN0eC5jb250ZXh0TWVudVJlZ2lzdHJ5LmRpc3BhdGNoQ29udGV4dChcInNlcmllc1wiLCBldmVudCwgeyBwaWNrZWROb2RlIH0pO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvc2VyaWVzTGF5ZXJNYW5hZ2VyLnRzXG52YXIgU0VSSUVTX1RIUkVTSE9MRF9GT1JfQUdHUkVTU0lWRV9MQVlFUl9SRURVQ1RJT04gPSAzMDtcbnZhciBTZXJpZXNMYXllck1hbmFnZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHNlcmllc1Jvb3QsIGhpZ2hsaWdodFJvb3QsIGFubm90YXRpb25Sb290KSB7XG4gICAgdGhpcy5zZXJpZXNSb290ID0gc2VyaWVzUm9vdDtcbiAgICB0aGlzLmhpZ2hsaWdodFJvb3QgPSBoaWdobGlnaHRSb290O1xuICAgIHRoaXMuYW5ub3RhdGlvblJvb3QgPSBhbm5vdGF0aW9uUm9vdDtcbiAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgIHRoaXMuc2VyaWVzID0ge307XG4gICAgdGhpcy5leHBlY3RlZFNlcmllc0NvdW50ID0gMTtcbiAgICB0aGlzLm1vZGUgPSBcIm5vcm1hbFwiO1xuICB9XG4gIHNldFNlcmllc0NvdW50KGNvdW50KSB7XG4gICAgdGhpcy5leHBlY3RlZFNlcmllc0NvdW50ID0gY291bnQ7XG4gIH1cbiAgcmVxdWVzdEdyb3VwKHNlcmllc0NvbmZpZykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJuYWxJZCxcbiAgICAgIHR5cGUsXG4gICAgICByb290R3JvdXA6IHNlcmllc1Jvb3RHcm91cCxcbiAgICAgIGhpZ2hsaWdodEdyb3VwOiBzZXJpZXNIaWdobGlnaHRHcm91cCxcbiAgICAgIGFubm90YXRpb25Hcm91cDogc2VyaWVzQW5ub3RhdGlvbkdyb3VwLFxuICAgICAgc2VyaWVzR3JvdXBpbmdcbiAgICB9ID0gc2VyaWVzQ29uZmlnO1xuICAgIGNvbnN0IHsgZ3JvdXBJbmRleCA9IGludGVybmFsSWQgfSA9IHNlcmllc0dyb3VwaW5nID8/IHt9O1xuICAgIGlmICh0aGlzLnNlcmllc1tpbnRlcm5hbElkXSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIHNlcmllcyBhbHJlYWR5IGhhcyBhbiBhbGxvY2F0ZWQgbGF5ZXI6ICR7dGhpcy5zZXJpZXNbaW50ZXJuYWxJZF19YCk7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLnNlcmllcykubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLm1vZGUgPSB0aGlzLmV4cGVjdGVkU2VyaWVzQ291bnQgPj0gU0VSSUVTX1RIUkVTSE9MRF9GT1JfQUdHUkVTU0lWRV9MQVlFUl9SRURVQ1RJT04gPyBcImFnZ3Jlc3NpdmUtZ3JvdXBpbmdcIiA6IFwibm9ybWFsXCI7XG4gICAgfVxuICAgIChfYSA9IHRoaXMuZ3JvdXBzKVt0eXBlXSA/PyAoX2FbdHlwZV0gPSB7fSk7XG4gICAgY29uc3QgbG9va3VwSW5kZXggPSB0aGlzLmxvb2t1cElkeChncm91cEluZGV4KTtcbiAgICBsZXQgZ3JvdXBJbmZvID0gdGhpcy5ncm91cHNbdHlwZV1bbG9va3VwSW5kZXhdO1xuICAgIGlmICghZ3JvdXBJbmZvKSB7XG4gICAgICBncm91cEluZm8gPSAoX2IgPSB0aGlzLmdyb3Vwc1t0eXBlXSlbbG9va3VwSW5kZXhdID8/IChfYltsb29rdXBJbmRleF0gPSB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGlkOiBsb29rdXBJbmRleCxcbiAgICAgICAgc2VyaWVzSWRzOiBbXSxcbiAgICAgICAgZ3JvdXA6IHRoaXMuc2VyaWVzUm9vdC5hcHBlbmRDaGlsZChcbiAgICAgICAgICBuZXcgR3JvdXAoe1xuICAgICAgICAgICAgbmFtZTogYCR7dHlwZX0tY29udGVudGAsXG4gICAgICAgICAgICBsYXllcjogdHJ1ZSxcbiAgICAgICAgICAgIHpJbmRleDogNCAvKiBTRVJJRVNfTEFZRVJfWklOREVYICovLFxuICAgICAgICAgICAgekluZGV4U3ViT3JkZXI6IHNlcmllc0NvbmZpZy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwiZGF0YVwiKVxuICAgICAgICAgIH0pXG4gICAgICAgICksXG4gICAgICAgIGhpZ2hsaWdodDogdGhpcy5oaWdobGlnaHRSb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgIG5ldyBHcm91cCh7XG4gICAgICAgICAgICBuYW1lOiBgJHt0eXBlfS1oaWdobGlnaHRgLFxuICAgICAgICAgICAgekluZGV4OiA0IC8qIFNFUklFU19MQVlFUl9aSU5ERVggKi8sXG4gICAgICAgICAgICB6SW5kZXhTdWJPcmRlcjogc2VyaWVzQ29uZmlnLmdldEdyb3VwWkluZGV4U3ViT3JkZXIoXCJoaWdobGlnaHRcIilcbiAgICAgICAgICB9KVxuICAgICAgICApLFxuICAgICAgICBhbm5vdGF0aW9uOiB0aGlzLmFubm90YXRpb25Sb290LmFwcGVuZENoaWxkKFxuICAgICAgICAgIG5ldyBHcm91cCh7XG4gICAgICAgICAgICBuYW1lOiBgJHt0eXBlfS1hbm5vdGF0aW9uYCxcbiAgICAgICAgICAgIHpJbmRleDogNCAvKiBTRVJJRVNfTEFZRVJfWklOREVYICovLFxuICAgICAgICAgICAgekluZGV4U3ViT3JkZXI6IHNlcmllc0NvbmZpZy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwiYW5ub3RhdGlvblwiKVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLnNlcmllc1tpbnRlcm5hbElkXSA9IHsgbGF5ZXJTdGF0ZTogZ3JvdXBJbmZvLCBzZXJpZXNDb25maWcgfTtcbiAgICBncm91cEluZm8uc2VyaWVzSWRzLnB1c2goaW50ZXJuYWxJZCk7XG4gICAgZ3JvdXBJbmZvLmdyb3VwLmFwcGVuZENoaWxkKHNlcmllc1Jvb3RHcm91cCk7XG4gICAgZ3JvdXBJbmZvLmhpZ2hsaWdodC5hcHBlbmRDaGlsZChzZXJpZXNIaWdobGlnaHRHcm91cCk7XG4gICAgZ3JvdXBJbmZvLmFubm90YXRpb24uYXBwZW5kQ2hpbGQoc2VyaWVzQW5ub3RhdGlvbkdyb3VwKTtcbiAgICByZXR1cm4gZ3JvdXBJbmZvLmdyb3VwO1xuICB9XG4gIGNoYW5nZUdyb3VwKHNlcmllc0NvbmZpZykge1xuICAgIGNvbnN0IHsgaW50ZXJuYWxJZCwgc2VyaWVzR3JvdXBpbmcsIHR5cGUsIHJvb3RHcm91cCwgaGlnaGxpZ2h0R3JvdXAsIGFubm90YXRpb25Hcm91cCwgb2xkR3JvdXBpbmcgfSA9IHNlcmllc0NvbmZpZztcbiAgICBjb25zdCB7IGdyb3VwSW5kZXggPSBpbnRlcm5hbElkIH0gPSBzZXJpZXNHcm91cGluZyA/PyB7fTtcbiAgICBpZiAodGhpcy5ncm91cHNbdHlwZV0/Lltncm91cEluZGV4XT8uc2VyaWVzSWRzLmluY2x1ZGVzKGludGVybmFsSWQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnNlcmllc1tpbnRlcm5hbElkXSAhPSBudWxsKSB7XG4gICAgICB0aGlzLnJlbGVhc2VHcm91cCh7XG4gICAgICAgIGludGVybmFsSWQsXG4gICAgICAgIHNlcmllc0dyb3VwaW5nOiBvbGRHcm91cGluZyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcm9vdEdyb3VwLFxuICAgICAgICBoaWdobGlnaHRHcm91cCxcbiAgICAgICAgYW5ub3RhdGlvbkdyb3VwXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5yZXF1ZXN0R3JvdXAoc2VyaWVzQ29uZmlnKTtcbiAgfVxuICByZWxlYXNlR3JvdXAoc2VyaWVzQ29uZmlnKSB7XG4gICAgY29uc3QgeyBpbnRlcm5hbElkLCByb290R3JvdXAsIGhpZ2hsaWdodEdyb3VwLCBhbm5vdGF0aW9uR3JvdXAsIHR5cGUgfSA9IHNlcmllc0NvbmZpZztcbiAgICBpZiAodGhpcy5zZXJpZXNbaW50ZXJuYWxJZF0gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBzZXJpZXMgZG9lc24ndCBoYXZlIGFuIGFsbG9jYXRlZCBsYXllcjogJHtpbnRlcm5hbElkfWApO1xuICAgIH1cbiAgICBjb25zdCBncm91cEluZm8gPSB0aGlzLnNlcmllc1tpbnRlcm5hbElkXT8ubGF5ZXJTdGF0ZTtcbiAgICBpZiAoZ3JvdXBJbmZvKSB7XG4gICAgICBncm91cEluZm8uc2VyaWVzSWRzID0gZ3JvdXBJbmZvLnNlcmllc0lkcy5maWx0ZXIoKHYpID0+IHYgIT09IGludGVybmFsSWQpO1xuICAgICAgZ3JvdXBJbmZvLmdyb3VwLnJlbW92ZUNoaWxkKHJvb3RHcm91cCk7XG4gICAgICBncm91cEluZm8uaGlnaGxpZ2h0LnJlbW92ZUNoaWxkKGhpZ2hsaWdodEdyb3VwKTtcbiAgICAgIGdyb3VwSW5mby5hbm5vdGF0aW9uLnJlbW92ZUNoaWxkKGFubm90YXRpb25Hcm91cCk7XG4gICAgfVxuICAgIGlmIChncm91cEluZm8/LnNlcmllc0lkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuc2VyaWVzUm9vdC5yZW1vdmVDaGlsZChncm91cEluZm8uZ3JvdXApO1xuICAgICAgdGhpcy5oaWdobGlnaHRSb290LnJlbW92ZUNoaWxkKGdyb3VwSW5mby5oaWdobGlnaHQpO1xuICAgICAgdGhpcy5hbm5vdGF0aW9uUm9vdC5yZW1vdmVDaGlsZChncm91cEluZm8uYW5ub3RhdGlvbik7XG4gICAgICBkZWxldGUgdGhpcy5ncm91cHNbZ3JvdXBJbmZvLnR5cGVdW2dyb3VwSW5mby5pZF07XG4gICAgICBkZWxldGUgdGhpcy5ncm91cHNbdHlwZV1baW50ZXJuYWxJZF07XG4gICAgfSBlbHNlIGlmIChncm91cEluZm8/LnNlcmllc0lkcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBsZWFkU2VyaWVzQ29uZmlnID0gdGhpcy5zZXJpZXNbZ3JvdXBJbmZvPy5zZXJpZXNJZHM/LlswXV0/LnNlcmllc0NvbmZpZztcbiAgICAgIGdyb3VwSW5mby5ncm91cC56SW5kZXhTdWJPcmRlciA9IGxlYWRTZXJpZXNDb25maWc/LmdldEdyb3VwWkluZGV4U3ViT3JkZXIoXCJkYXRhXCIpO1xuICAgICAgZ3JvdXBJbmZvLmhpZ2hsaWdodC56SW5kZXhTdWJPcmRlciA9IGxlYWRTZXJpZXNDb25maWc/LmdldEdyb3VwWkluZGV4U3ViT3JkZXIoXCJoaWdobGlnaHRcIik7XG4gICAgICBncm91cEluZm8uYW5ub3RhdGlvbi56SW5kZXhTdWJPcmRlciA9IGxlYWRTZXJpZXNDb25maWc/LmdldEdyb3VwWkluZGV4U3ViT3JkZXIoXCJhbm5vdGF0aW9uXCIpO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5zZXJpZXNbaW50ZXJuYWxJZF07XG4gIH1cbiAgbG9va3VwSWR4KGdyb3VwSW5kZXgpIHtcbiAgICBpZiAodGhpcy5tb2RlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICByZXR1cm4gZ3JvdXBJbmRleDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBncm91cEluZGV4ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBncm91cEluZGV4ID0gTnVtYmVyKGdyb3VwSW5kZXguc3BsaXQoXCItXCIpLmF0KC0xKSk7XG4gICAgICBpZiAoIWdyb3VwSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmZsb29yKFxuICAgICAgY2xhbXAoMCwgZ3JvdXBJbmRleCAvIHRoaXMuZXhwZWN0ZWRTZXJpZXNDb3VudCwgMSkgKiBTRVJJRVNfVEhSRVNIT0xEX0ZPUl9BR0dSRVNTSVZFX0xBWUVSX1JFRFVDVElPTlxuICAgICk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGNvbnN0IGdyb3VwcyBvZiBPYmplY3QudmFsdWVzKHRoaXMuZ3JvdXBzKSkge1xuICAgICAgZm9yIChjb25zdCBncm91cEluZm8gb2YgT2JqZWN0LnZhbHVlcyhncm91cHMpKSB7XG4gICAgICAgIHRoaXMuc2VyaWVzUm9vdC5yZW1vdmVDaGlsZChncm91cEluZm8uZ3JvdXApO1xuICAgICAgICB0aGlzLmhpZ2hsaWdodFJvb3QucmVtb3ZlQ2hpbGQoZ3JvdXBJbmZvLmhpZ2hsaWdodCk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblJvb3QucmVtb3ZlQ2hpbGQoZ3JvdXBJbmZvLmFubm90YXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgIHRoaXMuc2VyaWVzID0ge307XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3VwZGF0ZS9iYXNlTGF5b3V0UHJvY2Vzc29yLnRzXG52YXIgQmFzZUxheW91dFByb2Nlc3NvciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2hhcnRMaWtlLCBsYXlvdXRTZXJ2aWNlKSB7XG4gICAgdGhpcy5jaGFydExpa2UgPSBjaGFydExpa2U7XG4gICAgdGhpcy5sYXlvdXRTZXJ2aWNlID0gbGF5b3V0U2VydmljZTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzb25hcmpzL25vLWR1cGxpY2F0ZS1zdHJpbmdcbiAgICAgIHRoaXMubGF5b3V0U2VydmljZS5hZGRMaXN0ZW5lcihcInN0YXJ0LWxheW91dFwiLCAoZSkgPT4gdGhpcy5wb3NpdGlvblBhZGRpbmcoZSkpLFxuICAgICAgdGhpcy5sYXlvdXRTZXJ2aWNlLmFkZExpc3RlbmVyKFwibGF5b3V0LWNvbXBsZXRlXCIsIChlKSA9PiB0aGlzLmFsaWduQ2FwdGlvbnMoZSkpLFxuICAgICAgdGhpcy5sYXlvdXRTZXJ2aWNlLmFkZExpc3RlbmVyKFwic3RhcnQtbGF5b3V0XCIsIChlKSA9PiB0aGlzLnBvc2l0aW9uQ2FwdGlvbnMoZSkpXG4gICAgKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gIH1cbiAgcG9zaXRpb25QYWRkaW5nKGN0eCkge1xuICAgIGNvbnN0IHsgc2hyaW5rUmVjdCB9ID0gY3R4O1xuICAgIGNvbnN0IHsgcGFkZGluZyB9ID0gdGhpcy5jaGFydExpa2U7XG4gICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy5sZWZ0LCBcImxlZnRcIik7XG4gICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy50b3AsIFwidG9wXCIpO1xuICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcucmlnaHQsIFwicmlnaHRcIik7XG4gICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy5ib3R0b20sIFwiYm90dG9tXCIpO1xuICAgIHJldHVybiB7IC4uLmN0eCwgc2hyaW5rUmVjdCB9O1xuICB9XG4gIHBvc2l0aW9uQ2FwdGlvbnMoY3R4KSB7XG4gICAgY29uc3QgeyBzaHJpbmtSZWN0LCBwb3NpdGlvbnMsIHBhZGRpbmcgfSA9IGN0eDtcbiAgICBjb25zdCB7IHRpdGxlLCBzdWJ0aXRsZSwgZm9vdG5vdGUsIHRpdGxlUGFkZGluZyB9ID0gdGhpcy5jaGFydExpa2U7XG4gICAgY29uc3QgcGFkZGVkU2hyaW5rUmVjdCA9IHNocmlua1JlY3QuY2xvbmUoKS5zaHJpbmsodGl0bGVQYWRkaW5nKTtcbiAgICBjb25zdCBuZXdTaHJpbmtSZWN0ID0gc2hyaW5rUmVjdC5jbG9uZSgpO1xuICAgIGNvbnN0IHVwZGF0ZUNhcHRpb24gPSAoY2FwdGlvbikgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdENhcHRpb25IZWlnaHQgPSBzaHJpbmtSZWN0LmhlaWdodCAvIDEwO1xuICAgICAgY29uc3QgY2FwdGlvbkxpbmVIZWlnaHQgPSBjYXB0aW9uLmxpbmVIZWlnaHQgPz8gY2FwdGlvbi5mb250U2l6ZSAqIFRleHQuZGVmYXVsdExpbmVIZWlnaHRSYXRpbztcbiAgICAgIGNvbnN0IG1heFdpZHRoID0gc2hyaW5rUmVjdC53aWR0aDtcbiAgICAgIGNvbnN0IG1heEhlaWdodCA9IE1hdGgubWF4KGNhcHRpb25MaW5lSGVpZ2h0LCBkZWZhdWx0Q2FwdGlvbkhlaWdodCk7XG4gICAgICBjYXB0aW9uLmNvbXB1dGVUZXh0V3JhcChtYXhXaWR0aCwgbWF4SGVpZ2h0KTtcbiAgICB9O1xuICAgIGNvbnN0IGNvbXB1dGVYID0gKGFsaWduKSA9PiB7XG4gICAgICBpZiAoYWxpZ24gPT09IFwibGVmdFwiKSB7XG4gICAgICAgIHJldHVybiBwYWRkZWRTaHJpbmtSZWN0Lng7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduID09PSBcInJpZ2h0XCIpIHtcbiAgICAgICAgcmV0dXJuIHBhZGRlZFNocmlua1JlY3QueCArIHBhZGRlZFNocmlua1JlY3Qud2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKGFsaWduICE9PSBcImNlbnRlclwiKSB7XG4gICAgICAgIExvZ2dlci5lcnJvcihgaW52YWxpZCB0ZXh0QWxpZ24gdmFsdWU6ICR7YWxpZ259YCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFkZGVkU2hyaW5rUmVjdC54ICsgcGFkZGVkU2hyaW5rUmVjdC53aWR0aCAvIDI7XG4gICAgfTtcbiAgICBjb25zdCBwb3NpdGlvblRvcEFuZFNocmlua0JCb3ggPSAoY2FwdGlvbiwgc3BhY2luZykgPT4ge1xuICAgICAgY29uc3QgYmFzZVkgPSBwYWRkZWRTaHJpbmtSZWN0Lnk7XG4gICAgICBjYXB0aW9uLm5vZGUueCA9IGNvbXB1dGVYKGNhcHRpb24udGV4dEFsaWduKTtcbiAgICAgIGNhcHRpb24ubm9kZS55ID0gYmFzZVk7XG4gICAgICBjYXB0aW9uLm5vZGUudGV4dEJhc2VsaW5lID0gXCJ0b3BcIjtcbiAgICAgIHVwZGF0ZUNhcHRpb24oY2FwdGlvbik7XG4gICAgICBjb25zdCBiYm94ID0gY2FwdGlvbi5ub2RlLmdldEJCb3goKTtcbiAgICAgIGNvbnN0IGJib3hIZWlnaHQgPSBNYXRoLmNlaWwoYmJveC55IC0gYmFzZVkgKyBiYm94LmhlaWdodCArIHNwYWNpbmcpO1xuICAgICAgaWYgKGNhcHRpb24ubGF5b3V0U3R5bGUgPT09IFwiYmxvY2tcIikge1xuICAgICAgICBuZXdTaHJpbmtSZWN0LnNocmluayhiYm94SGVpZ2h0ICsgMiAqIHRpdGxlUGFkZGluZywgXCJ0b3BcIik7XG4gICAgICAgIHBhZGRlZFNocmlua1JlY3Quc2hyaW5rKGJib3hIZWlnaHQsIFwidG9wXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJib3g7XG4gICAgfTtcbiAgICBjb25zdCBwb3NpdGlvbkJvdHRvbUFuZFNocmlua0JCb3ggPSAoY2FwdGlvbiwgc3BhY2luZykgPT4ge1xuICAgICAgY29uc3QgYmFzZVkgPSBwYWRkZWRTaHJpbmtSZWN0LnkgKyBwYWRkZWRTaHJpbmtSZWN0LmhlaWdodDtcbiAgICAgIGNhcHRpb24ubm9kZS54ID0gY29tcHV0ZVgoY2FwdGlvbi50ZXh0QWxpZ24pO1xuICAgICAgY2FwdGlvbi5ub2RlLnkgPSBiYXNlWTtcbiAgICAgIGNhcHRpb24ubm9kZS50ZXh0QmFzZWxpbmUgPSBcImJvdHRvbVwiO1xuICAgICAgdXBkYXRlQ2FwdGlvbihjYXB0aW9uKTtcbiAgICAgIGNvbnN0IGJib3ggPSBjYXB0aW9uLm5vZGUuZ2V0QkJveCgpO1xuICAgICAgY29uc3QgYmJveEhlaWdodCA9IE1hdGguY2VpbChiYXNlWSAtIGJib3gueSArIHNwYWNpbmcpO1xuICAgICAgaWYgKGNhcHRpb24ubGF5b3V0U3R5bGUgPT09IFwiYmxvY2tcIikge1xuICAgICAgICBuZXdTaHJpbmtSZWN0LnNocmluayhiYm94SGVpZ2h0ICsgMiAqIHRpdGxlUGFkZGluZywgXCJib3R0b21cIik7XG4gICAgICAgIHBhZGRlZFNocmlua1JlY3Quc2hyaW5rKGJib3hIZWlnaHQsIFwiYm90dG9tXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJib3g7XG4gICAgfTtcbiAgICB0aXRsZS5ub2RlLnZpc2libGUgPSB0aXRsZS5lbmFibGVkO1xuICAgIHN1YnRpdGxlLm5vZGUudmlzaWJsZSA9IHN1YnRpdGxlLmVuYWJsZWQ7XG4gICAgZm9vdG5vdGUubm9kZS52aXNpYmxlID0gZm9vdG5vdGUuZW5hYmxlZDtcbiAgICBpZiAodGl0bGUuZW5hYmxlZCkge1xuICAgICAgY29uc3QgeyBzcGFjaW5nID0gc3VidGl0bGUuZW5hYmxlZCA/IENhcHRpb24uU01BTExfUEFERElORyA6IENhcHRpb24uTEFSR0VfUEFERElORyB9ID0gdGl0bGU7XG4gICAgICBwb3NpdGlvbnMudGl0bGUgPSBwb3NpdGlvblRvcEFuZFNocmlua0JCb3godGl0bGUsIHNwYWNpbmcpO1xuICAgIH1cbiAgICBpZiAoc3VidGl0bGUuZW5hYmxlZCkge1xuICAgICAgcG9zaXRpb25zLnN1YnRpdGxlID0gcG9zaXRpb25Ub3BBbmRTaHJpbmtCQm94KHN1YnRpdGxlLCBzdWJ0aXRsZS5zcGFjaW5nID8/IDApO1xuICAgIH1cbiAgICBpZiAoZm9vdG5vdGUuZW5hYmxlZCkge1xuICAgICAgcG9zaXRpb25zLmZvb3Rub3RlID0gcG9zaXRpb25Cb3R0b21BbmRTaHJpbmtCQm94KGZvb3Rub3RlLCBmb290bm90ZS5zcGFjaW5nID8/IDApO1xuICAgIH1cbiAgICBwYWRkaW5nLnRpdGxlID0gdGl0bGVQYWRkaW5nO1xuICAgIHJldHVybiB7IC4uLmN0eCwgc2hyaW5rUmVjdDogbmV3U2hyaW5rUmVjdCwgcG9zaXRpb25zIH07XG4gIH1cbiAgYWxpZ25DYXB0aW9ucyhjdHgpIHtcbiAgICBjb25zdCB7IHJlY3QgfSA9IGN0eC5zZXJpZXM7XG4gICAgY29uc3QgeyB0aXRsZSwgc3VidGl0bGUsIGZvb3Rub3RlLCB0aXRsZVBhZGRpbmcgfSA9IHRoaXMuY2hhcnRMaWtlO1xuICAgIGZvciAoY29uc3QgY2FwdGlvbiBvZiBbdGl0bGUsIHN1YnRpdGxlLCBmb290bm90ZV0pIHtcbiAgICAgIGlmIChjYXB0aW9uLmxheW91dFN0eWxlICE9PSBcIm92ZXJsYXlcIilcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoY2FwdGlvbi50ZXh0QWxpZ24gPT09IFwibGVmdFwiKSB7XG4gICAgICAgIGNhcHRpb24ubm9kZS54ID0gcmVjdC54ICsgdGl0bGVQYWRkaW5nO1xuICAgICAgfSBlbHNlIGlmIChjYXB0aW9uLnRleHRBbGlnbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgIGNvbnN0IGJib3ggPSBjYXB0aW9uLm5vZGUuZ2V0QkJveCgpO1xuICAgICAgICBjYXB0aW9uLm5vZGUueCA9IHJlY3QueCArIHJlY3Qud2lkdGggLSBiYm94LndpZHRoIC0gdGl0bGVQYWRkaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdXBkYXRlL2RhdGFXaW5kb3dQcm9jZXNzb3IudHNcbnZhciBEYXRhV2luZG93UHJvY2Vzc29yID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YVNlcnZpY2UsIHVwZGF0ZVNlcnZpY2UsIHpvb21NYW5hZ2VyKSB7XG4gICAgdGhpcy5jaGFydCA9IGNoYXJ0O1xuICAgIHRoaXMuZGF0YVNlcnZpY2UgPSBkYXRhU2VydmljZTtcbiAgICB0aGlzLnVwZGF0ZVNlcnZpY2UgPSB1cGRhdGVTZXJ2aWNlO1xuICAgIHRoaXMuem9vbU1hbmFnZXIgPSB6b29tTWFuYWdlcjtcbiAgICB0aGlzLmRpcnR5Wm9vbSA9IGZhbHNlO1xuICAgIHRoaXMuZGlydHlEYXRhU291cmNlID0gZmFsc2U7XG4gICAgdGhpcy5sYXN0QXhpc1pvb21zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIHRoaXMuZGF0YVNlcnZpY2UuYWRkTGlzdGVuZXIoXCJkYXRhLXNvdXJjZS1jaGFuZ2VcIiwgKCkgPT4gdGhpcy5vbkRhdGFTb3VyY2VDaGFuZ2UoKSksXG4gICAgICB0aGlzLmRhdGFTZXJ2aWNlLmFkZExpc3RlbmVyKFwiZGF0YS1sb2FkXCIsICgpID0+IHRoaXMub25EYXRhTG9hZCgpKSxcbiAgICAgIHRoaXMuZGF0YVNlcnZpY2UuYWRkTGlzdGVuZXIoXCJkYXRhLWVycm9yXCIsICgpID0+IHRoaXMub25EYXRhRXJyb3IoKSksXG4gICAgICB0aGlzLnVwZGF0ZVNlcnZpY2UuYWRkTGlzdGVuZXIoXCJ1cGRhdGUtY29tcGxldGVcIiwgKCkgPT4gdGhpcy5vblVwZGF0ZUNvbXBsZXRlKCkpLFxuICAgICAgdGhpcy56b29tTWFuYWdlci5hZGRMaXN0ZW5lcihcInpvb20tY2hhbmdlXCIsICgpID0+IHRoaXMub25ab29tQ2hhbmdlKCkpXG4gICAgKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gIH1cbiAgb25EYXRhTG9hZCgpIHtcbiAgICB0aGlzLnVwZGF0ZVNlcnZpY2UudXBkYXRlKDEgLyogVVBEQVRFX0RBVEEgKi8pO1xuICB9XG4gIG9uRGF0YUVycm9yKCkge1xuICAgIHRoaXMudXBkYXRlU2VydmljZS51cGRhdGUoMyAvKiBQRVJGT1JNX0xBWU9VVCAqLyk7XG4gIH1cbiAgb25EYXRhU291cmNlQ2hhbmdlKCkge1xuICAgIHRoaXMuZGlydHlEYXRhU291cmNlID0gdHJ1ZTtcbiAgfVxuICBvblVwZGF0ZUNvbXBsZXRlKCkge1xuICAgIGlmICghdGhpcy5kaXJ0eVpvb20gJiYgIXRoaXMuZGlydHlEYXRhU291cmNlKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMudXBkYXRlV2luZG93KCkuY2F0Y2goKGUpID0+IExvZ2dlci5lcnJvck9uY2UoZSkpO1xuICB9XG4gIG9uWm9vbUNoYW5nZSgpIHtcbiAgICB0aGlzLmRpcnR5Wm9vbSA9IHRydWU7XG4gIH1cbiAgYXN5bmMgdXBkYXRlV2luZG93KCkge1xuICAgIGlmICghdGhpcy5kYXRhU2VydmljZS5pc0xhenkoKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBheGlzID0gdGhpcy5nZXRWYWxpZEF4aXMoKTtcbiAgICBsZXQgd2luZG93MjtcbiAgICBsZXQgc2hvdWxkUmVmcmVzaCA9IHRydWU7XG4gICAgaWYgKGF4aXMpIHtcbiAgICAgIGNvbnN0IHpvb20yID0gdGhpcy56b29tTWFuYWdlci5nZXRBeGlzWm9vbShheGlzLmlkKTtcbiAgICAgIHdpbmRvdzIgPSB0aGlzLmdldEF4aXNXaW5kb3coYXhpcywgem9vbTIpO1xuICAgICAgc2hvdWxkUmVmcmVzaCA9IHRoaXMuc2hvdWxkUmVmcmVzaChheGlzLCB6b29tMik7XG4gICAgfVxuICAgIHRoaXMuZGlydHlab29tID0gZmFsc2U7XG4gICAgdGhpcy5kaXJ0eURhdGFTb3VyY2UgPSBmYWxzZTtcbiAgICBpZiAoIXNob3VsZFJlZnJlc2gpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5kYXRhU2VydmljZS5sb2FkKHsgd2luZG93U3RhcnQ6IHdpbmRvdzI/Lm1pbiwgd2luZG93RW5kOiB3aW5kb3cyPy5tYXggfSk7XG4gIH1cbiAgZ2V0VmFsaWRBeGlzKCkge1xuICAgIHJldHVybiB0aGlzLmNoYXJ0LmF4ZXMuZmluZCgoYXhpcykgPT4gYXhpcy50eXBlID09PSBcInRpbWVcIik7XG4gIH1cbiAgc2hvdWxkUmVmcmVzaChheGlzLCB6b29tMikge1xuICAgIGlmICh0aGlzLmRpcnR5RGF0YVNvdXJjZSlcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICghdGhpcy5kaXJ0eVpvb20pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgbGFzdFpvb20gPSB0aGlzLmxhc3RBeGlzWm9vbXMuZ2V0KGF4aXMuaWQpO1xuICAgIGlmIChsYXN0Wm9vbSAmJiB6b29tMi5taW4gPT09IGxhc3Rab29tLm1pbiAmJiB6b29tMi5tYXggPT09IGxhc3Rab29tLm1heCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmxhc3RBeGlzWm9vbXMuc2V0KGF4aXMuaWQsIHpvb20yKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXRBeGlzV2luZG93KGF4aXMsIHpvb20yKSB7XG4gICAgY29uc3QgZG9tYWluID0gYXhpcy5zY2FsZS5nZXREb21haW4/LigpO1xuICAgIGlmICghem9vbTIgfHwgIWRvbWFpbiB8fCBkb21haW4ubGVuZ3RoID09PSAwIHx8IGlzTmFOKE51bWJlcihkb21haW5bMF0pKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBkaWZmMiA9IE51bWJlcihkb21haW5bMV0pIC0gTnVtYmVyKGRvbWFpblswXSk7XG4gICAgY29uc3QgbWluID0gbmV3IERhdGUoTnVtYmVyKGRvbWFpblswXSkgKyBkaWZmMiAqIHpvb20yLm1pbik7XG4gICAgY29uc3QgbWF4ID0gbmV3IERhdGUoTnVtYmVyKGRvbWFpblswXSkgKyBkaWZmMiAqIHpvb20yLm1heCk7XG4gICAgcmV0dXJuIHsgbWluLCBtYXggfTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdXBkYXRlL292ZXJsYXlzUHJvY2Vzc29yLnRzXG52YXIgT3ZlcmxheXNQcm9jZXNzb3IgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNoYXJ0TGlrZSwgb3ZlcmxheXMsIGRhdGFTZXJ2aWNlLCBsYXlvdXRTZXJ2aWNlLCBsb2NhbGVNYW5hZ2VyLCBhbmltYXRpb25NYW5hZ2VyLCBkb21NYW5hZ2VyKSB7XG4gICAgdGhpcy5jaGFydExpa2UgPSBjaGFydExpa2U7XG4gICAgdGhpcy5vdmVybGF5cyA9IG92ZXJsYXlzO1xuICAgIHRoaXMuZGF0YVNlcnZpY2UgPSBkYXRhU2VydmljZTtcbiAgICB0aGlzLmxheW91dFNlcnZpY2UgPSBsYXlvdXRTZXJ2aWNlO1xuICAgIHRoaXMubG9jYWxlTWFuYWdlciA9IGxvY2FsZU1hbmFnZXI7XG4gICAgdGhpcy5hbmltYXRpb25NYW5hZ2VyID0gYW5pbWF0aW9uTWFuYWdlcjtcbiAgICB0aGlzLmRvbU1hbmFnZXIgPSBkb21NYW5hZ2VyO1xuICAgIHRoaXMuZGVzdHJveUZucyA9IFtdO1xuICAgIHRoaXMub3ZlcmxheUVsZW0gPSB0aGlzLmRvbU1hbmFnZXIuYWRkQ2hpbGQoXCJjYW52YXMtb3ZlcmxheVwiLCBcIm92ZXJsYXlcIik7XG4gICAgdGhpcy5vdmVybGF5RWxlbS5yb2xlID0gXCJzdGF0dXNcIjtcbiAgICB0aGlzLm92ZXJsYXlFbGVtLmFyaWFBdG9taWMgPSBcImZhbHNlXCI7XG4gICAgdGhpcy5vdmVybGF5RWxlbS5hcmlhTGl2ZSA9IFwicG9saXRlXCI7XG4gICAgdGhpcy5vdmVybGF5RWxlbS5jbGFzc0xpc3QudG9nZ2xlKERFRkFVTFRfT1ZFUkxBWV9DTEFTUyk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2godGhpcy5sYXlvdXRTZXJ2aWNlLmFkZExpc3RlbmVyKFwibGF5b3V0LWNvbXBsZXRlXCIsIChlKSA9PiB0aGlzLm9uTGF5b3V0Q29tcGxldGUoZSkpKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChjYikgPT4gY2IoKSk7XG4gICAgdGhpcy5kb21NYW5hZ2VyLnJlbW92ZVN0eWxlcyhcIm92ZXJsYXlzXCIpO1xuICAgIHRoaXMuZG9tTWFuYWdlci5yZW1vdmVDaGlsZChcImNhbnZhcy1vdmVybGF5XCIsIFwib3ZlcmxheVwiKTtcbiAgfVxuICBvbkxheW91dENvbXBsZXRlKHsgc2VyaWVzOiB7IHJlY3QgfSB9KSB7XG4gICAgY29uc3QgaXNMb2FkaW5nID0gdGhpcy5kYXRhU2VydmljZS5pc0xvYWRpbmcoKTtcbiAgICBjb25zdCBoYXNEYXRhID0gdGhpcy5jaGFydExpa2Uuc2VyaWVzLnNvbWUoKHMpID0+IHMuaGFzRGF0YSk7XG4gICAgY29uc3QgYW55U2VyaWVzVmlzaWJsZSA9IHRoaXMuY2hhcnRMaWtlLnNlcmllcy5zb21lKChzKSA9PiBzLnZpc2libGUpO1xuICAgIGlmICh0aGlzLm92ZXJsYXlzLmRhcmtUaGVtZSkge1xuICAgICAgdGhpcy5vdmVybGF5RWxlbS5jbGFzc0xpc3QuYWRkKERFRkFVTFRfT1ZFUkxBWV9EQVJLX0NMQVNTKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vdmVybGF5RWxlbS5jbGFzc0xpc3QucmVtb3ZlKERFRkFVTFRfT1ZFUkxBWV9EQVJLX0NMQVNTKTtcbiAgICB9XG4gICAgdGhpcy5vdmVybGF5RWxlbS5zdHlsZS5sZWZ0ID0gYCR7cmVjdC54fXB4YDtcbiAgICB0aGlzLm92ZXJsYXlFbGVtLnN0eWxlLnRvcCA9IGAke3JlY3QueX1weGA7XG4gICAgdGhpcy5vdmVybGF5RWxlbS5zdHlsZS53aWR0aCA9IGAke3JlY3Qud2lkdGh9cHhgO1xuICAgIHRoaXMub3ZlcmxheUVsZW0uc3R5bGUuaGVpZ2h0ID0gYCR7cmVjdC5oZWlnaHR9cHhgO1xuICAgIHRoaXMudG9nZ2xlT3ZlcmxheSh0aGlzLm92ZXJsYXlzLmxvYWRpbmcsIHJlY3QsIGlzTG9hZGluZyk7XG4gICAgdGhpcy50b2dnbGVPdmVybGF5KHRoaXMub3ZlcmxheXMubm9EYXRhLCByZWN0LCAhaXNMb2FkaW5nICYmICFoYXNEYXRhKTtcbiAgICB0aGlzLnRvZ2dsZU92ZXJsYXkodGhpcy5vdmVybGF5cy5ub1Zpc2libGVTZXJpZXMsIHJlY3QsIGhhc0RhdGEgJiYgIWFueVNlcmllc1Zpc2libGUpO1xuICB9XG4gIHRvZ2dsZU92ZXJsYXkob3ZlcmxheSwgc2VyaWVzUmVjdCwgdmlzaWJsZSkge1xuICAgIHRoaXMub3ZlcmxheUVsZW0uYXJpYUhpZGRlbiA9ICghdmlzaWJsZSkudG9TdHJpbmcoKTtcbiAgICBpZiAodmlzaWJsZSkge1xuICAgICAgY29uc3QgZWxlbWVudDIgPSBvdmVybGF5LmdldEVsZW1lbnQodGhpcy5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmxvY2FsZU1hbmFnZXIsIHNlcmllc1JlY3QpO1xuICAgICAgdGhpcy5vdmVybGF5RWxlbS5hcHBlbmRDaGlsZChlbGVtZW50Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG92ZXJsYXkucmVtb3ZlRWxlbWVudCgoKSA9PiB7XG4gICAgICAgIHRoaXMub3ZlcmxheUVsZW0uaW5uZXJUZXh0ID0gXCJcXHhBMFwiO1xuICAgICAgfSwgdGhpcy5hbmltYXRpb25NYW5hZ2VyKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2NoYXJ0LnRzXG52YXIgZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJvcHRzXCIpO1xudmFyIFNlcmllc0FyZWEgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnBhZGRpbmcgPSBuZXcgUGFkZGluZygwKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc0FyZWEucHJvdG90eXBlLCBcImNsaXBcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBTZXJpZXNBcmVhLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIDIpO1xudmFyIF9DaGFydCA9IGNsYXNzIF9DaGFydCBleHRlbmRzIE9ic2VydmFibGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCByZXNvdXJjZXMpIHtcbiAgICB2YXIgX2E7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlkID0gY3JlYXRlSWQodGhpcyk7XG4gICAgdGhpcy5zZXJpZXNSb290ID0gbmV3IEdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0tc2VyaWVzLXJvb3RgIH0pO1xuICAgIHRoaXMuaGlnaGxpZ2h0Um9vdCA9IG5ldyBHcm91cCh7XG4gICAgICBuYW1lOiBgJHt0aGlzLmlkfS1oaWdobGlnaHQtcm9vdGAsXG4gICAgICBsYXllcjogdHJ1ZSxcbiAgICAgIHpJbmRleDogNSAvKiBTRVJJRVNfSElHSExJR0hUX1pJTkRFWCAqLyxcbiAgICAgIG5vbkVtcHR5Q2hpbGREZXJpdmVkWkluZGV4OiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5hbm5vdGF0aW9uUm9vdCA9IG5ldyBHcm91cCh7XG4gICAgICBuYW1lOiBgJHt0aGlzLmlkfS1hbm5vdGF0aW9uLXJvb3RgLFxuICAgICAgbGF5ZXI6IHRydWUsXG4gICAgICB6SW5kZXg6IDEwIC8qIFNFUklFU19BTk5PVEFUSU9OX1pJTkRFWCAqL1xuICAgIH0pO1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUoKTtcbiAgICB0aGlzLmV4dHJhRGVidWdTdGF0cyA9IHt9O1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHRoaXMuX2ZpcnN0QXV0b1NpemUgPSB0cnVlO1xuICAgIHRoaXMucGFkZGluZyA9IG5ldyBQYWRkaW5nKDIwKTtcbiAgICB0aGlzLnRpdGxlUGFkZGluZyA9IDA7XG4gICAgdGhpcy5zZXJpZXNBcmVhID0gbmV3IFNlcmllc0FyZWEoKTtcbiAgICB0aGlzLnRpdGxlID0gbmV3IENhcHRpb24oKTtcbiAgICB0aGlzLnN1YnRpdGxlID0gbmV3IENhcHRpb24oKTtcbiAgICB0aGlzLmZvb3Rub3RlID0gbmV3IENhcHRpb24oKTtcbiAgICB0aGlzLmtleWJvYXJkID0gbmV3IEtleWJvYXJkKCk7XG4gICAgdGhpcy5tb2RlID0gXCJzdGFuZGFsb25lXCI7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9za2lwU3luYyA9IGZhbHNlO1xuICAgIHRoaXMuX2Rlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLmNoYXJ0QW5pbWF0aW9uUGhhc2UgPSBcImluaXRpYWxcIjtcbiAgICB0aGlzLm1vZHVsZXNNYW5hZ2VyID0gbmV3IE1vZHVsZXNNYW5hZ2VyKCk7XG4gICAgLy8gRklYTUU6IHpvb21NYW5hZ2VyIHNob3VsZCBiZSBvd25lZCBieSBjdHgsIGJ1dCBpdCBjYW4ndCBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgQ2FydGVzaWFuQ2hhcnQub25BeGlzQ2hhbmdlIGJlZm9yZSBjdHggaXMgaW5pdGlhbGlzZWRcbiAgICB0aGlzLnpvb21NYW5hZ2VyID0gbmV3IFpvb21NYW5hZ2VyKCk7XG4gICAgdGhpcy5wcm9jZXNzb3JzID0gW107XG4gICAgdGhpcy5xdWV1ZWRVc2VyT3B0aW9ucyA9IFtdO1xuICAgIHRoaXMuX3BlbmRpbmdGYWN0b3J5VXBkYXRlc0NvdW50ID0gMDtcbiAgICB0aGlzLl9wZXJmb3JtVXBkYXRlTm9SZW5kZXJDb3VudCA9IDA7XG4gICAgdGhpcy5fcGVyZm9ybVVwZGF0ZVNraXBBbmltYXRpb25zID0gZmFsc2U7XG4gICAgdGhpcy5wZXJmb3JtVXBkYXRlVHlwZSA9IDcgLyogTk9ORSAqLztcbiAgICB0aGlzLnVwZGF0ZVNob3J0Y3V0Q291bnQgPSAwO1xuICAgIHRoaXMuc2VyaWVzVG9VcGRhdGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMudXBkYXRlTXV0ZXggPSBuZXcgTXV0ZXgoKTtcbiAgICB0aGlzLnVwZGF0ZVJlcXVlc3RvcnMgPSB7fTtcbiAgICB0aGlzLnBlcmZvcm1VcGRhdGVUcmlnZ2VyID0gZGVib3VuY2VkQ2FsbGJhY2soYXN5bmMgKHsgY291bnQgfSkgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLnVwZGF0ZU11dGV4LmFjcXVpcmUoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMucGVyZm9ybVVwZGF0ZShjb3VudCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgTG9nZ2VyLmVycm9yKFwidXBkYXRlIGVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goKGUpID0+IExvZ2dlci5lcnJvck9uY2UoZSkpO1xuICAgIH0pO1xuICAgIHRoaXMuX3BlcmZvcm1VcGRhdGVTcGxpdHMgPSB7fTtcbiAgICB0aGlzLmF4ZXMgPSBbXTtcbiAgICB0aGlzLnNlcmllcyA9IFtdO1xuICAgIHRoaXMub25TZXJpZXNOb2RlQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgIGNvbnN0IHNlcmllc05vZGVDbGlja0V2ZW50ID0ge1xuICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgdHlwZTogXCJzZXJpZXNOb2RlQ2xpY2tcIlxuICAgICAgfTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZXJpZXNOb2RlQ2xpY2tFdmVudCwgXCJzZXJpZXNcIiwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgLy8gU2hvdWxkIGRpc3BsYXkgdGhlIGRlcHJlY2F0aW9uIHdhcm5pbmdcbiAgICAgICAgZ2V0OiAoKSA9PiBldmVudC5zZXJpZXNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5maXJlRXZlbnQoc2VyaWVzTm9kZUNsaWNrRXZlbnQpO1xuICAgIH07XG4gICAgdGhpcy5vblNlcmllc05vZGVEb3VibGVDbGljayA9IChldmVudCkgPT4ge1xuICAgICAgY29uc3Qgc2VyaWVzTm9kZURvdWJsZUNsaWNrID0ge1xuICAgICAgICAuLi5ldmVudCxcbiAgICAgICAgdHlwZTogXCJzZXJpZXNOb2RlRG91YmxlQ2xpY2tcIlxuICAgICAgfTtcbiAgICAgIHRoaXMuZmlyZUV2ZW50KHNlcmllc05vZGVEb3VibGVDbGljayk7XG4gICAgfTtcbiAgICB0aGlzLnNlcmllc0dyb3VwaW5nQ2hhbmdlZCA9IChldmVudCkgPT4ge1xuICAgICAgaWYgKCEoZXZlbnQgaW5zdGFuY2VvZiBTZXJpZXNHcm91cGluZ0NoYW5nZWRFdmVudCkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHsgc2VyaWVzLCBzZXJpZXNHcm91cGluZywgb2xkR3JvdXBpbmcgfSA9IGV2ZW50O1xuICAgICAgaWYgKHNlcmllcy5yb290R3JvdXAucGFyZW50ID09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuc2VyaWVzTGF5ZXJNYW5hZ2VyLmNoYW5nZUdyb3VwKHtcbiAgICAgICAgaW50ZXJuYWxJZDogc2VyaWVzLmludGVybmFsSWQsXG4gICAgICAgIHR5cGU6IHNlcmllcy50eXBlLFxuICAgICAgICByb290R3JvdXA6IHNlcmllcy5yb290R3JvdXAsXG4gICAgICAgIGhpZ2hsaWdodEdyb3VwOiBzZXJpZXMuaGlnaGxpZ2h0R3JvdXAsXG4gICAgICAgIGFubm90YXRpb25Hcm91cDogc2VyaWVzLmFubm90YXRpb25Hcm91cCxcbiAgICAgICAgZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcjogKHR5cGUpID0+IHNlcmllcy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKHR5cGUpLFxuICAgICAgICBzZXJpZXNHcm91cGluZyxcbiAgICAgICAgb2xkR3JvdXBpbmdcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5kYXRhUHJvY2Vzc0xpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5jaGFydE9wdGlvbnMgPSBvcHRpb25zO1xuICAgIGNvbnN0IHNjZW5lID0gcmVzb3VyY2VzPy5zY2VuZTtcbiAgICBjb25zdCBjb250YWluZXIgPSByZXNvdXJjZXM/LmNvbnRhaW5lcjtcbiAgICBjb25zdCByb290ID0gbmV3IEdyb3VwKHsgbmFtZTogXCJyb290XCIgfSk7XG4gICAgY29uc3QgdGl0bGVHcm91cCA9IG5ldyBHcm91cCh7IG5hbWU6IFwidGl0bGVzXCIsIGxheWVyOiB0cnVlLCB6SW5kZXg6IDggLyogU0VSSUVTX0xBQkVMX1pJTkRFWCAqLyB9KTtcbiAgICByb290LnZpc2libGUgPSBmYWxzZTtcbiAgICByb290LmFwcGVuZCh0aXRsZUdyb3VwKTtcbiAgICByb290LmFwcGVuZCh0aGlzLnNlcmllc1Jvb3QpO1xuICAgIHJvb3QuYXBwZW5kKHRoaXMuaGlnaGxpZ2h0Um9vdCk7XG4gICAgcm9vdC5hcHBlbmQodGhpcy5hbm5vdGF0aW9uUm9vdCk7XG4gICAgdGl0bGVHcm91cC5hcHBlbmQodGhpcy50aXRsZS5ub2RlKTtcbiAgICB0aXRsZUdyb3VwLmFwcGVuZCh0aGlzLnN1YnRpdGxlLm5vZGUpO1xuICAgIHRpdGxlR3JvdXAuYXBwZW5kKHRoaXMuZm9vdG5vdGUubm9kZSk7XG4gICAgY29uc3QgeyBvdmVycmlkZURldmljZVBpeGVsUmF0aW8gfSA9IG9wdGlvbnMuc3BlY2lhbE92ZXJyaWRlcztcbiAgICB0aGlzLnRvb2x0aXAgPSBuZXcgVG9vbHRpcCgpO1xuICAgIHRoaXMuc2VyaWVzTGF5ZXJNYW5hZ2VyID0gbmV3IFNlcmllc0xheWVyTWFuYWdlcih0aGlzLnNlcmllc1Jvb3QsIHRoaXMuaGlnaGxpZ2h0Um9vdCwgdGhpcy5hbm5vdGF0aW9uUm9vdCk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHggPSBuZXcgQ2hhcnRDb250ZXh0KHRoaXMsIHtcbiAgICAgIHNjZW5lLFxuICAgICAgcm9vdCxcbiAgICAgIHN5bmNNYW5hZ2VyOiBuZXcgU3luY01hbmFnZXIodGhpcyksXG4gICAgICBjb250YWluZXIsXG4gICAgICB1cGRhdGVDYWxsYmFjazogKHR5cGUgPSAwIC8qIEZVTEwgKi8sIG9wdHMpID0+IHRoaXMudXBkYXRlKHR5cGUsIG9wdHMpLFxuICAgICAgdXBkYXRlTXV0ZXg6IHRoaXMudXBkYXRlTXV0ZXgsXG4gICAgICBvdmVycmlkZURldmljZVBpeGVsUmF0aW9cbiAgICB9KTtcbiAgICB0aGlzLl9kZXN0cm95Rm5zLnB1c2goXG4gICAgICBjdHguZG9tTWFuYWdlci5hZGRMaXN0ZW5lcihcInJlc2l6ZVwiLCAoKSA9PiB0aGlzLnBhcmVudFJlc2l6ZShjdHguZG9tTWFuYWdlci5jb250YWluZXJTaXplKSlcbiAgICApO1xuICAgIHRoaXMub3ZlcmxheXMgPSBuZXcgQ2hhcnRPdmVybGF5cygpO1xuICAgIChfYSA9IHRoaXMub3ZlcmxheXMubG9hZGluZykucmVuZGVyZXIgPz8gKF9hLnJlbmRlcmVyID0gKCkgPT4gZ2V0TG9hZGluZ1NwaW5uZXIodGhpcy5vdmVybGF5cy5sb2FkaW5nLmdldFRleHQoY3R4LmxvY2FsZU1hbmFnZXIpLCBjdHguYW5pbWF0aW9uTWFuYWdlci5kZWZhdWx0RHVyYXRpb24pKTtcbiAgICB0aGlzLnByb2Nlc3NvcnMgPSBbXG4gICAgICBuZXcgQmFzZUxheW91dFByb2Nlc3Nvcih0aGlzLCBjdHgubGF5b3V0U2VydmljZSksXG4gICAgICBuZXcgRGF0YVdpbmRvd1Byb2Nlc3Nvcih0aGlzLCBjdHguZGF0YVNlcnZpY2UsIGN0eC51cGRhdGVTZXJ2aWNlLCBjdHguem9vbU1hbmFnZXIpLFxuICAgICAgbmV3IE92ZXJsYXlzUHJvY2Vzc29yKFxuICAgICAgICB0aGlzLFxuICAgICAgICB0aGlzLm92ZXJsYXlzLFxuICAgICAgICBjdHguZGF0YVNlcnZpY2UsXG4gICAgICAgIGN0eC5sYXlvdXRTZXJ2aWNlLFxuICAgICAgICBjdHgubG9jYWxlTWFuYWdlcixcbiAgICAgICAgY3R4LmFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICAgIGN0eC5kb21NYW5hZ2VyXG4gICAgICApXG4gICAgXTtcbiAgICB0aGlzLmhpZ2hsaWdodCA9IG5ldyBDaGFydEhpZ2hsaWdodCgpO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIGNvbnN0IG1vZHVsZUNvbnRleHQgPSB0aGlzLmdldE1vZHVsZUNvbnRleHQoKTtcbiAgICBjdHgucmVnaW9uTWFuYWdlci5hZGRSZWdpb24oXCJzZXJpZXNcIiAvKiBTRVJJRVMgKi8sIHRoaXMuc2VyaWVzUm9vdCwgdGhpcy5jdHguYXhpc01hbmFnZXIuYXhpc0dyaWRHcm91cCk7XG4gICAgY3R4LnJlZ2lvbk1hbmFnZXIuYWRkUmVnaW9uKFwiaG9yaXpvbnRhbC1heGVzXCIgLyogSE9SSVpPTlRBTF9BWEVTICovKTtcbiAgICBjdHgucmVnaW9uTWFuYWdlci5hZGRSZWdpb24oXCJ2ZXJ0aWNhbC1heGVzXCIgLyogVkVSVElDQUxfQVhFUyAqLyk7XG4gICAgY29uc3QgdGhpc0NoYXJ0ID0gdGhpcztcbiAgICB0aGlzLnNlcmllc0FyZWFNYW5hZ2VyID0gbmV3IFNlcmllc0FyZWFNYW5hZ2VyKFxuICAgICAge1xuICAgICAgICBmaXJlRXZlbnQ6IHRoaXMuZmlyZUV2ZW50LmJpbmQodGhpc0NoYXJ0KSxcbiAgICAgICAgZ2V0IHBlcmZvcm1VcGRhdGVUeXBlKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzQ2hhcnQucGVyZm9ybVVwZGF0ZVR5cGU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjdHgsXG4gICAgICB0aGlzLmdldENoYXJ0VHlwZSgpLFxuICAgICAgdGhpcy50b29sdGlwLFxuICAgICAgdGhpcy5oaWdobGlnaHQsXG4gICAgICB0aGlzLm92ZXJsYXlzXG4gICAgKTtcbiAgICBjdHgucmVnaW9uTWFuYWdlci5hZGRSZWdpb24oXCJyb290XCIsIHJvb3QpO1xuICAgIHRoaXMuX2Rlc3Ryb3lGbnMucHVzaChcbiAgICAgIGN0eC5kYXRhU2VydmljZS5hZGRMaXN0ZW5lcihcImRhdGEtbG9hZFwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5kYXRhID0gZXZlbnQuZGF0YTtcbiAgICAgIH0pLFxuICAgICAgdGhpcy50aXRsZS5yZWdpc3RlckludGVyYWN0aW9uKG1vZHVsZUNvbnRleHQpLFxuICAgICAgdGhpcy5zdWJ0aXRsZS5yZWdpc3RlckludGVyYWN0aW9uKG1vZHVsZUNvbnRleHQpLFxuICAgICAgdGhpcy5mb290bm90ZS5yZWdpc3RlckludGVyYWN0aW9uKG1vZHVsZUNvbnRleHQpLFxuICAgICAgY3R4LmludGVyYWN0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcInBhZ2UtbGVmdFwiLCAoKSA9PiB0aGlzLmRlc3Ryb3koKSksXG4gICAgICBjdHguYW5pbWF0aW9uTWFuYWdlci5hZGRMaXN0ZW5lcihcImFuaW1hdGlvbi1mcmFtZVwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlKDYgLyogU0NFTkVfUkVOREVSICovKTtcbiAgICAgIH0pLFxuICAgICAgY3R4Lnpvb21NYW5hZ2VyLmFkZExpc3RlbmVyKFwiem9vbS1jaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLnNlcmllcy5tYXAoKHMpID0+IHMuYW5pbWF0aW9uU3RhdGU/LnRyYW5zaXRpb24oXCJ1cGRhdGVEYXRhXCIpKTtcbiAgICAgICAgY29uc3Qgc2tpcEFuaW1hdGlvbnMgPSB0aGlzLmNoYXJ0QW5pbWF0aW9uUGhhc2UgIT09IFwiaW5pdGlhbFwiO1xuICAgICAgICB0aGlzLnVwZGF0ZSgzIC8qIFBFUkZPUk1fTEFZT1VUICovLCB7IGZvcmNlTm9kZURhdGFSZWZyZXNoOiB0cnVlLCBza2lwQW5pbWF0aW9ucyB9KTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnBhcmVudFJlc2l6ZShjdHguZG9tTWFuYWdlci5jb250YWluZXJTaXplKTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoZWxlbWVudDIpIHtcbiAgICByZXR1cm4gX0NoYXJ0LmNoYXJ0c0luc3RhbmNlcy5nZXQoZWxlbWVudDIpO1xuICB9XG4gIC8qKiBOT1RFOiBUaGlzIGlzIGV4cG9zZWQgZm9yIHVzZSBieSBJbnRlZ3JhdGVkIGNoYXJ0cyBvbmx5LiAqL1xuICBnZXQgY2FudmFzRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdHguc2NlbmUuY2FudmFzLmVsZW1lbnQ7XG4gIH1cbiAgZG93bmxvYWQoZmlsZU5hbWUsIGZpbGVGb3JtYXQpIHtcbiAgICB0aGlzLmN0eC5zY2VuZS5kb3dubG9hZChmaWxlTmFtZSwgZmlsZUZvcm1hdCk7XG4gIH1cbiAgZ2V0Q2FudmFzRGF0YVVSTChmaWxlRm9ybWF0KSB7XG4gICAgcmV0dXJuIHRoaXMuY3R4LnNjZW5lLmdldERhdGFVUkwoZmlsZUZvcm1hdCk7XG4gIH1cbiAgZ2V0T3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZWRVc2VyT3B0aW9ucy5hdCgtMSkgPz8gdGhpcy5jaGFydE9wdGlvbnMudXNlck9wdGlvbnM7XG4gIH1cbiAgZ2V0TW9kdWxlQ29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdHg7XG4gIH1cbiAgZ2V0Q2FwdGlvblRleHQoKSB7XG4gICAgcmV0dXJuIFt0aGlzLnRpdGxlLCB0aGlzLnN1YnRpdGxlLCB0aGlzLmZvb3Rub3RlXS5maWx0ZXIoKGNhcHRpb24pID0+IGNhcHRpb24uZW5hYmxlZCAmJiBjYXB0aW9uLnRleHQpLm1hcCgoY2FwdGlvbikgPT4gY2FwdGlvbi50ZXh0KS5qb2luKFwiLiBcIik7XG4gIH1cbiAgZ2V0QXJpYUxhYmVsKCkge1xuICAgIHJldHVybiB0aGlzLmN0eC5sb2NhbGVNYW5hZ2VyLnQoXCJhcmlhQW5ub3VuY2VDaGFydFwiLCB7IHNlcmllc0NvdW50OiB0aGlzLnNlcmllcy5sZW5ndGggfSk7XG4gIH1cbiAgcmVzZXRBbmltYXRpb25zKCkge1xuICAgIHRoaXMuY2hhcnRBbmltYXRpb25QaGFzZSA9IFwiaW5pdGlhbFwiO1xuICAgIGZvciAoY29uc3Qgc2VyaWVzIG9mIHRoaXMuc2VyaWVzKSB7XG4gICAgICBzZXJpZXMucmVzZXRBbmltYXRpb24odGhpcy5jaGFydEFuaW1hdGlvblBoYXNlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBheGlzIG9mIHRoaXMuYXhlcykge1xuICAgICAgYXhpcy5yZXNldEFuaW1hdGlvbih0aGlzLmNoYXJ0QW5pbWF0aW9uUGhhc2UpO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvblJlY3QgPSB2b2lkIDA7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5yZXNldCgpO1xuICB9XG4gIHNraXBBbmltYXRpb25zKCkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIHRoaXMuX3BlcmZvcm1VcGRhdGVTa2lwQW5pbWF0aW9ucyA9IHRydWU7XG4gIH1cbiAgZGVzdHJveShvcHRzKSB7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGtlZXBUcmFuc2ZlcmFibGVSZXNvdXJjZXMgPSBvcHRzPy5rZWVwVHJhbnNmZXJhYmxlUmVzb3VyY2VzO1xuICAgIGxldCByZXN1bHQ7XG4gICAgdGhpcy5wZXJmb3JtVXBkYXRlVHlwZSA9IDcgLyogTk9ORSAqLztcbiAgICB0aGlzLl9kZXN0cm95Rm5zLmZvckVhY2goKGZuKSA9PiBmbigpKTtcbiAgICB0aGlzLnByb2Nlc3NvcnMuZm9yRWFjaCgocCkgPT4gcC5kZXN0cm95KCkpO1xuICAgIHRoaXMudG9vbHRpcC5kZXN0cm95KHRoaXMuY3R4LmRvbU1hbmFnZXIpO1xuICAgIHRoaXMub3ZlcmxheXMuZGVzdHJveSgpO1xuICAgIHRoaXMubW9kdWxlc01hbmFnZXIuZGVzdHJveSgpO1xuICAgIGlmIChrZWVwVHJhbnNmZXJhYmxlUmVzb3VyY2VzKSB7XG4gICAgICB0aGlzLmN0eC5zY2VuZS5zdHJpcCgpO1xuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICBjb250YWluZXI6IHRoaXMuY29udGFpbmVyLFxuICAgICAgICBzY2VuZTogdGhpcy5jdHguc2NlbmVcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LnNjZW5lLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gdm9pZCAwO1xuICAgIH1cbiAgICB0aGlzLmRlc3Ryb3lTZXJpZXModGhpcy5zZXJpZXMpO1xuICAgIHRoaXMuc2VyaWVzTGF5ZXJNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmF4ZXMuZm9yRWFjaCgoYSkgPT4gYS5kZXN0cm95KCkpO1xuICAgIHRoaXMuYXhlcyA9IFtdO1xuICAgIHRoaXMuYW5pbWF0aW9uUmVjdCA9IHZvaWQgMDtcbiAgICB0aGlzLmN0eC5kZXN0cm95KCk7XG4gICAgdGhpcy56b29tTWFuYWdlci5kZXN0cm95KCk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXF1ZXN0RmFjdG9yeVVwZGF0ZShjYikge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9wZW5kaW5nRmFjdG9yeVVwZGF0ZXNDb3VudCsrO1xuICAgIHRoaXMudXBkYXRlTXV0ZXguYWNxdWlyZShhc3luYyAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGF3YWl0IGNiKHRoaXMpO1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLl9wZW5kaW5nRmFjdG9yeVVwZGF0ZXNDb3VudC0tO1xuICAgIH0pLmNhdGNoKChlKSA9PiBMb2dnZXIuZXJyb3JPbmNlKGUpKTtcbiAgfVxuICB1cGRhdGUodHlwZSA9IDAgLyogRlVMTCAqLywgb3B0cykge1xuICAgIGNvbnN0IHtcbiAgICAgIGZvcmNlTm9kZURhdGFSZWZyZXNoID0gZmFsc2UsXG4gICAgICBza2lwQW5pbWF0aW9ucyxcbiAgICAgIHNlcmllc1RvVXBkYXRlID0gdGhpcy5zZXJpZXMsXG4gICAgICBuZXdBbmltYXRpb25CYXRjaFxuICAgIH0gPSBvcHRzID8/IHt9O1xuICAgIGlmIChmb3JjZU5vZGVEYXRhUmVmcmVzaCkge1xuICAgICAgdGhpcy5zZXJpZXMuZm9yRWFjaCgoc2VyaWVzKSA9PiBzZXJpZXMubWFya05vZGVEYXRhRGlydHkoKSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgc2VyaWVzIG9mIHNlcmllc1RvVXBkYXRlKSB7XG4gICAgICB0aGlzLnNlcmllc1RvVXBkYXRlLmFkZChzZXJpZXMpO1xuICAgIH1cbiAgICBpZiAoc2tpcEFuaW1hdGlvbnMpIHtcbiAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgICAgdGhpcy5fcGVyZm9ybVVwZGF0ZVNraXBBbmltYXRpb25zID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5ld0FuaW1hdGlvbkJhdGNoICYmIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNBY3RpdmUoKSkge1xuICAgICAgdGhpcy5fcGVyZm9ybVVwZGF0ZVNraXBBbmltYXRpb25zID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5fc2tpcFN5bmMgPSBvcHRzPy5za2lwU3luYyA/PyBmYWxzZTtcbiAgICBpZiAodGhpcy5kZWJ1Zy5jaGVjaygpKSB7XG4gICAgICBsZXQgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjayA/PyBcIjx1bmtub3duPlwiO1xuICAgICAgc3RhY2sgPSBzdGFjay5yZXBsYWNlKC9cXChbXildKi9nLCBcIlwiKTtcbiAgICAgIHRoaXMudXBkYXRlUmVxdWVzdG9yc1tzdGFja10gPSB0eXBlO1xuICAgIH1cbiAgICBpZiAodHlwZSA8IHRoaXMucGVyZm9ybVVwZGF0ZVR5cGUpIHtcbiAgICAgIHRoaXMucGVyZm9ybVVwZGF0ZVR5cGUgPSB0eXBlO1xuICAgICAgdGhpcy5wZXJmb3JtVXBkYXRlVHJpZ2dlci5zY2hlZHVsZShvcHRzPy5iYWNrT2ZmTXMpO1xuICAgIH1cbiAgfVxuICBhc3luYyBwZXJmb3JtVXBkYXRlKGNvdW50KSB7XG4gICAgY29uc3QgeyBwZXJmb3JtVXBkYXRlVHlwZSwgZXh0cmFEZWJ1Z1N0YXRzLCBfcGVyZm9ybVVwZGF0ZVNwbGl0czogc3BsaXRzLCBjdHggfSA9IHRoaXM7XG4gICAgY29uc3Qgc2VyaWVzVG9VcGRhdGUgPSBbLi4udGhpcy5zZXJpZXNUb1VwZGF0ZV07XG4gICAgdGhpcy5wZXJmb3JtVXBkYXRlVHlwZSA9IDcgLyogTk9ORSAqLztcbiAgICB0aGlzLnNlcmllc1RvVXBkYXRlLmNsZWFyKCk7XG4gICAgaWYgKHRoaXMudXBkYXRlU2hvcnRjdXRDb3VudCA9PT0gMCAmJiBwZXJmb3JtVXBkYXRlVHlwZSA8IDYgLyogU0NFTkVfUkVOREVSICovKSB7XG4gICAgICBjdHguYW5pbWF0aW9uTWFuYWdlci5zdGFydEJhdGNoKHRoaXMuX3BlcmZvcm1VcGRhdGVTa2lwQW5pbWF0aW9ucyk7XG4gICAgICBjdHguYW5pbWF0aW9uTWFuYWdlci5vbkJhdGNoU3RvcCgoKSA9PiB0aGlzLmNoYXJ0QW5pbWF0aW9uUGhhc2UgPSBcInJlYWR5XCIpO1xuICAgIH1cbiAgICB0aGlzLmRlYnVnKFwiQ2hhcnQucGVyZm9ybVVwZGF0ZSgpIC0gc3RhcnRcIiwgQ2hhcnRVcGRhdGVUeXBlW3BlcmZvcm1VcGRhdGVUeXBlXSk7XG4gICAgbGV0IHByZXZpb3VzU3BsaXQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBzcGxpdHMuc3RhcnQgPz8gKHNwbGl0cy5zdGFydCA9IHByZXZpb3VzU3BsaXQpO1xuICAgIGNvbnN0IHVwZGF0ZVNwbGl0cyA9IChzcGxpdE5hbWUpID0+IHtcbiAgICAgIHNwbGl0c1tzcGxpdE5hbWVdID8/IChzcGxpdHNbc3BsaXROYW1lXSA9IDApO1xuICAgICAgc3BsaXRzW3NwbGl0TmFtZV0gKz0gcGVyZm9ybWFuY2Uubm93KCkgLSBwcmV2aW91c1NwbGl0O1xuICAgICAgcHJldmlvdXNTcGxpdCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIH07XG4gICAgbGV0IHVwZGF0ZURlZmVycmVkID0gZmFsc2U7XG4gICAgc3dpdGNoIChwZXJmb3JtVXBkYXRlVHlwZSkge1xuICAgICAgY2FzZSAwIC8qIEZVTEwgKi86XG4gICAgICAgIHRoaXMudXBkYXRlRE9NKCk7XG4gICAgICBjYXNlIDEgLyogVVBEQVRFX0RBVEEgKi86XG4gICAgICAgIGF3YWl0IHRoaXMudXBkYXRlRGF0YSgpO1xuICAgICAgICB1cGRhdGVTcGxpdHMoXCJcXHUyQjA3XFx1RkUwRlwiKTtcbiAgICAgIGNhc2UgMiAvKiBQUk9DRVNTX0RBVEEgKi86XG4gICAgICAgIGF3YWl0IHRoaXMucHJvY2Vzc0RhdGEoKTtcbiAgICAgICAgdGhpcy5zZXJpZXNBcmVhTWFuYWdlci5kYXRhQ2hhbmdlZCgpO1xuICAgICAgICB1cGRhdGVTcGxpdHMoXCJcXHV7MUYzRUR9XCIpO1xuICAgICAgY2FzZSAzIC8qIFBFUkZPUk1fTEFZT1VUICovOlxuICAgICAgICBpZiAodGhpcy5jaGVja1VwZGF0ZVNob3J0Y3V0KDMgLyogUEVSRk9STV9MQVlPVVQgKi8pKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tGaXJzdEF1dG9TaXplKHNlcmllc1RvVXBkYXRlKSkge1xuICAgICAgICAgIHVwZGF0ZURlZmVycmVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnByb2Nlc3NMYXlvdXQoKTtcbiAgICAgICAgdXBkYXRlU3BsaXRzKFwiXFx1MjMxNlwiKTtcbiAgICAgIGNhc2UgNCAvKiBTRVJJRVNfVVBEQVRFICovOlxuICAgICAgICBpZiAodGhpcy5jaGVja1VwZGF0ZVNob3J0Y3V0KDQgLyogU0VSSUVTX1VQREFURSAqLykpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvbnN0IHsgc2VyaWVzUmVjdCB9ID0gdGhpcztcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoc2VyaWVzVG9VcGRhdGUubWFwKChzZXJpZXMpID0+IHNlcmllcy51cGRhdGUoeyBzZXJpZXNSZWN0IH0pKSk7XG4gICAgICAgIHVwZGF0ZVNwbGl0cyhcIlxcdXsxRjkxNH1cIik7XG4gICAgICBjYXNlIDUgLyogUFJFX1NDRU5FX1JFTkRFUiAqLzpcbiAgICAgICAgaWYgKHRoaXMuY2hlY2tVcGRhdGVTaG9ydGN1dCg1IC8qIFBSRV9TQ0VORV9SRU5ERVIgKi8pKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjdHgudXBkYXRlU2VydmljZS5kaXNwYXRjaFByZVNjZW5lUmVuZGVyKHRoaXMuZ2V0TWluUmVjdHMoKSk7XG4gICAgICAgIHVwZGF0ZVNwbGl0cyhcIlxcdTIxOTZcIik7XG4gICAgICBjYXNlIDYgLyogU0NFTkVfUkVOREVSICovOlxuICAgICAgICBpZiAodGhpcy5jaGVja1VwZGF0ZVNob3J0Y3V0KDYgLyogU0NFTkVfUkVOREVSICovKSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY3R4LmFuaW1hdGlvbk1hbmFnZXIuZW5kQmF0Y2goKTtcbiAgICAgICAgZXh0cmFEZWJ1Z1N0YXRzW1widXBkYXRlU2hvcnRjdXRDb3VudFwiXSA9IHRoaXMudXBkYXRlU2hvcnRjdXRDb3VudDtcbiAgICAgICAgYXdhaXQgY3R4LnNjZW5lLnJlbmRlcih7IGRlYnVnU3BsaXRUaW1lczogc3BsaXRzLCBleHRyYURlYnVnU3RhdHMsIHNlcmllc1JlY3Q6IHRoaXMuc2VyaWVzUmVjdCB9KTtcbiAgICAgICAgdGhpcy5leHRyYURlYnVnU3RhdHMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc3BsaXRzKSB7XG4gICAgICAgICAgZGVsZXRlIHNwbGl0c1trZXldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIuaW5jcmVtZW50RGF0YUNvdW50ZXIoXCJzY2VuZVJlbmRlcnNcIik7XG4gICAgICBjYXNlIDcgLyogTk9ORSAqLzpcbiAgICAgICAgdGhpcy51cGRhdGVTaG9ydGN1dENvdW50ID0gMDtcbiAgICAgICAgdGhpcy51cGRhdGVSZXF1ZXN0b3JzID0ge307XG4gICAgICAgIHRoaXMuX3BlcmZvcm1VcGRhdGVTa2lwQW5pbWF0aW9ucyA9IGZhbHNlO1xuICAgICAgICBjdHguYW5pbWF0aW9uTWFuYWdlci5lbmRCYXRjaCgpO1xuICAgIH1cbiAgICBpZiAoIXVwZGF0ZURlZmVycmVkKSB7XG4gICAgICBjdHgudXBkYXRlU2VydmljZS5kaXNwYXRjaFVwZGF0ZUNvbXBsZXRlKHRoaXMuZ2V0TWluUmVjdHMoKSk7XG4gICAgfVxuICAgIGNvbnN0IGVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHRoaXMuZGVidWcoXCJDaGFydC5wZXJmb3JtVXBkYXRlKCkgLSBlbmRcIiwge1xuICAgICAgY2hhcnQ6IHRoaXMsXG4gICAgICBkdXJhdGlvbk1zOiBNYXRoLnJvdW5kKChlbmQgLSBzcGxpdHNbXCJzdGFydFwiXSkgKiAxMDApIC8gMTAwLFxuICAgICAgY291bnQsXG4gICAgICBwZXJmb3JtVXBkYXRlVHlwZTogQ2hhcnRVcGRhdGVUeXBlW3BlcmZvcm1VcGRhdGVUeXBlXVxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVRoZW1lQ2xhc3NOYW1lKCkge1xuICAgIGNvbnN0IHsgdGhlbWUgfSA9IHRoaXMuY2hhcnRPcHRpb25zLnByb2Nlc3NlZE9wdGlvbnM7XG4gICAgY29uc3QgdGhlbWVDbGFzc05hbWVQcmVmaXggPSBcImFnLWNoYXJ0cy10aGVtZS1cIjtcbiAgICBjb25zdCB2YWxpZFRoZW1lQ2xhc3NOYW1lcyA9IFtgJHt0aGVtZUNsYXNzTmFtZVByZWZpeH1kZWZhdWx0YCwgYCR7dGhlbWVDbGFzc05hbWVQcmVmaXh9ZGVmYXVsdC1kYXJrYF07XG4gICAgbGV0IHRoZW1lQ2xhc3NOYW1lID0gdmFsaWRUaGVtZUNsYXNzTmFtZXNbMF07XG4gICAgbGV0IGlzRGFyayA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2YgdGhlbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoZW1lQ2xhc3NOYW1lID0gdGhlbWUucmVwbGFjZShcImFnLVwiLCB0aGVtZUNsYXNzTmFtZVByZWZpeCk7XG4gICAgICBpc0RhcmsgPSB0aGVtZS5pbmNsdWRlcyhcIi1kYXJrXCIpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoZW1lPy5iYXNlVGhlbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoZW1lQ2xhc3NOYW1lID0gdGhlbWUuYmFzZVRoZW1lLnJlcGxhY2UoXCJhZy1cIiwgdGhlbWVDbGFzc05hbWVQcmVmaXgpO1xuICAgICAgaXNEYXJrID0gdGhlbWUuYmFzZVRoZW1lLmluY2x1ZGVzKFwiLWRhcmtcIik7XG4gICAgfVxuICAgIGlmICghdmFsaWRUaGVtZUNsYXNzTmFtZXMuaW5jbHVkZXModGhlbWVDbGFzc05hbWUpKSB7XG4gICAgICB0aGVtZUNsYXNzTmFtZSA9IGlzRGFyayA/IHZhbGlkVGhlbWVDbGFzc05hbWVzWzFdIDogdmFsaWRUaGVtZUNsYXNzTmFtZXNbMF07XG4gICAgfVxuICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIuc2V0VGhlbWVDbGFzcyh0aGVtZUNsYXNzTmFtZSk7XG4gIH1cbiAgdXBkYXRlRE9NKCkge1xuICAgIHRoaXMudXBkYXRlVGhlbWVDbGFzc05hbWUoKTtcbiAgICBjb25zdCB7IGVuYWJsZWQsIHRhYkluZGV4IH0gPSB0aGlzLmtleWJvYXJkO1xuICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIuc2V0VGFiSW5kZXgoZW5hYmxlZCA/IHRhYkluZGV4ID8/IDAgOiAtMSk7XG4gICAgc2V0QXR0cmlidXRlKHRoaXMuY3R4LnNjZW5lLmNhbnZhcy5lbGVtZW50LCBcInJvbGVcIiwgXCJpbWdcIik7XG4gICAgc2V0QXR0cmlidXRlKHRoaXMuY3R4LnNjZW5lLmNhbnZhcy5lbGVtZW50LCBcImFyaWEtbGFiZWxcIiwgdGhpcy5nZXRBcmlhTGFiZWwoKSk7XG4gIH1cbiAgY2hlY2tVcGRhdGVTaG9ydGN1dChjaGVja1VwZGF0ZVR5cGUpIHtcbiAgICBjb25zdCBtYXhTaG9ydGN1dHMgPSAzO1xuICAgIGlmICh0aGlzLnVwZGF0ZVNob3J0Y3V0Q291bnQgPiBtYXhTaG9ydGN1dHMpIHtcbiAgICAgIExvZ2dlci53YXJuKFxuICAgICAgICBgZXhjZWVkZWQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHNpbXVsdGFuZW91cyB1cGRhdGVzICgke21heFNob3J0Y3V0cyArIDF9KSwgZGlzY2FyZGluZyBjaGFuZ2VzIGFuZCByZW5kZXJpbmdgLFxuICAgICAgICB0aGlzLnVwZGF0ZVJlcXVlc3RvcnNcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLnBlcmZvcm1VcGRhdGVUeXBlIDw9IGNoZWNrVXBkYXRlVHlwZSkge1xuICAgICAgdGhpcy51cGRhdGVTaG9ydGN1dENvdW50Kys7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNoZWNrRmlyc3RBdXRvU2l6ZShzZXJpZXNUb1VwZGF0ZSkge1xuICAgIGlmICh0aGlzLndpZHRoICE9IG51bGwgJiYgdGhpcy5oZWlnaHQgIT0gbnVsbCkge1xuICAgIH0gZWxzZSBpZiAoIXRoaXMuX2xhc3RBdXRvU2l6ZSkge1xuICAgICAgY29uc3QgY291bnQgPSB0aGlzLl9wZXJmb3JtVXBkYXRlTm9SZW5kZXJDb3VudCsrO1xuICAgICAgY29uc3QgYmFja09mZk1zID0gKGNvdW50ICsgMSkgKiogMiAqIDQwO1xuICAgICAgaWYgKGNvdW50IDwgOCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgzIC8qIFBFUkZPUk1fTEFZT1VUICovLCB7IHNlcmllc1RvVXBkYXRlLCBiYWNrT2ZmTXMgfSk7XG4gICAgICAgIHRoaXMuZGVidWcoXCJDaGFydC5jaGVja0ZpcnN0QXV0b1NpemUoKSAtIGJhY2tpbmcgb2ZmIHVudGlsIGZpcnN0IHNpemUgdXBkYXRlXCIsIGJhY2tPZmZNcyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVidWcoXCJDaGFydC5jaGVja0ZpcnN0QXV0b1NpemUoKSAtIHRpbWVvdXQgZm9yIGZpcnN0IHNpemUgdXBkYXRlLlwiKTtcbiAgICB9XG4gICAgdGhpcy5fcGVyZm9ybVVwZGF0ZU5vUmVuZGVyQ291bnQgPSAwO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIG9uQXhpc0NoYW5nZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICBpZiAob2xkVmFsdWUgPT0gbnVsbCAmJiBuZXdWYWx1ZS5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5jdHguYXhpc01hbmFnZXIudXBkYXRlQXhlcyhvbGRWYWx1ZSA/PyBbXSwgbmV3VmFsdWUpO1xuICB9XG4gIG9uU2VyaWVzQ2hhbmdlKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIGNvbnN0IHNlcmllc1RvRGVzdHJveSA9IG9sZFZhbHVlPy5maWx0ZXIoKHNlcmllcykgPT4gIW5ld1ZhbHVlLmluY2x1ZGVzKHNlcmllcykpID8/IFtdO1xuICAgIHRoaXMuZGVzdHJveVNlcmllcyhzZXJpZXNUb0Rlc3Ryb3kpO1xuICAgIHRoaXMuc2VyaWVzTGF5ZXJNYW5hZ2VyPy5zZXRTZXJpZXNDb3VudChuZXdWYWx1ZS5sZW5ndGgpO1xuICAgIGZvciAoY29uc3Qgc2VyaWVzIG9mIG5ld1ZhbHVlKSB7XG4gICAgICBpZiAob2xkVmFsdWU/LmluY2x1ZGVzKHNlcmllcykpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKHNlcmllcy5yb290R3JvdXAucGFyZW50ID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5zZXJpZXNMYXllck1hbmFnZXIucmVxdWVzdEdyb3VwKHNlcmllcyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGFydCA9IHRoaXM7XG4gICAgICBzZXJpZXMuY2hhcnQgPSB7XG4gICAgICAgIGdldCBtb2RlKCkge1xuICAgICAgICAgIHJldHVybiBjaGFydC5tb2RlO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaXNNaW5pQ2hhcnQoKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgc2VyaWVzUmVjdCgpIHtcbiAgICAgICAgICByZXR1cm4gY2hhcnQuc2VyaWVzUmVjdDtcbiAgICAgICAgfSxcbiAgICAgICAgcGxhY2VMYWJlbHMoKSB7XG4gICAgICAgICAgcmV0dXJuIGNoYXJ0LnBsYWNlTGFiZWxzKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBzZXJpZXMucmVzZXRBbmltYXRpb24odGhpcy5jaGFydEFuaW1hdGlvblBoYXNlKTtcbiAgICAgIHRoaXMuYWRkU2VyaWVzTGlzdGVuZXJzKHNlcmllcyk7XG4gICAgICBzZXJpZXMuYWRkQ2hhcnRFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgICB0aGlzLnNlcmllc0FyZWFNYW5hZ2VyPy5zZXJpZXNDaGFuZ2VkKG5ld1ZhbHVlKTtcbiAgfVxuICBkZXN0cm95U2VyaWVzKGFsbFNlcmllcykge1xuICAgIGFsbFNlcmllcz8uZm9yRWFjaCgoc2VyaWVzKSA9PiB7XG4gICAgICBzZXJpZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm5vZGVDbGlja1wiLCB0aGlzLm9uU2VyaWVzTm9kZUNsaWNrKTtcbiAgICAgIHNlcmllcy5yZW1vdmVFdmVudExpc3RlbmVyKFwibm9kZURvdWJsZUNsaWNrXCIsIHRoaXMub25TZXJpZXNOb2RlRG91YmxlQ2xpY2spO1xuICAgICAgc2VyaWVzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJncm91cGluZ0NoYW5nZWRcIiwgdGhpcy5zZXJpZXNHcm91cGluZ0NoYW5nZWQpO1xuICAgICAgc2VyaWVzLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuc2VyaWVzTGF5ZXJNYW5hZ2VyLnJlbGVhc2VHcm91cChzZXJpZXMpO1xuICAgICAgc2VyaWVzLmNoYXJ0ID0gdm9pZCAwO1xuICAgIH0pO1xuICB9XG4gIGFkZFNlcmllc0xpc3RlbmVycyhzZXJpZXMpIHtcbiAgICBpZiAodGhpcy5oYXNFdmVudExpc3RlbmVyKFwic2VyaWVzTm9kZUNsaWNrXCIpKSB7XG4gICAgICBzZXJpZXMuYWRkRXZlbnRMaXN0ZW5lcihcIm5vZGVDbGlja1wiLCB0aGlzLm9uU2VyaWVzTm9kZUNsaWNrKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGFzRXZlbnRMaXN0ZW5lcihcInNlcmllc05vZGVEb3VibGVDbGlja1wiKSkge1xuICAgICAgc2VyaWVzLmFkZEV2ZW50TGlzdGVuZXIoXCJub2RlRG91YmxlQ2xpY2tcIiwgdGhpcy5vblNlcmllc05vZGVEb3VibGVDbGljayk7XG4gICAgfVxuICAgIHNlcmllcy5hZGRFdmVudExpc3RlbmVyKFwiZ3JvdXBpbmdDaGFuZ2VkXCIsIHRoaXMuc2VyaWVzR3JvdXBpbmdDaGFuZ2VkKTtcbiAgfVxuICB1cGRhdGVBbGxTZXJpZXNMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5zZXJpZXMuZm9yRWFjaCgoc2VyaWVzKSA9PiB7XG4gICAgICBzZXJpZXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm5vZGVDbGlja1wiLCB0aGlzLm9uU2VyaWVzTm9kZUNsaWNrKTtcbiAgICAgIHNlcmllcy5yZW1vdmVFdmVudExpc3RlbmVyKFwibm9kZURvdWJsZUNsaWNrXCIsIHRoaXMub25TZXJpZXNOb2RlRG91YmxlQ2xpY2spO1xuICAgICAgdGhpcy5hZGRTZXJpZXNMaXN0ZW5lcnMoc2VyaWVzKTtcbiAgICB9KTtcbiAgfVxuICBhc3NpZ25TZXJpZXNUb0F4ZXMoKSB7XG4gICAgdGhpcy5heGVzLmZvckVhY2goKGF4aXMpID0+IHtcbiAgICAgIGF4aXMuYm91bmRTZXJpZXMgPSB0aGlzLnNlcmllcy5maWx0ZXIoKHMpID0+IHtcbiAgICAgICAgY29uc3Qgc2VyaWVzQXhpcyA9IHMuYXhlc1theGlzLmRpcmVjdGlvbl07XG4gICAgICAgIHJldHVybiBzZXJpZXNBeGlzID09PSBheGlzO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgYXNzaWduQXhlc1RvU2VyaWVzKCkge1xuICAgIGNvbnN0IGRpcmVjdGlvblRvQXhlc01hcCA9IGdyb3VwQnkodGhpcy5heGVzLCAoYXhpcykgPT4gYXhpcy5kaXJlY3Rpb24pO1xuICAgIHRoaXMuc2VyaWVzLmZvckVhY2goKHNlcmllcykgPT4ge1xuICAgICAgc2VyaWVzLmRpcmVjdGlvbnMuZm9yRWFjaCgoZGlyZWN0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbkF4ZXMgPSBkaXJlY3Rpb25Ub0F4ZXNNYXBbZGlyZWN0aW9uXTtcbiAgICAgICAgaWYgKCFkaXJlY3Rpb25BeGVzKSB7XG4gICAgICAgICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgICAgICAgYG5vIGF2YWlsYWJsZSBheGlzIGZvciBkaXJlY3Rpb24gWyR7ZGlyZWN0aW9ufV07IGNoZWNrIHNlcmllcyBhbmQgYXhlcyBjb25maWd1cmF0aW9uLmBcbiAgICAgICAgICApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXJpZXNLZXlzID0gc2VyaWVzLmdldEtleXMoZGlyZWN0aW9uKTtcbiAgICAgICAgY29uc3QgbmV3QXhpcyA9IGRpcmVjdGlvbkF4ZXMuZmluZChcbiAgICAgICAgICAoYXhpcykgPT4gIWF4aXMua2V5cy5sZW5ndGggfHwgc2VyaWVzS2V5cy5zb21lKChrZXkpID0+IGF4aXMua2V5cy5pbmNsdWRlcyhrZXkpKVxuICAgICAgICApO1xuICAgICAgICBpZiAoIW5ld0F4aXMpIHtcbiAgICAgICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgICAgICBgbm8gbWF0Y2hpbmcgYXhpcyBmb3IgZGlyZWN0aW9uIFske2RpcmVjdGlvbn1dIGFuZCBrZXlzIFske3Nlcmllc0tleXN9XTsgY2hlY2sgc2VyaWVzIGFuZCBheGVzIGNvbmZpZ3VyYXRpb24uYFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlcmllcy5heGVzW2RpcmVjdGlvbl0gPSBuZXdBeGlzO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcGFyZW50UmVzaXplKHNpemUpIHtcbiAgICBpZiAoc2l6ZSA9PSBudWxsIHx8IHRoaXMud2lkdGggIT0gbnVsbCAmJiB0aGlzLmhlaWdodCAhPSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCB7IHdpZHRoLCBoZWlnaHQgfSA9IHNpemU7XG4gICAgd2lkdGggPSBNYXRoLmZsb29yKHdpZHRoKTtcbiAgICBoZWlnaHQgPSBNYXRoLmZsb29yKGhlaWdodCk7XG4gICAgaWYgKHdpZHRoID09PSAwICYmIGhlaWdodCA9PT0gMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBbYXV0b1dpZHRoID0gMCwgYXV0aEhlaWdodCA9IDBdID0gdGhpcy5fbGFzdEF1dG9TaXplID8/IFtdO1xuICAgIGlmIChhdXRvV2lkdGggPT09IHdpZHRoICYmIGF1dGhIZWlnaHQgPT09IGhlaWdodClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9sYXN0QXV0b1NpemUgPSBbd2lkdGgsIGhlaWdodF07XG4gICAgdGhpcy5yZXNpemUoXCJTaXplTW9uaXRvclwiLCB7fSk7XG4gIH1cbiAgcmVzaXplKHNvdXJjZSwgb3B0cykge1xuICAgIGNvbnN0IHsgc2NlbmUsIGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHsgaW5XaWR0aCwgaW5IZWlnaHQsIGluTWluV2lkdGgsIGluTWluSGVpZ2h0IH0gPSBvcHRzO1xuICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIuc2V0U2l6ZU9wdGlvbnMoXG4gICAgICBpbk1pbldpZHRoID8/IHRoaXMubWluV2lkdGgsXG4gICAgICBpbk1pbkhlaWdodCA/PyB0aGlzLm1pbkhlaWdodCxcbiAgICAgIGluV2lkdGggPz8gdGhpcy53aWR0aCxcbiAgICAgIGluSGVpZ2h0ID8/IHRoaXMuaGVpZ2h0XG4gICAgKTtcbiAgICBjb25zdCB3aWR0aCA9IGluV2lkdGggPz8gdGhpcy53aWR0aCA/PyB0aGlzLl9sYXN0QXV0b1NpemU/LlswXTtcbiAgICBjb25zdCBoZWlnaHQgPSBpbkhlaWdodCA/PyB0aGlzLmhlaWdodCA/PyB0aGlzLl9sYXN0QXV0b1NpemU/LlsxXTtcbiAgICB0aGlzLmRlYnVnKGBDaGFydC5yZXNpemUoKSBmcm9tICR7c291cmNlfWAsIHsgd2lkdGgsIGhlaWdodCwgc3RhY2s6IG5ldyBFcnJvcigpLnN0YWNrIH0pO1xuICAgIGlmICh3aWR0aCA9PSBudWxsIHx8IGhlaWdodCA9PSBudWxsIHx8ICFpc0Zpbml0ZU51bWJlcih3aWR0aCkgfHwgIWlzRmluaXRlTnVtYmVyKGhlaWdodCkpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHNjZW5lLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSkge1xuICAgICAgYW5pbWF0aW9uTWFuYWdlci5yZXNldCgpO1xuICAgICAgbGV0IHNraXBBbmltYXRpb25zID0gdHJ1ZTtcbiAgICAgIGlmICgodGhpcy53aWR0aCA9PSBudWxsIHx8IHRoaXMuaGVpZ2h0ID09IG51bGwpICYmIHRoaXMuX2ZpcnN0QXV0b1NpemUpIHtcbiAgICAgICAgc2tpcEFuaW1hdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZmlyc3RBdXRvU2l6ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGUoMyAvKiBQRVJGT1JNX0xBWU9VVCAqLywgeyBmb3JjZU5vZGVEYXRhUmVmcmVzaDogdHJ1ZSwgc2tpcEFuaW1hdGlvbnMgfSk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHVwZGF0ZURhdGEoKSB7XG4gICAgdGhpcy5zZXJpZXMuZm9yRWFjaCgocykgPT4gcy5zZXRDaGFydERhdGEodGhpcy5kYXRhKSk7XG4gICAgY29uc3QgbW9kdWxlUHJvbWlzZXMgPSB0aGlzLm1vZHVsZXNNYW5hZ2VyLm1hcE1vZHVsZXMoKG0pID0+IG0udXBkYXRlRGF0YT8uKHsgZGF0YTogdGhpcy5kYXRhIH0pKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChtb2R1bGVQcm9taXNlcyk7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0RhdGEoKSB7XG4gICAgaWYgKHRoaXMuc2VyaWVzLnNvbWUoKHMpID0+IHMuY2FuSGF2ZUF4ZXMpKSB7XG4gICAgICB0aGlzLmFzc2lnbkF4ZXNUb1NlcmllcygpO1xuICAgICAgY29uc3Qgc3luY01vZHVsZSA9IHRoaXMubW9kdWxlc01hbmFnZXIuZ2V0TW9kdWxlKFwic3luY1wiKTtcbiAgICAgIGlmIChzeW5jTW9kdWxlPy5lbmFibGVkKSB7XG4gICAgICAgIHN5bmNNb2R1bGUuc3luY0F4ZXModGhpcy5fc2tpcFN5bmMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hc3NpZ25TZXJpZXNUb0F4ZXMoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGF0YUNvbnRyb2xsZXIgPSBuZXcgRGF0YUNvbnRyb2xsZXIodGhpcy5tb2RlKTtcbiAgICBjb25zdCBzZXJpZXNQcm9taXNlcyA9IHRoaXMuc2VyaWVzLm1hcCgocykgPT4gcy5wcm9jZXNzRGF0YShkYXRhQ29udHJvbGxlcikpO1xuICAgIGNvbnN0IG1vZHVsZVByb21pc2VzID0gdGhpcy5tb2R1bGVzTWFuYWdlci5tYXBNb2R1bGVzKChtKSA9PiBtLnByb2Nlc3NEYXRhPy4oeyBkYXRhQ29udHJvbGxlciB9KSk7XG4gICAgZGF0YUNvbnRyb2xsZXIuZXhlY3V0ZSgpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFsuLi5zZXJpZXNQcm9taXNlcywgLi4ubW9kdWxlUHJvbWlzZXNdKTtcbiAgICBmb3IgKGNvbnN0IHsgbGVnZW5kVHlwZSwgbGVnZW5kIH0gb2YgdGhpcy5tb2R1bGVzTWFuYWdlci5sZWdlbmRzKCkpIHtcbiAgICAgIGxlZ2VuZC5kYXRhID0gdGhpcy5nZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUsIHRoaXMubW9kZSAhPT0gXCJpbnRlZ3JhdGVkXCIpO1xuICAgIH1cbiAgICB0aGlzLmRhdGFQcm9jZXNzTGlzdGVuZXJzLmZvckVhY2goKHJlc29sdmUpID0+IHJlc29sdmUoKSk7XG4gICAgdGhpcy5kYXRhUHJvY2Vzc0xpc3RlbmVycy5jbGVhcigpO1xuICB9XG4gIHBsYWNlTGFiZWxzKCkge1xuICAgIGNvbnN0IHZpc2libGVTZXJpZXMgPSBbXTtcbiAgICBjb25zdCBkYXRhID0gW107XG4gICAgZm9yIChjb25zdCBzZXJpZXMgb2YgdGhpcy5zZXJpZXMpIHtcbiAgICAgIGlmICghc2VyaWVzLnZpc2libGUpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgY29uc3QgbGFiZWxEYXRhID0gc2VyaWVzLmdldExhYmVsRGF0YSgpO1xuICAgICAgaWYgKGlzUG9pbnRMYWJlbERhdHVtKGxhYmVsRGF0YT8uWzBdKSkge1xuICAgICAgICBkYXRhLnB1c2gobGFiZWxEYXRhKTtcbiAgICAgICAgdmlzaWJsZVNlcmllcy5wdXNoKHNlcmllcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHsgc2VyaWVzUmVjdCB9ID0gdGhpcztcbiAgICBjb25zdCB7IHRvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdCB9ID0gdGhpcy5zZXJpZXNBcmVhLnBhZGRpbmc7XG4gICAgY29uc3QgbGFiZWxzID0gc2VyaWVzUmVjdCAmJiBkYXRhLmxlbmd0aCA+IDAgPyBwbGFjZUxhYmVscyhkYXRhLCB7XG4gICAgICB4OiAtbGVmdCxcbiAgICAgIHk6IC10b3AsXG4gICAgICB3aWR0aDogc2VyaWVzUmVjdC53aWR0aCArIGxlZnQgKyByaWdodCxcbiAgICAgIGhlaWdodDogc2VyaWVzUmVjdC5oZWlnaHQgKyB0b3AgKyBib3R0b21cbiAgICB9KSA6IFtdO1xuICAgIHJldHVybiBuZXcgTWFwKGxhYmVscy5tYXAoKGwsIGkpID0+IFt2aXNpYmxlU2VyaWVzW2ldLCBsXSkpO1xuICB9XG4gIGdldExlZ2VuZERhdGEobGVnZW5kVHlwZSwgd2FybkNvbmZsaWN0cykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsZWdlbmREYXRhID0gdGhpcy5zZXJpZXMuZmlsdGVyKChzKSA9PiBzLnByb3BlcnRpZXMuc2hvd0luTGVnZW5kKS5mbGF0TWFwKChzKSA9PiBzLmdldExlZ2VuZERhdGEobGVnZW5kVHlwZSkpO1xuICAgIGNvbnN0IGlzQ2F0ZWdvcnlMZWdlbmREYXRhID0gKGRhdGEpID0+IGRhdGEuZXZlcnkoKGQpID0+IGQubGVnZW5kVHlwZSA9PT0gXCJjYXRlZ29yeVwiKTtcbiAgICBpZiAod2FybkNvbmZsaWN0cyAmJiBpc0NhdGVnb3J5TGVnZW5kRGF0YShsZWdlbmREYXRhKSkge1xuICAgICAgY29uc3Qgc2VyaWVzTWFya2VyRmlsbHMgPSB7fTtcbiAgICAgIGNvbnN0IHNlcmllc1R5cGVNYXAgPSBuZXcgTWFwKHRoaXMuc2VyaWVzLm1hcCgocykgPT4gW3MuaWQsIHMudHlwZV0pKTtcbiAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICBzZXJpZXNJZCxcbiAgICAgICAgc3ltYm9sczogW3sgbWFya2VyIH1dLFxuICAgICAgICBsYWJlbFxuICAgICAgfSBvZiBsZWdlbmREYXRhKSB7XG4gICAgICAgIGlmIChtYXJrZXIuZmlsbCA9PSBudWxsKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBzZXJpZXNUeXBlMiA9IHNlcmllc1R5cGVNYXAuZ2V0KHNlcmllc0lkKTtcbiAgICAgICAgY29uc3QgbWFya2VyRmlsbCA9IHNlcmllc01hcmtlckZpbGxzW3Nlcmllc1R5cGUyXSA/PyAoc2VyaWVzTWFya2VyRmlsbHNbc2VyaWVzVHlwZTJdID0ge30pO1xuICAgICAgICBtYXJrZXJGaWxsW19hID0gbGFiZWwudGV4dF0gPz8gKG1hcmtlckZpbGxbX2FdID0gbWFya2VyLmZpbGwpO1xuICAgICAgICBpZiAobWFya2VyRmlsbFtsYWJlbC50ZXh0XSAhPT0gbWFya2VyLmZpbGwpIHtcbiAgICAgICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgICAgICBgbGVnZW5kIGl0ZW0gJyR7bGFiZWwudGV4dH0nIGhhcyBtdWx0aXBsZSBmaWxsIGNvbG9ycywgdGhpcyBtYXkgY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvdXIuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxlZ2VuZERhdGE7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0xheW91dCgpIHtcbiAgICBjb25zdCBvbGRSZWN0ID0gdGhpcy5hbmltYXRpb25SZWN0O1xuICAgIGF3YWl0IHRoaXMucGVyZm9ybUxheW91dCgpO1xuICAgIGlmIChvbGRSZWN0ICYmICF0aGlzLmFuaW1hdGlvblJlY3Q/LmVxdWFscyhvbGRSZWN0KSkge1xuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgfVxuICAgIHRoaXMuZGVidWcoXCJDaGFydC5wZXJmb3JtVXBkYXRlKCkgLSBzZXJpZXNSZWN0XCIsIHRoaXMuc2VyaWVzUmVjdCk7XG4gIH1cbiAgYXN5bmMgcGVyZm9ybUxheW91dCgpIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuY3R4LnNjZW5lO1xuICAgIGxldCBjdHggPSB7IHNocmlua1JlY3Q6IG5ldyBCQm94KDAsIDAsIHdpZHRoLCBoZWlnaHQpLCBwb3NpdGlvbnM6IHt9LCBwYWRkaW5nOiB7fSB9O1xuICAgIGN0eCA9IHRoaXMuY3R4LmxheW91dFNlcnZpY2UuZGlzcGF0Y2hQZXJmb3JtTGF5b3V0KFwic3RhcnQtbGF5b3V0XCIsIGN0eCk7XG4gICAgY3R4ID0gdGhpcy5jdHgubGF5b3V0U2VydmljZS5kaXNwYXRjaFBlcmZvcm1MYXlvdXQoXCJiZWZvcmUtc2VyaWVzXCIsIGN0eCk7XG4gICAgZm9yIChjb25zdCBtIG9mIHRoaXMubW9kdWxlc01hbmFnZXIubW9kdWxlcygpKSB7XG4gICAgICBpZiAobS5wZXJmb3JtTGF5b3V0ICE9IG51bGwpIHtcbiAgICAgICAgY3R4ID0gYXdhaXQgbS5wZXJmb3JtTGF5b3V0KGN0eCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjdHguc2hyaW5rUmVjdDtcbiAgfVxuICBhc3luYyB3YWl0Rm9yVXBkYXRlKHRpbWVvdXRNcyA9IDFlNCwgZmFpbE9uVGltZW91dCA9IGZhbHNlKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBpZiAodGhpcy5fcGVuZGluZ0ZhY3RvcnlVcGRhdGVzQ291bnQgPiAwKSB7XG4gICAgICBhd2FpdCB0aGlzLnVwZGF0ZU11dGV4LndhaXRGb3JDbGVhckFjcXVpcmVRdWV1ZSgpO1xuICAgIH1cbiAgICB3aGlsZSAodGhpcy5wZXJmb3JtVXBkYXRlVHlwZSAhPT0gNyAvKiBOT05FICovKSB7XG4gICAgICBpZiAocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCA+IHRpbWVvdXRNcykge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gYENoYXJ0LndhaXRGb3JVcGRhdGUoKSB0aW1lb3V0IG9mICR7dGltZW91dE1zfSByZWFjaGVkIC0gZmlyc3QgY2hhcnQgdXBkYXRlIHRha2luZyB0b28gbG9uZy5gO1xuICAgICAgICBpZiAoZmFpbE9uVGltZW91dCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBMb2dnZXIud2Fybk9uY2UobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGF3YWl0IHNsZWVwKDUwKTtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy51cGRhdGVNdXRleC53YWl0Rm9yQ2xlYXJBY3F1aXJlUXVldWUoKTtcbiAgfVxuICB3YWl0Rm9yRGF0YVByb2Nlc3ModGltZW91dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5kYXRhUHJvY2Vzc0xpc3RlbmVycy5hZGQocmVzb2x2ZSk7XG4gICAgICBpZiAoaXNOdW1iZXIodGltZW91dCkpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuZGF0YVByb2Nlc3NMaXN0ZW5lcnMuaGFzKHJlc29sdmUpKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFQcm9jZXNzTGlzdGVuZXJzLmRlbGV0ZShyZXNvbHZlKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldE1pblJlY3RzKCkge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy5jdHguc2NlbmU7XG4gICAgY29uc3QgbWluUmVjdHMgPSB0aGlzLnNlcmllcy5tYXAoKHNlcmllcykgPT4gc2VyaWVzLmdldE1pblJlY3RzKHdpZHRoLCBoZWlnaHQpKS5maWx0ZXIoaXNEZWZpbmVkKTtcbiAgICBpZiAobWluUmVjdHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBtYXhXaWR0aCA9IDA7XG4gICAgbGV0IG1heEhlaWdodCA9IDA7XG4gICAgbGV0IG1heFZpc2libGVXaWR0aCA9IDA7XG4gICAgbGV0IG1heFZpc2libGVIZWlnaHQgPSAwO1xuICAgIGZvciAoY29uc3QgeyBtaW5SZWN0OiBtaW5SZWN0MiwgbWluVmlzaWJsZVJlY3Q6IG1pblZpc2libGVSZWN0MiB9IG9mIG1pblJlY3RzKSB7XG4gICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KG1heFdpZHRoLCBtaW5SZWN0Mi53aWR0aCk7XG4gICAgICBtYXhIZWlnaHQgPSBNYXRoLm1heChtYXhIZWlnaHQsIG1pblJlY3QyLmhlaWdodCk7XG4gICAgICBtYXhWaXNpYmxlV2lkdGggPSBNYXRoLm1heChtYXhWaXNpYmxlV2lkdGgsIG1pblZpc2libGVSZWN0Mi53aWR0aCk7XG4gICAgICBtYXhWaXNpYmxlSGVpZ2h0ID0gTWF0aC5tYXgobWF4VmlzaWJsZUhlaWdodCwgbWluVmlzaWJsZVJlY3QyLmhlaWdodCk7XG4gICAgfVxuICAgIGNvbnN0IG1pblJlY3QgPSBuZXcgQkJveCgwLCAwLCBtYXhXaWR0aCwgbWF4SGVpZ2h0KTtcbiAgICBsZXQgbWluVmlzaWJsZVJlY3QgPSBtaW5SZWN0LmNsb25lKCk7XG4gICAgaWYgKG1heFZpc2libGVXaWR0aCA+IDAgJiYgbWF4VmlzaWJsZUhlaWdodCA+IDApIHtcbiAgICAgIG1pblZpc2libGVSZWN0ID0gbmV3IEJCb3goMCwgMCwgbWF4VmlzaWJsZVdpZHRoLCBtYXhWaXNpYmxlSGVpZ2h0KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWluUmVjdCwgbWluVmlzaWJsZVJlY3QgfTtcbiAgfVxuICBmaWx0ZXJNaW5pQ2hhcnRTZXJpZXMoc2VyaWVzKSB7XG4gICAgcmV0dXJuIHNlcmllcz8uZmlsdGVyKChzKSA9PiBzLnNob3dJbk1pbmlDaGFydCAhPT0gZmFsc2UpO1xuICB9XG4gIGFwcGx5T3B0aW9ucyhuZXdDaGFydE9wdGlvbnMpIHtcbiAgICBjb25zdCBpc0RpZmZlcmVudE9wdHMgPSBuZXdDaGFydE9wdGlvbnMgIT09IHRoaXMuY2hhcnRPcHRpb25zO1xuICAgIGNvbnN0IG9sZE9wdHMgPSBpc0RpZmZlcmVudE9wdHMgPyB0aGlzLmNoYXJ0T3B0aW9ucy5wcm9jZXNzZWRPcHRpb25zIDoge307XG4gICAgY29uc3QgbmV3T3B0cyA9IG5ld0NoYXJ0T3B0aW9ucy5wcm9jZXNzZWRPcHRpb25zO1xuICAgIGNvbnN0IGRlbHRhT3B0aW9ucyA9IG5ld0NoYXJ0T3B0aW9ucy5kaWZmT3B0aW9ucyhvbGRPcHRzKTtcbiAgICBpZiAoZGVsdGFPcHRpb25zID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgZGVidWcoXCJDaGFydC5hcHBseU9wdGlvbnMoKSAtIGFwcGx5aW5nIGRlbHRhXCIsIGRlbHRhT3B0aW9ucyk7XG4gICAgY29uc3QgbW9kdWxlc0NoYW5nZWQgPSB0aGlzLmFwcGx5TW9kdWxlcyhuZXdPcHRzKTtcbiAgICBjb25zdCBza2lwID0gW1xuICAgICAgXCJ0eXBlXCIsXG4gICAgICBcImRhdGFcIixcbiAgICAgIFwic2VyaWVzXCIsXG4gICAgICBcImxpc3RlbmVyc1wiLFxuICAgICAgXCJwcmVzZXRcIixcbiAgICAgIFwidGhlbWVcIixcbiAgICAgIFwibGVnZW5kLmxpc3RlbmVyc1wiLFxuICAgICAgXCJuYXZpZ2F0b3IubWluaUNoYXJ0LnNlcmllc1wiLFxuICAgICAgXCJuYXZpZ2F0b3IubWluaUNoYXJ0LmxhYmVsXCIsXG4gICAgICBcImxvY2FsZS5sb2NhbGVUZXh0XCIsXG4gICAgICBcImF4ZXNcIixcbiAgICAgIFwidG9wb2xvZ3lcIixcbiAgICAgIFwibm9kZXNcIixcbiAgICAgIFwiaW5pdGlhbFN0YXRlXCJcbiAgICBdO1xuICAgIGlmIChkZWx0YU9wdGlvbnMubGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKHRoaXMsIGRlbHRhT3B0aW9ucy5saXN0ZW5lcnMpO1xuICAgIH1cbiAgICBqc29uQXBwbHkodGhpcywgZGVsdGFPcHRpb25zLCB7IHNraXAgfSk7XG4gICAgbGV0IGZvcmNlTm9kZURhdGFSZWZyZXNoID0gZmFsc2U7XG4gICAgbGV0IHNlcmllc1N0YXR1cyA9IFwibm8tb3BcIjtcbiAgICBpZiAoZGVsdGFPcHRpb25zLnNlcmllcyAhPSBudWxsKSB7XG4gICAgICBzZXJpZXNTdGF0dXMgPSB0aGlzLmFwcGx5U2VyaWVzKHRoaXMsIGRlbHRhT3B0aW9ucy5zZXJpZXMsIG9sZE9wdHM/LnNlcmllcyk7XG4gICAgICBmb3JjZU5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChzZXJpZXNTdGF0dXMgPT09IFwicmVwbGFjZWRcIikge1xuICAgICAgdGhpcy5yZXNldEFuaW1hdGlvbnMoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXBwbHlBeGVzKHRoaXMsIG5ld09wdHMsIG9sZE9wdHMsIHNlcmllc1N0YXR1cywgW10sIHRydWUpKSB7XG4gICAgICBmb3JjZU5vZGVEYXRhUmVmcmVzaCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChkZWx0YU9wdGlvbnMuZGF0YSkge1xuICAgICAgdGhpcy5kYXRhID0gZGVsdGFPcHRpb25zLmRhdGE7XG4gICAgfVxuICAgIGlmIChkZWx0YU9wdGlvbnMubGVnZW5kPy5saXN0ZW5lcnMgJiYgdGhpcy5tb2R1bGVzTWFuYWdlci5pc0VuYWJsZWQoXCJsZWdlbmRcIikpIHtcbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5sZWdlbmQubGlzdGVuZXJzLCBkZWx0YU9wdGlvbnMubGVnZW5kLmxpc3RlbmVycyk7XG4gICAgfVxuICAgIGlmIChkZWx0YU9wdGlvbnMubGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLnVwZGF0ZUFsbFNlcmllc0xpc3RlbmVycygpO1xuICAgIH1cbiAgICBpZiAoZGVsdGFPcHRpb25zLmxvY2FsZT8ubG9jYWxlVGV4dCkge1xuICAgICAgdGhpcy5tb2R1bGVzTWFuYWdlci5nZXRNb2R1bGUoXCJsb2NhbGVcIikubG9jYWxlVGV4dCA9IGRlbHRhT3B0aW9ucy5sb2NhbGU/LmxvY2FsZVRleHQ7XG4gICAgfVxuICAgIHRoaXMuY2hhcnRPcHRpb25zID0gbmV3Q2hhcnRPcHRpb25zO1xuICAgIGNvbnN0IG5hdmlnYXRvck1vZHVsZSA9IHRoaXMubW9kdWxlc01hbmFnZXIuZ2V0TW9kdWxlKFwibmF2aWdhdG9yXCIpO1xuICAgIGNvbnN0IHpvb21Nb2R1bGUgPSB0aGlzLm1vZHVsZXNNYW5hZ2VyLmdldE1vZHVsZShcInpvb21cIik7XG4gICAgaWYgKCFuYXZpZ2F0b3JNb2R1bGU/LmVuYWJsZWQgJiYgIXpvb21Nb2R1bGU/LmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuY3R4Lnpvb21NYW5hZ2VyLnVwZGF0ZVpvb20oXCJjaGFydFwiKTtcbiAgICB9XG4gICAgY29uc3QgbWluaUNoYXJ0ID0gbmF2aWdhdG9yTW9kdWxlPy5taW5pQ2hhcnQ7XG4gICAgY29uc3QgbWluaUNoYXJ0U2VyaWVzID0gbmV3T3B0cy5uYXZpZ2F0b3I/Lm1pbmlDaGFydD8uc2VyaWVzID8/IG5ld09wdHMuc2VyaWVzO1xuICAgIGlmIChtaW5pQ2hhcnQ/LmVuYWJsZWQgPT09IHRydWUgJiYgbWluaUNoYXJ0U2VyaWVzICE9IG51bGwpIHtcbiAgICAgIHRoaXMuYXBwbHlNaW5pQ2hhcnRPcHRpb25zKG1pbmlDaGFydCwgbWluaUNoYXJ0U2VyaWVzLCBuZXdPcHRzLCBvbGRPcHRzKTtcbiAgICB9IGVsc2UgaWYgKG1pbmlDaGFydD8uZW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgIG1pbmlDaGFydC5zZXJpZXMgPSBbXTtcbiAgICAgIG1pbmlDaGFydC5heGVzID0gW107XG4gICAgfVxuICAgIHRoaXMuY3R4LmFubm90YXRpb25NYW5hZ2VyLnNldEFubm90YXRpb25TdHlsZXMobmV3Q2hhcnRPcHRpb25zLmFubm90YXRpb25UaGVtZXMpO1xuICAgIGZvcmNlTm9kZURhdGFSZWZyZXNoIHx8IChmb3JjZU5vZGVEYXRhUmVmcmVzaCA9IHRoaXMuc2hvdWxkRm9yY2VOb2RlRGF0YVJlZnJlc2goZGVsdGFPcHRpb25zLCBzZXJpZXNTdGF0dXMpKTtcbiAgICBjb25zdCBtYWpvckNoYW5nZSA9IGZvcmNlTm9kZURhdGFSZWZyZXNoIHx8IG1vZHVsZXNDaGFuZ2VkO1xuICAgIGNvbnN0IHVwZGF0ZVR5cGUgPSBtYWpvckNoYW5nZSA/IDAgLyogRlVMTCAqLyA6IDMgLyogUEVSRk9STV9MQVlPVVQgKi87XG4gICAgdGhpcy5tYXliZVJlc2V0QW5pbWF0aW9ucyhzZXJpZXNTdGF0dXMpO1xuICAgIGRlYnVnKFwiQ2hhcnQuYXBwbHlPcHRpb25zKCkgLSB1cGRhdGUgdHlwZVwiLCBDaGFydFVwZGF0ZVR5cGVbdXBkYXRlVHlwZV0sIHtcbiAgICAgIHNlcmllc1N0YXR1cyxcbiAgICAgIGZvcmNlTm9kZURhdGFSZWZyZXNoXG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGUodXBkYXRlVHlwZSwgeyBmb3JjZU5vZGVEYXRhUmVmcmVzaCwgbmV3QW5pbWF0aW9uQmF0Y2g6IHRydWUgfSk7XG4gICAgaWYgKGRlbHRhT3B0aW9ucy5pbml0aWFsU3RhdGUpIHtcbiAgICAgIHRoaXMuYXBwbHlJbml0aWFsU3RhdGUobmV3Q2hhcnRPcHRpb25zLnVzZXJPcHRpb25zLmluaXRpYWxTdGF0ZSk7XG4gICAgfVxuICB9XG4gIGFwcGx5SW5pdGlhbFN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGN0eDogeyBhbm5vdGF0aW9uTWFuYWdlciwgc3RhdGVNYW5hZ2VyIH1cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoaW5pdGlhbFN0YXRlPy5hbm5vdGF0aW9ucyAhPSBudWxsKSB7XG4gICAgICBjb25zdCBhbm5vdGF0aW9uczIgPSBpbml0aWFsU3RhdGUuYW5ub3RhdGlvbnMubWFwKChhbm5vdGF0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IGFubm90YXRpb25UaGVtZSA9IGFubm90YXRpb25NYW5hZ2VyLmdldEFubm90YXRpb25UeXBlU3R5bGVzKGFubm90YXRpb24udHlwZSk7XG4gICAgICAgIHJldHVybiBtZXJnZURlZmF1bHRzKGFubm90YXRpb24sIGFubm90YXRpb25UaGVtZSk7XG4gICAgICB9KTtcbiAgICAgIHN0YXRlTWFuYWdlci5zZXRTdGF0ZShhbm5vdGF0aW9uTWFuYWdlciwgYW5ub3RhdGlvbnMyKTtcbiAgICB9XG4gIH1cbiAgbWF5YmVSZXNldEFuaW1hdGlvbnMoc2VyaWVzU3RhdHVzKSB7XG4gICAgaWYgKHRoaXMubW9kZSAhPT0gXCJzdGFuZGFsb25lXCIpXG4gICAgICByZXR1cm47XG4gICAgc3dpdGNoIChzZXJpZXNTdGF0dXMpIHtcbiAgICAgIGNhc2UgXCJzZXJpZXMtZ3JvdXBpbmctY2hhbmdlXCI6XG4gICAgICBjYXNlIFwicmVwbGFjZWRcIjpcbiAgICAgICAgdGhpcy5yZXNldEFuaW1hdGlvbnMoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuICBzaG91bGRGb3JjZU5vZGVEYXRhUmVmcmVzaChkZWx0YU9wdGlvbnMsIHNlcmllc1N0YXR1cykge1xuICAgIGNvbnN0IHNlcmllc0RhdGFVcGRhdGUgPSAhIWRlbHRhT3B0aW9ucy5kYXRhIHx8IHNlcmllc1N0YXR1cyA9PT0gXCJkYXRhLWNoYW5nZVwiIHx8IHNlcmllc1N0YXR1cyA9PT0gXCJyZXBsYWNlZFwiO1xuICAgIGNvbnN0IGxlZ2VuZEtleXMgPSBsZWdlbmRSZWdpc3RyeS5nZXRLZXlzKCk7XG4gICAgY29uc3Qgb3B0aW9uc0hhdmVMZWdlbmQgPSBPYmplY3QudmFsdWVzKGxlZ2VuZEtleXMpLnNvbWUoXG4gICAgICAobGVnZW5kS2V5KSA9PiBkZWx0YU9wdGlvbnNbbGVnZW5kS2V5XSAhPSBudWxsXG4gICAgKTtcbiAgICBjb25zdCBvdGhlclJlZnJlc2hVcGRhdGUgPSBkZWx0YU9wdGlvbnMudGl0bGUgIT0gbnVsbCAmJiBkZWx0YU9wdGlvbnMuc3VidGl0bGUgIT0gbnVsbDtcbiAgICByZXR1cm4gc2VyaWVzRGF0YVVwZGF0ZSB8fCBvcHRpb25zSGF2ZUxlZ2VuZCB8fCBvdGhlclJlZnJlc2hVcGRhdGU7XG4gIH1cbiAgYXBwbHlNaW5pQ2hhcnRPcHRpb25zKG1pbmlDaGFydCwgbWluaUNoYXJ0U2VyaWVzLCBjb21wbGV0ZU9wdGlvbnMsIG9sZE9wdHMpIHtcbiAgICBjb25zdCBvbGRTZXJpZXMgPSBvbGRPcHRzPy5uYXZpZ2F0b3I/Lm1pbmlDaGFydD8uc2VyaWVzID8/IG9sZE9wdHM/LnNlcmllcztcbiAgICBjb25zdCBtaW5pQ2hhcnRTZXJpZXNTdGF0dXMgPSB0aGlzLmFwcGx5U2VyaWVzKFxuICAgICAgbWluaUNoYXJ0LFxuICAgICAgdGhpcy5maWx0ZXJNaW5pQ2hhcnRTZXJpZXMobWluaUNoYXJ0U2VyaWVzKSxcbiAgICAgIHRoaXMuZmlsdGVyTWluaUNoYXJ0U2VyaWVzKG9sZFNlcmllcylcbiAgICApO1xuICAgIHRoaXMuYXBwbHlBeGVzKG1pbmlDaGFydCwgY29tcGxldGVPcHRpb25zLCBvbGRPcHRzLCBtaW5pQ2hhcnRTZXJpZXNTdGF0dXMsIFtcbiAgICAgIFwiYXhlc1tdLnRpY2tcIixcbiAgICAgIFwiYXhlc1tdLnRoaWNrbmVzc1wiLFxuICAgICAgXCJheGVzW10udGl0bGVcIixcbiAgICAgIFwiYXhlc1tdLmNyb3NzaGFpclwiLFxuICAgICAgXCJheGVzW10uZ3JpZExpbmVcIixcbiAgICAgIFwiYXhlc1tdLmxhYmVsXCJcbiAgICBdKTtcbiAgICBjb25zdCBheGVzID0gbWluaUNoYXJ0LmF4ZXM7XG4gICAgY29uc3QgaG9yaXpvbnRhbEF4aXMgPSBheGVzLmZpbmQoKGF4aXMpID0+IGF4aXMuZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovKTtcbiAgICBmb3IgKGNvbnN0IGF4aXMgb2YgYXhlcykge1xuICAgICAgYXhpcy5ncmlkTGluZS5lbmFibGVkID0gZmFsc2U7XG4gICAgICBheGlzLmxhYmVsLmVuYWJsZWQgPSBheGlzID09PSBob3Jpem9udGFsQXhpcztcbiAgICAgIGF4aXMudGljay5lbmFibGVkID0gZmFsc2U7XG4gICAgICBheGlzLmludGVyYWN0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaG9yaXpvbnRhbEF4aXMgIT0gbnVsbCkge1xuICAgICAgY29uc3QgbWluaUNoYXJ0T3B0cyA9IGNvbXBsZXRlT3B0aW9ucy5uYXZpZ2F0b3I/Lm1pbmlDaGFydDtcbiAgICAgIGNvbnN0IGxhYmVsT3B0aW9ucyA9IG1pbmlDaGFydE9wdHM/LmxhYmVsO1xuICAgICAgY29uc3QgaW50ZXJ2YWxPcHRpb25zID0gbWluaUNoYXJ0T3B0cz8ubGFiZWw/LmludGVydmFsO1xuICAgICAgaG9yaXpvbnRhbEF4aXMubGluZS5lbmFibGVkID0gZmFsc2U7XG4gICAgICBob3Jpem9udGFsQXhpcy5sYWJlbC5zZXQoXG4gICAgICAgIHdpdGhvdXQobGFiZWxPcHRpb25zLCBbXCJpbnRlcnZhbFwiLCBcInJvdGF0aW9uXCIsIFwibWluU3BhY2luZ1wiLCBcImF1dG9Sb3RhdGVcIiwgXCJhdXRvUm90YXRlQW5nbGVcIl0pXG4gICAgICApO1xuICAgICAgaG9yaXpvbnRhbEF4aXMudGljay5zZXQoXG4gICAgICAgIHdpdGhvdXQoaW50ZXJ2YWxPcHRpb25zLCBbXCJlbmFibGVkXCIsIFwid2lkdGhcIiwgXCJzaXplXCIsIFwiY29sb3JcIiwgXCJpbnRlcnZhbFwiLCBcInN0ZXBcIl0pXG4gICAgICApO1xuICAgICAgY29uc3Qgc3RlcCA9IGludGVydmFsT3B0aW9ucz8uc3RlcDtcbiAgICAgIGlmIChzdGVwICE9IG51bGwpIHtcbiAgICAgICAgaG9yaXpvbnRhbEF4aXMuaW50ZXJ2YWwuc3RlcCA9IHN0ZXA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFwcGx5TW9kdWxlcyhvcHRpb25zKSB7XG4gICAgY29uc3QgeyB0eXBlOiBjaGFydFR5cGUyIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIGxldCBtb2R1bGVzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgbW9kdWxlIG9mIG1vZHVsZVJlZ2lzdHJ5LmJ5VHlwZShcInJvb3RcIiwgXCJsZWdlbmRcIikpIHtcbiAgICAgIGNvbnN0IGlzQ29uZmlndXJlZCA9IG9wdGlvbnNbbW9kdWxlLm9wdGlvbnNLZXldICE9IG51bGw7XG4gICAgICBjb25zdCBzaG91bGRCZUVuYWJsZWQgPSBpc0NvbmZpZ3VyZWQgJiYgbW9kdWxlLmNoYXJ0VHlwZXMuaW5jbHVkZXMoY2hhcnRUeXBlMik7XG4gICAgICBpZiAoc2hvdWxkQmVFbmFibGVkID09PSB0aGlzLm1vZHVsZXNNYW5hZ2VyLmlzRW5hYmxlZChtb2R1bGUpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChzaG91bGRCZUVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5tb2R1bGVzTWFuYWdlci5hZGRNb2R1bGUobW9kdWxlLCAobSkgPT4gbS5tb2R1bGVGYWN0b3J5KHRoaXMuZ2V0TW9kdWxlQ29udGV4dCgpKSk7XG4gICAgICAgIGlmIChtb2R1bGUudHlwZSA9PT0gXCJsZWdlbmRcIikge1xuICAgICAgICAgIHRoaXMubW9kdWxlc01hbmFnZXIuZ2V0TW9kdWxlKG1vZHVsZSk/LmF0dGFjaExlZ2VuZCh0aGlzLmN0eC5zY2VuZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1ttb2R1bGUub3B0aW9uc0tleV0gPSB0aGlzLm1vZHVsZXNNYW5hZ2VyLmdldE1vZHVsZShtb2R1bGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tb2R1bGVzTWFuYWdlci5yZW1vdmVNb2R1bGUobW9kdWxlKTtcbiAgICAgICAgZGVsZXRlIHRoaXNbbW9kdWxlLm9wdGlvbnNLZXldO1xuICAgICAgfVxuICAgICAgbW9kdWxlc0NoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbW9kdWxlc0NoYW5nZWQ7XG4gIH1cbiAgYXBwbHlTZXJpZXMoY2hhcnQsIG9wdFNlcmllcywgb2xkT3B0U2VyaWVzKSB7XG4gICAgaWYgKCFvcHRTZXJpZXMpIHtcbiAgICAgIHJldHVybiBcIm5vLWNoYW5nZVwiO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaFJlc3VsdCA9IG1hdGNoU2VyaWVzT3B0aW9ucyhjaGFydC5zZXJpZXMsIG9wdFNlcmllcywgb2xkT3B0U2VyaWVzKTtcbiAgICBpZiAobWF0Y2hSZXN1bHQuc3RhdHVzID09PSBcIm5vLW92ZXJsYXBcIikge1xuICAgICAgZGVidWcoYENoYXJ0LmFwcGx5U2VyaWVzKCkgLSBjcmVhdGluZyBuZXcgc2VyaWVzIGluc3RhbmNlcywgc3RhdHVzOiAke21hdGNoUmVzdWx0LnN0YXR1c31gLCBtYXRjaFJlc3VsdCk7XG4gICAgICBjaGFydC5zZXJpZXMgPSBvcHRTZXJpZXMubWFwKChvcHRzKSA9PiB0aGlzLmNyZWF0ZVNlcmllcyhvcHRzKSk7XG4gICAgICByZXR1cm4gXCJyZXBsYWNlZFwiO1xuICAgIH1cbiAgICBkZWJ1ZyhgQ2hhcnQuYXBwbHlTZXJpZXMoKSAtIG1hdGNoUmVzdWx0YCwgbWF0Y2hSZXN1bHQpO1xuICAgIGNvbnN0IHNlcmllc0luc3RhbmNlcyA9IFtdO1xuICAgIGxldCBkYXRhQ2hhbmdlZCA9IGZhbHNlO1xuICAgIGxldCBncm91cGluZ0NoYW5nZWQgPSBmYWxzZTtcbiAgICBsZXQgaXNVcGRhdGVkID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBjaGFuZ2Ugb2YgbWF0Y2hSZXN1bHQuY2hhbmdlcykge1xuICAgICAgZ3JvdXBpbmdDaGFuZ2VkIHx8IChncm91cGluZ0NoYW5nZWQgPSBjaGFuZ2Uuc3RhdHVzID09PSBcInNlcmllcy1ncm91cGluZ1wiKTtcbiAgICAgIGRhdGFDaGFuZ2VkIHx8IChkYXRhQ2hhbmdlZCA9IGNoYW5nZS5kaWZmPy5kYXRhICE9IG51bGwpO1xuICAgICAgaXNVcGRhdGVkIHx8IChpc1VwZGF0ZWQgPSBjaGFuZ2Uuc3RhdHVzICE9PSBcIm5vLW9wXCIpO1xuICAgICAgc3dpdGNoIChjaGFuZ2Uuc3RhdHVzKSB7XG4gICAgICAgIGNhc2UgXCJhZGRcIjpcbiAgICAgICAgICBjb25zdCBuZXdTZXJpZXMgPSB0aGlzLmNyZWF0ZVNlcmllcyhjaGFuZ2Uub3B0cyk7XG4gICAgICAgICAgc2VyaWVzSW5zdGFuY2VzLnB1c2gobmV3U2VyaWVzKTtcbiAgICAgICAgICBkZWJ1ZyhgQ2hhcnQuYXBwbHlTZXJpZXMoKSAtIGNyZWF0ZWQgbmV3IHNlcmllc2AsIG5ld1Nlcmllcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJyZW1vdmVcIjpcbiAgICAgICAgICBkZWJ1ZyhgQ2hhcnQuYXBwbHlTZXJpZXMoKSAtIHJlbW92aW5nIHNlcmllcyBhdCBwcmV2aW91cyBpZHggJHtjaGFuZ2UuaWR4fWAsIGNoYW5nZS5zZXJpZXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibm8tb3BcIjpcbiAgICAgICAgICBzZXJpZXNJbnN0YW5jZXMucHVzaChjaGFuZ2Uuc2VyaWVzKTtcbiAgICAgICAgICBkZWJ1ZyhgQ2hhcnQuYXBwbHlTZXJpZXMoKSAtIG5vIGNoYW5nZSB0byBzZXJpZXMgYXQgcHJldmlvdXMgaWR4ICR7Y2hhbmdlLmlkeH1gLCBjaGFuZ2Uuc2VyaWVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNlcmllcy1ncm91cGluZ1wiOlxuICAgICAgICBjYXNlIFwidXBkYXRlXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc3QgeyBzZXJpZXMsIGRpZmY6IGRpZmYyLCBpZHggfSA9IGNoYW5nZTtcbiAgICAgICAgICBkZWJ1ZyhgQ2hhcnQuYXBwbHlTZXJpZXMoKSAtIGFwcGx5aW5nIHNlcmllcyBkaWZmIHByZXZpb3VzIGlkeCAke2lkeH1gLCBkaWZmMiwgc2VyaWVzKTtcbiAgICAgICAgICB0aGlzLmFwcGx5U2VyaWVzVmFsdWVzKHNlcmllcywgZGlmZjIpO1xuICAgICAgICAgIHNlcmllcy5tYXJrTm9kZURhdGFEaXJ0eSgpO1xuICAgICAgICAgIHNlcmllc0luc3RhbmNlcy5wdXNoKHNlcmllcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNlcmllc0luc3RhbmNlcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICBzZXJpZXNJbnN0YW5jZXNbaWR4XS5fZGVjbGFyYXRpb25PcmRlciA9IGlkeDtcbiAgICB9XG4gICAgZGVidWcoYENoYXJ0LmFwcGx5U2VyaWVzKCkgLSBmaW5hbCBzZXJpZXMgaW5zdGFuY2VzYCwgc2VyaWVzSW5zdGFuY2VzKTtcbiAgICBjaGFydC5zZXJpZXMgPSBzZXJpZXNJbnN0YW5jZXM7XG4gICAgaWYgKGdyb3VwaW5nQ2hhbmdlZCkge1xuICAgICAgcmV0dXJuIFwic2VyaWVzLWdyb3VwaW5nLWNoYW5nZVwiO1xuICAgIH1cbiAgICBpZiAoZGF0YUNoYW5nZWQpIHtcbiAgICAgIHJldHVybiBcImRhdGEtY2hhbmdlXCI7XG4gICAgfVxuICAgIHJldHVybiBpc1VwZGF0ZWQgPyBcInVwZGF0ZWRcIiA6IFwibm8tb3BcIjtcbiAgfVxuICBhcHBseUF4ZXMoY2hhcnQsIG9wdGlvbnMsIG9sZE9wdHMsIHNlcmllc1N0YXR1cywgc2tpcCA9IFtdLCByZWdpc3RlclJlZ2lvbnMgPSBmYWxzZSkge1xuICAgIGlmICghKFwiYXhlc1wiIGluIG9wdGlvbnMpIHx8ICFvcHRpb25zLmF4ZXMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc2tpcCA9IFtcImF4ZXNbXS50eXBlXCIsIC4uLnNraXBdO1xuICAgIGNvbnN0IHsgYXhlcyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBmb3JjZVJlY3JlYXRlID0gc2VyaWVzU3RhdHVzID09PSBcInJlcGxhY2VkXCI7XG4gICAgY29uc3QgbWF0Y2hpbmdUeXBlcyA9ICFmb3JjZVJlY3JlYXRlICYmIGNoYXJ0LmF4ZXMubGVuZ3RoID09PSBheGVzLmxlbmd0aCAmJiBjaGFydC5heGVzLmV2ZXJ5KChhLCBpKSA9PiBhLnR5cGUgPT09IGF4ZXNbaV0udHlwZSk7XG4gICAgaWYgKG1hdGNoaW5nVHlwZXMgJiYgaXNBZ0NhcnRlc2lhbkNoYXJ0T3B0aW9ucyhvbGRPcHRzKSkge1xuICAgICAgY2hhcnQuYXhlcy5mb3JFYWNoKChheGlzLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBwcmV2aW91c09wdHMgPSBvbGRPcHRzLmF4ZXM/LltpbmRleF0gPz8ge307XG4gICAgICAgIGNvbnN0IGF4aXNEaWZmID0ganNvbkRpZmYocHJldmlvdXNPcHRzLCBheGVzW2luZGV4XSk7XG4gICAgICAgIGRlYnVnKGBDaGFydC5hcHBseUF4ZXMoKSAtIGFwcGx5aW5nIGF4aXMgZGlmZiBpZHggJHtpbmRleH1gLCBheGlzRGlmZik7XG4gICAgICAgIGNvbnN0IHBhdGggPSBgYXhlc1ske2luZGV4fV1gO1xuICAgICAgICBqc29uQXBwbHkoYXhpcywgYXhpc0RpZmYsIHsgcGF0aCwgc2tpcCB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRlYnVnKGBDaGFydC5hcHBseUF4ZXMoKSAtIGNyZWF0aW5nIG5ldyBheGVzIGluc3RhbmNlczsgc2VyaWVzU3RhdHVzOiAke3Nlcmllc1N0YXR1c31gKTtcbiAgICBjaGFydC5heGVzID0gdGhpcy5jcmVhdGVBeGlzKGF4ZXMsIHNraXApO1xuICAgIGNvbnN0IGF4aXNHcm91cHMgPSB7XG4gICAgICBbXCJ4XCIgLyogWCAqL106IFtdLFxuICAgICAgW1wieVwiIC8qIFkgKi9dOiBbXVxuICAgIH07XG4gICAgY2hhcnQuYXhlcy5mb3JFYWNoKChheGlzKSA9PiBheGlzR3JvdXBzW2F4aXMuZGlyZWN0aW9uXS5wdXNoKGF4aXMuZ2V0UmVnaW9uQkJveFByb3ZpZGVyKCkpKTtcbiAgICBpZiAocmVnaXN0ZXJSZWdpb25zKSB7XG4gICAgICB0aGlzLmN0eC5yZWdpb25NYW5hZ2VyLnVwZGF0ZVJlZ2lvbihcImhvcml6b250YWwtYXhlc1wiIC8qIEhPUklaT05UQUxfQVhFUyAqLywgLi4uYXhpc0dyb3Vwc1tcInhcIiAvKiBYICovXSk7XG4gICAgICB0aGlzLmN0eC5yZWdpb25NYW5hZ2VyLnVwZGF0ZVJlZ2lvbihcInZlcnRpY2FsLWF4ZXNcIiAvKiBWRVJUSUNBTF9BWEVTICovLCAuLi5heGlzR3JvdXBzW1wieVwiIC8qIFkgKi9dKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY3JlYXRlU2VyaWVzKHNlcmllc09wdGlvbnMpIHtcbiAgICBjb25zdCBzZXJpZXNJbnN0YW5jZSA9IHNlcmllc1JlZ2lzdHJ5LmNyZWF0ZShzZXJpZXNPcHRpb25zLnR5cGUsIHRoaXMuZ2V0TW9kdWxlQ29udGV4dCgpKTtcbiAgICB0aGlzLmFwcGx5U2VyaWVzT3B0aW9uTW9kdWxlcyhzZXJpZXNJbnN0YW5jZSwgc2VyaWVzT3B0aW9ucyk7XG4gICAgdGhpcy5hcHBseVNlcmllc1ZhbHVlcyhzZXJpZXNJbnN0YW5jZSwgc2VyaWVzT3B0aW9ucyk7XG4gICAgcmV0dXJuIHNlcmllc0luc3RhbmNlO1xuICB9XG4gIGFwcGx5U2VyaWVzT3B0aW9uTW9kdWxlcyhzZXJpZXMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBtb2R1bGVDb250ZXh0ID0gc2VyaWVzLmNyZWF0ZU1vZHVsZUNvbnRleHQoKTtcbiAgICBjb25zdCBtb2R1bGVNYXAgPSBzZXJpZXMuZ2V0TW9kdWxlTWFwKCk7XG4gICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlUmVnaXN0cnkuYnlUeXBlKFwic2VyaWVzLW9wdGlvblwiKSkge1xuICAgICAgaWYgKG1vZHVsZS5vcHRpb25zS2V5IGluIG9wdGlvbnMgJiYgbW9kdWxlLnNlcmllc1R5cGVzLmluY2x1ZGVzKHNlcmllcy50eXBlKSkge1xuICAgICAgICBtb2R1bGVNYXAuYWRkTW9kdWxlKG1vZHVsZSwgKG0pID0+IG0ubW9kdWxlRmFjdG9yeShtb2R1bGVDb250ZXh0KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFwcGx5U2VyaWVzVmFsdWVzKHRhcmdldCwgb3B0aW9ucykge1xuICAgIGNvbnN0IG1vZHVsZU1hcCA9IHRhcmdldC5nZXRNb2R1bGVNYXAoKTtcbiAgICBjb25zdCB7IHR5cGU6IF8sIGRhdGEsIGxpc3RlbmVycywgc2VyaWVzR3JvdXBpbmcsIHNob3dJbk1pbmlDaGFydDogX18sIC4uLnNlcmllc09wdGlvbnMgfSA9IG9wdGlvbnM7XG4gICAgZm9yIChjb25zdCBtb2R1bGVEZWYgb2YgRVhQRUNURURfRU5URVJQUklTRV9NT0RVTEVTKSB7XG4gICAgICBpZiAobW9kdWxlRGVmLnR5cGUgIT09IFwic2VyaWVzLW9wdGlvblwiKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChtb2R1bGVEZWYub3B0aW9uc0tleSBpbiBzZXJpZXNPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IG1vZHVsZU1hcC5nZXRNb2R1bGUobW9kdWxlRGVmLm9wdGlvbnNLZXkpO1xuICAgICAgICBpZiAobW9kdWxlKSB7XG4gICAgICAgICAgY29uc3QgbW9kdWxlT3B0aW9ucyA9IHNlcmllc09wdGlvbnNbbW9kdWxlRGVmLm9wdGlvbnNLZXldO1xuICAgICAgICAgIGRlbGV0ZSBzZXJpZXNPcHRpb25zW21vZHVsZURlZi5vcHRpb25zS2V5XTtcbiAgICAgICAgICBtb2R1bGUucHJvcGVydGllcy5zZXQobW9kdWxlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGFyZ2V0LnByb3BlcnRpZXMuc2V0KHNlcmllc09wdGlvbnMpO1xuICAgIGlmIChcImRhdGFcIiBpbiBvcHRpb25zKSB7XG4gICAgICB0YXJnZXQuc2V0T3B0aW9uc0RhdGEoZGF0YSk7XG4gICAgfVxuICAgIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnModGFyZ2V0LCBsaXN0ZW5lcnMpO1xuICAgIH1cbiAgICBpZiAoXCJzZXJpZXNHcm91cGluZ1wiIGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChzZXJpZXNHcm91cGluZyA9PSBudWxsKSB7XG4gICAgICAgIHRhcmdldC5zZXJpZXNHcm91cGluZyA9IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldC5zZXJpZXNHcm91cGluZyA9IHsgLi4udGFyZ2V0LnNlcmllc0dyb3VwaW5nLCAuLi5zZXJpZXNHcm91cGluZyB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjcmVhdGVBeGlzKG9wdGlvbnMsIHNraXApIHtcbiAgICBjb25zdCBuZXdBeGVzID0gW107XG4gICAgY29uc3QgbW9kdWxlQ29udGV4dCA9IHRoaXMuZ2V0TW9kdWxlQ29udGV4dCgpO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBvcHRpb25zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgYXhpc09wdGlvbnMgPSBvcHRpb25zW2luZGV4XTtcbiAgICAgIGNvbnN0IGF4aXMgPSBheGlzUmVnaXN0cnkuY3JlYXRlKGF4aXNPcHRpb25zLnR5cGUsIG1vZHVsZUNvbnRleHQpO1xuICAgICAgdGhpcy5hcHBseUF4aXNNb2R1bGVzKGF4aXMsIGF4aXNPcHRpb25zKTtcbiAgICAgIGpzb25BcHBseShheGlzLCBheGlzT3B0aW9ucywgeyBwYXRoOiBgYXhlc1ske2luZGV4fV1gLCBza2lwIH0pO1xuICAgICAgbmV3QXhlcy5wdXNoKGF4aXMpO1xuICAgIH1cbiAgICBndWVzc0ludmFsaWRQb3NpdGlvbnMobmV3QXhlcyk7XG4gICAgcmV0dXJuIG5ld0F4ZXM7XG4gIH1cbiAgYXBwbHlBeGlzTW9kdWxlcyhheGlzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbW9kdWxlQ29udGV4dCA9IGF4aXMuY3JlYXRlTW9kdWxlQ29udGV4dCgpO1xuICAgIGNvbnN0IG1vZHVsZU1hcCA9IGF4aXMuZ2V0TW9kdWxlTWFwKCk7XG4gICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlUmVnaXN0cnkuYnlUeXBlKFwiYXhpcy1vcHRpb25cIikpIHtcbiAgICAgIGNvbnN0IHNob3VsZEJlRW5hYmxlZCA9IG9wdGlvbnNbbW9kdWxlLm9wdGlvbnNLZXldICE9IG51bGw7XG4gICAgICBpZiAoc2hvdWxkQmVFbmFibGVkID09PSBtb2R1bGVNYXAuaXNFbmFibGVkKG1vZHVsZSkpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKHNob3VsZEJlRW5hYmxlZCkge1xuICAgICAgICBtb2R1bGVNYXAuYWRkTW9kdWxlKG1vZHVsZSwgKG0pID0+IG0ubW9kdWxlRmFjdG9yeShtb2R1bGVDb250ZXh0KSk7XG4gICAgICAgIGF4aXNbbW9kdWxlLm9wdGlvbnNLZXldID0gbW9kdWxlTWFwLmdldE1vZHVsZShtb2R1bGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kdWxlTWFwLnJlbW92ZU1vZHVsZShtb2R1bGUpO1xuICAgICAgICBkZWxldGUgYXhpc1ttb2R1bGUub3B0aW9uc0tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKHNvdXJjZSwgbGlzdGVuZXJzKSB7XG4gICAgc291cmNlLmNsZWFyRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICBmb3IgKGNvbnN0IFtwcm9wZXJ0eSwgbGlzdGVuZXJdIG9mIE9iamVjdC5lbnRyaWVzKGxpc3RlbmVycykpIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVyKSkge1xuICAgICAgICBzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihwcm9wZXJ0eSwgbGlzdGVuZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbl9DaGFydC5jaGFydHNJbnN0YW5jZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBuZXdWYWx1ZSh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLmN0eC5kb21NYW5hZ2VyLnNldENvbnRhaW5lcih2YWx1ZSk7XG4gICAgICBfQ2hhcnQuY2hhcnRzSW5zdGFuY2VzLnNldCh2YWx1ZSwgdGhpcyk7XG4gICAgfSxcbiAgICBvbGRWYWx1ZSh2YWx1ZSkge1xuICAgICAgX0NoYXJ0LmNoYXJ0c0luc3RhbmNlcy5kZWxldGUodmFsdWUpO1xuICAgIH1cbiAgfSlcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwiY29udGFpbmVyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIG5ld1ZhbHVlKHZhbHVlKSB7XG4gICAgICB0aGlzLnJlc2l6ZShcIndpZHRoIG9wdGlvblwiLCB7IGluV2lkdGg6IHZhbHVlIH0pO1xuICAgIH1cbiAgfSlcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwid2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgbmV3VmFsdWUodmFsdWUpIHtcbiAgICAgIHRoaXMucmVzaXplKFwiaGVpZ2h0IG9wdGlvblwiLCB7IGluSGVpZ2h0OiB2YWx1ZSB9KTtcbiAgICB9XG4gIH0pXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcImhlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBuZXdWYWx1ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5yZXNpemUoXCJtaW5XaWR0aCBvcHRpb25cIiwgeyBpbk1pbldpZHRoOiB2YWx1ZSB9KTtcbiAgICB9XG4gIH0pXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcIm1pbldpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIG5ld1ZhbHVlKHZhbHVlKSB7XG4gICAgICB0aGlzLnJlc2l6ZShcIm1pbkhlaWdodCBvcHRpb25cIiwgeyBpbk1pbkhlaWdodDogdmFsdWUgfSk7XG4gICAgfVxuICB9KVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJtaW5IZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcInRpdGxlUGFkZGluZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwic2VyaWVzQXJlYVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwidGl0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcInN1YnRpdGxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgX0NoYXJ0LnByb3RvdHlwZSwgXCJmb290bm90ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwia2V5Ym9hcmRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShVTklPTihbXCJzdGFuZGFsb25lXCIsIFwiaW50ZWdyYXRlZFwiXSwgXCJhIGNoYXJ0IG1vZGVcIikpXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcIm1vZGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgY2hhbmdlVmFsdWUobmV3VmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgICB0aGlzLm9uQXhpc0NoYW5nZShuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuICAgIH1cbiAgfSlcbl0sIF9DaGFydC5wcm90b3R5cGUsIFwiYXhlc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBjaGFuZ2VWYWx1ZShuZXdWYWx1ZSwgb2xkVmFsdWUpIHtcbiAgICAgIHRoaXMub25TZXJpZXNDaGFuZ2UobmV3VmFsdWUsIG9sZFZhbHVlKTtcbiAgICB9XG4gIH0pXG5dLCBfQ2hhcnQucHJvdG90eXBlLCBcInNlcmllc1wiLCAyKTtcbnZhciBDaGFydCA9IF9DaGFydDtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvdXRpbC9xdWFkdHJlZS50c1xudmFyIFF1YWR0cmVlTmVhcmVzdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2FwYWNpdHksIG1heGRlcHRoLCBib3VuZGFyeSkge1xuICAgIHRoaXMucm9vdCA9IG5ldyBRdWFkdHJlZU5vZGVOZWFyZXN0KGNhcGFjaXR5LCBtYXhkZXB0aCwgYm91bmRhcnkpO1xuICB9XG4gIGNsZWFyKGJvdW5kYXJ5KSB7XG4gICAgdGhpcy5yb290LmNsZWFyKGJvdW5kYXJ5KTtcbiAgfVxuICBhZGRWYWx1ZShoaXRUZXN0ZXIsIHZhbHVlKSB7XG4gICAgY29uc3QgZWxlbSA9IHtcbiAgICAgIGhpdFRlc3RlcixcbiAgICAgIHZhbHVlLFxuICAgICAgZGlzdGFuY2VTcXVhcmVkOiAoeCwgeSkgPT4ge1xuICAgICAgICByZXR1cm4gaGl0VGVzdGVyLmRpc3RhbmNlU3F1YXJlZCh4LCB5KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMucm9vdC5hZGRFbGVtKGVsZW0pO1xuICB9XG4gIGZpbmQoeCwgeSkge1xuICAgIGNvbnN0IGFyZyA9IHsgYmVzdDogeyBuZWFyZXN0OiB2b2lkIDAsIGRpc3RhbmNlU3F1YXJlZDogSW5maW5pdHkgfSB9O1xuICAgIHRoaXMucm9vdC5maW5kKHgsIHksIGFyZyk7XG4gICAgcmV0dXJuIGFyZy5iZXN0O1xuICB9XG59O1xudmFyIFF1YWR0cmVlU3ViZGl2aXNpb25zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihudywgbmUsIHN3LCBzZSkge1xuICAgIHRoaXMubncgPSBudztcbiAgICB0aGlzLm5lID0gbmU7XG4gICAgdGhpcy5zdyA9IHN3O1xuICAgIHRoaXMuc2UgPSBzZTtcbiAgfVxuICBhZGRFbGVtKGVsZW0pIHtcbiAgICB0aGlzLm53LmFkZEVsZW0oZWxlbSk7XG4gICAgdGhpcy5uZS5hZGRFbGVtKGVsZW0pO1xuICAgIHRoaXMuc3cuYWRkRWxlbShlbGVtKTtcbiAgICB0aGlzLnNlLmFkZEVsZW0oZWxlbSk7XG4gIH1cbiAgZmluZCh4LCB5LCBhcmcpIHtcbiAgICB0aGlzLm53LmZpbmQoeCwgeSwgYXJnKTtcbiAgICB0aGlzLm5lLmZpbmQoeCwgeSwgYXJnKTtcbiAgICB0aGlzLnN3LmZpbmQoeCwgeSwgYXJnKTtcbiAgICB0aGlzLnNlLmZpbmQoeCwgeSwgYXJnKTtcbiAgfVxufTtcbnZhciBRdWFkdHJlZU5vZGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGNhcGFjaXR5LCBtYXhkZXB0aCwgYm91bmRhcnkpIHtcbiAgICB0aGlzLmNhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgdGhpcy5tYXhkZXB0aCA9IG1heGRlcHRoO1xuICAgIHRoaXMuYm91bmRhcnkgPSBib3VuZGFyeSA/PyBCQm94Lk5hTjtcbiAgICB0aGlzLmVsZW1zID0gW107XG4gICAgdGhpcy5zdWJkaXZpc2lvbnMgPSB2b2lkIDA7XG4gIH1cbiAgY2xlYXIoYm91bmRhcnkpIHtcbiAgICB0aGlzLmVsZW1zLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5ib3VuZGFyeSA9IGJvdW5kYXJ5O1xuICAgIHRoaXMuc3ViZGl2aXNpb25zID0gdm9pZCAwO1xuICB9XG4gIGFkZEVsZW0oZSkge1xuICAgIGlmICh0aGlzLmFkZENvbmRpdGlvbihlKSkge1xuICAgICAgaWYgKHRoaXMuc3ViZGl2aXNpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKHRoaXMubWF4ZGVwdGggPT09IDAgfHwgdGhpcy5lbGVtcy5sZW5ndGggPCB0aGlzLmNhcGFjaXR5KSB7XG4gICAgICAgICAgdGhpcy5lbGVtcy5wdXNoKGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc3ViZGl2aWRlKGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN1YmRpdmlzaW9ucy5hZGRFbGVtKGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmaW5kKHgsIHksIGFyZykge1xuICAgIGlmICh0aGlzLmZpbmRDb25kaXRpb24oeCwgeSwgYXJnKSkge1xuICAgICAgaWYgKHRoaXMuc3ViZGl2aXNpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5maW5kQWN0aW9uKHgsIHksIGFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN1YmRpdmlzaW9ucy5maW5kKHgsIHksIGFyZyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN1YmRpdmlkZShuZXdFbGVtKSB7XG4gICAgdGhpcy5zdWJkaXZpc2lvbnMgPSB0aGlzLm1ha2VTdWJkaXZpc2lvbnMoKTtcbiAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5lbGVtcykge1xuICAgICAgdGhpcy5zdWJkaXZpc2lvbnMuYWRkRWxlbShlKTtcbiAgICB9XG4gICAgdGhpcy5zdWJkaXZpc2lvbnMuYWRkRWxlbShuZXdFbGVtKTtcbiAgICB0aGlzLmVsZW1zLmxlbmd0aCA9IDA7XG4gIH1cbiAgbWFrZVN1YmRpdmlzaW9ucygpIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuYm91bmRhcnk7XG4gICAgY29uc3QgeyBjYXBhY2l0eSB9ID0gdGhpcztcbiAgICBjb25zdCBkZXB0aCA9IHRoaXMubWF4ZGVwdGggLSAxO1xuICAgIGNvbnN0IGhhbGZXaWR0aCA9IHdpZHRoIC8gMjtcbiAgICBjb25zdCBoYWxmSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgICBjb25zdCBud0JvdW5kYXJ5ID0gbmV3IEJCb3goeCwgeSwgaGFsZldpZHRoLCBoYWxmSGVpZ2h0KTtcbiAgICBjb25zdCBuZUJvdW5kYXJ5ID0gbmV3IEJCb3goeCArIGhhbGZXaWR0aCwgeSwgaGFsZldpZHRoLCBoYWxmSGVpZ2h0KTtcbiAgICBjb25zdCBzd0JvdW5kYXJ5ID0gbmV3IEJCb3goeCwgeSArIGhhbGZIZWlnaHQsIGhhbGZXaWR0aCwgaGFsZkhlaWdodCk7XG4gICAgY29uc3Qgc2VCb3VuZGFyeSA9IG5ldyBCQm94KHggKyBoYWxmV2lkdGgsIHkgKyBoYWxmSGVpZ2h0LCBoYWxmV2lkdGgsIGhhbGZIZWlnaHQpO1xuICAgIHJldHVybiBuZXcgUXVhZHRyZWVTdWJkaXZpc2lvbnMoXG4gICAgICB0aGlzLmNoaWxkKGNhcGFjaXR5LCBkZXB0aCwgbndCb3VuZGFyeSksXG4gICAgICB0aGlzLmNoaWxkKGNhcGFjaXR5LCBkZXB0aCwgbmVCb3VuZGFyeSksXG4gICAgICB0aGlzLmNoaWxkKGNhcGFjaXR5LCBkZXB0aCwgc3dCb3VuZGFyeSksXG4gICAgICB0aGlzLmNoaWxkKGNhcGFjaXR5LCBkZXB0aCwgc2VCb3VuZGFyeSlcbiAgICApO1xuICB9XG59O1xudmFyIFF1YWR0cmVlTm9kZU5lYXJlc3QgPSBjbGFzcyBfUXVhZHRyZWVOb2RlTmVhcmVzdCBleHRlbmRzIFF1YWR0cmVlTm9kZSB7XG4gIGFkZENvbmRpdGlvbihlKSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBlLmhpdFRlc3Rlci5taWRQb2ludDtcbiAgICByZXR1cm4gdGhpcy5ib3VuZGFyeS5jb250YWluc1BvaW50KHgsIHkpO1xuICB9XG4gIGZpbmRDb25kaXRpb24oeCwgeSwgYXJnKSB7XG4gICAgY29uc3QgeyBiZXN0IH0gPSBhcmc7XG4gICAgcmV0dXJuIGJlc3QuZGlzdGFuY2VTcXVhcmVkICE9PSAwICYmIHRoaXMuYm91bmRhcnkuZGlzdGFuY2VTcXVhcmVkKHgsIHkpIDwgYmVzdC5kaXN0YW5jZVNxdWFyZWQ7XG4gIH1cbiAgZmluZEFjdGlvbih4LCB5LCBhcmcpIHtcbiAgICBjb25zdCBvdGhlciA9IG5lYXJlc3RTcXVhcmVkKHgsIHksIHRoaXMuZWxlbXMsIGFyZy5iZXN0LmRpc3RhbmNlU3F1YXJlZCk7XG4gICAgaWYgKG90aGVyLm5lYXJlc3QgIT09IHZvaWQgMCAmJiBvdGhlci5kaXN0YW5jZVNxdWFyZWQgPCBhcmcuYmVzdC5kaXN0YW5jZVNxdWFyZWQpIHtcbiAgICAgIGFyZy5iZXN0ID0gb3RoZXI7XG4gICAgfVxuICB9XG4gIGNoaWxkKGNhcGFjaXR5LCBkZXB0aCwgYm91bmRhcnkpIHtcbiAgICByZXR1cm4gbmV3IF9RdWFkdHJlZU5vZGVOZWFyZXN0KGNhcGFjaXR5LCBkZXB0aCwgYm91bmRhcnkpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXJrZXIvbWFya2VyLnRzXG52YXIgTWFya2VyID0gY2xhc3MgZXh0ZW5kcyBQYXRoIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5zaXplID0gMTI7XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgY29uc3QgeyB4LCB5LCBzaXplIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgY2VudGVyIH0gPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBuZXcgQkJveCh4IC0gc2l6ZSAqIGNlbnRlci54LCB5IC0gc2l6ZSAqIGNlbnRlci55LCBzaXplLCBzaXplKTtcbiAgfVxuICBjb21wdXRlVHJhbnNmb3JtZWRCQm94KCkge1xuICAgIHJldHVybiBzdXBlci5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XG4gIH1cbiAgYXBwbHlQYXRoKHMsIG1vdmVzKSB7XG4gICAgY29uc3QgeyBwYXRoIH0gPSB0aGlzO1xuICAgIGxldCB7IHgsIHkgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMucmVwZWF0ICE9IG51bGwpIHtcbiAgICAgIHggPSAwO1xuICAgICAgeSA9IDA7XG4gICAgfVxuICAgIHBhdGguY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IHsgeDogbXgsIHk6IG15LCB0IH0gb2YgbW92ZXMpIHtcbiAgICAgIHggKz0gbXggKiBzO1xuICAgICAgeSArPSBteSAqIHM7XG4gICAgICBpZiAodCA9PT0gXCJtb3ZlXCIpIHtcbiAgICAgICAgcGF0aC5tb3ZlVG8oeCwgeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXRoLmxpbmVUbyh4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxuICBleGVjdXRlRmlsbChjdHgsIHBhdGgpIHtcbiAgICBpZiAoIXBhdGgpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMucmVwZWF0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBzdXBlci5leGVjdXRlRmlsbChjdHgsIHBhdGgpO1xuICAgIH1cbiAgICBjdHguc2F2ZSgpO1xuICAgIGxldCB4ID0gdGhpcy50cmFuc2xhdGlvblg7XG4gICAgbGV0IHkgPSB0aGlzLnRyYW5zbGF0aW9uWTtcbiAgICBmb3IgKGNvbnN0IHRyYW5zbGF0aW9uIG9mIHRoaXMucmVwZWF0KSB7XG4gICAgICBjdHgudHJhbnNsYXRlKHRyYW5zbGF0aW9uLnggLSB4LCB0cmFuc2xhdGlvbi55IC0geSk7XG4gICAgICBjdHguZmlsbChwYXRoKTtcbiAgICAgIHggPSB0cmFuc2xhdGlvbi54O1xuICAgICAgeSA9IHRyYW5zbGF0aW9uLnk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgZXhlY3V0ZVN0cm9rZShjdHgsIHBhdGgpIHtcbiAgICBpZiAoIXBhdGgpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMucmVwZWF0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBzdXBlci5leGVjdXRlU3Ryb2tlKGN0eCwgcGF0aCk7XG4gICAgfVxuICAgIGN0eC5zYXZlKCk7XG4gICAgbGV0IHggPSB0aGlzLnRyYW5zbGF0aW9uWDtcbiAgICBsZXQgeSA9IHRoaXMudHJhbnNsYXRpb25ZO1xuICAgIGZvciAoY29uc3QgdHJhbnNsYXRpb24gb2YgdGhpcy5yZXBlYXQpIHtcbiAgICAgIGN0eC50cmFuc2xhdGUodHJhbnNsYXRpb24ueCAtIHgsIHRyYW5zbGF0aW9uLnkgLSB5KTtcbiAgICAgIGN0eC5zdHJva2UocGF0aCk7XG4gICAgICB4ID0gdHJhbnNsYXRpb24ueDtcbiAgICAgIHkgPSB0cmFuc2xhdGlvbi55O1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59O1xuTWFya2VyLmNlbnRlciA9IHsgeDogMC41LCB5OiAwLjUgfTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBNYXJrZXIucHJvdG90eXBlLCBcInhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgTWFya2VyLnByb3RvdHlwZSwgXCJ5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKHsgY29udmVydG9yOiBNYXRoLmFicyB9KVxuXSwgTWFya2VyLnByb3RvdHlwZSwgXCJzaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIE1hcmtlci5wcm90b3R5cGUsIFwicmVwZWF0XCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXJrZXIvY2lyY2xlLnRzXG52YXIgQ2lyY2xlID0gY2xhc3MgZXh0ZW5kcyBNYXJrZXIge1xuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHsgeCwgeSwgcGF0aCwgc2l6ZSB9ID0gdGhpcztcbiAgICBjb25zdCByID0gc2l6ZSAvIDI7XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIHBhdGguYXJjKHgsIHksIHIsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG59O1xuQ2lyY2xlLmNsYXNzTmFtZSA9IFwiQ2lyY2xlXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcmtlci9jcm9zcy50c1xudmFyIF9Dcm9zcyA9IGNsYXNzIF9Dcm9zcyBleHRlbmRzIE1hcmtlciB7XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuc2l6ZSAvIDQuMjtcbiAgICBzdXBlci5hcHBseVBhdGgocywgX0Nyb3NzLm1vdmVzKTtcbiAgfVxufTtcbl9Dcm9zcy5jbGFzc05hbWUgPSBcIkNyb3NzXCI7XG5fQ3Jvc3MubW92ZXMgPSBbXG4gIHsgeDogLTEsIHk6IDAsIHQ6IFwibW92ZVwiIH0sXG4gIHsgeDogLTEsIHk6IC0xIH0sXG4gIHsgeDogMSwgeTogLTEgfSxcbiAgeyB4OiAxLCB5OiAxIH0sXG4gIHsgeDogMSwgeTogLTEgfSxcbiAgeyB4OiAxLCB5OiAxIH0sXG4gIHsgeDogLTEsIHk6IDEgfSxcbiAgeyB4OiAxLCB5OiAxIH0sXG4gIHsgeDogLTEsIHk6IDEgfSxcbiAgeyB4OiAtMSwgeTogLTEgfSxcbiAgeyB4OiAtMSwgeTogMSB9LFxuICB7IHg6IC0xLCB5OiAtMSB9XG5dO1xudmFyIENyb3NzID0gX0Nyb3NzO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXJrZXIvZGlhbW9uZC50c1xudmFyIF9EaWFtb25kID0gY2xhc3MgX0RpYW1vbmQgZXh0ZW5kcyBNYXJrZXIge1xuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHMgPSB0aGlzLnNpemUgLyAyO1xuICAgIHN1cGVyLmFwcGx5UGF0aChzLCBfRGlhbW9uZC5tb3Zlcyk7XG4gIH1cbn07XG5fRGlhbW9uZC5jbGFzc05hbWUgPSBcIkRpYW1vbmRcIjtcbl9EaWFtb25kLm1vdmVzID0gW1xuICB7IHg6IDAsIHk6IC0xLCB0OiBcIm1vdmVcIiB9LFxuICB7IHg6IDEsIHk6IDEgfSxcbiAgeyB4OiAtMSwgeTogMSB9LFxuICB7IHg6IC0xLCB5OiAtMSB9LFxuICB7IHg6IDEsIHk6IC0xIH1cbl07XG52YXIgRGlhbW9uZCA9IF9EaWFtb25kO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXJrZXIvaGVhcnQudHNcbnZhciBIZWFydCA9IGNsYXNzIGV4dGVuZHMgTWFya2VyIHtcbiAgcmFkKGRlZ3JlZTIpIHtcbiAgICByZXR1cm4gZGVncmVlMiAvIDE4MCAqIE1hdGguUEk7XG4gIH1cbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCB7IHgsIHBhdGgsIHNpemUsIHJhZCB9ID0gdGhpcztcbiAgICBjb25zdCByID0gc2l6ZSAvIDQ7XG4gICAgY29uc3QgeSA9IHRoaXMueSArIHIgLyAyO1xuICAgIHBhdGguY2xlYXIoKTtcbiAgICBwYXRoLmFyYyh4IC0gciwgeSAtIHIsIHIsIHJhZCgxMzApLCByYWQoMzMwKSk7XG4gICAgcGF0aC5hcmMoeCArIHIsIHkgLSByLCByLCByYWQoMjIwKSwgcmFkKDUwKSk7XG4gICAgcGF0aC5saW5lVG8oeCwgeSArIHIpO1xuICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5IZWFydC5jbGFzc05hbWUgPSBcIkhlYXJ0XCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcmtlci9waW4udHNcbnZhciBQaW4gPSBjbGFzcyBleHRlbmRzIE1hcmtlciB7XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgeyBwYXRoLCB4LCB5IH0gPSB0aGlzO1xuICAgIGNvbnN0IHMgPSB0aGlzLnNpemU7XG4gICAgY29uc3QgY3ggPSAwLjU7XG4gICAgY29uc3QgY3kgPSAxO1xuICAgIHBhdGguY2xlYXIoKTtcbiAgICBwYXRoLm1vdmVUbyh4ICsgKDAuMTU2MjUgLSBjeCkgKiBzLCB5ICsgKDAuMzQzNzUgLSBjeSkgKiBzKTtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgIHggKyAoMC4xNTYyNSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuMTUxNDkxIC0gY3kpICogcyxcbiAgICAgIHggKyAoMC4zMDc3NDEgLSBjeCkgKiBzLFxuICAgICAgeSArICgwIC0gY3kpICogcyxcbiAgICAgIHggKyAoMC41IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMCAtIGN5KSAqIHNcbiAgICApO1xuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgeCArICgwLjY5MjI1OSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjg0Mzc1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC4xNTE0OTEgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjg0Mzc1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC4zNDM3NSAtIGN5KSAqIHNcbiAgICApO1xuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgeCArICgwLjg0Mzc1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC40OTM4MjQgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjc4NDYyNSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNjAwMTgxIC0gY3kpICogcyxcbiAgICAgIHggKyAoMC43MTY0NjEgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjY5NTM5MyAtIGN5KSAqIHNcbiAgICApO1xuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgeCArICgwLjY5OTAwOSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNzE5NzY5IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC42ODEyNzEgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjc0MzEwNCAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNjYzNzg1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC43NjYxMDUgLSBjeSkgKiBzXG4gICAgKTtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgIHggKyAoMC42MTE4OTMgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjgzNDM2NyAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNTYyMjI4IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC44OTk2OTkgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjUyODg5NiAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuOTgwNjQ4IC0gY3kpICogc1xuICAgICk7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICB4ICsgKDAuNTI0MDc1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC45OTIzNTggLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjUxMjY2MyAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDEgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjUgLSBjeCkgKiBzLFxuICAgICAgeSArICgxIC0gY3kpICogc1xuICAgICk7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICB4ICsgKDAuNDg3MzM3IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMSAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNDc1OTI1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC45OTIzNTggLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjQ3MTEwNCAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuOTgwNjQ4IC0gY3kpICogc1xuICAgICk7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICB4ICsgKDAuNDg3MzM3IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMSAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuNDc1OTI1IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC45OTIzNTggLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjQ3MTEwNCAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuOTgwNjQ4IC0gY3kpICogc1xuICAgICk7XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8oXG4gICAgICB4ICsgKDAuNDM3NzcyIC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC44OTk2OTkgLSBjeSkgKiBzLFxuICAgICAgeCArICgwLjM4ODEwNyAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuODM0MzY3IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC4zMzYyMTUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjc2NjEwNSAtIGN5KSAqIHNcbiAgICApO1xuICAgIHBhdGguY3ViaWNDdXJ2ZVRvKFxuICAgICAgeCArICgwLjMxODcyOSAtIGN4KSAqIHMsXG4gICAgICB5ICsgKDAuNzQzMTA0IC0gY3kpICogcyxcbiAgICAgIHggKyAoMC4zMDA5OTEgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjcxOTc2OSAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuMjgzNTM5IC0gY3gpICogcyxcbiAgICAgIHkgKyAoMC42OTUzOTMgLSBjeSkgKiBzXG4gICAgKTtcbiAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgIHggKyAoMC4yMTUzNzUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjYwMDE4MSAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuMTU2MjUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjQ5MzgyNCAtIGN5KSAqIHMsXG4gICAgICB4ICsgKDAuMTU2MjUgLSBjeCkgKiBzLFxuICAgICAgeSArICgwLjM0Mzc1IC0gY3kpICogc1xuICAgICk7XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcblBpbi5jbGFzc05hbWUgPSBcIk1hcFBpblwiO1xuUGluLmNlbnRlciA9IHsgeDogMC41LCB5OiAxIH07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L21hcmtlci9wbHVzLnRzXG52YXIgX1BsdXMgPSBjbGFzcyBfUGx1cyBleHRlbmRzIE1hcmtlciB7XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgcyA9IHRoaXMuc2l6ZSAvIDM7XG4gICAgc3VwZXIuYXBwbHlQYXRoKHMsIF9QbHVzLm1vdmVzKTtcbiAgfVxufTtcbl9QbHVzLmNsYXNzTmFtZSA9IFwiUGx1c1wiO1xuX1BsdXMubW92ZXMgPSBbXG4gIHsgeDogLTAuNSwgeTogLTAuNSwgdDogXCJtb3ZlXCIgfSxcbiAgeyB4OiAwLCB5OiAtMSB9LFxuICB7IHg6IDEsIHk6IDAgfSxcbiAgeyB4OiAwLCB5OiAxIH0sXG4gIHsgeDogMSwgeTogMCB9LFxuICB7IHg6IDAsIHk6IDEgfSxcbiAgeyB4OiAtMSwgeTogMCB9LFxuICB7IHg6IDAsIHk6IDEgfSxcbiAgeyB4OiAtMSwgeTogMCB9LFxuICB7IHg6IDAsIHk6IC0xIH0sXG4gIHsgeDogLTEsIHk6IDAgfSxcbiAgeyB4OiAwLCB5OiAtMSB9XG5dO1xudmFyIFBsdXMgPSBfUGx1cztcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFya2VyL3NxdWFyZS50c1xudmFyIFNxdWFyZSA9IGNsYXNzIGV4dGVuZHMgTWFya2VyIHtcbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCB7IHBhdGgsIHgsIHkgfSA9IHRoaXM7XG4gICAgY29uc3QgaHMgPSB0aGlzLnNpemUgLyAyO1xuICAgIHBhdGguY2xlYXIoKTtcbiAgICBwYXRoLm1vdmVUbyh0aGlzLmFsaWduKHggLSBocyksIHRoaXMuYWxpZ24oeSAtIGhzKSk7XG4gICAgcGF0aC5saW5lVG8odGhpcy5hbGlnbih4ICsgaHMpLCB0aGlzLmFsaWduKHkgLSBocykpO1xuICAgIHBhdGgubGluZVRvKHRoaXMuYWxpZ24oeCArIGhzKSwgdGhpcy5hbGlnbih5ICsgaHMpKTtcbiAgICBwYXRoLmxpbmVUbyh0aGlzLmFsaWduKHggLSBocyksIHRoaXMuYWxpZ24oeSArIGhzKSk7XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcblNxdWFyZS5jbGFzc05hbWUgPSBcIlNxdWFyZVwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXJrZXIvc3Rhci50c1xudmFyIFN0YXIgPSBjbGFzcyBleHRlbmRzIE1hcmtlciB7XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgeyB4LCB5LCBwYXRoLCBzaXplIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNwaWtlcyA9IDU7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBzaXplIC8gMjtcbiAgICBjb25zdCByb3RhdGlvbiA9IE1hdGguUEkgLyAyO1xuICAgIHBhdGguY2xlYXIoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwaWtlcyAqIDI7IGkrKykge1xuICAgICAgY29uc3QgcmFkaXVzID0gaSAlIDIgPT09IDAgPyBzaXplIDogaW5uZXJSYWRpdXM7XG4gICAgICBjb25zdCBhbmdsZTIgPSBpICogTWF0aC5QSSAvIHNwaWtlcyAtIHJvdGF0aW9uO1xuICAgICAgY29uc3QgeENvb3JkaW5hdGUgPSB4ICsgTWF0aC5jb3MoYW5nbGUyKSAqIHJhZGl1cztcbiAgICAgIGNvbnN0IHlDb29yZGluYXRlID0geSArIE1hdGguc2luKGFuZ2xlMikgKiByYWRpdXM7XG4gICAgICBwYXRoLmxpbmVUbyh4Q29vcmRpbmF0ZSwgeUNvb3JkaW5hdGUpO1xuICAgIH1cbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG59O1xuU3Rhci5jbGFzc05hbWUgPSBcIlN0YXJcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbWFya2VyL3RyaWFuZ2xlLnRzXG52YXIgX1RyaWFuZ2xlID0gY2xhc3MgX1RyaWFuZ2xlIGV4dGVuZHMgTWFya2VyIHtcbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCBzID0gdGhpcy5zaXplICogMS4xO1xuICAgIHN1cGVyLmFwcGx5UGF0aChzLCBfVHJpYW5nbGUubW92ZXMpO1xuICB9XG59O1xuX1RyaWFuZ2xlLmNsYXNzTmFtZSA9IFwiVHJpYW5nbGVcIjtcbl9UcmlhbmdsZS5tb3ZlcyA9IFtcbiAgeyB4OiAwLCB5OiAtMC40OCwgdDogXCJtb3ZlXCIgfSxcbiAgeyB4OiAwLjUsIHk6IDAuODcgfSxcbiAgeyB4OiAtMSwgeTogMCB9XG5dO1xudmFyIFRyaWFuZ2xlID0gX1RyaWFuZ2xlO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXJrZXIvdXRpbC50c1xudmFyIE1BUktFUl9TSEFQRVMgPSB7XG4gIGNpcmNsZTogQ2lyY2xlLFxuICBjcm9zczogQ3Jvc3MsXG4gIGRpYW1vbmQ6IERpYW1vbmQsXG4gIGhlYXJ0OiBIZWFydCxcbiAgcGluOiBQaW4sXG4gIHBsdXM6IFBsdXMsXG4gIHNxdWFyZTogU3F1YXJlLFxuICBzdGFyOiBTdGFyLFxuICB0cmlhbmdsZTogVHJpYW5nbGVcbn07XG52YXIgTUFSS0VSX1NVUFBPUlRFRF9TSEFQRVMgPSBPYmplY3Qua2V5cyhNQVJLRVJfU0hBUEVTKTtcbmZ1bmN0aW9uIGlzTWFya2VyU2hhcGUoc2hhcGUpIHtcbiAgcmV0dXJuIHR5cGVvZiBzaGFwZSA9PT0gXCJzdHJpbmdcIiAmJiBNQVJLRVJfU1VQUE9SVEVEX1NIQVBFUy5pbmNsdWRlcyhzaGFwZSk7XG59XG5mdW5jdGlvbiBnZXRNYXJrZXIoc2hhcGUgPSBTcXVhcmUpIHtcbiAgaWYgKGlzTWFya2VyU2hhcGUoc2hhcGUpKSB7XG4gICAgcmV0dXJuIE1BUktFUl9TSEFQRVNbc2hhcGVdO1xuICB9XG4gIGlmICh0eXBlb2Ygc2hhcGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBzaGFwZTtcbiAgfVxuICByZXR1cm4gU3F1YXJlO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvZGF0YU1vZGVsU2VyaWVzLnRzXG52YXIgRGF0YU1vZGVsU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBTZXJpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuc2hvd0ZvY3VzQm94ID0gdHJ1ZTtcbiAgfVxuICBnZXRTY2FsZUluZm9ybWF0aW9uKHtcbiAgICB4U2NhbGUsXG4gICAgeVNjYWxlXG4gIH0pIHtcbiAgICBjb25zdCBpc0NvbnRpbnVvdXNYID0gQ29udGludW91c1NjYWxlLmlzKHhTY2FsZSk7XG4gICAgY29uc3QgaXNDb250aW51b3VzWSA9IENvbnRpbnVvdXNTY2FsZS5pcyh5U2NhbGUpO1xuICAgIHJldHVybiB7IGlzQ29udGludW91c1gsIGlzQ29udGludW91c1ksIHhTY2FsZVR5cGU6IHhTY2FsZT8udHlwZSwgeVNjYWxlVHlwZTogeVNjYWxlPy50eXBlIH07XG4gIH1cbiAgZ2V0TW9kdWxlUHJvcGVydHlEZWZpbml0aW9ucygpIHtcbiAgICBjb25zdCB4U2NhbGUgPSB0aGlzLmF4ZXNbXCJ4XCIgLyogWCAqL10/LnNjYWxlO1xuICAgIGNvbnN0IHlTY2FsZSA9IHRoaXMuYXhlc1tcInlcIiAvKiBZICovXT8uc2NhbGU7XG4gICAgcmV0dXJuIHRoaXMubW9kdWxlTWFwLm1hcE1vZHVsZXMoKG1vZDIpID0+IG1vZDIuZ2V0UHJvcGVydHlEZWZpbml0aW9ucyh0aGlzLmdldFNjYWxlSW5mb3JtYXRpb24oeyB4U2NhbGUsIHlTY2FsZSB9KSkpLmZsYXQoKTtcbiAgfVxuICAvLyBSZXF1ZXN0IGRhdGEsIGJ1dCB3aXRoIG1lc3NhZ2UgZGlzcGF0Y2hpbmcgdG8gc2VyaWVzLW9wdGlvbnMgKG1vZHVsZXMpLlxuICBhc3luYyByZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCBkYXRhLCBvcHRzKSB7XG4gICAgb3B0cy5wcm9wcy5wdXNoKC4uLnRoaXMuZ2V0TW9kdWxlUHJvcGVydHlEZWZpbml0aW9ucygpKTtcbiAgICBjb25zdCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0gYXdhaXQgZGF0YUNvbnRyb2xsZXIucmVxdWVzdCh0aGlzLmlkLCBkYXRhID8/IFtdLCBvcHRzKTtcbiAgICB0aGlzLmRhdGFNb2RlbCA9IGRhdGFNb2RlbDtcbiAgICB0aGlzLnByb2Nlc3NlZERhdGEgPSBwcm9jZXNzZWREYXRhO1xuICAgIHRoaXMuZGlzcGF0Y2goXCJkYXRhLXByb2Nlc3NlZFwiLCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9KTtcbiAgICByZXR1cm4geyBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEgfTtcbiAgfVxuICBpc1Byb2Nlc3NlZERhdGFBbmltYXRhYmxlKCkge1xuICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHRzID0gdGhpcy5wcm9jZXNzZWREYXRhPy5yZWR1Y2VkPy5hbmltYXRpb25WYWxpZGF0aW9uO1xuICAgIGlmICghdmFsaWRhdGlvblJlc3VsdHMpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB7IG9yZGVyZWRLZXlzLCB1bmlxdWVLZXlzIH0gPSB2YWxpZGF0aW9uUmVzdWx0cztcbiAgICByZXR1cm4gb3JkZXJlZEtleXMgJiYgdW5pcXVlS2V5cztcbiAgfVxuICBjaGVja1Byb2Nlc3NlZERhdGFBbmltYXRhYmxlKCkge1xuICAgIGlmICghdGhpcy5pc1Byb2Nlc3NlZERhdGFBbmltYXRhYmxlKCkpIHtcbiAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIH1cbiAgfVxuICBwaWNrRm9jdXMob3B0cykge1xuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5nZXROb2RlRGF0YSgpO1xuICAgIGlmIChub2RlRGF0YSA9PT0gdm9pZCAwIHx8IG5vZGVEYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3QgZGF0dW1JbmRleCA9IHRoaXMuY29tcHV0ZUZvY3VzRGF0dW1JbmRleChvcHRzLCBub2RlRGF0YSk7XG4gICAgaWYgKGRhdHVtSW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3QgeyBzaG93Rm9jdXNCb3ggfSA9IHRoaXM7XG4gICAgY29uc3QgZGF0dW0gPSBub2RlRGF0YVtkYXR1bUluZGV4XTtcbiAgICBjb25zdCBkZXJpdmVkT3B0cyA9IHsgLi4ub3B0cywgZGF0dW1JbmRleCB9O1xuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuY29tcHV0ZUZvY3VzQm91bmRzKGRlcml2ZWRPcHRzKTtcbiAgICBpZiAoYm91bmRzICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB7IGJvdW5kcywgc2hvd0ZvY3VzQm94LCBkYXR1bSwgZGF0dW1JbmRleCB9O1xuICAgIH1cbiAgfVxuICBjb21wdXRlRm9jdXNEYXR1bUluZGV4KG9wdHMsIG5vZGVEYXRhKSB7XG4gICAgY29uc3QgaXNEYXR1bUVuYWJsZWQgPSAoZGF0dW1JbmRleDIpID0+IHtcbiAgICAgIGNvbnN0IHsgbWlzc2luZyA9IGZhbHNlLCBlbmFibGVkID0gdHJ1ZSwgZm9jdXNhYmxlID0gdHJ1ZSB9ID0gbm9kZURhdGFbZGF0dW1JbmRleDJdO1xuICAgICAgcmV0dXJuICFtaXNzaW5nICYmIGVuYWJsZWQgJiYgZm9jdXNhYmxlO1xuICAgIH07XG4gICAgY29uc3Qgc2VhcmNoQmFja3dhcmQgPSAoZGF0dW1JbmRleDIpID0+IHtcbiAgICAgIHdoaWxlIChkYXR1bUluZGV4MiA+PSAwICYmICFpc0RhdHVtRW5hYmxlZChkYXR1bUluZGV4MikpIHtcbiAgICAgICAgZGF0dW1JbmRleDItLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXR1bUluZGV4MiA9PT0gLTEgPyB2b2lkIDAgOiBkYXR1bUluZGV4MjtcbiAgICB9O1xuICAgIGNvbnN0IHNlYXJjaEZvcndhcmQgPSAoZGF0dW1JbmRleDIpID0+IHtcbiAgICAgIHdoaWxlIChkYXR1bUluZGV4MiA8IG5vZGVEYXRhLmxlbmd0aCAmJiAhaXNEYXR1bUVuYWJsZWQoZGF0dW1JbmRleDIpKSB7XG4gICAgICAgIGRhdHVtSW5kZXgyKys7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0dW1JbmRleDIgPT09IG5vZGVEYXRhLmxlbmd0aCA/IHZvaWQgMCA6IGRhdHVtSW5kZXgyO1xuICAgIH07XG4gICAgbGV0IGRhdHVtSW5kZXg7XG4gICAgY29uc3QgY2xhbXBlZEluZGV4ID0gY2xhbXAoMCwgb3B0cy5kYXR1bUluZGV4LCBub2RlRGF0YS5sZW5ndGggLSAxKTtcbiAgICBpZiAob3B0cy5kYXR1bUluZGV4RGVsdGEgPCAwKSB7XG4gICAgICBkYXR1bUluZGV4ID0gc2VhcmNoQmFja3dhcmQoY2xhbXBlZEluZGV4KTtcbiAgICB9IGVsc2UgaWYgKG9wdHMuZGF0dW1JbmRleERlbHRhID4gMCkge1xuICAgICAgZGF0dW1JbmRleCA9IHNlYXJjaEZvcndhcmQoY2xhbXBlZEluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0dW1JbmRleCA/PyAoZGF0dW1JbmRleCA9IHNlYXJjaEZvcndhcmQoY2xhbXBlZEluZGV4KSk7XG4gICAgICBkYXR1bUluZGV4ID8/IChkYXR1bUluZGV4ID0gc2VhcmNoQmFja3dhcmQoY2xhbXBlZEluZGV4KSk7XG4gICAgfVxuICAgIGlmIChkYXR1bUluZGV4ID09PSB2b2lkIDApIHtcbiAgICAgIGlmIChvcHRzLmRhdHVtSW5kZXhEZWx0YSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9wdHMuZGF0dW1JbmRleCAtIG9wdHMuZGF0dW1JbmRleERlbHRhO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGF0dW1JbmRleDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXNQcm9wZXJ0aWVzLnRzXG52YXIgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5maWxsID0gXCJyZ2JhKDI1NSwyNTUsMjU1LCAwLjMzKVwiO1xuICAgIHRoaXMuc3Ryb2tlID0gYHJnYmEoMCwgMCwgMCwgMC40KWA7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwiZmlsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNJdGVtSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShMSU5FX0RBU0gsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwibGluZURhc2hPZmZzZXRcIiwgMik7XG52YXIgU2VyaWVzSGlnaGxpZ2h0U3R5bGUgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc0hpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNIaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwiZGltT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc0hpZ2hsaWdodFN0eWxlLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xudmFyIFRleHRIaWdobGlnaHRTdHlsZSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuY29sb3IgPSBcImJsYWNrXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFRleHRIaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwiY29sb3JcIiwgMik7XG52YXIgSGlnaGxpZ2h0UHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaWdobGlnaHRQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xudmFyIEhpZ2hsaWdodFN0eWxlID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5pdGVtID0gbmV3IFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZSgpO1xuICAgIHRoaXMuc2VyaWVzID0gbmV3IFNlcmllc0hpZ2hsaWdodFN0eWxlKCk7XG4gICAgdGhpcy50ZXh0ID0gbmV3IFRleHRIaWdobGlnaHRTdHlsZSgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcIml0ZW1cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBIaWdobGlnaHRTdHlsZS5wcm90b3R5cGUsIFwic2VyaWVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgSGlnaGxpZ2h0U3R5bGUucHJvdG90eXBlLCBcInRleHRcIiwgMik7XG52YXIgU2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5zaG93SW5MZWdlbmQgPSB0cnVlO1xuICAgIHRoaXMuY3Vyc29yID0gXCJkZWZhdWx0XCI7XG4gICAgdGhpcy5ub2RlQ2xpY2tSYW5nZSA9IFwiZXhhY3RcIjtcbiAgICB0aGlzLmhpZ2hsaWdodCA9IG5ldyBIaWdobGlnaHRQcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy5oaWdobGlnaHRTdHlsZSA9IG5ldyBIaWdobGlnaHRTdHlsZSgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNob3dJbkxlZ2VuZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImN1cnNvclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKElOVEVSQUNUSU9OX1JBTkdFKVxuXSwgU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibm9kZUNsaWNrUmFuZ2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJoaWdobGlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJoaWdobGlnaHRTdHlsZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9jYXJ0ZXNpYW5TZXJpZXMudHNcbnZhciBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fS0VZUyA9IHtcbiAgW1wieFwiIC8qIFggKi9dOiBbXCJ4S2V5XCJdLFxuICBbXCJ5XCIgLyogWSAqL106IFtcInlLZXlcIl1cbn07XG52YXIgREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX05BTUVTID0ge1xuICBbXCJ4XCIgLyogWCAqL106IFtcInhOYW1lXCJdLFxuICBbXCJ5XCIgLyogWSAqL106IFtcInlOYW1lXCJdXG59O1xudmFyIENhcnRlc2lhblNlcmllc05vZGVFdmVudCA9IGNsYXNzIGV4dGVuZHMgU2VyaWVzTm9kZUV2ZW50IHtcbiAgY29uc3RydWN0b3IodHlwZSwgbmF0aXZlRXZlbnQsIGRhdHVtLCBzZXJpZXMpIHtcbiAgICBzdXBlcih0eXBlLCBuYXRpdmVFdmVudCwgZGF0dW0sIHNlcmllcyk7XG4gICAgdGhpcy54S2V5ID0gc2VyaWVzLnByb3BlcnRpZXMueEtleTtcbiAgICB0aGlzLnlLZXkgPSBzZXJpZXMucHJvcGVydGllcy55S2V5O1xuICB9XG59O1xudmFyIENhcnRlc2lhblNlcmllc1Byb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIFNlcmllc1Byb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMucGlja091dHNpZGVWaXNpYmxlTWlub3JBeGlzID0gZmFsc2U7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIENhcnRlc2lhblNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxlZ2VuZEl0ZW1OYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwicGlja091dHNpZGVWaXNpYmxlTWlub3JBeGlzXCIsIDIpO1xudmFyIENhcnRlc2lhblNlcmllcyA9IGNsYXNzIGV4dGVuZHMgRGF0YU1vZGVsU2VyaWVzIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHBhdGhzUGVyU2VyaWVzID0gW1wicGF0aFwiXSxcbiAgICBoYXNNYXJrZXJzID0gZmFsc2UsXG4gICAgaGFzSGlnaGxpZ2h0ZWRMYWJlbHMgPSBmYWxzZSxcbiAgICBwYXRoc1pJbmRleFN1Yk9yZGVyT2Zmc2V0ID0gW10sXG4gICAgZGF0dW1TZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvbiA9IHRydWUsXG4gICAgbWFya2VyU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb24gPSB0cnVlLFxuICAgIGFuaW1hdGlvbkFsd2F5c1VwZGF0ZVNlbGVjdGlvbnMgPSBmYWxzZSxcbiAgICBhbmltYXRpb25SZXNldEZucyxcbiAgICBkaXJlY3Rpb25LZXlzLFxuICAgIGRpcmVjdGlvbk5hbWVzLFxuICAgIC4uLm90aGVyT3B0c1xuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgZGlyZWN0aW9uS2V5cyxcbiAgICAgIGRpcmVjdGlvbk5hbWVzLFxuICAgICAgY2FuSGF2ZUF4ZXM6IHRydWUsXG4gICAgICAuLi5vdGhlck9wdHNcbiAgICB9KTtcbiAgICB0aGlzLk5vZGVFdmVudCA9IENhcnRlc2lhblNlcmllc05vZGVFdmVudDtcbiAgICB0aGlzLmRhdGFOb2RlR3JvdXAgPSB0aGlzLmNvbnRlbnRHcm91cC5hcHBlbmRDaGlsZChcbiAgICAgIG5ldyBHcm91cCh7XG4gICAgICAgIG5hbWU6IGAke3RoaXMuaWR9LXNlcmllcy1kYXRhTm9kZXNgLFxuICAgICAgICB6SW5kZXg6IDQgLyogU0VSSUVTX0xBWUVSX1pJTkRFWCAqLyxcbiAgICAgICAgekluZGV4U3ViT3JkZXI6IHRoaXMuZ2V0R3JvdXBaSW5kZXhTdWJPcmRlcihcImRhdGFcIilcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLm1hcmtlckdyb3VwID0gdGhpcy5jb250ZW50R3JvdXAuYXBwZW5kQ2hpbGQoXG4gICAgICBuZXcgR3JvdXAoe1xuICAgICAgICBuYW1lOiBgJHt0aGlzLmlkfS1zZXJpZXMtbWFya2Vyc2AsXG4gICAgICAgIHpJbmRleDogNCAvKiBTRVJJRVNfTEFZRVJfWklOREVYICovLFxuICAgICAgICB6SW5kZXhTdWJPcmRlcjogdGhpcy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwibWFya2VyXCIpXG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5sYWJlbEdyb3VwID0gdGhpcy5jb250ZW50R3JvdXAuYXBwZW5kQ2hpbGQoXG4gICAgICBuZXcgR3JvdXAoe1xuICAgICAgICBuYW1lOiBgJHt0aGlzLmlkfS1zZXJpZXMtbGFiZWxzYCxcbiAgICAgICAgekluZGV4OiA4IC8qIFNFUklFU19MQUJFTF9aSU5ERVggKi8sXG4gICAgICAgIHpJbmRleFN1Yk9yZGVyOiB0aGlzLmdldEdyb3VwWkluZGV4U3ViT3JkZXIoXCJsYWJlbHNcIilcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLmxhYmVsU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdCh0aGlzLmxhYmVsR3JvdXAsIFRleHQpO1xuICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMuaGlnaGxpZ2h0Tm9kZSxcbiAgICAgICgpID0+IHRoaXMub3B0cy5oYXNNYXJrZXJzID8gdGhpcy5tYXJrZXJGYWN0b3J5KCkgOiB0aGlzLm5vZGVGYWN0b3J5KClcbiAgICApO1xuICAgIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRoaXMuaGlnaGxpZ2h0TGFiZWwsIFRleHQpO1xuICAgIHRoaXMuYW5ub3RhdGlvblNlbGVjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMubWluUmVjdHNDYWNoZSA9IHtcbiAgICAgIGRpcnR5Tm9kZURhdGE6IHRydWVcbiAgICB9O1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUoKTtcbiAgICBpZiAoIWRpcmVjdGlvbktleXMgfHwgIWRpcmVjdGlvbk5hbWVzKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gaW5pdGlhbGlzZSBzZXJpZXMgdHlwZSAke3RoaXMudHlwZX1gKTtcbiAgICB0aGlzLm9wdHMgPSB7XG4gICAgICBwYXRoc1BlclNlcmllcyxcbiAgICAgIGhhc01hcmtlcnMsXG4gICAgICBoYXNIaWdobGlnaHRlZExhYmVscyxcbiAgICAgIHBhdGhzWkluZGV4U3ViT3JkZXJPZmZzZXQsXG4gICAgICBkaXJlY3Rpb25LZXlzLFxuICAgICAgZGlyZWN0aW9uTmFtZXMsXG4gICAgICBhbmltYXRpb25SZXNldEZucyxcbiAgICAgIGFuaW1hdGlvbkFsd2F5c1VwZGF0ZVNlbGVjdGlvbnMsXG4gICAgICBkYXR1bVNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uLFxuICAgICAgbWFya2VyU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb25cbiAgICB9O1xuICAgIHRoaXMucGF0aHMgPSBbXTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGF0aHNQZXJTZXJpZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB0aGlzLnBhdGhzW2luZGV4XSA9IG5ldyBQYXRoKHsgbmFtZTogYCR7dGhpcy5pZH0tJHtwYXRoc1BlclNlcmllc1tpbmRleF19YCB9KTtcbiAgICAgIHRoaXMucGF0aHNbaW5kZXhdLnpJbmRleCA9IDQgLyogU0VSSUVTX0xBWUVSX1pJTkRFWCAqLztcbiAgICAgIHRoaXMucGF0aHNbaW5kZXhdLnpJbmRleFN1Yk9yZGVyID0gdGhpcy5nZXRHcm91cFpJbmRleFN1Yk9yZGVyKFwicGF0aHNcIiwgaW5kZXgpO1xuICAgICAgdGhpcy5jb250ZW50R3JvdXAuYXBwZW5kQ2hpbGQodGhpcy5wYXRoc1tpbmRleF0pO1xuICAgIH1cbiAgICB0aGlzLmRhdHVtU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMuZGF0YU5vZGVHcm91cCxcbiAgICAgICgpID0+IHRoaXMubm9kZUZhY3RvcnkoKSxcbiAgICAgIGRhdHVtU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb25cbiAgICApO1xuICAgIHRoaXMubWFya2VyU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMubWFya2VyR3JvdXAsXG4gICAgICAoKSA9PiB0aGlzLm1hcmtlckZhY3RvcnkoKSxcbiAgICAgIG1hcmtlclNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uXG4gICAgKTtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gbmV3IFN0YXRlTWFjaGluZShcbiAgICAgIFwiZW1wdHlcIixcbiAgICAgIHtcbiAgICAgICAgZW1wdHk6IHtcbiAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJyZWFkeVwiLFxuICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlRW1wdHlVcGRhdGVSZWFkeShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCIsXG4gICAgICAgICAgZGlzYWJsZTogXCJkaXNhYmxlZFwiXG4gICAgICAgIH0sXG4gICAgICAgIHJlYWR5OiB7XG4gICAgICAgICAgdXBkYXRlRGF0YTogXCJ3YWl0aW5nXCIsXG4gICAgICAgICAgY2xlYXI6IFwiY2xlYXJpbmdcIixcbiAgICAgICAgICBoaWdobGlnaHQ6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeUhpZ2hsaWdodChkYXRhKSxcbiAgICAgICAgICBoaWdobGlnaHRNYXJrZXJzOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlUmVhZHlIaWdobGlnaHRNYXJrZXJzKGRhdGEpLFxuICAgICAgICAgIHJlc2l6ZTogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVJlYWR5UmVzaXplKGRhdGEpLFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgc2tpcDogXCJyZWFkeVwiLFxuICAgICAgICAgIGRpc2FibGU6IFwiZGlzYWJsZWRcIlxuICAgICAgICB9LFxuICAgICAgICB3YWl0aW5nOiB7XG4gICAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwicmVhZHlcIixcbiAgICAgICAgICAgIGFjdGlvbjogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCIsXG4gICAgICAgICAgZGlzYWJsZTogXCJkaXNhYmxlZFwiXG4gICAgICAgIH0sXG4gICAgICAgIGRpc2FibGVkOiB7XG4gICAgICAgICAgdXBkYXRlOiAoZGF0YSkgPT4gdGhpcy5yZXNldEFsbEFuaW1hdGlvbihkYXRhKSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiXG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFyaW5nOiB7XG4gICAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICAgIGFjdGlvbjogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZUNsZWFyaW5nVXBkYXRlRW1wdHkoZGF0YSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgc2tpcDogXCJyZWFkeVwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAoKSA9PiB0aGlzLmNoZWNrUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKVxuICAgICk7XG4gIH1cbiAgZ2V0IGNvbnRleHROb2RlRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGV4dE5vZGVEYXRhO1xuICB9XG4gIGdldE5vZGVEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHROb2RlRGF0YT8ubm9kZURhdGE7XG4gIH1cbiAgcmVzZXRBbmltYXRpb24ocGhhc2UpIHtcbiAgICBpZiAocGhhc2UgPT09IFwiaW5pdGlhbFwiKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJyZXNldFwiKTtcbiAgICB9IGVsc2UgaWYgKHBoYXNlID09PSBcInJlYWR5XCIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInNraXBcIik7XG4gICAgfSBlbHNlIGlmIChwaGFzZSA9PT0gXCJkaXNhYmxlZFwiKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJkaXNhYmxlXCIpO1xuICAgIH1cbiAgfVxuICBhZGRDaGFydEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgdGhpcy5jdHguY2hhcnRFdmVudE1hbmFnZXIuYWRkTGlzdGVuZXIoXCJsZWdlbmQtaXRlbS1jbGlja1wiLCAoZXZlbnQpID0+IHRoaXMub25MZWdlbmRJdGVtQ2xpY2soZXZlbnQpKSxcbiAgICAgIHRoaXMuY3R4LmNoYXJ0RXZlbnRNYW5hZ2VyLmFkZExpc3RlbmVyKFxuICAgICAgICBcImxlZ2VuZC1pdGVtLWRvdWJsZS1jbGlja1wiLFxuICAgICAgICAoZXZlbnQpID0+IHRoaXMub25MZWdlbmRJdGVtRG91YmxlQ2xpY2soZXZlbnQpXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLl9jb250ZXh0Tm9kZURhdGEgPSB2b2lkIDA7XG4gIH1cbiAgYXN5bmMgdXBkYXRlKHsgc2VyaWVzUmVjdCB9KSB7XG4gICAgY29uc3QgeyB2aXNpYmxlLCBfY29udGV4dE5vZGVEYXRhOiBwcmV2aW91c0NvbnRleHREYXRhIH0gPSB0aGlzO1xuICAgIGNvbnN0IHNlcmllcyA9IHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXI/LmdldEFjdGl2ZUhpZ2hsaWdodCgpPy5zZXJpZXM7XG4gICAgY29uc3Qgc2VyaWVzSGlnaGxpZ2h0ZWQgPSBzZXJpZXMgPT09IHRoaXM7XG4gICAgY29uc3QgcmVzaXplID0gdGhpcy5jaGVja1Jlc2l6ZShzZXJpZXNSZWN0KTtcbiAgICBjb25zdCBoaWdobGlnaHRJdGVtcyA9IGF3YWl0IHRoaXMudXBkYXRlSGlnaGxpZ2h0U2VsZWN0aW9uKHNlcmllc0hpZ2hsaWdodGVkKTtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZVNlbGVjdGlvbnModmlzaWJsZSk7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVOb2RlcyhoaWdobGlnaHRJdGVtcywgc2VyaWVzSGlnaGxpZ2h0ZWQsIHZpc2libGUpO1xuICAgIGNvbnN0IGFuaW1hdGlvbkRhdGEgPSB0aGlzLmdldEFuaW1hdGlvbkRhdGEoc2VyaWVzUmVjdCwgcHJldmlvdXNDb250ZXh0RGF0YSk7XG4gICAgaWYgKCFhbmltYXRpb25EYXRhKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInJlc2l6ZVwiLCBhbmltYXRpb25EYXRhKTtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlXCIsIGFuaW1hdGlvbkRhdGEpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVNlbGVjdGlvbnMoYW55U2VyaWVzSXRlbUVuYWJsZWQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYW5pbWF0aW9uU2tpcFVwZGF0ZSA9ICF0aGlzLm9wdHMuYW5pbWF0aW9uQWx3YXlzVXBkYXRlU2VsZWN0aW9ucyAmJiB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xuICAgIGlmICghYW55U2VyaWVzSXRlbUVuYWJsZWQgJiYgYW5pbWF0aW9uU2tpcFVwZGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMubm9kZURhdGFSZWZyZXNoICYmICF0aGlzLmlzUGF0aE9yU2VsZWN0aW9uRGlydHkoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5ub2RlRGF0YVJlZnJlc2gpIHtcbiAgICAgIHRoaXMubm9kZURhdGFSZWZyZXNoID0gZmFsc2U7XG4gICAgICB0aGlzLmRlYnVnKGBDYXJ0ZXNpYW5TZXJpZXMudXBkYXRlU2VsZWN0aW9ucygpIC0gY2FsbGluZyBjcmVhdGVOb2RlRGF0YSgpIGZvcmAsIHRoaXMuaWQpO1xuICAgICAgdGhpcy5tYXJrUXVhZHRyZWVEaXJ0eSgpO1xuICAgICAgdGhpcy5fY29udGV4dE5vZGVEYXRhID0gYXdhaXQgdGhpcy5jcmVhdGVOb2RlRGF0YSgpO1xuICAgICAgY29uc3QgYW5pbWF0aW9uVmFsaWQgPSB0aGlzLmlzUHJvY2Vzc2VkRGF0YUFuaW1hdGFibGUoKTtcbiAgICAgIGlmICh0aGlzLl9jb250ZXh0Tm9kZURhdGEpIHtcbiAgICAgICAgKF9hID0gdGhpcy5fY29udGV4dE5vZGVEYXRhKS5hbmltYXRpb25WYWxpZCA/PyAoX2EuYW5pbWF0aW9uVmFsaWQgPSBhbmltYXRpb25WYWxpZCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1pblJlY3RzQ2FjaGUuZGlydHlOb2RlRGF0YSA9IHRydWU7XG4gICAgICBjb25zdCB7IGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSB9ID0gdGhpcztcbiAgICAgIGlmIChkYXRhTW9kZWwgIT09IHZvaWQgMCAmJiBwcm9jZXNzZWREYXRhICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaChcImRhdGEtdXBkYXRlXCIsIHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBhd2FpdCB0aGlzLnVwZGF0ZVNlcmllc1NlbGVjdGlvbnMoKTtcbiAgfVxuICBhc3luYyB1cGRhdGVTZXJpZXNTZWxlY3Rpb25zKHNlcmllc0hpZ2hsaWdodGVkKSB7XG4gICAgY29uc3QgeyBkYXR1bVNlbGVjdGlvbiwgbGFiZWxTZWxlY3Rpb24sIG1hcmtlclNlbGVjdGlvbiwgcGF0aHMgfSA9IHRoaXM7XG4gICAgY29uc3QgY29udGV4dERhdGEgPSB0aGlzLl9jb250ZXh0Tm9kZURhdGE7XG4gICAgaWYgKCFjb250ZXh0RGF0YSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IG5vZGVEYXRhLCBsYWJlbERhdGEsIGl0ZW1JZCB9ID0gY29udGV4dERhdGE7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVQYXRocyh7IHNlcmllc0hpZ2hsaWdodGVkLCBpdGVtSWQsIGNvbnRleHREYXRhLCBwYXRocyB9KTtcbiAgICB0aGlzLmRhdHVtU2VsZWN0aW9uID0gYXdhaXQgdGhpcy51cGRhdGVEYXR1bVNlbGVjdGlvbih7IG5vZGVEYXRhLCBkYXR1bVNlbGVjdGlvbiB9KTtcbiAgICB0aGlzLmxhYmVsU2VsZWN0aW9uID0gYXdhaXQgdGhpcy51cGRhdGVMYWJlbFNlbGVjdGlvbih7IGxhYmVsRGF0YSwgbGFiZWxTZWxlY3Rpb24gfSk7XG4gICAgaWYgKHRoaXMub3B0cy5oYXNNYXJrZXJzKSB7XG4gICAgICB0aGlzLm1hcmtlclNlbGVjdGlvbiA9IGF3YWl0IHRoaXMudXBkYXRlTWFya2VyU2VsZWN0aW9uKHsgbm9kZURhdGEsIG1hcmtlclNlbGVjdGlvbiB9KTtcbiAgICB9XG4gIH1cbiAgbWFya2VyRmFjdG9yeSgpIHtcbiAgICBjb25zdCBNYXJrZXJTaGFwZSA9IGdldE1hcmtlcigpO1xuICAgIHJldHVybiBuZXcgTWFya2VyU2hhcGUoKTtcbiAgfVxuICBnZXRHcm91cFpJbmRleFN1Yk9yZGVyKHR5cGUsIHN1YkluZGV4ID0gMCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLmdldEdyb3VwWkluZGV4U3ViT3JkZXIodHlwZSwgc3ViSW5kZXgpO1xuICAgIGlmICh0eXBlID09PSBcInBhdGhzXCIpIHtcbiAgICAgIGNvbnN0IFtzdXBlckZuXSA9IHJlc3VsdDtcbiAgICAgIGNvbnN0IHBhdGhPZmZzZXQgPSB0aGlzLm9wdHMucGF0aHNaSW5kZXhTdWJPcmRlck9mZnNldFtzdWJJbmRleF0gPz8gMDtcbiAgICAgIHJlc3VsdFswXSA9IGlzRnVuY3Rpb24oc3VwZXJGbikgPyAoKSA9PiBOdW1iZXIoc3VwZXJGbigpKSArIHBhdGhPZmZzZXQgOiBOdW1iZXIoc3VwZXJGbikgKyBwYXRoT2Zmc2V0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIHVwZGF0ZU5vZGVzKGhpZ2hsaWdodGVkSXRlbXMsIHNlcmllc0hpZ2hsaWdodGVkLCBhbnlTZXJpZXNJdGVtRW5hYmxlZCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhpZ2hsaWdodFNlbGVjdGlvbixcbiAgICAgIGhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLFxuICAgICAgb3B0czogeyBoYXNNYXJrZXJzLCBoYXNIaWdobGlnaHRlZExhYmVscyB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgYW5pbWF0aW9uRW5hYmxlZCA9ICF0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xuICAgIGNvbnN0IHZpc2libGUgPSB0aGlzLnZpc2libGUgJiYgdGhpcy5fY29udGV4dE5vZGVEYXRhICE9IG51bGwgJiYgYW55U2VyaWVzSXRlbUVuYWJsZWQ7XG4gICAgdGhpcy5yb290R3JvdXAudmlzaWJsZSA9IGFuaW1hdGlvbkVuYWJsZWQgfHwgdmlzaWJsZTtcbiAgICB0aGlzLmNvbnRlbnRHcm91cC52aXNpYmxlID0gYW5pbWF0aW9uRW5hYmxlZCB8fCB2aXNpYmxlO1xuICAgIHRoaXMuaGlnaGxpZ2h0R3JvdXAudmlzaWJsZSA9IChhbmltYXRpb25FbmFibGVkIHx8IHZpc2libGUpICYmIHNlcmllc0hpZ2hsaWdodGVkO1xuICAgIGNvbnN0IG9wYWNpdHkgPSB0aGlzLmdldE9wYWNpdHkoKTtcbiAgICBpZiAoaGFzTWFya2Vycykge1xuICAgICAgYXdhaXQgdGhpcy51cGRhdGVNYXJrZXJOb2Rlcyh7XG4gICAgICAgIG1hcmtlclNlbGVjdGlvbjogaGlnaGxpZ2h0U2VsZWN0aW9uLFxuICAgICAgICBpc0hpZ2hsaWdodDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJoaWdobGlnaHRNYXJrZXJzXCIsIGhpZ2hsaWdodFNlbGVjdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlRGF0dW1Ob2Rlcyh7XG4gICAgICAgIGRhdHVtU2VsZWN0aW9uOiBoaWdobGlnaHRTZWxlY3Rpb24sXG4gICAgICAgIGlzSGlnaGxpZ2h0OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcImhpZ2hsaWdodFwiLCBoaWdobGlnaHRTZWxlY3Rpb24pO1xuICAgIH1cbiAgICBpZiAoaGFzSGlnaGxpZ2h0ZWRMYWJlbHMpIHtcbiAgICAgIGF3YWl0IHRoaXMudXBkYXRlTGFiZWxOb2Rlcyh7IGxhYmVsU2VsZWN0aW9uOiBoaWdobGlnaHRMYWJlbFNlbGVjdGlvbiB9KTtcbiAgICB9XG4gICAgY29uc3QgeyBkYXRhTm9kZUdyb3VwLCBtYXJrZXJHcm91cCwgZGF0dW1TZWxlY3Rpb24sIGxhYmVsU2VsZWN0aW9uLCBtYXJrZXJTZWxlY3Rpb24sIHBhdGhzLCBsYWJlbEdyb3VwIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgaXRlbUlkIH0gPSB0aGlzLmNvbnRleHROb2RlRGF0YSA/PyB7fTtcbiAgICBkYXRhTm9kZUdyb3VwLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgIGRhdGFOb2RlR3JvdXAudmlzaWJsZSA9IGFuaW1hdGlvbkVuYWJsZWQgfHwgdmlzaWJsZTtcbiAgICBsYWJlbEdyb3VwLnZpc2libGUgPSB2aXNpYmxlO1xuICAgIGlmIChoYXNNYXJrZXJzKSB7XG4gICAgICBtYXJrZXJHcm91cC5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgIG1hcmtlckdyb3VwLnpJbmRleCA9IGRhdGFOb2RlR3JvdXAuekluZGV4ID49IDQgLyogU0VSSUVTX0xBWUVSX1pJTkRFWCAqLyA/IGRhdGFOb2RlR3JvdXAuekluZGV4IDogZGF0YU5vZGVHcm91cC56SW5kZXggKyAxO1xuICAgICAgbWFya2VyR3JvdXAudmlzaWJsZSA9IHZpc2libGU7XG4gICAgfVxuICAgIGlmIChsYWJlbEdyb3VwKSB7XG4gICAgICBsYWJlbEdyb3VwLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnVwZGF0ZVBhdGhOb2Rlcyh7XG4gICAgICBzZXJpZXNIaWdobGlnaHRlZCxcbiAgICAgIGl0ZW1JZCxcbiAgICAgIHBhdGhzLFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHZpc2libGUsXG4gICAgICBhbmltYXRpb25FbmFibGVkXG4gICAgfSk7XG4gICAgaWYgKCFkYXRhTm9kZUdyb3VwLnZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy51cGRhdGVEYXR1bU5vZGVzKHsgZGF0dW1TZWxlY3Rpb24sIGhpZ2hsaWdodGVkSXRlbXMsIGlzSGlnaGxpZ2h0OiBmYWxzZSB9KTtcbiAgICBhd2FpdCB0aGlzLnVwZGF0ZUxhYmVsTm9kZXMoeyBsYWJlbFNlbGVjdGlvbiB9KTtcbiAgICBpZiAoaGFzTWFya2Vycykge1xuICAgICAgYXdhaXQgdGhpcy51cGRhdGVNYXJrZXJOb2Rlcyh7IG1hcmtlclNlbGVjdGlvbiwgaXNIaWdobGlnaHQ6IGZhbHNlIH0pO1xuICAgIH1cbiAgfVxuICBnZXRIaWdobGlnaHRMYWJlbERhdGEobGFiZWxEYXRhLCBoaWdobGlnaHRlZEl0ZW0pIHtcbiAgICBjb25zdCBsYWJlbEl0ZW1zID0gbGFiZWxEYXRhLmZpbHRlcihcbiAgICAgIChsZCkgPT4gbGQuZGF0dW0gPT09IGhpZ2hsaWdodGVkSXRlbS5kYXR1bSAmJiBsZC5pdGVtSWQgPT09IGhpZ2hsaWdodGVkSXRlbS5pdGVtSWRcbiAgICApO1xuICAgIHJldHVybiBsYWJlbEl0ZW1zLmxlbmd0aCA9PT0gMCA/IHZvaWQgMCA6IGxhYmVsSXRlbXM7XG4gIH1cbiAgZ2V0SGlnaGxpZ2h0RGF0YShfbm9kZURhdGEsIGhpZ2hsaWdodGVkSXRlbSkge1xuICAgIHJldHVybiBoaWdobGlnaHRlZEl0ZW0gPyBbaGlnaGxpZ2h0ZWRJdGVtXSA6IHZvaWQgMDtcbiAgfVxuICBhc3luYyB1cGRhdGVIaWdobGlnaHRTZWxlY3Rpb24oc2VyaWVzSGlnaGxpZ2h0ZWQpIHtcbiAgICBjb25zdCB7IGhpZ2hsaWdodFNlbGVjdGlvbiwgaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24sIF9jb250ZXh0Tm9kZURhdGE6IGNvbnRleHROb2RlRGF0YSB9ID0gdGhpcztcbiAgICBpZiAoIWNvbnRleHROb2RlRGF0YSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBoaWdobGlnaHRlZERhdHVtID0gdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlcj8uZ2V0QWN0aXZlSGlnaGxpZ2h0KCk7XG4gICAgY29uc3QgaXRlbSA9IHNlcmllc0hpZ2hsaWdodGVkICYmIGhpZ2hsaWdodGVkRGF0dW0/LmRhdHVtID8gaGlnaGxpZ2h0ZWREYXR1bSA6IHZvaWQgMDtcbiAgICBsZXQgbGFiZWxJdGVtcztcbiAgICBsZXQgaGlnaGxpZ2h0SXRlbXM7XG4gICAgaWYgKGl0ZW0gIT0gbnVsbCkge1xuICAgICAgY29uc3QgbGFiZWxzRW5hYmxlZCA9IHRoaXMuaXNMYWJlbEVuYWJsZWQoKTtcbiAgICAgIGNvbnN0IHsgbGFiZWxEYXRhLCBub2RlRGF0YSB9ID0gY29udGV4dE5vZGVEYXRhO1xuICAgICAgaGlnaGxpZ2h0SXRlbXMgPSB0aGlzLmdldEhpZ2hsaWdodERhdGEobm9kZURhdGEsIGl0ZW0pO1xuICAgICAgbGFiZWxJdGVtcyA9IGxhYmVsc0VuYWJsZWQgPyB0aGlzLmdldEhpZ2hsaWdodExhYmVsRGF0YShsYWJlbERhdGEsIGl0ZW0pIDogdm9pZCAwO1xuICAgIH1cbiAgICB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbiA9IGF3YWl0IHRoaXMudXBkYXRlSGlnaGxpZ2h0U2VsZWN0aW9uSXRlbSh7XG4gICAgICBpdGVtczogaGlnaGxpZ2h0SXRlbXMsXG4gICAgICBoaWdobGlnaHRTZWxlY3Rpb25cbiAgICB9KTtcbiAgICB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uID0gYXdhaXQgdGhpcy51cGRhdGVIaWdobGlnaHRTZWxlY3Rpb25MYWJlbCh7XG4gICAgICBpdGVtczogbGFiZWxJdGVtcyxcbiAgICAgIGhpZ2hsaWdodExhYmVsU2VsZWN0aW9uXG4gICAgfSk7XG4gICAgcmV0dXJuIGhpZ2hsaWdodEl0ZW1zO1xuICB9XG4gIG1hcmtRdWFkdHJlZURpcnR5KCkge1xuICAgIHRoaXMucXVhZHRyZWUgPSB2b2lkIDA7XG4gIH1cbiAgKmRhdHVtTm9kZXNJdGVyKCkge1xuICAgIGZvciAoY29uc3QgeyBub2RlIH0gb2YgdGhpcy5kYXR1bVNlbGVjdGlvbikge1xuICAgICAgaWYgKG5vZGUuZGF0dW0ubWlzc2luZyA9PT0gdHJ1ZSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB5aWVsZCBub2RlO1xuICAgIH1cbiAgfVxuICBnZXRRdWFkVHJlZSgpIHtcbiAgICBpZiAodGhpcy5xdWFkdHJlZSA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuY3R4LnNjZW5lLmNhbnZhcztcbiAgICAgIGNvbnN0IGNhbnZhc1JlY3QgPSBuZXcgQkJveCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHRoaXMucXVhZHRyZWUgPSBuZXcgUXVhZHRyZWVOZWFyZXN0KDEwMCwgMTAsIGNhbnZhc1JlY3QpO1xuICAgICAgdGhpcy5pbml0UXVhZFRyZWUodGhpcy5xdWFkdHJlZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnF1YWR0cmVlO1xuICB9XG4gIGluaXRRdWFkVHJlZShfcXVhZHRyZWUpIHtcbiAgfVxuICBwaWNrTm9kZUV4YWN0U2hhcGUocG9pbnQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBzdXBlci5waWNrTm9kZUV4YWN0U2hhcGUocG9pbnQpO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQ7XG4gICAgY29uc3Qge1xuICAgICAgb3B0czogeyBoYXNNYXJrZXJzIH1cbiAgICB9ID0gdGhpcztcbiAgICBsZXQgbWF0Y2g7XG4gICAgY29uc3QgeyBkYXRhTm9kZUdyb3VwLCBtYXJrZXJHcm91cCB9ID0gdGhpcztcbiAgICBtYXRjaCA9IGRhdGFOb2RlR3JvdXAucGlja05vZGUoeCwgeSk7XG4gICAgaWYgKCFtYXRjaCAmJiBoYXNNYXJrZXJzKSB7XG4gICAgICBtYXRjaCA9IG1hcmtlckdyb3VwPy5waWNrTm9kZSh4LCB5KTtcbiAgICB9XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmRhdHVtLm1pc3NpbmcgIT09IHRydWUpIHtcbiAgICAgIHJldHVybiB7IGRhdHVtOiBtYXRjaC5kYXR1bSwgZGlzdGFuY2U6IDAgfTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBtb2QyIG9mIHRoaXMubW9kdWxlTWFwLm1vZHVsZXMoKSkge1xuICAgICAgY29uc3QgeyBkYXR1bSB9ID0gbW9kMi5waWNrTm9kZUV4YWN0KHBvaW50KSA/PyB7fTtcbiAgICAgIGlmIChkYXR1bSA9PSBudWxsKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGlmIChkYXR1bT8ubWlzc2luZyA9PT0gdHJ1ZSlcbiAgICAgICAgY29udGludWU7XG4gICAgICByZXR1cm4geyBkYXR1bSwgZGlzdGFuY2U6IDAgfTtcbiAgICB9XG4gIH1cbiAgcGlja05vZGVDbG9zZXN0RGF0dW0ocG9pbnQpIHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50O1xuICAgIGNvbnN0IHsgYXhlcywgcm9vdEdyb3VwLCBfY29udGV4dE5vZGVEYXRhOiBjb250ZXh0Tm9kZURhdGEgfSA9IHRoaXM7XG4gICAgaWYgKCFjb250ZXh0Tm9kZURhdGEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeEF4aXMgPSBheGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBjb25zdCBoaXRQb2ludCA9IHJvb3RHcm91cC50cmFuc2Zvcm1Qb2ludCh4LCB5KTtcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICBsZXQgY2xvc2VzdERhdHVtO1xuICAgIGZvciAoY29uc3QgZGF0dW0gb2YgY29udGV4dE5vZGVEYXRhLm5vZGVEYXRhKSB7XG4gICAgICBjb25zdCB7IHBvaW50OiB7IHg6IGRhdHVtWCA9IE5hTiwgeTogZGF0dW1ZID0gTmFOIH0gPSB7fSB9ID0gZGF0dW07XG4gICAgICBpZiAoaXNOYU4oZGF0dW1YKSB8fCBpc05hTihkYXR1bVkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNJblJhbmdlID0geEF4aXM/LmluUmFuZ2UoZGF0dW1YKSAmJiB5QXhpcz8uaW5SYW5nZShkYXR1bVkpO1xuICAgICAgaWYgKCFpc0luUmFuZ2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBkaXN0YW5jZTMgPSBNYXRoLm1heCgoaGl0UG9pbnQueCAtIGRhdHVtWCkgKiogMiArIChoaXRQb2ludC55IC0gZGF0dW1ZKSAqKiAyLCAwKTtcbiAgICAgIGlmIChkaXN0YW5jZTMgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlMztcbiAgICAgICAgY2xvc2VzdERhdHVtID0gZGF0dW07XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgbW9kMiBvZiB0aGlzLm1vZHVsZU1hcC5tb2R1bGVzKCkpIHtcbiAgICAgIGNvbnN0IG1vZFBpY2sgPSBtb2QyLnBpY2tOb2RlTmVhcmVzdChwb2ludCk7XG4gICAgICBpZiAobW9kUGljayAhPT0gdm9pZCAwICYmIG1vZFBpY2suZGlzdGFuY2VTcXVhcmVkIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgbWluRGlzdGFuY2UgPSBtb2RQaWNrLmRpc3RhbmNlU3F1YXJlZDtcbiAgICAgICAgY2xvc2VzdERhdHVtID0gbW9kUGljay5kYXR1bTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjbG9zZXN0RGF0dW0pIHtcbiAgICAgIGNvbnN0IGRpc3RhbmNlMyA9IE1hdGgubWF4KE1hdGguc3FydChtaW5EaXN0YW5jZSkgLSAoY2xvc2VzdERhdHVtLnBvaW50Py5zaXplID8/IDApLCAwKTtcbiAgICAgIHJldHVybiB7IGRhdHVtOiBjbG9zZXN0RGF0dW0sIGRpc3RhbmNlOiBkaXN0YW5jZTMgfTtcbiAgICB9XG4gIH1cbiAgcGlja05vZGVNYWluQXhpc0ZpcnN0KHBvaW50LCByZXF1aXJlQ2F0ZWdvcnlBeGlzKSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBwb2ludDtcbiAgICBjb25zdCB7IGF4ZXMsIHJvb3RHcm91cCwgX2NvbnRleHROb2RlRGF0YTogY29udGV4dE5vZGVEYXRhIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcGlja091dHNpZGVWaXNpYmxlTWlub3JBeGlzIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgaWYgKCFjb250ZXh0Tm9kZURhdGEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeEF4aXMgPSBheGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBjb25zdCBkaXJlY3Rpb25zMiA9IFt4QXhpcywgeUF4aXNdLmZpbHRlcigoYSkgPT4gYSBpbnN0YW5jZW9mIENhdGVnb3J5QXhpcykubWFwKChhKSA9PiBhLmRpcmVjdGlvbik7XG4gICAgaWYgKHJlcXVpcmVDYXRlZ29yeUF4aXMgJiYgZGlyZWN0aW9uczIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IFttYWpvckRpcmVjdGlvbiA9IFwieFwiIC8qIFggKi9dID0gZGlyZWN0aW9uczI7XG4gICAgY29uc3QgaGl0UG9pbnQgPSByb290R3JvdXAudHJhbnNmb3JtUG9pbnQoeCwgeSk7XG4gICAgY29uc3QgaGl0UG9pbnRDb29yZHMgPSBbaGl0UG9pbnQueCwgaGl0UG9pbnQueV07XG4gICAgaWYgKG1ham9yRGlyZWN0aW9uICE9PSBcInhcIiAvKiBYICovKVxuICAgICAgaGl0UG9pbnRDb29yZHMucmV2ZXJzZSgpO1xuICAgIGNvbnN0IG1pbkRpc3RhbmNlID0gW0luZmluaXR5LCBJbmZpbml0eV07XG4gICAgbGV0IGNsb3Nlc3REYXR1bTtcbiAgICBmb3IgKGNvbnN0IGRhdHVtIG9mIGNvbnRleHROb2RlRGF0YS5ub2RlRGF0YSkge1xuICAgICAgY29uc3QgeyB4OiBkYXR1bVggPSBOYU4sIHk6IGRhdHVtWSA9IE5hTiB9ID0gZGF0dW0ucG9pbnQgPz8gZGF0dW0ubWlkUG9pbnQgPz8ge307XG4gICAgICBpZiAoaXNOYU4oZGF0dW1YKSB8fCBpc05hTihkYXR1bVkpIHx8IGRhdHVtLm1pc3NpbmcgPT09IHRydWUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCB2aXNpYmxlID0gW3hBeGlzPy5pblJhbmdlKGRhdHVtWCksIHlBeGlzPy5pblJhbmdlKGRhdHVtWSldO1xuICAgICAgaWYgKG1ham9yRGlyZWN0aW9uICE9PSBcInhcIiAvKiBYICovKVxuICAgICAgICB2aXNpYmxlLnJldmVyc2UoKTtcbiAgICAgIGlmICghdmlzaWJsZVswXSB8fCAhcGlja091dHNpZGVWaXNpYmxlTWlub3JBeGlzICYmICF2aXNpYmxlWzFdKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZGF0dW1Qb2ludCA9IFtkYXR1bVgsIGRhdHVtWV07XG4gICAgICBpZiAobWFqb3JEaXJlY3Rpb24gIT09IFwieFwiIC8qIFggKi8pXG4gICAgICAgIGRhdHVtUG9pbnQucmV2ZXJzZSgpO1xuICAgICAgbGV0IG5ld01pbkRpc3RhbmNlID0gdHJ1ZTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0dW1Qb2ludC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBkaXN0ID0gTWF0aC5hYnMoZGF0dW1Qb2ludFtpXSAtIGhpdFBvaW50Q29vcmRzW2ldKTtcbiAgICAgICAgaWYgKGRpc3QgPiBtaW5EaXN0YW5jZVtpXSkge1xuICAgICAgICAgIG5ld01pbkRpc3RhbmNlID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3QgPCBtaW5EaXN0YW5jZVtpXSkge1xuICAgICAgICAgIG1pbkRpc3RhbmNlW2ldID0gZGlzdDtcbiAgICAgICAgICBtaW5EaXN0YW5jZS5maWxsKEluZmluaXR5LCBpICsgMSwgbWluRGlzdGFuY2UubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5ld01pbkRpc3RhbmNlKSB7XG4gICAgICAgIGNsb3Nlc3REYXR1bSA9IGRhdHVtO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2xvc2VzdERhdHVtKSB7XG4gICAgICBsZXQgY2xvc2VzdERpc3RhbmNlU3F1YXJlZCA9IE1hdGgubWF4KFxuICAgICAgICBtaW5EaXN0YW5jZVswXSAqKiAyICsgbWluRGlzdGFuY2VbMV0gKiogMiAtIChjbG9zZXN0RGF0dW0ucG9pbnQ/LnNpemUgPz8gMCksXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBmb3IgKGNvbnN0IG1vZDIgb2YgdGhpcy5tb2R1bGVNYXAubW9kdWxlcygpKSB7XG4gICAgICAgIGNvbnN0IG1vZFBpY2sgPSBtb2QyLnBpY2tOb2RlTWFpbkF4aXNGaXJzdChwb2ludCk7XG4gICAgICAgIGlmIChtb2RQaWNrICE9PSB2b2lkIDAgJiYgbW9kUGljay5kaXN0YW5jZVNxdWFyZWQgPCBjbG9zZXN0RGlzdGFuY2VTcXVhcmVkKSB7XG4gICAgICAgICAgY2xvc2VzdERhdHVtID0gbW9kUGljay5kYXR1bTtcbiAgICAgICAgICBjbG9zZXN0RGlzdGFuY2VTcXVhcmVkID0gbW9kUGljay5kaXN0YW5jZVNxdWFyZWQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IGRhdHVtOiBjbG9zZXN0RGF0dW0sIGRpc3RhbmNlOiBNYXRoLnNxcnQoY2xvc2VzdERpc3RhbmNlU3F1YXJlZCkgfTtcbiAgICB9XG4gIH1cbiAgb25MZWdlbmRJdGVtQ2xpY2soZXZlbnQpIHtcbiAgICBjb25zdCB7IGxlZ2VuZEl0ZW1OYW1lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBlbmFibGVkLCBpdGVtSWQsIHNlcmllcyB9ID0gZXZlbnQ7XG4gICAgY29uc3QgbWF0Y2hlZExlZ2VuZEl0ZW1OYW1lID0gbGVnZW5kSXRlbU5hbWUgIT0gbnVsbCAmJiBsZWdlbmRJdGVtTmFtZSA9PT0gZXZlbnQubGVnZW5kSXRlbU5hbWU7XG4gICAgaWYgKHNlcmllcy5pZCA9PT0gdGhpcy5pZCB8fCBtYXRjaGVkTGVnZW5kSXRlbU5hbWUpIHtcbiAgICAgIHRoaXMudG9nZ2xlU2VyaWVzSXRlbShpdGVtSWQsIGVuYWJsZWQpO1xuICAgIH1cbiAgfVxuICBvbkxlZ2VuZEl0ZW1Eb3VibGVDbGljayhldmVudCkge1xuICAgIGNvbnN0IHsgZW5hYmxlZCwgaXRlbUlkLCBzZXJpZXMsIG51bVZpc2libGVJdGVtcyB9ID0gZXZlbnQ7XG4gICAgY29uc3QgeyBsZWdlbmRJdGVtTmFtZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IG1hdGNoZWRMZWdlbmRJdGVtTmFtZSA9IGxlZ2VuZEl0ZW1OYW1lICE9IG51bGwgJiYgbGVnZW5kSXRlbU5hbWUgPT09IGV2ZW50LmxlZ2VuZEl0ZW1OYW1lO1xuICAgIGlmIChzZXJpZXMuaWQgPT09IHRoaXMuaWQgfHwgbWF0Y2hlZExlZ2VuZEl0ZW1OYW1lKSB7XG4gICAgICB0aGlzLnRvZ2dsZVNlcmllc0l0ZW0oaXRlbUlkLCB0cnVlKTtcbiAgICB9IGVsc2UgaWYgKGVuYWJsZWQgJiYgbnVtVmlzaWJsZUl0ZW1zID09PSAxKSB7XG4gICAgICB0aGlzLnRvZ2dsZVNlcmllc0l0ZW0oaXRlbUlkLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50b2dnbGVTZXJpZXNJdGVtKGl0ZW1JZCwgZmFsc2UpO1xuICAgIH1cbiAgfVxuICBpc1BhdGhPclNlbGVjdGlvbkRpcnR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXRMYWJlbERhdGEoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHNob3VsZEZsaXBYWSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgbWluaW11bSBib3VuZGluZyBib3ggdGhhdCBjb250YWlucyBhbnkgYWRqYWNlbnQgdHdvIG5vZGVzLiBUaGUgYXhlcyBhcmUgdHJlYXRlZCBpbmRlcGVuZGVudGx5LCBzbyB0aGlzXG4gICAqIG1heSBub3QgcmVwcmVzZW50IHRoZSBzYW1lIHR3byBwb2ludHMgZm9yIGJvdGggZGlyZWN0aW9ucy4gVGhlIGRpbWVuc2lvbnMgcmVwcmVzZW50IHRoZSBncmVhdGVzdCBkaXN0YW5jZVxuICAgKiBiZXR3ZWVuIGFueSB0d28gYWRqYWNlbnQgbm9kZXMuXG4gICAqL1xuICBnZXRNaW5SZWN0cyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgeyBkaXJ0eU5vZGVEYXRhLCBzaXplQ2FjaGUsIG1pblJlY3QsIG1pblZpc2libGVSZWN0IH0gPSB0aGlzLm1pblJlY3RzQ2FjaGU7XG4gICAgY29uc3QgbmV3U2l6ZUNhY2hlID0gSlNPTi5zdHJpbmdpZnkoeyB3aWR0aCwgaGVpZ2h0IH0pO1xuICAgIGNvbnN0IGRpcnR5U2l6ZSA9IG5ld1NpemVDYWNoZSAhPT0gc2l6ZUNhY2hlO1xuICAgIGlmICghZGlydHlTaXplICYmICFkaXJ0eU5vZGVEYXRhICYmIG1pblJlY3QgJiYgbWluVmlzaWJsZVJlY3QpIHtcbiAgICAgIHJldHVybiB7IG1pblJlY3QsIG1pblZpc2libGVSZWN0IH07XG4gICAgfVxuICAgIGNvbnN0IHJlY3RzID0gdGhpcy5jb21wdXRlTWluUmVjdHMod2lkdGgsIGhlaWdodCk7XG4gICAgdGhpcy5taW5SZWN0c0NhY2hlID0ge1xuICAgICAgZGlydHlOb2RlRGF0YTogZmFsc2UsXG4gICAgICBzaXplQ2FjaGU6IG5ld1NpemVDYWNoZSxcbiAgICAgIG1pblJlY3Q6IHJlY3RzPy5taW5SZWN0LFxuICAgICAgbWluVmlzaWJsZVJlY3Q6IHJlY3RzPy5taW5WaXNpYmxlUmVjdFxuICAgIH07XG4gICAgcmV0dXJuIHJlY3RzO1xuICB9XG4gIGNvbXB1dGVNaW5SZWN0cyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2NvbnRleHROb2RlRGF0YTtcbiAgICBpZiAoIWNvbnRleHQ/Lm5vZGVEYXRhLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IG5vZGVEYXRhIH0gPSBjb250ZXh0O1xuICAgIGNvbnN0IG1pblJlY3RYcyA9IEFycmF5KG5vZGVEYXRhLmxlbmd0aCk7XG4gICAgY29uc3QgbWluUmVjdFlzID0gQXJyYXkobm9kZURhdGEubGVuZ3RoKTtcbiAgICBmb3IgKGNvbnN0IFtpLCB7IG1pZFBvaW50IH1dIG9mIG5vZGVEYXRhLmVudHJpZXMoKSkge1xuICAgICAgbWluUmVjdFhzW2ldID0gbWlkUG9pbnQ/LnggPz8gMDtcbiAgICAgIG1pblJlY3RZc1tpXSA9IG1pZFBvaW50Py55ID8/IDA7XG4gICAgfVxuICAgIG1pblJlY3RYcy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgbWluUmVjdFlzLnNvcnQoKGEsIGIpID0+IGEgLSBiKTtcbiAgICBsZXQgemVyb1gsIHdpZHRoWCwgemVyb1ksIGhlaWdodFk7XG4gICAgbGV0IG1heFdpZHRoID0gMDtcbiAgICBsZXQgbWF4SGVpZ2h0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG5vZGVEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobWluUmVjdFhzW2ldID49IDApXG4gICAgICAgIHplcm9YID8/ICh6ZXJvWCA9IGkpO1xuICAgICAgaWYgKG1pblJlY3RYc1tpXSA+IHdpZHRoKVxuICAgICAgICB3aWR0aFggPz8gKHdpZHRoWCA9IGkpO1xuICAgICAgaWYgKG1pblJlY3RZc1tpXSA+PSAwKVxuICAgICAgICB6ZXJvWSA/PyAoemVyb1kgPSBpKTtcbiAgICAgIGlmIChtaW5SZWN0WXNbaV0gPiBoZWlnaHQpXG4gICAgICAgIGhlaWdodFkgPz8gKGhlaWdodFkgPSBpKTtcbiAgICAgIG1heFdpZHRoID0gTWF0aC5tYXgobWF4V2lkdGgsIG1pblJlY3RYc1tpXSAtIG1pblJlY3RYc1tpIC0gMV0pO1xuICAgICAgbWF4SGVpZ2h0ID0gTWF0aC5tYXgobWF4SGVpZ2h0LCBtaW5SZWN0WXNbaV0gLSBtaW5SZWN0WXNbaSAtIDFdKTtcbiAgICB9XG4gICAgd2lkdGhYID8/ICh3aWR0aFggPSBub2RlRGF0YS5sZW5ndGgpO1xuICAgIGhlaWdodFkgPz8gKGhlaWdodFkgPSBub2RlRGF0YS5sZW5ndGgpO1xuICAgIGNvbnN0IG1pblZpc2libGVSZWN0WHMgPSB6ZXJvWCAhPSBudWxsICYmIHdpZHRoWCAhPSBudWxsID8gbWluUmVjdFhzLnNsaWNlKHplcm9YLCB3aWR0aFgpIDogW107XG4gICAgY29uc3QgbWluVmlzaWJsZVJlY3RZcyA9IHplcm9ZICE9IG51bGwgJiYgaGVpZ2h0WSAhPSBudWxsID8gbWluUmVjdFlzLnNsaWNlKHplcm9ZLCBoZWlnaHRZKSA6IFtdO1xuICAgIGxldCBtYXhWaXNpYmxlV2lkdGggPSAwO1xuICAgIGxldCBtYXhWaXNpYmxlSGVpZ2h0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IE1hdGgubWF4KG1pblZpc2libGVSZWN0WHMubGVuZ3RoLCBtaW5WaXNpYmxlUmVjdFlzLmxlbmd0aCk7IGkrKykge1xuICAgICAgY29uc3QgeDEgPSBtaW5WaXNpYmxlUmVjdFhzW2ldO1xuICAgICAgY29uc3QgeDIgPSBtaW5WaXNpYmxlUmVjdFhzW2kgLSAxXTtcbiAgICAgIGNvbnN0IHkxID0gbWluVmlzaWJsZVJlY3RZc1tpXTtcbiAgICAgIGNvbnN0IHkyID0gbWluVmlzaWJsZVJlY3RZc1tpIC0gMV07XG4gICAgICBpZiAoeDEgIT0gbnVsbCAmJiB4MiAhPSBudWxsKSB7XG4gICAgICAgIG1heFZpc2libGVXaWR0aCA9IE1hdGgubWF4KG1heFZpc2libGVXaWR0aCwgeDEgLSB4Mik7XG4gICAgICB9XG4gICAgICBpZiAoeTEgIT0gbnVsbCAmJiB5MiAhPSBudWxsKSB7XG4gICAgICAgIG1heFZpc2libGVIZWlnaHQgPSBNYXRoLm1heChtYXhWaXNpYmxlSGVpZ2h0LCB5MSAtIHkyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWluUmVjdCA9IG5ldyBCQm94KDAsIDAsIG1heFdpZHRoLCBtYXhIZWlnaHQpO1xuICAgIGNvbnN0IG1pblZpc2libGVSZWN0ID0gbmV3IEJCb3goMCwgMCwgbWF4VmlzaWJsZVdpZHRoLCBtYXhWaXNpYmxlSGVpZ2h0KTtcbiAgICByZXR1cm4geyBtaW5SZWN0LCBtaW5WaXNpYmxlUmVjdCB9O1xuICB9XG4gIHVwZGF0ZUhpZ2hsaWdodFNlbGVjdGlvbkl0ZW0ob3B0cykge1xuICAgIGNvbnN0IHtcbiAgICAgIG9wdHM6IHsgaGFzTWFya2VycyB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBpdGVtcywgaGlnaGxpZ2h0U2VsZWN0aW9uIH0gPSBvcHRzO1xuICAgIGNvbnN0IG5vZGVEYXRhID0gaXRlbXMgPz8gW107XG4gICAgaWYgKGhhc01hcmtlcnMpIHtcbiAgICAgIGNvbnN0IG1hcmtlclNlbGVjdGlvbiA9IGhpZ2hsaWdodFNlbGVjdGlvbjtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZU1hcmtlclNlbGVjdGlvbih7IG5vZGVEYXRhLCBtYXJrZXJTZWxlY3Rpb24gfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnVwZGF0ZURhdHVtU2VsZWN0aW9uKHtcbiAgICAgICAgbm9kZURhdGEsXG4gICAgICAgIGRhdHVtU2VsZWN0aW9uOiBoaWdobGlnaHRTZWxlY3Rpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICB1cGRhdGVIaWdobGlnaHRTZWxlY3Rpb25MYWJlbChvcHRzKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlTGFiZWxTZWxlY3Rpb24oe1xuICAgICAgbGFiZWxEYXRhOiBvcHRzLml0ZW1zID8/IFtdLFxuICAgICAgbGFiZWxTZWxlY3Rpb246IG9wdHMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb25cbiAgICB9KTtcbiAgfVxuICBhc3luYyB1cGRhdGVEYXR1bVNlbGVjdGlvbihvcHRzKSB7XG4gICAgcmV0dXJuIG9wdHMuZGF0dW1TZWxlY3Rpb247XG4gIH1cbiAgYXN5bmMgdXBkYXRlRGF0dW1Ob2Rlcyhfb3B0cykge1xuICB9XG4gIGFzeW5jIHVwZGF0ZU1hcmtlclNlbGVjdGlvbihvcHRzKSB7XG4gICAgcmV0dXJuIG9wdHMubWFya2VyU2VsZWN0aW9uO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU1hcmtlck5vZGVzKF9vcHRzKSB7XG4gIH1cbiAgYXN5bmMgdXBkYXRlUGF0aHMob3B0cykge1xuICAgIG9wdHMucGF0aHMuZm9yRWFjaCgocCkgPT4gcC52aXNpYmxlID0gZmFsc2UpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVBhdGhOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBwYXRocywgb3BhY2l0eSwgdmlzaWJsZSB9ID0gb3B0cztcbiAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcbiAgICAgIHBhdGgub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICBwYXRoLnZpc2libGUgPSB2aXNpYmxlO1xuICAgIH1cbiAgfVxuICByZXNldFBhdGhBbmltYXRpb24oZGF0YSkge1xuICAgIGNvbnN0IHsgcGF0aCB9ID0gdGhpcy5vcHRzPy5hbmltYXRpb25SZXNldEZucyA/PyB7fTtcbiAgICBpZiAocGF0aCkge1xuICAgICAgZGF0YS5wYXRocy5mb3JFYWNoKChwYXRocykgPT4ge1xuICAgICAgICByZXNldE1vdGlvbihbcGF0aHNdLCBwYXRoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXNldERhdHVtQW5pbWF0aW9uKGRhdGEpIHtcbiAgICBjb25zdCB7IGRhdHVtIH0gPSB0aGlzLm9wdHM/LmFuaW1hdGlvblJlc2V0Rm5zID8/IHt9O1xuICAgIGlmIChkYXR1bSkge1xuICAgICAgcmVzZXRNb3Rpb24oW2RhdGEuZGF0dW1TZWxlY3Rpb25dLCBkYXR1bSk7XG4gICAgfVxuICB9XG4gIHJlc2V0TGFiZWxBbmltYXRpb24oZGF0YSkge1xuICAgIGNvbnN0IHsgbGFiZWwgfSA9IHRoaXMub3B0cz8uYW5pbWF0aW9uUmVzZXRGbnMgPz8ge307XG4gICAgaWYgKGxhYmVsKSB7XG4gICAgICByZXNldE1vdGlvbihbZGF0YS5sYWJlbFNlbGVjdGlvbl0sIGxhYmVsKTtcbiAgICB9XG4gIH1cbiAgcmVzZXRNYXJrZXJBbmltYXRpb24oZGF0YSkge1xuICAgIGNvbnN0IHsgbWFya2VyIH0gPSB0aGlzLm9wdHM/LmFuaW1hdGlvblJlc2V0Rm5zID8/IHt9O1xuICAgIGlmIChtYXJrZXIgJiYgdGhpcy5vcHRzLmhhc01hcmtlcnMpIHtcbiAgICAgIHJlc2V0TW90aW9uKFtkYXRhLm1hcmtlclNlbGVjdGlvbl0sIG1hcmtlcik7XG4gICAgfVxuICB9XG4gIHJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpIHtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnN0b3BCeUFuaW1hdGlvbkdyb3VwSWQodGhpcy5pZCk7XG4gICAgdGhpcy5yZXNldFBhdGhBbmltYXRpb24oZGF0YSk7XG4gICAgdGhpcy5yZXNldERhdHVtQW5pbWF0aW9uKGRhdGEpO1xuICAgIHRoaXMucmVzZXRMYWJlbEFuaW1hdGlvbihkYXRhKTtcbiAgICB0aGlzLnJlc2V0TWFya2VyQW5pbWF0aW9uKGRhdGEpO1xuICAgIGlmIChkYXRhLmNvbnRleHREYXRhPy5hbmltYXRpb25WYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIH1cbiAgfVxuICBhbmltYXRlRW1wdHlVcGRhdGVSZWFkeShkYXRhKSB7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbihkYXRhKTtcbiAgfVxuICBhbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KGRhdGEpIHtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpO1xuICB9XG4gIGFuaW1hdGVSZWFkeUhpZ2hsaWdodChkYXRhKSB7XG4gICAgY29uc3QgeyBkYXR1bSB9ID0gdGhpcy5vcHRzPy5hbmltYXRpb25SZXNldEZucyA/PyB7fTtcbiAgICBpZiAoZGF0dW0pIHtcbiAgICAgIHJlc2V0TW90aW9uKFtkYXRhXSwgZGF0dW0pO1xuICAgIH1cbiAgfVxuICBhbmltYXRlUmVhZHlIaWdobGlnaHRNYXJrZXJzKGRhdGEpIHtcbiAgICBjb25zdCB7IG1hcmtlciB9ID0gdGhpcy5vcHRzPy5hbmltYXRpb25SZXNldEZucyA/PyB7fTtcbiAgICBpZiAobWFya2VyKSB7XG4gICAgICByZXNldE1vdGlvbihbZGF0YV0sIG1hcmtlcik7XG4gICAgfVxuICB9XG4gIGFuaW1hdGVSZWFkeVJlc2l6ZShkYXRhKSB7XG4gICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbihkYXRhKTtcbiAgfVxuICBhbmltYXRlQ2xlYXJpbmdVcGRhdGVFbXB0eShkYXRhKSB7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbihkYXRhKTtcbiAgfVxuICBhbmltYXRpb25UcmFuc2l0aW9uQ2xlYXIoKSB7XG4gICAgY29uc3QgYW5pbWF0aW9uRGF0YSA9IHRoaXMuZ2V0QW5pbWF0aW9uRGF0YSgpO1xuICAgIGlmICghYW5pbWF0aW9uRGF0YSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJjbGVhclwiLCBhbmltYXRpb25EYXRhKTtcbiAgfVxuICBnZXRBbmltYXRpb25EYXRhKHNlcmllc1JlY3QsIHByZXZpb3VzQ29udGV4dERhdGEpIHtcbiAgICBjb25zdCB7IF9jb250ZXh0Tm9kZURhdGE6IGNvbnRleHREYXRhIH0gPSB0aGlzO1xuICAgIGlmICghY29udGV4dERhdGEpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYW5pbWF0aW9uRGF0YSA9IHtcbiAgICAgIGRhdHVtU2VsZWN0aW9uOiB0aGlzLmRhdHVtU2VsZWN0aW9uLFxuICAgICAgbWFya2VyU2VsZWN0aW9uOiB0aGlzLm1hcmtlclNlbGVjdGlvbixcbiAgICAgIGxhYmVsU2VsZWN0aW9uOiB0aGlzLmxhYmVsU2VsZWN0aW9uLFxuICAgICAgYW5ub3RhdGlvblNlbGVjdGlvbnM6IFsuLi50aGlzLmFubm90YXRpb25TZWxlY3Rpb25zXSxcbiAgICAgIGNvbnRleHREYXRhLFxuICAgICAgcHJldmlvdXNDb250ZXh0RGF0YSxcbiAgICAgIHBhdGhzOiB0aGlzLnBhdGhzLFxuICAgICAgc2VyaWVzUmVjdFxuICAgIH07XG4gICAgcmV0dXJuIGFuaW1hdGlvbkRhdGE7XG4gIH1cbiAgY2FsY3VsYXRlU2NhbGluZygpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGRpcmVjdGlvbiBvZiBPYmplY3QudmFsdWVzKENoYXJ0QXhpc0RpcmVjdGlvbikpIHtcbiAgICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4ZXNbZGlyZWN0aW9uXTtcbiAgICAgIGlmICghYXhpcylcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoYXhpcy5zY2FsZSBpbnN0YW5jZW9mIExvZ1NjYWxlKSB7XG4gICAgICAgIGNvbnN0IHsgcmFuZ2U6IHJhbmdlMywgZG9tYWluIH0gPSBheGlzLnNjYWxlO1xuICAgICAgICByZXN1bHRbZGlyZWN0aW9uXSA9IHtcbiAgICAgICAgICB0eXBlOiBcImxvZ1wiLFxuICAgICAgICAgIGNvbnZlcnQ6IChkKSA9PiBheGlzLnNjYWxlLmNvbnZlcnQoZCksXG4gICAgICAgICAgZG9tYWluOiBbZG9tYWluWzBdLCBkb21haW5bMV1dLFxuICAgICAgICAgIHJhbmdlOiBbcmFuZ2UzWzBdLCByYW5nZTNbMV1dXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGF4aXMuc2NhbGUgaW5zdGFuY2VvZiBDb250aW51b3VzU2NhbGUpIHtcbiAgICAgICAgY29uc3QgeyByYW5nZTogcmFuZ2UzIH0gPSBheGlzLnNjYWxlO1xuICAgICAgICBjb25zdCBkb21haW4gPSBheGlzLnNjYWxlLmdldERvbWFpbigpO1xuICAgICAgICByZXN1bHRbZGlyZWN0aW9uXSA9IHtcbiAgICAgICAgICB0eXBlOiBcImNvbnRpbnVvdXNcIixcbiAgICAgICAgICBkb21haW46IFtkb21haW5bMF0sIGRvbWFpblsxXV0sXG4gICAgICAgICAgcmFuZ2U6IFtyYW5nZTNbMF0sIHJhbmdlM1sxXV1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoYXhpcy5zY2FsZSkge1xuICAgICAgICBjb25zdCB7IGRvbWFpbiB9ID0gYXhpcy5zY2FsZTtcbiAgICAgICAgcmVzdWx0W2RpcmVjdGlvbl0gPSB7XG4gICAgICAgICAgdHlwZTogXCJjYXRlZ29yeVwiLFxuICAgICAgICAgIGRvbWFpbixcbiAgICAgICAgICByYW5nZTogZG9tYWluLm1hcCgoZCkgPT4gYXhpcy5zY2FsZS5jb252ZXJ0KGQpKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jYXJ0ZXNpYW5DaGFydC50c1xudmFyIGRpcmVjdGlvbnMgPSBbXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIl07XG52YXIgQ2FydGVzaWFuQ2hhcnQgPSBjbGFzcyBleHRlbmRzIENoYXJ0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgcmVzb3VyY2VzKSB7XG4gICAgc3VwZXIob3B0aW9ucywgcmVzb3VyY2VzKTtcbiAgICAvKiogSW50ZWdyYXRlZCBDaGFydHMgZmVhdHVyZSBzdGF0ZSAtIG5vdCB1c2VkIGluIFN0YW5kYWxvbmUgQ2hhcnRzLiAqL1xuICAgIHRoaXMucGFpcmVkID0gdHJ1ZTtcbiAgICB0aGlzLmZpcnN0U2VyaWVzVHJhbnNsYXRpb24gPSB0cnVlO1xuICAgIHRoaXMuX2xhc3RDcm9zc0xpbmVJZHMgPSB2b2lkIDA7XG4gICAgdGhpcy5fbGFzdEF4aXNBcmVhV2lkdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLl9sYXN0Q2xpcFNlcmllcyA9IGZhbHNlO1xuICAgIHRoaXMuX2xhc3RWaXNpYmlsaXR5ID0ge1xuICAgICAgY3Jvc3NMaW5lczogdHJ1ZSxcbiAgICAgIHNlcmllczogdHJ1ZVxuICAgIH07XG4gIH1cbiAgb25BeGlzQ2hhbmdlKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIHN1cGVyLm9uQXhpc0NoYW5nZShuZXdWYWx1ZSwgb2xkVmFsdWUpO1xuICAgIHRoaXMuem9vbU1hbmFnZXIudXBkYXRlQXhlcyhuZXdWYWx1ZSk7XG4gIH1cbiAgZGVzdHJveVNlcmllcyhzZXJpZXMpIHtcbiAgICBzdXBlci5kZXN0cm95U2VyaWVzKHNlcmllcyk7XG4gICAgdGhpcy5maXJzdFNlcmllc1RyYW5zbGF0aW9uID0gdHJ1ZTtcbiAgfVxuICBnZXRDaGFydFR5cGUoKSB7XG4gICAgcmV0dXJuIFwiY2FydGVzaWFuXCI7XG4gIH1cbiAgYXN5bmMgcGVyZm9ybUxheW91dCgpIHtcbiAgICBjb25zdCBzaHJpbmtSZWN0ID0gYXdhaXQgc3VwZXIucGVyZm9ybUxheW91dCgpO1xuICAgIGNvbnN0IHsgZmlyc3RTZXJpZXNUcmFuc2xhdGlvbiwgc2VyaWVzUm9vdCwgYW5ub3RhdGlvblJvb3QsIGhpZ2hsaWdodFJvb3QgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBhbmltYXRpb25SZWN0LCBzZXJpZXNSZWN0LCB2aXNpYmlsaXR5LCBjbGlwU2VyaWVzIH0gPSB0aGlzLnVwZGF0ZUF4ZXMoc2hyaW5rUmVjdCk7XG4gICAgdGhpcy5zZXJpZXNSb290LnZpc2libGUgPSB2aXNpYmlsaXR5LnNlcmllcztcbiAgICB0aGlzLnNlcmllc1JlY3QgPSBzZXJpZXNSZWN0O1xuICAgIHRoaXMuYW5pbWF0aW9uUmVjdCA9IGFuaW1hdGlvblJlY3Q7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBzZXJpZXNSZWN0O1xuICAgIGlmIChmaXJzdFNlcmllc1RyYW5zbGF0aW9uKSB7XG4gICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFtzZXJpZXNSb290LCBhbm5vdGF0aW9uUm9vdCwgaGlnaGxpZ2h0Um9vdF0pIHtcbiAgICAgICAgZ3JvdXAudHJhbnNsYXRpb25YID0gTWF0aC5mbG9vcih4KTtcbiAgICAgICAgZ3JvdXAudHJhbnNsYXRpb25ZID0gTWF0aC5mbG9vcih5KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmlyc3RTZXJpZXNUcmFuc2xhdGlvbiA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IHRyYW5zbGF0aW9uWCwgdHJhbnNsYXRpb25ZIH0gPSBzZXJpZXNSb290O1xuICAgICAgc3RhdGljRnJvbVRvTW90aW9uKFxuICAgICAgICB0aGlzLmlkLFxuICAgICAgICBcInNlcmllc1JlY3RcIixcbiAgICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgICAgW3Nlcmllc1Jvb3QsIGhpZ2hsaWdodFJvb3QsIGFubm90YXRpb25Sb290XSxcbiAgICAgICAgeyB0cmFuc2xhdGlvblgsIHRyYW5zbGF0aW9uWSB9LFxuICAgICAgICB7IHRyYW5zbGF0aW9uWDogTWF0aC5mbG9vcih4KSwgdHJhbnNsYXRpb25ZOiBNYXRoLmZsb29yKHkpIH0sXG4gICAgICAgIHsgcGhhc2U6IFwidXBkYXRlXCIgfVxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWVzUGFkZGVkUmVjdCA9IHNlcmllc1JlY3QuY2xvbmUoKS5ncm93KHRoaXMuc2VyaWVzQXJlYS5wYWRkaW5nKTtcbiAgICBjb25zdCBjbGlwUmVjdCA9IHRoaXMuc2VyaWVzQXJlYS5jbGlwIHx8IGNsaXBTZXJpZXMgPyBzZXJpZXNQYWRkZWRSZWN0IDogdm9pZCAwO1xuICAgIHNlcmllc1Jvb3Quc2V0Q2xpcFJlY3RJbkdyb3VwQ29vcmRpbmF0ZVNwYWNlKGNsaXBSZWN0KTtcbiAgICBoaWdobGlnaHRSb290LnNldENsaXBSZWN0SW5Hcm91cENvb3JkaW5hdGVTcGFjZShjbGlwUmVjdCk7XG4gICAgYW5ub3RhdGlvblJvb3Quc2V0Q2xpcFJlY3RJbkdyb3VwQ29vcmRpbmF0ZVNwYWNlKGNsaXBSZWN0KTtcbiAgICB0aGlzLmN0eC5sYXlvdXRTZXJ2aWNlLmRpc3BhdGNoTGF5b3V0Q29tcGxldGUoe1xuICAgICAgdHlwZTogXCJsYXlvdXQtY29tcGxldGVcIixcbiAgICAgIGNoYXJ0OiB7IHdpZHRoOiB0aGlzLmN0eC5zY2VuZS53aWR0aCwgaGVpZ2h0OiB0aGlzLmN0eC5zY2VuZS5oZWlnaHQgfSxcbiAgICAgIGNsaXBTZXJpZXMsXG4gICAgICBzZXJpZXM6IHtcbiAgICAgICAgcmVjdDogc2VyaWVzUmVjdCxcbiAgICAgICAgcGFkZGVkUmVjdDogc2VyaWVzUGFkZGVkUmVjdCxcbiAgICAgICAgdmlzaWJsZTogdmlzaWJpbGl0eS5zZXJpZXMsXG4gICAgICAgIHNob3VsZEZsaXBYWTogdGhpcy5zaG91bGRGbGlwWFkoKVxuICAgICAgfSxcbiAgICAgIGF4ZXM6IHRoaXMuYXhlcy5tYXAoKGF4aXMpID0+IGF4aXMuZ2V0TGF5b3V0U3RhdGUoKSlcbiAgICB9KTtcbiAgICBjb25zdCBtb2R1bGVQcm9taXNlcyA9IHRoaXMubW9kdWxlc01hbmFnZXIubWFwTW9kdWxlcygobSkgPT4gbS5wZXJmb3JtQ2FydGVzaWFuTGF5b3V0Py4oeyBzZXJpZXNSZWN0IH0pKTtcbiAgICBhd2FpdCBQcm9taXNlLmFsbChtb2R1bGVQcm9taXNlcyk7XG4gICAgcmV0dXJuIHNocmlua1JlY3Q7XG4gIH1cbiAgdXBkYXRlQXhlcyhpbnB1dFNocmlua1JlY3QpIHtcbiAgICBjb25zdCBjcm9zc0xpbmVJZHMgPSB0aGlzLmF4ZXMuZmxhdE1hcCgoYXhpcykgPT4gYXhpcy5jcm9zc0xpbmVzID8/IFtdKS5tYXAoKGNyb3NzTGluZSkgPT4gY3Jvc3NMaW5lLmlkKTtcbiAgICBjb25zdCBheGVzVmFsaWQgPSB0aGlzLl9sYXN0Q3Jvc3NMaW5lSWRzICE9IG51bGwgJiYgdGhpcy5fbGFzdENyb3NzTGluZUlkcy5sZW5ndGggPT09IGNyb3NzTGluZUlkcy5sZW5ndGggJiYgdGhpcy5fbGFzdENyb3NzTGluZUlkcy5ldmVyeSgoaWQsIGluZGV4KSA9PiBjcm9zc0xpbmVJZHNbaW5kZXhdID09PSBpZCk7XG4gICAgbGV0IGF4aXNBcmVhV2lkdGhzO1xuICAgIGxldCBjbGlwU2VyaWVzO1xuICAgIGxldCB2aXNpYmlsaXR5O1xuICAgIGlmIChheGVzVmFsaWQpIHtcbiAgICAgIGF4aXNBcmVhV2lkdGhzID0gbmV3IE1hcCh0aGlzLl9sYXN0QXhpc0FyZWFXaWR0aHMuZW50cmllcygpKTtcbiAgICAgIGNsaXBTZXJpZXMgPSB0aGlzLl9sYXN0Q2xpcFNlcmllcztcbiAgICAgIHZpc2liaWxpdHkgPSB7IC4uLnRoaXMuX2xhc3RWaXNpYmlsaXR5IH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGF4aXNBcmVhV2lkdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGNsaXBTZXJpZXMgPSBmYWxzZTtcbiAgICAgIHZpc2liaWxpdHkgPSB7IGNyb3NzTGluZXM6IHRydWUsIHNlcmllczogdHJ1ZSB9O1xuICAgICAgdGhpcy5fbGFzdENyb3NzTGluZUlkcyA9IGNyb3NzTGluZUlkcztcbiAgICB9XG4gICAgY29uc3QgbGl2ZUF4aXNXaWR0aHMgPSBuZXcgU2V0KHRoaXMuYXhlcy5tYXAoKGEpID0+IGEucG9zaXRpb24pKTtcbiAgICBmb3IgKGNvbnN0IHBvc2l0aW9uIG9mIGF4aXNBcmVhV2lkdGhzLmtleXMoKSkge1xuICAgICAgaWYgKCFsaXZlQXhpc1dpZHRocy5oYXMocG9zaXRpb24pKSB7XG4gICAgICAgIGF4aXNBcmVhV2lkdGhzLmRlbGV0ZShwb3NpdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHN0YWJsZU91dHB1dHMgPSAob3RoZXJBeGlzV2lkdGhzLCBvdGhlckNsaXBTZXJpZXMsIG90aGVyVmlzaWJpbGl0eSkgPT4ge1xuICAgICAgaWYgKFsuLi5vdGhlckF4aXNXaWR0aHMua2V5cygpXS5zb21lKChrKSA9PiAhYXhpc0FyZWFXaWR0aHMuaGFzKGspKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAodmlzaWJpbGl0eS5jcm9zc0xpbmVzICE9PSBvdGhlclZpc2liaWxpdHkuY3Jvc3NMaW5lcyB8fCB2aXNpYmlsaXR5LnNlcmllcyAhPT0gb3RoZXJWaXNpYmlsaXR5LnNlcmllcyB8fCBjbGlwU2VyaWVzICE9PSBvdGhlckNsaXBTZXJpZXMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFsuLi5heGlzQXJlYVdpZHRocy5lbnRyaWVzKCldLmV2ZXJ5KChbcCwgd10pID0+IHtcbiAgICAgICAgY29uc3Qgb3RoZXJXID0gb3RoZXJBeGlzV2lkdGhzLmdldChwKTtcbiAgICAgICAgaWYgKHcgIT0gbnVsbCB8fCBvdGhlclcgIT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB3ID09PSBvdGhlclc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGNlaWxWYWx1ZXMgPSAobWFwKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtYXAuZW50cmllcygpKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiBNYXRoLmFicyh2YWx1ZSkgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgbWFwLnNldChrZXksIDApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSAhPSBudWxsID8gTWF0aC5jZWlsKHZhbHVlKSA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXA7XG4gICAgfTtcbiAgICBsZXQgbGFzdFBhc3NBeGlzQXJlYVdpZHRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgbGV0IGxhc3RQYXNzVmlzaWJpbGl0eSA9IHt9O1xuICAgIGxldCBsYXN0UGFzc0NsaXBTZXJpZXMgPSBmYWxzZTtcbiAgICBsZXQgc2VyaWVzUmVjdCA9IHRoaXMuc2VyaWVzUmVjdD8uY2xvbmUoKTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGxldCBwcmltYXJ5VGlja0NvdW50cyA9IHt9O1xuICAgIGRvIHtcbiAgICAgIGF4aXNBcmVhV2lkdGhzID0gbmV3IE1hcChsYXN0UGFzc0F4aXNBcmVhV2lkdGhzLmVudHJpZXMoKSk7XG4gICAgICBjbGlwU2VyaWVzID0gbGFzdFBhc3NDbGlwU2VyaWVzO1xuICAgICAgT2JqZWN0LmFzc2lnbih2aXNpYmlsaXR5LCBsYXN0UGFzc1Zpc2liaWxpdHkpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy51cGRhdGVBeGVzUGFzcyhheGlzQXJlYVdpZHRocywgaW5wdXRTaHJpbmtSZWN0LmNsb25lKCksIHNlcmllc1JlY3QpO1xuICAgICAgbGFzdFBhc3NBeGlzQXJlYVdpZHRocyA9IGNlaWxWYWx1ZXMocmVzdWx0LmF4aXNBcmVhV2lkdGhzKTtcbiAgICAgIGxhc3RQYXNzVmlzaWJpbGl0eSA9IHJlc3VsdC52aXNpYmlsaXR5O1xuICAgICAgbGFzdFBhc3NDbGlwU2VyaWVzID0gcmVzdWx0LmNsaXBTZXJpZXM7XG4gICAgICAoeyBzZXJpZXNSZWN0LCBwcmltYXJ5VGlja0NvdW50cyB9ID0gcmVzdWx0KTtcbiAgICAgIGlmIChjb3VudCsrID4gMTApIHtcbiAgICAgICAgTG9nZ2VyLndhcm4oXCJ1bmFibGUgdG8gZmluZCBzdGFibGUgYXhpcyBsYXlvdXQuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IHdoaWxlICghc3RhYmxlT3V0cHV0cyhsYXN0UGFzc0F4aXNBcmVhV2lkdGhzLCBsYXN0UGFzc0NsaXBTZXJpZXMsIGxhc3RQYXNzVmlzaWJpbGl0eSkpO1xuICAgIHRoaXMuYXhlcy5mb3JFYWNoKChheGlzKSA9PiB7XG4gICAgICBheGlzLnVwZGF0ZShwcmltYXJ5VGlja0NvdW50c1theGlzLmRpcmVjdGlvbl0pO1xuICAgIH0pO1xuICAgIGNvbnN0IGNsaXBSZWN0UGFkZGluZyA9IDU7XG4gICAgdGhpcy5heGVzLmZvckVhY2goKGF4aXMpID0+IHtcbiAgICAgIGF4aXMuc2V0Q3Jvc3NMaW5lc1Zpc2libGUodmlzaWJpbGl0eS5jcm9zc0xpbmVzKTtcbiAgICAgIGlmICghc2VyaWVzUmVjdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBheGlzLmNsaXBHcmlkKFxuICAgICAgICBzZXJpZXNSZWN0LngsXG4gICAgICAgIHNlcmllc1JlY3QueSxcbiAgICAgICAgc2VyaWVzUmVjdC53aWR0aCArIGNsaXBSZWN0UGFkZGluZyxcbiAgICAgICAgc2VyaWVzUmVjdC5oZWlnaHQgKyBjbGlwUmVjdFBhZGRpbmdcbiAgICAgICk7XG4gICAgICBzd2l0Y2ggKGF4aXMucG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSBcImxlZnRcIjpcbiAgICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgICAgYXhpcy5jbGlwVGlja0xpbmVzKFxuICAgICAgICAgICAgaW5wdXRTaHJpbmtSZWN0LngsXG4gICAgICAgICAgICBzZXJpZXNSZWN0LnksXG4gICAgICAgICAgICBpbnB1dFNocmlua1JlY3Qud2lkdGggKyBjbGlwUmVjdFBhZGRpbmcsXG4gICAgICAgICAgICBzZXJpZXNSZWN0LmhlaWdodCArIGNsaXBSZWN0UGFkZGluZ1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICAgIGF4aXMuY2xpcFRpY2tMaW5lcyhcbiAgICAgICAgICAgIHNlcmllc1JlY3QueCxcbiAgICAgICAgICAgIGlucHV0U2hyaW5rUmVjdC55LFxuICAgICAgICAgICAgc2VyaWVzUmVjdC53aWR0aCArIGNsaXBSZWN0UGFkZGluZyxcbiAgICAgICAgICAgIGlucHV0U2hyaW5rUmVjdC5oZWlnaHQgKyBjbGlwUmVjdFBhZGRpbmdcbiAgICAgICAgICApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuX2xhc3RBeGlzQXJlYVdpZHRocyA9IGF4aXNBcmVhV2lkdGhzO1xuICAgIHRoaXMuX2xhc3RWaXNpYmlsaXR5ID0gdmlzaWJpbGl0eTtcbiAgICB0aGlzLl9sYXN0Q2xpcFNlcmllcyA9IGNsaXBTZXJpZXM7XG4gICAgcmV0dXJuIHsgc2VyaWVzUmVjdCwgYW5pbWF0aW9uUmVjdDogaW5wdXRTaHJpbmtSZWN0LCB2aXNpYmlsaXR5LCBjbGlwU2VyaWVzIH07XG4gIH1cbiAgdXBkYXRlQXhlc1Bhc3MoYXhpc0FyZWFXaWR0aHMsIGJvdW5kcywgbGFzdFBhc3NTZXJpZXNSZWN0KSB7XG4gICAgY29uc3QgYXhpc1dpZHRocyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgYXhpc0dyb3VwcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgY29uc3QgdmlzaWJpbGl0eSA9IHtcbiAgICAgIHNlcmllczogdHJ1ZSxcbiAgICAgIGNyb3NzTGluZXM6IHRydWVcbiAgICB9O1xuICAgIGxldCBjbGlwU2VyaWVzID0gZmFsc2U7XG4gICAgY29uc3QgcHJpbWFyeVRpY2tDb3VudHMgPSB7fTtcbiAgICBjb25zdCBwYWRkZWRCb3VuZHMgPSB0aGlzLmFwcGx5U2VyaWVzUGFkZGluZyhib3VuZHMpO1xuICAgIGNvbnN0IGNyb3NzTGluZVBhZGRpbmcgPSBsYXN0UGFzc1Nlcmllc1JlY3QgPyB0aGlzLmJ1aWxkQ3Jvc3NMaW5lUGFkZGluZyhheGlzQXJlYVdpZHRocykgOiB7fTtcbiAgICBjb25zdCBheGlzQXJlYUJvdW5kID0gdGhpcy5idWlsZEF4aXNCb3VuZChwYWRkZWRCb3VuZHMsIGF4aXNBcmVhV2lkdGhzLCBjcm9zc0xpbmVQYWRkaW5nLCB2aXNpYmlsaXR5KTtcbiAgICBjb25zdCBzZXJpZXNSZWN0ID0gdGhpcy5idWlsZFNlcmllc1JlY3QoYXhpc0FyZWFCb3VuZCwgYXhpc0FyZWFXaWR0aHMpO1xuICAgIGZvciAoY29uc3QgYXhpcyBvZiB0aGlzLmF4ZXMpIHtcbiAgICAgIGNvbnN0IHsgcG9zaXRpb24gPSBcImxlZnRcIiB9ID0gYXhpcztcbiAgICAgIGNvbnN0IHsgY2xpcFNlcmllczogbmV3Q2xpcFNlcmllcywgYXhpc1RoaWNrbmVzcyB9ID0gdGhpcy5jYWxjdWxhdGVBeGlzRGltZW5zaW9ucyh7XG4gICAgICAgIGF4aXMsXG4gICAgICAgIHNlcmllc1JlY3QsXG4gICAgICAgIHBhZGRlZEJvdW5kcyxcbiAgICAgICAgcHJpbWFyeVRpY2tDb3VudHMsXG4gICAgICAgIGNsaXBTZXJpZXNcbiAgICAgIH0pO1xuICAgICAgYXhpc1dpZHRocy5zZXQoYXhpcy5pZCwgYXhpc1RoaWNrbmVzcyk7XG4gICAgICBpZiAoIWF4aXNHcm91cHMuaGFzKHBvc2l0aW9uKSlcbiAgICAgICAgYXhpc0dyb3Vwcy5zZXQocG9zaXRpb24sIFtdKTtcbiAgICAgIGF4aXNHcm91cHMuZ2V0KHBvc2l0aW9uKT8ucHVzaChheGlzKTtcbiAgICAgIGNsaXBTZXJpZXMgPSBjbGlwU2VyaWVzIHx8IG5ld0NsaXBTZXJpZXM7XG4gICAgfVxuICAgIGNvbnN0IG5ld0F4aXNBcmVhV2lkdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBjb25zdCBheGlzT2Zmc2V0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBbcG9zaXRpb24sIGF4ZXNdIG9mIGF4aXNHcm91cHMuZW50cmllcygpKSB7XG4gICAgICBuZXdBeGlzQXJlYVdpZHRocy5zZXQocG9zaXRpb24sIHRoaXMuY2FsY3VsYXRlQXhpc0FyZWEoYXhlcywgYXhpc1dpZHRocywgYXhpc09mZnNldHMpKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBbcG9zaXRpb24sIGF4ZXNdIG9mIGF4aXNHcm91cHMuZW50cmllcygpKSB7XG4gICAgICB0aGlzLnBvc2l0aW9uQXhlcyh7XG4gICAgICAgIGF4ZXMsXG4gICAgICAgIHBvc2l0aW9uLFxuICAgICAgICBheGlzV2lkdGhzLFxuICAgICAgICBheGlzT2Zmc2V0cyxcbiAgICAgICAgYXhpc0FyZWFXaWR0aHM6IG5ld0F4aXNBcmVhV2lkdGhzLFxuICAgICAgICBheGlzQm91bmQ6IGF4aXNBcmVhQm91bmQsXG4gICAgICAgIHNlcmllc1JlY3RcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4geyBjbGlwU2VyaWVzLCBzZXJpZXNSZWN0LCBheGlzQXJlYVdpZHRoczogbmV3QXhpc0FyZWFXaWR0aHMsIHZpc2liaWxpdHksIHByaW1hcnlUaWNrQ291bnRzIH07XG4gIH1cbiAgYnVpbGRDcm9zc0xpbmVQYWRkaW5nKGF4aXNBcmVhU2l6ZSkge1xuICAgIGNvbnN0IGNyb3NzTGluZVBhZGRpbmcgPSB7fTtcbiAgICB0aGlzLmF4ZXMuZm9yRWFjaCgoYXhpcykgPT4ge1xuICAgICAgYXhpcy5jcm9zc0xpbmVzPy5mb3JFYWNoKChjcm9zc0xpbmUpID0+IHtcbiAgICAgICAgY3Jvc3NMaW5lLmNhbGN1bGF0ZVBhZGRpbmc/Lihjcm9zc0xpbmVQYWRkaW5nKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGZvciAoY29uc3QgW3NpZGUsIHBhZGRpbmcgPSAwXSBvZiBPYmplY3QuZW50cmllcyhjcm9zc0xpbmVQYWRkaW5nKSkge1xuICAgICAgY3Jvc3NMaW5lUGFkZGluZ1tzaWRlXSA9IE1hdGgubWF4KHBhZGRpbmcgLSAoYXhpc0FyZWFTaXplLmdldChzaWRlKSA/PyAwKSwgMCk7XG4gICAgfVxuICAgIHJldHVybiBjcm9zc0xpbmVQYWRkaW5nO1xuICB9XG4gIGFwcGx5U2VyaWVzUGFkZGluZyhib3VuZHMpIHtcbiAgICBjb25zdCBwYWRkZWRSZWN0ID0gYm91bmRzLmNsb25lKCk7XG4gICAgY29uc3QgcmV2ZXJzZWRBeGVzID0gdGhpcy5heGVzLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgIGRpcmVjdGlvbnMuZm9yRWFjaCgoZGlyKSA9PiB7XG4gICAgICBjb25zdCBwYWRkaW5nID0gdGhpcy5zZXJpZXNBcmVhLnBhZGRpbmdbZGlyXTtcbiAgICAgIGNvbnN0IGF4aXMgPSByZXZlcnNlZEF4ZXMuZmluZCgoYSkgPT4gYS5wb3NpdGlvbiA9PT0gZGlyKTtcbiAgICAgIGlmIChheGlzKSB7XG4gICAgICAgIGF4aXMuc2VyaWVzQXJlYVBhZGRpbmcgPSBwYWRkaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFkZGVkUmVjdC5zaHJpbmsocGFkZGluZywgZGlyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcGFkZGVkUmVjdDtcbiAgfVxuICBidWlsZEF4aXNCb3VuZChib3VuZHMsIGF4aXNBcmVhV2lkdGhzLCBjcm9zc0xpbmVQYWRkaW5nLCB2aXNpYmlsaXR5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYm91bmRzLmNsb25lKCk7XG4gICAgY29uc3QgeyB0b3AgPSAwLCByaWdodCA9IDAsIGJvdHRvbSA9IDAsIGxlZnQgPSAwIH0gPSBjcm9zc0xpbmVQYWRkaW5nO1xuICAgIGNvbnN0IGhvcml6b250YWxQYWRkaW5nID0gbGVmdCArIHJpZ2h0O1xuICAgIGNvbnN0IHZlcnRpY2FsUGFkZGluZyA9IHRvcCArIGJvdHRvbTtcbiAgICBjb25zdCB0b3RhbFdpZHRoID0gKGF4aXNBcmVhV2lkdGhzLmdldChcImxlZnRcIikgPz8gMCkgKyAoYXhpc0FyZWFXaWR0aHMuZ2V0KFwicmlnaHRcIikgPz8gMCkgKyBob3Jpem9udGFsUGFkZGluZztcbiAgICBjb25zdCB0b3RhbEhlaWdodCA9IChheGlzQXJlYVdpZHRocy5nZXQoXCJ0b3BcIikgPz8gMCkgKyAoYXhpc0FyZWFXaWR0aHMuZ2V0KFwiYm90dG9tXCIpID8/IDApICsgdmVydGljYWxQYWRkaW5nO1xuICAgIGlmIChyZXN1bHQud2lkdGggPD0gdG90YWxXaWR0aCB8fCByZXN1bHQuaGVpZ2h0IDw9IHRvdGFsSGVpZ2h0KSB7XG4gICAgICB2aXNpYmlsaXR5LmNyb3NzTGluZXMgPSBmYWxzZTtcbiAgICAgIHZpc2liaWxpdHkuc2VyaWVzID0gZmFsc2U7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXN1bHQueCArPSBsZWZ0O1xuICAgIHJlc3VsdC55ICs9IHRvcDtcbiAgICByZXN1bHQud2lkdGggLT0gaG9yaXpvbnRhbFBhZGRpbmc7XG4gICAgcmVzdWx0LmhlaWdodCAtPSB2ZXJ0aWNhbFBhZGRpbmc7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBidWlsZFNlcmllc1JlY3QoYXhpc0JvdW5kLCBheGlzQXJlYVdpZHRocykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF4aXNCb3VuZC5jbG9uZSgpO1xuICAgIHJlc3VsdC54ICs9IGF4aXNBcmVhV2lkdGhzLmdldChcImxlZnRcIikgPz8gMDtcbiAgICByZXN1bHQueSArPSBheGlzQXJlYVdpZHRocy5nZXQoXCJ0b3BcIikgPz8gMDtcbiAgICByZXN1bHQud2lkdGggLT0gKGF4aXNBcmVhV2lkdGhzLmdldChcImxlZnRcIikgPz8gMCkgKyAoYXhpc0FyZWFXaWR0aHMuZ2V0KFwicmlnaHRcIikgPz8gMCk7XG4gICAgcmVzdWx0LmhlaWdodCAtPSAoYXhpc0FyZWFXaWR0aHMuZ2V0KFwidG9wXCIpID8/IDApICsgKGF4aXNBcmVhV2lkdGhzLmdldChcImJvdHRvbVwiKSA/PyAwKTtcbiAgICByZXN1bHQud2lkdGggPSBNYXRoLm1heCgwLCByZXN1bHQud2lkdGgpO1xuICAgIHJlc3VsdC5oZWlnaHQgPSBNYXRoLm1heCgwLCByZXN1bHQuaGVpZ2h0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNsYW1wVG9PdXRzaWRlU2VyaWVzUmVjdChzZXJpZXNSZWN0LCB2YWx1ZSwgZGltZW5zaW9uLCBkaXJlY3Rpb24pIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHNlcmllc1JlY3Q7XG4gICAgY29uc3QgY2xhbXBCb3VuZHMgPSBbeCwgeSwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0XTtcbiAgICBjb25zdCBjb21wYXJlVG8gPSBjbGFtcEJvdW5kc1soZGltZW5zaW9uID09PSBcInhcIiA/IDAgOiAxKSArIChkaXJlY3Rpb24gPT09IDEgPyAwIDogMildO1xuICAgIGNvbnN0IGNsYW1wRm4gPSBkaXJlY3Rpb24gPT09IDEgPyBNYXRoLm1pbiA6IE1hdGgubWF4O1xuICAgIHJldHVybiBjbGFtcEZuKHZhbHVlLCBjb21wYXJlVG8pO1xuICB9XG4gIGNhbGN1bGF0ZUF4aXNEaW1lbnNpb25zKG9wdHMpIHtcbiAgICBjb25zdCB7IGF4aXMsIHNlcmllc1JlY3QsIHBhZGRlZEJvdW5kcywgcHJpbWFyeVRpY2tDb3VudHMgfSA9IG9wdHM7XG4gICAgbGV0IHsgY2xpcFNlcmllcyB9ID0gb3B0cztcbiAgICBjb25zdCB7IHBvc2l0aW9uID0gXCJsZWZ0XCIsIGRpcmVjdGlvbiB9ID0gYXhpcztcbiAgICB0aGlzLnNpemVBeGlzKGF4aXMsIHNlcmllc1JlY3QsIHBvc2l0aW9uKTtcbiAgICBsZXQgcHJpbWFyeVRpY2tDb3VudCA9IGF4aXMubmljZSA/IHByaW1hcnlUaWNrQ291bnRzW2RpcmVjdGlvbl0gOiB2b2lkIDA7XG4gICAgY29uc3QgaXNWZXJ0aWNhbCA9IGRpcmVjdGlvbiA9PT0gXCJ5XCIgLyogWSAqLztcbiAgICBjb25zdCBwYWRkZWRCb3VuZHNDb2VmZmljaWVudCA9IDAuMztcbiAgICBpZiAoYXhpcy50aGlja25lc3MpIHtcbiAgICAgIGF4aXMubWF4VGhpY2tuZXNzID0gYXhpcy50aGlja25lc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF4aXMubWF4VGhpY2tuZXNzID0gKGlzVmVydGljYWwgPyBwYWRkZWRCb3VuZHMud2lkdGggOiBwYWRkZWRCb3VuZHMuaGVpZ2h0KSAqIHBhZGRlZEJvdW5kc0NvZWZmaWNpZW50O1xuICAgIH1cbiAgICBjb25zdCBsYXlvdXQgPSBheGlzLmNhbGN1bGF0ZUxheW91dChwcmltYXJ5VGlja0NvdW50KTtcbiAgICBwcmltYXJ5VGlja0NvdW50ID0gbGF5b3V0LnByaW1hcnlUaWNrQ291bnQ7XG4gICAgcHJpbWFyeVRpY2tDb3VudHNbZGlyZWN0aW9uXSA/PyAocHJpbWFyeVRpY2tDb3VudHNbZGlyZWN0aW9uXSA9IHByaW1hcnlUaWNrQ291bnQpO1xuICAgIGNsaXBTZXJpZXMgfHwgKGNsaXBTZXJpZXMgPSBheGlzLmRhdGFEb21haW4uY2xpcHBlZCB8fCBheGlzLnZpc2libGVSYW5nZVswXSA+IDAgfHwgYXhpcy52aXNpYmxlUmFuZ2VbMV0gPCAxKTtcbiAgICBsZXQgYXhpc1RoaWNrbmVzcztcbiAgICBpZiAoYXhpcy50aGlja25lc3MgIT0gbnVsbCAmJiBheGlzLnRoaWNrbmVzcyA+IDApIHtcbiAgICAgIGF4aXNUaGlja25lc3MgPSBheGlzLnRoaWNrbmVzcztcbiAgICB9IGVsc2Uge1xuICAgICAgYXhpc1RoaWNrbmVzcyA9IGlzVmVydGljYWwgPyBsYXlvdXQuYmJveC53aWR0aCA6IGxheW91dC5iYm94LmhlaWdodDtcbiAgICB9XG4gICAgYXhpc1RoaWNrbmVzcyA9IE1hdGguY2VpbChheGlzVGhpY2tuZXNzKTtcbiAgICByZXR1cm4geyBjbGlwU2VyaWVzLCBheGlzVGhpY2tuZXNzLCBwcmltYXJ5VGlja0NvdW50IH07XG4gIH1cbiAgc2l6ZUF4aXMoYXhpcywgc2VyaWVzUmVjdCwgcG9zaXRpb24pIHtcbiAgICBjb25zdCBpc0NhdGVnb3J5ID0gYXhpcyBpbnN0YW5jZW9mIENhdGVnb3J5QXhpcyB8fCBheGlzIGluc3RhbmNlb2YgR3JvdXBlZENhdGVnb3J5QXhpcztcbiAgICBjb25zdCBpc0xlZnRSaWdodCA9IHBvc2l0aW9uID09PSBcImxlZnRcIiB8fCBwb3NpdGlvbiA9PT0gXCJyaWdodFwiO1xuICAgIGxldCB7IG1pbiwgbWF4IH0gPSB0aGlzLmN0eC56b29tTWFuYWdlci5nZXRBeGlzWm9vbShheGlzLmlkKTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IHNlcmllc1JlY3Q7XG4gICAgY29uc3QgbWluU3RhcnQgPSAwO1xuICAgIGNvbnN0IG1heEVuZCA9IGlzTGVmdFJpZ2h0ID8gaGVpZ2h0IDogd2lkdGg7XG4gICAgbGV0IHN0YXJ0ID0gbWluU3RhcnQ7XG4gICAgbGV0IGVuZCA9IG1heEVuZDtcbiAgICBjb25zdCB7IHdpZHRoOiBheGlzV2lkdGgsIHVuaXQsIGFsaWduIH0gPSBheGlzLmxheW91dENvbnN0cmFpbnRzO1xuICAgIGlmICh1bml0ID09PSBcInB4XCIpIHtcbiAgICAgIGVuZCA9IHN0YXJ0ICsgYXhpc1dpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmQgPSBlbmQgKiBheGlzV2lkdGggLyAxMDA7XG4gICAgfVxuICAgIGlmIChhbGlnbiA9PT0gXCJlbmRcIikge1xuICAgICAgc3RhcnQgPSBtYXhFbmQgLSAoZW5kIC0gc3RhcnQpO1xuICAgICAgZW5kID0gbWF4RW5kO1xuICAgIH1cbiAgICBpZiAoaXNDYXRlZ29yeSAmJiBpc0xlZnRSaWdodCkge1xuICAgICAgW21pbiwgbWF4XSA9IFsxIC0gbWF4LCAxIC0gbWluXTtcbiAgICB9IGVsc2UgaWYgKGlzTGVmdFJpZ2h0KSB7XG4gICAgICBbc3RhcnQsIGVuZF0gPSBbZW5kLCBzdGFydF07XG4gICAgfVxuICAgIGF4aXMucmFuZ2UgPSBbc3RhcnQsIGVuZF07XG4gICAgYXhpcy52aXNpYmxlUmFuZ2UgPSBbbWluLCBtYXhdO1xuICAgIGF4aXMuZ3JpZExlbmd0aCA9IGlzTGVmdFJpZ2h0ID8gd2lkdGggOiBoZWlnaHQ7XG4gIH1cbiAgY2FsY3VsYXRlQXhpc0FyZWEoYXhlcywgYXhpc1dpZHRocywgYXhpc09mZnNldHMpIHtcbiAgICBsZXQgdG90YWxBeGlzV2lkdGggPSAwO1xuICAgIGxldCBjdXJyZW50T2Zmc2V0ID0gMDtcbiAgICBmb3IgKGNvbnN0IGF4aXMgb2YgYXhlcykge1xuICAgICAgYXhpc09mZnNldHMuc2V0KGF4aXMuaWQsIGN1cnJlbnRPZmZzZXQpO1xuICAgICAgY29uc3QgYXhpc1RoaWNrbmVzcyA9IGF4aXNXaWR0aHMuZ2V0KGF4aXMuaWQpID8/IDA7XG4gICAgICB0b3RhbEF4aXNXaWR0aCA9IE1hdGgubWF4KHRvdGFsQXhpc1dpZHRoLCBjdXJyZW50T2Zmc2V0ICsgYXhpc1RoaWNrbmVzcyk7XG4gICAgICBpZiAoYXhpcy5sYXlvdXRDb25zdHJhaW50cy5zdGFja2VkKSB7XG4gICAgICAgIGN1cnJlbnRPZmZzZXQgKz0gYXhpc1RoaWNrbmVzcyArIDE1O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG90YWxBeGlzV2lkdGg7XG4gIH1cbiAgcG9zaXRpb25BeGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IGF4ZXMsIGF4aXNCb3VuZCwgYXhpc1dpZHRocywgYXhpc09mZnNldHMsIGF4aXNBcmVhV2lkdGhzLCBzZXJpZXNSZWN0LCBwb3NpdGlvbiB9ID0gb3B0cztcbiAgICBjb25zdCBheGlzQXJlYVdpZHRoID0gYXhpc0FyZWFXaWR0aHMuZ2V0KHBvc2l0aW9uKSA/PyAwO1xuICAgIGxldCBtYWluRGltZW5zaW9uID0gXCJ4XCI7XG4gICAgbGV0IG1pbm9yRGltZW5zaW9uID0gXCJ5XCI7XG4gICAgbGV0IGRpcmVjdGlvbiA9IDE7XG4gICAgbGV0IGF4aXNCb3VuZE1haW5PZmZzZXQgPSAwO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gXCJ0b3BcIiB8fCBwb3NpdGlvbiA9PT0gXCJib3R0b21cIikge1xuICAgICAgbWFpbkRpbWVuc2lvbiA9IFwieVwiO1xuICAgICAgbWlub3JEaW1lbnNpb24gPSBcInhcIjtcbiAgICAgIGF4aXNCb3VuZE1haW5PZmZzZXQgKz0gMTtcbiAgICB9XG4gICAgYXhpc0JvdW5kTWFpbk9mZnNldCArPSBheGlzQm91bmRbbWFpbkRpbWVuc2lvbl07XG4gICAgaWYgKHBvc2l0aW9uID09PSBcInJpZ2h0XCIgfHwgcG9zaXRpb24gPT09IFwiYm90dG9tXCIpIHtcbiAgICAgIGRpcmVjdGlvbiA9IC0xO1xuICAgICAgYXhpc0JvdW5kTWFpbk9mZnNldCArPSBtYWluRGltZW5zaW9uID09PSBcInhcIiA/IGF4aXNCb3VuZC53aWR0aCA6IGF4aXNCb3VuZC5oZWlnaHQ7XG4gICAgfVxuICAgIGZvciAoY29uc3QgYXhpcyBvZiBheGVzKSB7XG4gICAgICBjb25zdCBtaW5vck9mZnNldCA9IGF4aXNBcmVhV2lkdGhzLmdldChtaW5vckRpbWVuc2lvbiA9PT0gXCJ4XCIgPyBcImxlZnRcIiA6IFwidG9wXCIpID8/IDA7XG4gICAgICBheGlzLnRyYW5zbGF0aW9uW21pbm9yRGltZW5zaW9uXSA9IGF4aXNCb3VuZFttaW5vckRpbWVuc2lvbl0gKyBtaW5vck9mZnNldDtcbiAgICAgIGNvbnN0IGF4aXNUaGlja25lc3MgPSBheGlzV2lkdGhzLmdldChheGlzLmlkKSA/PyAwO1xuICAgICAgY29uc3QgYXhpc09mZnNldCA9IGF4aXNPZmZzZXRzLmdldChheGlzLmlkKSA/PyAwO1xuICAgICAgYXhpcy50cmFuc2xhdGlvblttYWluRGltZW5zaW9uXSA9IHRoaXMuY2xhbXBUb091dHNpZGVTZXJpZXNSZWN0KFxuICAgICAgICBzZXJpZXNSZWN0LFxuICAgICAgICBheGlzQm91bmRNYWluT2Zmc2V0ICsgZGlyZWN0aW9uICogKGF4aXNPZmZzZXQgKyBheGlzVGhpY2tuZXNzKSxcbiAgICAgICAgbWFpbkRpbWVuc2lvbixcbiAgICAgICAgZGlyZWN0aW9uXG4gICAgICApO1xuICAgICAgYXhpcy5ncmlkUGFkZGluZyA9IGF4aXNBcmVhV2lkdGggLSBheGlzT2Zmc2V0IC0gYXhpc1RoaWNrbmVzcztcbiAgICAgIGF4aXMudXBkYXRlUG9zaXRpb24oKTtcbiAgICB9XG4gIH1cbiAgc2hvdWxkRmxpcFhZKCkge1xuICAgIHJldHVybiAhdGhpcy5zZXJpZXMuc29tZSgoc2VyaWVzKSA9PiAhKHNlcmllcyBpbnN0YW5jZW9mIENhcnRlc2lhblNlcmllcyAmJiBzZXJpZXMuc2hvdWxkRmxpcFhZKCkpKTtcbiAgfVxufTtcbkNhcnRlc2lhbkNoYXJ0LmNsYXNzTmFtZSA9IFwiQ2FydGVzaWFuQ2hhcnRcIjtcbkNhcnRlc2lhbkNoYXJ0LnR5cGUgPSBcImNhcnRlc2lhblwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9jaGFydFByb3h5LnRzXG52YXIgX0FnQ2hhcnRJbnN0YW5jZVByb3h5ID0gY2xhc3MgX0FnQ2hhcnRJbnN0YW5jZVByb3h5IHtcbiAgY29uc3RydWN0b3IoY2hhcnQsIGZhY3RvcnlBcGksIGxpY2Vuc2VNYW5hZ2VyKSB7XG4gICAgdGhpcy5mYWN0b3J5QXBpID0gZmFjdG9yeUFwaTtcbiAgICB0aGlzLmxpY2Vuc2VNYW5hZ2VyID0gbGljZW5zZU1hbmFnZXI7XG4gICAgdGhpcy5jaGFydCA9IGNoYXJ0O1xuICAgIGNoYXJ0LnB1YmxpY0FwaSA9IHRoaXM7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoeCkge1xuICAgIGlmICh4IGluc3RhbmNlb2YgX0FnQ2hhcnRJbnN0YW5jZVByb3h5KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHguY29uc3RydWN0b3I/Lm5hbWUgPT09IFwiQWdDaGFydEluc3RhbmNlUHJveHlcIiAmJiB4LmNoYXJ0ICE9IG51bGwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4geC5jaGFydCAhPSBudWxsICYmIHRoaXMudmFsaWRhdGVJbXBsZW1lbnRhdGlvbih4KTtcbiAgfVxuICBzdGF0aWMgdmFsaWRhdGVJbXBsZW1lbnRhdGlvbih4KSB7XG4gICAgY29uc3QgY2hhcnRQcm9wcyA9IFtcImdldE9wdGlvbnNcIiwgXCJkZXN0cm95XCJdO1xuICAgIGNvbnN0IHNpZ25hdHVyZVByb3BzID0gT2JqZWN0LmtleXMoT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpID8/IHt9KTtcbiAgICByZXR1cm4gY2hhcnRQcm9wcy5ldmVyeSgocHJvcCkgPT4gc2lnbmF0dXJlUHJvcHMuaW5jbHVkZXMocHJvcCkpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZShvcHRpb25zKSB7XG4gICAgdGhpcy5mYWN0b3J5QXBpLmNyZWF0ZU9yVXBkYXRlKG9wdGlvbnMsIHRoaXMpO1xuICAgIGF3YWl0IHRoaXMuY2hhcnQud2FpdEZvclVwZGF0ZSgpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZURlbHRhKGRlbHRhT3B0aW9ucykge1xuICAgIHRoaXMuZmFjdG9yeUFwaS51cGRhdGVVc2VyRGVsdGEodGhpcywgZGVsdGFPcHRpb25zKTtcbiAgICBhd2FpdCB0aGlzLmNoYXJ0LndhaXRGb3JVcGRhdGUoKTtcbiAgfVxuICBnZXRPcHRpb25zKCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBkZWVwQ2xvbmUodGhpcy5jaGFydC5nZXRPcHRpb25zKCkpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMpIHtcbiAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIl9cIikpIHtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbiAgd2FpdEZvclVwZGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jaGFydC53YWl0Rm9yVXBkYXRlKCk7XG4gIH1cbiAgYXN5bmMgZG93bmxvYWQob3B0cykge1xuICAgIGNvbnN0IGNsb25lID0gYXdhaXQgdGhpcy5wcmVwYXJlUmVzaXplZENoYXJ0KHRoaXMsIG9wdHMpO1xuICAgIHRyeSB7XG4gICAgICBjbG9uZS5jaGFydC5kb3dubG9hZChvcHRzPy5maWxlTmFtZSwgb3B0cz8uZmlsZUZvcm1hdCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNsb25lLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZ2V0SW1hZ2VEYXRhVVJMKG9wdHMpIHtcbiAgICBjb25zdCBjbG9uZSA9IGF3YWl0IHRoaXMucHJlcGFyZVJlc2l6ZWRDaGFydCh0aGlzLCBvcHRzKTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGNsb25lLmNoYXJ0LmdldENhbnZhc0RhdGFVUkwob3B0cz8uZmlsZUZvcm1hdCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNsb25lLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbiAgZ2V0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmFjdG9yeUFwaS5jYXJldGFrZXIuc2F2ZSh0aGlzLmNoYXJ0LmN0eC5hbm5vdGF0aW9uTWFuYWdlcik7XG4gIH1cbiAgYXN5bmMgc2V0U3RhdGUoc3RhdGUpIHtcbiAgICB0aGlzLmZhY3RvcnlBcGkuY2FyZXRha2VyLnJlc3RvcmUoc3RhdGUsIHRoaXMuY2hhcnQuY3R4LmFubm90YXRpb25NYW5hZ2VyKTtcbiAgICBhd2FpdCB0aGlzLmNoYXJ0LndhaXRGb3JVcGRhdGUoKTtcbiAgfVxuICByZXNldEFuaW1hdGlvbnMoKSB7XG4gICAgdGhpcy5jaGFydC5yZXNldEFuaW1hdGlvbnMoKTtcbiAgfVxuICBza2lwQW5pbWF0aW9ucygpIHtcbiAgICB0aGlzLmNoYXJ0LnNraXBBbmltYXRpb25zKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNoYXJ0LnB1YmxpY0FwaSA9IHZvaWQgMDtcbiAgICB0aGlzLmNoYXJ0LmRlc3Ryb3koKTtcbiAgfVxuICBhc3luYyBwcmVwYXJlUmVzaXplZENoYXJ0KHByb3h5LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCB7IGNoYXJ0IH0gPSBwcm94eTtcbiAgICBjb25zdCB3aWR0aCA9IG9wdHMud2lkdGggPz8gY2hhcnQud2lkdGggPz8gY2hhcnQuY3R4LnNjZW5lLmNhbnZhcy53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBvcHRzLmhlaWdodCA/PyBjaGFydC5oZWlnaHQgPz8gY2hhcnQuY3R4LnNjZW5lLmNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3Qgc3RhdGUgPSBwcm94eS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGlzRW50ZXJwcmlzZSA9IG1vZHVsZVJlZ2lzdHJ5Lmhhc0VudGVycHJpc2VNb2R1bGVzKCk7XG4gICAgY29uc3Qgb3ZlcnJpZGVPcHRpb25zID0ge307XG4gICAgY29uc3QgcHJvY2Vzc2VkT3B0aW9ucyA9IGNoYXJ0LmNoYXJ0T3B0aW9ucy5nZXRPcHRpb25zKCk7XG4gICAgaWYgKGlzRW50ZXJwcmlzZSkge1xuICAgICAgb3ZlcnJpZGVPcHRpb25zLmFuaW1hdGlvbiA9IHsgZW5hYmxlZDogZmFsc2UgfTtcbiAgICAgIGlmIChpc0FnQ2FydGVzaWFuQ2hhcnRPcHRpb25zKHByb2Nlc3NlZE9wdGlvbnMpKSB7XG4gICAgICAgIG92ZXJyaWRlT3B0aW9ucy50b29sYmFyID0geyBlbmFibGVkOiBmYWxzZSB9O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGljZW5zZU1hbmFnZXI/LmlzRGlzcGxheVdhdGVybWFyaygpKSB7XG4gICAgICAgIG92ZXJyaWRlT3B0aW9ucy5mb3JlZ3JvdW5kID0ge1xuICAgICAgICAgIHRleHQ6IHRoaXMubGljZW5zZU1hbmFnZXIuZ2V0V2F0ZXJtYXJrTWVzc2FnZSgpLFxuICAgICAgICAgIGltYWdlOiB7XG4gICAgICAgICAgICB1cmw6IGBkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUIzYVdSMGFEMGlNalU0SWlCb1pXbG5hSFE5SWpRd0lpQjJhV1YzUW05NFBTSXdJREFnTWpVNElEUXdJaUJtYVd4c1BTSnViMjVsSWlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M015NXZjbWN2TWpBd01DOXpkbWNpUGdvOGNHRjBhQ0JrUFNKTk1qVXVOemM1SURJNExqWTFOMGd4TXk0ek5UbE1NVEV1TVRjeklETTBMakF4TWtnMUxqWTNNamszVERFM0xqRTRNaUEzTGpBMU9UazVTREl4TGprMU0wd3pNeTQwTmpJZ016UXVNREV5U0RJM0xqazJNa3d5TlM0M056WWdNamd1TmpVM1NESTFMamMzT1ZwTk1qUXVNRFk0SURJMExqTTVOMHd4T1M0MU9EZ2dNVE11TkRNMFRERTFMakV3TnlBeU5DNHpPVGRJTWpRdU1EWTRXazAyTWk0d09USWdNVGd1T0RJelNEUTVMamd4TjFZeU15NHdPRFpJTlRZdU56YzFRelUyTGpVMU5TQXlOUzR5TWpJZ05UVXVOelUxSURJMkxqa3lOeUExTkM0ek56SWdNamd1TWpBeVF6VXlMams0T1NBeU9TNDBOellnTlRFdU1UWTJJRE13TGpFeE5TQTBPQzQ1TURrZ016QXVNVEUxUXpRM0xqWXlNaUF6TUM0eE1UVWdORFl1TkRVZ01qa3VPRGcxSURRMUxqTTVNeUF5T1M0ME1qTkRORFF1TXpVNE15QXlPQzQ1TnpneElEUXpMalF6TWpZZ01qZ3VNekV6T0NBME1pNDJPQ0F5Tnk0ME56WkROREV1T1RJM0lESTJMall6T1NBME1TNHpORFFnTWpVdU5qTXhJRFF3TGprek1TQXlOQzQwTlRORE5EQXVOVEU1SURJekxqSTNOU0EwTUM0ek1URWdNakV1T1RjZ05EQXVNekV4SURJd0xqVXpOME0wTUM0ek1URWdNVGt1TVRBMUlEUXdMalV4TmlBeE55NDRJRFF3TGprek1TQXhOaTQyTWpGRE5ERXVNelEwSURFMUxqUTBNeUEwTVM0NU1qY2dNVFF1TkRNMklEUXlMalk0SURFekxqVTVPRU0wTXk0ME16YzJJREV5TGpjMU56Y2dORFF1TXpZNU5pQXhNaTR3T1RNeUlEUTFMalF4TVNBeE1TNDJOVEZETkRZdU5EYzRJREV4TGpFNE9TQTBOeTQyTlRZZ01UQXVPVFlnTkRndU9UUTJJREV3TGprMlF6VXhMall4TWlBeE1DNDVOaUExTXk0Mk16Y2dNVEV1TmpBeUlEVTFMakF5SURFeUxqZzROVXcxT0M0eklEa3VOakEwT1RsRE5UVXVPREUzSURjdU5qWTVPVGtnTlRJdU5qYzJJRFl1TmprNU9Ua2dORGd1T0RjeUlEWXVOams1T1RsRE5EWXVOellnTmk0Mk9UazVPU0EwTkM0NE5UTWdOeTR3TXpRNU9TQTBNeTR4TlRRZ055NDNNREE1T1VNME1TNDBOVFVnT0M0ek5qYzVPU0F6T1M0NU9UZ2dPUzR6TURNNU9TQXpPQzQzT0RNZ01UQXVOVEEwUXpNM0xqVTJOeUF4TVM0M01EY2dNell1TmpNMElERXpMakUxT0NBek5TNDVOemNnTVRRdU9EVTNRek0xTGpNeE9TQXhOaTQxTlRZZ016UXVPVGswSURFNExqUTFNU0F6TkM0NU9UUWdNakF1TlRSRE16UXVPVGswSURJeUxqWXpJRE0xTGpNeU9TQXlOQzQwT1RRZ016VXVPVGsxSURJMkxqSXdOVU16Tmk0Mk5qSWdNamN1T1RFMklETTNMall3TlNBeU9TNHpOelFnTXpndU9ERTNJRE13TGpVM04wTTBNQzR3TXpJZ016RXVOemdnTkRFdU5EZzJJRE15TGpjeE15QTBNeTR4T0RnZ016TXVNemd6UXpRMExqZzRPQ0F6TkM0d05Ea2dORFl1TnpneUlETTBMak00TkNBME9DNDROeklnTXpRdU16ZzBRelV3TGprMk1TQXpOQzR6T0RRZ05USXVOelVnTXpRdU1EUTVJRFUwTGpNNUlETXpMak00TTBNMU5pNHdNekVnTXpJdU56RTJJRFUzTGpReU5pQXpNUzQzT0NBMU9DNDFOemtnTXpBdU5UYzNRelU1TGpjek15QXlPUzR6TnpRZ05qQXVOakU1SURJM0xqa3hOaUEyTVM0eU16a2dNall1TWpBMVF6WXhMamcySURJMExqUTVOQ0EyTWk0eE55QXlNaTQyTURVZ05qSXVNVGNnTWpBdU5UUkROakl1TVRZNU5pQXhPUzQ1TmpnNElEWXlMakUwTkRVZ01Ua3VNems0SURZeUxqQTVOU0F4T0M0NE1qbE1Oakl1TURreUlERTRMamd5TTFwTk1UVXhMamd4SURFMkxqazRNVU14TlRNdU5ERWdNVFF1TmpBNUlERTFOeTQwTVRrZ01UUXVNelU0SURFMU9TNHdNaklnTVRRdU16VTRWakU0TGpreFF6RTFOaTQ1TlRjZ01UZ3VPVEVnTVRVMExqazROU0F4T0M0NU9UWWdNVFV6TGpjMU55QXhPUzQ0T1RKRE1UVXlMalV5T1NBeU1DNDNPVElnTVRVeExqa3hPU0F5TVM0NU9ESWdNVFV4TGpreE9TQXlNeTQwTmpSV016TXVPVGxJTVRRMkxqazJORll4TkM0ek5UaElNVFV4TGpjek5rd3hOVEV1T0RFZ01UWXVPVGd4V2sweE5ETXVNREV4SURFMExqTTJNVll6TkM0d016RklNVE00TGpJMFRERXpPQzR4TXpFZ016RXVNRFExUXpFek55NDBOallnTXpJdU1EYzJJREV6Tmk0MU5URWdNekl1T1RJeE9TQXhNelV1TkRjeElETXpMalV3TkVNeE16UXVNemMySURNMExqQTVPU0F4TXpNdU1EWTRJRE0wTGpNNU5pQXhNekV1TlRNMklETTBMak01TmtNeE16QXVNaUF6TkM0ek9UWWdNVEk0TGprMk15QXpOQzR4TlRJZ01USTNMamd5TWlBek15NDJOamhETVRJMkxqY2dNek11TVRrMk5DQXhNalV1TmpnNUlETXlMalE1TlNBeE1qUXVPRFUxSURNeExqWXdPVU14TWpRdU1ERTRJRE13TGpjeU1pQXhNak11TXpVMElESTVMalkyTWlBeE1qSXVPRGN4SURJNExqUXlNa014TWpJdU16ZzBJREkzTGpFNE5TQXhNakl1TVRReUlESTFMamd4TVNBeE1qSXVNVFF5SURJMExqTXdORU14TWpJdU1UUXlJREl5TGpjNU9DQXhNakl1TXpnMElESXhMak0zT0NBeE1qSXVPRGN4SURJd0xqRXhOa014TWpNdU16VTNJREU0TGpnMU5DQXhNalF1TURFNElERTNMamMzTWlBeE1qUXVPRFUxSURFMkxqZzNNME14TWpVdU5qZzRJREUxTGprM05qUWdNVEkyTGpZNU9DQXhOUzR5TmpNMklERXlOeTQ0TWpJZ01UUXVOemhETVRJNExqazJNeUF4TkM0eU9ERWdNVE13TGpJd015QXhOQzR3TXpNZ01UTXhMalV6TmlBeE5DNHdNek5ETVRNekxqQTBNeUF4TkM0d016TWdNVE0wTGpNeklERTBMak14T0NBeE16VXVNemszSURFMExqZzRPRU14TXpZdU5EWXlJREUxTGpRMU9Ea2dNVE0zTGpNM05TQXhOaTR5TnpnZ01UTTRMakExTnlBeE55NHlOelpXTVRRdU16WXhTREUwTXk0d01URmFUVEV6TWk0Mk16RWdNekF1TVRNelF6RXpOQzR5TlRZZ016QXVNVE16SURFek5TNDFOamNnTWprdU5UazBJREV6Tmk0MU5qVWdNamd1TlRFeVF6RXpOeTQxTmpFZ01qY3VORE1nTVRNNExqQTJJREkxTGprNU1TQXhNemd1TURZZ01qUXVNVGsyUXpFek9DNHdOaUF5TWk0ME1ERWdNVE0zTGpVMk1TQXlNQzQ1T1NBeE16WXVOVFkxSURFNUxqZzVPVU14TXpVdU5UY2dNVGd1T0RBM0lERXpOQzR5TlRrZ01UZ3VNalU0SURFek1pNDJNekVnTVRndU1qVTRRekV6TVM0d01ETWdNVGd1TWpVNElERXlPUzQzTWprZ01UZ3VPREEwSURFeU9DNDNNelFnTVRrdU9EazVRekV5Tnk0M016Z2dNakF1T1RreklERXlOeTR5TXprZ01qSXVORE00SURFeU55NHlNemtnTWpRdU1qTXpRekV5Tnk0eU16a2dNall1TURJNElERXlOeTQzTXpVZ01qY3VORE16SURFeU9DNDNNelFnTWpndU5URTFRekV5T1M0M01qa2dNamt1TlRrMElERXpNUzR3TWpnZ016QXVNVE0ySURFek1pNDJNekVnTXpBdU1UTTJWak13TGpFek0xcE5PVE11TmprNElESTNMamczTmtNNU15NDFOemsxSURJNExqQXdNalVnT1RNdU5EVTJOQ0F5T0M0eE1qUTJJRGt6TGpNeU9TQXlPQzR5TkRKRE9URXVPVFEzSURJNUxqVXhOaUE1TUM0eE1qTWdNekF1TVRVMUlEZzNMamcyTmlBek1DNHhOVFZET0RZdU5UZ2dNekF1TVRVMUlEZzFMalF3T0NBeU9TNDVNallnT0RRdU16VWdNamt1TkRZMFF6Z3pMak14TlRVZ01qa3VNREU0T1NBNE1pNHpPRGs0SURJNExqTTFORFlnT0RFdU5qTTNJREkzTGpVeE4wTTRNQzQ0T0RRZ01qWXVOamM1SURnd0xqTXdNU0F5TlM0Mk56SWdOemt1T0RnNUlESTBMalE1TkVNM09TNDBOellnTWpNdU16RTFJRGM1TGpJMk9TQXlNaTR3TVNBM09TNHlOamtnTWpBdU5UYzRRemM1TGpJMk9TQXhPUzR4TkRVZ056a3VORGN6SURFM0xqZzBJRGM1TGpnNE9TQXhOaTQyTmpKRE9EQXVNekF4SURFMUxqUTROQ0E0TUM0NE9EUWdNVFF1TkRjMklEZ3hMall6TnlBeE15NDJNemxET0RJdU16azBPU0F4TWk0M09UZzNJRGd6TGpNeU56TWdNVEl1TVRNME1pQTROQzR6TmprZ01URXVOamt5UXpnMUxqUXpOaUF4TVM0eU15QTROaTQyTVRRZ01URWdPRGN1T1RBeklERXhRemt3TGpVM0lERXhJRGt5TGpVNU5TQXhNUzQyTkRJZ09UTXVPVGMzSURFeUxqa3lOa3c1Tnk0eU5UZ2dPUzQyTkRRNU9VTTVOQzQzTnpRZ055NDNNVEE1T1NBNU1TNDJNek1nTmk0M016azVPU0E0Tnk0NE1qa2dOaTQzTXprNU9VTTROUzQzTVRnZ05pNDNNems1T1NBNE15NDRNVEVnTnk0d056UTVPU0E0TWk0eE1USWdOeTQzTkRFNU9VTTRNQzQwTVRNZ09DNDBNRGM1T1NBM09DNDVOVFlnT1M0ek5EUTVPU0EzTnk0M05DQXhNQzQxTkRWRE56WXVOVEkxSURFeExqYzBOeUEzTlM0MU9USWdNVE11TVRrNUlEYzBMamt6TkNBeE5DNDRPVGhETnpRdU1qYzNJREUyTGpVNU55QTNNeTQ1TlRFZ01UZ3VORGt4SURjekxqazFNU0F5TUM0MU9ERkROek11T1RVeElESXlMalkzSURjMExqSTROaUF5TkM0MU16UWdOelF1T1RVeklESTJMakkwTlVNM05TNDJNVGtnTWpjdU9UVTNJRGMyTGpVMk1pQXlPUzQwTVRRZ056Y3VOemMwSURNd0xqWXhOME0zT0M0NU9TQXpNUzQ0TWlBNE1DNDBORFFnTXpJdU56VXpJRGd5TGpFME5pQXpNeTQwTWpORE9ETXVPRFExSURNMExqQTVJRGcxTGpjek9TQXpOQzQwTWpRZ09EY3VPREk1SURNMExqUXlORU00T1M0NU1Ua2dNelF1TkRJMElEa3hMamN3T0NBek5DNHdPU0E1TXk0ek5EZ2dNek11TkRJelF6azBMamN4T0NBek1pNDROalVnT1RVdU9URTRJRE15TGpFeU1TQTVOaTQ1TkRnZ016RXVNVGt4UXprM0xqRTBPU0F6TVM0d01EZ2dPVGN1TXpRNElETXdMamd4TlNBNU55NDFNemNnTXpBdU5qSk1PVE11TnpBeElESTNMamc0TlV3NU15NDJPVGdnTWpjdU9EYzJXazB4TVRBdU9EQXlJREUwTGpBeE5VTXhNRGt1TVRrNUlERTBMakF4TlNBeE1EWXVPRE0ySURFMExqUTNNU0F4TURVdU5qRXhJREUyTGpFMU9Fd3hNRFV1TlRNM0lEWXVNREUxT1RsSU1UQXdMamMyTlZZek15NDVNemxJTVRBMUxqY3lWakl5TGpZME1VTXhNRFV1TnpjeElESXhMalEyTURjZ01UQTJMakk0T0NBeU1DNHpORGc0SURFd055NHhOVGNnTVRrdU5UUTRPVU14TURndU1ESTNJREU0TGpjME9URWdNVEE1TGpFM09DQXhPQzR6TWpZMklERXhNQzR6TlRnZ01UZ3VNemMwUXpFeE15NHpPVGNnTVRndU16YzBJREV4TkM0eU5qZ2dNakV1TVRVNUlERXhOQzR5TmpnZ01qSXVOalF4VmpNekxqa3pPVWd4TVRrdU1qSXpWakl4TGpBMU9VTXhNVGt1TWpJeklESXhMakExT1NBeE1Ua3VNVFF5SURFMExqQXhOU0F4TVRBdU9EQXlJREUwTGpBeE5WcE5NVGN6TGpjMk15QXhOQzR6TlRoSU1UWTVMams1T1ZZNExqY3hORGs1U0RFMk5TNHdORGhXTVRRdU16VTRTREUyTVM0eU9EUldNVGd1T1RFMlNERTJOUzR3TkRoV016UXVNREF6U0RFMk9TNDVPVGxXTVRndU9URTJTREUzTXk0M05qTldNVFF1TXpVNFdrMHhPVEF1TnpnM0lESTFMakkyTWtNeE9UQXVNVEk1SURJMExqVXdNVFFnTVRnNUxqTXdOeUF5TXk0NE9UazBJREU0T0M0ek9EUWdNak11TlRBeFF6RTROeTQwT0RnZ01qTXVNVEUzSURFNE5pNHpNekVnTWpJdU56TXlJREU0TkM0NU5EZ2dNakl1TXpZMFF6RTROQzR4TmpVZ01qSXVNVFF6T1NBeE9ETXVNemtnTWpFdU9EazNPQ0F4T0RJdU5qSXpJREl4TGpZeU5rTXhPREl1TVRZeklESXhMalEyTWpFZ01UZ3hMamMwTVNBeU1TNHlNRFkySURFNE1TNHpPRE1nTWpBdU9EYzFRekU0TVM0eU16VWdNakF1TnpReU1TQXhPREV1TVRFNElESXdMalUzT0RrZ01UZ3hMakF6T1NBeU1DNHpPVFkwUXpFNE1DNDVOakVnTWpBdU1qRTBJREU0TUM0NU1qSWdNakF1TURFMk5pQXhPREF1T1RJM0lERTVMamd4T0VNeE9EQXVPVEkzSURFNUxqSTNNaUF4T0RFdU1UVTJJREU0TGpnME5DQXhPREV1TmpJMUlERTRMalV4UXpFNE1pNHhNakVnTVRndU1UVTJJREU0TWk0NE5qSWdNVGN1T1RjMklERTRNeTQ0TWpZZ01UY3VPVGMyUXpFNE5DNDNPU0F4Tnk0NU56WWdNVGcxTGpVNE55QXhPQzR5TURrZ01UZzJMakUwT0NBeE9DNDJOamhETVRnMkxqY3dOaUF4T1M0eE1qUWdNVGczTGpBd055QXhPUzQzTWpVZ01UZzNMakEzTWlBeU1DNDFUREU0Tnk0d09UUWdNakF1TnpneVNERTVNUzQyTXpOTU1Ua3hMall4TnlBeU1DNDBOa014T1RFdU5USXhJREU0TGpRNE5TQXhPVEF1TnpjeElERTJMamtnTVRnNUxqTTROU0F4TlM0M05VTXhPRGd1TURFeUlERTBMall4TWlBeE9EWXVNVGcxSURFMExqQXpNeUF4T0RNdU9UWXlJREUwTGpBek0wTXhPREl1TkRjM0lERTBMakF6TXlBeE9ERXVNVFF4SURFMExqSTROeUF4TnprdU9UazBJREUwTGpjNE5rTXhOemd1T0RNeElERTFMakk1TVNBeE56Y3VPVEkySURFMUxqazVOU0F4TnpjdU1qazJJREUyTGpnNE1rTXhOell1TmpjeklERTNMamMwTlRVZ01UYzJMak16T0NBeE9DNDNPRFFnTVRjMkxqTTBNU0F4T1M0NE5EbERNVGMyTGpNME1TQXlNUzR4TmpjZ01UYzJMalk1T0NBeU1pNHlORGtnTVRjM0xqTTVPU0F5TXk0d05qUkRNVGM0TGpBMklESXpMamcwTXpJZ01UYzRMamc1T0NBeU5DNDBOVE0wSURFM09TNDRORElnTWpRdU9EUTBRekU0TUM0M05EUWdNalV1TWpFMklERTRNUzQ1TWpnZ01qVXVOakEzSURFNE15NHpOakVnTWpaRE1UZzBMamd3TmlBeU5pNDBNU0F4T0RVdU9EY3lJREkyTGpjNE5TQXhPRFl1TlRNZ01qY3VNVEl6UXpFNE55NHhJREkzTGpReE5DQXhPRGN1TXpjNUlESTNMamcwTlNBeE9EY3VNemM1SURJNExqUTBORU14T0RjdU16YzVJREk1TGpBME1pQXhPRGN1TVRJeUlESTVMalEyTnlBeE9EWXVOVGsxSURJNUxqZ3pPVU14T0RZdU1EUXpJRE13TGpJeU5pQXhPRFV1TWpNM0lETXdMalF5TlNBeE9EUXVNakF4SURNd0xqUXlOVU14T0RNdU1UWTJJRE13TGpReU5TQXhPREl1TXprMElETXdMakUzTkNBeE9ERXVOelE1SURJNUxqWTNORU14T0RFdU1URXpJREk1TGpFNE1TQXhPREF1TnpjeUlESTRMalU0T1NBeE9EQXVOekVnTWpjdU9EWTBUREU0TUM0Mk9EVWdNamN1TlRneVNERTNOaTR3TVROTU1UYzJMakF5TlNBeU55NDVNREZETVRjMkxqQTJOeUF5T1M0d09UVTFJREUzTmk0ME56SWdNekF1TWpRNE55QXhOemN1TVRnNElETXhMakl3TmtNeE56Y3VPVEEzSURNeUxqRTRJREUzT0M0NE9UTWdNekl1T1RVNElERTRNQzR4TVRnZ016TXVOVEU1UXpFNE1TNHpNellnTXpRdU1EYzNJREU0TWk0M016SWdNelF1TXpZeUlERTROQzR5TmpZZ016UXVNell5UXpFNE5TNDRNREVnTXpRdU16WXlJREU0Tnk0eE1Ea2dNelF1TVRBNElERTRPQzR5TXpnZ016TXVOakE1UXpFNE9TNHpOellnTXpNdU1UQTBJREU1TUM0eU56SWdNekl1TXprMElERTVNQzQ1TURFZ016RXVORGswUXpFNU1TNDFNelFnTXpBdU5Ua3lJREU1TVM0NE5UTWdNamt1TlRVMElERTVNUzQ0TlRNZ01qZ3VOREF6UXpFNU1TNDRNamdnTWpjdU1URWdNVGt4TGpRMk5pQXlOaTR3TlRNZ01Ua3dMamMzTnlBeU5TNHlOakpJTVRrd0xqYzROMW9pSUdacGJHdzlJaU01UWpsQ09VSWlMejRLUEhCaGRHZ2daRDBpVFRJME1TNDVPRElnTWpVdU5qVTRNbFl4Tnk0M01URTNTREl5T0M0ME5ERk1Nakl3TGpRNU5DQXlOUzQyTlRneVNESTBNUzQ1T0RKYUlpQm1hV3hzUFNJak9VSTVRamxDSWk4K0NqeHdZWFJvSUdROUlrMHlOVGN1TWpNNUlEVXVPVFV3T0RGSU1qUXdMakkyTlV3eU16SXVNalUxSURFekxqZzVOek5JTWpVM0xqSXpPVlkxTGprMU1EZ3hXaUlnWm1sc2JEMGlJemxDT1VJNVFpSXZQZ284Y0dGMGFDQmtQU0pOTWpFeUxqWXhNU0F6TXk0Mk1EUTRUREl4Tmk0Mk9DQXlPUzQxTXpZeFNESXpNQzQwTVRKV016Y3VORGd5TjBneU1USXVOakV4VmpNekxqWXdORGhhSWlCbWFXeHNQU0lqT1VJNVFqbENJaTgrQ2p4d1lYUm9JR1E5SWsweU1UVXVOVGs1SURJeExqYzRNRE5JTWpJMExqTTNNa3d5TXpJdU16Z3lJREV6TGpnek16ZElNakUxTGpVNU9WWXlNUzQzT0RBeldpSWdabWxzYkQwaUl6bENPVUk1UWlJdlBnbzhjR0YwYUNCa1BTSk5NakEySURNekxqWXdORGRJTWpFeUxqWXhNVXd5TWpBdU5EazBJREkxTGpZMU9ESklNakEyVmpNekxqWXdORGRhSWlCbWFXeHNQU0lqT1VJNVFqbENJaTgrQ2p4d1lYUm9JR1E5SWsweU5EQXVNalkxSURVdU9UVXdPREZNTWpNMkxqRTVOeUF4TUM0d01UazBTREl4TUM0eU5UbFdNaTR3TnpJNE9FZ3lOREF1TWpZMVZqVXVPVFV3T0RGYUlpQm1hV3hzUFNJak9VSTVRamxDSWk4K0Nqd3ZjM1puUGdvPWAsXG4gICAgICAgICAgICB3aWR0aDogMTcwLFxuICAgICAgICAgICAgaGVpZ2h0OiAyNSxcbiAgICAgICAgICAgIHJpZ2h0OiAyNSxcbiAgICAgICAgICAgIGJvdHRvbTogNTAsXG4gICAgICAgICAgICBvcGFjaXR5OiAwLjdcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPSBtZXJnZURlZmF1bHRzKFxuICAgICAge1xuICAgICAgICBjb250YWluZXI6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0sXG4gICAgICBvdmVycmlkZU9wdGlvbnMsXG4gICAgICBwcm9jZXNzZWRPcHRpb25zXG4gICAgKTtcbiAgICBjb25zdCBjbG9uZVByb3h5ID0gYXdhaXQgdGhpcy5mYWN0b3J5QXBpLmNyZWF0ZU9yVXBkYXRlKG9wdGlvbnMpO1xuICAgIGF3YWl0IGNsb25lUHJveHkuc2V0U3RhdGUoc3RhdGUpO1xuICAgIGNsb25lUHJveHkuY2hhcnQuY3R4Lnpvb21NYW5hZ2VyLnVwZGF0ZVpvb20oXCJhZ0NoYXJ0VjJcIiwgY2hhcnQuY3R4Lnpvb21NYW5hZ2VyLmdldFpvb20oKSk7XG4gICAgY2hhcnQuc2VyaWVzLmZvckVhY2goKHNlcmllcywgaW5kZXgpID0+IHtcbiAgICAgIGlmICghc2VyaWVzLnZpc2libGUpIHtcbiAgICAgICAgY2xvbmVQcm94eS5jaGFydC5zZXJpZXNbaW5kZXhdLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjaGFydC51cGRhdGUoMCAvKiBGVUxMICovLCB7IGZvcmNlTm9kZURhdGFSZWZyZXNoOiB0cnVlIH0pO1xuICAgIGF3YWl0IGNsb25lUHJveHkud2FpdEZvclVwZGF0ZSgpO1xuICAgIHJldHVybiBjbG9uZVByb3h5O1xuICB9XG59O1xuX0FnQ2hhcnRJbnN0YW5jZVByb3h5LmNoYXJ0SW5zdGFuY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgb2xkVmFsdWUoY2hhcnQpIHtcbiAgICAgIF9BZ0NoYXJ0SW5zdGFuY2VQcm94eS5jaGFydEluc3RhbmNlcy5kZWxldGUoY2hhcnQpO1xuICAgIH0sXG4gICAgbmV3VmFsdWUoY2hhcnQpIHtcbiAgICAgIF9BZ0NoYXJ0SW5zdGFuY2VQcm94eS5jaGFydEluc3RhbmNlcy5zZXQoY2hhcnQsIHRoaXMpO1xuICAgIH1cbiAgfSlcbl0sIF9BZ0NoYXJ0SW5zdGFuY2VQcm94eS5wcm90b3R5cGUsIFwiY2hhcnRcIiwgMik7XG52YXIgQWdDaGFydEluc3RhbmNlUHJveHkgPSBfQWdDaGFydEluc3RhbmNlUHJveHk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjYWxlL2xpbmVhclNjYWxlLnRzXG52YXIgTGluZWFyU2NhbGUgPSBjbGFzcyBleHRlbmRzIENvbnRpbnVvdXNTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFswLCAxXSwgWzAsIDFdKTtcbiAgICB0aGlzLnR5cGUgPSBcIm51bWJlclwiO1xuICB9XG4gIHRvRG9tYWluKGQpIHtcbiAgICByZXR1cm4gZDtcbiAgfVxuICB0aWNrcygpIHtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMudGlja0NvdW50ID8/IENvbnRpbnVvdXNTY2FsZS5kZWZhdWx0VGlja0NvdW50O1xuICAgIGlmICghdGhpcy5kb21haW4gfHwgdGhpcy5kb21haW4ubGVuZ3RoIDwgMiB8fCBjb3VudCA8IDEgfHwgIXRoaXMuZG9tYWluLmV2ZXJ5KGlzRmluaXRlKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgICBjb25zdCBbZDAsIGQxXSA9IHRoaXMuZ2V0RG9tYWluKCk7XG4gICAgaWYgKHRoaXMuaW50ZXJ2YWwpIHtcbiAgICAgIGNvbnN0IHN0ZXAgPSBNYXRoLmFicyh0aGlzLmludGVydmFsKTtcbiAgICAgIGlmICghaXNEZW5zZUludGVydmFsKChkMSAtIGQwKSAvIHN0ZXAsIHRoaXMuZ2V0UGl4ZWxSYW5nZSgpKSkge1xuICAgICAgICByZXR1cm4gcmFuZ2UoZDAsIGQxLCBzdGVwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVRpY2tzKGQwLCBkMSwgY291bnQsIHRoaXMubWluVGlja0NvdW50LCB0aGlzLm1heFRpY2tDb3VudCk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGlmICghdGhpcy5kb21haW4gfHwgdGhpcy5kb21haW4ubGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5uaWNlKSB7XG4gICAgICB0aGlzLnVwZGF0ZU5pY2VEb21haW4oKTtcbiAgICB9XG4gIH1cbiAgZ2V0VGlja1N0ZXAoc3RhcnQsIHN0b3ApIHtcbiAgICByZXR1cm4gdGhpcy5pbnRlcnZhbCA/PyB0aWNrU3RlcChzdGFydCwgc3RvcCwgdGhpcy50aWNrQ291bnQsIHRoaXMubWluVGlja0NvdW50LCB0aGlzLm1heFRpY2tDb3VudCk7XG4gIH1cbiAgLyoqXG4gICAqIEV4dGVuZHMgdGhlIGRvbWFpbiBzbyB0aGF0IGl0IHN0YXJ0cyBhbmQgZW5kcyBvbiBuaWNlIHJvdW5kIHZhbHVlcy5cbiAgICovXG4gIHVwZGF0ZU5pY2VEb21haW4oKSB7XG4gICAgY29uc3QgY291bnQgPSB0aGlzLnRpY2tDb3VudDtcbiAgICBpZiAoY291bnQgPCAxKSB7XG4gICAgICB0aGlzLm5pY2VEb21haW4gPSBbLi4udGhpcy5kb21haW5dO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgW3N0YXJ0LCBzdG9wXSA9IHRoaXMuZG9tYWluO1xuICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgW3N0YXJ0LCBzdG9wXSA9IG5pY2VUaWNrc0RvbWFpbihzdGFydCwgc3RvcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJvdW5kU3RhcnQgPSBzdGFydCA+IHN0b3AgPyBNYXRoLmNlaWwgOiBNYXRoLmZsb29yO1xuICAgICAgY29uc3Qgcm91bmRTdG9wID0gc3RvcCA8IHN0YXJ0ID8gTWF0aC5mbG9vciA6IE1hdGguY2VpbDtcbiAgICAgIGNvbnN0IG1heEF0dGVtcHRzID0gNDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4QXR0ZW1wdHM7IGkrKykge1xuICAgICAgICBjb25zdCBwcmV2MCA9IHN0YXJ0O1xuICAgICAgICBjb25zdCBwcmV2MSA9IHN0b3A7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLmdldFRpY2tTdGVwKHN0YXJ0LCBzdG9wKTtcbiAgICAgICAgY29uc3QgW2QwLCBkMV0gPSB0aGlzLmRvbWFpbjtcbiAgICAgICAgaWYgKHN0ZXAgPj0gMSkge1xuICAgICAgICAgIHN0YXJ0ID0gcm91bmRTdGFydChkMCAvIHN0ZXApICogc3RlcDtcbiAgICAgICAgICBzdG9wID0gcm91bmRTdG9wKGQxIC8gc3RlcCkgKiBzdGVwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHMgPSAxIC8gc3RlcDtcbiAgICAgICAgICBzdGFydCA9IHJvdW5kU3RhcnQoZDAgKiBzKSAvIHM7XG4gICAgICAgICAgc3RvcCA9IHJvdW5kU3RvcChkMSAqIHMpIC8gcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnQgPT09IHByZXYwICYmIHN0b3AgPT09IHByZXYxKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5uaWNlRG9tYWluID0gW3N0YXJ0LCBzdG9wXTtcbiAgfVxuICB0aWNrRm9ybWF0KHsgdGlja3M6IHNwZWNpZmllZFRpY2tzLCBzcGVjaWZpZXIgfSkge1xuICAgIHJldHVybiB0aWNrRm9ybWF0KHNwZWNpZmllZFRpY2tzID8/IHRoaXMudGlja3MoKSwgc3BlY2lmaWVyKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9zZWNvbmRhcnlBeGlzVGlja3MudHNcbmZ1bmN0aW9uIGNhbGN1bGF0ZU5pY2VTZWNvbmRhcnlBeGlzKGRvbWFpbiwgcHJpbWFyeVRpY2tDb3VudCwgcmV2ZXJzZSkge1xuICBsZXQgW3N0YXJ0LCBzdG9wXSA9IGZpbmRNaW5NYXgoZG9tYWluKTtcbiAgc3RhcnQgPSBjYWxjdWxhdGVOaWNlU3RhcnQoTWF0aC5mbG9vcihzdGFydCksIHN0b3AsIHByaW1hcnlUaWNrQ291bnQpO1xuICBjb25zdCBzdGVwID0gZ2V0VGlja1N0ZXAoc3RhcnQsIHN0b3AsIHByaW1hcnlUaWNrQ291bnQpO1xuICBjb25zdCBzZWdtZW50cyA9IHByaW1hcnlUaWNrQ291bnQgLSAxO1xuICBzdG9wID0gc3RhcnQgKyBzZWdtZW50cyAqIHN0ZXA7XG4gIGNvbnN0IGQgPSByZXZlcnNlID8gW3N0b3AsIHN0YXJ0XSA6IFtzdGFydCwgc3RvcF07XG4gIGNvbnN0IHRpY2tzID0gZ2V0VGlja3Moc3RhcnQsIHN0ZXAsIHByaW1hcnlUaWNrQ291bnQpO1xuICByZXR1cm4geyBkb21haW46IGQsIHRpY2tzIH07XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVOaWNlU3RhcnQoYSwgYiwgY291bnQpIHtcbiAgY29uc3QgcmF3U3RlcCA9IE1hdGguYWJzKGIgLSBhKSAvIChjb3VudCAtIDEpO1xuICBjb25zdCBvcmRlciA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChyYXdTdGVwKSk7XG4gIGNvbnN0IG1hZ25pdHVkZSA9IE1hdGgucG93KDEwLCBvcmRlcik7XG4gIHJldHVybiBNYXRoLmZsb29yKGEgLyBtYWduaXR1ZGUpICogbWFnbml0dWRlO1xufVxuZnVuY3Rpb24gZ2V0VGlja3Moc3RhcnQsIHN0ZXAsIGNvdW50KSB7XG4gIGNvbnN0IHN0ZXBQb3dlciA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChzdGVwKSk7XG4gIGNvbnN0IGZyYWN0aW9uRGlnaXRzID0gc3RlcCA+IDAgJiYgc3RlcCA8IDEgPyBNYXRoLmFicyhzdGVwUG93ZXIpIDogMDtcbiAgY29uc3QgZiA9IE1hdGgucG93KDEwLCBmcmFjdGlvbkRpZ2l0cyk7XG4gIGNvbnN0IHRpY2tzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgIGNvbnN0IHRpY2sgPSBzdGFydCArIHN0ZXAgKiBpO1xuICAgIHRpY2tzW2ldID0gTWF0aC5yb3VuZCh0aWNrICogZikgLyBmO1xuICB9XG4gIHJldHVybiB0aWNrcztcbn1cbmZ1bmN0aW9uIGdldFRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBjb3VudCkge1xuICBjb25zdCBzZWdtZW50cyA9IGNvdW50IC0gMTtcbiAgY29uc3QgcmF3U3RlcCA9IChzdG9wIC0gc3RhcnQpIC8gc2VnbWVudHM7XG4gIHJldHVybiBjYWxjdWxhdGVOZXh0TmljZVN0ZXAocmF3U3RlcCk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVOZXh0TmljZVN0ZXAocmF3U3RlcCkge1xuICBjb25zdCBvcmRlciA9IE1hdGguZmxvb3IoTWF0aC5sb2cxMChyYXdTdGVwKSk7XG4gIGNvbnN0IG1hZ25pdHVkZSA9IE1hdGgucG93KDEwLCBvcmRlcik7XG4gIGNvbnN0IHN0ZXAgPSByYXdTdGVwIC8gbWFnbml0dWRlICogMTA7XG4gIGlmIChzdGVwID4gMCAmJiBzdGVwIDw9IDEpIHtcbiAgICByZXR1cm4gbWFnbml0dWRlIC8gMTA7XG4gIH1cbiAgaWYgKHN0ZXAgPiAxICYmIHN0ZXAgPD0gMikge1xuICAgIHJldHVybiAyICogbWFnbml0dWRlIC8gMTA7XG4gIH1cbiAgaWYgKHN0ZXAgPiAxICYmIHN0ZXAgPD0gNSkge1xuICAgIHJldHVybiA1ICogbWFnbml0dWRlIC8gMTA7XG4gIH1cbiAgaWYgKHN0ZXAgPiA1ICYmIHN0ZXAgPD0gMTApIHtcbiAgICByZXR1cm4gMTAgKiBtYWduaXR1ZGUgLyAxMDtcbiAgfVxuICBpZiAoc3RlcCA+IDEwICYmIHN0ZXAgPD0gMjApIHtcbiAgICByZXR1cm4gMjAgKiBtYWduaXR1ZGUgLyAxMDtcbiAgfVxuICBpZiAoc3RlcCA+IDIwICYmIHN0ZXAgPD0gNDApIHtcbiAgICByZXR1cm4gNDAgKiBtYWduaXR1ZGUgLyAxMDtcbiAgfVxuICBpZiAoc3RlcCA+IDQwICYmIHN0ZXAgPD0gNTApIHtcbiAgICByZXR1cm4gNTAgKiBtYWduaXR1ZGUgLyAxMDtcbiAgfVxuICBpZiAoc3RlcCA+IDUwICYmIHN0ZXAgPD0gMTAwKSB7XG4gICAgcmV0dXJuIDEwMCAqIG1hZ25pdHVkZSAvIDEwO1xuICB9XG4gIHJldHVybiBzdGVwO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL251bWJlckF4aXMudHNcbnZhciBOdW1iZXJBeGlzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5BeGlzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4LCBzY2FsZTIgPSBuZXcgTGluZWFyU2NhbGUoKSkge1xuICAgIHN1cGVyKG1vZHVsZUN0eCwgc2NhbGUyKTtcbiAgICB0aGlzLm1pbiA9IE5hTjtcbiAgICB0aGlzLm1heCA9IE5hTjtcbiAgfVxuICBub3JtYWxpc2VEYXRhRG9tYWluKGQpIHtcbiAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgZXh0ZW50OiBleHRlbnQyLCBjbGlwcGVkIH0gPSBub3JtYWxpc2VkRXh0ZW50V2l0aE1ldGFkYXRhKGQsIG1pbiwgbWF4KTtcbiAgICByZXR1cm4geyBkb21haW46IGV4dGVudDIsIGNsaXBwZWQgfTtcbiAgfVxuICB1cGRhdGVTZWNvbmRhcnlBeGlzVGlja3MocHJpbWFyeVRpY2tDb3VudCkge1xuICAgIGlmICh0aGlzLmRhdGFEb21haW4gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQUcgQ2hhcnRzIC0gZGF0YURvbWFpbiBub3QgY2FsY3VsYXRlZCwgY2Fubm90IHBlcmZvcm0gdGljayBjYWxjdWxhdGlvbi5cIik7XG4gICAgfVxuICAgIGlmICh0aGlzLmRhdGFEb21haW4uZG9tYWluLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB7IGRvbWFpbiwgdGlja3MgfSA9IGNhbGN1bGF0ZU5pY2VTZWNvbmRhcnlBeGlzKFxuICAgICAgdGhpcy5kYXRhRG9tYWluLmRvbWFpbixcbiAgICAgIHByaW1hcnlUaWNrQ291bnQgPz8gMCxcbiAgICAgIHRoaXMucmV2ZXJzZVxuICAgICk7XG4gICAgdGhpcy5zY2FsZS5uaWNlID0gZmFsc2U7XG4gICAgdGhpcy5zY2FsZS5kb21haW4gPSBkb21haW47XG4gICAgdGhpcy5zY2FsZS51cGRhdGUoKTtcbiAgICByZXR1cm4gdGlja3M7XG4gIH1cbn07XG5OdW1iZXJBeGlzLmNsYXNzTmFtZSA9IFwiTnVtYmVyQXhpc1wiO1xuTnVtYmVyQXhpcy50eXBlID0gXCJudW1iZXJcIjtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEFORChOVU1CRVJfT1JfTkFOLCBMRVNTX1RIQU4oXCJtYXhcIikpKSxcbiAgRGVmYXVsdChOYU4pXG5dLCBOdW1iZXJBeGlzLnByb3RvdHlwZSwgXCJtaW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShBTkQoTlVNQkVSX09SX05BTiwgR1JFQVRFUl9USEFOKFwibWluXCIpKSksXG4gIERlZmF1bHQoTmFOKVxuXSwgTnVtYmVyQXhpcy5wcm90b3R5cGUsIFwibWF4XCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL2xvZ0F4aXMudHNcbnZhciBOT05fWkVST19OVU1CRVIgPSBwcmVkaWNhdGVXaXRoTWVzc2FnZSgodmFsdWUpID0+IGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAhPT0gMCwgXCJhIG5vbi16ZXJvIG51bWJlclwiKTtcbnZhciBMb2dBeGlzID0gY2xhc3MgZXh0ZW5kcyBOdW1iZXJBeGlzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XG4gICAgc3VwZXIobW9kdWxlQ3R4LCBuZXcgTG9nU2NhbGUoKSk7XG4gICAgdGhpcy5taW4gPSBOYU47XG4gICAgdGhpcy5tYXggPSBOYU47XG4gIH1cbiAgbm9ybWFsaXNlRGF0YURvbWFpbihkKSB7XG4gICAgY29uc3QgeyBtaW4sIG1heCB9ID0gdGhpcztcbiAgICBjb25zdCB7IGV4dGVudDogZXh0ZW50MiwgY2xpcHBlZCB9ID0gbm9ybWFsaXNlZEV4dGVudFdpdGhNZXRhZGF0YShkLCBtaW4sIG1heCk7XG4gICAgY29uc3QgaXNJbnZlcnRlZCA9IGV4dGVudDJbMF0gPiBleHRlbnQyWzFdO1xuICAgIGNvbnN0IGNyb3NzZXNaZXJvID0gZXh0ZW50MlswXSA8IDAgJiYgZXh0ZW50MlsxXSA+IDA7XG4gICAgY29uc3QgaGFzWmVyb0V4dGVudCA9IGV4dGVudDJbMF0gPT09IDAgJiYgZXh0ZW50MlsxXSA9PT0gMDtcbiAgICBjb25zdCBpbnZhbGlkRG9tYWluID0gaXNJbnZlcnRlZCB8fCBjcm9zc2VzWmVybyB8fCBoYXNaZXJvRXh0ZW50O1xuICAgIGlmIChpbnZhbGlkRG9tYWluKSB7XG4gICAgICBpZiAoY3Jvc3Nlc1plcm8pIHtcbiAgICAgICAgTG9nZ2VyLndhcm4oXG4gICAgICAgICAgYHRoZSBkYXRhIGRvbWFpbiBjcm9zc2VzIHplcm8sIHRoZSBjaGFydCBkYXRhIGNhbm5vdCBiZSByZW5kZXJlZC4gU2VlIGxvZyBheGlzIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgaW5mb3JtYXRpb24uYFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIGlmIChoYXNaZXJvRXh0ZW50KSB7XG4gICAgICAgIExvZ2dlci53YXJuKGB0aGUgZGF0YSBkb21haW4gaGFzIDAgZXh0ZW50LCBubyBkYXRhIGlzIHJlbmRlcmVkLmApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXh0ZW50MlswXSA9PT0gMCkge1xuICAgICAgZXh0ZW50MlswXSA9IDE7XG4gICAgfVxuICAgIGlmIChleHRlbnQyWzFdID09PSAwKSB7XG4gICAgICBleHRlbnQyWzFdID0gLTE7XG4gICAgfVxuICAgIHJldHVybiB7IGRvbWFpbjogZXh0ZW50MiwgY2xpcHBlZCB9O1xuICB9XG4gIHNldCBiYXNlKHZhbHVlKSB7XG4gICAgdGhpcy5zY2FsZS5iYXNlID0gdmFsdWU7XG4gIH1cbiAgZ2V0IGJhc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGUuYmFzZTtcbiAgfVxufTtcbkxvZ0F4aXMuY2xhc3NOYW1lID0gXCJMb2dBeGlzXCI7XG5Mb2dBeGlzLnR5cGUgPSBcImxvZ1wiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQU5EKE5VTUJFUl9PUl9OQU4sIE5PTl9aRVJPX05VTUJFUiwgTEVTU19USEFOKFwibWF4XCIpKSksXG4gIERlZmF1bHQoTmFOKVxuXSwgTG9nQXhpcy5wcm90b3R5cGUsIFwibWluXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQU5EKE5VTUJFUl9PUl9OQU4sIE5PTl9aRVJPX05VTUJFUiwgR1JFQVRFUl9USEFOKFwibWluXCIpKSksXG4gIERlZmF1bHQoTmFOKVxuXSwgTG9nQXhpcy5wcm90b3R5cGUsIFwibWF4XCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9heGlzL3RpbWVBeGlzLnRzXG52YXIgVGltZUF4aXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhbkF4aXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcihtb2R1bGVDdHgsIG5ldyBUaW1lU2NhbGUoKSk7XG4gICAgdGhpcy5taW4gPSB2b2lkIDA7XG4gICAgdGhpcy5tYXggPSB2b2lkIDA7XG4gIH1cbiAgbm9ybWFsaXNlRGF0YURvbWFpbihkKSB7XG4gICAgbGV0IHsgbWluLCBtYXggfSA9IHRoaXM7XG4gICAgbGV0IGNsaXBwZWQgPSBmYWxzZTtcbiAgICBpZiAodHlwZW9mIG1pbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgbWluID0gbmV3IERhdGUobWluKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtYXggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIG1heCA9IG5ldyBEYXRlKG1heCk7XG4gICAgfVxuICAgIGlmIChkLmxlbmd0aCA+IDIpIHtcbiAgICAgIGQgPSAoZXh0ZW50KGQpID8/IFswLCAxZTNdKS5tYXAoKHgpID0+IG5ldyBEYXRlKHgpKTtcbiAgICB9XG4gICAgaWYgKG1pbiBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIGNsaXBwZWQgfHwgKGNsaXBwZWQgPSBtaW4gPiBkWzBdKTtcbiAgICAgIGQgPSBbbWluLCBkWzFdXTtcbiAgICB9XG4gICAgaWYgKG1heCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIGNsaXBwZWQgfHwgKGNsaXBwZWQgPSBtYXggPCBkWzFdKTtcbiAgICAgIGQgPSBbZFswXSwgbWF4XTtcbiAgICB9XG4gICAgaWYgKGRbMF0gPiBkWzFdKSB7XG4gICAgICBkID0gW107XG4gICAgfVxuICAgIHJldHVybiB7IGRvbWFpbjogZCwgY2xpcHBlZCB9O1xuICB9XG4gIG9uRm9ybWF0Q2hhbmdlKHRpY2tzLCBmcmFjdGlvbkRpZ2l0cywgZG9tYWluLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICBzdXBlci5vbkZvcm1hdENoYW5nZSh0aWNrcywgZnJhY3Rpb25EaWdpdHMsIGRvbWFpbiwgZm9ybWF0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYWJlbEZvcm1hdHRlciA9IHRoaXMuc2NhbGUudGlja0Zvcm1hdCh7IHRpY2tzLCBkb21haW4gfSk7XG4gICAgICB0aGlzLmRhdHVtRm9ybWF0dGVyID0gdGhpcy5zY2FsZS50aWNrRm9ybWF0KHsgdGlja3MsIGRvbWFpbiwgZm9ybWF0T2Zmc2V0OiAxIH0pO1xuICAgIH1cbiAgfVxuICBjYWxjdWxhdGVQYWRkaW5nKCkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbn07XG5UaW1lQXhpcy5jbGFzc05hbWUgPSBcIlRpbWVBeGlzXCI7XG5UaW1lQXhpcy50eXBlID0gXCJ0aW1lXCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShBTkQoREFURV9PUl9EQVRFVElNRV9NUywgTEVTU19USEFOKFwibWF4XCIpKSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgVGltZUF4aXMucHJvdG90eXBlLCBcIm1pblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEFORChEQVRFX09SX0RBVEVUSU1FX01TLCBHUkVBVEVSX1RIQU4oXCJtaW5cIikpLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBUaW1lQXhpcy5wcm90b3R5cGUsIFwibWF4XCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS91dGlsL2Nvcm5lci50c1xudmFyIGRyYXdDb3JuZXIgPSAocGF0aCwgeyB4MCwgeTAsIHgxLCB5MSwgY3gsIGN5IH0sIGNvcm5lclJhZGl1cywgbW92ZSkgPT4ge1xuICBpZiAobW92ZSkge1xuICAgIHBhdGgubW92ZVRvKHgwLCB5MCk7XG4gIH1cbiAgaWYgKHgwICE9PSB4MSB8fCB5MCAhPT0geTEpIHtcbiAgICBjb25zdCByMCA9IE1hdGguYXRhbjIoeTAgLSBjeSwgeDAgLSBjeCk7XG4gICAgY29uc3QgcjEgPSBNYXRoLmF0YW4yKHkxIC0gY3ksIHgxIC0gY3gpO1xuICAgIHBhdGguYXJjKGN4LCBjeSwgY29ybmVyUmFkaXVzLCByMCwgcjEpO1xuICB9IGVsc2Uge1xuICAgIHBhdGgubGluZVRvKHgwLCB5MCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NoYXBlL3JlY3QudHNcbnZhciBlcHNpbG9uID0gMWUtNjtcbnZhciBjb3JuZXJFZGdlcyA9IChsZWFkaW5nRWRnZSwgdHJhaWxpbmdFZGdlLCBsZWFkaW5nSW5zZXQsIHRyYWlsaW5nSW5zZXQsIGNvcm5lclJhZGl1cykgPT4ge1xuICBsZXQgbGVhZGluZ0NsaXBwZWQgPSBmYWxzZTtcbiAgbGV0IHRyYWlsaW5nQ2xpcHBlZCA9IGZhbHNlO1xuICBsZXQgbGVhZGluZzAgPSB0cmFpbGluZ0luc2V0IC0gTWF0aC5zcXJ0KE1hdGgubWF4KGNvcm5lclJhZGl1cyAqKiAyIC0gbGVhZGluZ0luc2V0ICoqIDIsIDApKTtcbiAgbGV0IGxlYWRpbmcxID0gMDtcbiAgbGV0IHRyYWlsaW5nMCA9IDA7XG4gIGxldCB0cmFpbGluZzEgPSBsZWFkaW5nSW5zZXQgLSBNYXRoLnNxcnQoTWF0aC5tYXgoY29ybmVyUmFkaXVzICoqIDIgLSB0cmFpbGluZ0luc2V0ICoqIDIsIDApKTtcbiAgaWYgKGxlYWRpbmcwID4gbGVhZGluZ0VkZ2UpIHtcbiAgICBsZWFkaW5nQ2xpcHBlZCA9IHRydWU7XG4gICAgbGVhZGluZzAgPSBsZWFkaW5nRWRnZTtcbiAgICBsZWFkaW5nMSA9IGxlYWRpbmdJbnNldCAtIE1hdGguc3FydChNYXRoLm1heChjb3JuZXJSYWRpdXMgKiogMiAtICh0cmFpbGluZ0luc2V0IC0gbGVhZGluZ0VkZ2UpICoqIDIpKTtcbiAgfSBlbHNlIGlmIChsZWFkaW5nMCA8IGVwc2lsb24pIHtcbiAgICBsZWFkaW5nMCA9IDA7XG4gIH1cbiAgaWYgKHRyYWlsaW5nMSA+IHRyYWlsaW5nRWRnZSkge1xuICAgIHRyYWlsaW5nQ2xpcHBlZCA9IHRydWU7XG4gICAgdHJhaWxpbmcwID0gdHJhaWxpbmdJbnNldCAtIE1hdGguc3FydChNYXRoLm1heChjb3JuZXJSYWRpdXMgKiogMiAtIChsZWFkaW5nSW5zZXQgLSB0cmFpbGluZ0VkZ2UpICoqIDIpKTtcbiAgICB0cmFpbGluZzEgPSB0cmFpbGluZ0VkZ2U7XG4gIH0gZWxzZSBpZiAodHJhaWxpbmcxIDwgZXBzaWxvbikge1xuICAgIHRyYWlsaW5nMSA9IDA7XG4gIH1cbiAgcmV0dXJuIHsgbGVhZGluZzAsIGxlYWRpbmcxLCB0cmFpbGluZzAsIHRyYWlsaW5nMSwgbGVhZGluZ0NsaXBwZWQsIHRyYWlsaW5nQ2xpcHBlZCB9O1xufTtcbnZhciBpbnNldENvcm5lclJhZGl1c1JlY3QgPSAocGF0aCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgY29ybmVyUmFkaWksIGNsaXBCQm94KSA9PiB7XG4gIGxldCB7XG4gICAgdG9wTGVmdDogdG9wTGVmdENvcm5lclJhZGl1cyxcbiAgICB0b3BSaWdodDogdG9wUmlnaHRDb3JuZXJSYWRpdXMsXG4gICAgYm90dG9tUmlnaHQ6IGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzLFxuICAgIGJvdHRvbUxlZnQ6IGJvdHRvbUxlZnRDb3JuZXJSYWRpdXNcbiAgfSA9IGNvcm5lclJhZGlpO1xuICBjb25zdCBtYXhWZXJ0aWNhbENvcm5lclJhZGl1cyA9IE1hdGgubWF4KFxuICAgIHRvcExlZnRDb3JuZXJSYWRpdXMgKyBib3R0b21MZWZ0Q29ybmVyUmFkaXVzLFxuICAgIHRvcFJpZ2h0Q29ybmVyUmFkaXVzICsgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXNcbiAgKTtcbiAgY29uc3QgbWF4SG9yaXpvbnRhbENvcm5lclJhZGl1cyA9IE1hdGgubWF4KFxuICAgIHRvcExlZnRDb3JuZXJSYWRpdXMgKyB0b3BSaWdodENvcm5lclJhZGl1cyxcbiAgICBib3R0b21MZWZ0Q29ybmVyUmFkaXVzICsgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXNcbiAgKTtcbiAgaWYgKG1heFZlcnRpY2FsQ29ybmVyUmFkaXVzIDw9IDAgJiYgbWF4SG9yaXpvbnRhbENvcm5lclJhZGl1cyA8PSAwKSB7XG4gICAgaWYgKGNsaXBCQm94ID09IG51bGwpIHtcbiAgICAgIHBhdGgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aC5yZWN0KGNsaXBCQm94LngsIGNsaXBCQm94LnksIGNsaXBCQm94LndpZHRoLCBjbGlwQkJveC5oZWlnaHQpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoY2xpcEJCb3ggPT0gbnVsbCAmJiB0b3BMZWZ0Q29ybmVyUmFkaXVzID09PSB0b3BSaWdodENvcm5lclJhZGl1cyAmJiB0b3BMZWZ0Q29ybmVyUmFkaXVzID09PSBib3R0b21SaWdodENvcm5lclJhZGl1cyAmJiB0b3BMZWZ0Q29ybmVyUmFkaXVzID09PSBib3R0b21MZWZ0Q29ybmVyUmFkaXVzKSB7XG4gICAgcGF0aC5yb3VuZFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgdG9wTGVmdENvcm5lclJhZGl1cyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh3aWR0aCA8IDApIHtcbiAgICB4ICs9IHdpZHRoO1xuICAgIHdpZHRoID0gTWF0aC5hYnMod2lkdGgpO1xuICB9XG4gIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgeSArPSBoZWlnaHQ7XG4gICAgaGVpZ2h0ID0gTWF0aC5hYnMoaGVpZ2h0KTtcbiAgfVxuICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMClcbiAgICByZXR1cm47XG4gIGlmIChjbGlwQkJveCA9PSBudWxsKSB7XG4gICAgY2xpcEJCb3ggPSBuZXcgQkJveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB4MCA9IE1hdGgubWF4KHgsIGNsaXBCQm94LngpO1xuICAgIGNvbnN0IHgxID0gTWF0aC5taW4oeCArIHdpZHRoLCBjbGlwQkJveC54ICsgY2xpcEJCb3gud2lkdGgpO1xuICAgIGNvbnN0IHkwID0gTWF0aC5tYXgoeSwgY2xpcEJCb3gueSk7XG4gICAgY29uc3QgeTEgPSBNYXRoLm1pbih5ICsgaGVpZ2h0LCBjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0KTtcbiAgICBjbGlwQkJveCA9IG5ldyBCQm94KHgwLCB5MCwgeDEgLSB4MCwgeTEgLSB5MCk7XG4gIH1cbiAgY29uc3QgYm9yZGVyU2NhbGUgPSBNYXRoLm1heChtYXhWZXJ0aWNhbENvcm5lclJhZGl1cyAvIGhlaWdodCwgbWF4SG9yaXpvbnRhbENvcm5lclJhZGl1cyAvIHdpZHRoLCAxKTtcbiAgaWYgKGJvcmRlclNjYWxlID4gMSkge1xuICAgIHRvcExlZnRDb3JuZXJSYWRpdXMgLz0gYm9yZGVyU2NhbGU7XG4gICAgdG9wUmlnaHRDb3JuZXJSYWRpdXMgLz0gYm9yZGVyU2NhbGU7XG4gICAgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMgLz0gYm9yZGVyU2NhbGU7XG4gICAgYm90dG9tTGVmdENvcm5lclJhZGl1cyAvPSBib3JkZXJTY2FsZTtcbiAgfVxuICBsZXQgZHJhd1RvcExlZnRDb3JuZXIgPSB0cnVlO1xuICBsZXQgZHJhd1RvcFJpZ2h0Q29ybmVyID0gdHJ1ZTtcbiAgbGV0IGRyYXdCb3R0b21SaWdodENvcm5lciA9IHRydWU7XG4gIGxldCBkcmF3Qm90dG9tTGVmdENvcm5lciA9IHRydWU7XG4gIGxldCB0b3BMZWZ0Q29ybmVyO1xuICBsZXQgdG9wUmlnaHRDb3JuZXI7XG4gIGxldCBib3R0b21SaWdodENvcm5lcjtcbiAgbGV0IGJvdHRvbUxlZnRDb3JuZXI7XG4gIGlmIChkcmF3VG9wTGVmdENvcm5lcikge1xuICAgIGNvbnN0IG5vZGVzID0gY29ybmVyRWRnZXMoXG4gICAgICBjbGlwQkJveC5oZWlnaHQsXG4gICAgICBjbGlwQkJveC53aWR0aCxcbiAgICAgIE1hdGgubWF4KHggKyB0b3BMZWZ0Q29ybmVyUmFkaXVzIC0gY2xpcEJCb3gueCwgMCksXG4gICAgICBNYXRoLm1heCh5ICsgdG9wTGVmdENvcm5lclJhZGl1cyAtIGNsaXBCQm94LnksIDApLFxuICAgICAgdG9wTGVmdENvcm5lclJhZGl1c1xuICAgICk7XG4gICAgaWYgKG5vZGVzLmxlYWRpbmdDbGlwcGVkKVxuICAgICAgZHJhd0JvdHRvbUxlZnRDb3JuZXIgPSBmYWxzZTtcbiAgICBpZiAobm9kZXMudHJhaWxpbmdDbGlwcGVkKVxuICAgICAgZHJhd1RvcFJpZ2h0Q29ybmVyID0gZmFsc2U7XG4gICAgY29uc3QgeDAgPSBNYXRoLm1heChjbGlwQkJveC54ICsgbm9kZXMubGVhZGluZzEsIGNsaXBCQm94LngpO1xuICAgIGNvbnN0IHkwID0gTWF0aC5tYXgoY2xpcEJCb3gueSArIG5vZGVzLmxlYWRpbmcwLCBjbGlwQkJveC55KTtcbiAgICBjb25zdCB4MSA9IE1hdGgubWF4KGNsaXBCQm94LnggKyBub2Rlcy50cmFpbGluZzEsIGNsaXBCQm94LngpO1xuICAgIGNvbnN0IHkxID0gTWF0aC5tYXgoY2xpcEJCb3gueSArIG5vZGVzLnRyYWlsaW5nMCwgY2xpcEJCb3gueSk7XG4gICAgY29uc3QgY3ggPSB4ICsgdG9wTGVmdENvcm5lclJhZGl1cztcbiAgICBjb25zdCBjeSA9IHkgKyB0b3BMZWZ0Q29ybmVyUmFkaXVzO1xuICAgIHRvcExlZnRDb3JuZXIgPSB7IHgwLCB5MCwgeDEsIHkxLCBjeCwgY3kgfTtcbiAgfVxuICBpZiAoZHJhd1RvcFJpZ2h0Q29ybmVyKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBjb3JuZXJFZGdlcyhcbiAgICAgIGNsaXBCQm94LndpZHRoLFxuICAgICAgY2xpcEJCb3guaGVpZ2h0LFxuICAgICAgTWF0aC5tYXgoeSArIHRvcFJpZ2h0Q29ybmVyUmFkaXVzIC0gY2xpcEJCb3gueSwgMCksXG4gICAgICBNYXRoLm1heChjbGlwQkJveC54ICsgY2xpcEJCb3gud2lkdGggLSAoeCArIHdpZHRoIC0gdG9wUmlnaHRDb3JuZXJSYWRpdXMpLCAwKSxcbiAgICAgIHRvcFJpZ2h0Q29ybmVyUmFkaXVzXG4gICAgKTtcbiAgICBpZiAobm9kZXMubGVhZGluZ0NsaXBwZWQpXG4gICAgICBkcmF3VG9wTGVmdENvcm5lciA9IGZhbHNlO1xuICAgIGlmIChub2Rlcy50cmFpbGluZ0NsaXBwZWQpXG4gICAgICBkcmF3Qm90dG9tUmlnaHRDb3JuZXIgPSBmYWxzZTtcbiAgICBjb25zdCB4MCA9IE1hdGgubWluKGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCAtIG5vZGVzLmxlYWRpbmcwLCBjbGlwQkJveC54ICsgY2xpcEJCb3gud2lkdGgpO1xuICAgIGNvbnN0IHkwID0gTWF0aC5tYXgoY2xpcEJCb3gueSArIG5vZGVzLmxlYWRpbmcxLCBjbGlwQkJveC55KTtcbiAgICBjb25zdCB4MSA9IE1hdGgubWluKGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCAtIG5vZGVzLnRyYWlsaW5nMCwgY2xpcEJCb3gueCArIGNsaXBCQm94LndpZHRoKTtcbiAgICBjb25zdCB5MSA9IE1hdGgubWF4KGNsaXBCQm94LnkgKyBub2Rlcy50cmFpbGluZzEsIGNsaXBCQm94LnkpO1xuICAgIGNvbnN0IGN4ID0geCArIHdpZHRoIC0gdG9wUmlnaHRDb3JuZXJSYWRpdXM7XG4gICAgY29uc3QgY3kgPSB5ICsgdG9wUmlnaHRDb3JuZXJSYWRpdXM7XG4gICAgdG9wUmlnaHRDb3JuZXIgPSB7IHgwLCB5MCwgeDEsIHkxLCBjeCwgY3kgfTtcbiAgfVxuICBpZiAoZHJhd0JvdHRvbVJpZ2h0Q29ybmVyKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBjb3JuZXJFZGdlcyhcbiAgICAgIGNsaXBCQm94LmhlaWdodCxcbiAgICAgIGNsaXBCQm94LndpZHRoLFxuICAgICAgTWF0aC5tYXgoY2xpcEJCb3gueCArIGNsaXBCQm94LndpZHRoIC0gKHggKyB3aWR0aCAtIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzKSwgMCksXG4gICAgICBNYXRoLm1heChjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0IC0gKHkgKyBoZWlnaHQgLSBib3R0b21SaWdodENvcm5lclJhZGl1cyksIDApLFxuICAgICAgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXNcbiAgICApO1xuICAgIGlmIChub2Rlcy5sZWFkaW5nQ2xpcHBlZClcbiAgICAgIGRyYXdUb3BSaWdodENvcm5lciA9IGZhbHNlO1xuICAgIGlmIChub2Rlcy50cmFpbGluZ0NsaXBwZWQpXG4gICAgICBkcmF3Qm90dG9tTGVmdENvcm5lciA9IGZhbHNlO1xuICAgIGNvbnN0IHgwID0gTWF0aC5taW4oY2xpcEJCb3gueCArIGNsaXBCQm94LndpZHRoIC0gbm9kZXMubGVhZGluZzEsIGNsaXBCQm94LnggKyBjbGlwQkJveC53aWR0aCk7XG4gICAgY29uc3QgeTAgPSBNYXRoLm1pbihjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0IC0gbm9kZXMubGVhZGluZzAsIGNsaXBCQm94LnkgKyBjbGlwQkJveC5oZWlnaHQpO1xuICAgIGNvbnN0IHgxID0gTWF0aC5taW4oY2xpcEJCb3gueCArIGNsaXBCQm94LndpZHRoIC0gbm9kZXMudHJhaWxpbmcxLCBjbGlwQkJveC54ICsgY2xpcEJCb3gud2lkdGgpO1xuICAgIGNvbnN0IHkxID0gTWF0aC5taW4oY2xpcEJCb3gueSArIGNsaXBCQm94LmhlaWdodCAtIG5vZGVzLnRyYWlsaW5nMCwgY2xpcEJCb3gueSArIGNsaXBCQm94LmhlaWdodCk7XG4gICAgY29uc3QgY3ggPSB4ICsgd2lkdGggLSBib3R0b21SaWdodENvcm5lclJhZGl1cztcbiAgICBjb25zdCBjeSA9IHkgKyBoZWlnaHQgLSBib3R0b21SaWdodENvcm5lclJhZGl1cztcbiAgICBib3R0b21SaWdodENvcm5lciA9IHsgeDAsIHkwLCB4MSwgeTEsIGN4LCBjeSB9O1xuICB9XG4gIGlmIChkcmF3Qm90dG9tTGVmdENvcm5lcikge1xuICAgIGNvbnN0IG5vZGVzID0gY29ybmVyRWRnZXMoXG4gICAgICBjbGlwQkJveC53aWR0aCxcbiAgICAgIGNsaXBCQm94LmhlaWdodCxcbiAgICAgIE1hdGgubWF4KGNsaXBCQm94LnkgKyBjbGlwQkJveC5oZWlnaHQgLSAoeSArIGhlaWdodCAtIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXMpLCAwKSxcbiAgICAgIE1hdGgubWF4KHggKyBib3R0b21MZWZ0Q29ybmVyUmFkaXVzIC0gY2xpcEJCb3gueCwgMCksXG4gICAgICBib3R0b21MZWZ0Q29ybmVyUmFkaXVzXG4gICAgKTtcbiAgICBpZiAobm9kZXMubGVhZGluZ0NsaXBwZWQpXG4gICAgICBkcmF3Qm90dG9tUmlnaHRDb3JuZXIgPSBmYWxzZTtcbiAgICBpZiAobm9kZXMudHJhaWxpbmdDbGlwcGVkKVxuICAgICAgZHJhd1RvcExlZnRDb3JuZXIgPSBmYWxzZTtcbiAgICBjb25zdCB4MCA9IE1hdGgubWF4KGNsaXBCQm94LnggKyBub2Rlcy5sZWFkaW5nMCwgY2xpcEJCb3gueCk7XG4gICAgY29uc3QgeTAgPSBNYXRoLm1pbihjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0IC0gbm9kZXMubGVhZGluZzEsIGNsaXBCQm94LnkgKyBjbGlwQkJveC5oZWlnaHQpO1xuICAgIGNvbnN0IHgxID0gTWF0aC5tYXgoY2xpcEJCb3gueCArIG5vZGVzLnRyYWlsaW5nMCwgY2xpcEJCb3gueCk7XG4gICAgY29uc3QgeTEgPSBNYXRoLm1pbihjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0IC0gbm9kZXMudHJhaWxpbmcxLCBjbGlwQkJveC55ICsgY2xpcEJCb3guaGVpZ2h0KTtcbiAgICBjb25zdCBjeCA9IHggKyBib3R0b21MZWZ0Q29ybmVyUmFkaXVzO1xuICAgIGNvbnN0IGN5ID0geSArIGhlaWdodCAtIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXM7XG4gICAgYm90dG9tTGVmdENvcm5lciA9IHsgeDAsIHkwLCB4MSwgeTEsIGN4LCBjeSB9O1xuICB9XG4gIGxldCBkaWRNb3ZlID0gZmFsc2U7XG4gIGlmIChkcmF3VG9wTGVmdENvcm5lciAmJiB0b3BMZWZ0Q29ybmVyICE9IG51bGwpIHtcbiAgICBkcmF3Q29ybmVyKHBhdGgsIHRvcExlZnRDb3JuZXIsIHRvcExlZnRDb3JuZXJSYWRpdXMsICFkaWRNb3ZlKTtcbiAgICBkaWRNb3ZlIHx8IChkaWRNb3ZlID0gdHJ1ZSk7XG4gIH1cbiAgaWYgKGRyYXdUb3BSaWdodENvcm5lciAmJiB0b3BSaWdodENvcm5lciAhPSBudWxsKSB7XG4gICAgZHJhd0Nvcm5lcihwYXRoLCB0b3BSaWdodENvcm5lciwgdG9wUmlnaHRDb3JuZXJSYWRpdXMsICFkaWRNb3ZlKTtcbiAgICBkaWRNb3ZlIHx8IChkaWRNb3ZlID0gdHJ1ZSk7XG4gIH1cbiAgaWYgKGRyYXdCb3R0b21SaWdodENvcm5lciAmJiBib3R0b21SaWdodENvcm5lciAhPSBudWxsKSB7XG4gICAgZHJhd0Nvcm5lcihwYXRoLCBib3R0b21SaWdodENvcm5lciwgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMsICFkaWRNb3ZlKTtcbiAgICBkaWRNb3ZlIHx8IChkaWRNb3ZlID0gdHJ1ZSk7XG4gIH1cbiAgaWYgKGRyYXdCb3R0b21MZWZ0Q29ybmVyICYmIGJvdHRvbUxlZnRDb3JuZXIgIT0gbnVsbCkge1xuICAgIGRyYXdDb3JuZXIocGF0aCwgYm90dG9tTGVmdENvcm5lciwgYm90dG9tTGVmdENvcm5lclJhZGl1cywgIWRpZE1vdmUpO1xuICAgIGRpZE1vdmUgfHwgKGRpZE1vdmUgPSB0cnVlKTtcbiAgfVxuICBwYXRoLmNsb3NlUGF0aCgpO1xufTtcbnZhciBSZWN0ID0gY2xhc3MgZXh0ZW5kcyBQYXRoIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmJvcmRlclBhdGggPSBuZXcgRXh0ZW5kZWRQYXRoMkQoKTtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy53aWR0aCA9IDEwO1xuICAgIHRoaXMuaGVpZ2h0ID0gMTA7XG4gICAgdGhpcy50b3BMZWZ0Q29ybmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLnRvcFJpZ2h0Q29ybmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLmJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLmJvdHRvbUxlZnRDb3JuZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMuY2xpcEJCb3ggPSB2b2lkIDA7XG4gICAgdGhpcy5jcmlzcCA9IGZhbHNlO1xuICAgIHRoaXMubGFzdFVwZGF0ZVBhdGhTdHJva2VXaWR0aCA9IFNoYXBlLmRlZmF1bHRTdHlsZXMuc3Ryb2tlV2lkdGg7XG4gICAgdGhpcy5lZmZlY3RpdmVTdHJva2VXaWR0aCA9IFNoYXBlLmRlZmF1bHRTdHlsZXMuc3Ryb2tlV2lkdGg7XG4gICAgdGhpcy5oaXR0ZXN0ZXIgPSBzdXBlci5pc1BvaW50SW5QYXRoO1xuICAgIHRoaXMuZGlzdGFuY2VDYWxjdWxhdG9yID0gc3VwZXIuZGlzdGFuY2VTcXVhcmVkVHJhbnNmb3JtZWRQb2ludDtcbiAgICAvKipcbiAgICAgKiBXaGVuIHRoZSByZWN0YW5nbGUncyB3aWR0aCBvciBoZWlnaHQgaXMgbGVzcyB0aGFuIGEgcGl4ZWxcbiAgICAgKiBhbmQgY3Jpc3AgbW9kZSBpcyBvbiwgdGhlIHJlY3RhbmdsZSB3aWxsIHN0aWxsIGZpdCBpbnRvIHRoZSBwaXhlbCxcbiAgICAgKiBidXQgd2lsbCBiZSBsZXNzIG9wYXF1ZSB0byBtYWtlIGFuIGVmZmVjdCBvZiBob2xkaW5nIGxlc3Mgc3BhY2UuXG4gICAgICovXG4gICAgdGhpcy5taWNyb1BpeGVsRWZmZWN0T3BhY2l0eSA9IDE7XG4gIH1cbiAgc2V0IGNvcm5lclJhZGl1cyhjb3JuZXJSYWRpdXMpIHtcbiAgICB0aGlzLnRvcExlZnRDb3JuZXJSYWRpdXMgPSBjb3JuZXJSYWRpdXM7XG4gICAgdGhpcy50b3BSaWdodENvcm5lclJhZGl1cyA9IGNvcm5lclJhZGl1cztcbiAgICB0aGlzLmJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzID0gY29ybmVyUmFkaXVzO1xuICAgIHRoaXMuYm90dG9tTGVmdENvcm5lclJhZGl1cyA9IGNvcm5lclJhZGl1cztcbiAgfVxuICBpc0RpcnR5UGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXN0VXBkYXRlUGF0aFN0cm9rZVdpZHRoICE9PSB0aGlzLnN0cm9rZVdpZHRoIHx8IEJvb2xlYW4odGhpcy5wYXRoLmlzRGlydHkoKSB8fCB0aGlzLmJvcmRlclBhdGguaXNEaXJ0eSgpKTtcbiAgfVxuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhdGgsXG4gICAgICBib3JkZXJQYXRoLFxuICAgICAgY3Jpc3AsXG4gICAgICB0b3BMZWZ0Q29ybmVyUmFkaXVzOiB0b3BMZWZ0LFxuICAgICAgdG9wUmlnaHRDb3JuZXJSYWRpdXM6IHRvcFJpZ2h0LFxuICAgICAgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXM6IGJvdHRvbVJpZ2h0LFxuICAgICAgYm90dG9tTGVmdENvcm5lclJhZGl1czogYm90dG9tTGVmdFxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB7IHgsIHksIHdpZHRoOiB3LCBoZWlnaHQ6IGgsIHN0cm9rZVdpZHRoLCBjbGlwQkJveCB9ID0gdGhpcztcbiAgICBjb25zdCBwaXhlbFJhdGlvID0gdGhpcy5sYXllck1hbmFnZXI/LmNhbnZhcy5waXhlbFJhdGlvID8/IDE7XG4gICAgY29uc3QgcGl4ZWxTaXplID0gMSAvIHBpeGVsUmF0aW87XG4gICAgbGV0IG1pY3JvUGl4ZWxFZmZlY3RPcGFjaXR5ID0gMTtcbiAgICBwYXRoLmNsZWFyKHRydWUpO1xuICAgIGJvcmRlclBhdGguY2xlYXIodHJ1ZSk7XG4gICAgaWYgKGNyaXNwKSB7XG4gICAgICBpZiAodyA8PSBwaXhlbFNpemUpIHtcbiAgICAgICAgbWljcm9QaXhlbEVmZmVjdE9wYWNpdHkgKj0gdyAvIHBpeGVsU2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChoIDw9IHBpeGVsU2l6ZSkge1xuICAgICAgICBtaWNyb1BpeGVsRWZmZWN0T3BhY2l0eSAqPSBoIC8gcGl4ZWxTaXplO1xuICAgICAgfVxuICAgICAgdyA9IHRoaXMuYWxpZ24oeCwgdyk7XG4gICAgICBoID0gdGhpcy5hbGlnbih5LCBoKTtcbiAgICAgIHggPSB0aGlzLmFsaWduKHgpO1xuICAgICAgeSA9IHRoaXMuYWxpZ24oeSk7XG4gICAgICBjbGlwQkJveCA9IGNsaXBCQm94ICE9IG51bGwgPyBuZXcgQkJveChcbiAgICAgICAgdGhpcy5hbGlnbihjbGlwQkJveC54KSxcbiAgICAgICAgdGhpcy5hbGlnbihjbGlwQkJveC55KSxcbiAgICAgICAgdGhpcy5hbGlnbihjbGlwQkJveC54LCBjbGlwQkJveC53aWR0aCksXG4gICAgICAgIHRoaXMuYWxpZ24oY2xpcEJCb3gueSwgY2xpcEJCb3guaGVpZ2h0KVxuICAgICAgKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHN0cm9rZVdpZHRoKSB7XG4gICAgICBpZiAodyA8IHBpeGVsU2l6ZSkge1xuICAgICAgICBjb25zdCBseCA9IHggKyBwaXhlbFNpemUgLyAyO1xuICAgICAgICBib3JkZXJQYXRoLm1vdmVUbyhseCwgeSk7XG4gICAgICAgIGJvcmRlclBhdGgubGluZVRvKGx4LCB5ICsgaCk7XG4gICAgICAgIHN0cm9rZVdpZHRoID0gcGl4ZWxTaXplO1xuICAgICAgICB0aGlzLmJvcmRlckNsaXBQYXRoID0gdm9pZCAwO1xuICAgICAgfSBlbHNlIGlmIChoIDwgcGl4ZWxTaXplKSB7XG4gICAgICAgIGNvbnN0IGx5ID0geSArIHBpeGVsU2l6ZSAvIDI7XG4gICAgICAgIGJvcmRlclBhdGgubW92ZVRvKHgsIGx5KTtcbiAgICAgICAgYm9yZGVyUGF0aC5saW5lVG8oeCArIHcsIGx5KTtcbiAgICAgICAgc3Ryb2tlV2lkdGggPSBwaXhlbFNpemU7XG4gICAgICAgIHRoaXMuYm9yZGVyQ2xpcFBhdGggPSB2b2lkIDA7XG4gICAgICB9IGVsc2UgaWYgKHN0cm9rZVdpZHRoIDwgdyAmJiBzdHJva2VXaWR0aCA8IGgpIHtcbiAgICAgICAgY29uc3QgaGFsZlN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGggLyAyO1xuICAgICAgICB4ICs9IGhhbGZTdHJva2VXaWR0aDtcbiAgICAgICAgeSArPSBoYWxmU3Ryb2tlV2lkdGg7XG4gICAgICAgIHcgLT0gc3Ryb2tlV2lkdGg7XG4gICAgICAgIGggLT0gc3Ryb2tlV2lkdGg7XG4gICAgICAgIGNvbnN0IGFkanVzdGVkQ2xpcEJCb3ggPSBjbGlwQkJveD8uY2xvbmUoKS5zaHJpbmsoaGFsZlN0cm9rZVdpZHRoKTtcbiAgICAgICAgY29uc3QgY29ybmVyUmFkaWkgPSB7XG4gICAgICAgICAgdG9wTGVmdDogdG9wTGVmdCA+IDAgPyB0b3BMZWZ0IC0gc3Ryb2tlV2lkdGggOiAwLFxuICAgICAgICAgIHRvcFJpZ2h0OiB0b3BSaWdodCA+IDAgPyB0b3BSaWdodCAtIHN0cm9rZVdpZHRoIDogMCxcbiAgICAgICAgICBib3R0b21SaWdodDogYm90dG9tUmlnaHQgPiAwID8gYm90dG9tUmlnaHQgLSBzdHJva2VXaWR0aCA6IDAsXG4gICAgICAgICAgYm90dG9tTGVmdDogYm90dG9tTGVmdCA+IDAgPyBib3R0b21MZWZ0IC0gc3Ryb2tlV2lkdGggOiAwXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYm9yZGVyQ2xpcFBhdGggPSB2b2lkIDA7XG4gICAgICAgIGlmICh3ID4gMCAmJiBoID4gMCAmJiAoYWRqdXN0ZWRDbGlwQkJveCA9PSBudWxsIHx8IGFkanVzdGVkQ2xpcEJCb3g/LndpZHRoID4gMCAmJiBhZGp1c3RlZENsaXBCQm94Py5oZWlnaHQgPiAwKSkge1xuICAgICAgICAgIGluc2V0Q29ybmVyUmFkaXVzUmVjdChwYXRoLCB4LCB5LCB3LCBoLCBjb3JuZXJSYWRpaSwgYWRqdXN0ZWRDbGlwQkJveCk7XG4gICAgICAgICAgaW5zZXRDb3JuZXJSYWRpdXNSZWN0KGJvcmRlclBhdGgsIHgsIHksIHcsIGgsIGNvcm5lclJhZGlpLCBhZGp1c3RlZENsaXBCQm94KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ib3JkZXJDbGlwUGF0aCA9IHRoaXMuYm9yZGVyQ2xpcFBhdGggPz8gbmV3IEV4dGVuZGVkUGF0aDJEKCk7XG4gICAgICAgIHRoaXMuYm9yZGVyQ2xpcFBhdGguY2xlYXIodHJ1ZSk7XG4gICAgICAgIHRoaXMuYm9yZGVyQ2xpcFBhdGgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICAgICAgYm9yZGVyUGF0aC5yZWN0KHgsIHksIHcsIGgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb3JuZXJSYWRpaSA9IHsgdG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbVJpZ2h0LCBib3R0b21MZWZ0IH07XG4gICAgICB0aGlzLmJvcmRlckNsaXBQYXRoID0gdm9pZCAwO1xuICAgICAgaW5zZXRDb3JuZXJSYWRpdXNSZWN0KHBhdGgsIHgsIHksIHcsIGgsIGNvcm5lclJhZGlpLCBjbGlwQkJveCk7XG4gICAgfVxuICAgIGlmIChbdG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbVJpZ2h0LCBib3R0b21MZWZ0XS5ldmVyeSgocikgPT4gciA9PT0gMCkpIHtcbiAgICAgIHRoaXMuaGl0dGVzdGVyID0gKGhpdFgsIGhpdFkpID0+IHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLnRyYW5zZm9ybVBvaW50KGhpdFgsIGhpdFkpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCQm94KCkuY29udGFpbnNQb2ludChwb2ludC54LCBwb2ludC55KTtcbiAgICAgIH07XG4gICAgICB0aGlzLmRpc3RhbmNlU3F1YXJlZCA9IChoaXRYLCBoaXRZKSA9PiB0aGlzLmdldEJCb3goKS5kaXN0YW5jZVNxdWFyZWQoaGl0WCwgaGl0WSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaGl0dGVzdGVyID0gc3VwZXIuaXNQb2ludEluUGF0aDtcbiAgICAgIHRoaXMuZGlzdGFuY2VDYWxjdWxhdG9yID0gc3VwZXIuZGlzdGFuY2VTcXVhcmVkVHJhbnNmb3JtZWRQb2ludDtcbiAgICB9XG4gICAgdGhpcy5lZmZlY3RpdmVTdHJva2VXaWR0aCA9IHN0cm9rZVdpZHRoO1xuICAgIHRoaXMubGFzdFVwZGF0ZVBhdGhTdHJva2VXaWR0aCA9IHN0cm9rZVdpZHRoO1xuICAgIHRoaXMubWljcm9QaXhlbEVmZmVjdE9wYWNpdHkgPSBtaWNyb1BpeGVsRWZmZWN0T3BhY2l0eTtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQsIGNsaXBCQm94IH0gPSB0aGlzO1xuICAgIHJldHVybiBjbGlwQkJveD8uY2xvbmUoKSA/PyBuZXcgQkJveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICBpc1BvaW50SW5QYXRoKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5oaXR0ZXN0ZXIoeCwgeSk7XG4gIH1cbiAgZ2V0IG1pZFBvaW50KCkge1xuICAgIHJldHVybiB7IHg6IHRoaXMueCArIHRoaXMud2lkdGggLyAyLCB5OiB0aGlzLnkgKyB0aGlzLmhlaWdodCAvIDIgfTtcbiAgfVxuICBkaXN0YW5jZVNxdWFyZWQoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLmRpc3RhbmNlQ2FsY3VsYXRvcih4LCB5KTtcbiAgfVxuICBhcHBseUZpbGxBbHBoYShjdHgpIHtcbiAgICBjb25zdCB7IGZpbGxPcGFjaXR5LCBtaWNyb1BpeGVsRWZmZWN0T3BhY2l0eSwgb3BhY2l0eSB9ID0gdGhpcztcbiAgICBjdHguZ2xvYmFsQWxwaGEgKj0gb3BhY2l0eSAqIGZpbGxPcGFjaXR5ICogbWljcm9QaXhlbEVmZmVjdE9wYWNpdHk7XG4gIH1cbiAgcmVuZGVyU3Ryb2tlKGN0eCkge1xuICAgIGNvbnN0IHsgc3Ryb2tlLCBlZmZlY3RpdmVTdHJva2VXaWR0aCB9ID0gdGhpcztcbiAgICBpZiAoc3Ryb2tlICYmIGVmZmVjdGl2ZVN0cm9rZVdpZHRoKSB7XG4gICAgICBjb25zdCB7IGdsb2JhbEFscGhhIH0gPSBjdHg7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICAgIGxpbmVEYXNoLFxuICAgICAgICBsaW5lRGFzaE9mZnNldCxcbiAgICAgICAgbGluZUNhcCxcbiAgICAgICAgbGluZUpvaW4sXG4gICAgICAgIGJvcmRlclBhdGgsXG4gICAgICAgIGJvcmRlckNsaXBQYXRoLFxuICAgICAgICBvcGFjaXR5LFxuICAgICAgICBtaWNyb1BpeGVsRWZmZWN0T3BhY2l0eVxuICAgICAgfSA9IHRoaXM7XG4gICAgICBpZiAoYm9yZGVyQ2xpcFBhdGgpIHtcbiAgICAgICAgY3R4LmNsaXAoYm9yZGVyQ2xpcFBhdGguZ2V0UGF0aDJEKCkpO1xuICAgICAgfVxuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhICo9IG9wYWNpdHkgKiBzdHJva2VPcGFjaXR5ICogbWljcm9QaXhlbEVmZmVjdE9wYWNpdHk7XG4gICAgICBjdHgubGluZVdpZHRoID0gZWZmZWN0aXZlU3Ryb2tlV2lkdGg7XG4gICAgICBpZiAobGluZURhc2gpIHtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKGxpbmVEYXNoKTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lRGFzaE9mZnNldCkge1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBsaW5lRGFzaE9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lQ2FwKSB7XG4gICAgICAgIGN0eC5saW5lQ2FwID0gbGluZUNhcDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lSm9pbikge1xuICAgICAgICBjdHgubGluZUpvaW4gPSBsaW5lSm9pbjtcbiAgICAgIH1cbiAgICAgIGN0eC5zdHJva2UoYm9yZGVyUGF0aC5nZXRQYXRoMkQoKSk7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBnbG9iYWxBbHBoYTtcbiAgICB9XG4gIH1cbn07XG5SZWN0LmNsYXNzTmFtZSA9IFwiUmVjdFwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJlY3QucHJvdG90eXBlLCBcInhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmVjdC5wcm90b3R5cGUsIFwieVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJ3aWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmVjdC5wcm90b3R5cGUsIFwidG9wTGVmdENvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJ0b3BSaWdodENvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJib3R0b21SaWdodENvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSZWN0LnByb3RvdHlwZSwgXCJib3R0b21MZWZ0Q29ybmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJlY3QucHJvdG90eXBlLCBcImNsaXBCQm94XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJlY3QucHJvdG90eXBlLCBcImNyaXNwXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9iYWNrZ3JvdW5kL2JhY2tncm91bmQudHNcbnZhciBCYWNrZ3JvdW5kID0gY2xhc3MgZXh0ZW5kcyBCYXNlTW9kdWxlSW5zdGFuY2Uge1xuICBjb25zdHJ1Y3RvcihjdHgsIHpJbmRleCA9IDAgLyogU0VSSUVTX0JBQ0tHUk9VTkRfWklOREVYICovLCBsYXllciA9IGZhbHNlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnpJbmRleCA9IHpJbmRleDtcbiAgICB0aGlzLmxheWVyID0gbGF5ZXI7XG4gICAgdGhpcy5yZWN0Tm9kZSA9IG5ldyBSZWN0KCk7XG4gICAgdGhpcy50ZXh0Tm9kZSA9IG5ldyBUZXh0KCk7XG4gICAgdGhpcy5maWxsID0gXCJ3aGl0ZVwiO1xuICAgIHRoaXMubm9kZSA9IG5ldyBHcm91cCh7IG5hbWU6IFwiYmFja2dyb3VuZFwiLCB6SW5kZXg6IHRoaXMuekluZGV4LCBsYXllcjogdGhpcy5sYXllciB9KTtcbiAgICB0aGlzLm5vZGUuYXBwZW5kKFt0aGlzLnJlY3ROb2RlLCB0aGlzLnRleHROb2RlXSk7XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIGN0eC5zY2VuZS5hdHRhY2hOb2RlKHRoaXMubm9kZSksXG4gICAgICBjdHgubGF5b3V0U2VydmljZS5hZGRMaXN0ZW5lcihcImxheW91dC1jb21wbGV0ZVwiLCAoZSkgPT4gdGhpcy5vbkxheW91dENvbXBsZXRlKGUpKVxuICAgICk7XG4gIH1cbiAgb25MYXlvdXRDb21wbGV0ZShlKSB7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBlLmNoYXJ0O1xuICAgIHRoaXMucmVjdE5vZGUud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLnJlY3ROb2RlLmhlaWdodCA9IGhlaWdodDtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pLFxuICBQcm94eVByb3BlcnR5T25Xcml0ZShcIm5vZGVcIiwgXCJ2aXNpYmxlXCIpXG5dLCBCYWNrZ3JvdW5kLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pLFxuICBQcm94eVByb3BlcnR5T25Xcml0ZShcInJlY3ROb2RlXCIsIFwiZmlsbFwiKVxuXSwgQmFja2dyb3VuZC5wcm90b3R5cGUsIFwiZmlsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVCwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQmFja2dyb3VuZC5wcm90b3R5cGUsIFwiaW1hZ2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwidGV4dE5vZGVcIilcbl0sIEJhY2tncm91bmQucHJvdG90eXBlLCBcInRleHRcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2JhY2tncm91bmQvYmFja2dyb3VuZE1vZHVsZS50c1xudmFyIEJhY2tncm91bmRNb2R1bGUgPSB7XG4gIHR5cGU6IFwicm9vdFwiLFxuICBvcHRpb25zS2V5OiBcImJhY2tncm91bmRcIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiLCBcInBvbGFyXCIsIFwiaGllcmFyY2h5XCIsIFwidG9wb2xvZ3lcIiwgXCJmbG93LXByb3BvcnRpb25cIl0sXG4gIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBCYWNrZ3JvdW5kKGN0eClcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3Nwcml0ZVJlbmRlcmVyLnRzXG52YXIgU3ByaXRlUmVuZGVyZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMub2Zmc2NyZWVuQ2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcygxLCAxKTtcbiAgICBjb25zdCBjdHggPSB0aGlzLm9mZnNjcmVlbkNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaWYgKGN0eCA9PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQUcgQ2hhcnRzIC0gaW52YWxpZCAyZCBjb250ZXh0YCk7XG4gICAgdGhpcy5yZW5kZXJDdHggPSB7XG4gICAgICBjdHgsXG4gICAgICBkZXZpY2VQaXhlbFJhdGlvOiAxLFxuICAgICAgZm9yY2VSZW5kZXI6IHRydWUsXG4gICAgICByZXNpemVkOiBmYWxzZSxcbiAgICAgIGRlYnVnTm9kZXM6IHt9XG4gICAgfTtcbiAgfVxuICByZXNpemUoeyBzcHJpdGVQaXhlbFJhdGlvLCBzcHJpdGVXaWR0aCwgc3ByaXRlSGVpZ2h0IH0pIHtcbiAgICB0aGlzLm9mZnNjcmVlbkNhbnZhcy53aWR0aCA9IE1hdGgubWF4KHNwcml0ZVdpZHRoLCAwKSAqIHNwcml0ZVBpeGVsUmF0aW87XG4gICAgdGhpcy5vZmZzY3JlZW5DYW52YXMuaGVpZ2h0ID0gTWF0aC5tYXgoc3ByaXRlSGVpZ2h0LCAwKSAqIHNwcml0ZVBpeGVsUmF0aW87XG4gIH1cbiAgcmVuZGVyU3ByaXRlKG5vZGVzLCBvcHRzKSB7XG4gICAgbm9kZXMgPSB0b0l0ZXJhYmxlKG5vZGVzKTtcbiAgICBjb25zdCB7XG4gICAgICByZW5kZXJDdHgsXG4gICAgICByZW5kZXJDdHg6IHsgY3R4IH0sXG4gICAgICBvZmZzY3JlZW5DYW52YXNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7IHNjYWxlOiBzY2FsZTIgPSAxLCB0cmFuc2xhdGVYID0gMCwgdHJhbnNsYXRlWSA9IDAgfSA9IG9wdHMgPz8ge307XG4gICAgY3R4LnJlc2V0VHJhbnNmb3JtKCk7XG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCBvZmZzY3JlZW5DYW52YXMud2lkdGgsIG9mZnNjcmVlbkNhbnZhcy5oZWlnaHQpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oc2NhbGUyLCAwLCAwLCBzY2FsZTIsIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVkpO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgbm9kZS5yZW5kZXIocmVuZGVyQ3R4KTtcbiAgICB9XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgcmV0dXJuIG9mZnNjcmVlbkNhbnZhcy50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9rZXluYXZVdGlsLnRzXG5mdW5jdGlvbiBhZGRSZW1vdmFibGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIGJ1dHRvbiwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpO1xuICBkZXN0cm95Rm5zLnB1c2goKCkgPT4gYnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpKTtcbn1cbmZ1bmN0aW9uIGFkZEVzY2FwZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgZWxlbSwgb25Fc2NhcGUpIHtcbiAgYWRkUmVtb3ZhYmxlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBlbGVtLCBcImtleWRvd25cIiwgKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgb25Fc2NhcGUoZXZlbnQpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBtYXRjaGVzS2V5KGV2ZW50LCBrZXksIC4uLm1vcmVrZXlzKSB7XG4gIHJldHVybiAhKGV2ZW50LnNoaWZ0S2V5IHx8IGV2ZW50LmFsdEtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50Lm1ldGFLZXkpICYmIChldmVudC5rZXkgPT09IGtleSB8fCBtb3Jla2V5cy5zb21lKChhbHRrZXkpID0+IGV2ZW50LmtleSA9PT0gYWx0a2V5KSk7XG59XG5mdW5jdGlvbiBsaW5rVHdvQnV0dG9ucyhkZXN0cm95Rm5zLCBzcmMsIGRzdCwga2V5KSB7XG4gIGlmICghZHN0KVxuICAgIHJldHVybjtcbiAgYWRkUmVtb3ZhYmxlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBzcmMsIFwia2V5ZG93blwiLCAoZXZlbnQpID0+IHtcbiAgICBpZiAobWF0Y2hlc0tleShldmVudCwga2V5KSkge1xuICAgICAgZHN0LmZvY3VzKCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGxpbmtUaHJlZUJ1dHRvbnMoZGVzdHJveUZucywgY3VyciwgbmV4dCwgbmV4dEtleSwgcHJldiwgcHJldktleSkge1xuICBsaW5rVHdvQnV0dG9ucyhkZXN0cm95Rm5zLCBjdXJyLCBwcmV2LCBwcmV2S2V5KTtcbiAgbGlua1R3b0J1dHRvbnMoZGVzdHJveUZucywgY3VyciwgbmV4dCwgbmV4dEtleSk7XG4gIGFkZFJlbW92YWJsZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgY3VyciwgXCJrZXlkb3duXCIsIChldmVudCkgPT4ge1xuICAgIGlmIChtYXRjaGVzS2V5KGV2ZW50LCBuZXh0S2V5LCBwcmV2S2V5KSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH0pO1xufVxudmFyIFBSRVZfTkVYVF9LRVlTID0ge1xuICBob3Jpem9udGFsOiB7IG5leHRLZXk6IFwiQXJyb3dSaWdodFwiLCBwcmV2S2V5OiBcIkFycm93TGVmdFwiIH0sXG4gIHZlcnRpY2FsOiB7IG5leHRLZXk6IFwiQXJyb3dEb3duXCIsIHByZXZLZXk6IFwiQXJyb3dVcFwiIH1cbn07XG5mdW5jdGlvbiBpbml0VG9vbGJhcktleU5hdihvcHRzKSB7XG4gIGNvbnN0IHsgb3JpZW50YXRpb24sIHRvb2xiYXIsIGJ1dHRvbnMsIG9uRXNjYXBlLCBvbkZvY3VzLCBvbkJsdXIgfSA9IG9wdHM7XG4gIGNvbnN0IHsgbmV4dEtleSwgcHJldktleSB9ID0gUFJFVl9ORVhUX0tFWVNbb3JpZW50YXRpb25dO1xuICBjb25zdCBhcmlhSGlkZGVuID0gYnV0dG9ucy5sZW5ndGggPT09IDA7XG4gIHRvb2xiYXIucm9sZSA9IFwidG9vbGJhclwiO1xuICB0b29sYmFyLmFyaWFPcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xuICB0b29sYmFyLmFyaWFIaWRkZW4gPSBhcmlhSGlkZGVuLnRvU3RyaW5nKCk7XG4gIGNvbnN0IHNldFRhYkluZGljZXMgPSAoZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICYmIFwidGFiSW5kZXhcIiBpbiBldmVudC50YXJnZXQpIHtcbiAgICAgIGJ1dHRvbnMuZm9yRWFjaCgoYikgPT4gYi50YWJJbmRleCA9IC0xKTtcbiAgICAgIGV2ZW50LnRhcmdldC50YWJJbmRleCA9IDA7XG4gICAgfVxuICB9O1xuICBjb25zdCBkZXN0cm95Rm5zID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnV0dG9ucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHByZXYgPSBidXR0b25zW2kgLSAxXTtcbiAgICBjb25zdCBjdXJyID0gYnV0dG9uc1tpXTtcbiAgICBjb25zdCBuZXh0ID0gYnV0dG9uc1tpICsgMV07XG4gICAgYWRkUmVtb3ZhYmxlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBjdXJyLCBcImZvY3VzXCIsIHNldFRhYkluZGljZXMpO1xuICAgIGlmIChvbkZvY3VzKVxuICAgICAgYWRkUmVtb3ZhYmxlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBjdXJyLCBcImZvY3VzXCIsIG9uRm9jdXMpO1xuICAgIGlmIChvbkJsdXIpXG4gICAgICBhZGRSZW1vdmFibGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIGN1cnIsIFwiYmx1clwiLCBvbkJsdXIpO1xuICAgIGlmIChvbkVzY2FwZSlcbiAgICAgIGFkZEVzY2FwZUV2ZW50TGlzdGVuZXIoZGVzdHJveUZucywgY3Vyciwgb25Fc2NhcGUpO1xuICAgIGxpbmtUaHJlZUJ1dHRvbnMoZGVzdHJveUZucywgY3VyciwgcHJldiwgcHJldktleSwgbmV4dCwgbmV4dEtleSk7XG4gICAgY3Vyci50YWJJbmRleCA9IGkgPT09IDAgPyAwIDogLTE7XG4gIH1cbiAgcmV0dXJuIGRlc3Ryb3lGbnM7XG59XG5mdW5jdGlvbiBpbml0TWVudUtleU5hdihvcHRzKSB7XG4gIGNvbnN0IHsgb3JpZW50YXRpb24sIG1lbnUsIGJ1dHRvbnMsIG9uRXNjYXBlIH0gPSBvcHRzO1xuICBjb25zdCB7IG5leHRLZXksIHByZXZLZXkgfSA9IFBSRVZfTkVYVF9LRVlTW29yaWVudGF0aW9uXTtcbiAgbWVudS5yb2xlID0gXCJtZW51XCI7XG4gIG1lbnUuYXJpYU9yaWVudGF0aW9uID0gb3JpZW50YXRpb247XG4gIGNvbnN0IGRlc3Ryb3lGbnMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidXR0b25zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcHJldiA9IGJ1dHRvbnNbKGJ1dHRvbnMubGVuZ3RoICsgaSAtIDEpICUgYnV0dG9ucy5sZW5ndGhdO1xuICAgIGNvbnN0IGN1cnIgPSBidXR0b25zW2ldO1xuICAgIGNvbnN0IG5leHQgPSBidXR0b25zWyhidXR0b25zLmxlbmd0aCArIGkgKyAxKSAlIGJ1dHRvbnMubGVuZ3RoXTtcbiAgICBpZiAob25Fc2NhcGUpXG4gICAgICBhZGRFc2NhcGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIGN1cnIsIG9uRXNjYXBlKTtcbiAgICBsaW5rVGhyZWVCdXR0b25zKGRlc3Ryb3lGbnMsIGN1cnIsIHByZXYsIHByZXZLZXksIG5leHQsIG5leHRLZXkpO1xuICAgIGN1cnIudGFiSW5kZXggPSAtMTtcbiAgfVxuICBtZW51LnRhYkluZGV4ID0gLTE7XG4gIGlmIChvbkVzY2FwZSlcbiAgICBhZGRFc2NhcGVFdmVudExpc3RlbmVyKGRlc3Ryb3lGbnMsIG1lbnUsIG9uRXNjYXBlKTtcbiAgYWRkUmVtb3ZhYmxlRXZlbnRMaXN0ZW5lcihkZXN0cm95Rm5zLCBtZW51LCBcImtleWRvd25cIiwgKGV2KSA9PiB7XG4gICAgaWYgKGV2LnRhcmdldCA9PT0gbWVudSAmJiAoZXYua2V5ID09PSBuZXh0S2V5IHx8IGV2LmtleSA9PT0gcHJldktleSkpIHtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBidXR0b25zWzBdPy5mb2N1cygpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkZXN0cm95Rm5zO1xufVxuZnVuY3Rpb24gbWFrZUFjY2Vzc2libGVDbGlja0xpc3RlbmVyKGVsZW1lbnQyLCBvbmNsaWNrKSB7XG4gIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICBpZiAoZWxlbWVudDIuYXJpYURpc2FibGVkID09PSBcInRydWVcIikge1xuICAgICAgcmV0dXJuIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIG9uY2xpY2soZXZlbnQpO1xuICB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9ncmlkTGF5b3V0LnRzXG5mdW5jdGlvbiBncmlkTGF5b3V0KHtcbiAgb3JpZW50YXRpb24sXG4gIGJib3hlcyxcbiAgbWF4SGVpZ2h0LFxuICBtYXhXaWR0aCxcbiAgaXRlbVBhZGRpbmdZID0gMCxcbiAgaXRlbVBhZGRpbmdYID0gMCxcbiAgZm9yY2VSZXN1bHQgPSBmYWxzZVxufSkge1xuICBjb25zdCBob3Jpem9udGFsID0gb3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiO1xuICBjb25zdCBwcmltYXJ5ID0ge1xuICAgIG1heDogaG9yaXpvbnRhbCA/IG1heFdpZHRoIDogbWF4SGVpZ2h0LFxuICAgIGZuOiBob3Jpem9udGFsID8gKGIpID0+IGIud2lkdGggOiAoYikgPT4gYi5oZWlnaHQsXG4gICAgcGFkZGluZzogaG9yaXpvbnRhbCA/IGl0ZW1QYWRkaW5nWCA6IGl0ZW1QYWRkaW5nWVxuICB9O1xuICBjb25zdCBzZWNvbmRhcnkgPSB7XG4gICAgbWF4OiBob3Jpem9udGFsID8gbWF4SGVpZ2h0IDogbWF4V2lkdGgsXG4gICAgZm46IGhvcml6b250YWwgPyAoYikgPT4gYi5oZWlnaHQgOiAoYikgPT4gYi53aWR0aCxcbiAgICBwYWRkaW5nOiBob3Jpem9udGFsID8gaXRlbVBhZGRpbmdZIDogaXRlbVBhZGRpbmdYXG4gIH07XG4gIGxldCBwcm9jZXNzZWRCQm94Q291bnQgPSAwO1xuICBjb25zdCByYXdQYWdlcyA9IFtdO1xuICB3aGlsZSAocHJvY2Vzc2VkQkJveENvdW50IDwgYmJveGVzLmxlbmd0aCkge1xuICAgIGNvbnN0IHVucHJvY2Vzc2VkQkJveGVzID0gYmJveGVzLnNsaWNlKHByb2Nlc3NlZEJCb3hDb3VudCk7XG4gICAgY29uc3QgcmVzdWx0ID0gcHJvY2Vzc0JCb3hlcyh1bnByb2Nlc3NlZEJCb3hlcywgcHJvY2Vzc2VkQkJveENvdW50LCBwcmltYXJ5LCBzZWNvbmRhcnksIGZvcmNlUmVzdWx0KTtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBwcm9jZXNzZWRCQm94Q291bnQgKz0gcmVzdWx0LnByb2Nlc3NlZEJCb3hDb3VudDtcbiAgICByYXdQYWdlcy5wdXNoKHJlc3VsdC5wYWdlSW5kaWNlcyk7XG4gIH1cbiAgcmV0dXJuIGJ1aWxkUGFnZXMocmF3UGFnZXMsIG9yaWVudGF0aW9uLCBiYm94ZXMsIGl0ZW1QYWRkaW5nWSwgaXRlbVBhZGRpbmdYKTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NCQm94ZXMoYmJveGVzLCBpbmRleE9mZnNldCwgcHJpbWFyeSwgc2Vjb25kYXJ5LCBmb3JjZVJlc3VsdCkge1xuICBjb25zdCBtaW5HdWVzcyA9IDE7XG4gIGxldCBzdGFydGluZ0d1ZXNzID0gZXN0aW1hdGVTdGFydGluZ0d1ZXNzKGJib3hlcywgcHJpbWFyeSk7XG4gIGlmIChzdGFydGluZ0d1ZXNzIDwgbWluR3Vlc3MpIHtcbiAgICBpZiAoIWZvcmNlUmVzdWx0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0YXJ0aW5nR3Vlc3MgPSBtaW5HdWVzcztcbiAgfVxuICBsZXQgZ3Vlc3MgPSBzdGFydGluZ0d1ZXNzO1xuICB3aGlsZSAoZ3Vlc3MgPj0gbWluR3Vlc3MpIHtcbiAgICBjb25zdCBwYWdlSW5kaWNlcyA9IGNhbGN1bGF0ZVBhZ2UoYmJveGVzLCBpbmRleE9mZnNldCwgZ3Vlc3MsIHByaW1hcnksIHNlY29uZGFyeSwgZm9yY2VSZXN1bHQpO1xuICAgIGlmIChwYWdlSW5kaWNlcyA9PSBudWxsICYmIGd1ZXNzIDw9IG1pbkd1ZXNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwYWdlSW5kaWNlcyA9PSBudWxsKSB7XG4gICAgICBndWVzcy0tO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcGFnZUluZGljZXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIGlmIChwYWdlSW5kaWNlcyA8PSBtaW5HdWVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBndWVzcyA9IHBhZ2VJbmRpY2VzIDwgZ3Vlc3MgJiYgcGFnZUluZGljZXMgPiBtaW5HdWVzcyA/IHBhZ2VJbmRpY2VzIDogZ3Vlc3M7XG4gICAgICBndWVzcy0tO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHByb2Nlc3NlZEJCb3hDb3VudCA9IHBhZ2VJbmRpY2VzLmxlbmd0aCAqIHBhZ2VJbmRpY2VzWzBdLmxlbmd0aDtcbiAgICByZXR1cm4geyBwcm9jZXNzZWRCQm94Q291bnQsIHBhZ2VJbmRpY2VzIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVBhZ2UoYmJveGVzLCBpbmRleE9mZnNldCwgcHJpbWFyeUNvdW50LCBwcmltYXJ5LCBzZWNvbmRhcnksIGZvcmNlUmVzdWx0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBsZXQgc3VtU2Vjb25kYXJ5ID0gMDtcbiAgbGV0IGN1cnJlbnRNYXhTZWNvbmRhcnkgPSAwO1xuICBsZXQgY3VycmVudFByaW1hcnlJbmRpY2VzID0gW107XG4gIGNvbnN0IG1heFByaW1hcnlWYWx1ZXMgPSBbXTtcbiAgZm9yIChsZXQgYmJveEluZGV4ID0gMDsgYmJveEluZGV4IDwgYmJveGVzLmxlbmd0aDsgYmJveEluZGV4KyspIHtcbiAgICBjb25zdCBwcmltYXJ5VmFsdWVJZHggPSAoYmJveEluZGV4ICsgcHJpbWFyeUNvdW50KSAlIHByaW1hcnlDb3VudDtcbiAgICBpZiAocHJpbWFyeVZhbHVlSWR4ID09PSAwKSB7XG4gICAgICBzdW1TZWNvbmRhcnkgKz0gY3VycmVudE1heFNlY29uZGFyeTtcbiAgICAgIGN1cnJlbnRNYXhTZWNvbmRhcnkgPSAwO1xuICAgICAgaWYgKGN1cnJlbnRQcmltYXJ5SW5kaWNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnRQcmltYXJ5SW5kaWNlcyk7XG4gICAgICB9XG4gICAgICBjdXJyZW50UHJpbWFyeUluZGljZXMgPSBbXTtcbiAgICB9XG4gICAgY29uc3QgcHJpbWFyeVZhbHVlID0gcHJpbWFyeS5mbihiYm94ZXNbYmJveEluZGV4XSkgKyBwcmltYXJ5LnBhZGRpbmc7XG4gICAgbWF4UHJpbWFyeVZhbHVlc1twcmltYXJ5VmFsdWVJZHhdID0gTWF0aC5tYXgobWF4UHJpbWFyeVZhbHVlc1twcmltYXJ5VmFsdWVJZHhdID8/IDAsIHByaW1hcnlWYWx1ZSk7XG4gICAgY3VycmVudE1heFNlY29uZGFyeSA9IE1hdGgubWF4KGN1cnJlbnRNYXhTZWNvbmRhcnksIHNlY29uZGFyeS5mbihiYm94ZXNbYmJveEluZGV4XSkgKyBzZWNvbmRhcnkucGFkZGluZyk7XG4gICAgY29uc3QgY3VycmVudFNlY29uZGFyeURpbWVuc2lvbiA9IHN1bVNlY29uZGFyeSArIGN1cnJlbnRNYXhTZWNvbmRhcnk7XG4gICAgY29uc3QgcmV0dXJuUmVzdWx0ID0gIWZvcmNlUmVzdWx0IHx8IHJlc3VsdC5sZW5ndGggPiAwO1xuICAgIGlmIChjdXJyZW50U2Vjb25kYXJ5RGltZW5zaW9uID4gc2Vjb25kYXJ5Lm1heCAmJiByZXR1cm5SZXN1bHQpIHtcbiAgICAgIGN1cnJlbnRQcmltYXJ5SW5kaWNlcyA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNvbnN0IHN1bVByaW1hcnkgPSBtYXhQcmltYXJ5VmFsdWVzLnJlZHVjZSgoc3VtMiwgbmV4dCkgPT4gc3VtMiArIG5leHQsIDApO1xuICAgIGlmIChzdW1QcmltYXJ5ID4gcHJpbWFyeS5tYXggJiYgIWZvcmNlUmVzdWx0KSB7XG4gICAgICBpZiAobWF4UHJpbWFyeVZhbHVlcy5sZW5ndGggPCBwcmltYXJ5Q291bnQpIHtcbiAgICAgICAgcmV0dXJuIG1heFByaW1hcnlWYWx1ZXMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjdXJyZW50UHJpbWFyeUluZGljZXMucHVzaChiYm94SW5kZXggKyBpbmRleE9mZnNldCk7XG4gIH1cbiAgaWYgKGN1cnJlbnRQcmltYXJ5SW5kaWNlcy5sZW5ndGggPiAwKSB7XG4gICAgcmVzdWx0LnB1c2goY3VycmVudFByaW1hcnlJbmRpY2VzKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA+IDAgPyByZXN1bHQgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBidWlsZFBhZ2VzKHJhd1BhZ2VzLCBvcmllbnRhdGlvbiwgYmJveGVzLCBpdGVtUGFkZGluZ1ksIGl0ZW1QYWRkaW5nWCkge1xuICBsZXQgbWF4UGFnZVdpZHRoID0gMDtcbiAgbGV0IG1heFBhZ2VIZWlnaHQgPSAwO1xuICBjb25zdCBwYWdlcyA9IHJhd1BhZ2VzLm1hcCgoaW5kaWNlcykgPT4ge1xuICAgIGlmIChvcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgIGluZGljZXMgPSB0cmFuc3Bvc2UoaW5kaWNlcyk7XG4gICAgfVxuICAgIGxldCBlbmRJbmRleCA9IDA7XG4gICAgY29uc3QgY29sdW1ucyA9IGluZGljZXMubWFwKChjb2xJbmRpY2VzKSA9PiB7XG4gICAgICBjb25zdCBjb2xCQm94ZXMgPSBjb2xJbmRpY2VzLm1hcCgoYmJveEluZGV4KSA9PiB7XG4gICAgICAgIGVuZEluZGV4ID0gTWF0aC5tYXgoYmJveEluZGV4LCBlbmRJbmRleCk7XG4gICAgICAgIHJldHVybiBiYm94ZXNbYmJveEluZGV4XTtcbiAgICAgIH0pO1xuICAgICAgbGV0IGNvbHVtbkhlaWdodCA9IDA7XG4gICAgICBsZXQgY29sdW1uV2lkdGggPSAwO1xuICAgICAgY29sQkJveGVzLmZvckVhY2goKGJib3gpID0+IHtcbiAgICAgICAgY29sdW1uSGVpZ2h0ICs9IGJib3guaGVpZ2h0ICsgaXRlbVBhZGRpbmdZO1xuICAgICAgICBjb2x1bW5XaWR0aCA9IE1hdGgubWF4KGNvbHVtbldpZHRoLCBiYm94LndpZHRoICsgaXRlbVBhZGRpbmdYKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5kaWNlczogY29sSW5kaWNlcyxcbiAgICAgICAgYmJveGVzOiBjb2xCQm94ZXMsXG4gICAgICAgIGNvbHVtbkhlaWdodDogTWF0aC5jZWlsKGNvbHVtbkhlaWdodCksXG4gICAgICAgIGNvbHVtbldpZHRoOiBNYXRoLmNlaWwoY29sdW1uV2lkdGgpXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGxldCBwYWdlV2lkdGggPSAwO1xuICAgIGxldCBwYWdlSGVpZ2h0ID0gMDtcbiAgICBjb2x1bW5zLmZvckVhY2goKGNvbHVtbikgPT4ge1xuICAgICAgcGFnZVdpZHRoICs9IGNvbHVtbi5jb2x1bW5XaWR0aDtcbiAgICAgIHBhZ2VIZWlnaHQgPSBNYXRoLm1heChwYWdlSGVpZ2h0LCBjb2x1bW4uY29sdW1uSGVpZ2h0KTtcbiAgICB9KTtcbiAgICBtYXhQYWdlV2lkdGggPSBNYXRoLm1heChwYWdlV2lkdGgsIG1heFBhZ2VXaWR0aCk7XG4gICAgbWF4UGFnZUhlaWdodCA9IE1hdGgubWF4KHBhZ2VIZWlnaHQsIG1heFBhZ2VIZWlnaHQpO1xuICAgIHJldHVybiB7XG4gICAgICBjb2x1bW5zLFxuICAgICAgc3RhcnRJbmRleDogaW5kaWNlc1swXVswXSxcbiAgICAgIGVuZEluZGV4LFxuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodFxuICAgIH07XG4gIH0pO1xuICByZXR1cm4geyBwYWdlcywgbWF4UGFnZVdpZHRoLCBtYXhQYWdlSGVpZ2h0IH07XG59XG5mdW5jdGlvbiB0cmFuc3Bvc2UoZGF0YSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChjb25zdCBfIG9mIGRhdGFbMF0pIHtcbiAgICByZXN1bHQucHVzaChbXSk7XG4gIH1cbiAgZGF0YS5mb3JFYWNoKChpbm5lckRhdGEsIGRhdGFJZHgpID0+IHtcbiAgICBpbm5lckRhdGEuZm9yRWFjaCgoaXRlbSwgaXRlbUlkeCkgPT4ge1xuICAgICAgcmVzdWx0W2l0ZW1JZHhdW2RhdGFJZHhdID0gaXRlbTtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBlc3RpbWF0ZVN0YXJ0aW5nR3Vlc3MoYmJveGVzLCBwcmltYXJ5KSB7XG4gIGNvbnN0IG4gPSBiYm94ZXMubGVuZ3RoO1xuICBsZXQgcHJpbWFyeVN1bSA9IDA7XG4gIGZvciAobGV0IGJib3hJbmRleCA9IDA7IGJib3hJbmRleCA8IG47IGJib3hJbmRleCsrKSB7XG4gICAgcHJpbWFyeVN1bSArPSBwcmltYXJ5LmZuKGJib3hlc1tiYm94SW5kZXhdKSArIHByaW1hcnkucGFkZGluZztcbiAgICBpZiAocHJpbWFyeVN1bSA+IHByaW1hcnkubWF4KSB7XG4gICAgICBjb25zdCByYXRpbzIgPSBuIC8gYmJveEluZGV4O1xuICAgICAgaWYgKHJhdGlvMiA8IDIpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChuIC8gMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmJveEluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvaW1hZ2UudHNcbnZhciBJbWFnZSA9IGNsYXNzIGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZUltYWdlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNvdXJjZUltYWdlID0gc291cmNlSW1hZ2U7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLm9wYWNpdHkgPSAxO1xuICB9XG4gIHVwZGF0ZUJpdG1hcChuZXdCaXRtYXAsIGJpdG1hcFBpeGVsUmF0aW8sIHgsIHkpIHtcbiAgICB0aGlzLnNvdXJjZUltYWdlID0gbmV3Qml0bWFwO1xuICAgIHRoaXMud2lkdGggPSBuZXdCaXRtYXAud2lkdGggLyBiaXRtYXBQaXhlbFJhdGlvO1xuICAgIHRoaXMuaGVpZ2h0ID0gbmV3Qml0bWFwLmhlaWdodCAvIGJpdG1hcFBpeGVsUmF0aW87XG4gICAgdGhpcy54ID0geCAvIGJpdG1hcFBpeGVsUmF0aW87XG4gICAgdGhpcy55ID0geSAvIGJpdG1hcFBpeGVsUmF0aW87XG4gICAgdGhpcy5tYXJrRGlydHkodGhpcywgMyAvKiBNQUpPUiAqLyk7XG4gIH1cbiAgcmVuZGVyKHJlbmRlckN0eCkge1xuICAgIGNvbnN0IHsgY3R4LCBmb3JjZVJlbmRlciwgc3RhdHMgfSA9IHJlbmRlckN0eDtcbiAgICBpZiAodGhpcy5kaXJ0eSA9PT0gMCAvKiBOT05FICovICYmICFmb3JjZVJlbmRlcikge1xuICAgICAgaWYgKHN0YXRzKVxuICAgICAgICBzdGF0cy5ub2Rlc1NraXBwZWQrKztcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW1hZ2UgPSB0aGlzLnNvdXJjZUltYWdlO1xuICAgIGlmICghaW1hZ2UpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy50cmFuc2Zvcm1SZW5kZXJDb250ZXh0KHJlbmRlckN0eCk7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5vcGFjaXR5O1xuICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgc3VwZXIucmVuZGVyKHJlbmRlckN0eCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgSW1hZ2UucHJvdG90eXBlLCBcInhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgSW1hZ2UucHJvdG90eXBlLCBcInlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgSW1hZ2UucHJvdG90eXBlLCBcIndpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIEltYWdlLnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgSW1hZ2UucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2xlZ2VuZE1hcmtlckxhYmVsLnRzXG52YXIgTGVnZW5kTWFya2VyTGFiZWwgPSBjbGFzcyBleHRlbmRzIEdyb3VwIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoeyBuYW1lOiBcIm1hcmtlckxhYmVsR3JvdXBcIiB9KTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IFRleHQoKTtcbiAgICB0aGlzLnN5bWJvbHNHcm91cCA9IG5ldyBHcm91cCh7XG4gICAgICBuYW1lOiBcImxlZ2VuZC1tYXJrZXJMYWJlbC1zeW1ib2xzXCJcbiAgICB9KTtcbiAgICB0aGlzLmJpdG1hcCA9IG5ldyBJbWFnZSgpO1xuICAgIHRoaXMuYml0bWFwRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5wYWdlSW5kZXggPSBOYU47XG4gICAgdGhpcy5fbWFya2VycyA9IFtdO1xuICAgIHRoaXMuX2xpbmVzID0gW107XG4gICAgY29uc3QgeyBtYXJrZXJzLCBsYWJlbCwgbGluZXMgfSA9IHRoaXM7XG4gICAgbGFiZWwudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICBsYWJlbC5mb250U2l6ZSA9IDEyO1xuICAgIGxhYmVsLmZvbnRGYW1pbHkgPSBcIlZlcmRhbmEsIHNhbnMtc2VyaWZcIjtcbiAgICBsYWJlbC5maWxsID0gXCJibGFja1wiO1xuICAgIGxhYmVsLnkgPSAxO1xuICAgIHRoaXMudXBkYXRlU3ltYm9scyhtYXJrZXJzLCBsaW5lcyk7XG4gICAgdGhpcy5hcHBlbmQoYXJnc0l0ZXJhYmxlKHRoaXMuc3ltYm9sc0dyb3VwLCBsYWJlbCkpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIHRoaXMucHJveHlCdXR0b24/LnJlbW92ZSgpO1xuICB9XG4gIGdldCBtYXJrZXJzKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXJrZXJzO1xuICB9XG4gIGdldCBsaW5lcygpIHtcbiAgICByZXR1cm4gdGhpcy5fbGluZXM7XG4gIH1cbiAgdXBkYXRlU3ltYm9scyhtYXJrZXJzLCBsaW5lcykge1xuICAgIGlmIChhcnJheXNFcXVhbCh0aGlzLl9tYXJrZXJzLCBtYXJrZXJzKSAmJiBhcnJheXNFcXVhbCh0aGlzLl9saW5lcywgbGluZXMpKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuYml0bWFwRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX21hcmtlcnMgPSBtYXJrZXJzO1xuICAgIHRoaXMuX2xpbmVzID0gbGluZXM7XG4gICAgdGhpcy5zeW1ib2xzR3JvdXAuY2xlYXIoKTtcbiAgICB0aGlzLnN5bWJvbHNHcm91cC5hcHBlbmQoW3RoaXMuYml0bWFwLCAuLi5tYXJrZXJzLCAuLi5saW5lc10pO1xuICB9XG4gIHNldEVuYWJsZWQoZW5hYmxlZCkge1xuICAgIHRoaXMuZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgdGhpcy5yZWZyZXNoVmlzaWJpbGl0aWVzKCk7XG4gIH1cbiAgcmVmcmVzaFZpc2liaWxpdGllcygpIHtcbiAgICBjb25zdCBvcGFjaXR5ID0gdGhpcy5lbmFibGVkID8gMSA6IDAuNTtcbiAgICB0aGlzLmxhYmVsLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgIHRoaXMub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgdGhpcy5iaXRtYXAub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgdGhpcy5zZXRCaXRtYXBWaXNpYmlsaXR5KCF0aGlzLmVuYWJsZWQpO1xuICB9XG4gIHNldEJpdG1hcFZpc2liaWxpdHkodmlzaWJsZSkge1xuICAgIGNvbnN0IHsgbGluZXMsIG1hcmtlcnMgfSA9IHRoaXM7XG4gICAgW2xpbmVzLCBtYXJrZXJzXS5mb3JFYWNoKChzaGFwZXMpID0+IHNoYXBlcy5mb3JFYWNoKChzaGFwZSkgPT4gc2hhcGUudmlzaWJsZSA9ICF2aXNpYmxlKSk7XG4gICAgdGhpcy5iaXRtYXAudmlzaWJsZSA9IHZpc2libGU7XG4gIH1cbiAgLy8gVGhlIEJCb3ggb2YgdGhpcy5iaXRtYXAgaXMgYHNwcml0ZVBhZGRpbmdgIHBpeGVscyBiaWdnZXIgaW4gZWFjaCBkaXJlY3Rpb24gdGhhbiBCQm94IG9mIHRoZSBtYXJrZXJzIGFuZCBsaW5lcy5cbiAgLy8gVGhpcyBwYWRkaW5nIGFsbG93cyB0aGUgU3ByaXRlUmVuZGVyZXIgdG8gZHJhdyBhbnRpYWxpYXNpbmcgcGl4ZWxzIHRoYXQgY2FuIGV4dGVuZCBiZXlvbmQgdGhlIHNoYXBlcycgYm91bmRzLlxuICB1cGRhdGUoc3ByaXRlUmVuZGVyZXIsIHsgc3ByaXRlQUFQYWRkaW5nLCBzcHJpdGVQaXhlbFJhdGlvOiBzY2FsZTIgfSwgZGltZW5zaW9uUHJvcHMpIHtcbiAgICBjb25zdCB7IG1hcmtlcnMsIGxpbmVzIH0gPSB0aGlzO1xuICAgIGxldCBzcHJpdGVYID0gMDtcbiAgICBsZXQgc3ByaXRlWSA9IDA7XG4gICAgbGV0IHNoaWZ0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IE1hdGgubWF4KG1hcmtlcnMubGVuZ3RoLCBsaW5lcy5sZW5ndGgpOyBpKyspIHtcbiAgICAgIGNvbnN0IHsgbGVuZ3RoOiBsZW5ndGgyLCBzcGFjaW5nIH0gPSBkaW1lbnNpb25Qcm9wc1tpXSA/PyAwO1xuICAgICAgY29uc3QgbWFya2VyID0gbWFya2Vyc1tpXTtcbiAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgIGNvbnN0IHNpemUgPSBtYXJrZXI/LnNpemUgPz8gMDtcbiAgICAgIGxldCBsaW5lVG9wID0gSW5maW5pdHk7XG4gICAgICBsZXQgbWFya2VyVG9wID0gSW5maW5pdHk7XG4gICAgICBsZXQgbWFya2VyTGVmdCA9IEluZmluaXR5O1xuICAgICAgaWYgKG1hcmtlcikge1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBtYXJrZXIuY29uc3RydWN0b3IuY2VudGVyO1xuICAgICAgICBjb25zdCByYWRpdXMgPSAoc2l6ZSArIG1hcmtlci5zdHJva2VXaWR0aCkgLyAyO1xuICAgICAgICBtYXJrZXIueCA9IChjZW50ZXIueCAtIDAuNSkgKiBzaXplICsgbGVuZ3RoMiAvIDIgKyBzaGlmdDtcbiAgICAgICAgbWFya2VyLnkgPSAoY2VudGVyLnkgLSAwLjUpICogc2l6ZTtcbiAgICAgICAgbWFya2VyVG9wID0gbWFya2VyLnkgLSByYWRpdXM7XG4gICAgICAgIG1hcmtlckxlZnQgPSBtYXJrZXIueCAtIHJhZGl1cztcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgIGxpbmUueDEgPSBzaGlmdDtcbiAgICAgICAgbGluZS54MiA9IHNoaWZ0ICsgbGVuZ3RoMjtcbiAgICAgICAgbGluZS55MSA9IDA7XG4gICAgICAgIGxpbmUueTIgPSAwO1xuICAgICAgICBsaW5lLm1hcmtEaXJ0eVRyYW5zZm9ybSgpO1xuICAgICAgICBsaW5lVG9wID0gLWxpbmUuc3Ryb2tlV2lkdGggLyAyO1xuICAgICAgfVxuICAgICAgc2hpZnQgKz0gc3BhY2luZyArIE1hdGgubWF4KGxlbmd0aDIsIHNpemUpO1xuICAgICAgc3ByaXRlWCA9IE1hdGgubWluKHNwcml0ZVgsIGxpbmUueDEsIGxpbmUueDIsIG1hcmtlckxlZnQpO1xuICAgICAgc3ByaXRlWSA9IE1hdGgubWluKHNwcml0ZVksIGxpbmVUb3AsIG1hcmtlclRvcCk7XG4gICAgfVxuICAgIGNvbnN0IGxhc3RTeW1ib2xQcm9wcyA9IGRpbWVuc2lvblByb3BzLmF0KC0xKTtcbiAgICBjb25zdCBsYXN0TGluZSA9IHRoaXMubGluZXMuYXQoLTEpO1xuICAgIGNvbnN0IGxhc3RNYXJrZXIgPSB0aGlzLm1hcmtlcnMuYXQoLTEpO1xuICAgIGNvbnN0IGxpbmVFbmQgPSBsYXN0TGluZSA/IGxhc3RMaW5lLngyIDogLUluZmluaXR5O1xuICAgIGNvbnN0IG1hcmtlckVuZCA9IChsYXN0TWFya2VyPy54ID8/IDApICsgKGxhc3RNYXJrZXI/LnNpemUgPz8gMCkgLyAyO1xuICAgIHRoaXMubGFiZWwueCA9IE1hdGgubWF4KGxpbmVFbmQsIG1hcmtlckVuZCkgKyAobGFzdFN5bWJvbFByb3BzPy5zcGFjaW5nID8/IDApO1xuICAgIGlmICh0aGlzLmJpdG1hcERpcnR5KSB7XG4gICAgICB0aGlzLnNldEJpdG1hcFZpc2liaWxpdHkoZmFsc2UpO1xuICAgICAgY29uc3QgdHJhbnNsYXRlWCA9IChzcHJpdGVBQVBhZGRpbmcgKyBzcHJpdGVYKSAqIHNjYWxlMjtcbiAgICAgIGNvbnN0IHRyYW5zbGF0ZVkgPSAoc3ByaXRlQUFQYWRkaW5nIC0gc3ByaXRlWSkgKiBzY2FsZTI7XG4gICAgICBjb25zdCBzcHJpdGUgPSBzcHJpdGVSZW5kZXJlci5yZW5kZXJTcHJpdGUodGhpcy5zeW1ib2xzR3JvdXAsIHtcbiAgICAgICAgc2NhbGU6IHNjYWxlMixcbiAgICAgICAgdHJhbnNsYXRlWDogTWF0aC5mbG9vcih0cmFuc2xhdGVYKSxcbiAgICAgICAgdHJhbnNsYXRlWTogTWF0aC5mbG9vcih0cmFuc2xhdGVZKVxuICAgICAgfSk7XG4gICAgICB0aGlzLmJpdG1hcC51cGRhdGVCaXRtYXAoc3ByaXRlLCBzY2FsZTIsIE1hdGguY2VpbCgtdHJhbnNsYXRlWCksIE1hdGguY2VpbCgtdHJhbnNsYXRlWSkpO1xuICAgICAgdGhpcy5iaXRtYXBEaXJ0eSA9IGZhbHNlO1xuICAgICAgdGhpcy5yZWZyZXNoVmlzaWJpbGl0aWVzKCk7XG4gICAgfVxuICAgIGlmIChkaW1lbnNpb25Qcm9wcy5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGJib3ggPSB0aGlzLnN5bWJvbHNHcm91cC5nZXRCQm94KCk7XG4gICAgY29uc3QgY2xpcHBlZFdpZHRoID0gTWF0aC5tYXgobGFzdE1hcmtlcj8uc2l6ZSA/PyAwLCBsYXN0U3ltYm9sUHJvcHM/Lmxlbmd0aCA/PyAwKTtcbiAgICBjb25zdCBjbGlwUmVjdCA9IG5ldyBCQm94KGJib3gueCArIGNsaXBwZWRXaWR0aCAvIDIsIGJib3gueSwgY2xpcHBlZFdpZHRoLCBiYm94LmhlaWdodCk7XG4gICAgdGhpcy5zeW1ib2xzR3JvdXAuc2V0Q2xpcFJlY3RJbkdyb3VwQ29vcmRpbmF0ZVNwYWNlKGNsaXBSZWN0KTtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICBjb25zdCB7IGxhYmVsLCBsaW5lcywgbWFya2VycyB9ID0gdGhpcztcbiAgICByZXR1cm4gR3JvdXAuY29tcHV0ZUJCb3goYXJyYXlzSXRlcmFibGUoW2xhYmVsXSwgbGluZXMsIG1hcmtlcnMpLCB7IHNraXBJbnZpc2libGU6IGZhbHNlIH0pO1xuICB9XG59O1xuTGVnZW5kTWFya2VyTGFiZWwuY2xhc3NOYW1lID0gXCJNYXJrZXJMYWJlbFwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJsYWJlbFwiKVxuXSwgTGVnZW5kTWFya2VyTGFiZWwucHJvdG90eXBlLCBcInRleHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5T25Xcml0ZShcImxhYmVsXCIpXG5dLCBMZWdlbmRNYXJrZXJMYWJlbC5wcm90b3R5cGUsIFwiZm9udFN0eWxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eU9uV3JpdGUoXCJsYWJlbFwiKVxuXSwgTGVnZW5kTWFya2VyTGFiZWwucHJvdG90eXBlLCBcImZvbnRXZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5T25Xcml0ZShcImxhYmVsXCIpXG5dLCBMZWdlbmRNYXJrZXJMYWJlbC5wcm90b3R5cGUsIFwiZm9udFNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5T25Xcml0ZShcImxhYmVsXCIpXG5dLCBMZWdlbmRNYXJrZXJMYWJlbC5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHlPbldyaXRlKFwibGFiZWxcIiwgXCJmaWxsXCIpXG5dLCBMZWdlbmRNYXJrZXJMYWJlbC5wcm90b3R5cGUsIFwiY29sb3JcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3BhZ2luYXRpb24vcGFnaW5hdGlvbi50c1xudmFyIFBhZ2luYXRpb25MYWJlbCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuY29sb3IgPSBcImJsYWNrXCI7XG4gICAgdGhpcy5mb250U3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5mb250V2VpZ2h0ID0gdm9pZCAwO1xuICAgIHRoaXMuZm9udFNpemUgPSAxMjtcbiAgICB0aGlzLmZvbnRGYW1pbHkgPSBcIlZlcmRhbmEsIHNhbnMtc2VyaWZcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORylcbl0sIFBhZ2luYXRpb25MYWJlbC5wcm90b3R5cGUsIFwiY29sb3JcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1NUWUxFLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQYWdpbmF0aW9uTGFiZWwucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZPTlRfV0VJR0hULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQYWdpbmF0aW9uTGFiZWwucHJvdG90eXBlLCBcImZvbnRXZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQYWdpbmF0aW9uTGFiZWwucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgUGFnaW5hdGlvbkxhYmVsLnByb3RvdHlwZSwgXCJmb250RmFtaWx5XCIsIDIpO1xudmFyIFBhZ2luYXRpb25NYXJrZXJTdHlsZSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuc2l6ZSA9IDE1O1xuICAgIHRoaXMuZmlsbCA9IHZvaWQgMDtcbiAgICB0aGlzLmZpbGxPcGFjaXR5ID0gdm9pZCAwO1xuICAgIHRoaXMuc3Ryb2tlID0gdm9pZCAwO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQYWdpbmF0aW9uTWFya2VyU3R5bGUucHJvdG90eXBlLCBcInNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBhZ2luYXRpb25NYXJrZXJTdHlsZS5wcm90b3R5cGUsIFwiZmlsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQYWdpbmF0aW9uTWFya2VyU3R5bGUucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQYWdpbmF0aW9uTWFya2VyU3R5bGUucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBhZ2luYXRpb25NYXJrZXJTdHlsZS5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIFBhZ2luYXRpb25NYXJrZXJTdHlsZS5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbnZhciBQYWdpbmF0aW9uTWFya2VyID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5zaGFwZSA9IFRyaWFuZ2xlO1xuICAgIHRoaXMuc2l6ZSA9IDE1O1xuICAgIHRoaXMucGFkZGluZyA9IDg7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBBY3Rpb25PblNldCh7XG4gICAgY2hhbmdlVmFsdWUoKSB7XG4gICAgICBpZiAodGhpcy5wYXJlbnQubWFya2VyID09PSB0aGlzKSB7XG4gICAgICAgIHRoaXMucGFyZW50Lm9uTWFya2VyU2hhcGVDaGFuZ2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5dLCBQYWdpbmF0aW9uTWFya2VyLnByb3RvdHlwZSwgXCJzaGFwZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBhZ2luYXRpb25NYXJrZXIucHJvdG90eXBlLCBcInNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQYWdpbmF0aW9uTWFya2VyLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIDIpO1xudmFyIFBhZ2luYXRpb24gPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoY2hhcnRVcGRhdGVDYWxsYmFjaywgcGFnZVVwZGF0ZUNhbGxiYWNrLCByZWdpb25NYW5hZ2VyLCBjdXJzb3JNYW5hZ2VyKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNoYXJ0VXBkYXRlQ2FsbGJhY2sgPSBjaGFydFVwZGF0ZUNhbGxiYWNrO1xuICAgIHRoaXMucGFnZVVwZGF0ZUNhbGxiYWNrID0gcGFnZVVwZGF0ZUNhbGxiYWNrO1xuICAgIHRoaXMucmVnaW9uTWFuYWdlciA9IHJlZ2lvbk1hbmFnZXI7XG4gICAgdGhpcy5jdXJzb3JNYW5hZ2VyID0gY3Vyc29yTWFuYWdlcjtcbiAgICB0aGlzLmlkID0gY3JlYXRlSWQodGhpcyk7XG4gICAgdGhpcy5tYXJrZXIgPSBuZXcgUGFnaW5hdGlvbk1hcmtlcih0aGlzKTtcbiAgICB0aGlzLmFjdGl2ZVN0eWxlID0gbmV3IFBhZ2luYXRpb25NYXJrZXJTdHlsZSgpO1xuICAgIHRoaXMuaW5hY3RpdmVTdHlsZSA9IG5ldyBQYWdpbmF0aW9uTWFya2VyU3R5bGUoKTtcbiAgICB0aGlzLmhpZ2hsaWdodFN0eWxlID0gbmV3IFBhZ2luYXRpb25NYXJrZXJTdHlsZSgpO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgUGFnaW5hdGlvbkxhYmVsKCk7XG4gICAgdGhpcy5ncm91cCA9IG5ldyBHcm91cCh7IG5hbWU6IFwicGFnaW5hdGlvblwiIH0pO1xuICAgIHRoaXMubGFiZWxOb2RlID0gbmV3IFRleHQoKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMgPSBbXTtcbiAgICB0aGlzLnRvdGFsUGFnZXMgPSAwO1xuICAgIHRoaXMuY3VycmVudFBhZ2UgPSAwO1xuICAgIHRoaXMudHJhbnNsYXRpb25YID0gMDtcbiAgICB0aGlzLnRyYW5zbGF0aW9uWSA9IDA7XG4gICAgdGhpcy5uZXh0QnV0dG9uRGlzYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLnByZXZpb3VzQnV0dG9uRGlzYWJsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9vcmllbnRhdGlvbiA9IFwidmVydGljYWxcIjtcbiAgICB0aGlzLl9uZXh0QnV0dG9uID0gbmV3IFRyaWFuZ2xlKCk7XG4gICAgdGhpcy5fcHJldmlvdXNCdXR0b24gPSBuZXcgVHJpYW5nbGUoKTtcbiAgICB0aGlzLmxhYmVsTm9kZS5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgIHRleHRCYXNlbGluZTogXCJtaWRkbGVcIixcbiAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgIGZvbnRGYW1pbHk6IFwiVmVyZGFuYSwgc2Fucy1zZXJpZlwiLFxuICAgICAgZmlsbDogXCJibGFja1wiLFxuICAgICAgeTogMVxuICAgIH0pO1xuICAgIHRoaXMuZ3JvdXAuYXBwZW5kKFt0aGlzLm5leHRCdXR0b24sIHRoaXMucHJldmlvdXNCdXR0b24sIHRoaXMubGFiZWxOb2RlXSk7XG4gICAgY29uc3QgcmVnaW9uID0gdGhpcy5yZWdpb25NYW5hZ2VyLmFkZFJlZ2lvbihcInBhZ2luYXRpb25cIiwgdGhpcy5ncm91cCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICByZWdpb24uYWRkTGlzdGVuZXIoXCJjbGlja1wiLCAoZXZlbnQpID0+IHRoaXMub25QYWdpbmF0aW9uQ2xpY2soZXZlbnQpKSxcbiAgICAgIHJlZ2lvbi5hZGRMaXN0ZW5lcihcImhvdmVyXCIsIChldmVudCkgPT4gdGhpcy5vblBhZ2luYXRpb25Nb3VzZU1vdmUoZXZlbnQpKVxuICAgICk7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgICB0aGlzLnVwZGF0ZU1hcmtlcnMoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5mb3JFYWNoKChmKSA9PiBmKCkpO1xuICB9XG4gIHNldCB2aXNpYmxlKHZhbHVlKSB7XG4gICAgdGhpcy5fdmlzaWJsZSA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlR3JvdXBWaXNpYmlsaXR5KCk7XG4gIH1cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gIH1cbiAgc2V0IGVuYWJsZWQodmFsdWUpIHtcbiAgICB0aGlzLl9lbmFibGVkID0gdmFsdWU7XG4gICAgdGhpcy51cGRhdGVHcm91cFZpc2liaWxpdHkoKTtcbiAgfVxuICBnZXQgZW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgfVxuICB1cGRhdGVHcm91cFZpc2liaWxpdHkoKSB7XG4gICAgdGhpcy5ncm91cC52aXNpYmxlID0gdGhpcy5lbmFibGVkICYmIHRoaXMudmlzaWJsZTtcbiAgfVxuICBzZXQgb3JpZW50YXRpb24odmFsdWUpIHtcbiAgICB0aGlzLl9vcmllbnRhdGlvbiA9IHZhbHVlO1xuICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgIGNhc2UgXCJob3Jpem9udGFsXCI6IHtcbiAgICAgICAgdGhpcy5wcmV2aW91c0J1dHRvbi5yb3RhdGlvbiA9IC1NYXRoLlBJIC8gMjtcbiAgICAgICAgdGhpcy5uZXh0QnV0dG9uLnJvdGF0aW9uID0gTWF0aC5QSSAvIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInZlcnRpY2FsXCI6XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRoaXMucHJldmlvdXNCdXR0b24ucm90YXRpb24gPSAwO1xuICAgICAgICB0aGlzLm5leHRCdXR0b24ucm90YXRpb24gPSBNYXRoLlBJO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgb3JpZW50YXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX29yaWVudGF0aW9uO1xuICB9XG4gIHNldCBuZXh0QnV0dG9uKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX25leHRCdXR0b24gIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmdyb3VwLnJlbW92ZUNoaWxkKHRoaXMuX25leHRCdXR0b24pO1xuICAgICAgdGhpcy5fbmV4dEJ1dHRvbiA9IHZhbHVlO1xuICAgICAgdGhpcy5ncm91cC5hcHBlbmRDaGlsZCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIGdldCBuZXh0QnV0dG9uKCkge1xuICAgIHJldHVybiB0aGlzLl9uZXh0QnV0dG9uO1xuICB9XG4gIHNldCBwcmV2aW91c0J1dHRvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLl9wcmV2aW91c0J1dHRvbiAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuZ3JvdXAucmVtb3ZlQ2hpbGQodGhpcy5fcHJldmlvdXNCdXR0b24pO1xuICAgICAgdGhpcy5fcHJldmlvdXNCdXR0b24gPSB2YWx1ZTtcbiAgICAgIHRoaXMuZ3JvdXAuYXBwZW5kQ2hpbGQodmFsdWUpO1xuICAgIH1cbiAgfVxuICBnZXQgcHJldmlvdXNCdXR0b24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzQnV0dG9uO1xuICB9XG4gIHVwZGF0ZSgpIHtcbiAgICB0aGlzLnVwZGF0ZUxhYmVsKCk7XG4gICAgdGhpcy51cGRhdGVQb3NpdGlvbnMoKTtcbiAgICB0aGlzLmVuYWJsZU9yRGlzYWJsZUJ1dHRvbnMoKTtcbiAgfVxuICB1cGRhdGVQb3NpdGlvbnMoKSB7XG4gICAgdGhpcy5ncm91cC50cmFuc2xhdGlvblggPSB0aGlzLnRyYW5zbGF0aW9uWDtcbiAgICB0aGlzLmdyb3VwLnRyYW5zbGF0aW9uWSA9IHRoaXMudHJhbnNsYXRpb25ZO1xuICAgIHRoaXMudXBkYXRlTGFiZWxQb3NpdGlvbigpO1xuICAgIHRoaXMudXBkYXRlTmV4dEJ1dHRvblBvc2l0aW9uKCk7XG4gIH1cbiAgdXBkYXRlTGFiZWxQb3NpdGlvbigpIHtcbiAgICBjb25zdCB7IHNpemU6IG1hcmtlclNpemUsIHBhZGRpbmc6IG1hcmtlclBhZGRpbmcgfSA9IHRoaXMubWFya2VyO1xuICAgIHRoaXMubmV4dEJ1dHRvbi5zaXplID0gbWFya2VyU2l6ZTtcbiAgICB0aGlzLnByZXZpb3VzQnV0dG9uLnNpemUgPSBtYXJrZXJTaXplO1xuICAgIHRoaXMubGFiZWxOb2RlLnggPSBtYXJrZXJTaXplIC8gMiArIG1hcmtlclBhZGRpbmc7XG4gIH1cbiAgdXBkYXRlTmV4dEJ1dHRvblBvc2l0aW9uKCkge1xuICAgIGNvbnN0IGxhYmVsQkJveCA9IHRoaXMubGFiZWxOb2RlLmdldEJCb3goKTtcbiAgICB0aGlzLm5leHRCdXR0b24udHJhbnNsYXRpb25YID0gbGFiZWxCQm94LnggKyBsYWJlbEJCb3gud2lkdGggKyB0aGlzLm1hcmtlci5zaXplIC8gMiArIHRoaXMubWFya2VyLnBhZGRpbmc7XG4gIH1cbiAgdXBkYXRlTGFiZWwoKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudFBhZ2UsXG4gICAgICB0b3RhbFBhZ2VzOiBwYWdlcyxcbiAgICAgIGxhYmVsTm9kZSxcbiAgICAgIGxhYmVsOiB7IGNvbG9yLCBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5IH1cbiAgICB9ID0gdGhpcztcbiAgICBsYWJlbE5vZGUudGV4dCA9IGAke2N1cnJlbnRQYWdlICsgMX0gLyAke3BhZ2VzfWA7XG4gICAgbGFiZWxOb2RlLmZpbGwgPSBjb2xvcjtcbiAgICBsYWJlbE5vZGUuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgIGxhYmVsTm9kZS5mb250V2VpZ2h0ID0gZm9udFdlaWdodDtcbiAgICBsYWJlbE5vZGUuZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICBsYWJlbE5vZGUuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gIH1cbiAgdXBkYXRlTWFya2VycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBuZXh0QnV0dG9uLFxuICAgICAgcHJldmlvdXNCdXR0b24sXG4gICAgICBuZXh0QnV0dG9uRGlzYWJsZWQsXG4gICAgICBwcmV2aW91c0J1dHRvbkRpc2FibGVkLFxuICAgICAgYWN0aXZlU3R5bGUsXG4gICAgICBpbmFjdGl2ZVN0eWxlLFxuICAgICAgaGlnaGxpZ2h0U3R5bGUsXG4gICAgICBoaWdobGlnaHRBY3RpdmVcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBidXR0b25TdHlsZSA9IChidXR0b24sIGRpc2FibGVkKSA9PiB7XG4gICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIGluYWN0aXZlU3R5bGU7XG4gICAgICB9IGVsc2UgaWYgKGJ1dHRvbiA9PT0gaGlnaGxpZ2h0QWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBoaWdobGlnaHRTdHlsZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY3RpdmVTdHlsZTtcbiAgICB9O1xuICAgIHRoaXMudXBkYXRlTWFya2VyKG5leHRCdXR0b24sIGJ1dHRvblN0eWxlKFwibmV4dFwiLCBuZXh0QnV0dG9uRGlzYWJsZWQpKTtcbiAgICB0aGlzLnVwZGF0ZU1hcmtlcihwcmV2aW91c0J1dHRvbiwgYnV0dG9uU3R5bGUoXCJwcmV2aW91c1wiLCBwcmV2aW91c0J1dHRvbkRpc2FibGVkKSk7XG4gIH1cbiAgdXBkYXRlTWFya2VyKG1hcmtlciwgc3R5bGUpIHtcbiAgICBjb25zdCB7IHNpemUgfSA9IHRoaXMubWFya2VyO1xuICAgIG1hcmtlci5zaXplID0gc2l6ZTtcbiAgICBtYXJrZXIuZmlsbCA9IHN0eWxlLmZpbGw7XG4gICAgbWFya2VyLmZpbGxPcGFjaXR5ID0gc3R5bGUuZmlsbE9wYWNpdHkgPz8gMTtcbiAgICBtYXJrZXIuc3Ryb2tlID0gc3R5bGUuc3Ryb2tlO1xuICAgIG1hcmtlci5zdHJva2VXaWR0aCA9IHN0eWxlLnN0cm9rZVdpZHRoO1xuICAgIG1hcmtlci5zdHJva2VPcGFjaXR5ID0gc3R5bGUuc3Ryb2tlT3BhY2l0eTtcbiAgfVxuICBlbmFibGVPckRpc2FibGVCdXR0b25zKCkge1xuICAgIGNvbnN0IHsgY3VycmVudFBhZ2UsIHRvdGFsUGFnZXMgfSA9IHRoaXM7XG4gICAgY29uc3QgemVyb1BhZ2VzVG9EaXNwbGF5ID0gdG90YWxQYWdlcyA9PT0gMDtcbiAgICBjb25zdCBvbkxhc3RQYWdlID0gY3VycmVudFBhZ2UgPT09IHRvdGFsUGFnZXMgLSAxO1xuICAgIGNvbnN0IG9uRmlyc3RQYWdlID0gY3VycmVudFBhZ2UgPT09IDA7XG4gICAgdGhpcy5uZXh0QnV0dG9uRGlzYWJsZWQgPSBvbkxhc3RQYWdlIHx8IHplcm9QYWdlc1RvRGlzcGxheTtcbiAgICB0aGlzLnByZXZpb3VzQnV0dG9uRGlzYWJsZWQgPSBvbkZpcnN0UGFnZSB8fCB6ZXJvUGFnZXNUb0Rpc3BsYXk7XG4gIH1cbiAgbmV4dEJ1dHRvbkNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgIHJldHVybiAhdGhpcy5uZXh0QnV0dG9uRGlzYWJsZWQgJiYgdGhpcy5uZXh0QnV0dG9uLmNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gIH1cbiAgcHJldmlvdXNCdXR0b25Db250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpIHtcbiAgICByZXR1cm4gIXRoaXMucHJldmlvdXNCdXR0b25EaXNhYmxlZCAmJiB0aGlzLnByZXZpb3VzQnV0dG9uLmNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gIH1cbiAgY2xpY2tOZXh0KCkge1xuICAgIHRoaXMuaW5jcmVtZW50UGFnZSgpO1xuICAgIHRoaXMub25QYWdpbmF0aW9uQ2hhbmdlZCgpO1xuICB9XG4gIGNsaWNrUHJldmlvdXMoKSB7XG4gICAgdGhpcy5kZWNyZW1lbnRQYWdlKCk7XG4gICAgdGhpcy5vblBhZ2luYXRpb25DaGFuZ2VkKCk7XG4gIH1cbiAgc2V0UGFnZShwYWdlTnVtYmVyKSB7XG4gICAgcGFnZU51bWJlciA9IGNsYW1wKDAsIHBhZ2VOdW1iZXIsIHRoaXMudG90YWxQYWdlcyAtIDEpO1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYWdlICE9PSBwYWdlTnVtYmVyKSB7XG4gICAgICB0aGlzLmN1cnJlbnRQYWdlID0gcGFnZU51bWJlcjtcbiAgICAgIHRoaXMub25QYWdpbmF0aW9uQ2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuICBvblBhZ2luYXRpb25DbGljayhldmVudCkge1xuICAgIGNvbnN0IHsgb2Zmc2V0WCwgb2Zmc2V0WSB9ID0gZXZlbnQ7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAodGhpcy5uZXh0QnV0dG9uQ29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSkge1xuICAgICAgdGhpcy5jbGlja05leHQoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucHJldmlvdXNCdXR0b25Db250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpKSB7XG4gICAgICB0aGlzLmNsaWNrUHJldmlvdXMoKTtcbiAgICB9XG4gIH1cbiAgb25QYWdpbmF0aW9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcbiAgICBpZiAodGhpcy5uZXh0QnV0dG9uQ29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSkge1xuICAgICAgdGhpcy5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcih0aGlzLmlkLCBcInBvaW50ZXJcIik7XG4gICAgICB0aGlzLmhpZ2hsaWdodEFjdGl2ZSA9IFwibmV4dFwiO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2aW91c0J1dHRvbkNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSkpIHtcbiAgICAgIHRoaXMuY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IodGhpcy5pZCwgXCJwb2ludGVyXCIpO1xuICAgICAgdGhpcy5oaWdobGlnaHRBY3RpdmUgPSBcInByZXZpb3VzXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IodGhpcy5pZCk7XG4gICAgICB0aGlzLmhpZ2hsaWdodEFjdGl2ZSA9IHZvaWQgMDtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVNYXJrZXJzKCk7XG4gICAgdGhpcy5jaGFydFVwZGF0ZUNhbGxiYWNrKDYgLyogU0NFTkVfUkVOREVSICovKTtcbiAgfVxuICBvblBhZ2luYXRpb25DaGFuZ2VkKCkge1xuICAgIHRoaXMucGFnZVVwZGF0ZUNhbGxiYWNrKHRoaXMuY3VycmVudFBhZ2UpO1xuICB9XG4gIGluY3JlbWVudFBhZ2UoKSB7XG4gICAgdGhpcy5jdXJyZW50UGFnZSA9IE1hdGgubWluKHRoaXMuY3VycmVudFBhZ2UgKyAxLCB0aGlzLnRvdGFsUGFnZXMgLSAxKTtcbiAgfVxuICBkZWNyZW1lbnRQYWdlKCkge1xuICAgIHRoaXMuY3VycmVudFBhZ2UgPSBNYXRoLm1heCh0aGlzLmN1cnJlbnRQYWdlIC0gMSwgMCk7XG4gIH1cbiAgb25NYXJrZXJTaGFwZUNoYW5nZSgpIHtcbiAgICBjb25zdCBNYXJrZXIyID0gZ2V0TWFya2VyKHRoaXMubWFya2VyLnNoYXBlIHx8IFRyaWFuZ2xlKTtcbiAgICB0aGlzLnByZXZpb3VzQnV0dG9uID0gbmV3IE1hcmtlcjIoKTtcbiAgICB0aGlzLm5leHRCdXR0b24gPSBuZXcgTWFya2VyMigpO1xuICAgIHRoaXMudXBkYXRlUG9zaXRpb25zKCk7XG4gICAgdGhpcy51cGRhdGVNYXJrZXJzKCk7XG4gICAgdGhpcy5jaGFydFVwZGF0ZUNhbGxiYWNrKDYgLyogU0NFTkVfUkVOREVSICovKTtcbiAgfVxuICBhdHRhY2hQYWdpbmF0aW9uKG5vZGUpIHtcbiAgICBub2RlLmFwcGVuZCh0aGlzLmdyb3VwKTtcbiAgfVxuICBnZXRCQm94KCkge1xuICAgIHJldHVybiB0aGlzLmdyb3VwLmdldEJCb3godHJ1ZSk7XG4gIH1cbiAgY29tcHV0ZUNTU0JvdW5kcygpIHtcbiAgICBjb25zdCBwcmV2ID0gdGhpcy5fcHJldmlvdXNCdXR0b24uY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpO1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLl9uZXh0QnV0dG9uLmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKTtcbiAgICByZXR1cm4geyBwcmV2LCBuZXh0IH07XG4gIH1cbn07XG5QYWdpbmF0aW9uLmNsYXNzTmFtZSA9IFwiUGFnaW5hdGlvblwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgUGFnaW5hdGlvbi5wcm90b3R5cGUsIFwibWFya2VyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgUGFnaW5hdGlvbi5wcm90b3R5cGUsIFwiYWN0aXZlU3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQYWdpbmF0aW9uLnByb3RvdHlwZSwgXCJpbmFjdGl2ZVN0eWxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgUGFnaW5hdGlvbi5wcm90b3R5cGUsIFwiaGlnaGxpZ2h0U3R5bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQYWdpbmF0aW9uLnByb3RvdHlwZSwgXCJsYWJlbFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbGVnZW5kLnRzXG52YXIgTGVnZW5kTGFiZWwgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLm1heExlbmd0aCA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbG9yID0gXCJibGFja1wiO1xuICAgIHRoaXMuZm9udFN0eWxlID0gdm9pZCAwO1xuICAgIHRoaXMuZm9udFdlaWdodCA9IHZvaWQgMDtcbiAgICB0aGlzLmZvbnRTaXplID0gMTI7XG4gICAgdGhpcy5mb250RmFtaWx5ID0gXCJWZXJkYW5hLCBzYW5zLXNlcmlmXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZExhYmVsLnByb3RvdHlwZSwgXCJtYXhMZW5ndGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcpXG5dLCBMZWdlbmRMYWJlbC5wcm90b3R5cGUsIFwiY29sb3JcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGT05UX1NUWUxFLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmRMYWJlbC5wcm90b3R5cGUsIFwiZm9udFN0eWxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRk9OVF9XRUlHSFQsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZExhYmVsLnByb3RvdHlwZSwgXCJmb250V2VpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgTGVnZW5kTGFiZWwucHJvdG90eXBlLCBcImZvbnRTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgTGVnZW5kTGFiZWwucHJvdG90eXBlLCBcImZvbnRGYW1pbHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTGFiZWwucHJvdG90eXBlLCBcImZvcm1hdHRlclwiLCAyKTtcbnZhciBMZWdlbmRNYXJrZXIgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnNpemUgPSAxNTtcbiAgICB0aGlzLnBhZGRpbmcgPSA4O1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCkgPT4gdGFyZ2V0LnBhcmVudD8ub25NYXJrZXJTaGFwZUNoYW5nZSgpKVxuXSwgTGVnZW5kTWFya2VyLnByb3RvdHlwZSwgXCJzaGFwZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIExlZ2VuZE1hcmtlci5wcm90b3R5cGUsIFwic2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIExlZ2VuZE1hcmtlci5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTWFya2VyLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBMZWdlbmRNYXJrZXIucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG52YXIgTGVnZW5kTGluZSA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTGluZS5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZExpbmUucHJvdG90eXBlLCBcImxlbmd0aFwiLCAyKTtcbnZhciBMZWdlbmRJdGVtID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5wYWRkaW5nWCA9IDE2O1xuICAgIHRoaXMucGFkZGluZ1kgPSA4O1xuICAgIHRoaXMuc2hvd1Nlcmllc1N0cm9rZSA9IGZhbHNlO1xuICAgIHRoaXMubWFya2VyID0gbmV3IExlZ2VuZE1hcmtlcigpO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgTGVnZW5kTGFiZWwoKTtcbiAgICB0aGlzLmxpbmUgPSBuZXcgTGVnZW5kTGluZSgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmRJdGVtLnByb3RvdHlwZSwgXCJtYXhXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIExlZ2VuZEl0ZW0ucHJvdG90eXBlLCBcInBhZGRpbmdYXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgTGVnZW5kSXRlbS5wcm90b3R5cGUsIFwicGFkZGluZ1lcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgTGVnZW5kSXRlbS5wcm90b3R5cGUsIFwic2hvd1Nlcmllc1N0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIExlZ2VuZEl0ZW0ucHJvdG90eXBlLCBcIm1hcmtlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIExlZ2VuZEl0ZW0ucHJvdG90eXBlLCBcImxhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGVnZW5kSXRlbS5wcm90b3R5cGUsIFwibGluZVwiLCAyKTtcbnZhciBMZWdlbmRMaXN0ZW5lcnMgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTGlzdGVuZXJzLnByb3RvdHlwZSwgXCJsZWdlbmRJdGVtQ2xpY2tcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kTGlzdGVuZXJzLnByb3RvdHlwZSwgXCJsZWdlbmRJdGVtRG91YmxlQ2xpY2tcIiwgMik7XG52YXIgSURfTEVHRU5EX1ZJU0lCSUxJVFkgPSBcImxlZ2VuZC12aXNpYmlsaXR5XCI7XG52YXIgSURfTEVHRU5EX09USEVSX1NFUklFUyA9IFwibGVnZW5kLW90aGVyLXNlcmllc1wiO1xudmFyIExlZ2VuZCA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuaWQgPSBjcmVhdGVJZCh0aGlzKTtcbiAgICB0aGlzLmdyb3VwID0gbmV3IEdyb3VwKHsgbmFtZTogXCJsZWdlbmRcIiwgbGF5ZXI6IHRydWUsIHpJbmRleDogMTMgLyogTEVHRU5EX1pJTkRFWCAqLyB9KTtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy5ncm91cCxcbiAgICAgIExlZ2VuZE1hcmtlckxhYmVsXG4gICAgKTtcbiAgICB0aGlzLnNwcml0ZVJlbmRlcmVyID0gbmV3IFNwcml0ZVJlbmRlcmVyKCk7XG4gICAgdGhpcy5vbGRTaXplID0gWzAsIDBdO1xuICAgIHRoaXMucGFnZXMgPSBbXTtcbiAgICB0aGlzLm1heFBhZ2VTaXplID0gWzAsIDBdO1xuICAgIC8qKiBJdGVtIGluZGV4IHRvIHRyYWNrIG9uIHJlLXBhZ2luYXRpb24sIHNvIGN1cnJlbnQgcGFnZSB1cGRhdGVzIGFwcHJvcHJpYXRlbHkuICovXG4gICAgdGhpcy5wYWdpbmF0aW9uVHJhY2tpbmdJbmRleCA9IDA7XG4gICAgdGhpcy50cnVuY2F0ZWRJdGVtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5fZGF0YSA9IFtdO1xuICAgIHRoaXMudG9nZ2xlU2VyaWVzID0gdHJ1ZTtcbiAgICB0aGlzLml0ZW0gPSBuZXcgTGVnZW5kSXRlbSgpO1xuICAgIHRoaXMubGlzdGVuZXJzID0gbmV3IExlZ2VuZExpc3RlbmVycygpO1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5wb3NpdGlvbiA9IFwiYm90dG9tXCI7XG4gICAgdGhpcy5zcGFjaW5nID0gMjA7XG4gICAgdGhpcy5kZXN0cm95Rm5zID0gW107XG4gICAgdGhpcy5zaXplID0gWzAsIDBdO1xuICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuICAgIHRoaXMuaXRlbS5tYXJrZXIucGFyZW50ID0gdGhpcztcbiAgICB0aGlzLnBhZ2luYXRpb24gPSBuZXcgUGFnaW5hdGlvbihcbiAgICAgICh0eXBlKSA9PiBjdHgudXBkYXRlU2VydmljZS51cGRhdGUodHlwZSksXG4gICAgICAocGFnZSkgPT4gdGhpcy51cGRhdGVQYWdlTnVtYmVyKHBhZ2UpLFxuICAgICAgY3R4LnJlZ2lvbk1hbmFnZXIsXG4gICAgICBjdHguY3Vyc29yTWFuYWdlclxuICAgICk7XG4gICAgdGhpcy5wYWdpbmF0aW9uLmF0dGFjaFBhZ2luYXRpb24odGhpcy5ncm91cCk7XG4gICAgY3R4LmNvbnRleHRNZW51UmVnaXN0cnkucmVnaXN0ZXJEZWZhdWx0QWN0aW9uKHtcbiAgICAgIGlkOiBJRF9MRUdFTkRfVklTSUJJTElUWSxcbiAgICAgIHR5cGU6IFwibGVnZW5kXCIsXG4gICAgICBsYWJlbDogXCJjb250ZXh0TWVudVRvZ2dsZVNlcmllc1Zpc2liaWxpdHlcIixcbiAgICAgIGFjdGlvbjogKHBhcmFtcykgPT4gdGhpcy5jb250ZXh0VG9nZ2xlVmlzaWJpbGl0eShwYXJhbXMpXG4gICAgfSk7XG4gICAgY3R4LmNvbnRleHRNZW51UmVnaXN0cnkucmVnaXN0ZXJEZWZhdWx0QWN0aW9uKHtcbiAgICAgIGlkOiBJRF9MRUdFTkRfT1RIRVJfU0VSSUVTLFxuICAgICAgdHlwZTogXCJsZWdlbmRcIixcbiAgICAgIGxhYmVsOiBcImNvbnRleHRNZW51VG9nZ2xlT3RoZXJTZXJpZXNcIixcbiAgICAgIGFjdGlvbjogKHBhcmFtcykgPT4gdGhpcy5jb250ZXh0VG9nZ2xlT3RoZXJTZXJpZXMocGFyYW1zKVxuICAgIH0pO1xuICAgIGNvbnN0IHsgRGVmYXVsdDogRGVmYXVsdDIsIEFuaW1hdGlvbjogQW5pbWF0aW9uMiwgQ29udGV4dE1lbnUgfSA9IEludGVyYWN0aW9uU3RhdGU7XG4gICAgY29uc3QgYW5pbWF0aW9uU3RhdGUgPSBEZWZhdWx0MiB8IEFuaW1hdGlvbjI7XG4gICAgY29uc3QgY29udGV4dE1lbnVTdGF0ZSA9IERlZmF1bHQyIHwgQW5pbWF0aW9uMiB8IENvbnRleHRNZW51O1xuICAgIGNvbnN0IHJlZ2lvbiA9IGN0eC5yZWdpb25NYW5hZ2VyLmFkZFJlZ2lvbihcImxlZ2VuZFwiLCB0aGlzLmdyb3VwKTtcbiAgICB0aGlzLmRlc3Ryb3lGbnMucHVzaChcbiAgICAgIHJlZ2lvbi5hZGRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIChlKSA9PiB0aGlzLmNoZWNrQ29udGV4dENsaWNrKGUpLCBjb250ZXh0TWVudVN0YXRlKSxcbiAgICAgIHJlZ2lvbi5hZGRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB0aGlzLmNoZWNrTGVnZW5kQ2xpY2soZSksIGFuaW1hdGlvblN0YXRlKSxcbiAgICAgIHJlZ2lvbi5hZGRMaXN0ZW5lcihcImRibGNsaWNrXCIsIChlKSA9PiB0aGlzLmNoZWNrTGVnZW5kRG91YmxlQ2xpY2soZSksIGFuaW1hdGlvblN0YXRlKSxcbiAgICAgIHJlZ2lvbi5hZGRMaXN0ZW5lcihcImhvdmVyXCIsIChlKSA9PiB0aGlzLmhhbmRsZUxlZ2VuZE1vdXNlTW92ZShlKSwgYW5pbWF0aW9uU3RhdGUpLFxuICAgICAgcmVnaW9uLmFkZExpc3RlbmVyKFwibGVhdmVcIiwgKCkgPT4gdGhpcy5oYW5kbGVMZWdlbmRNb3VzZUV4aXQoKSwgYW5pbWF0aW9uU3RhdGUpLFxuICAgICAgcmVnaW9uLmFkZExpc3RlbmVyKFwiZW50ZXJcIiwgKGUpID0+IHRoaXMuaGFuZGxlTGVnZW5kTW91c2VFbnRlcihlKSwgYW5pbWF0aW9uU3RhdGUpLFxuICAgICAgY3R4LmxheW91dFNlcnZpY2UuYWRkTGlzdGVuZXIoXCJzdGFydC1sYXlvdXRcIiwgKGUpID0+IHRoaXMucG9zaXRpb25MZWdlbmQoZSkpLFxuICAgICAgY3R4LmxvY2FsZU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJsb2NhbGUtY2hhbmdlZFwiLCAoKSA9PiB0aGlzLm9uTG9jYWxlQ2hhbmdlZCgpKSxcbiAgICAgICgpID0+IHRoaXMuZ3JvdXAucGFyZW50Py5yZW1vdmVDaGlsZCh0aGlzLmdyb3VwKVxuICAgICk7XG4gICAgdGhpcy5wcm94eUxlZ2VuZFRvb2xiYXIgPSB0aGlzLmN0eC5wcm94eUludGVyYWN0aW9uU2VydmljZS5jcmVhdGVQcm94eUNvbnRhaW5lcih7XG4gICAgICB0eXBlOiBcInRvb2xiYXJcIixcbiAgICAgIGlkOiBgJHt0aGlzLmlkfS10b29sYmFyYCxcbiAgICAgIGNsYXNzTGlzdDogW1wiYWctY2hhcnRzLXByb3h5LWxlZ2VuZC10b29sYmFyXCJdLFxuICAgICAgYXJpYUxhYmVsOiB7IGlkOiBcImFyaWFMYWJlbExlZ2VuZFwiIH0sXG4gICAgICBhcmlhT3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgYXJpYUhpZGRlbjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMucHJveHlMZWdlbmRQYWdpbmF0aW9uID0gdGhpcy5jdHgucHJveHlJbnRlcmFjdGlvblNlcnZpY2UuY3JlYXRlUHJveHlDb250YWluZXIoe1xuICAgICAgdHlwZTogXCJncm91cFwiLFxuICAgICAgaWQ6IGAke3RoaXMuaWR9LXBhZ2luYXRpb25gLFxuICAgICAgY2xhc3NMaXN0OiBbXCJhZy1jaGFydHMtcHJveHktbGVnZW5kLXBhZ2luYXRpb25cIl0sXG4gICAgICBhcmlhTGFiZWw6IHsgaWQ6IFwiYXJpYUxhYmVsTGVnZW5kUGFnaW5hdGlvblwiIH0sXG4gICAgICBhcmlhT3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgYXJpYUhpZGRlbjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHNldCBkYXRhKHZhbHVlKSB7XG4gICAgdGhpcy5fZGF0YSA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlR3JvdXBWaXNpYmlsaXR5KCk7XG4gIH1cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmN0eC5kb21NYW5hZ2VyLnJlbW92ZUNoaWxkKFwiY2FudmFzLW92ZXJsYXlcIiwgYCR7dGhpcy5pZH0tdG9vbGJhcmApO1xuICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIucmVtb3ZlQ2hpbGQoXCJjYW52YXMtb3ZlcmxheVwiLCBgJHt0aGlzLmlkfS1wYWdpbmF0aW9uYCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLmZvckVhY2goKGYpID0+IGYoKSk7XG4gICAgdGhpcy5wYWdpbmF0aW9uLmRlc3Ryb3koKTtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uY2xlYXIoKTtcbiAgfVxuICBpbml0TGVnZW5kSXRlbVRvb2xiYXIoKSB7XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLmVhY2goKG1hcmtlckxhYmVsLCBfLCBpKSA9PiB7XG4gICAgICBtYXJrZXJMYWJlbC5wcm94eUJ1dHRvbiA/PyAobWFya2VyTGFiZWwucHJveHlCdXR0b24gPSB0aGlzLmN0eC5wcm94eUludGVyYWN0aW9uU2VydmljZS5jcmVhdGVQcm94eUVsZW1lbnQoe1xuICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICBpZDogYGFnLWNoYXJ0cy1sZWdlbmQtaXRlbS0ke2l9YCxcbiAgICAgICAgdGV4dENvbnRlbnQ6IHRoaXMuZ2V0SXRlbUFyaWFUZXh0KGkpLFxuICAgICAgICBwYXJlbnQ6IHRoaXMucHJveHlMZWdlbmRUb29sYmFyLFxuICAgICAgICBmb2N1c2FibGU6IG1hcmtlckxhYmVsLFxuICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgZGF0dW0gZnJvbSB0aGUgbm9kZSByYXRoZXIgdGhhbiBmcm9tIHRoZSBtZXRob2QgcGFyYW1ldGVyLlxuICAgICAgICAvLyBUaGUgbWV0aG9kIHBhcmFtZXRlciBgZGF0dW1gIGdldHMgZGVzdHJveWVkIHdoZW4gdGhlIGRhdGEgaXMgcmVmcmVzaGVkXG4gICAgICAgIC8vIHVzaW5nIFNlcmllcy5nZXRMZWdlbmREYXRhKCkuIEJ1dCB0aGUgc2NlbmUgbm9kZSB3aWxsIHN0YXkgdGhlIHNhbWUuXG4gICAgICAgIG9uY2xpY2s6ICgpID0+IHtcbiAgICAgICAgICB0aGlzLmRvQ2xpY2sobWFya2VyTGFiZWwuZGF0dW0pO1xuICAgICAgICAgIG1hcmtlckxhYmVsLnByb3h5QnV0dG9uLnRleHRDb250ZW50ID0gdGhpcy5nZXRJdGVtQXJpYVRleHQoaSwgIW1hcmtlckxhYmVsLmRhdHVtLmVuYWJsZWQpO1xuICAgICAgICB9LFxuICAgICAgICBvbmJsdXI6ICgpID0+IHRoaXMuaGFuZGxlTGVnZW5kTW91c2VFeGl0KCksXG4gICAgICAgIG9uZm9jdXM6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBib3VuZHMgPSBtYXJrZXJMYWJlbD8uY29tcHV0ZVRyYW5zZm9ybWVkQkJveCgpO1xuICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbWFrZUtleWJvYXJkUG9pbnRlckV2ZW50KHRoaXMuY3R4LmZvY3VzSW5kaWNhdG9yLCB7IGJvdW5kcywgc2hvd0ZvY3VzQm94OiB0cnVlIH0pO1xuICAgICAgICAgIHRoaXMuZG9Ib3ZlcihldmVudCwgbWFya2VyTGFiZWwuZGF0dW0pO1xuICAgICAgICAgIHRoaXMucGFnaW5hdGlvbi5zZXRQYWdlKG1hcmtlckxhYmVsLnBhZ2VJbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICBjb25zdCBidXR0b25zID0gdGhpcy5pdGVtU2VsZWN0aW9uLm5vZGVzKCkubWFwKChtYXJrZXJMYWJlbCkgPT4gbWFya2VyTGFiZWwucHJveHlCdXR0b24pLmZpbHRlcigoYnV0dG9uKSA9PiAhIWJ1dHRvbik7XG4gICAgaW5pdFRvb2xiYXJLZXlOYXYoe1xuICAgICAgb3JpZW50YXRpb246IHRoaXMuZ2V0T3JpZW50YXRpb24oKSxcbiAgICAgIGJ1dHRvbnMsXG4gICAgICB0b29sYmFyOiB0aGlzLnByb3h5TGVnZW5kVG9vbGJhclxuICAgIH0pO1xuICB9XG4gIG9uTWFya2VyU2hhcGVDaGFuZ2UoKSB7XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgdGhpcy5ncm91cC5tYXJrRGlydHkodGhpcy5ncm91cCwgMiAvKiBNSU5PUiAqLyk7XG4gIH1cbiAgZ2V0T3JpZW50YXRpb24oKSB7XG4gICAgaWYgKHRoaXMub3JpZW50YXRpb24gIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHRoaXMub3JpZW50YXRpb247XG4gICAgfVxuICAgIHN3aXRjaCAodGhpcy5wb3NpdGlvbikge1xuICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICByZXR1cm4gXCJ2ZXJ0aWNhbFwiO1xuICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICByZXR1cm4gXCJob3Jpem9udGFsXCI7XG4gICAgfVxuICB9XG4gIHNldCB2aXNpYmxlKHZhbHVlKSB7XG4gICAgdGhpcy5fdmlzaWJsZSA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlR3JvdXBWaXNpYmlsaXR5KCk7XG4gIH1cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Zpc2libGU7XG4gIH1cbiAgdXBkYXRlR3JvdXBWaXNpYmlsaXR5KCkge1xuICAgIHRoaXMuZ3JvdXAudmlzaWJsZSA9IHRoaXMuZW5hYmxlZCAmJiB0aGlzLnZpc2libGUgJiYgdGhpcy5kYXRhLmxlbmd0aCA+IDA7XG4gIH1cbiAgYXR0YWNoTGVnZW5kKHNjZW5lKSB7XG4gICAgc2NlbmUuYXBwZW5kQ2hpbGQodGhpcy5ncm91cCk7XG4gIH1cbiAgZ2V0SXRlbUxhYmVsKGRhdHVtKSB7XG4gICAgY29uc3Qge1xuICAgICAgY3R4OiB7IGNhbGxiYWNrQ2FjaGUgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgZm9ybWF0dGVyIH0gPSB0aGlzLml0ZW0ubGFiZWw7XG4gICAgaWYgKGZvcm1hdHRlcikge1xuICAgICAgcmV0dXJuIGNhbGxiYWNrQ2FjaGUuY2FsbChmb3JtYXR0ZXIsIHtcbiAgICAgICAgaXRlbUlkOiBkYXR1bS5pdGVtSWQsXG4gICAgICAgIHZhbHVlOiBkYXR1bS5sYWJlbC50ZXh0LFxuICAgICAgICBzZXJpZXNJZDogZGF0dW0uc2VyaWVzSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGF0dW0ubGFiZWwudGV4dDtcbiAgfVxuICAvKipcbiAgICogVGhlIG1ldGhvZCBpcyBnaXZlbiB0aGUgZGVzaXJlZCBzaXplIG9mIHRoZSBsZWdlbmQsIHdoaWNoIG9ubHkgc2VydmVzIGFzIGEgaGludC5cbiAgICogVGhlIHZlcnRpY2FsbHkgb3JpZW50ZWQgbGVnZW5kIHdpbGwgdGFrZSBhcyBtdWNoIGhvcml6b250YWwgc3BhY2UgYXMgbmVlZGVkLCBidXQgd2lsbFxuICAgKiByZXNwZWN0IHRoZSBoZWlnaHQgY29uc3RyYWludHMsIGFuZCB0aGUgaG9yaXpvbnRhbCBsZWdlbmQgd2lsbCB0YWtlIGFzIG11Y2ggdmVydGljYWxcbiAgICogc3BhY2UgYXMgbmVlZGVkIGluIGFuIGF0dGVtcHQgbm90IHRvIGV4Y2VlZCB0aGUgZ2l2ZW4gd2lkdGguXG4gICAqIEFmdGVyIHRoZSBsYXlvdXQgaXMgZG9uZSwgdGhlIHtAbGluayBzaXplfSB3aWxsIGNvbnRhaW4gdGhlIGFjdHVhbCBzaXplIG9mIHRoZSBsZWdlbmQuXG4gICAqIElmIHRoZSBhY3R1YWwgc2l6ZSBpcyBub3QgdGhlIHNhbWUgYXMgdGhlIHByZXZpb3VzIGFjdHVhbCBzaXplLCB0aGUgbGVnZW5kIHdpbGwgZmlyZVxuICAgKiB0aGUgJ2xheW91dENoYW5nZScgZXZlbnQgdG8gY29tbXVuaWNhdGUgdGhhdCBhbm90aGVyIGxheW91dCBpcyBuZWVkZWQsIGFuZCB0aGUgYWJvdmVcbiAgICogcHJvY2VzcyBzaG91bGQgYmUgcmVwZWF0ZWQuXG4gICAqIEBwYXJhbSB3aWR0aFxuICAgKiBAcGFyYW0gaGVpZ2h0XG4gICAqL1xuICBjYWxjTGF5b3V0KHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYWRkaW5nWCxcbiAgICAgIHBhZGRpbmdZLFxuICAgICAgbGFiZWwsXG4gICAgICBtYXhXaWR0aCxcbiAgICAgIGxhYmVsOiB7IG1heExlbmd0aCA9IEluZmluaXR5LCBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5IH1cbiAgICB9ID0gdGhpcy5pdGVtO1xuICAgIGNvbnN0IGRhdGEgPSBbLi4udGhpcy5kYXRhXTtcbiAgICBpZiAodGhpcy5yZXZlcnNlT3JkZXIpIHtcbiAgICAgIGRhdGEucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBjb25zdCBwcm94eVRvb2xiYXJOZWVkc1VwZGF0ZSA9IHRoaXMuaXRlbVNlbGVjdGlvbi5ub2RlcygpLmxlbmd0aCA9PT0gMDtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24udXBkYXRlKGRhdGEpO1xuICAgIGlmIChwcm94eVRvb2xiYXJOZWVkc1VwZGF0ZSkge1xuICAgICAgdGhpcy5pbml0TGVnZW5kSXRlbVRvb2xiYXIoKTtcbiAgICB9XG4gICAgY29uc3QgYmJveGVzID0gW107XG4gICAgY29uc3QgZm9udCA9IFRleHRVdGlscy50b0ZvbnRTdHJpbmcobGFiZWwpO1xuICAgIGNvbnN0IGl0ZW1NYXhXaWR0aFBlcmNlbnRhZ2UgPSAwLjg7XG4gICAgY29uc3QgbWF4SXRlbVdpZHRoID0gbWF4V2lkdGggPz8gd2lkdGggKiBpdGVtTWF4V2lkdGhQZXJjZW50YWdlO1xuICAgIGNvbnN0IHNwcml0ZURpbXMgPSB0aGlzLmNhbGN1bGF0ZVNwcml0ZURpbWVuc2lvbnMoKTtcbiAgICB0aGlzLnNwcml0ZVJlbmRlcmVyLnJlc2l6ZShzcHJpdGVEaW1zKTtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uZWFjaCgobWFya2VyTGFiZWwsIGRhdHVtKSA9PiB7XG4gICAgICBtYXJrZXJMYWJlbC5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgICBtYXJrZXJMYWJlbC5mb250V2VpZ2h0ID0gZm9udFdlaWdodDtcbiAgICAgIG1hcmtlckxhYmVsLmZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICBtYXJrZXJMYWJlbC5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgIGNvbnN0IHBhZGRlZFN5bWJvbFdpZHRoID0gdGhpcy51cGRhdGVNYXJrZXJMYWJlbChtYXJrZXJMYWJlbCwgZGF0dW0sIHNwcml0ZURpbXMpO1xuICAgICAgY29uc3QgaWQgPSBkYXR1bS5pdGVtSWQgPz8gZGF0dW0uaWQ7XG4gICAgICBjb25zdCBsYWJlbFRleHQgPSB0aGlzLmdldEl0ZW1MYWJlbChkYXR1bSk7XG4gICAgICBjb25zdCB0ZXh0ID0gKGxhYmVsVGV4dCA/PyBcIjx1bmtub3duPlwiKS5yZXBsYWNlKC9cXHI/XFxuL2csIFwiIFwiKTtcbiAgICAgIG1hcmtlckxhYmVsLnRleHQgPSB0aGlzLnRydW5jYXRlKHRleHQsIG1heExlbmd0aCwgbWF4SXRlbVdpZHRoLCBwYWRkZWRTeW1ib2xXaWR0aCwgZm9udCwgaWQpO1xuICAgICAgYmJveGVzLnB1c2gobWFya2VyTGFiZWwuZ2V0QkJveCgpKTtcbiAgICB9KTtcbiAgICB3aWR0aCA9IE1hdGgubWF4KDEsIHdpZHRoKTtcbiAgICBoZWlnaHQgPSBNYXRoLm1heCgxLCBoZWlnaHQpO1xuICAgIGlmICghaXNGaW5pdGUod2lkdGgpKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHNpemUgPSB0aGlzLnNpemU7XG4gICAgY29uc3Qgb2xkU2l6ZSA9IHRoaXMub2xkU2l6ZTtcbiAgICBzaXplWzBdID0gd2lkdGg7XG4gICAgc2l6ZVsxXSA9IGhlaWdodDtcbiAgICBpZiAoc2l6ZVswXSAhPT0gb2xkU2l6ZVswXSB8fCBzaXplWzFdICE9PSBvbGRTaXplWzFdKSB7XG4gICAgICBvbGRTaXplWzBdID0gc2l6ZVswXTtcbiAgICAgIG9sZFNpemVbMV0gPSBzaXplWzFdO1xuICAgIH1cbiAgICBjb25zdCB7IHBhZ2VzLCBtYXhQYWdlSGVpZ2h0LCBtYXhQYWdlV2lkdGggfSA9IHRoaXMudXBkYXRlUGFnaW5hdGlvbihiYm94ZXMsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGNvbnN0IG9sZFBhZ2VzID0gdGhpcy5wYWdlcztcbiAgICB0aGlzLnBhZ2VzID0gcGFnZXM7XG4gICAgdGhpcy5tYXhQYWdlU2l6ZSA9IFttYXhQYWdlV2lkdGggLSBwYWRkaW5nWCwgbWF4UGFnZUhlaWdodCAtIHBhZGRpbmdZXTtcbiAgICBjb25zdCBwYWdlTnVtYmVyID0gdGhpcy5wYWdpbmF0aW9uLmN1cnJlbnRQYWdlO1xuICAgIGNvbnN0IHBhZ2UgPSB0aGlzLnBhZ2VzW3BhZ2VOdW1iZXJdO1xuICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA8IDEgfHwgIXBhZ2UpIHtcbiAgICAgIHRoaXMudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHsgb2xkUGFnZXMgfTtcbiAgICB9XG4gICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9ucyhwYWdlTnVtYmVyKTtcbiAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIHJldHVybiB7IG9sZFBhZ2VzIH07XG4gIH1cbiAgY2FsY1N5bWJvbHNFbmFibGVkKHN5bWJvbCkge1xuICAgIGNvbnN0IHsgc2hvd1Nlcmllc1N0cm9rZSwgbWFya2VyIH0gPSB0aGlzLml0ZW07XG4gICAgY29uc3QgbWFya2VyRW5hYmxlZCA9ICEhbWFya2VyLmVuYWJsZWQgfHwgIXNob3dTZXJpZXNTdHJva2UgfHwgKHN5bWJvbC5tYXJrZXIuZW5hYmxlZCA/PyB0cnVlKTtcbiAgICBjb25zdCBsaW5lRW5hYmxlZCA9ICEhKHN5bWJvbC5saW5lICYmIHNob3dTZXJpZXNTdHJva2UpO1xuICAgIHJldHVybiB7IG1hcmtlckVuYWJsZWQsIGxpbmVFbmFibGVkIH07XG4gIH1cbiAgY2FsY1N5bWJvbHNMZW5ndGhzKHN5bWJvbCkge1xuICAgIGNvbnN0IHsgbWFya2VyLCBsaW5lIH0gPSB0aGlzLml0ZW07XG4gICAgY29uc3QgeyBtYXJrZXJFbmFibGVkLCBsaW5lRW5hYmxlZCB9ID0gdGhpcy5jYWxjU3ltYm9sc0VuYWJsZWQoc3ltYm9sKTtcbiAgICBjb25zdCB7IHN0cm9rZVdpZHRoOiBtYXJrZXJTdHJva2VXaWR0aCB9ID0gdGhpcy5nZXRNYXJrZXJTdHlsZXMoc3ltYm9sKTtcbiAgICBjb25zdCB7IHN0cm9rZVdpZHRoOiBsaW5lU3Ryb2tlV2lkdGggfSA9IGxpbmVFbmFibGVkID8gdGhpcy5nZXRMaW5lU3R5bGVzKHN5bWJvbCkgOiB7IHN0cm9rZVdpZHRoOiAwIH07XG4gICAgY29uc3QgbWFya2VyTGVuZ3RoID0gbWFya2VyRW5hYmxlZCA/IG1hcmtlci5zaXplIDogMDtcbiAgICBjb25zdCBsaW5lTGVuZ3RoID0gbGluZUVuYWJsZWQgPyBsaW5lLmxlbmd0aCA/PyAyNSA6IDA7XG4gICAgcmV0dXJuIHsgbWFya2VyTGVuZ3RoLCBtYXJrZXJTdHJva2VXaWR0aCwgbGluZUxlbmd0aCwgbGluZVN0cm9rZVdpZHRoIH07XG4gIH1cbiAgY2FsY3VsYXRlU3ByaXRlRGltZW5zaW9ucygpIHtcbiAgICBsZXQgc3ByaXRlQUFQYWRkaW5nID0gMDtcbiAgICBsZXQgc3ByaXRlV2lkdGggPSAwO1xuICAgIGxldCBzcHJpdGVIZWlnaHQgPSAwO1xuICAgIGxldCBtYXJrZXJXaWR0aCA9IDA7XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLmVhY2goKF8sIGRhdHVtKSA9PiB7XG4gICAgICBkYXR1bS5zeW1ib2xzLmZvckVhY2goKHN5bWJvbCkgPT4ge1xuICAgICAgICBjb25zdCB7IG1hcmtlckxlbmd0aCwgbWFya2VyU3Ryb2tlV2lkdGgsIGxpbmVMZW5ndGgsIGxpbmVTdHJva2VXaWR0aCB9ID0gdGhpcy5jYWxjU3ltYm9sc0xlbmd0aHMoc3ltYm9sKTtcbiAgICAgICAgY29uc3QgbWFya2VyVG90YWxMZW5ndGggPSBtYXJrZXJMZW5ndGggKyBtYXJrZXJTdHJva2VXaWR0aDtcbiAgICAgICAgbWFya2VyV2lkdGggPSBNYXRoLm1heChtYXJrZXJXaWR0aCwgbGluZUxlbmd0aCwgbWFya2VyTGVuZ3RoKTtcbiAgICAgICAgc3ByaXRlV2lkdGggPSBNYXRoLm1heChzcHJpdGVXaWR0aCwgbGluZUxlbmd0aCwgbWFya2VyVG90YWxMZW5ndGgpO1xuICAgICAgICBzcHJpdGVIZWlnaHQgPSBNYXRoLm1heChzcHJpdGVIZWlnaHQsIGxpbmVTdHJva2VXaWR0aCwgbWFya2VyVG90YWxMZW5ndGgpO1xuICAgICAgICBzcHJpdGVBQVBhZGRpbmcgPSBNYXRoLm1heChzcHJpdGVBQVBhZGRpbmcsIG1hcmtlclN0cm9rZVdpZHRoICsgMC41KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHNwcml0ZVdpZHRoICs9IHNwcml0ZUFBUGFkZGluZyAqIDI7XG4gICAgc3ByaXRlSGVpZ2h0ICs9IHNwcml0ZUFBUGFkZGluZyAqIDI7XG4gICAgY29uc3Qgc3ByaXRlUGl4ZWxSYXRpbyA9IGdldFdpbmRvdygpLmRldmljZVBpeGVsUmF0aW87XG4gICAgcmV0dXJuIHsgc3ByaXRlUGl4ZWxSYXRpbywgc3ByaXRlQUFQYWRkaW5nLCBzcHJpdGVXaWR0aCwgc3ByaXRlSGVpZ2h0LCBtYXJrZXJXaWR0aCB9O1xuICB9XG4gIHVwZGF0ZU1hcmtlckxhYmVsKG1hcmtlckxhYmVsLCBkYXR1bSwgc3ByaXRlRGltcykge1xuICAgIGNvbnN0IHsgbWFya2VyOiBpdGVtTWFya2VyLCBwYWRkaW5nWCB9ID0gdGhpcy5pdGVtO1xuICAgIGNvbnN0IHsgbWFya2VyV2lkdGggfSA9IHNwcml0ZURpbXM7XG4gICAgY29uc3QgZGltZW5zaW9uUHJvcHMgPSBbXTtcbiAgICBsZXQgcGFkZGVkU3ltYm9sV2lkdGggPSBwYWRkaW5nWDtcbiAgICBpZiAobWFya2VyTGFiZWwubWFya2Vycy5sZW5ndGggIT09IGRhdHVtLnN5bWJvbHMubGVuZ3RoICYmIG1hcmtlckxhYmVsLmxpbmVzLmxlbmd0aCAhPT0gZGF0dW0uc3ltYm9scy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG1hcmtlcnMgPSBbXTtcbiAgICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgICBkYXR1bS5zeW1ib2xzLmZvckVhY2goKHN5bWJvbCkgPT4ge1xuICAgICAgICBjb25zdCB7IHNoYXBlOiBtYXJrZXJTaGFwZSA9IHN5bWJvbC5tYXJrZXIuc2hhcGUgfSA9IGl0ZW1NYXJrZXI7XG4gICAgICAgIGNvbnN0IE1hcmtlckN0ciA9IGdldE1hcmtlcihtYXJrZXJTaGFwZSk7XG4gICAgICAgIGxpbmVzLnB1c2gobmV3IExpbmUoKSk7XG4gICAgICAgIG1hcmtlcnMucHVzaChuZXcgTWFya2VyQ3RyKCkpO1xuICAgICAgfSk7XG4gICAgICBtYXJrZXJMYWJlbC51cGRhdGVTeW1ib2xzKG1hcmtlcnMsIGxpbmVzKTtcbiAgICB9XG4gICAgZGF0dW0uc3ltYm9scy5mb3JFYWNoKChzeW1ib2wsIGkpID0+IHtcbiAgICAgIGNvbnN0IHNwYWNpbmcgPSBzeW1ib2wubWFya2VyLnBhZGRpbmcgPz8gaXRlbU1hcmtlci5wYWRkaW5nO1xuICAgICAgY29uc3QgeyBtYXJrZXJFbmFibGVkLCBsaW5lRW5hYmxlZCB9ID0gdGhpcy5jYWxjU3ltYm9sc0VuYWJsZWQoc3ltYm9sKTtcbiAgICAgIG1hcmtlckxhYmVsLm1hcmtlcnNbaV0uc2l6ZSA9IG1hcmtlckVuYWJsZWQgfHwgIWxpbmVFbmFibGVkID8gaXRlbU1hcmtlci5zaXplIDogMDtcbiAgICAgIGRpbWVuc2lvblByb3BzLnB1c2goeyBsZW5ndGg6IG1hcmtlcldpZHRoLCBzcGFjaW5nIH0pO1xuICAgICAgaWYgKG1hcmtlckVuYWJsZWQgfHwgbGluZUVuYWJsZWQpIHtcbiAgICAgICAgcGFkZGVkU3ltYm9sV2lkdGggKz0gc3BhY2luZyArIG1hcmtlcldpZHRoO1xuICAgICAgfVxuICAgICAgY29uc3QgbWFya2VyID0gbWFya2VyTGFiZWwubWFya2Vyc1tpXTtcbiAgICAgIGNvbnN0IGxpbmUgPSBtYXJrZXJMYWJlbC5saW5lc1tpXTtcbiAgICAgIGlmIChtYXJrZXIpIHtcbiAgICAgICAgY29uc3QgeyBzdHJva2VXaWR0aCwgZmlsbCwgc3Ryb2tlLCBmaWxsT3BhY2l0eSwgc3Ryb2tlT3BhY2l0eSB9ID0gdGhpcy5nZXRNYXJrZXJTdHlsZXMoc3ltYm9sKTtcbiAgICAgICAgbWFya2VyLmZpbGwgPSBmaWxsO1xuICAgICAgICBtYXJrZXIuc3Ryb2tlID0gc3Ryb2tlO1xuICAgICAgICBtYXJrZXIuc3Ryb2tlV2lkdGggPSBzdHJva2VXaWR0aDtcbiAgICAgICAgbWFya2VyLmZpbGxPcGFjaXR5ID0gZmlsbE9wYWNpdHk7XG4gICAgICAgIG1hcmtlci5zdHJva2VPcGFjaXR5ID0gc3Ryb2tlT3BhY2l0eTtcbiAgICAgIH1cbiAgICAgIGlmIChsaW5lKSB7XG4gICAgICAgIGNvbnN0IGxpbmVTdHlsZXMgPSB0aGlzLmdldExpbmVTdHlsZXMoc3ltYm9sKTtcbiAgICAgICAgbGluZS5zdHJva2UgPSBsaW5lU3R5bGVzLnN0cm9rZTtcbiAgICAgICAgbGluZS5zdHJva2VPcGFjaXR5ID0gbGluZVN0eWxlcy5zdHJva2VPcGFjaXR5O1xuICAgICAgICBsaW5lLnN0cm9rZVdpZHRoID0gbGluZVN0eWxlcy5zdHJva2VXaWR0aDtcbiAgICAgICAgbGluZS5saW5lRGFzaCA9IGxpbmVTdHlsZXMubGluZURhc2g7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbWFya2VyTGFiZWwudXBkYXRlKHRoaXMuc3ByaXRlUmVuZGVyZXIsIHNwcml0ZURpbXMsIGRpbWVuc2lvblByb3BzKTtcbiAgICByZXR1cm4gcGFkZGVkU3ltYm9sV2lkdGg7XG4gIH1cbiAgdHJ1bmNhdGUodGV4dCwgbWF4Q2hhckxlbmd0aCwgbWF4SXRlbVdpZHRoLCBwYWRkZWRNYXJrZXJXaWR0aCwgZm9udCwgaWQpIHtcbiAgICBsZXQgYWRkRWxsaXBzaXMgPSBmYWxzZTtcbiAgICBpZiAodGV4dC5sZW5ndGggPiBtYXhDaGFyTGVuZ3RoKSB7XG4gICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgbWF4Q2hhckxlbmd0aCk7XG4gICAgICBhZGRFbGxpcHNpcyA9IHRydWU7XG4gICAgfVxuICAgIGNvbnN0IG1lYXN1cmVyID0gQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbC5nZXRNZWFzdXJlcih7IGZvbnQgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gVGV4dFdyYXBwZXIudHJ1bmNhdGVMaW5lKHRleHQsIG1lYXN1cmVyLCBtYXhJdGVtV2lkdGggLSBwYWRkZWRNYXJrZXJXaWR0aCwgYWRkRWxsaXBzaXMpO1xuICAgIGlmIChyZXN1bHQuZW5kc1dpdGgoVGV4dFV0aWxzLkVsbGlwc2lzQ2hhcikpIHtcbiAgICAgIHRoaXMudHJ1bmNhdGVkSXRlbXMuYWRkKGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cnVuY2F0ZWRJdGVtcy5kZWxldGUoaWQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHVwZGF0ZVBhZ2luYXRpb24oYmJveGVzLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3Qgb3JpZW50YXRpb24gPSB0aGlzLmdldE9yaWVudGF0aW9uKCk7XG4gICAgY29uc3QgdHJhY2tpbmdJbmRleCA9IE1hdGgubWluKHRoaXMucGFnaW5hdGlvblRyYWNraW5nSW5kZXgsIGJib3hlcy5sZW5ndGgpO1xuICAgIHRoaXMucGFnaW5hdGlvbi5vcmllbnRhdGlvbiA9IG9yaWVudGF0aW9uO1xuICAgIHRoaXMucGFnaW5hdGlvbi50cmFuc2xhdGlvblggPSAwO1xuICAgIHRoaXMucGFnaW5hdGlvbi50cmFuc2xhdGlvblkgPSAwO1xuICAgIGNvbnN0IHsgcGFnZXMsIG1heFBhZ2VIZWlnaHQsIG1heFBhZ2VXaWR0aCwgcGFnaW5hdGlvbkJCb3gsIHBhZ2luYXRpb25WZXJ0aWNhbCB9ID0gdGhpcy5jYWxjdWxhdGVQYWdpbmF0aW9uKFxuICAgICAgYmJveGVzLFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICApO1xuICAgIGNvbnN0IG5ld0N1cnJlbnRQYWdlID0gcGFnZXMuZmluZEluZGV4KChwKSA9PiBwLmVuZEluZGV4ID49IHRyYWNraW5nSW5kZXgpO1xuICAgIHRoaXMucGFnaW5hdGlvbi5jdXJyZW50UGFnZSA9IGNsYW1wKDAsIG5ld0N1cnJlbnRQYWdlLCBwYWdlcy5sZW5ndGggLSAxKTtcbiAgICBjb25zdCB7IHBhZGRpbmdYOiBpdGVtUGFkZGluZ1gsIHBhZGRpbmdZOiBpdGVtUGFkZGluZ1kgfSA9IHRoaXMuaXRlbTtcbiAgICBjb25zdCBwYWdpbmF0aW9uQ29tcG9uZW50UGFkZGluZyA9IDg7XG4gICAgY29uc3QgbGVnZW5kSXRlbXNXaWR0aCA9IG1heFBhZ2VXaWR0aCAtIGl0ZW1QYWRkaW5nWDtcbiAgICBjb25zdCBsZWdlbmRJdGVtc0hlaWdodCA9IG1heFBhZ2VIZWlnaHQgLSBpdGVtUGFkZGluZ1k7XG4gICAgbGV0IHBhZ2luYXRpb25YID0gMDtcbiAgICBsZXQgcGFnaW5hdGlvblkgPSAtcGFnaW5hdGlvbkJCb3gueSAtIHRoaXMuaXRlbS5tYXJrZXIuc2l6ZSAvIDI7XG4gICAgaWYgKHBhZ2luYXRpb25WZXJ0aWNhbCkge1xuICAgICAgcGFnaW5hdGlvblkgKz0gbGVnZW5kSXRlbXNIZWlnaHQgKyBwYWdpbmF0aW9uQ29tcG9uZW50UGFkZGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgcGFnaW5hdGlvblggKz0gLXBhZ2luYXRpb25CQm94LnggKyBsZWdlbmRJdGVtc1dpZHRoICsgcGFnaW5hdGlvbkNvbXBvbmVudFBhZGRpbmc7XG4gICAgICBwYWdpbmF0aW9uWSArPSAobGVnZW5kSXRlbXNIZWlnaHQgLSBwYWdpbmF0aW9uQkJveC5oZWlnaHQpIC8gMjtcbiAgICB9XG4gICAgdGhpcy5wYWdpbmF0aW9uLnRyYW5zbGF0aW9uWCA9IHBhZ2luYXRpb25YO1xuICAgIHRoaXMucGFnaW5hdGlvbi50cmFuc2xhdGlvblkgPSBwYWdpbmF0aW9uWTtcbiAgICB0aGlzLnBhZ2luYXRpb24udXBkYXRlKCk7XG4gICAgdGhpcy5wYWdpbmF0aW9uLnVwZGF0ZU1hcmtlcnMoKTtcbiAgICBsZXQgcGFnZUluZGV4ID0gMDtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uZWFjaCgobWFya2VyTGFiZWwsIF8sIG5vZGVJbmRleCkgPT4ge1xuICAgICAgaWYgKG5vZGVJbmRleCA+IChwYWdlc1twYWdlSW5kZXhdPy5lbmRJbmRleCA/PyBJbmZpbml0eSkpIHtcbiAgICAgICAgcGFnZUluZGV4Kys7XG4gICAgICB9XG4gICAgICBtYXJrZXJMYWJlbC5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1heFBhZ2VIZWlnaHQsXG4gICAgICBtYXhQYWdlV2lkdGgsXG4gICAgICBwYWdlc1xuICAgIH07XG4gIH1cbiAgdXBkYXRlSXRlbVByb3h5QnV0dG9ucygpIHtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uZWFjaCgobWFya2VyTGFiZWwpID0+IHtcbiAgICAgIGNvbnN0IGJib3ggPSBtYXJrZXJMYWJlbC5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk/LmNsb25lKCk7XG4gICAgICBiYm94LnRyYW5zbGF0ZSh0aGlzLmdyb3VwLnRyYW5zbGF0aW9uWCwgdGhpcy5ncm91cC50cmFuc2xhdGlvblkpO1xuICAgICAgc2V0RWxlbWVudEJCb3gobWFya2VyTGFiZWwucHJveHlCdXR0b24sIGJib3gpO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVBhZ2luYXRpb25Qcm94eUJ1dHRvbnMob2xkUGFnZXMpIHtcbiAgICB0aGlzLnByb3h5TGVnZW5kUGFnaW5hdGlvbi5zdHlsZS5kaXNwbGF5ID0gdGhpcy5wYWdpbmF0aW9uLnZpc2libGUgPyBcImFic29sdXRlXCIgOiBcIm5vbmVcIjtcbiAgICBjb25zdCBvbGROZWVkc0J1dHRvbnMgPSAob2xkUGFnZXM/Lmxlbmd0aCA/PyB0aGlzLnBhZ2VzLmxlbmd0aCkgPiAxO1xuICAgIGNvbnN0IG5ld05lZWRzQnV0dG9ucyA9IHRoaXMucGFnZXMubGVuZ3RoID4gMTtcbiAgICBpZiAob2xkTmVlZHNCdXR0b25zICE9PSBuZXdOZWVkc0J1dHRvbnMpIHtcbiAgICAgIGlmIChuZXdOZWVkc0J1dHRvbnMpIHtcbiAgICAgICAgdGhpcy5wcm94eVByZXZCdXR0b24gPSB0aGlzLmN0eC5wcm94eUludGVyYWN0aW9uU2VydmljZS5jcmVhdGVQcm94eUVsZW1lbnQoe1xuICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgaWQ6IGAke3RoaXMuaWR9LXByZXYtcGFnZWAsXG4gICAgICAgICAgdGV4dENvbnRlbnQ6IHsgaWQ6IFwiYXJpYUxhYmVsTGVnZW5kUGFnZVByZXZpb3VzXCIgfSxcbiAgICAgICAgICB0YWJJbmRleDogMCxcbiAgICAgICAgICBwYXJlbnQ6IHRoaXMucHJveHlMZWdlbmRQYWdpbmF0aW9uLFxuICAgICAgICAgIGZvY3VzYWJsZTogdGhpcy5wYWdpbmF0aW9uLnByZXZpb3VzQnV0dG9uLFxuICAgICAgICAgIG9uY2xpY2s6ICgpID0+IHRoaXMucGFnaW5hdGlvbi5jbGlja1ByZXZpb3VzKClcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJveHlOZXh0QnV0dG9uID8/ICh0aGlzLnByb3h5TmV4dEJ1dHRvbiA9IHRoaXMuY3R4LnByb3h5SW50ZXJhY3Rpb25TZXJ2aWNlLmNyZWF0ZVByb3h5RWxlbWVudCh7XG4gICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICBpZDogYCR7dGhpcy5pZH0tbmV4dC1wYWdlYCxcbiAgICAgICAgICB0ZXh0Q29udGVudDogeyBpZDogXCJhcmlhTGFiZWxMZWdlbmRQYWdlTmV4dFwiIH0sXG4gICAgICAgICAgdGFiSW5kZXg6IDAsXG4gICAgICAgICAgcGFyZW50OiB0aGlzLnByb3h5TGVnZW5kUGFnaW5hdGlvbixcbiAgICAgICAgICBmb2N1c2FibGU6IHRoaXMucGFnaW5hdGlvbi5uZXh0QnV0dG9uLFxuICAgICAgICAgIG9uY2xpY2s6ICgpID0+IHRoaXMucGFnaW5hdGlvbi5jbGlja05leHQoKVxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnByb3h5TmV4dEJ1dHRvbj8ucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMucHJveHlQcmV2QnV0dG9uPy5yZW1vdmUoKTtcbiAgICAgICAgW3RoaXMucHJveHlOZXh0QnV0dG9uLCB0aGlzLnByb3h5UHJldkJ1dHRvbl0gPSBbdm9pZCAwLCB2b2lkIDBdO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IHByZXYsIG5leHQgfSA9IHRoaXMucGFnaW5hdGlvbi5jb21wdXRlQ1NTQm91bmRzKCk7XG4gICAgc2V0RWxlbWVudEJCb3godGhpcy5wcm94eVByZXZCdXR0b24sIHByZXYpO1xuICAgIHNldEVsZW1lbnRCQm94KHRoaXMucHJveHlOZXh0QnV0dG9uLCBuZXh0KTtcbiAgfVxuICBjYWxjdWxhdGVQYWdpbmF0aW9uKGJib3hlcywgd2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHsgcGFkZGluZ1g6IGl0ZW1QYWRkaW5nWCwgcGFkZGluZ1k6IGl0ZW1QYWRkaW5nWSB9ID0gdGhpcy5pdGVtO1xuICAgIGNvbnN0IG9yaWVudGF0aW9uID0gdGhpcy5nZXRPcmllbnRhdGlvbigpO1xuICAgIGNvbnN0IHBhZ2luYXRpb25WZXJ0aWNhbCA9IFtcImxlZnRcIiwgXCJyaWdodFwiXS5pbmNsdWRlcyh0aGlzLnBvc2l0aW9uKTtcbiAgICBsZXQgcGFnaW5hdGlvbkJCb3ggPSB0aGlzLnBhZ2luYXRpb24uZ2V0QkJveCgpO1xuICAgIGxldCBsYXN0UGFzc1BhZ2luYXRpb25CQm94ID0gbmV3IEJCb3goMCwgMCwgMCwgMCk7XG4gICAgbGV0IHBhZ2VzID0gW107XG4gICAgbGV0IG1heFBhZ2VXaWR0aCA9IDA7XG4gICAgbGV0IG1heFBhZ2VIZWlnaHQgPSAwO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgY29uc3Qgc3RhYmxlT3V0cHV0ID0gKGJib3gpID0+IHtcbiAgICAgIHJldHVybiBiYm94LndpZHRoID09PSBwYWdpbmF0aW9uQkJveC53aWR0aCAmJiBiYm94LmhlaWdodCA9PT0gcGFnaW5hdGlvbkJCb3guaGVpZ2h0O1xuICAgIH07XG4gICAgY29uc3QgZm9yY2VSZXN1bHQgPSB0aGlzLm1heFdpZHRoICE9PSB2b2lkIDAgJiYgdGhpcy5tYXhIZWlnaHQgIT09IHZvaWQgMDtcbiAgICBkbyB7XG4gICAgICBpZiAoY291bnQrKyA+IDEwKSB7XG4gICAgICAgIExvZ2dlci53YXJuKFwidW5hYmxlIHRvIGZpbmQgc3RhYmxlIGxlZ2VuZCBsYXlvdXQuXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHBhZ2luYXRpb25CQm94ID0gbGFzdFBhc3NQYWdpbmF0aW9uQkJveDtcbiAgICAgIGNvbnN0IG1heFdpZHRoID0gd2lkdGggLSAocGFnaW5hdGlvblZlcnRpY2FsID8gMCA6IHBhZ2luYXRpb25CQm94LndpZHRoKTtcbiAgICAgIGNvbnN0IG1heEhlaWdodCA9IGhlaWdodCAtIChwYWdpbmF0aW9uVmVydGljYWwgPyBwYWdpbmF0aW9uQkJveC5oZWlnaHQgOiAwKTtcbiAgICAgIGNvbnN0IGxheW91dCA9IGdyaWRMYXlvdXQoe1xuICAgICAgICBvcmllbnRhdGlvbixcbiAgICAgICAgYmJveGVzLFxuICAgICAgICBtYXhIZWlnaHQsXG4gICAgICAgIG1heFdpZHRoLFxuICAgICAgICBpdGVtUGFkZGluZ1ksXG4gICAgICAgIGl0ZW1QYWRkaW5nWCxcbiAgICAgICAgZm9yY2VSZXN1bHRcbiAgICAgIH0pO1xuICAgICAgcGFnZXMgPSBsYXlvdXQ/LnBhZ2VzID8/IFtdO1xuICAgICAgbWF4UGFnZVdpZHRoID0gbGF5b3V0Py5tYXhQYWdlV2lkdGggPz8gMDtcbiAgICAgIG1heFBhZ2VIZWlnaHQgPSBsYXlvdXQ/Lm1heFBhZ2VIZWlnaHQgPz8gMDtcbiAgICAgIGNvbnN0IHRvdGFsUGFnZXMgPSBwYWdlcy5sZW5ndGg7XG4gICAgICB0aGlzLnBhZ2luYXRpb24udmlzaWJsZSA9IHRvdGFsUGFnZXMgPiAxO1xuICAgICAgdGhpcy5wYWdpbmF0aW9uLnRvdGFsUGFnZXMgPSB0b3RhbFBhZ2VzO1xuICAgICAgdGhpcy5wYWdpbmF0aW9uLnVwZGF0ZSgpO1xuICAgICAgbGFzdFBhc3NQYWdpbmF0aW9uQkJveCA9IHRoaXMucGFnaW5hdGlvbi5nZXRCQm94KCk7XG4gICAgICBpZiAoIXRoaXMucGFnaW5hdGlvbi52aXNpYmxlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKCFzdGFibGVPdXRwdXQobGFzdFBhc3NQYWdpbmF0aW9uQkJveCkpO1xuICAgIHJldHVybiB7IG1heFBhZ2VXaWR0aCwgbWF4UGFnZUhlaWdodCwgcGFnZXMsIHBhZ2luYXRpb25CQm94LCBwYWdpbmF0aW9uVmVydGljYWwgfTtcbiAgfVxuICB1cGRhdGVQb3NpdGlvbnMocGFnZU51bWJlciA9IDApIHtcbiAgICBjb25zdCB7XG4gICAgICBpdGVtOiB7IHBhZGRpbmdZIH0sXG4gICAgICBpdGVtU2VsZWN0aW9uLFxuICAgICAgcGFnZXNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAocGFnZXMubGVuZ3RoIDwgMSB8fCAhcGFnZXNbcGFnZU51bWJlcl0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBjb2x1bW5zLCBzdGFydEluZGV4OiB2aXNpYmxlU3RhcnQsIGVuZEluZGV4OiB2aXNpYmxlRW5kIH0gPSBwYWdlc1twYWdlTnVtYmVyXTtcbiAgICBsZXQgeCA9IDA7XG4gICAgbGV0IHkgPSAwO1xuICAgIGNvbnN0IGNvbHVtbkNvdW50ID0gY29sdW1ucy5sZW5ndGg7XG4gICAgY29uc3Qgcm93Q291bnQgPSBjb2x1bW5zWzBdLmluZGljZXMubGVuZ3RoO1xuICAgIGNvbnN0IGhvcml6b250YWwgPSB0aGlzLmdldE9yaWVudGF0aW9uKCkgPT09IFwiaG9yaXpvbnRhbFwiO1xuICAgIGNvbnN0IGl0ZW1IZWlnaHQgPSBjb2x1bW5zWzBdLmJib3hlc1swXS5oZWlnaHQgKyBwYWRkaW5nWTtcbiAgICBjb25zdCByb3dTdW1Db2x1bW5XaWR0aHMgPSBbXTtcbiAgICBpdGVtU2VsZWN0aW9uLmVhY2goKG1hcmtlckxhYmVsLCBfLCBpKSA9PiB7XG4gICAgICBpZiAoaSA8IHZpc2libGVTdGFydCB8fCBpID4gdmlzaWJsZUVuZCkge1xuICAgICAgICBtYXJrZXJMYWJlbC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhZ2VJbmRleCA9IGkgLSB2aXNpYmxlU3RhcnQ7XG4gICAgICBsZXQgY29sdW1uSW5kZXg7XG4gICAgICBsZXQgcm93SW5kZXg7XG4gICAgICBpZiAoaG9yaXpvbnRhbCkge1xuICAgICAgICBjb2x1bW5JbmRleCA9IHBhZ2VJbmRleCAlIGNvbHVtbkNvdW50O1xuICAgICAgICByb3dJbmRleCA9IE1hdGguZmxvb3IocGFnZUluZGV4IC8gY29sdW1uQ291bnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sdW1uSW5kZXggPSBNYXRoLmZsb29yKHBhZ2VJbmRleCAvIHJvd0NvdW50KTtcbiAgICAgICAgcm93SW5kZXggPSBwYWdlSW5kZXggJSByb3dDb3VudDtcbiAgICAgIH1cbiAgICAgIG1hcmtlckxhYmVsLnZpc2libGUgPSB0cnVlO1xuICAgICAgY29uc3QgY29sdW1uID0gY29sdW1uc1tjb2x1bW5JbmRleF07XG4gICAgICBpZiAoIWNvbHVtbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB5ID0gTWF0aC5mbG9vcihpdGVtSGVpZ2h0ICogcm93SW5kZXgpO1xuICAgICAgeCA9IE1hdGguZmxvb3Iocm93U3VtQ29sdW1uV2lkdGhzW3Jvd0luZGV4XSA/PyAwKTtcbiAgICAgIHJvd1N1bUNvbHVtbldpZHRoc1tyb3dJbmRleF0gPSAocm93U3VtQ29sdW1uV2lkdGhzW3Jvd0luZGV4XSA/PyAwKSArIGNvbHVtbi5jb2x1bW5XaWR0aDtcbiAgICAgIG1hcmtlckxhYmVsLnRyYW5zbGF0aW9uWCA9IHg7XG4gICAgICBtYXJrZXJMYWJlbC50cmFuc2xhdGlvblkgPSB5O1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVBhZ2VOdW1iZXIocGFnZU51bWJlcikge1xuICAgIGNvbnN0IHsgcGFnZXMgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBzdGFydEluZGV4LCBlbmRJbmRleCB9ID0gcGFnZXNbcGFnZU51bWJlcl07XG4gICAgaWYgKHN0YXJ0SW5kZXggPT09IDApIHtcbiAgICAgIHRoaXMucGFnaW5hdGlvblRyYWNraW5nSW5kZXggPSAwO1xuICAgIH0gZWxzZSBpZiAocGFnZU51bWJlciA9PT0gcGFnZXMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy5wYWdpbmF0aW9uVHJhY2tpbmdJbmRleCA9IGVuZEluZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBhZ2luYXRpb25UcmFja2luZ0luZGV4ID0gTWF0aC5mbG9vcigoc3RhcnRJbmRleCArIGVuZEluZGV4KSAvIDIpO1xuICAgIH1cbiAgICB0aGlzLnBhZ2luYXRpb24udXBkYXRlKCk7XG4gICAgdGhpcy5wYWdpbmF0aW9uLnVwZGF0ZU1hcmtlcnMoKTtcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9ucyhwYWdlTnVtYmVyKTtcbiAgICB0aGlzLmN0eC51cGRhdGVTZXJ2aWNlLnVwZGF0ZSg2IC8qIFNDRU5FX1JFTkRFUiAqLyk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxhYmVsOiB7IGNvbG9yIH1cbiAgICB9ID0gdGhpcy5pdGVtO1xuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5lYWNoKChtYXJrZXJMYWJlbCwgZGF0dW0pID0+IHtcbiAgICAgIG1hcmtlckxhYmVsLnNldEVuYWJsZWQoZGF0dW0uZW5hYmxlZCk7XG4gICAgICBtYXJrZXJMYWJlbC5jb2xvciA9IGNvbG9yO1xuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlQ29udGV4dE1lbnUoKTtcbiAgfVxuICB1cGRhdGVDb250ZXh0TWVudSgpIHtcbiAgICBjb25zdCB7IHRvZ2dsZVNlcmllcyB9ID0gdGhpcztcbiAgICB0aGlzLmN0eC5jb250ZXh0TWVudVJlZ2lzdHJ5LnNldEFjdGlvblZpc2libGl0eShJRF9MRUdFTkRfVklTSUJJTElUWSwgdG9nZ2xlU2VyaWVzKTtcbiAgICB0aGlzLmN0eC5jb250ZXh0TWVudVJlZ2lzdHJ5LnNldEFjdGlvblZpc2libGl0eShJRF9MRUdFTkRfT1RIRVJfU0VSSUVTLCB0b2dnbGVTZXJpZXMpO1xuICB9XG4gIGdldExpbmVTdHlsZXMoZGF0dW0pIHtcbiAgICBjb25zdCB7IHN0cm9rZSwgc3Ryb2tlT3BhY2l0eSA9IDEsIHN0cm9rZVdpZHRoLCBsaW5lRGFzaCB9ID0gZGF0dW0ubGluZSA/PyB7fTtcbiAgICBjb25zdCBkZWZhdWx0TGluZVN0cm9rZVdpZHRoID0gTWF0aC5taW4oMiwgc3Ryb2tlV2lkdGggPz8gMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0cm9rZSxcbiAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICBzdHJva2VXaWR0aDogdGhpcy5pdGVtLmxpbmUuc3Ryb2tlV2lkdGggPz8gZGVmYXVsdExpbmVTdHJva2VXaWR0aCxcbiAgICAgIGxpbmVEYXNoXG4gICAgfTtcbiAgfVxuICBnZXRNYXJrZXJTdHlsZXMoZGF0dW0pIHtcbiAgICBjb25zdCB7IGZpbGwsIHN0cm9rZSwgc3Ryb2tlT3BhY2l0eSA9IDEsIGZpbGxPcGFjaXR5ID0gMSwgc3Ryb2tlV2lkdGggfSA9IGRhdHVtLm1hcmtlcjtcbiAgICBjb25zdCBkZWZhdWx0TGluZVN0cm9rZVdpZHRoID0gTWF0aC5taW4oMiwgc3Ryb2tlV2lkdGggPz8gMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGwsXG4gICAgICBzdHJva2UsXG4gICAgICBzdHJva2VPcGFjaXR5LFxuICAgICAgZmlsbE9wYWNpdHksXG4gICAgICBzdHJva2VXaWR0aDogdGhpcy5pdGVtLm1hcmtlci5zdHJva2VXaWR0aCA/PyBkZWZhdWx0TGluZVN0cm9rZVdpZHRoXG4gICAgfTtcbiAgfVxuICBnZXREYXR1bUZvclBvaW50KHgsIHkpIHtcbiAgICBjb25zdCB2aXNpYmxlQ2hpbGRCQm94ZXMgPSBbXTtcbiAgICBjb25zdCBjbG9zZXN0TGVmdFRvcCA9IHsgZGlzdDogSW5maW5pdHksIGRhdHVtOiB2b2lkIDAgfTtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuZ3JvdXAuY2hpbGRyZW4pIHtcbiAgICAgIGlmICghY2hpbGQudmlzaWJsZSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoIShjaGlsZCBpbnN0YW5jZW9mIExlZ2VuZE1hcmtlckxhYmVsKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBjaGlsZEJCb3ggPSBjaGlsZC5nZXRCQm94KCkuY2xvbmUoKTtcbiAgICAgIGNoaWxkQkJveC5ncm93KHRoaXMuaXRlbS5wYWRkaW5nWCAvIDIsIFwiaG9yaXpvbnRhbFwiKTtcbiAgICAgIGNoaWxkQkJveC5ncm93KHRoaXMuaXRlbS5wYWRkaW5nWSAvIDIsIFwidmVydGljYWxcIik7XG4gICAgICBpZiAoY2hpbGRCQm94LmNvbnRhaW5zUG9pbnQoeCwgeSkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkLmRhdHVtO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlzdFggPSB4IC0gY2hpbGRCQm94LnggLSB0aGlzLml0ZW0ucGFkZGluZ1ggLyAyO1xuICAgICAgY29uc3QgZGlzdFkgPSB5IC0gY2hpbGRCQm94LnkgLSB0aGlzLml0ZW0ucGFkZGluZ1kgLyAyO1xuICAgICAgY29uc3QgZGlzdCA9IGRpc3RYICoqIDIgKyBkaXN0WSAqKiAyO1xuICAgICAgY29uc3QgdG9UaGVMZWZ0VG9wID0gZGlzdFggPj0gMCAmJiBkaXN0WSA+PSAwO1xuICAgICAgaWYgKHRvVGhlTGVmdFRvcCAmJiBkaXN0IDwgY2xvc2VzdExlZnRUb3AuZGlzdCkge1xuICAgICAgICBjbG9zZXN0TGVmdFRvcC5kaXN0ID0gZGlzdDtcbiAgICAgICAgY2xvc2VzdExlZnRUb3AuZGF0dW0gPSBjaGlsZC5kYXR1bTtcbiAgICAgIH1cbiAgICAgIHZpc2libGVDaGlsZEJCb3hlcy5wdXNoKGNoaWxkQkJveCk7XG4gICAgfVxuICAgIGNvbnN0IHBhZ2VCQm94ID0gQkJveC5tZXJnZSh2aXNpYmxlQ2hpbGRCQm94ZXMpO1xuICAgIGlmICghcGFnZUJCb3guY29udGFpbnNQb2ludCh4LCB5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICByZXR1cm4gY2xvc2VzdExlZnRUb3AuZGF0dW07XG4gIH1cbiAgY29tcHV0ZVBhZ2VkQkJveCgpIHtcbiAgICBsZXQgYWN0dWFsQkJveCA9IHRoaXMuZ3JvdXAuZ2V0QkJveCgpO1xuICAgIGlmICh0aGlzLnBhZ2VzLmxlbmd0aCA8PSAxKSB7XG4gICAgICByZXR1cm4gYWN0dWFsQkJveDtcbiAgICB9XG4gICAgY29uc3QgW21heFBhZ2VXaWR0aCwgbWF4UGFnZUhlaWdodF0gPSB0aGlzLm1heFBhZ2VTaXplO1xuICAgIGFjdHVhbEJCb3ggPSBhY3R1YWxCQm94LmNsb25lKCk7XG4gICAgYWN0dWFsQkJveC5oZWlnaHQgPSBNYXRoLm1heChtYXhQYWdlSGVpZ2h0LCBhY3R1YWxCQm94LmhlaWdodCk7XG4gICAgYWN0dWFsQkJveC53aWR0aCA9IE1hdGgubWF4KG1heFBhZ2VXaWR0aCwgYWN0dWFsQkJveC53aWR0aCk7XG4gICAgcmV0dXJuIGFjdHVhbEJCb3g7XG4gIH1cbiAgY29udGV4dFRvZ2dsZVZpc2liaWxpdHkocGFyYW1zKSB7XG4gICAgY29uc3QgZGF0dW0gPSB0aGlzLmRhdGEuZmluZCgodikgPT4gdi5pdGVtSWQgPT09IHBhcmFtcy5pdGVtSWQpO1xuICAgIHRoaXMuZG9DbGljayhkYXR1bSk7XG4gIH1cbiAgY29udGV4dFRvZ2dsZU90aGVyU2VyaWVzKHBhcmFtcykge1xuICAgIGNvbnN0IGRhdHVtID0gdGhpcy5kYXRhLmZpbmQoKHYpID0+IHYuaXRlbUlkID09PSBwYXJhbXMuaXRlbUlkKTtcbiAgICB0aGlzLmRvRG91YmxlQ2xpY2soZGF0dW0pO1xuICB9XG4gIGNoZWNrQ29udGV4dENsaWNrKGV2ZW50KSB7XG4gICAgY29uc3QgbGVnZW5kSXRlbSA9IHRoaXMuZ2V0RGF0dW1Gb3JQb2ludChldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgICBpZiAodGhpcy5wcmV2ZW50SGlkaW5nQWxsICYmIHRoaXMuY29udGV4dE1lbnVEYXR1bT8uZW5hYmxlZCAmJiB0aGlzLmdldFZpc2libGVJdGVtQ291bnQoKSA8PSAxKSB7XG4gICAgICB0aGlzLmN0eC5jb250ZXh0TWVudVJlZ2lzdHJ5LmRpc2FibGVBY3Rpb24oSURfTEVHRU5EX1ZJU0lCSUxJVFkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC5jb250ZXh0TWVudVJlZ2lzdHJ5LmVuYWJsZUFjdGlvbihJRF9MRUdFTkRfVklTSUJJTElUWSk7XG4gICAgfVxuICAgIHRoaXMuY3R4LmNvbnRleHRNZW51UmVnaXN0cnkuZGlzcGF0Y2hDb250ZXh0KFwibGVnZW5kXCIsIGV2ZW50LCB7IGxlZ2VuZEl0ZW0gfSk7XG4gIH1cbiAgY2hlY2tMZWdlbmRDbGljayhldmVudCkge1xuICAgIGNvbnN0IGRhdHVtID0gdGhpcy5nZXREYXR1bUZvclBvaW50KGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xuICAgIGlmICh0aGlzLmRvQ2xpY2soZGF0dW0pKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBnZXRWaXNpYmxlSXRlbUNvdW50KCkge1xuICAgIHJldHVybiB0aGlzLmN0eC5jaGFydFNlcnZpY2Uuc2VyaWVzLmZsYXRNYXAoKHMpID0+IHMuZ2V0TGVnZW5kRGF0YShcImNhdGVnb3J5XCIpKS5maWx0ZXIoKGQpID0+IGQuZW5hYmxlZCkubGVuZ3RoO1xuICB9XG4gIGRvQ2xpY2soZGF0dW0pIHtcbiAgICBjb25zdCB7XG4gICAgICBsaXN0ZW5lcnM6IHsgbGVnZW5kSXRlbUNsaWNrIH0sXG4gICAgICBjdHg6IHsgY2hhcnRTZXJ2aWNlLCBoaWdobGlnaHRNYW5hZ2VyIH0sXG4gICAgICBwcmV2ZW50SGlkaW5nQWxsLFxuICAgICAgdG9nZ2xlU2VyaWVzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFkYXR1bSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCBpdGVtSWQsIGVuYWJsZWQgfSA9IGRhdHVtO1xuICAgIGNvbnN0IHNlcmllcyA9IGNoYXJ0U2VydmljZS5zZXJpZXMuZmluZCgocykgPT4gcy5pZCA9PT0gaWQpO1xuICAgIGlmICghc2VyaWVzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBuZXdFbmFibGVkID0gZW5hYmxlZDtcbiAgICBpZiAodG9nZ2xlU2VyaWVzKSB7XG4gICAgICBuZXdFbmFibGVkID0gIWVuYWJsZWQ7XG4gICAgICBpZiAocHJldmVudEhpZGluZ0FsbCAmJiAhbmV3RW5hYmxlZCkge1xuICAgICAgICBjb25zdCBudW1WaXNpYmxlSXRlbXMgPSB0aGlzLmdldFZpc2libGVJdGVtQ291bnQoKTtcbiAgICAgICAgaWYgKG51bVZpc2libGVJdGVtcyA8IDIpIHtcbiAgICAgICAgICBuZXdFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHVzID0gbmV3RW5hYmxlZCA/IFwiYXJpYUFubm91bmNlVmlzaWJsZVwiIDogXCJhcmlhQW5ub3VuY2VIaWRkZW5cIjtcbiAgICAgIHRoaXMuY3R4LmFyaWFBbm5vdW5jZW1lbnRTZXJ2aWNlLmFubm91bmNlVmFsdWUoc3RhdHVzKTtcbiAgICAgIHRoaXMuY3R4LmNoYXJ0RXZlbnRNYW5hZ2VyLmxlZ2VuZEl0ZW1DbGljayhzZXJpZXMsIGl0ZW1JZCwgbmV3RW5hYmxlZCwgZGF0dW0ubGVnZW5kSXRlbU5hbWUpO1xuICAgIH1cbiAgICBpZiAobmV3RW5hYmxlZCkge1xuICAgICAgaGlnaGxpZ2h0TWFuYWdlci51cGRhdGVIaWdobGlnaHQodGhpcy5pZCwge1xuICAgICAgICBzZXJpZXMsXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgZGF0dW06IHZvaWQgMFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZ2hsaWdodE1hbmFnZXIudXBkYXRlSGlnaGxpZ2h0KHRoaXMuaWQpO1xuICAgIH1cbiAgICB0aGlzLmN0eC51cGRhdGVTZXJ2aWNlLnVwZGF0ZSgyIC8qIFBST0NFU1NfREFUQSAqLywgeyBmb3JjZU5vZGVEYXRhUmVmcmVzaDogdHJ1ZSB9KTtcbiAgICBsZWdlbmRJdGVtQ2xpY2s/Lih7IHR5cGU6IFwiY2xpY2tcIiwgZW5hYmxlZDogbmV3RW5hYmxlZCwgaXRlbUlkLCBzZXJpZXNJZDogc2VyaWVzLmlkIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNoZWNrTGVnZW5kRG91YmxlQ2xpY2soZXZlbnQpIHtcbiAgICBjb25zdCBkYXR1bSA9IHRoaXMuZ2V0RGF0dW1Gb3JQb2ludChldmVudC5vZmZzZXRYLCBldmVudC5vZmZzZXRZKTtcbiAgICBpZiAodGhpcy5kb0RvdWJsZUNsaWNrKGRhdHVtKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgZG9Eb3VibGVDbGljayhkYXR1bSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxpc3RlbmVyczogeyBsZWdlbmRJdGVtRG91YmxlQ2xpY2sgfSxcbiAgICAgIGN0eDogeyBjaGFydFNlcnZpY2UgfSxcbiAgICAgIHRvZ2dsZVNlcmllc1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChjaGFydFNlcnZpY2UubW9kZSA9PT0gXCJpbnRlZ3JhdGVkXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFkYXR1bSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7IGlkLCBpdGVtSWQsIHNlcmllc0lkIH0gPSBkYXR1bTtcbiAgICBjb25zdCBzZXJpZXMgPSBjaGFydFNlcnZpY2Uuc2VyaWVzLmZpbmQoKHMpID0+IHMuaWQgPT09IGlkKTtcbiAgICBpZiAoIXNlcmllcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodG9nZ2xlU2VyaWVzKSB7XG4gICAgICBjb25zdCBsZWdlbmREYXRhID0gY2hhcnRTZXJ2aWNlLnNlcmllcy5mbGF0TWFwKChzKSA9PiBzLmdldExlZ2VuZERhdGEoXCJjYXRlZ29yeVwiKSk7XG4gICAgICBjb25zdCBudW1WaXNpYmxlSXRlbXMgPSBsZWdlbmREYXRhLmZpbHRlcigoZCkgPT4gZC5lbmFibGVkKS5sZW5ndGg7XG4gICAgICBjb25zdCBjbGlja2VkSXRlbSA9IGxlZ2VuZERhdGEuZmluZCgoZCkgPT4gZC5pdGVtSWQgPT09IGl0ZW1JZCAmJiBkLnNlcmllc0lkID09PSBzZXJpZXNJZCk7XG4gICAgICB0aGlzLmN0eC5jaGFydEV2ZW50TWFuYWdlci5sZWdlbmRJdGVtRG91YmxlQ2xpY2soXG4gICAgICAgIHNlcmllcyxcbiAgICAgICAgaXRlbUlkLFxuICAgICAgICBjbGlja2VkSXRlbT8uZW5hYmxlZCA/PyBmYWxzZSxcbiAgICAgICAgbnVtVmlzaWJsZUl0ZW1zLFxuICAgICAgICBjbGlja2VkSXRlbT8ubGVnZW5kSXRlbU5hbWVcbiAgICAgICk7XG4gICAgfVxuICAgIHRoaXMuY3R4LnVwZGF0ZVNlcnZpY2UudXBkYXRlKDIgLyogUFJPQ0VTU19EQVRBICovLCB7IGZvcmNlTm9kZURhdGFSZWZyZXNoOiB0cnVlIH0pO1xuICAgIGxlZ2VuZEl0ZW1Eb3VibGVDbGljaz8uKHsgdHlwZTogXCJkYmxjbGlja1wiLCBlbmFibGVkOiB0cnVlLCBpdGVtSWQsIHNlcmllc0lkOiBzZXJpZXMuaWQgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaGFuZGxlTGVnZW5kTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IGRhdHVtID0gdGhpcy5nZXREYXR1bUZvclBvaW50KG9mZnNldFgsIG9mZnNldFkpO1xuICAgIHRoaXMuZG9Ib3ZlcihldmVudCwgZGF0dW0pO1xuICB9XG4gIGRvSG92ZXIoZXZlbnQsIGRhdHVtKSB7XG4gICAgY29uc3QgeyB0b2dnbGVTZXJpZXMsIGxpc3RlbmVycyB9ID0gdGhpcztcbiAgICBpZiAoZXZlbnQgPT09IHZvaWQgMCB8fCBkYXR1bSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmN0eC5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcih0aGlzLmlkKTtcbiAgICAgIHRoaXMudXBkYXRlSGlnaGxpZ2h0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNlcmllcyA9IGRhdHVtID8gdGhpcy5jdHguY2hhcnRTZXJ2aWNlLnNlcmllcy5maW5kKChzKSA9PiBzLmlkID09PSBkYXR1bT8uaWQpIDogdm9pZCAwO1xuICAgIGlmIChkYXR1bSAmJiB0aGlzLnRydW5jYXRlZEl0ZW1zLmhhcyhkYXR1bS5pdGVtSWQgPz8gZGF0dW0uaWQpKSB7XG4gICAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50O1xuICAgICAgdGhpcy5jdHgudG9vbHRpcE1hbmFnZXIudXBkYXRlVG9vbHRpcChcbiAgICAgICAgdGhpcy5pZCxcbiAgICAgICAgeyBvZmZzZXRYLCBvZmZzZXRZLCBsYXN0UG9pbnRlckV2ZW50OiBldmVudCwgc2hvd0Fycm93OiBmYWxzZSB9LFxuICAgICAgICB0b1Rvb2x0aXBIdG1sKHsgY29udGVudDogdGhpcy5nZXRJdGVtTGFiZWwoZGF0dW0pIH0pXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC50b29sdGlwTWFuYWdlci5yZW1vdmVUb29sdGlwKHRoaXMuaWQpO1xuICAgIH1cbiAgICBpZiAodG9nZ2xlU2VyaWVzIHx8IGxpc3RlbmVycy5sZWdlbmRJdGVtQ2xpY2sgIT0gbnVsbCB8fCBsaXN0ZW5lcnMubGVnZW5kSXRlbURvdWJsZUNsaWNrICE9IG51bGwpIHtcbiAgICAgIHRoaXMuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKHRoaXMuaWQsIFwicG9pbnRlclwiKTtcbiAgICB9XG4gICAgaWYgKGRhdHVtPy5lbmFibGVkICYmIHNlcmllcykge1xuICAgICAgdGhpcy51cGRhdGVIaWdobGlnaHQoe1xuICAgICAgICBzZXJpZXMsXG4gICAgICAgIGl0ZW1JZDogZGF0dW0/Lml0ZW1JZCxcbiAgICAgICAgZGF0dW06IHZvaWQgMFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBkYXRlSGlnaGxpZ2h0KCk7XG4gICAgfVxuICB9XG4gIGhhbmRsZUxlZ2VuZE1vdXNlRXhpdCgpIHtcbiAgICB0aGlzLmN0eC5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcih0aGlzLmlkKTtcbiAgICB0aGlzLmN0eC50b29sdGlwTWFuYWdlci5yZW1vdmVUb29sdGlwKHRoaXMuaWQpO1xuICAgIHRoaXMudXBkYXRlSGlnaGxpZ2h0KCk7XG4gIH1cbiAgdXBkYXRlSGlnaGxpZ2h0KGRhdHVtKSB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmN0eC5pbnRlcmFjdGlvbk1hbmFnZXIuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUgPT09IDE2IC8qIERlZmF1bHQgKi8pIHtcbiAgICAgIHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXIudXBkYXRlSGlnaGxpZ2h0KHRoaXMuaWQsIGRhdHVtKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlID09PSAxIC8qIEFuaW1hdGlvbiAqLykge1xuICAgICAgdGhpcy5wZW5kaW5nSGlnaGxpZ2h0RGF0dW0gPSBkYXR1bTtcbiAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIub25CYXRjaFN0b3AoKCkgPT4ge1xuICAgICAgICB0aGlzLmN0eC5oaWdobGlnaHRNYW5hZ2VyLnVwZGF0ZUhpZ2hsaWdodCh0aGlzLmlkLCB0aGlzLnBlbmRpbmdIaWdobGlnaHREYXR1bSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlTGVnZW5kTW91c2VFbnRlcihldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVuYWJsZWQsXG4gICAgICB0b2dnbGVTZXJpZXMsXG4gICAgICBsaXN0ZW5lcnM6IHsgbGVnZW5kSXRlbUNsaWNrOiBjbGlja0xpc3RlbmVyLCBsZWdlbmRJdGVtRG91YmxlQ2xpY2s6IGRibGNsaWNrTGlzdGVuZXIgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGRhdHVtID0gdGhpcy5nZXREYXR1bUZvclBvaW50KGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xuICAgIGlmIChlbmFibGVkICYmIGRhdHVtICE9PSB2b2lkIDAgJiYgKHRvZ2dsZVNlcmllcyB8fCBjbGlja0xpc3RlbmVyICE9IG51bGwgfHwgZGJsY2xpY2tMaXN0ZW5lciAhPSBudWxsKSkge1xuICAgICAgdGhpcy5jdHguY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IodGhpcy5pZCwgXCJwb2ludGVyXCIpO1xuICAgIH1cbiAgfVxuICBvbkxvY2FsZUNoYW5nZWQoKSB7XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLmVhY2goKHsgcHJveHlCdXR0b24gfSwgXywgaSkgPT4ge1xuICAgICAgaWYgKHByb3h5QnV0dG9uICE9IG51bGwpIHtcbiAgICAgICAgcHJveHlCdXR0b24udGV4dENvbnRlbnQgPSB0aGlzLmdldEl0ZW1BcmlhVGV4dChpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRJdGVtQXJpYVRleHQobm9kZUluZGV4LCBlbmFibGVkKSB7XG4gICAgY29uc3QgZGF0dW0gPSB0aGlzLmRhdGFbbm9kZUluZGV4XTtcbiAgICBjb25zdCBsYWJlbCA9IGRhdHVtICYmIHRoaXMuZ2V0SXRlbUxhYmVsKGRhdHVtKTtcbiAgICBlbmFibGVkID8/IChlbmFibGVkID0gZGF0dW0uZW5hYmxlZCk7XG4gICAgY29uc3QgbG0gPSB0aGlzLmN0eC5sb2NhbGVNYW5hZ2VyO1xuICAgIGlmIChub2RlSW5kZXggPj0gMCAmJiBsYWJlbCkge1xuICAgICAgY29uc3QgaW5kZXggPSBub2RlSW5kZXggKyAxO1xuICAgICAgY29uc3QgY291bnQgPSB0aGlzLmRhdGEubGVuZ3RoO1xuICAgICAgY29uc3QgcGFydDEgPSBsbS50KFwiYXJpYUxhYmVsTGVnZW5kSXRlbVwiLCB7IGxhYmVsLCBpbmRleCwgY291bnQgfSk7XG4gICAgICBjb25zdCBwYXJ0MiA9IGxtLnQoZW5hYmxlZCA/IFwiYXJpYUFubm91bmNlVmlzaWJsZVwiIDogXCJhcmlhQW5ub3VuY2VIaWRkZW5cIik7XG4gICAgICByZXR1cm4gW3BhcnQxLCBwYXJ0Ml0uam9pbihcIlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGxtLnQoXCJhcmlhTGFiZWxMZWdlbmRJdGVtVW5rbm93blwiKTtcbiAgfVxuICBwb3NpdGlvbkxlZ2VuZChjdHgpIHtcbiAgICBjb25zdCB7IHNocmlua1JlY3QgfSA9IGN0eDtcbiAgICBjb25zdCBuZXdTaHJpbmtSZWN0ID0gc2hyaW5rUmVjdC5jbG9uZSgpO1xuICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICF0aGlzLmRhdGEubGVuZ3RoKSB7XG4gICAgICByZXR1cm4geyAuLi5jdHgsIHNocmlua1JlY3Q6IG5ld1Nocmlua1JlY3QgfTtcbiAgICB9XG4gICAgY29uc3QgW2xlZ2VuZFdpZHRoLCBsZWdlbmRIZWlnaHRdID0gdGhpcy5jYWxjdWxhdGVMZWdlbmREaW1lbnNpb25zKHNocmlua1JlY3QpO1xuICAgIHRoaXMuZ3JvdXAudHJhbnNsYXRpb25YID0gMDtcbiAgICB0aGlzLmdyb3VwLnRyYW5zbGF0aW9uWSA9IDA7XG4gICAgY29uc3QgeyBvbGRQYWdlcyB9ID0gdGhpcy5jYWxjTGF5b3V0KGxlZ2VuZFdpZHRoLCBsZWdlbmRIZWlnaHQpO1xuICAgIGNvbnN0IGxlZ2VuZEJCb3ggPSB0aGlzLmNvbXB1dGVQYWdlZEJCb3goKTtcbiAgICBjb25zdCBjYWxjdWxhdGVUcmFuc2xhdGlvblBlcnBlbmRpY3VsYXJEaW1lbnNpb24gPSAoKSA9PiB7XG4gICAgICBzd2l0Y2ggKHRoaXMucG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgcmV0dXJuIHNocmlua1JlY3QuaGVpZ2h0IC0gbGVnZW5kQkJveC5oZWlnaHQ7XG4gICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBzaHJpbmtSZWN0LndpZHRoIC0gbGVnZW5kQkJveC53aWR0aDtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmICh0aGlzLnZpc2libGUpIHtcbiAgICAgIGNvbnN0IGxlZ2VuZFBhZGRpbmcgPSB0aGlzLnNwYWNpbmc7XG4gICAgICBsZXQgdHJhbnNsYXRpb25YO1xuICAgICAgbGV0IHRyYW5zbGF0aW9uWTtcbiAgICAgIHN3aXRjaCAodGhpcy5wb3NpdGlvbikge1xuICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgICB0cmFuc2xhdGlvblggPSAoc2hyaW5rUmVjdC53aWR0aCAtIGxlZ2VuZEJCb3gud2lkdGgpIC8gMjtcbiAgICAgICAgICB0cmFuc2xhdGlvblkgPSBjYWxjdWxhdGVUcmFuc2xhdGlvblBlcnBlbmRpY3VsYXJEaW1lbnNpb24oKTtcbiAgICAgICAgICBuZXdTaHJpbmtSZWN0LnNocmluayhsZWdlbmRCQm94LmhlaWdodCArIGxlZ2VuZFBhZGRpbmcsIHRoaXMucG9zaXRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0cmFuc2xhdGlvblggPSBjYWxjdWxhdGVUcmFuc2xhdGlvblBlcnBlbmRpY3VsYXJEaW1lbnNpb24oKTtcbiAgICAgICAgICB0cmFuc2xhdGlvblkgPSAoc2hyaW5rUmVjdC5oZWlnaHQgLSBsZWdlbmRCQm94LmhlaWdodCkgLyAyO1xuICAgICAgICAgIG5ld1Nocmlua1JlY3Quc2hyaW5rKGxlZ2VuZEJCb3gud2lkdGggKyBsZWdlbmRQYWRkaW5nLCB0aGlzLnBvc2l0aW9uKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZ3JvdXAudHJhbnNsYXRpb25YID0gTWF0aC5mbG9vcigtbGVnZW5kQkJveC54ICsgc2hyaW5rUmVjdC54ICsgdHJhbnNsYXRpb25YKTtcbiAgICAgIHRoaXMuZ3JvdXAudHJhbnNsYXRpb25ZID0gTWF0aC5mbG9vcigtbGVnZW5kQkJveC55ICsgc2hyaW5rUmVjdC55ICsgdHJhbnNsYXRpb25ZKTtcbiAgICAgIHRoaXMucHJveHlMZWdlbmRUb29sYmFyLnN0eWxlLnJlbW92ZVByb3BlcnR5KFwiZGlzcGxheVwiKTtcbiAgICAgIHRoaXMucHJveHlMZWdlbmRUb29sYmFyLmFyaWFPcmllbnRhdGlvbiA9IHRoaXMuZ2V0T3JpZW50YXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcm94eUxlZ2VuZFRvb2xiYXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZUl0ZW1Qcm94eUJ1dHRvbnMoKTtcbiAgICB0aGlzLnVwZGF0ZVBhZ2luYXRpb25Qcm94eUJ1dHRvbnMob2xkUGFnZXMpO1xuICAgIHJldHVybiB7IC4uLmN0eCwgc2hyaW5rUmVjdDogbmV3U2hyaW5rUmVjdCB9O1xuICB9XG4gIGNhbGN1bGF0ZUxlZ2VuZERpbWVuc2lvbnMoc2hyaW5rUmVjdCkge1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gc2hyaW5rUmVjdDtcbiAgICBjb25zdCBhc3BlY3RSYXRpbyA9IHdpZHRoIC8gaGVpZ2h0O1xuICAgIGNvbnN0IG1heENvZWZmaWNpZW50ID0gMC41O1xuICAgIGNvbnN0IG1pbkhlaWdodENvZWZmaWNpZW50ID0gMC4yO1xuICAgIGNvbnN0IG1pbldpZHRoQ29lZmZpY2llbnQgPSAwLjI1O1xuICAgIGxldCBsZWdlbmRXaWR0aCwgbGVnZW5kSGVpZ2h0O1xuICAgIHN3aXRjaCAodGhpcy5wb3NpdGlvbikge1xuICAgICAgY2FzZSBcInRvcFwiOlxuICAgICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgICBjb25zdCBoZWlnaHRDb2VmZmljaWVudCA9IGFzcGVjdFJhdGlvIDwgMSA/IE1hdGgubWluKG1heENvZWZmaWNpZW50LCBtaW5IZWlnaHRDb2VmZmljaWVudCAqICgxIC8gYXNwZWN0UmF0aW8pKSA6IG1pbkhlaWdodENvZWZmaWNpZW50O1xuICAgICAgICBsZWdlbmRXaWR0aCA9IHRoaXMubWF4V2lkdGggPyBNYXRoLm1pbih0aGlzLm1heFdpZHRoLCB3aWR0aCkgOiB3aWR0aDtcbiAgICAgICAgbGVnZW5kSGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgPyBNYXRoLm1pbih0aGlzLm1heEhlaWdodCwgaGVpZ2h0KSA6IE1hdGgucm91bmQoaGVpZ2h0ICogaGVpZ2h0Q29lZmZpY2llbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnN0IHdpZHRoQ29lZmZpY2llbnQgPSBhc3BlY3RSYXRpbyA+IDEgPyBNYXRoLm1pbihtYXhDb2VmZmljaWVudCwgbWluV2lkdGhDb2VmZmljaWVudCAqIGFzcGVjdFJhdGlvKSA6IG1pbldpZHRoQ29lZmZpY2llbnQ7XG4gICAgICAgIGxlZ2VuZFdpZHRoID0gdGhpcy5tYXhXaWR0aCA/IE1hdGgubWluKHRoaXMubWF4V2lkdGgsIHdpZHRoKSA6IE1hdGgucm91bmQod2lkdGggKiB3aWR0aENvZWZmaWNpZW50KTtcbiAgICAgICAgbGVnZW5kSGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgPyBNYXRoLm1pbih0aGlzLm1heEhlaWdodCwgaGVpZ2h0KSA6IGhlaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIFtsZWdlbmRXaWR0aCwgbGVnZW5kSGVpZ2h0XTtcbiAgfVxufTtcbkxlZ2VuZC5jbGFzc05hbWUgPSBcIkxlZ2VuZFwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwidG9nZ2xlU2VyaWVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJwYWdpbmF0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJpdGVtXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJsaXN0ZW5lcnNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB0YXJnZXQudXBkYXRlR3JvdXBWaXNpYmlsaXR5KCkpLFxuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJT04pXG5dLCBMZWdlbmQucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmQucHJvdG90eXBlLCBcIm1heFdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmQucHJvdG90eXBlLCBcIm1heEhlaWdodFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExlZ2VuZC5wcm90b3R5cGUsIFwicmV2ZXJzZU9yZGVyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVU5JT04oW1wiaG9yaXpvbnRhbFwiLCBcInZlcnRpY2FsXCJdLCBcImFuIG9yaWVudGF0aW9uXCIpLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMZWdlbmQucHJvdG90eXBlLCBcIm9yaWVudGF0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJwcmV2ZW50SGlkaW5nQWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgTGVnZW5kLnByb3RvdHlwZSwgXCJzcGFjaW5nXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9sZWdlbmRNb2R1bGUudHNcbnZhciBDb21tdW5pdHlMZWdlbmRNb2R1bGUgPSB7XG4gIHR5cGU6IFwibGVnZW5kXCIsXG4gIG9wdGlvbnNLZXk6IFwibGVnZW5kXCIsXG4gIGlkZW50aWZpZXI6IFwiY2F0ZWdvcnlcIixcbiAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCIsIFwicG9sYXJcIiwgXCJoaWVyYXJjaHlcIiwgXCJ0b3BvbG9neVwiLCBcImZsb3ctcHJvcG9ydGlvblwiXSxcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IExlZ2VuZChjdHgpLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIlxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbG9jYWxlL2xvY2FsZS50c1xudmFyIExvY2FsZSA9IGNsYXNzIGV4dGVuZHMgQmFzZU1vZHVsZUluc3RhbmNlIHtcbiAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmxvY2FsZVRleHQgPSB2b2lkIDA7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB7XG4gICAgdGFyZ2V0LmN0eC5sb2NhbGVNYW5hZ2VyLnNldExvY2FsZVRleHQodGFyZ2V0LmxvY2FsZVRleHQpO1xuICB9KSxcbiAgVmFsaWRhdGUoUExBSU5fT0JKRUNULCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMb2NhbGUucHJvdG90eXBlLCBcImxvY2FsZVRleHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB7XG4gICAgdGFyZ2V0LmN0eC5sb2NhbGVNYW5hZ2VyLnNldExvY2FsZVRleHRGb3JtYXR0ZXIodGFyZ2V0LmdldExvY2FsZVRleHQpO1xuICB9KSxcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExvY2FsZS5wcm90b3R5cGUsIFwiZ2V0TG9jYWxlVGV4dFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvbG9jYWxlL2xvY2FsZU1vZHVsZS50c1xudmFyIExvY2FsZU1vZHVsZSA9IHtcbiAgdHlwZTogXCJyb290XCIsXG4gIG9wdGlvbnNLZXk6IFwibG9jYWxlXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIiwgXCJwb2xhclwiLCBcImhpZXJhcmNoeVwiLCBcInRvcG9sb2d5XCIsIFwiZmxvdy1wcm9wb3J0aW9uXCJdLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgTG9jYWxlKGN0eClcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L25hdmlnYXRvci9zaGFwZXMvcmFuZ2VIYW5kbGUudHNcbnZhciBSYW5nZUhhbmRsZSA9IGNsYXNzIGV4dGVuZHMgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy56SW5kZXggPSAzO1xuICAgIHRoaXMuY2VudGVyWCA9IDA7XG4gICAgdGhpcy5jZW50ZXJZID0gMDtcbiAgICB0aGlzLndpZHRoID0gODtcbiAgICB0aGlzLmhlaWdodCA9IDE2O1xuICAgIHRoaXMuZ3JpcExpbmVHYXAgPSAyO1xuICAgIHRoaXMuZ3JpcExpbmVMZW5ndGggPSA4O1xuICB9XG4gIHNldENlbnRlcih4LCB5KSB7XG4gICAgdGhpcy5kaXJ0eVBhdGggPSB0cnVlO1xuICAgIHRoaXMuY2VudGVyWCA9IHg7XG4gICAgdGhpcy5jZW50ZXJZID0geTtcbiAgfVxuICBzdGF0aWMgYWxpZ24obWluSGFuZGxlLCBtYXhIYW5kbGUsIHgsIHksIHdpZHRoLCBoZWlnaHQsIG1pbiwgbWF4KSB7XG4gICAgY29uc3QgaGFuZGxlUGl4ZWxBbGlnbiA9IG1pbkhhbmRsZS5zdHJva2VXaWR0aCAvIDI7XG4gICAgY29uc3QgbWluSGFuZGxlWCA9IG1pbkhhbmRsZS5hbGlnbih4ICsgd2lkdGggKiBtaW4pICsgaGFuZGxlUGl4ZWxBbGlnbjtcbiAgICBjb25zdCBtYXhIYW5kbGVYID0gbWluSGFuZGxlWCArIG1pbkhhbmRsZS5hbGlnbih4ICsgd2lkdGggKiBtaW4sIHdpZHRoICogKG1heCAtIG1pbikpIC0gMiAqIGhhbmRsZVBpeGVsQWxpZ247XG4gICAgY29uc3QgaGFuZGxlWSA9IG1pbkhhbmRsZS5hbGlnbih5ICsgaGVpZ2h0IC8gMikgKyBoYW5kbGVQaXhlbEFsaWduO1xuICAgIG1pbkhhbmRsZS5zZXRDZW50ZXIobWluSGFuZGxlWCwgaGFuZGxlWSk7XG4gICAgbWF4SGFuZGxlLnNldENlbnRlcihtYXhIYW5kbGVYLCBoYW5kbGVZKTtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICBjb25zdCB7IGNlbnRlclgsIGNlbnRlclksIHdpZHRoLCBoZWlnaHQgfSA9IHRoaXM7XG4gICAgY29uc3QgeCA9IGNlbnRlclggLSB3aWR0aCAvIDI7XG4gICAgY29uc3QgeSA9IGNlbnRlclkgLSBoZWlnaHQgLyAyO1xuICAgIHJldHVybiBuZXcgQkJveCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICBjb21wdXRlVHJhbnNmb3JtZWRCQm94KCkge1xuICAgIHJldHVybiBzdXBlci5jb21wdXRlVHJhbnNmb3JtZWRCQm94KCk7XG4gIH1cbiAgaXNQb2ludEluUGF0aCh4LCB5KSB7XG4gICAgY29uc3QgcG9pbnQgPSB0aGlzLnRyYW5zZm9ybVBvaW50KHgsIHkpO1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLmdldEJCb3goKTtcbiAgICByZXR1cm4gYmJveC5jb250YWluc1BvaW50KHBvaW50LngsIHBvaW50LnkpO1xuICB9XG4gIHVwZGF0ZVBhdGgoKSB7XG4gICAgY29uc3QgeyBjZW50ZXJYLCBjZW50ZXJZLCBwYXRoLCBzdHJva2VXaWR0aCwgZ3JpcExpbmVHYXAsIGdyaXBMaW5lTGVuZ3RoIH0gPSB0aGlzO1xuICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB0aGlzLmxheWVyTWFuYWdlcj8uY2FudmFzPy5waXhlbFJhdGlvID8/IDE7XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIGNvbnN0IGhhbGZXaWR0aCA9IE1hdGguZmxvb3IodGhpcy53aWR0aCAvIDIgKiBwaXhlbFJhdGlvKSAvIHBpeGVsUmF0aW87XG4gICAgY29uc3QgaGFsZkhlaWdodCA9IE1hdGguZmxvb3IodGhpcy5oZWlnaHQgLyAyICogcGl4ZWxSYXRpbykgLyBwaXhlbFJhdGlvO1xuICAgIHBhdGgubW92ZVRvKGNlbnRlclggLSBoYWxmV2lkdGgsIGNlbnRlclkgLSBoYWxmSGVpZ2h0KTtcbiAgICBwYXRoLmxpbmVUbyhjZW50ZXJYICsgaGFsZldpZHRoLCBjZW50ZXJZIC0gaGFsZkhlaWdodCk7XG4gICAgcGF0aC5saW5lVG8oY2VudGVyWCArIGhhbGZXaWR0aCwgY2VudGVyWSArIGhhbGZIZWlnaHQpO1xuICAgIHBhdGgubGluZVRvKGNlbnRlclggLSBoYWxmV2lkdGgsIGNlbnRlclkgKyBoYWxmSGVpZ2h0KTtcbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgIGNvbnN0IGR4ID0gTWF0aC5mbG9vcigoZ3JpcExpbmVHYXAgKyBzdHJva2VXaWR0aCkgLyAyICogcGl4ZWxSYXRpbykgLyBwaXhlbFJhdGlvO1xuICAgIGNvbnN0IGR5ID0gTWF0aC5mbG9vcihncmlwTGluZUxlbmd0aCAvIDIgKiBwaXhlbFJhdGlvKSAvIHBpeGVsUmF0aW87XG4gICAgcGF0aC5tb3ZlVG8oY2VudGVyWCAtIGR4LCBjZW50ZXJZIC0gZHkpO1xuICAgIHBhdGgubGluZVRvKGNlbnRlclggLSBkeCwgY2VudGVyWSArIGR5KTtcbiAgICBwYXRoLm1vdmVUbyhjZW50ZXJYICsgZHgsIGNlbnRlclkgLSBkeSk7XG4gICAgcGF0aC5saW5lVG8oY2VudGVyWCArIGR4LCBjZW50ZXJZICsgZHkpO1xuICB9XG59O1xuUmFuZ2VIYW5kbGUuY2xhc3NOYW1lID0gXCJSYW5nZUhhbmRsZVwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8sIHR5cGU6IFwicGF0aFwiIH0pXG5dLCBSYW5nZUhhbmRsZS5wcm90b3R5cGUsIFwid2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLywgdHlwZTogXCJwYXRoXCIgfSlcbl0sIFJhbmdlSGFuZGxlLnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLywgdHlwZTogXCJwYXRoXCIgfSlcbl0sIFJhbmdlSGFuZGxlLnByb3RvdHlwZSwgXCJncmlwTGluZUdhcFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovLCB0eXBlOiBcInBhdGhcIiB9KVxuXSwgUmFuZ2VIYW5kbGUucHJvdG90eXBlLCBcImdyaXBMaW5lTGVuZ3RoXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9uYXZpZ2F0b3Ivc2hhcGVzL3JhbmdlTWFzay50c1xudmFyIFJhbmdlTWFzayA9IGNsYXNzIGV4dGVuZHMgUGF0aCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy56SW5kZXggPSAyO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLndpZHRoID0gMjAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gMzA7XG4gICAgdGhpcy5taW4gPSAwO1xuICAgIHRoaXMubWF4ID0gMTtcbiAgfVxuICBsYXlvdXQoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5kaXJ0eVBhdGggPSB0cnVlO1xuICB9XG4gIHVwZGF0ZShtaW4sIG1heCkge1xuICAgIHRoaXMubWluID0gaXNOYU4obWluKSA/IHRoaXMubWluIDogbWluO1xuICAgIHRoaXMubWF4ID0gaXNOYU4obWF4KSA/IHRoaXMubWF4IDogbWF4O1xuICAgIHRoaXMuZGlydHlQYXRoID0gdHJ1ZTtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBCQm94KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIGNvbXB1dGVWaXNpYmxlUmFuZ2VCQm94KCkge1xuICAgIGNvbnN0IHsgeCwgeSwgd2lkdGgsIGhlaWdodCwgbWluLCBtYXggfSA9IHRoaXM7XG4gICAgY29uc3QgbWluWCA9IHggKyB3aWR0aCAqIG1pbjtcbiAgICBjb25zdCBtYXhYID0geCArIHdpZHRoICogbWF4O1xuICAgIHJldHVybiBuZXcgQkJveChtaW5YLCB5LCBtYXhYIC0gbWluWCwgaGVpZ2h0KTtcbiAgfVxuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHsgcGF0aCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgbWluLCBtYXgsIHN0cm9rZVdpZHRoIH0gPSB0aGlzO1xuICAgIGNvbnN0IHBpeGVsQWxpZ24gPSBzdHJva2VXaWR0aCAvIDI7XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIGNvbnN0IGF4ID0gdGhpcy5hbGlnbih4KSArIHBpeGVsQWxpZ247XG4gICAgY29uc3QgYXkgPSB0aGlzLmFsaWduKHkpICsgcGl4ZWxBbGlnbjtcbiAgICBjb25zdCBheHcgPSBheCArIHRoaXMuYWxpZ24oeCwgd2lkdGgpIC0gMiAqIHBpeGVsQWxpZ247XG4gICAgY29uc3QgYXloID0gYXkgKyB0aGlzLmFsaWduKHksIGhlaWdodCkgLSAyICogcGl4ZWxBbGlnbjtcbiAgICBwYXRoLm1vdmVUbyhheCwgYXkpO1xuICAgIHBhdGgubGluZVRvKGF4dywgYXkpO1xuICAgIHBhdGgubGluZVRvKGF4dywgYXloKTtcbiAgICBwYXRoLmxpbmVUbyhheCwgYXloKTtcbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgIGNvbnN0IG1pblggPSB0aGlzLmFsaWduKHggKyB3aWR0aCAqIG1pbikgKyBwaXhlbEFsaWduO1xuICAgIGNvbnN0IG1heFggPSBtaW5YICsgdGhpcy5hbGlnbih4ICsgd2lkdGggKiBtaW4sIHdpZHRoICogKG1heCAtIG1pbikpIC0gMiAqIHBpeGVsQWxpZ247XG4gICAgcGF0aC5tb3ZlVG8obWluWCwgYXkpO1xuICAgIHBhdGgubGluZVRvKG1pblgsIGF5aCk7XG4gICAgcGF0aC5saW5lVG8obWF4WCwgYXloKTtcbiAgICBwYXRoLmxpbmVUbyhtYXhYLCBheSk7XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxufTtcblJhbmdlTWFzay5jbGFzc05hbWUgPSBcIlJhbmdlTWFza1wiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9uYXZpZ2F0b3Ivc2hhcGVzL3JhbmdlU2VsZWN0b3IudHNcbnZhciBSYW5nZVNlbGVjdG9yID0gY2xhc3MgZXh0ZW5kcyBHcm91cCB7XG4gIGNvbnN0cnVjdG9yKGNoaWxkcmVuKSB7XG4gICAgc3VwZXIoeyBuYW1lOiBcInJhbmdlU2VsZWN0b3JHcm91cFwiLCBsYXllcjogdHJ1ZSwgekluZGV4OiAxNCAvKiBOQVZJR0FUT1JfWklOREVYICovIH0pO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLndpZHRoID0gMjAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gMzA7XG4gICAgdGhpcy5sT2Zmc2V0ID0gMDtcbiAgICB0aGlzLnJPZmZzZXQgPSAwO1xuICAgIHRoaXMuaXNDb250YWluZXJOb2RlID0gdHJ1ZTtcbiAgICB0aGlzLmJhY2tncm91bmQgPSBuZXcgR3JvdXAoeyBuYW1lOiBcIm5hdmlnYXRvci1iYWNrZ3JvdW5kXCIgfSk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kLnpJbmRleCA9IDE7XG4gICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLmJhY2tncm91bmQpO1xuICAgIHRoaXMuYXBwZW5kKGNoaWxkcmVuKTtcbiAgfVxuICBsYXlvdXQoeCwgeSwgd2lkdGgsIGhlaWdodCwgbE9mZnNldCwgck9mZnNldCkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5sT2Zmc2V0ID0gbE9mZnNldDtcbiAgICB0aGlzLnJPZmZzZXQgPSByT2Zmc2V0O1xuICAgIHRoaXMuYmFja2dyb3VuZC50cmFuc2xhdGlvblggPSB4O1xuICAgIHRoaXMuYmFja2dyb3VuZC50cmFuc2xhdGlvblkgPSB5O1xuICB9XG4gIHVwZGF0ZUJhY2tncm91bmQob2xkR3JvdXAsIG5ld0dyb3VwKSB7XG4gICAgaWYgKG9sZEdyb3VwICE9IG51bGwpIHtcbiAgICAgIHRoaXMuYmFja2dyb3VuZC5yZW1vdmVDaGlsZChvbGRHcm91cCk7XG4gICAgfVxuICAgIGlmIChuZXdHcm91cCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmJhY2tncm91bmQuYXBwZW5kQ2hpbGQobmV3R3JvdXApO1xuICAgIH1cbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQsIGxPZmZzZXQsIHJPZmZzZXQgfSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBCQm94KHggLSBsT2Zmc2V0LCB5LCB3aWR0aCArIChsT2Zmc2V0ICsgck9mZnNldCksIGhlaWdodCk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L25hdmlnYXRvci9uYXZpZ2F0b3IudHNcbnZhciBOYXZpZ2F0b3IgPSBjbGFzcyBleHRlbmRzIEJhc2VNb2R1bGVJbnN0YW5jZSB7XG4gIGNvbnN0cnVjdG9yKGN0eCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5taW5pQ2hhcnQgPSB2b2lkIDA7XG4gICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5tYXNrID0gbmV3IFJhbmdlTWFzaygpO1xuICAgIHRoaXMubWluSGFuZGxlID0gbmV3IFJhbmdlSGFuZGxlKCk7XG4gICAgdGhpcy5tYXhIYW5kbGUgPSBuZXcgUmFuZ2VIYW5kbGUoKTtcbiAgICB0aGlzLm1hc2tWaXNpYmxlUmFuZ2UgPSB7XG4gICAgICBpZDogXCJuYXZpZ2F0b3ItbWFzay12aXNpYmxlLXJhbmdlXCIsXG4gICAgICBnZXRCQm94OiAoKSA9PiB0aGlzLm1hc2suY29tcHV0ZVZpc2libGVSYW5nZUJCb3goKSxcbiAgICAgIGNvbXB1dGVUcmFuc2Zvcm1lZEJCb3g6ICgpID0+IHRoaXMubWFzay5jb21wdXRlVmlzaWJsZVJhbmdlQkJveCgpXG4gICAgfTtcbiAgICB0aGlzLmhlaWdodCA9IDMwO1xuICAgIHRoaXMuc3BhY2luZyA9IDEwO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLndpZHRoID0gMDtcbiAgICB0aGlzLnJhbmdlU2VsZWN0b3IgPSBuZXcgUmFuZ2VTZWxlY3RvcihbdGhpcy5tYXNrLCB0aGlzLm1pbkhhbmRsZSwgdGhpcy5tYXhIYW5kbGVdKTtcbiAgICB0aGlzLl9taW4gPSAwO1xuICAgIHRoaXMuX21heCA9IDE7XG4gICAgdGhpcy5taW5SYW5nZSA9IDFlLTM7XG4gICAgY29uc3QgcmVnaW9uID0gY3R4LnJlZ2lvbk1hbmFnZXIuYWRkUmVnaW9uKFwibmF2aWdhdG9yXCIsIHRoaXMucmFuZ2VTZWxlY3Rvcik7XG4gICAgY29uc3QgZHJhZ1N0YXRlcyA9IDE2IC8qIERlZmF1bHQgKi8gfCAxIC8qIEFuaW1hdGlvbiAqLyB8IDggLyogWm9vbURyYWcgKi87XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICBjdHguc2NlbmUuYXR0YWNoTm9kZSh0aGlzLnJhbmdlU2VsZWN0b3IpLFxuICAgICAgcmVnaW9uLmFkZExpc3RlbmVyKFwiaG92ZXJcIiwgKGV2ZW50KSA9PiB0aGlzLm9uSG92ZXIoZXZlbnQpLCBkcmFnU3RhdGVzKSxcbiAgICAgIHJlZ2lvbi5hZGRMaXN0ZW5lcihcImRyYWctc3RhcnRcIiwgKGV2ZW50KSA9PiB0aGlzLm9uRHJhZ1N0YXJ0KGV2ZW50KSwgZHJhZ1N0YXRlcyksXG4gICAgICByZWdpb24uYWRkTGlzdGVuZXIoXCJkcmFnXCIsIChldmVudCkgPT4gdGhpcy5vbkRyYWcoZXZlbnQpLCBkcmFnU3RhdGVzKSxcbiAgICAgIHJlZ2lvbi5hZGRMaXN0ZW5lcihcImRyYWctZW5kXCIsICgpID0+IHRoaXMub25EcmFnRW5kKCksIGRyYWdTdGF0ZXMpLFxuICAgICAgcmVnaW9uLmFkZExpc3RlbmVyKFwibGVhdmVcIiwgKGV2ZW50KSA9PiB0aGlzLm9uTGVhdmUoZXZlbnQpLCBkcmFnU3RhdGVzKSxcbiAgICAgIHRoaXMuY3R4LmxvY2FsZU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJsb2NhbGUtY2hhbmdlZFwiLCAoKSA9PiB0aGlzLnVwZGF0ZVpvb20oKSksXG4gICAgICBjdHguem9vbU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJ6b29tLWNoYW5nZVwiLCAoZXZlbnQpID0+IHRoaXMub25ab29tQ2hhbmdlKGV2ZW50KSlcbiAgICApO1xuICAgIHRoaXMucHJveHlOYXZpZ2F0b3JUb29sYmFyID0gdGhpcy5jdHgucHJveHlJbnRlcmFjdGlvblNlcnZpY2UuY3JlYXRlUHJveHlDb250YWluZXIoe1xuICAgICAgdHlwZTogXCJ0b29sYmFyXCIsXG4gICAgICBpZDogYG5hdmlnYXRvci10b29sYmFyYCxcbiAgICAgIGNsYXNzTGlzdDogW1wiYWctY2hhcnRzLXByb3h5LW5hdmlnYXRvci10b29sYmFyXCJdLFxuICAgICAgYXJpYU9yaWVudGF0aW9uOiBcInZlcnRpY2FsXCIsXG4gICAgICBhcmlhTGFiZWw6IHsgaWQ6IFwiYXJpYUxhYmVsTmF2aWdhdG9yXCIgfVxuICAgIH0pO1xuICAgIHRoaXMudXBkYXRlR3JvdXBWaXNpYmlsaXR5KCk7XG4gICAgdGhpcy5wcm94eU5hdmlnYXRvckVsZW1lbnRzID0gW1xuICAgICAgdGhpcy5jdHgucHJveHlJbnRlcmFjdGlvblNlcnZpY2UuY3JlYXRlUHJveHlFbGVtZW50KHtcbiAgICAgICAgdHlwZTogXCJzbGlkZXJcIixcbiAgICAgICAgaWQ6IFwiYWctY2hhcnRzLW5hdmlnYXRvci1taW5cIixcbiAgICAgICAgYXJpYUxhYmVsOiB7IGlkOiBcImFyaWFMYWJlbE5hdmlnYXRvck1pbmltdW1cIiB9LFxuICAgICAgICBhcmlhT3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgICBwYXJlbnQ6IHRoaXMucHJveHlOYXZpZ2F0b3JUb29sYmFyLFxuICAgICAgICBmb2N1c2FibGU6IHRoaXMubWluSGFuZGxlLFxuICAgICAgICBvbmNoYW5nZTogKGV2KSA9PiB0aGlzLm9uTWluU2xpZGVyQ2hhbmdlKGV2KVxuICAgICAgfSksXG4gICAgICB0aGlzLmN0eC5wcm94eUludGVyYWN0aW9uU2VydmljZS5jcmVhdGVQcm94eUVsZW1lbnQoe1xuICAgICAgICB0eXBlOiBcInNsaWRlclwiLFxuICAgICAgICBpZDogXCJhZy1jaGFydHMtbmF2aWdhdG9yLXBhblwiLFxuICAgICAgICBhcmlhTGFiZWw6IHsgaWQ6IFwiYXJpYUxhYmVsTmF2aWdhdG9yUmFuZ2VcIiB9LFxuICAgICAgICBhcmlhT3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgICBwYXJlbnQ6IHRoaXMucHJveHlOYXZpZ2F0b3JUb29sYmFyLFxuICAgICAgICBmb2N1c2FibGU6IHRoaXMubWFza1Zpc2libGVSYW5nZSxcbiAgICAgICAgb25jaGFuZ2U6IChldikgPT4gdGhpcy5vblBhblNsaWRlckNoYW5nZShldilcbiAgICAgIH0pLFxuICAgICAgdGhpcy5jdHgucHJveHlJbnRlcmFjdGlvblNlcnZpY2UuY3JlYXRlUHJveHlFbGVtZW50KHtcbiAgICAgICAgdHlwZTogXCJzbGlkZXJcIixcbiAgICAgICAgaWQ6IFwiYWctY2hhcnRzLW5hdmlnYXRvci1tYXhcIixcbiAgICAgICAgYXJpYUxhYmVsOiB7IGlkOiBcImFyaWFMYWJlbE5hdmlnYXRvck1heGltdW1cIiB9LFxuICAgICAgICBhcmlhT3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgICBwYXJlbnQ6IHRoaXMucHJveHlOYXZpZ2F0b3JUb29sYmFyLFxuICAgICAgICBmb2N1c2FibGU6IHRoaXMubWF4SGFuZGxlLFxuICAgICAgICBvbmNoYW5nZTogKGV2KSA9PiB0aGlzLm9uTWF4U2xpZGVyQ2hhbmdlKGV2KVxuICAgICAgfSlcbiAgICBdO1xuICAgIGluaXRUb29sYmFyS2V5TmF2KHtcbiAgICAgIG9yaWVudGF0aW9uOiBcInZlcnRpY2FsXCIsXG4gICAgICB0b29sYmFyOiB0aGlzLnByb3h5TmF2aWdhdG9yVG9vbGJhcixcbiAgICAgIGJ1dHRvbnM6IHRoaXMucHJveHlOYXZpZ2F0b3JFbGVtZW50c1xuICAgIH0pO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKCgpID0+IHtcbiAgICAgIHRoaXMucHJveHlOYXZpZ2F0b3JFbGVtZW50cy5mb3JFYWNoKChlKSA9PiBlLnJlbW92ZSgpKTtcbiAgICAgIHRoaXMucHJveHlOYXZpZ2F0b3JUb29sYmFyLnJlbW92ZSgpO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUJhY2tncm91bmQob2xkR3JvdXAsIG5ld0dyb3VwKSB7XG4gICAgdGhpcy5yYW5nZVNlbGVjdG9yPy51cGRhdGVCYWNrZ3JvdW5kKG9sZEdyb3VwLCBuZXdHcm91cCk7XG4gIH1cbiAgdXBkYXRlR3JvdXBWaXNpYmlsaXR5KCkge1xuICAgIGNvbnN0IHsgZW5hYmxlZCB9ID0gdGhpcztcbiAgICBpZiAodGhpcy5yYW5nZVNlbGVjdG9yID09IG51bGwgfHwgZW5hYmxlZCA9PT0gdGhpcy5yYW5nZVNlbGVjdG9yLnZpc2libGUpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5yYW5nZVNlbGVjdG9yLnZpc2libGUgPSBlbmFibGVkO1xuICAgIHRoaXMucHJveHlOYXZpZ2F0b3JUb29sYmFyLmFyaWFIaWRkZW4gPSAoIWVuYWJsZWQpLnRvU3RyaW5nKCk7XG4gICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlWm9vbSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmN0eC56b29tTWFuYWdlci51cGRhdGVab29tKFwibmF2aWdhdG9yXCIpO1xuICAgIH1cbiAgfVxuICBhc3luYyBwZXJmb3JtTGF5b3V0KGN0eCkge1xuICAgIGNvbnN0IHsgc2hyaW5rUmVjdCB9ID0gY3R4O1xuICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IG5hdmlnYXRvclRvdGFsSGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyB0aGlzLnNwYWNpbmc7XG4gICAgICBzaHJpbmtSZWN0LnNocmluayhuYXZpZ2F0b3JUb3RhbEhlaWdodCwgXCJib3R0b21cIik7XG4gICAgICB0aGlzLnkgPSBzaHJpbmtSZWN0LnkgKyBzaHJpbmtSZWN0LmhlaWdodCArIHRoaXMuc3BhY2luZztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy55ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHsgLi4uY3R4LCBzaHJpbmtSZWN0IH07XG4gIH1cbiAgYXN5bmMgcGVyZm9ybUNhcnRlc2lhbkxheW91dChvcHRzKSB7XG4gICAgY29uc3QgeyB4LCB3aWR0aCB9ID0gb3B0cy5zZXJpZXNSZWN0O1xuICAgIGlmICh0aGlzLmVuYWJsZWQpIHtcbiAgICAgIGNvbnN0IHsgeSwgaGVpZ2h0IH0gPSB0aGlzO1xuICAgICAgdGhpcy5sYXlvdXROb2Rlcyh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHNldEVsZW1lbnRCQm94KHRoaXMucHJveHlOYXZpZ2F0b3JUb29sYmFyLCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSk7XG4gICAgICB0aGlzLnByb3h5TmF2aWdhdG9yVG9vbGJhci5zdHlsZS5yZW1vdmVQcm9wZXJ0eShcImRpc3BsYXlcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJveHlOYXZpZ2F0b3JUb29sYmFyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gIH1cbiAgb25Ib3ZlcihldmVudCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgbWFzaywgbWluSGFuZGxlLCBtYXhIYW5kbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBvZmZzZXRYLCBvZmZzZXRZIH0gPSBldmVudDtcbiAgICBpZiAobWluSGFuZGxlLmNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSkgfHwgbWF4SGFuZGxlLmNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSkpIHtcbiAgICAgIHRoaXMuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKFwibmF2aWdhdG9yXCIsIFwiZXctcmVzaXplXCIpO1xuICAgIH0gZWxzZSBpZiAobWFzay5jb21wdXRlVmlzaWJsZVJhbmdlQkJveCgpLmNvbnRhaW5zUG9pbnQob2Zmc2V0WCwgb2Zmc2V0WSkpIHtcbiAgICAgIHRoaXMuY3R4LmN1cnNvck1hbmFnZXIudXBkYXRlQ3Vyc29yKFwibmF2aWdhdG9yXCIsIFwiZ3JhYlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguY3Vyc29yTWFuYWdlci51cGRhdGVDdXJzb3IoXCJuYXZpZ2F0b3JcIik7XG4gICAgfVxuICB9XG4gIG9uRHJhZ1N0YXJ0KGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBtYXNrLCBtaW5IYW5kbGUsIG1heEhhbmRsZSwgeCwgd2lkdGgsIF9taW46IG1pbiB9ID0gdGhpcztcbiAgICBjb25zdCB7IG9mZnNldFgsIG9mZnNldFkgfSA9IGV2ZW50O1xuICAgIGlmIChtaW5IYW5kbGUuekluZGV4IDwgbWF4SGFuZGxlLnpJbmRleCkge1xuICAgICAgaWYgKG1heEhhbmRsZS5jb250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpKSB7XG4gICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBcIm1heFwiO1xuICAgICAgfSBlbHNlIGlmIChtaW5IYW5kbGUuY29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSkge1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gXCJtaW5cIjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1pbkhhbmRsZS5jb250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpKSB7XG4gICAgICB0aGlzLmRyYWdnaW5nID0gXCJtaW5cIjtcbiAgICB9IGVsc2UgaWYgKG1heEhhbmRsZS5jb250YWluc1BvaW50KG9mZnNldFgsIG9mZnNldFkpKSB7XG4gICAgICB0aGlzLmRyYWdnaW5nID0gXCJtYXhcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMuZHJhZ2dpbmcgPT0gbnVsbCAmJiBtYXNrLmNvbXB1dGVWaXNpYmxlUmFuZ2VCQm94KCkuY29udGFpbnNQb2ludChvZmZzZXRYLCBvZmZzZXRZKSkge1xuICAgICAgdGhpcy5kcmFnZ2luZyA9IFwicGFuXCI7XG4gICAgICB0aGlzLnBhblN0YXJ0ID0gKG9mZnNldFggLSB4KSAvIHdpZHRoIC0gbWluO1xuICAgIH1cbiAgICBpZiAodGhpcy5kcmFnZ2luZyAhPSBudWxsKSB7XG4gICAgICB0aGlzLmN0eC56b29tTWFuYWdlci5maXJlWm9vbVBhblN0YXJ0RXZlbnQoXCJuYXZpZ2F0b3JcIik7XG4gICAgfVxuICB9XG4gIG9uRHJhZyhldmVudCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkIHx8IHRoaXMuZHJhZ2dpbmcgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGRyYWdnaW5nLCBtaW5SYW5nZSwgcGFuU3RhcnQsIHgsIHdpZHRoIH0gPSB0aGlzO1xuICAgIGxldCB7IF9taW46IG1pbiwgX21heDogbWF4IH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgb2Zmc2V0WCB9ID0gZXZlbnQ7XG4gICAgY29uc3QgcmF0aW8yID0gKG9mZnNldFggLSB4KSAvIHdpZHRoO1xuICAgIGlmIChkcmFnZ2luZyA9PT0gXCJtaW5cIikge1xuICAgICAgbWluID0gY2xhbXAoMCwgcmF0aW8yLCBtYXggLSBtaW5SYW5nZSk7XG4gICAgfSBlbHNlIGlmIChkcmFnZ2luZyA9PT0gXCJtYXhcIikge1xuICAgICAgbWF4ID0gY2xhbXAobWluICsgbWluUmFuZ2UsIHJhdGlvMiwgMSk7XG4gICAgfSBlbHNlIGlmIChkcmFnZ2luZyA9PT0gXCJwYW5cIiAmJiBwYW5TdGFydCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBzcGFuID0gbWF4IC0gbWluO1xuICAgICAgbWluID0gY2xhbXAoMCwgcmF0aW8yIC0gcGFuU3RhcnQsIDEgLSBzcGFuKTtcbiAgICAgIG1heCA9IG1pbiArIHNwYW47XG4gICAgfVxuICAgIHRoaXMuX21pbiA9IG1pbjtcbiAgICB0aGlzLl9tYXggPSBtYXg7XG4gICAgdGhpcy51cGRhdGVab29tKCk7XG4gIH1cbiAgb25EcmFnRW5kKCkge1xuICAgIHRoaXMuZHJhZ2dpbmcgPSB2b2lkIDA7XG4gIH1cbiAgb25MZWF2ZShfZXZlbnQpIHtcbiAgICB0aGlzLmN0eC5jdXJzb3JNYW5hZ2VyLnVwZGF0ZUN1cnNvcihcIm5hdmlnYXRvclwiKTtcbiAgfVxuICBvblpvb21DaGFuZ2UoZXZlbnQpIHtcbiAgICBjb25zdCB7IHggfSA9IGV2ZW50O1xuICAgIGlmICgheClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLl9taW4gPSB4Lm1pbjtcbiAgICB0aGlzLl9tYXggPSB4Lm1heDtcbiAgICB0aGlzLnVwZGF0ZU5vZGVzKHgubWluLCB4Lm1heCk7XG4gICAgdGhpcy5zZXRQYW5TbGlkZXJWYWx1ZSh4Lm1pbiwgeC5tYXgpO1xuICAgIHRoaXMuc2V0U2xpZGVyUmF0aW8odGhpcy5wcm94eU5hdmlnYXRvckVsZW1lbnRzWzBdLCB4Lm1pbik7XG4gICAgdGhpcy5zZXRTbGlkZXJSYXRpbyh0aGlzLnByb3h5TmF2aWdhdG9yRWxlbWVudHNbMl0sIHgubWF4KTtcbiAgfVxuICBvblBhblNsaWRlckNoYW5nZShfZXZlbnQpIHtcbiAgICBjb25zdCByYXRpbzIgPSB0aGlzLmdldFNsaWRlclJhdGlvKHRoaXMucHJveHlOYXZpZ2F0b3JFbGVtZW50c1sxXSk7XG4gICAgY29uc3Qgc3BhbiA9IHRoaXMuX21heCAtIHRoaXMuX21pbjtcbiAgICB0aGlzLl9taW4gPSBjbGFtcCgwLCByYXRpbzIsIDEgLSBzcGFuKTtcbiAgICB0aGlzLl9tYXggPSB0aGlzLl9taW4gKyBzcGFuO1xuICAgIHRoaXMudXBkYXRlWm9vbSgpO1xuICB9XG4gIG9uTWluU2xpZGVyQ2hhbmdlKF9ldmVudCkge1xuICAgIGNvbnN0IHNsaWRlciA9IHRoaXMucHJveHlOYXZpZ2F0b3JFbGVtZW50c1swXTtcbiAgICB0aGlzLl9taW4gPSB0aGlzLnNldFNsaWRlclJhdGlvQ2xhbXBlZChzbGlkZXIsIDAsIHRoaXMuX21heCAtIHRoaXMubWluUmFuZ2UpO1xuICAgIHRoaXMudXBkYXRlWm9vbSgpO1xuICB9XG4gIG9uTWF4U2xpZGVyQ2hhbmdlKF9ldmVudCkge1xuICAgIGNvbnN0IHNsaWRlciA9IHRoaXMucHJveHlOYXZpZ2F0b3JFbGVtZW50c1syXTtcbiAgICB0aGlzLl9tYXggPSB0aGlzLnNldFNsaWRlclJhdGlvQ2xhbXBlZChzbGlkZXIsIHRoaXMuX21pbiArIHRoaXMubWluUmFuZ2UsIDEpO1xuICAgIHRoaXMudXBkYXRlWm9vbSgpO1xuICB9XG4gIHNldFBhblNsaWRlclZhbHVlKG1pbiwgbWF4KSB7XG4gICAgdGhpcy5wcm94eU5hdmlnYXRvckVsZW1lbnRzWzFdLnZhbHVlID0gYCR7TWF0aC5yb3VuZChtaW4gKiAxMDApfWA7XG4gICAgdGhpcy5wcm94eU5hdmlnYXRvckVsZW1lbnRzWzFdLmFyaWFWYWx1ZVRleHQgPSB0aGlzLmN0eC5sb2NhbGVNYW5hZ2VyLnQoXCJhcmlhVmFsdWVQYW5SYW5nZVwiLCB7IG1pbiwgbWF4IH0pO1xuICB9XG4gIHNldFNsaWRlclJhdGlvQ2xhbXBlZChzbGlkZXIsIGNsYW1wTWluLCBjbGFtcE1heCkge1xuICAgIGNvbnN0IHJhdGlvMiA9IHRoaXMuZ2V0U2xpZGVyUmF0aW8oc2xpZGVyKTtcbiAgICBjb25zdCBjbGFtcGVkUmF0aW8gPSBjbGFtcChjbGFtcE1pbiwgcmF0aW8yLCBjbGFtcE1heCk7XG4gICAgaWYgKGNsYW1wZWRSYXRpbyAhPT0gcmF0aW8yKSB7XG4gICAgICB0aGlzLnNldFNsaWRlclJhdGlvKHNsaWRlciwgY2xhbXBlZFJhdGlvKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYW1wZWRSYXRpbztcbiAgfVxuICBzZXRTbGlkZXJSYXRpbyhzbGlkZXIsIHJhdGlvMikge1xuICAgIGNvbnN0IHZhbHVlID0gTWF0aC5yb3VuZChyYXRpbzIgKiAxMDApO1xuICAgIHNsaWRlci52YWx1ZSA9IGAke3ZhbHVlfWA7XG4gICAgc2xpZGVyLmFyaWFWYWx1ZVRleHQgPSBmb3JtYXRQZXJjZW50YWdlKHZhbHVlKTtcbiAgfVxuICBnZXRTbGlkZXJSYXRpbyhzbGlkZXIpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChzbGlkZXIudmFsdWUpIC8gMTAwO1xuICB9XG4gIGxheW91dE5vZGVzKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB7IHJhbmdlU2VsZWN0b3IsIG1hc2ssIG1pbkhhbmRsZSwgbWF4SGFuZGxlLCBfbWluOiBtaW4sIF9tYXg6IG1heCB9ID0gdGhpcztcbiAgICByYW5nZVNlbGVjdG9yLmxheW91dCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBtaW5IYW5kbGUud2lkdGggLyAyLCBtYXhIYW5kbGUud2lkdGggLyAyKTtcbiAgICBtYXNrLmxheW91dCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBSYW5nZUhhbmRsZS5hbGlnbihtaW5IYW5kbGUsIG1heEhhbmRsZSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgbWluLCBtYXgpO1xuICAgIGlmIChtaW4gKyAobWF4IC0gbWluKSAvIDIgPCAwLjUpIHtcbiAgICAgIG1pbkhhbmRsZS56SW5kZXggPSAzO1xuICAgICAgbWF4SGFuZGxlLnpJbmRleCA9IDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1pbkhhbmRsZS56SW5kZXggPSA0O1xuICAgICAgbWF4SGFuZGxlLnpJbmRleCA9IDM7XG4gICAgfVxuICAgIFttaW5IYW5kbGUsIHRoaXMubWFza1Zpc2libGVSYW5nZSwgbWF4SGFuZGxlXS5mb3JFYWNoKChub2RlLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgYmJveCA9IG5vZGUuZ2V0QkJveCgpO1xuICAgICAgY29uc3QgdGJveCA9IHsgeDogYmJveC54IC0geCwgeTogYmJveC55IC0geSwgaGVpZ2h0OiBiYm94LmhlaWdodCwgd2lkdGg6IGJib3gud2lkdGggfTtcbiAgICAgIHNldEVsZW1lbnRCQm94KHRoaXMucHJveHlOYXZpZ2F0b3JFbGVtZW50c1tpbmRleF0sIHRib3gpO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZU5vZGVzKG1pbiwgbWF4KSB7XG4gICAgdGhpcy5tYXNrLnVwZGF0ZShtaW4sIG1heCk7XG4gIH1cbiAgdXBkYXRlWm9vbSgpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IF9taW46IG1pbiwgX21heDogbWF4IH0gPSB0aGlzO1xuICAgIGlmIChtaW4gPT0gbnVsbCB8fCBtYXggPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB3YXJuT25Db25mbGljdCA9IChzdGF0ZUlkKSA9PiB7XG4gICAgICBpZiAodGhpcy5taW4gPT0gbnVsbCAmJiB0aGlzLm1heCA9PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgIGBDb3VsZCBub3QgYXBwbHkgW25hdmlnYXRvci5taW5dIG9yIFtuYXZpZ2F0b3IubWF4XSBhcyBbJHtzdGF0ZUlkfV0gaGFzIG1vZGlmaWVkIHRoZSBpbml0aWFsIHpvb20gc3RhdGUuYFxuICAgICAgKTtcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmN0eC56b29tTWFuYWdlci51cGRhdGVab29tKFwibmF2aWdhdG9yXCIsIHsgeDogeyBtaW4sIG1heCB9IH0sIGZhbHNlLCB3YXJuT25Db25mbGljdCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIE5hdmlnYXRvci5wcm90b3R5cGUsIFwibWluaUNoYXJ0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiksXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHRhcmdldC51cGRhdGVHcm91cFZpc2liaWxpdHkoKSlcbl0sIE5hdmlnYXRvci5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIE5hdmlnYXRvci5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgTmF2aWdhdG9yLnByb3RvdHlwZSwgXCJzcGFjaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgQWN0aW9uT25TZXQoe1xuICAgIG5ld1ZhbHVlKG1pbikge1xuICAgICAgdGhpcy5fbWluID0gbWluO1xuICAgICAgdGhpcy51cGRhdGVab29tKCk7XG4gICAgfVxuICB9KSxcbiAgVmFsaWRhdGUoQU5EKFJBVElPLCBMRVNTX1RIQU4oXCJtYXhcIikpLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBOYXZpZ2F0b3IucHJvdG90eXBlLCBcIm1pblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIEFjdGlvbk9uU2V0KHtcbiAgICBuZXdWYWx1ZShtYXgpIHtcbiAgICAgIHRoaXMuX21heCA9IG1heDtcbiAgICAgIHRoaXMudXBkYXRlWm9vbSgpO1xuICAgIH1cbiAgfSksXG4gIFZhbGlkYXRlKEFORChSQVRJTywgR1JFQVRFUl9USEFOKFwibWluXCIpKSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTmF2aWdhdG9yLnByb3RvdHlwZSwgXCJtYXhcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L25hdmlnYXRvci9uYXZpZ2F0b3JNb2R1bGUudHNcbnZhciBOYXZpZ2F0b3JNb2R1bGUgPSB7XG4gIHR5cGU6IFwicm9vdFwiLFxuICBvcHRpb25zS2V5OiBcIm5hdmlnYXRvclwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgTmF2aWdhdG9yKGN0eCksXG4gIHRoZW1lVGVtcGxhdGU6IHtcbiAgICBuYXZpZ2F0b3I6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgaGVpZ2h0OiAzMCxcbiAgICAgIG1hc2s6IHtcbiAgICAgICAgZmlsbDogXCIjOTk5OTk5XCIsXG4gICAgICAgIHN0cm9rZTogXCIjOTk5OTk5XCIsXG4gICAgICAgIHN0cm9rZVdpZHRoOiAxLFxuICAgICAgICBmaWxsT3BhY2l0eTogMC4yXG4gICAgICB9LFxuICAgICAgbWluSGFuZGxlOiB7XG4gICAgICAgIGZpbGw6IFwiI2YyZjJmMlwiLFxuICAgICAgICBzdHJva2U6IFwiIzk5OTk5OVwiLFxuICAgICAgICBzdHJva2VXaWR0aDogMSxcbiAgICAgICAgd2lkdGg6IDksXG4gICAgICAgIGhlaWdodDogMTYsXG4gICAgICAgIGdyaXBMaW5lR2FwOiAxLFxuICAgICAgICBncmlwTGluZUxlbmd0aDogOFxuICAgICAgfSxcbiAgICAgIG1heEhhbmRsZToge1xuICAgICAgICBmaWxsOiBcIiNmMmYyZjJcIixcbiAgICAgICAgc3Ryb2tlOiBcIiM5OTk5OTlcIixcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIHdpZHRoOiA5LFxuICAgICAgICBoZWlnaHQ6IDE2LFxuICAgICAgICBncmlwTGluZUdhcDogMSxcbiAgICAgICAgZ3JpcExpbmVMZW5ndGg6IDhcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vZHVsZS90aGVtZS50c1xuZnVuY3Rpb24gc2luZ2xlU2VyaWVzUGFsZXR0ZUZhY3RvcnkoeyB0YWtlQ29sb3JzIH0pIHtcbiAgY29uc3Qge1xuICAgIGZpbGxzOiBbZmlsbF0sXG4gICAgc3Ryb2tlczogW3N0cm9rZV1cbiAgfSA9IHRha2VDb2xvcnMoMSk7XG4gIHJldHVybiB7IGZpbGwsIHN0cm9rZSB9O1xufVxuZnVuY3Rpb24gbWFya2VyUGFsZXR0ZUZhY3RvcnkocGFyYW1zKSB7XG4gIHJldHVybiB7IG1hcmtlcjogc2luZ2xlU2VyaWVzUGFsZXR0ZUZhY3RvcnkocGFyYW1zKSB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvY29uc3RhbnRzLnRzXG52YXIgRk9OVF9TSVpFID0gLyogQF9fUFVSRV9fICovICgoRk9OVF9TSVpFMikgPT4ge1xuICBGT05UX1NJWkUyW0ZPTlRfU0laRTJbXCJTTUFMTFwiXSA9IDEyXSA9IFwiU01BTExcIjtcbiAgRk9OVF9TSVpFMltGT05UX1NJWkUyW1wiTUVESVVNXCJdID0gMTNdID0gXCJNRURJVU1cIjtcbiAgRk9OVF9TSVpFMltGT05UX1NJWkUyW1wiTEFSR0VcIl0gPSAxN10gPSBcIkxBUkdFXCI7XG4gIHJldHVybiBGT05UX1NJWkUyO1xufSkoRk9OVF9TSVpFIHx8IHt9KTtcbnZhciBGT05UX1dFSUdIVDIgPSAvKiBAX19QVVJFX18gKi8gKChGT05UX1dFSUdIVDMpID0+IHtcbiAgRk9OVF9XRUlHSFQzW1wiTk9STUFMXCJdID0gXCJub3JtYWxcIjtcbiAgRk9OVF9XRUlHSFQzW1wiQk9MRFwiXSA9IFwiYm9sZFwiO1xuICBGT05UX1dFSUdIVDNbXCJCT0xERVJcIl0gPSBcImJvbGRlclwiO1xuICBGT05UX1dFSUdIVDNbXCJMSUdIVEVSXCJdID0gXCJsaWdodGVyXCI7XG4gIHJldHVybiBGT05UX1dFSUdIVDM7XG59KShGT05UX1dFSUdIVDIgfHwge30pO1xudmFyIFBPU0lUSU9OMiA9IC8qIEBfX1BVUkVfXyAqLyAoKFBPU0lUSU9OMykgPT4ge1xuICBQT1NJVElPTjNbXCJUT1BcIl0gPSBcInRvcFwiO1xuICBQT1NJVElPTjNbXCJSSUdIVFwiXSA9IFwicmlnaHRcIjtcbiAgUE9TSVRJT04zW1wiQk9UVE9NXCJdID0gXCJib3R0b21cIjtcbiAgUE9TSVRJT04zW1wiTEVGVFwiXSA9IFwibGVmdFwiO1xuICByZXR1cm4gUE9TSVRJT04zO1xufSkoUE9TSVRJT04yIHx8IHt9KTtcbnZhciBDQVJURVNJQU5fQVhJU19UWVBFID0gLyogQF9fUFVSRV9fICovICgoQ0FSVEVTSUFOX0FYSVNfVFlQRTIpID0+IHtcbiAgQ0FSVEVTSUFOX0FYSVNfVFlQRTJbXCJDQVRFR09SWVwiXSA9IFwiY2F0ZWdvcnlcIjtcbiAgQ0FSVEVTSUFOX0FYSVNfVFlQRTJbXCJPUkRJTkFMX1RJTUVcIl0gPSBcIm9yZGluYWwtdGltZVwiO1xuICBDQVJURVNJQU5fQVhJU19UWVBFMltcIk5VTUJFUlwiXSA9IFwibnVtYmVyXCI7XG4gIENBUlRFU0lBTl9BWElTX1RZUEUyW1wiVElNRVwiXSA9IFwidGltZVwiO1xuICBDQVJURVNJQU5fQVhJU19UWVBFMltcIkxPR1wiXSA9IFwibG9nXCI7XG4gIHJldHVybiBDQVJURVNJQU5fQVhJU19UWVBFMjtcbn0pKENBUlRFU0lBTl9BWElTX1RZUEUgfHwge30pO1xudmFyIFBPTEFSX0FYSVNfVFlQRSA9IC8qIEBfX1BVUkVfXyAqLyAoKFBPTEFSX0FYSVNfVFlQRTIpID0+IHtcbiAgUE9MQVJfQVhJU19UWVBFMltcIkFOR0xFX0NBVEVHT1JZXCJdID0gXCJhbmdsZS1jYXRlZ29yeVwiO1xuICBQT0xBUl9BWElTX1RZUEUyW1wiQU5HTEVfTlVNQkVSXCJdID0gXCJhbmdsZS1udW1iZXJcIjtcbiAgUE9MQVJfQVhJU19UWVBFMltcIlJBRElVU19DQVRFR09SWVwiXSA9IFwicmFkaXVzLWNhdGVnb3J5XCI7XG4gIFBPTEFSX0FYSVNfVFlQRTJbXCJSQURJVVNfTlVNQkVSXCJdID0gXCJyYWRpdXMtbnVtYmVyXCI7XG4gIHJldHVybiBQT0xBUl9BWElTX1RZUEUyO1xufSkoUE9MQVJfQVhJU19UWVBFIHx8IHt9KTtcbnZhciBQT0xBUl9BWElTX1NIQVBFID0gLyogQF9fUFVSRV9fICovICgoUE9MQVJfQVhJU19TSEFQRTIpID0+IHtcbiAgUE9MQVJfQVhJU19TSEFQRTJbXCJDSVJDTEVcIl0gPSBcImNpcmNsZVwiO1xuICBQT0xBUl9BWElTX1NIQVBFMltcIlBPTFlHT05cIl0gPSBcInBvbHlnb25cIjtcbiAgcmV0dXJuIFBPTEFSX0FYSVNfU0hBUEUyO1xufSkoUE9MQVJfQVhJU19TSEFQRSB8fCB7fSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9zeW1ib2xzLnRzXG52YXIgSVNfREFSS19USEVNRSA9IFN5bWJvbChcImlzLWRhcmstdGhlbWVcIik7XG52YXIgREVGQVVMVF9GT05UX0ZBTUlMWSA9IFN5bWJvbChcImRlZmF1bHQtZm9udFwiKTtcbnZhciBERUZBVUxUX0xBQkVMX0NPTE9VUiA9IFN5bWJvbChcImRlZmF1bHQtbGFiZWwtY29sb3VyXCIpO1xudmFyIERFRkFVTFRfSU5WRVJURURfTEFCRUxfQ09MT1VSID0gU3ltYm9sKFwiZGVmYXVsdC1pbnZlcnRlZC1sYWJlbC1jb2xvdXJcIik7XG52YXIgREVGQVVMVF9JTlNJREVfU0VSSUVTX0xBQkVMX0NPTE9VUiA9IFN5bWJvbChcImRlZmF1bHQtaW5zaWRlLXNlcmllcy1sYWJlbC1jb2xvdXJcIik7XG52YXIgREVGQVVMVF9NVVRFRF9MQUJFTF9DT0xPVVIgPSBTeW1ib2woXCJkZWZhdWx0LW11dGVkLWxhYmVsLWNvbG91clwiKTtcbnZhciBERUZBVUxUX0FYSVNfR1JJRF9DT0xPVVIgPSBTeW1ib2woXCJkZWZhdWx0LWF4aXMtZ3JpZC1jb2xvdXJcIik7XG52YXIgREVGQVVMVF9BWElTX0xJTkVfQ09MT1VSID0gU3ltYm9sKFwiZGVmYXVsdC1heGlzLWxpbmUtY29sb3VyXCIpO1xudmFyIERFRkFVTFRfQ1JPU1NfTElORVNfQ09MT1VSID0gU3ltYm9sKFwiZGVmYXVsdC1jcm9zcy1saW5lcy1jb2xvdXJcIik7XG52YXIgREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9VUiA9IFN5bWJvbChcImRlZmF1bHQtYmFja2dyb3VuZC1jb2xvdXJcIik7XG52YXIgREVGQVVMVF9TSEFET1dfQ09MT1VSID0gU3ltYm9sKFwiZGVmYXVsdC1zaGFkb3ctY29sb3VyXCIpO1xudmFyIERFRkFVTFRfQ09MT1VSUyA9IFN5bWJvbChcImRlZmF1bHQtY29sb3Vyc1wiKTtcbnZhciBERUZBVUxUX1BBRERJTkcgPSBTeW1ib2woXCJkZWZhdWx0LXBhZGRpbmdcIik7XG52YXIgREVGQVVMVF9DQVBUSU9OX0xBWU9VVF9TVFlMRSA9IFN5bWJvbChcImRlZmF1bHQtY2FwdGlvbi1sYXlvdXQtc3R5bGVcIik7XG52YXIgREVGQVVMVF9DQVBUSU9OX0FMSUdOTUVOVCA9IFN5bWJvbChcImRlZmF1bHQtY2FwdGlvbi1hbGlnbm1lbnRcIik7XG52YXIgUEFMRVRURV9VUF9TVFJPS0UgPSBTeW1ib2woXCJwYWxldHRlLXVwLXN0cm9rZVwiKTtcbnZhciBQQUxFVFRFX0RPV05fU1RST0tFID0gU3ltYm9sKFwicGFsZXR0ZS1kb3duLXN0cm9rZVwiKTtcbnZhciBQQUxFVFRFX1VQX0ZJTEwgPSBTeW1ib2woXCJwYWxldHRlLXVwLWZpbGxcIik7XG52YXIgUEFMRVRURV9ET1dOX0ZJTEwgPSBTeW1ib2woXCJwYWxldHRlLWRvd24tZmlsbFwiKTtcbnZhciBQQUxFVFRFX05FVVRSQUxfU1RST0tFID0gU3ltYm9sKFwicGFsZXR0ZS1uZXV0cmFsLXN0cm9rZVwiKTtcbnZhciBQQUxFVFRFX05FVVRSQUxfRklMTCA9IFN5bWJvbChcInBhbGV0dGUtbmV1dHJhbC1maWxsXCIpO1xudmFyIFBBTEVUVEVfQUxUX1VQX1NUUk9LRSA9IFN5bWJvbChcInBhbGV0dGUtYWx0LXVwLXN0cm9rZVwiKTtcbnZhciBQQUxFVFRFX0FMVF9ET1dOX1NUUk9LRSA9IFN5bWJvbChcInBhbGV0dGUtYWx0LWRvd24tc3Ryb2tlXCIpO1xudmFyIFBBTEVUVEVfQUxUX1VQX0ZJTEwgPSBTeW1ib2woXCJwYWxldHRlLWFsdC11cC1maWxsXCIpO1xudmFyIFBBTEVUVEVfQUxUX0RPV05fRklMTCA9IFN5bWJvbChcInBhbGV0dGUtYWx0LWRvd24tZmlsbFwiKTtcbnZhciBQQUxFVFRFX0FMVF9ORVVUUkFMX0ZJTEwgPSBTeW1ib2woXCJwYWxldHRlLWdyYXktZmlsbFwiKTtcbnZhciBQQUxFVFRFX0FMVF9ORVVUUkFMX1NUUk9LRSA9IFN5bWJvbChcInBhbGV0dGUtZ3JheS1zdHJva2VcIik7XG52YXIgREVGQVVMVF9QT0xBUl9TRVJJRVNfU1RST0tFID0gU3ltYm9sKFwiZGVmYXVsdC1wb2xhci1zZXJpZXMtc3Ryb2tlXCIpO1xudmFyIERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPVVJfUkFOR0UgPSBTeW1ib2woXG4gIFwiZGVmYXVsdC1kaXZlcmdpbmctc2VyaWVzLWNvbG91ci1yYW5nZVwiXG4pO1xudmFyIERFRkFVTFRfSElFUkFSQ0hZX0ZJTExTID0gU3ltYm9sKFwiZGVmYXVsdC1oaWVyYXJjaHktZmlsbHNcIik7XG52YXIgREVGQVVMVF9ISUVSQVJDSFlfU1RST0tFUyA9IFN5bWJvbChcImRlZmF1bHQtaGllcmFyY2h5LXN0cm9rZXNcIik7XG52YXIgREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SID0gU3ltYm9sKFwiZGVmYXVsdC1hbm5vdGF0aW9uLXN0cm9rZVwiKTtcbnZhciBERUZBVUxUX1RFWFRfQU5OT1RBVElPTl9DT0xPUiA9IFN5bWJvbChcImRlZmF1bHQtdGV4dC1hbm5vdGF0aW9uLWNvbG9yXCIpO1xudmFyIERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwgPSBTeW1ib2woXCJkZWZhdWx0LWFubm90YXRpb24tYmFja2dyb3VuZC1maWxsXCIpO1xudmFyIERFRkFVTFRfQU5OT1RBVElPTl9IQU5ETEVfRklMTCA9IFN5bWJvbChcImRlZmF1bHQtYW5ub3RhdGlvbi1oYW5kbGUtZmlsbFwiKTtcbnZhciBERUZBVUxUX1RFWFRCT1hfRklMTCA9IFN5bWJvbChcImRlZmF1bHQtdGV4dGJveC1maWxsXCIpO1xudmFyIERFRkFVTFRfVEVYVEJPWF9TVFJPS0UgPSBTeW1ib2woXCJkZWZhdWx0LXRleHRib3gtc3Ryb2tlXCIpO1xudmFyIERFRkFVTFRfVEVYVEJPWF9DT0xPUiA9IFN5bWJvbChcImRlZmF1bHQtdGV4dGJveC1jb2xvclwiKTtcbnZhciBERUZBVUxUX1RPT0xCQVJfUE9TSVRJT04gPSBTeW1ib2woXCJkZWZhdWx0LXRvb2xiYXItcG9zaXRpb25cIik7XG52YXIgREVGQVVMVF9HUklETElORV9FTkFCTEVEID0gU3ltYm9sKFwiZGVmYXVsdC1ncmlkbGluZS1lbmFibGVkXCIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9tb3Rpb24vcGF0aE1vdGlvbi50c1xuZnVuY3Rpb24gcGF0aE1vdGlvbihncm91cElkLCBzdWJJZCwgYW5pbWF0aW9uTWFuYWdlciwgcGF0aHMsIGZucykge1xuICBjb25zdCB7IGFkZFBoYXNlRm4sIHVwZGF0ZVBoYXNlRm4sIHJlbW92ZVBoYXNlRm4gfSA9IGZucztcbiAgY29uc3QgYW5pbWF0ZSA9IChwaGFzZSwgcGF0aCwgdXBkYXRlRm4pID0+IHtcbiAgICBhbmltYXRpb25NYW5hZ2VyLmFuaW1hdGUoe1xuICAgICAgaWQ6IGAke2dyb3VwSWR9XyR7c3ViSWR9XyR7cGF0aC5pZH1fJHtwaGFzZX1gLFxuICAgICAgZ3JvdXBJZCxcbiAgICAgIGZyb206IDAsXG4gICAgICB0bzogMSxcbiAgICAgIGVhc2U6IGVhc2VPdXQsXG4gICAgICBjb2xsYXBzYWJsZTogZmFsc2UsXG4gICAgICBvblVwZGF0ZShyYXRpbzIsIHByZUluaXQpIHtcbiAgICAgICAgaWYgKHByZUluaXQgJiYgcGhhc2UgIT09IFwicmVtb3ZlZFwiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGF0aC5wYXRoLmNsZWFyKHRydWUpO1xuICAgICAgICB1cGRhdGVGbihyYXRpbzIsIHBhdGgpO1xuICAgICAgICBwYXRoLmNoZWNrUGF0aERpcnR5KCk7XG4gICAgICB9LFxuICAgICAgb25TdG9wKCkge1xuICAgICAgICBpZiAocGhhc2UgIT09IFwiYWRkZWRcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBhdGgucGF0aC5jbGVhcih0cnVlKTtcbiAgICAgICAgdXBkYXRlRm4oMSwgcGF0aCk7XG4gICAgICAgIHBhdGguY2hlY2tQYXRoRGlydHkoKTtcbiAgICAgIH0sXG4gICAgICBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1twaGFzZV1cbiAgICB9KTtcbiAgfTtcbiAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XG4gICAgaWYgKCFhbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpKSB7XG4gICAgICBhbmltYXRlKFwicmVtb3ZlZFwiLCBwYXRoLCByZW1vdmVQaGFzZUZuKTtcbiAgICAgIGFuaW1hdGUoXCJ1cGRhdGVkXCIsIHBhdGgsIHVwZGF0ZVBoYXNlRm4pO1xuICAgIH1cbiAgICBhbmltYXRlKFwiYWRkZWRcIiwgcGF0aCwgYWRkUGhhc2VGbik7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9zYW5pdGl6ZS50c1xudmFyIGVsZW1lbnQgPSBudWxsO1xuZnVuY3Rpb24gc2FuaXRpemVIdG1sKHRleHQpIHtcbiAgaWYgKHRleHQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmICh0ZXh0ID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgZWxlbWVudCA/PyAoZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO1xuICBlbGVtZW50LnRleHRDb250ZW50ID0gU3RyaW5nKHRleHQpO1xuICByZXR1cm4gZWxlbWVudC5pbm5lckhUTUw7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9zZXJpZXNMYWJlbFV0aWwudHNcbmZ1bmN0aW9uIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHsgaWQgfSwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIC4uLmxhYmVsU2VsZWN0aW9ucykge1xuICBzdGF0aWNGcm9tVG9Nb3Rpb24oXG4gICAgaWQsXG4gICAgc3ViSWQsXG4gICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICBsYWJlbFNlbGVjdGlvbnMsXG4gICAgeyBvcGFjaXR5OiAwIH0sXG4gICAgeyBvcGFjaXR5OiAxIH0sXG4gICAgeyBwaGFzZTogXCJ0cmFpbGluZ1wiIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHNlcmllc0xhYmVsRmFkZU91dEFuaW1hdGlvbih7IGlkIH0sIHN1YklkLCBhbmltYXRpb25NYW5hZ2VyLCAuLi5sYWJlbFNlbGVjdGlvbnMpIHtcbiAgc3RhdGljRnJvbVRvTW90aW9uKFxuICAgIGlkLFxuICAgIHN1YklkLFxuICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgbGFiZWxTZWxlY3Rpb25zLFxuICAgIHsgb3BhY2l0eTogMSB9LFxuICAgIHsgb3BhY2l0eTogMCB9LFxuICAgIHsgcGhhc2U6IFwicmVtb3ZlXCIgfVxuICApO1xufVxuZnVuY3Rpb24gcmVzZXRMYWJlbEZuKF9ub2RlKSB7XG4gIHJldHVybiB7IG9wYWNpdHk6IDEgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvdXRpbC9jaGFuZ2VEZXRlY3RhYmxlUHJvcGVydGllcy50c1xudmFyIENoYW5nZURldGVjdGFibGVQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5fZGlydHkgPSAzIC8qIE1BSk9SICovO1xuICB9XG4gIG1hcmtEaXJ0eShfc291cmNlLCB0eXBlID0gMSAvKiBUUklWSUFMICovKSB7XG4gICAgaWYgKHRoaXMuX2RpcnR5IDwgdHlwZSkge1xuICAgICAgdGhpcy5fZGlydHkgPSB0eXBlO1xuICAgIH1cbiAgfVxuICBtYXJrQ2xlYW4oX29wdHMpIHtcbiAgICB0aGlzLl9kaXJ0eSA9IDAgLyogTk9ORSAqLztcbiAgfVxuICBpc0RpcnR5KCkge1xuICAgIHJldHVybiB0aGlzLl9kaXJ0eSA+IDAgLyogTk9ORSAqLztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvZHJvcFNoYWRvdy50c1xudmFyIERyb3BTaGFkb3cgPSBjbGFzcyBleHRlbmRzIENoYW5nZURldGVjdGFibGVQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuY29sb3IgPSBcInJnYmEoMCwgMCwgMCwgMC41KVwiO1xuICAgIHRoaXMueE9mZnNldCA9IDA7XG4gICAgdGhpcy55T2Zmc2V0ID0gMDtcbiAgICB0aGlzLmJsdXIgPSA1O1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBEcm9wU2hhZG93LnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIERyb3BTaGFkb3cucHJvdG90eXBlLCBcImNvbG9yXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIERyb3BTaGFkb3cucHJvdG90eXBlLCBcInhPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgRHJvcFNoYWRvdy5wcm90b3R5cGUsIFwieU9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBEcm9wU2hhZG93LnByb3RvdHlwZSwgXCJibHVyXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvc2VyaWVzTWFya2VyLnRzXG52YXIgTUFSS0VSX1NIQVBFID0gcHJlZGljYXRlV2l0aE1lc3NhZ2UoXG4gICh2YWx1ZSkgPT4gaXNNYXJrZXJTaGFwZSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgJiYgT2JqZWN0LmNyZWF0ZSh2YWx1ZS5wcm90b3R5cGUpIGluc3RhbmNlb2YgTWFya2VyLFxuICBgYSBtYXJrZXIgc2hhcGUga2V5d29yZCBzdWNoIGFzICdjaXJjbGUnLCAnZGlhbW9uZCcgb3IgJ3NxdWFyZScgb3IgYW4gb2JqZWN0IGV4dGVuZGluZyB0aGUgTWFya2VyIGNsYXNzYFxuKTtcbnZhciBTZXJpZXNNYXJrZXIgPSBjbGFzcyBleHRlbmRzIENoYW5nZURldGVjdGFibGVQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuc2hhcGUgPSBDaXJjbGU7XG4gICAgdGhpcy5zaXplID0gNjtcbiAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbiAgICB0aGlzLnN0cm9rZU9wYWNpdHkgPSAxO1xuICB9XG4gIGdldFN0eWxlKCkge1xuICAgIGNvbnN0IHsgc2l6ZSwgc2hhcGUsIGZpbGwsIGZpbGxPcGFjaXR5LCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VPcGFjaXR5IH0gPSB0aGlzO1xuICAgIHJldHVybiB7IHNpemUsIHNoYXBlLCBmaWxsLCBmaWxsT3BhY2l0eSwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlT3BhY2l0eSB9O1xuICB9XG4gIGdldERpYW1ldGVyKCkge1xuICAgIHJldHVybiB0aGlzLnNpemUgKyB0aGlzLnN0cm9rZVdpZHRoO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShNQVJLRVJfU0hBUEUpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJzaGFwZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUiksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcInNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTyksXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBTZXJpZXNNYXJrZXIucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKSxcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIFNlcmllc01hcmtlci5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEZVTkNUSU9OLCB7IG9wdGlvbmFsOiB0cnVlIH0pLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJpdGVtU3R5bGVyXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvc2VyaWVzVG9vbHRpcC50c1xudmFyIFNlcmllc1Rvb2x0aXBJbnRlcmFjdGlvbiA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIFNlcmllc1Rvb2x0aXBJbnRlcmFjdGlvbi5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbnZhciBTZXJpZXNUb29sdGlwID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmludGVyYWN0aW9uID0gbmV3IFNlcmllc1Rvb2x0aXBJbnRlcmFjdGlvbigpO1xuICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgdGhpcy5yYW5nZSA9IHZvaWQgMDtcbiAgfVxuICB0b1Rvb2x0aXBIdG1sKGRlZmF1bHRzLCBwYXJhbXMpIHtcbiAgICBpZiAodGhpcy5yZW5kZXJlcikge1xuICAgICAgcmV0dXJuIHRvVG9vbHRpcEh0bWwodGhpcy5yZW5kZXJlcihwYXJhbXMpLCBkZWZhdWx0cyk7XG4gICAgfVxuICAgIHJldHVybiB0b1Rvb2x0aXBIdG1sKGRlZmF1bHRzKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBTZXJpZXNUb29sdGlwLnByb3RvdHlwZSwgXCJlbmFibGVkXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2VyaWVzVG9vbHRpcC5wcm90b3R5cGUsIFwic2hvd0Fycm93XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNlcmllc1Rvb2x0aXAucHJvdG90eXBlLCBcInJlbmRlcmVyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgU2VyaWVzVG9vbHRpcC5wcm90b3R5cGUsIFwiaW50ZXJhY3Rpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBTZXJpZXNUb29sdGlwLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKElOVEVSQUNUSU9OX1JBTkdFLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTZXJpZXNUb29sdGlwLnByb3RvdHlwZSwgXCJyYW5nZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9pbnRlcnBvbGF0aW9uUHJvcGVydGllcy50c1xudmFyIElOVEVSUE9MQVRJT05fVFlQRSA9IFVOSU9OKFtcImxpbmVhclwiLCBcInNtb290aFwiLCBcInN0ZXBcIl0sIFwiYSBsaW5lIHN0eWxlXCIpO1xudmFyIElOVEVSUE9MQVRJT05fU1RFUF9QT1NJVElPTiA9IFVOSU9OKFtcInN0YXJ0XCIsIFwibWlkZGxlXCIsIFwiZW5kXCJdKTtcbnZhciBJbnRlcnBvbGF0aW9uUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQmFzZVByb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9IFwibGluZWFyXCI7XG4gICAgdGhpcy50ZW5zaW9uID0gMTtcbiAgICB0aGlzLnBvc2l0aW9uID0gXCJlbmRcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKElOVEVSUE9MQVRJT05fVFlQRSlcbl0sIEludGVycG9sYXRpb25Qcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0eXBlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBJbnRlcnBvbGF0aW9uUHJvcGVydGllcy5wcm90b3R5cGUsIFwidGVuc2lvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKElOVEVSUE9MQVRJT05fU1RFUF9QT1NJVElPTilcbl0sIEludGVycG9sYXRpb25Qcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9hcmVhU2VyaWVzUHJvcGVydGllcy50c1xudmFyIEFyZWFTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnhOYW1lID0gdm9pZCAwO1xuICAgIHRoaXMuZmlsbCA9IFwiI2MxNjA2OFwiO1xuICAgIHRoaXMuZmlsbE9wYWNpdHkgPSAxO1xuICAgIHRoaXMuc3Ryb2tlID0gXCIjODc0MzQ5XCI7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDI7XG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICB0aGlzLmxpbmVEYXNoID0gWzBdO1xuICAgIHRoaXMubGluZURhc2hPZmZzZXQgPSAwO1xuICAgIHRoaXMuaW50ZXJwb2xhdGlvbiA9IG5ldyBJbnRlcnBvbGF0aW9uUHJvcGVydGllcygpO1xuICAgIHRoaXMuc2hhZG93ID0gbmV3IERyb3BTaGFkb3coKTtcbiAgICB0aGlzLm1hcmtlciA9IG5ldyBTZXJpZXNNYXJrZXIoKTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IExhYmVsKCk7XG4gICAgdGhpcy50b29sdGlwID0gbmV3IFNlcmllc1Rvb2x0aXAoKTtcbiAgICB0aGlzLmNvbm5lY3RNaXNzaW5nRGF0YSA9IGZhbHNlO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieU5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJub3JtYWxpemVkVG9cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShMSU5FX0RBU0gpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaW50ZXJwb2xhdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEFyZWFTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaGFkb3dcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBBcmVhU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibWFya2VyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInRvb2x0aXBcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgQXJlYVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbm5lY3RNaXNzaW5nRGF0YVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NlbmUvdXRpbC9iZXppZXIudHNcbmZ1bmN0aW9uIGV2YWx1YXRlQmV6aWVyKHAwLCBwMSwgcDIsIHAzLCB0KSB7XG4gIHJldHVybiAoMSAtIHQpICoqIDMgKiBwMCArIDMgKiAoMSAtIHQpICoqIDIgKiB0ICogcDEgKyAzICogKDEgLSB0KSArIHQgKiogMiAqIHAyICsgdCAqKiAzICogcDM7XG59XG5mdW5jdGlvbiBzb2x2ZUJlemllcihwMCwgcDEsIHAyLCBwMywgdmFsdWUpIHtcbiAgaWYgKHZhbHVlIDw9IE1hdGgubWluKHAwLCBwMykpIHtcbiAgICByZXR1cm4gcDAgPCBwMyA/IDAgOiAxO1xuICB9IGVsc2UgaWYgKHZhbHVlID49IE1hdGgubWF4KHAwLCBwMykpIHtcbiAgICByZXR1cm4gcDAgPCBwMyA/IDEgOiAwO1xuICB9XG4gIGxldCB0MCA9IDA7XG4gIGxldCB0MSA9IDE7XG4gIGxldCB0ID0gTmFOO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkgKz0gMSkge1xuICAgIHQgPSAodDAgKyB0MSkgLyAyO1xuICAgIGNvbnN0IGN1cnZlVmFsdWUgPSAoMSAtIHQpICoqIDMgKiBwMCArIDMgKiAoMSAtIHQpICoqIDIgKiB0ICogcDEgKyAzICogKDEgLSB0KSAqIHQgKiogMiAqIHAyICsgdCAqKiAzICogcDM7XG4gICAgaWYgKGN1cnZlVmFsdWUgPCB2YWx1ZSkge1xuICAgICAgdDAgPSB0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0MSA9IHQ7XG4gICAgfVxuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gc3BsaXRCZXppZXIocDB4LCBwMHksIHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3ksIHQpIHtcbiAgY29uc3QgeDAxID0gKDEgLSB0KSAqIHAweCArIHQgKiBwMXg7XG4gIGNvbnN0IHkwMSA9ICgxIC0gdCkgKiBwMHkgKyB0ICogcDF5O1xuICBjb25zdCB4MTIgPSAoMSAtIHQpICogcDF4ICsgdCAqIHAyeDtcbiAgY29uc3QgeTEyID0gKDEgLSB0KSAqIHAxeSArIHQgKiBwMnk7XG4gIGNvbnN0IHgyMyA9ICgxIC0gdCkgKiBwMnggKyB0ICogcDN4O1xuICBjb25zdCB5MjMgPSAoMSAtIHQpICogcDJ5ICsgdCAqIHAzeTtcbiAgY29uc3QgeDAxMiA9ICgxIC0gdCkgKiB4MDEgKyB0ICogeDEyO1xuICBjb25zdCB5MDEyID0gKDEgLSB0KSAqIHkwMSArIHQgKiB5MTI7XG4gIGNvbnN0IHgxMjMgPSAoMSAtIHQpICogeDEyICsgdCAqIHgyMztcbiAgY29uc3QgeTEyMyA9ICgxIC0gdCkgKiB5MTIgKyB0ICogeTIzO1xuICBjb25zdCB4MDEyMyA9ICgxIC0gdCkgKiB4MDEyICsgdCAqIHgxMjM7XG4gIGNvbnN0IHkwMTIzID0gKDEgLSB0KSAqIHkwMTIgKyB0ICogeTEyMztcbiAgcmV0dXJuIFtcbiAgICBbXG4gICAgICB7IHg6IHAweCwgeTogcDB5IH0sXG4gICAgICB7IHg6IHgwMSwgeTogeTAxIH0sXG4gICAgICB7IHg6IHgwMTIsIHk6IHkwMTIgfSxcbiAgICAgIHsgeDogeDAxMjMsIHk6IHkwMTIzIH1cbiAgICBdLFxuICAgIFtcbiAgICAgIHsgeDogeDAxMjMsIHk6IHkwMTIzIH0sXG4gICAgICB7IHg6IHgxMjMsIHk6IHkxMjMgfSxcbiAgICAgIHsgeDogeDIzLCB5OiB5MjMgfSxcbiAgICAgIHsgeDogcDN4LCB5OiBwM3kgfVxuICAgIF1cbiAgXTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9saW5lSW50ZXJwb2xhdGlvbi50c1xuZnVuY3Rpb24gc3BhblJhbmdlKHNwYW4pIHtcbiAgc3dpdGNoIChzcGFuLnR5cGUpIHtcbiAgICBjYXNlIFwibGluZWFyXCI6XG4gICAgY2FzZSBcInN0ZXBcIjpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHsgeDogc3Bhbi54MCwgeTogc3Bhbi55MCB9LFxuICAgICAgICB7IHg6IHNwYW4ueDEsIHk6IHNwYW4ueTEgfVxuICAgICAgXTtcbiAgICBjYXNlIFwiY3ViaWNcIjpcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHsgeDogc3Bhbi5jcDB4LCB5OiBzcGFuLmNwMHkgfSxcbiAgICAgICAgeyB4OiBzcGFuLmNwM3gsIHk6IHNwYW4uY3AzeSB9XG4gICAgICBdO1xuICB9XG59XG5mdW5jdGlvbiByZXZlcnNlU3BhbihzcGFuKSB7XG4gIHN3aXRjaCAoc3Bhbi50eXBlKSB7XG4gICAgY2FzZSBcImxpbmVhclwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJsaW5lYXJcIixcbiAgICAgICAgbW92ZVRvOiBzcGFuLm1vdmVUbyxcbiAgICAgICAgeDA6IHNwYW4ueDEsXG4gICAgICAgIHkwOiBzcGFuLnkxLFxuICAgICAgICB4MTogc3Bhbi54MCxcbiAgICAgICAgeTE6IHNwYW4ueTBcbiAgICAgIH07XG4gICAgY2FzZSBcImN1YmljXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImN1YmljXCIsXG4gICAgICAgIG1vdmVUbzogc3Bhbi5tb3ZlVG8sXG4gICAgICAgIGNwMHg6IHNwYW4uY3AzeCxcbiAgICAgICAgY3AweTogc3Bhbi5jcDN5LFxuICAgICAgICBjcDF4OiBzcGFuLmNwMngsXG4gICAgICAgIGNwMXk6IHNwYW4uY3AyeSxcbiAgICAgICAgY3AyeDogc3Bhbi5jcDF4LFxuICAgICAgICBjcDJ5OiBzcGFuLmNwMXksXG4gICAgICAgIGNwM3g6IHNwYW4uY3AweCxcbiAgICAgICAgY3AzeTogc3Bhbi5jcDB5XG4gICAgICB9O1xuICAgIGNhc2UgXCJzdGVwXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInN0ZXBcIixcbiAgICAgICAgbW92ZVRvOiBzcGFuLm1vdmVUbyxcbiAgICAgICAgeDA6IHNwYW4ueDEsXG4gICAgICAgIHkwOiBzcGFuLnkxLFxuICAgICAgICB4MTogc3Bhbi54MCxcbiAgICAgICAgeTE6IHNwYW4ueTAsXG4gICAgICAgIHN0ZXBYOiBzcGFuLnN0ZXBYXG4gICAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBjb2xsYXBzZVNwYW5Ub1BvaW50KHNwYW4sIHBvaW50KSB7XG4gIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQ7XG4gIHN3aXRjaCAoc3Bhbi50eXBlKSB7XG4gICAgY2FzZSBcImxpbmVhclwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJsaW5lYXJcIixcbiAgICAgICAgbW92ZVRvOiBzcGFuLm1vdmVUbyxcbiAgICAgICAgeDA6IHgsXG4gICAgICAgIHkwOiB5LFxuICAgICAgICB4MTogeCxcbiAgICAgICAgeTE6IHlcbiAgICAgIH07XG4gICAgY2FzZSBcInN0ZXBcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwic3RlcFwiLFxuICAgICAgICBtb3ZlVG86IHNwYW4ubW92ZVRvLFxuICAgICAgICB4MDogeCxcbiAgICAgICAgeTA6IHksXG4gICAgICAgIHgxOiB4LFxuICAgICAgICB5MTogeSxcbiAgICAgICAgc3RlcFg6IHhcbiAgICAgIH07XG4gICAgY2FzZSBcImN1YmljXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImN1YmljXCIsXG4gICAgICAgIG1vdmVUbzogc3Bhbi5tb3ZlVG8sXG4gICAgICAgIGNwMHg6IHgsXG4gICAgICAgIGNwMHk6IHksXG4gICAgICAgIGNwMXg6IHgsXG4gICAgICAgIGNwMXk6IHksXG4gICAgICAgIGNwMng6IHgsXG4gICAgICAgIGNwMnk6IHksXG4gICAgICAgIGNwM3g6IHgsXG4gICAgICAgIGNwM3k6IHlcbiAgICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc2NhbGVTcGFuKHNwYW4sIG5leHRTdGFydCwgbmV4dEVuZCkge1xuICBjb25zdCBbcHJldlN0YXJ0LCBwcmV2RW5kXSA9IHNwYW5SYW5nZShzcGFuKTtcbiAgY29uc3Qgd2lkdGhTY2FsZSA9IHByZXZFbmQueCAhPT0gcHJldlN0YXJ0LnggPyAobmV4dEVuZC54IC0gbmV4dFN0YXJ0LngpIC8gKHByZXZFbmQueCAtIHByZXZTdGFydC54KSA6IDA7XG4gIGNvbnN0IGhlaWdodFNjYWxlID0gcHJldkVuZC55ICE9PSBwcmV2U3RhcnQueSA/IChuZXh0RW5kLnkgLSBuZXh0U3RhcnQueSkgLyAocHJldkVuZC55IC0gcHJldlN0YXJ0LnkpIDogMDtcbiAgc3dpdGNoIChzcGFuLnR5cGUpIHtcbiAgICBjYXNlIFwibGluZWFyXCI6XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImxpbmVhclwiLFxuICAgICAgICBtb3ZlVG86IHNwYW4ubW92ZVRvLFxuICAgICAgICB4MDogbmV4dFN0YXJ0LngsXG4gICAgICAgIHkwOiBuZXh0U3RhcnQueSxcbiAgICAgICAgeDE6IG5leHRFbmQueCxcbiAgICAgICAgeTE6IG5leHRFbmQueVxuICAgICAgfTtcbiAgICBjYXNlIFwiY3ViaWNcIjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiY3ViaWNcIixcbiAgICAgICAgbW92ZVRvOiBzcGFuLm1vdmVUbyxcbiAgICAgICAgY3AweDogbmV4dFN0YXJ0LngsXG4gICAgICAgIGNwMHk6IG5leHRTdGFydC55LFxuICAgICAgICBjcDF4OiBuZXh0RW5kLnggLSAoc3Bhbi5jcDJ4IC0gcHJldlN0YXJ0LngpICogd2lkdGhTY2FsZSxcbiAgICAgICAgY3AxeTogbmV4dEVuZC55IC0gKHNwYW4uY3AyeSAtIHByZXZTdGFydC55KSAqIGhlaWdodFNjYWxlLFxuICAgICAgICBjcDJ4OiBuZXh0RW5kLnggLSAoc3Bhbi5jcDF4IC0gcHJldlN0YXJ0LngpICogd2lkdGhTY2FsZSxcbiAgICAgICAgY3AyeTogbmV4dEVuZC55IC0gKHNwYW4uY3AxeSAtIHByZXZTdGFydC55KSAqIGhlaWdodFNjYWxlLFxuICAgICAgICBjcDN4OiBuZXh0RW5kLngsXG4gICAgICAgIGNwM3k6IG5leHRFbmQueVxuICAgICAgfTtcbiAgICBjYXNlIFwic3RlcFwiOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJzdGVwXCIsXG4gICAgICAgIG1vdmVUbzogc3Bhbi5tb3ZlVG8sXG4gICAgICAgIHgwOiBuZXh0U3RhcnQueCxcbiAgICAgICAgeTA6IG5leHRTdGFydC55LFxuICAgICAgICB4MTogbmV4dEVuZC54LFxuICAgICAgICB5MTogbmV4dEVuZC55LFxuICAgICAgICBzdGVwWDogbmV4dEVuZC54IC0gKHNwYW4uc3RlcFggLSBwcmV2U3RhcnQueCkgKiB3aWR0aFNjYWxlXG4gICAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBzZXRNb3ZlVG8oc3BhbiwgbW92ZVRvKSB7XG4gIHJldHVybiBzcGFuLm1vdmVUbyAhPT0gbW92ZVRvID8geyAuLi5zcGFuLCBtb3ZlVG8gfSA6IHNwYW47XG59XG5mdW5jdGlvbiBzcGxpdFNwYW5BdFgoc3BhbiwgeCkge1xuICBjb25zdCBbc3RhcnQsIGVuZF0gPSBzcGFuUmFuZ2Uoc3Bhbik7XG4gIGxldCB4MDtcbiAgbGV0IHkwO1xuICBsZXQgeDE7XG4gIGxldCB5MTtcbiAgaWYgKHN0YXJ0LnggPCBlbmQueCkge1xuICAgIHgwID0gc3RhcnQueDtcbiAgICB5MCA9IHN0YXJ0Lnk7XG4gICAgeDEgPSBlbmQueDtcbiAgICB5MSA9IGVuZC55O1xuICB9IGVsc2Uge1xuICAgIHgwID0gZW5kLng7XG4gICAgeTAgPSBlbmQueTtcbiAgICB4MSA9IHN0YXJ0Lng7XG4gICAgeTEgPSBzdGFydC55O1xuICB9XG4gIGlmICh4IDwgeDApIHtcbiAgICByZXR1cm4gW3Jlc2NhbGVTcGFuKHNwYW4sIHN0YXJ0LCBzdGFydCksIHNldE1vdmVUbyhzcGFuLCBmYWxzZSldO1xuICB9IGVsc2UgaWYgKHggPiB4MSkge1xuICAgIHJldHVybiBbc3Bhbiwgc2V0TW92ZVRvKHJlc2NhbGVTcGFuKHNwYW4sIGVuZCwgZW5kKSwgZmFsc2UpXTtcbiAgfVxuICBzd2l0Y2ggKHNwYW4udHlwZSkge1xuICAgIGNhc2UgXCJsaW5lYXJcIjoge1xuICAgICAgY29uc3QgbWlkWSA9IHkwID09PSB5MSA/IHkwIDogKHkxIC0geTApIC8gKHgxIC0geDApICogKHggLSB4MCkgKyB5MDtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHsgdHlwZTogXCJsaW5lYXJcIiwgbW92ZVRvOiBzcGFuLm1vdmVUbywgeDAsIHkwLCB4MTogeCwgeTE6IG1pZFkgfSxcbiAgICAgICAgeyB0eXBlOiBcImxpbmVhclwiLCBtb3ZlVG86IGZhbHNlLCB4MDogeCwgeTA6IG1pZFksIHgxLCB5MSB9XG4gICAgICBdO1xuICAgIH1cbiAgICBjYXNlIFwic3RlcFwiOlxuICAgICAgaWYgKHggPCBzcGFuLnN0ZXBYKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgeyB0eXBlOiBcInN0ZXBcIiwgbW92ZVRvOiBzcGFuLm1vdmVUbywgeDAsIHkwLCB4MTogeCwgeTE6IHkwLCBzdGVwWDogeCB9LFxuICAgICAgICAgIHsgdHlwZTogXCJzdGVwXCIsIG1vdmVUbzogZmFsc2UsIHgwOiB4LCB5MCwgeDEsIHkxLCBzdGVwWDogc3Bhbi5zdGVwWCB9XG4gICAgICAgIF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHsgdHlwZTogXCJzdGVwXCIsIG1vdmVUbzogc3Bhbi5tb3ZlVG8sIHgwLCB5MCwgeDE6IHgsIHkxLCBzdGVwWDogc3Bhbi5zdGVwWCB9LFxuICAgICAgICAgIHsgdHlwZTogXCJzdGVwXCIsIG1vdmVUbzogZmFsc2UsIHgwOiB4LCB5MDogeTEsIHgxLCB5MSwgc3RlcFg6IHggfVxuICAgICAgICBdO1xuICAgICAgfVxuICAgIGNhc2UgXCJjdWJpY1wiOiB7XG4gICAgICBjb25zdCB0ID0gc29sdmVCZXppZXIoc3Bhbi5jcDB4LCBzcGFuLmNwMXgsIHNwYW4uY3AyeCwgc3Bhbi5jcDN4LCB4KTtcbiAgICAgIGNvbnN0IFthLCBiXSA9IHNwbGl0QmV6aWVyKFxuICAgICAgICBzcGFuLmNwMHgsXG4gICAgICAgIHNwYW4uY3AweSxcbiAgICAgICAgc3Bhbi5jcDF4LFxuICAgICAgICBzcGFuLmNwMXksXG4gICAgICAgIHNwYW4uY3AyeCxcbiAgICAgICAgc3Bhbi5jcDJ5LFxuICAgICAgICBzcGFuLmNwM3gsXG4gICAgICAgIHNwYW4uY3AzeSxcbiAgICAgICAgdFxuICAgICAgKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImN1YmljXCIsXG4gICAgICAgICAgbW92ZVRvOiBzcGFuLm1vdmVUbyxcbiAgICAgICAgICBjcDB4OiBhWzBdLngsXG4gICAgICAgICAgY3AweTogYVswXS55LFxuICAgICAgICAgIGNwMXg6IGFbMV0ueCxcbiAgICAgICAgICBjcDF5OiBhWzFdLnksXG4gICAgICAgICAgY3AyeDogYVsyXS54LFxuICAgICAgICAgIGNwMnk6IGFbMl0ueSxcbiAgICAgICAgICBjcDN4OiBhWzNdLngsXG4gICAgICAgICAgY3AzeTogYVszXS55XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcImN1YmljXCIsXG4gICAgICAgICAgbW92ZVRvOiBmYWxzZSxcbiAgICAgICAgICBjcDB4OiBiWzBdLngsXG4gICAgICAgICAgY3AweTogYlswXS55LFxuICAgICAgICAgIGNwMXg6IGJbMV0ueCxcbiAgICAgICAgICBjcDF5OiBiWzFdLnksXG4gICAgICAgICAgY3AyeDogYlsyXS54LFxuICAgICAgICAgIGNwMnk6IGJbMl0ueSxcbiAgICAgICAgICBjcDN4OiBiWzNdLngsXG4gICAgICAgICAgY3AzeTogYlszXS55XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjbGlwU3Bhblgoc3BhbiwgeDAsIHgxKSB7XG4gIGNvbnN0IHsgbW92ZVRvIH0gPSBzcGFuO1xuICBjb25zdCBbc3RhcnQsIGVuZF0gPSBzcGFuUmFuZ2Uoc3Bhbik7XG4gIGxldCBzcGFuWDA7XG4gIGxldCBzcGFuWTA7XG4gIGxldCBzcGFuWDE7XG4gIGxldCBzcGFuWTE7XG4gIGlmIChzdGFydC54IDwgZW5kLngpIHtcbiAgICBzcGFuWDAgPSBzdGFydC54O1xuICAgIHNwYW5ZMCA9IHN0YXJ0Lnk7XG4gICAgc3BhblgxID0gZW5kLng7XG4gICAgc3BhblkxID0gZW5kLnk7XG4gIH0gZWxzZSB7XG4gICAgc3BhblgwID0gZW5kLng7XG4gICAgc3BhblkwID0gZW5kLnk7XG4gICAgc3BhblgxID0gc3RhcnQueDtcbiAgICBzcGFuWTEgPSBzdGFydC55O1xuICB9XG4gIGlmICh4MSA8IHNwYW5YMCkge1xuICAgIHJldHVybiByZXNjYWxlU3BhbihzcGFuLCBzdGFydCwgc3RhcnQpO1xuICB9IGVsc2UgaWYgKHgwID4gc3BhblgxKSB7XG4gICAgcmV0dXJuIHJlc2NhbGVTcGFuKHNwYW4sIGVuZCwgZW5kKTtcbiAgfVxuICBzd2l0Y2ggKHNwYW4udHlwZSkge1xuICAgIGNhc2UgXCJsaW5lYXJcIjoge1xuICAgICAgY29uc3QgbSA9IHNwYW5ZMCA9PT0gc3BhblkxID8gdm9pZCAwIDogKHNwYW5ZMSAtIHNwYW5ZMCkgLyAoc3BhblgxIC0gc3BhblgwKTtcbiAgICAgIGNvbnN0IHkwID0gbSA9PSBudWxsID8gc3BhblkwIDogbSAqICh4MCAtIHNwYW5YMCkgKyBzcGFuWTA7XG4gICAgICBjb25zdCB5MSA9IG0gPT0gbnVsbCA/IHNwYW5ZMCA6IG0gKiAoeDEgLSBzcGFuWDApICsgc3BhblkwO1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJsaW5lYXJcIiwgbW92ZVRvLCB4MCwgeTAsIHgxLCB5MSB9O1xuICAgIH1cbiAgICBjYXNlIFwic3RlcFwiOlxuICAgICAgaWYgKHgxIDw9IHNwYW4uc3RlcFgpIHtcbiAgICAgICAgY29uc3QgeSA9IHNwYW4ueTA7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwic3RlcFwiLCBtb3ZlVG8sIHgwLCB5MDogeSwgeDEsIHkxOiB5LCBzdGVwWDogeDEgfTtcbiAgICAgIH0gZWxzZSBpZiAoeDAgPj0gc3Bhbi5zdGVwWCkge1xuICAgICAgICBjb25zdCB5ID0gc3Bhbi55MTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJzdGVwXCIsIG1vdmVUbywgeDAsIHkwOiB5LCB4MSwgeTE6IHksIHN0ZXBYOiB4MCB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyB5MCwgeTEsIHN0ZXBYIH0gPSBzcGFuO1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcInN0ZXBcIiwgbW92ZVRvLCB4MCwgeTAsIHgxLCB5MSwgc3RlcFggfTtcbiAgICAgIH1cbiAgICBjYXNlIFwiY3ViaWNcIjoge1xuICAgICAgY29uc3QgdDAgPSBzb2x2ZUJlemllcihzcGFuLmNwMHgsIHNwYW4uY3AxeCwgc3Bhbi5jcDJ4LCBzcGFuLmNwM3gsIHgwKTtcbiAgICAgIGxldCBbX3VudXNlZCwgYmV6aWVyXSA9IHNwbGl0QmV6aWVyKFxuICAgICAgICBzcGFuLmNwMHgsXG4gICAgICAgIHNwYW4uY3AweSxcbiAgICAgICAgc3Bhbi5jcDF4LFxuICAgICAgICBzcGFuLmNwMXksXG4gICAgICAgIHNwYW4uY3AyeCxcbiAgICAgICAgc3Bhbi5jcDJ5LFxuICAgICAgICBzcGFuLmNwM3gsXG4gICAgICAgIHNwYW4uY3AzeSxcbiAgICAgICAgdDBcbiAgICAgICk7XG4gICAgICBjb25zdCB0MSA9IHNvbHZlQmV6aWVyKGJlemllclswXS54LCBiZXppZXJbMV0ueCwgYmV6aWVyWzJdLngsIGJlemllclszXS54LCB4MSk7XG4gICAgICBbYmV6aWVyLCBfdW51c2VkXSA9IHNwbGl0QmV6aWVyKFxuICAgICAgICBiZXppZXJbMF0ueCxcbiAgICAgICAgYmV6aWVyWzBdLnksXG4gICAgICAgIGJlemllclsxXS54LFxuICAgICAgICBiZXppZXJbMV0ueSxcbiAgICAgICAgYmV6aWVyWzJdLngsXG4gICAgICAgIGJlemllclsyXS55LFxuICAgICAgICBiZXppZXJbM10ueCxcbiAgICAgICAgYmV6aWVyWzNdLnksXG4gICAgICAgIHQxXG4gICAgICApO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJjdWJpY1wiLFxuICAgICAgICBtb3ZlVG8sXG4gICAgICAgIGNwMHg6IGJlemllclswXS54LFxuICAgICAgICBjcDB5OiBiZXppZXJbMF0ueSxcbiAgICAgICAgY3AxeDogYmV6aWVyWzFdLngsXG4gICAgICAgIGNwMXk6IGJlemllclsxXS55LFxuICAgICAgICBjcDJ4OiBiZXppZXJbMl0ueCxcbiAgICAgICAgY3AyeTogYmV6aWVyWzJdLnksXG4gICAgICAgIGNwM3g6IGJlemllclszXS54LFxuICAgICAgICBjcDN5OiBiZXppZXJbM10ueVxuICAgICAgfTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlU3BhbnMoYSwgYiwgcmF0aW8yKSB7XG4gIGlmIChhLnR5cGUgPT09IFwiY3ViaWNcIiAmJiBiLnR5cGUgPT09IFwiY3ViaWNcIikge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImN1YmljXCIsXG4gICAgICBtb3ZlVG86IGEubW92ZVRvLFxuICAgICAgY3AweDogKGIuY3AweCAtIGEuY3AweCkgKiByYXRpbzIgKyBhLmNwMHgsXG4gICAgICBjcDB5OiAoYi5jcDB5IC0gYS5jcDB5KSAqIHJhdGlvMiArIGEuY3AweSxcbiAgICAgIGNwMXg6IChiLmNwMXggLSBhLmNwMXgpICogcmF0aW8yICsgYS5jcDF4LFxuICAgICAgY3AxeTogKGIuY3AxeSAtIGEuY3AxeSkgKiByYXRpbzIgKyBhLmNwMXksXG4gICAgICBjcDJ4OiAoYi5jcDJ4IC0gYS5jcDJ4KSAqIHJhdGlvMiArIGEuY3AyeCxcbiAgICAgIGNwMnk6IChiLmNwMnkgLSBhLmNwMnkpICogcmF0aW8yICsgYS5jcDJ5LFxuICAgICAgY3AzeDogKGIuY3AzeCAtIGEuY3AzeCkgKiByYXRpbzIgKyBhLmNwM3gsXG4gICAgICBjcDN5OiAoYi5jcDN5IC0gYS5jcDN5KSAqIHJhdGlvMiArIGEuY3AzeVxuICAgIH07XG4gIH0gZWxzZSBpZiAoYS50eXBlID09PSBcInN0ZXBcIiAmJiBiLnR5cGUgPT09IFwic3RlcFwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwic3RlcFwiLFxuICAgICAgbW92ZVRvOiBhLm1vdmVUbyxcbiAgICAgIHgwOiAoYi54MCAtIGEueDApICogcmF0aW8yICsgYS54MCxcbiAgICAgIHkwOiAoYi55MCAtIGEueTApICogcmF0aW8yICsgYS55MCxcbiAgICAgIHgxOiAoYi54MSAtIGEueDEpICogcmF0aW8yICsgYS54MSxcbiAgICAgIHkxOiAoYi55MSAtIGEueTEpICogcmF0aW8yICsgYS55MSxcbiAgICAgIHN0ZXBYOiAoYi5zdGVwWCAtIGEuc3RlcFgpICogcmF0aW8yICsgYS5zdGVwWFxuICAgIH07XG4gIH1cbiAgY29uc3QgW2FTdGFydCwgYUVuZF0gPSBzcGFuUmFuZ2UoYSk7XG4gIGNvbnN0IFtiU3RhcnQsIGJFbmRdID0gc3BhblJhbmdlKGIpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwibGluZWFyXCIsXG4gICAgbW92ZVRvOiBhLm1vdmVUbyxcbiAgICB4MDogKGJTdGFydC54IC0gYVN0YXJ0LngpICogcmF0aW8yICsgYVN0YXJ0LngsXG4gICAgeTA6IChiU3RhcnQueSAtIGFTdGFydC55KSAqIHJhdGlvMiArIGFTdGFydC55LFxuICAgIHgxOiAoYkVuZC54IC0gYUVuZC54KSAqIHJhdGlvMiArIGFFbmQueCxcbiAgICB5MTogKGJFbmQueSAtIGFFbmQueSkgKiByYXRpbzIgKyBhRW5kLnlcbiAgfTtcbn1cbmZ1bmN0aW9uIHBsb3RTcGFuKHBhdGgsIHNwYW4sIG1vdmVUbyA9IHNwYW4ubW92ZVRvID8gMSAvKiBNb3ZlVG8gKi8gOiAwIC8qIE5vbmUgKi8pIHtcbiAgY29uc3QgW3N0YXJ0XSA9IHNwYW5SYW5nZShzcGFuKTtcbiAgc3dpdGNoIChtb3ZlVG8pIHtcbiAgICBjYXNlIDEgLyogTW92ZVRvICovOlxuICAgICAgcGF0aC5tb3ZlVG8oc3RhcnQueCwgc3RhcnQueSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDIgLyogTGluZVRvICovOlxuICAgICAgcGF0aC5saW5lVG8oc3RhcnQueCwgc3RhcnQueSk7XG4gICAgICBicmVhaztcbiAgfVxuICBzd2l0Y2ggKHNwYW4udHlwZSkge1xuICAgIGNhc2UgXCJsaW5lYXJcIjpcbiAgICAgIHBhdGgubGluZVRvKHNwYW4ueDEsIHNwYW4ueTEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImN1YmljXCI6XG4gICAgICBwYXRoLmN1YmljQ3VydmVUbyhzcGFuLmNwMXgsIHNwYW4uY3AxeSwgc3Bhbi5jcDJ4LCBzcGFuLmNwMnksIHNwYW4uY3AzeCwgc3Bhbi5jcDN5KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJzdGVwXCI6XG4gICAgICBwYXRoLmxpbmVUbyhzcGFuLnN0ZXBYLCBzcGFuLnkwKTtcbiAgICAgIHBhdGgubGluZVRvKHNwYW4uc3RlcFgsIHNwYW4ueTEpO1xuICAgICAgcGF0aC5saW5lVG8oc3Bhbi54MSwgc3Bhbi55MSk7XG4gICAgICBicmVhaztcbiAgfVxufVxuZnVuY3Rpb24gbGluZWFyUG9pbnRzKHBvaW50cykge1xuICBjb25zdCBzcGFucyA9IFtdO1xuICBsZXQgaSA9IDA7XG4gIGxldCB4MCA9IE5hTjtcbiAgbGV0IHkwID0gTmFOO1xuICBmb3IgKGNvbnN0IHsgeDogeDEsIHk6IHkxIH0gb2YgcG9pbnRzKSB7XG4gICAgaWYgKGkgPiAwKSB7XG4gICAgICBjb25zdCBtb3ZlVG8gPSBpID09PSAxO1xuICAgICAgc3BhbnMucHVzaCh7IHR5cGU6IFwibGluZWFyXCIsIG1vdmVUbywgeDAsIHkwLCB4MSwgeTEgfSk7XG4gICAgfVxuICAgIGkgKz0gMTtcbiAgICB4MCA9IHgxO1xuICAgIHkwID0geTE7XG4gIH1cbiAgcmV0dXJuIHNwYW5zO1xufVxudmFyIGxpbmVTdGVwcyA9IHtcbiAgc3RhcnQ6IDAsXG4gIG1pZGRsZTogMC41LFxuICBlbmQ6IDFcbn07XG5mdW5jdGlvbiBzdGVwUG9pbnRzKHBvaW50cywgcG9zaXRpb24pIHtcbiAgY29uc3Qgc3BhbnMgPSBbXTtcbiAgbGV0IGkgPSAwO1xuICBsZXQgeDAgPSBOYU47XG4gIGxldCB5MCA9IE5hTjtcbiAgY29uc3QgcDAgPSB0eXBlb2YgcG9zaXRpb24gPT09IFwibnVtYmVyXCIgPyBwb3NpdGlvbiA6IGxpbmVTdGVwc1twb3NpdGlvbl07XG4gIGZvciAoY29uc3QgeyB4OiB4MSwgeTogeTEgfSBvZiBwb2ludHMpIHtcbiAgICBpZiAoaSA+IDApIHtcbiAgICAgIGNvbnN0IG1vdmVUbyA9IGkgPT09IDE7XG4gICAgICBjb25zdCBzdGVwWCA9IHgwICsgKHgxIC0geDApICogcDA7XG4gICAgICBzcGFucy5wdXNoKHsgdHlwZTogXCJzdGVwXCIsIG1vdmVUbywgeDAsIHkwLCB4MSwgeTEsIHN0ZXBYIH0pO1xuICAgIH1cbiAgICBpICs9IDE7XG4gICAgeDAgPSB4MTtcbiAgICB5MCA9IHkxO1xuICB9XG4gIHJldHVybiBzcGFucztcbn1cbnZhciBmbGF0bmVzc1JhdGlvID0gMC4wNTtcbmZ1bmN0aW9uIHNtb290aFBvaW50cyhpUG9pbnRzLCB0ZW5zaW9uKSB7XG4gIGNvbnN0IHBvaW50cyA9IEFycmF5LmlzQXJyYXkoaVBvaW50cykgPyBpUG9pbnRzIDogQXJyYXkuZnJvbShpUG9pbnRzKTtcbiAgaWYgKHBvaW50cy5sZW5ndGggPD0gMSlcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IGdyYWRpZW50cyA9IHBvaW50cy5tYXAoKGMsIGkpID0+IHtcbiAgICBjb25zdCBwID0gaSA9PT0gMCA/IGMgOiBwb2ludHNbaSAtIDFdO1xuICAgIGNvbnN0IG4gPSBpID09PSBwb2ludHMubGVuZ3RoIC0gMSA/IGMgOiBwb2ludHNbaSArIDFdO1xuICAgIGNvbnN0IGlzVGVybWluYWxQb2ludCA9IGkgPT09IDAgfHwgaSA9PT0gcG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgaWYgKE1hdGguc2lnbihwLnkgLSBjLnkpID09PSBNYXRoLnNpZ24obi55IC0gYy55KSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmICghaXNUZXJtaW5hbFBvaW50KSB7XG4gICAgICBjb25zdCByYW5nZTMgPSBNYXRoLmFicyhwLnkgLSBuLnkpO1xuICAgICAgY29uc3QgcHJldlJhdGlvID0gTWF0aC5hYnMoYy55IC0gcC55KSAvIHJhbmdlMztcbiAgICAgIGNvbnN0IG5leHRSYXRpbyA9IE1hdGguYWJzKGMueSAtIG4ueSkgLyByYW5nZTM7XG4gICAgICBpZiAocHJldlJhdGlvIDw9IGZsYXRuZXNzUmF0aW8gfHwgMSAtIHByZXZSYXRpbyA8PSBmbGF0bmVzc1JhdGlvIHx8IG5leHRSYXRpbyA8PSBmbGF0bmVzc1JhdGlvIHx8IDEgLSBuZXh0UmF0aW8gPD0gZmxhdG5lc3NSYXRpbykge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChuLnkgLSBwLnkpIC8gKG4ueCAtIHAueCk7XG4gIH0pO1xuICBpZiAoZ3JhZGllbnRzWzFdID09PSAwKSB7XG4gICAgZ3JhZGllbnRzWzBdICo9IDI7XG4gIH1cbiAgaWYgKGdyYWRpZW50c1tncmFkaWVudHMubGVuZ3RoIC0gMl0gPT09IDApIHtcbiAgICBncmFkaWVudHNbZ3JhZGllbnRzLmxlbmd0aCAtIDFdICo9IDI7XG4gIH1cbiAgY29uc3Qgc3BhbnMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCBwcmV2ID0gcG9pbnRzW2kgLSAxXTtcbiAgICBjb25zdCBwcmV2TSA9IGdyYWRpZW50c1tpIC0gMV07XG4gICAgY29uc3QgY3VyID0gcG9pbnRzW2ldO1xuICAgIGNvbnN0IGN1ck0gPSBncmFkaWVudHNbaV07XG4gICAgY29uc3QgZHggPSBjdXIueCAtIHByZXYueDtcbiAgICBjb25zdCBkeSA9IGN1ci55IC0gcHJldi55O1xuICAgIGxldCBkY3AxeCA9IGR4ICogdGVuc2lvbiAvIDM7XG4gICAgbGV0IGRjcDF5ID0gZHggKiBwcmV2TSAqIHRlbnNpb24gLyAzO1xuICAgIGxldCBkY3AyeCA9IGR4ICogdGVuc2lvbiAvIDM7XG4gICAgbGV0IGRjcDJ5ID0gZHggKiBjdXJNICogdGVuc2lvbiAvIDM7XG4gICAgaWYgKGN1ck0gPT09IDAgJiYgTWF0aC5hYnMoZGNwMXkpID4gTWF0aC5hYnMoZHkpKSB7XG4gICAgICBkY3AxeCAqPSBNYXRoLmFicyhkeSAvIGRjcDF5KTtcbiAgICAgIGRjcDF5ID0gTWF0aC5zaWduKGRjcDF5KSAqIE1hdGguYWJzKGR5KTtcbiAgICB9XG4gICAgaWYgKHByZXZNID09PSAwICYmIE1hdGguYWJzKGRjcDJ5KSA+IE1hdGguYWJzKGR5KSkge1xuICAgICAgZGNwMnggKj0gTWF0aC5hYnMoZHkgLyBkY3AyeSk7XG4gICAgICBkY3AyeSA9IE1hdGguc2lnbihkY3AyeSkgKiBNYXRoLmFicyhkeSk7XG4gICAgfVxuICAgIHNwYW5zLnB1c2goe1xuICAgICAgdHlwZTogXCJjdWJpY1wiLFxuICAgICAgbW92ZVRvOiBpID09PSAxLFxuICAgICAgY3AweDogcHJldi54LFxuICAgICAgY3AweTogcHJldi55LFxuICAgICAgY3AxeDogcHJldi54ICsgZGNwMXgsXG4gICAgICBjcDF5OiBwcmV2LnkgKyBkY3AxeSxcbiAgICAgIGNwMng6IGN1ci54IC0gZGNwMngsXG4gICAgICBjcDJ5OiBjdXIueSAtIGRjcDJ5LFxuICAgICAgY3AzeDogY3VyLngsXG4gICAgICBjcDN5OiBjdXIueVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzcGFucztcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9tYXJrZXJVdGlsLnRzXG5mdW5jdGlvbiBtYXJrZXJGYWRlSW5BbmltYXRpb24oeyBpZCB9LCBhbmltYXRpb25NYW5hZ2VyLCBzdGF0dXMsIC4uLm1hcmtlclNlbGVjdGlvbnMpIHtcbiAgY29uc3QgcGFyYW1zID0geyBwaGFzZTogc3RhdHVzID8gTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1tzdGF0dXNdIDogXCJ0cmFpbGluZ1wiIH07XG4gIHN0YXRpY0Zyb21Ub01vdGlvbihpZCwgXCJtYXJrZXJzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIG1hcmtlclNlbGVjdGlvbnMsIHsgb3BhY2l0eTogMCB9LCB7IG9wYWNpdHk6IDEgfSwgcGFyYW1zKTtcbiAgbWFya2VyU2VsZWN0aW9ucy5mb3JFYWNoKChzKSA9PiBzLmNsZWFudXAoKSk7XG59XG5mdW5jdGlvbiBtYXJrZXJTY2FsZUluQW5pbWF0aW9uKHsgaWQgfSwgYW5pbWF0aW9uTWFuYWdlciwgLi4ubWFya2VyU2VsZWN0aW9ucykge1xuICBzdGF0aWNGcm9tVG9Nb3Rpb24oXG4gICAgaWQsXG4gICAgXCJtYXJrZXJzXCIsXG4gICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICBtYXJrZXJTZWxlY3Rpb25zLFxuICAgIHsgc2NhbGluZ1g6IDAsIHNjYWxpbmdZOiAwIH0sXG4gICAgeyBzY2FsaW5nWDogMSwgc2NhbGluZ1k6IDEgfSxcbiAgICB7IHBoYXNlOiBcImluaXRpYWxcIiB9XG4gICk7XG4gIG1hcmtlclNlbGVjdGlvbnMuZm9yRWFjaCgocykgPT4gcy5jbGVhbnVwKCkpO1xufVxuZnVuY3Rpb24gbWFya2VyU3dpcGVTY2FsZUluQW5pbWF0aW9uKHsgaWQsIG5vZGVEYXRhRGVwZW5kZW5jaWVzIH0sIGFuaW1hdGlvbk1hbmFnZXIsIC4uLm1hcmtlclNlbGVjdGlvbnMpIHtcbiAgY29uc3Qgc2VyaWVzV2lkdGggPSBub2RlRGF0YURlcGVuZGVuY2llcy5zZXJpZXNSZWN0V2lkdGg7XG4gIGNvbnN0IGZyb21GbiA9IChfLCBkYXR1bSkgPT4ge1xuICAgIGNvbnN0IHggPSBkYXR1bS5taWRQb2ludD8ueCA/PyBzZXJpZXNXaWR0aDtcbiAgICBsZXQgZGVsYXkgPSBjbGFtcCgwLCBpbnZlcnNlRWFzZU91dCh4IC8gc2VyaWVzV2lkdGgpLCAxKTtcbiAgICBpZiAoaXNOYU4oZGVsYXkpKSB7XG4gICAgICBkZWxheSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB7IHNjYWxpbmdYOiAwLCBzY2FsaW5nWTogMCwgZGVsYXksIGR1cmF0aW9uOiBRVUlDS19UUkFOU0lUSU9OLCBwaGFzZTogXCJpbml0aWFsXCIgfTtcbiAgfTtcbiAgY29uc3QgdG9GbiA9ICgpID0+IHtcbiAgICByZXR1cm4geyBzY2FsaW5nWDogMSwgc2NhbGluZ1k6IDEgfTtcbiAgfTtcbiAgZnJvbVRvTW90aW9uKGlkLCBcIm1hcmtlcnNcIiwgYW5pbWF0aW9uTWFuYWdlciwgbWFya2VyU2VsZWN0aW9ucywgeyBmcm9tRm4sIHRvRm4gfSk7XG59XG5mdW5jdGlvbiByZXNldE1hcmtlckZuKF9ub2RlKSB7XG4gIHJldHVybiB7IG9wYWNpdHk6IDEsIHNjYWxpbmdYOiAxLCBzY2FsaW5nWTogMSB9O1xufVxuZnVuY3Rpb24gcmVzZXRNYXJrZXJQb3NpdGlvbkZuKF9ub2RlLCBkYXR1bSkge1xuICByZXR1cm4ge1xuICAgIHRyYW5zbGF0aW9uWDogZGF0dW0ucG9pbnQ/LnggPz8gTmFOLFxuICAgIHRyYW5zbGF0aW9uWTogZGF0dW0ucG9pbnQ/LnkgPz8gTmFOXG4gIH07XG59XG5mdW5jdGlvbiBwcmVwYXJlTWFya2VyQW5pbWF0aW9uKHBhaXJNYXAsIHBhcmVudFN0YXR1cykge1xuICBjb25zdCByZWFkRmlyc3RQYWlyID0gKHhWYWx1ZSwgdHlwZSkgPT4ge1xuICAgIGNvbnN0IHZhbCA9IHBhaXJNYXBbdHlwZV1beFZhbHVlXTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gdmFsWzBdIDogdmFsO1xuICB9O1xuICBjb25zdCBtYXJrZXJTdGF0dXMgPSAoZGF0dW0pID0+IHtcbiAgICBjb25zdCB7IHhWYWx1ZSB9ID0gZGF0dW07XG4gICAgaWYgKHBhaXJNYXAubW92ZWRbeFZhbHVlXSkge1xuICAgICAgcmV0dXJuIHsgcG9pbnQ6IHJlYWRGaXJzdFBhaXIoeFZhbHVlLCBcIm1vdmVkXCIpLCBzdGF0dXM6IFwidXBkYXRlZFwiIH07XG4gICAgfSBlbHNlIGlmIChwYWlyTWFwLnJlbW92ZWRbeFZhbHVlXSkge1xuICAgICAgcmV0dXJuIHsgcG9pbnQ6IHJlYWRGaXJzdFBhaXIoeFZhbHVlLCBcInJlbW92ZWRcIiksIHN0YXR1czogXCJyZW1vdmVkXCIgfTtcbiAgICB9IGVsc2UgaWYgKHBhaXJNYXAuYWRkZWRbeFZhbHVlXSkge1xuICAgICAgcmV0dXJuIHsgcG9pbnQ6IHJlYWRGaXJzdFBhaXIoeFZhbHVlLCBcImFkZGVkXCIpLCBzdGF0dXM6IFwiYWRkZWRcIiB9O1xuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IFwidW5rbm93blwiIH07XG4gIH07XG4gIGNvbnN0IGZyb21GbiA9IChtYXJrZXIsIGRhdHVtKSA9PiB7XG4gICAgY29uc3QgeyBzdGF0dXMsIHBvaW50IH0gPSBtYXJrZXJTdGF0dXMoZGF0dW0pO1xuICAgIGlmIChzdGF0dXMgPT09IFwidW5rbm93blwiKVxuICAgICAgcmV0dXJuIHsgb3BhY2l0eTogMCB9O1xuICAgIGNvbnN0IGRlZmF1bHRzID0ge1xuICAgICAgdHJhbnNsYXRpb25YOiBwb2ludD8uZnJvbT8ueCA/PyBtYXJrZXIudHJhbnNsYXRpb25YLFxuICAgICAgdHJhbnNsYXRpb25ZOiBwb2ludD8uZnJvbT8ueSA/PyBtYXJrZXIudHJhbnNsYXRpb25ZLFxuICAgICAgb3BhY2l0eTogbWFya2VyLm9wYWNpdHksXG4gICAgICBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1tzdGF0dXNdXG4gICAgfTtcbiAgICBpZiAocGFyZW50U3RhdHVzID09PSBcImFkZGVkXCIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmRlZmF1bHRzLFxuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICB0cmFuc2xhdGlvblg6IHBvaW50Py50bz8ueCxcbiAgICAgICAgdHJhbnNsYXRpb25ZOiBwb2ludD8udG8/LnksXG4gICAgICAgIHBoYXNlOiBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HW1wiYWRkZWRcIl1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IFwiYWRkZWRcIikge1xuICAgICAgZGVmYXVsdHMub3BhY2l0eSA9IDA7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0cztcbiAgfTtcbiAgY29uc3QgdG9GbiA9IChfbWFya2VyLCBkYXR1bSkgPT4ge1xuICAgIGNvbnN0IHsgc3RhdHVzLCBwb2ludCB9ID0gbWFya2VyU3RhdHVzKGRhdHVtKTtcbiAgICBpZiAoc3RhdHVzID09PSBcInVua25vd25cIilcbiAgICAgIHJldHVybiB7IG9wYWNpdHk6IDAgfTtcbiAgICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICAgIHRyYW5zbGF0aW9uWDogZGF0dW0ucG9pbnQueCxcbiAgICAgIHRyYW5zbGF0aW9uWTogZGF0dW0ucG9pbnQueSxcbiAgICAgIG9wYWNpdHk6IDEsXG4gICAgICBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1tzdGF0dXNdXG4gICAgfTtcbiAgICBpZiAoc3RhdHVzID09PSBcInJlbW92ZWRcIiB8fCBwYXJlbnRTdGF0dXMgPT09IFwicmVtb3ZlZFwiKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5kZWZhdWx0cyxcbiAgICAgICAgdHJhbnNsYXRpb25YOiBwb2ludD8udG8/LngsXG4gICAgICAgIHRyYW5zbGF0aW9uWTogcG9pbnQ/LnRvPy55LFxuICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1tcInJlbW92ZWRcIl1cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0cztcbiAgfTtcbiAgcmV0dXJuIHsgZnJvbUZuLCB0b0ZuIH07XG59XG5mdW5jdGlvbiBjb21wdXRlTWFya2VyRm9jdXNCb3VuZHMoc2VyaWVzLCB7IGRhdHVtSW5kZXggfSkge1xuICBjb25zdCBub2RlRGF0YSA9IHNlcmllcy5nZXROb2RlRGF0YSgpO1xuICBpZiAobm9kZURhdGEgPT09IHZvaWQgMClcbiAgICByZXR1cm4gdm9pZCAwO1xuICBjb25zdCBkYXR1bSA9IG5vZGVEYXRhW2RhdHVtSW5kZXhdO1xuICBpZiAoZGF0dW0gPT09IHZvaWQgMCB8fCBkYXR1bS5wb2ludCA9PT0gdm9pZCAwKVxuICAgIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IHNpemUgPSBzZXJpZXMuZ2V0Rm9ybWF0dGVkTWFya2VyU3R5bGUoZGF0dW0pLnNpemU7XG4gIGNvbnN0IHJhZGl1cyA9IHNpemUgLyAyO1xuICBjb25zdCB7IHgsIHkgfSA9IHNlcmllcy5jb250ZW50R3JvdXAuaW52ZXJzZVRyYW5zZm9ybVBvaW50KGRhdHVtLnBvaW50LnggLSByYWRpdXMsIGRhdHVtLnBvaW50LnkgLSByYWRpdXMpO1xuICByZXR1cm4gbmV3IEJCb3goeCwgeSwgc2l6ZSwgc2l6ZSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vbGluZVBsb3R0ZXIudHNcbmZ1bmN0aW9uIHBsb3RMaW5lYXJQb2ludHMocGF0aCwgcG9pbnRzLCBjb250aW51ZVBhdGgpIHtcbiAgbGV0IGRpZE1vdmUgPSBjb250aW51ZVBhdGg7XG4gIGZvciAoY29uc3QgeyB4LCB5IH0gb2YgcG9pbnRzKSB7XG4gICAgaWYgKGRpZE1vdmUpIHtcbiAgICAgIHBhdGgubGluZVRvKHgsIHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoLm1vdmVUbyh4LCB5KTtcbiAgICAgIGRpZE1vdmUgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxudmFyIGZsYXRuZXNzUmF0aW8yID0gMC4wNTtcbmZ1bmN0aW9uIHBsb3RTbW9vdGhQb2ludHMocGF0aCwgaVBvaW50cywgdGVuc2lvbiwgY29udGludWVQYXRoKSB7XG4gIGNvbnN0IHBvaW50cyA9IEFycmF5LmlzQXJyYXkoaVBvaW50cykgPyBpUG9pbnRzIDogQXJyYXkuZnJvbShpUG9pbnRzKTtcbiAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuO1xuICBpZiAoY29udGludWVQYXRoKSB7XG4gICAgcGF0aC5saW5lVG8ocG9pbnRzWzBdLngsIHBvaW50c1swXS55KTtcbiAgfSBlbHNlIHtcbiAgICBwYXRoLm1vdmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xuICB9XG4gIGlmIChwb2ludHMubGVuZ3RoIDw9IDEpXG4gICAgcmV0dXJuO1xuICBjb25zdCBncmFkaWVudHMgPSBwb2ludHMubWFwKChjLCBpKSA9PiB7XG4gICAgY29uc3QgcCA9IGkgPT09IDAgPyBjIDogcG9pbnRzW2kgLSAxXTtcbiAgICBjb25zdCBuID0gaSA9PT0gcG9pbnRzLmxlbmd0aCAtIDEgPyBjIDogcG9pbnRzW2kgKyAxXTtcbiAgICBjb25zdCBpc1Rlcm1pbmFsUG9pbnQgPSBpID09PSAwIHx8IGkgPT09IHBvaW50cy5sZW5ndGggLSAxO1xuICAgIGlmIChNYXRoLnNpZ24ocC55IC0gYy55KSA9PT0gTWF0aC5zaWduKG4ueSAtIGMueSkpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoIWlzVGVybWluYWxQb2ludCkge1xuICAgICAgY29uc3QgcmFuZ2UzID0gTWF0aC5hYnMocC55IC0gbi55KTtcbiAgICAgIGNvbnN0IHByZXZSYXRpbyA9IE1hdGguYWJzKGMueSAtIHAueSkgLyByYW5nZTM7XG4gICAgICBjb25zdCBuZXh0UmF0aW8gPSBNYXRoLmFicyhjLnkgLSBuLnkpIC8gcmFuZ2UzO1xuICAgICAgaWYgKHByZXZSYXRpbyA8PSBmbGF0bmVzc1JhdGlvMiB8fCAxIC0gcHJldlJhdGlvIDw9IGZsYXRuZXNzUmF0aW8yIHx8IG5leHRSYXRpbyA8PSBmbGF0bmVzc1JhdGlvMiB8fCAxIC0gbmV4dFJhdGlvIDw9IGZsYXRuZXNzUmF0aW8yKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKG4ueSAtIHAueSkgLyAobi54IC0gcC54KTtcbiAgfSk7XG4gIGlmIChncmFkaWVudHNbMV0gPT09IDApIHtcbiAgICBncmFkaWVudHNbMF0gKj0gMjtcbiAgfVxuICBpZiAoZ3JhZGllbnRzW2dyYWRpZW50cy5sZW5ndGggLSAyXSA9PT0gMCkge1xuICAgIGdyYWRpZW50c1tncmFkaWVudHMubGVuZ3RoIC0gMV0gKj0gMjtcbiAgfVxuICBmb3IgKGxldCBpID0gMTsgaSA8IHBvaW50cy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHByZXYgPSBwb2ludHNbaSAtIDFdO1xuICAgIGNvbnN0IHByZXZNID0gZ3JhZGllbnRzW2kgLSAxXTtcbiAgICBjb25zdCBjdXIgPSBwb2ludHNbaV07XG4gICAgY29uc3QgY3VyTSA9IGdyYWRpZW50c1tpXTtcbiAgICBjb25zdCBkeCA9IGN1ci54IC0gcHJldi54O1xuICAgIGNvbnN0IGR5ID0gY3VyLnkgLSBwcmV2Lnk7XG4gICAgbGV0IGRjcDF4ID0gZHggKiB0ZW5zaW9uIC8gMztcbiAgICBsZXQgZGNwMXkgPSBkeCAqIHByZXZNICogdGVuc2lvbiAvIDM7XG4gICAgbGV0IGRjcDJ4ID0gZHggKiB0ZW5zaW9uIC8gMztcbiAgICBsZXQgZGNwMnkgPSBkeCAqIGN1ck0gKiB0ZW5zaW9uIC8gMztcbiAgICBpZiAoY3VyTSA9PT0gMCAmJiBNYXRoLmFicyhkY3AxeSkgPiBNYXRoLmFicyhkeSkpIHtcbiAgICAgIGRjcDF4ICo9IE1hdGguYWJzKGR5IC8gZGNwMXkpO1xuICAgICAgZGNwMXkgPSBNYXRoLnNpZ24oZGNwMXkpICogTWF0aC5hYnMoZHkpO1xuICAgIH1cbiAgICBpZiAocHJldk0gPT09IDAgJiYgTWF0aC5hYnMoZGNwMnkpID4gTWF0aC5hYnMoZHkpKSB7XG4gICAgICBkY3AyeCAqPSBNYXRoLmFicyhkeSAvIGRjcDJ5KTtcbiAgICAgIGRjcDJ5ID0gTWF0aC5zaWduKGRjcDJ5KSAqIE1hdGguYWJzKGR5KTtcbiAgICB9XG4gICAgcGF0aC5jdWJpY0N1cnZlVG8ocHJldi54ICsgZGNwMXgsIHByZXYueSArIGRjcDF5LCBjdXIueCAtIGRjcDJ4LCBjdXIueSAtIGRjcDJ5LCBjdXIueCwgY3VyLnkpO1xuICB9XG59XG5mdW5jdGlvbiBwbG90U3RlcFBvaW50cyhwYXRoLCBwb2ludHMsIGFsaWduLCBjb250aW51ZVBhdGgpIHtcbiAgbGV0IGxhc3RQb2ludDtcbiAgZm9yIChjb25zdCBwb2ludCBvZiBwb2ludHMpIHtcbiAgICBpZiAobGFzdFBvaW50ICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbmFsQWxpZ24gPSBsYXN0UG9pbnQueCA8IHBvaW50LnggPyBhbGlnbiA6IDEgLSBhbGlnbjtcbiAgICAgIGNvbnN0IHggPSAocG9pbnQueCAtIGxhc3RQb2ludC54KSAqIGRpcmVjdGlvbmFsQWxpZ24gKyBsYXN0UG9pbnQueDtcbiAgICAgIHBhdGgubGluZVRvKHgsIGxhc3RQb2ludD8ueSA/PyBwb2ludC55KTtcbiAgICAgIHBhdGgubGluZVRvKHgsIHBvaW50LnkpO1xuICAgICAgcGF0aC5saW5lVG8ocG9pbnQueCwgcG9pbnQueSk7XG4gICAgfSBlbHNlIGlmIChjb250aW51ZVBhdGgpIHtcbiAgICAgIHBhdGgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoLm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICB9XG4gICAgbGFzdFBvaW50ID0gcG9pbnQ7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9wYXRoVXRpbC50c1xuZnVuY3Rpb24gbWluTWF4KG5vZGVEYXRhKSB7XG4gIHJldHVybiBub2RlRGF0YS5yZWR1Y2UoXG4gICAgKHsgbWluLCBtYXggfSwgbm9kZSkgPT4ge1xuICAgICAgaWYgKG1pbiA9PSBudWxsIHx8IG1pbi5wb2ludC54ID4gbm9kZS5wb2ludC54KSB7XG4gICAgICAgIG1pbiA9IG5vZGU7XG4gICAgICB9XG4gICAgICBpZiAobWF4ID09IG51bGwgfHwgbWF4LnBvaW50LnggPCBub2RlLnBvaW50LngpIHtcbiAgICAgICAgbWF4ID0gbm9kZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG1pbiwgbWF4IH07XG4gICAgfSxcbiAgICB7fVxuICApO1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uT25MaW5lKGEsIGIsIHRhcmdldFgpIHtcbiAgY29uc3QgbSA9IChiLnkgLSBhLnkpIC8gKGIueCAtIGEueCk7XG4gIGNvbnN0IHkgPSAodGFyZ2V0WCAtIGEueCkgKiBtICsgYS55O1xuICByZXR1cm4geyB4OiB0YXJnZXRYLCB5IH07XG59XG5mdW5jdGlvbiBiYWNrZmlsbFBhdGhQb2ludChyZXN1bHRzLCBwcm9jZXNzLCBza2lwLCBwcm9jZXNzRm4pIHtcbiAgbGV0IHByZXZNYXJrZXJJZHggPSAtMSwgbmV4dE1hcmtlcklkeCA9IDA7XG4gIGNvbnN0IHRvUHJvY2VzcyA9IFtdO1xuICB3aGlsZSAobmV4dE1hcmtlcklkeCA8IHJlc3VsdHMubGVuZ3RoKSB7XG4gICAgaWYgKHJlc3VsdHNbbmV4dE1hcmtlcklkeF0uY2hhbmdlID09PSBwcm9jZXNzKSB7XG4gICAgICB0b1Byb2Nlc3MucHVzaChyZXN1bHRzW25leHRNYXJrZXJJZHhdKTtcbiAgICAgIG5leHRNYXJrZXJJZHgrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocmVzdWx0c1tuZXh0TWFya2VySWR4XS5jaGFuZ2UgPT09IHNraXApIHtcbiAgICAgIG5leHRNYXJrZXJJZHgrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodG9Qcm9jZXNzLmxlbmd0aCA+IDApIHtcbiAgICAgIHByb2Nlc3NGbih0b1Byb2Nlc3MsIHByZXZNYXJrZXJJZHgsIG5leHRNYXJrZXJJZHgpO1xuICAgICAgdG9Qcm9jZXNzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHByZXZNYXJrZXJJZHggPSBuZXh0TWFya2VySWR4O1xuICAgIG5leHRNYXJrZXJJZHgrKztcbiAgfVxuICBpZiAodG9Qcm9jZXNzLmxlbmd0aCA+IDApIHtcbiAgICBwcm9jZXNzRm4odG9Qcm9jZXNzLCBwcmV2TWFya2VySWR4LCBuZXh0TWFya2VySWR4KTtcbiAgfVxufVxuZnVuY3Rpb24gYmFja2ZpbGxQYXRoUG9pbnREYXRhKHJlc3VsdCwgc3BsaXRNb2RlKSB7XG4gIGJhY2tmaWxsUGF0aFBvaW50KHJlc3VsdCwgXCJvdXRcIiwgXCJpblwiLCAodG9Qcm9jZXNzLCBzSWR4LCBlSWR4KSA9PiB7XG4gICAgaWYgKHNJZHggPT09IC0xICYmIHJlc3VsdFtlSWR4XSkge1xuICAgICAgdG9Qcm9jZXNzLmZvckVhY2goKGQpID0+IGQudG8gPSByZXN1bHRbZUlkeF0uZnJvbSk7XG4gICAgfSBlbHNlIGlmIChlSWR4ID09PSByZXN1bHQubGVuZ3RoICYmIHJlc3VsdFtzSWR4XSkge1xuICAgICAgdG9Qcm9jZXNzLmZvckVhY2goKGQpID0+IGQudG8gPSByZXN1bHRbc0lkeF0uZnJvbSk7XG4gICAgfSBlbHNlIGlmIChzcGxpdE1vZGUgPT09IFwiaW50ZXJzZWN0XCIgJiYgcmVzdWx0W3NJZHhdPy5mcm9tICYmIHJlc3VsdFtlSWR4XT8uZnJvbSkge1xuICAgICAgdG9Qcm9jZXNzLmZvckVhY2goKGQpID0+IGQudG8gPSBpbnRlcnNlY3Rpb25PbkxpbmUocmVzdWx0W3NJZHhdLmZyb20sIHJlc3VsdFtlSWR4XS5mcm9tLCBkLmZyb20ueCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b1Byb2Nlc3MuZm9yRWFjaCgoZCkgPT4gZC50byA9IGQuZnJvbSk7XG4gICAgfVxuICB9KTtcbiAgYmFja2ZpbGxQYXRoUG9pbnQocmVzdWx0LCBcImluXCIsIFwib3V0XCIsICh0b1Byb2Nlc3MsIHNJZHgsIGVJZHgpID0+IHtcbiAgICBpZiAoc0lkeCA9PT0gLTEgJiYgcmVzdWx0W2VJZHhdKSB7XG4gICAgICB0b1Byb2Nlc3MuZm9yRWFjaCgoZCkgPT4gZC5mcm9tID0gcmVzdWx0W2VJZHhdLnRvKTtcbiAgICB9IGVsc2UgaWYgKGVJZHggPT09IHJlc3VsdC5sZW5ndGggJiYgcmVzdWx0W3NJZHhdKSB7XG4gICAgICB0b1Byb2Nlc3MuZm9yRWFjaCgoZCkgPT4gZC5mcm9tID0gcmVzdWx0W3NJZHhdLnRvKTtcbiAgICB9IGVsc2UgaWYgKHNwbGl0TW9kZSA9PT0gXCJpbnRlcnNlY3RcIiAmJiByZXN1bHRbc0lkeF0/LnRvICYmIHJlc3VsdFtlSWR4XT8udG8pIHtcbiAgICAgIHRvUHJvY2Vzcy5mb3JFYWNoKChkKSA9PiBkLmZyb20gPSBpbnRlcnNlY3Rpb25PbkxpbmUocmVzdWx0W3NJZHhdLnRvLCByZXN1bHRbZUlkeF0udG8sIGQudG8ueCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b1Byb2Nlc3MuZm9yRWFjaCgoZCkgPT4gZC5mcm9tID0gZC50byk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZVBvaW50KGZyb20yLCB0bywgcmF0aW8yKSB7XG4gIGNvbnN0IHgxID0gaXNOYU4oZnJvbTIueCkgPyB0by54IDogZnJvbTIueDtcbiAgY29uc3QgeTEgPSBpc05hTihmcm9tMi55KSA/IHRvLnkgOiBmcm9tMi55O1xuICBjb25zdCB4ZCA9IHRvLnggLSBmcm9tMi54O1xuICBjb25zdCB5ZCA9IHRvLnkgLSBmcm9tMi55O1xuICBjb25zdCB4ciA9IGlzTmFOKHhkKSA/IDAgOiB4ZCAqIHJhdGlvMjtcbiAgY29uc3QgeXIgPSBpc05hTih5ZCkgPyAwIDogeWQgKiByYXRpbzI7XG4gIHJldHVybiB7XG4gICAgeDogeDEgKyB4cixcbiAgICB5OiB5MSArIHlyXG4gIH07XG59XG52YXIgbGluZVN0ZXBzMiA9IHtcbiAgc3RhcnQ6IDAsXG4gIG1pZGRsZTogMC41LFxuICBlbmQ6IDFcbn07XG5mdW5jdGlvbiBwbG90UGF0aChwb2ludHMsIHBhdGgsIGludGVycG9sYXRpb24sIGNvbnRpbnVlUGF0aCA9IGZhbHNlKSB7XG4gIGNvbnN0IHsgcGF0aDogbGluZVBhdGggfSA9IHBhdGg7XG4gIGlmIChpbnRlcnBvbGF0aW9uPy50eXBlID09PSBcInNtb290aFwiKSB7XG4gICAgcGxvdFNtb290aFBvaW50cyhsaW5lUGF0aCwgcG9pbnRzLCBpbnRlcnBvbGF0aW9uLnRlbnNpb24gPz8gMSwgY29udGludWVQYXRoKTtcbiAgfSBlbHNlIGlmIChpbnRlcnBvbGF0aW9uPy50eXBlID09PSBcInN0ZXBcIikge1xuICAgIHBsb3RTdGVwUG9pbnRzKGxpbmVQYXRoLCBwb2ludHMsIGxpbmVTdGVwczJbaW50ZXJwb2xhdGlvbi5wb3NpdGlvbiA/PyBcImVuZFwiXSwgY29udGludWVQYXRoKTtcbiAgfSBlbHNlIHtcbiAgICBwbG90TGluZWFyUG9pbnRzKGxpbmVQYXRoLCBwb2ludHMsIGNvbnRpbnVlUGF0aCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNwbGl0UGFpckRhdGEocGFpckRhdGEsIHJhdGlvcykge1xuICBsZXQgcHJldmlvdXNUbztcbiAgbGV0IHBvaW50cyA9IHZvaWQgMDtcbiAgY29uc3Qgb3V0ID0gW107XG4gIGNvbnN0IGZsdXNoQ3VycmVudCA9ICgpID0+IHtcbiAgICBpZiAocG9pbnRzICE9IG51bGwpIHtcbiAgICAgIG91dC5wdXNoKHBvaW50cyk7XG4gICAgICBwb2ludHMgPSB2b2lkIDA7XG4gICAgfVxuICB9O1xuICBmb3IgKGNvbnN0IGRhdGEgb2YgcGFpckRhdGEpIHtcbiAgICBjb25zdCB7IGZyb206IGZyb20yLCB0byB9ID0gZGF0YTtcbiAgICBjb25zdCByYXRpbzIgPSByYXRpb3NbZGF0YS5jaGFuZ2VdO1xuICAgIGlmIChyYXRpbzIgPT0gbnVsbCB8fCBmcm9tMiA9PSBudWxsIHx8IHRvID09IG51bGwpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBwb2ludCA9IGNhbGN1bGF0ZVBvaW50KGZyb20yLCB0bywgcmF0aW8yKTtcbiAgICBpZiAoZGF0YS5tb3ZlVG8gPT09IGZhbHNlKSB7XG4gICAgICBwb2ludHMgPz8gKHBvaW50cyA9IFtdKTtcbiAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICB9IGVsc2UgaWYgKGRhdGEubW92ZVRvID09PSB0cnVlIHx8ICFwcmV2aW91c1RvKSB7XG4gICAgICBmbHVzaEN1cnJlbnQoKTtcbiAgICAgIHBvaW50cyA9IFtwb2ludF07XG4gICAgfSBlbHNlIGlmIChwcmV2aW91c1RvKSB7XG4gICAgICBjb25zdCBtb3ZlVG9SYXRpbyA9IGRhdGEubW92ZVRvID09PSBcImluXCIgPyByYXRpbzIgOiAxIC0gcmF0aW8yO1xuICAgICAgY29uc3QgeyB4OiBtaWRQb2ludFgsIHk6IG1pZFBvaW50WSB9ID0gY2FsY3VsYXRlUG9pbnQocHJldmlvdXNUbywgcG9pbnQsIG1vdmVUb1JhdGlvKTtcbiAgICAgIHBvaW50cyA/PyAocG9pbnRzID0gW10pO1xuICAgICAgcG9pbnRzLnB1c2goeyB4OiBtaWRQb2ludFgsIHk6IG1pZFBvaW50WSB9KTtcbiAgICAgIGZsdXNoQ3VycmVudCgpO1xuICAgICAgcG9pbnRzID0gW3BvaW50XTtcbiAgICB9XG4gICAgcHJldmlvdXNUbyA9IHBvaW50O1xuICB9XG4gIGZsdXNoQ3VycmVudCgpO1xuICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gcmVuZGVyUGFydGlhbFBhdGgocGFpckRhdGEsIHJhdGlvcywgcGF0aCwgaW50ZXJwb2xhdGlvbikge1xuICBzcGxpdFBhaXJEYXRhKHBhaXJEYXRhLCByYXRpb3MpLmZvckVhY2goKHBvaW50cykgPT4ge1xuICAgIHBsb3RQYXRoKHBvaW50cywgcGF0aCwgaW50ZXJwb2xhdGlvbik7XG4gIH0pO1xufVxuZnVuY3Rpb24gcGF0aFN3aXBlSW5BbmltYXRpb24oeyBpZCwgdmlzaWJsZSwgbm9kZURhdGFEZXBlbmRlbmNpZXMgfSwgYW5pbWF0aW9uTWFuYWdlciwgLi4ucGF0aHMpIHtcbiAgY29uc3QgeyBzZXJpZXNSZWN0V2lkdGg6IHdpZHRoLCBzZXJpZXNSZWN0SGVpZ2h0OiBoZWlnaHQgfSA9IG5vZGVEYXRhRGVwZW5kZW5jaWVzO1xuICBzdGF0aWNGcm9tVG9Nb3Rpb24oXG4gICAgaWQsXG4gICAgXCJwYXRoX3Byb3BlcnRpZXNcIixcbiAgICBhbmltYXRpb25NYW5hZ2VyLFxuICAgIHBhdGhzLFxuICAgIHsgY2xpcFg6IDAgfSxcbiAgICB7IGNsaXBYOiB3aWR0aCB9LFxuICAgIHtcbiAgICAgIHBoYXNlOiBcImluaXRpYWxcIixcbiAgICAgIHN0YXJ0OiB7IGNsaXBNb2RlOiBcIm5vcm1hbFwiLCBjbGlwWTogaGVpZ2h0LCB2aXNpYmxlIH0sXG4gICAgICBmaW5pc2g6IHsgY2xpcE1vZGU6IHZvaWQgMCwgdmlzaWJsZSB9XG4gICAgfVxuICApO1xufVxuZnVuY3Rpb24gcGF0aEZhZGVJbkFuaW1hdGlvbih7IGlkIH0sIHN1YklkLCBhbmltYXRpb25NYW5hZ2VyLCBwaGFzZSA9IFwiYWRkXCIsIC4uLnNlbGVjdGlvbikge1xuICBzdGF0aWNGcm9tVG9Nb3Rpb24oaWQsIHN1YklkLCBhbmltYXRpb25NYW5hZ2VyLCBzZWxlY3Rpb24sIHsgb3BhY2l0eTogMCB9LCB7IG9wYWNpdHk6IDEgfSwgeyBwaGFzZSB9KTtcbn1cbmZ1bmN0aW9uIHBhdGhGYWRlT3V0QW5pbWF0aW9uKHsgaWQgfSwgc3ViSWQsIGFuaW1hdGlvbk1hbmFnZXIsIC4uLnNlbGVjdGlvbikge1xuICBzdGF0aWNGcm9tVG9Nb3Rpb24oaWQsIHN1YklkLCBhbmltYXRpb25NYW5hZ2VyLCBzZWxlY3Rpb24sIHsgb3BhY2l0eTogMSB9LCB7IG9wYWNpdHk6IDAgfSwgeyBwaGFzZTogXCJyZW1vdmVcIiB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUmVzZXRQYXRoRm4ob3B0cykge1xuICByZXR1cm4gKF9ub2RlKSA9PiB7XG4gICAgcmV0dXJuIHsgdmlzaWJsZTogb3B0cy5nZXRWaXNpYmxlKCksIG9wYWNpdHk6IG9wdHMuZ2V0T3BhY2l0eSgpLCBjbGlwU2NhbGluZ1g6IDEsIGNsaXBNb2RlOiB2b2lkIDAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNsaXBQYXRoKHsgbm9kZURhdGFEZXBlbmRlbmNpZXMgfSwgcGF0aCkge1xuICBjb25zdCB0b0Zpbml0ZSA9ICh2YWx1ZSkgPT4gaXNGaW5pdGUodmFsdWUpID8gdmFsdWUgOiAwO1xuICBwYXRoLmNsaXBYID0gdG9GaW5pdGUobm9kZURhdGFEZXBlbmRlbmNpZXMuc2VyaWVzUmVjdFdpZHRoKTtcbiAgcGF0aC5jbGlwWSA9IHRvRmluaXRlKG5vZGVEYXRhRGVwZW5kZW5jaWVzLnNlcmllc1JlY3RIZWlnaHQpO1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL3NjYWxpbmcudHNcbmZ1bmN0aW9uIGlzQ29udGludW91c1NjYWxpbmcoc2NhbGluZykge1xuICByZXR1cm4gc2NhbGluZy50eXBlID09PSBcImNvbnRpbnVvdXNcIiB8fCBzY2FsaW5nLnR5cGUgPT09IFwibG9nXCI7XG59XG5mdW5jdGlvbiBpc0NhdGVnb3J5U2NhbGluZyhzY2FsaW5nKSB7XG4gIHJldHVybiBzY2FsaW5nLnR5cGUgPT09IFwiY2F0ZWdvcnlcIjtcbn1cbmZ1bmN0aW9uIGFyZUVxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEuZG9tYWluLmxlbmd0aCA9PT0gYi5kb21haW4ubGVuZ3RoICYmIGEucmFuZ2UubGVuZ3RoID09PSBiLnJhbmdlLmxlbmd0aCAmJiBhLmRvbWFpbi5ldmVyeSgodmFsLCBpbmRleCkgPT4gdmFsID09PSBiLmRvbWFpbltpbmRleF0pICYmIGEucmFuZ2UuZXZlcnkoKHZhbCwgaW5kZXgpID0+IHZhbCA9PT0gYi5yYW5nZVtpbmRleF0pO1xufVxuZnVuY3Rpb24gYXJlU2NhbGluZ0VxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IHZvaWQgMCB8fCBiID09PSB2b2lkIDApIHtcbiAgICByZXR1cm4gYSAhPT0gdm9pZCAwIHx8IGIgIT09IHZvaWQgMDtcbiAgfVxuICBpZiAoaXNDb250aW51b3VzU2NhbGluZyhhKSAmJiBpc0NvbnRpbnVvdXNTY2FsaW5nKGIpKSB7XG4gICAgcmV0dXJuIGEudHlwZSA9PT0gYi50eXBlICYmIGFyZUVxdWFsKGEsIGIpO1xuICB9XG4gIGlmIChpc0NhdGVnb3J5U2NhbGluZyhhKSAmJiBpc0NhdGVnb3J5U2NhbGluZyhiKSkge1xuICAgIHJldHVybiBhcmVFcXVhbChhLCBiKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1NjYWxlVmFsaWQoc2NhbGUyKSB7XG4gIGlmIChzY2FsZTIgPT0gbnVsbClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmICghc2NhbGUyLnJhbmdlLmV2ZXJ5KCh2KSA9PiBOdW1iZXIuaXNGaW5pdGUodikpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHNjYWxlMi50eXBlID09PSBcImNhdGVnb3J5XCIpIHtcbiAgICByZXR1cm4gc2NhbGUyLmRvbWFpbi5ldmVyeSgodikgPT4gdiAhPSBudWxsKTtcbiAgfVxuICByZXR1cm4gc2NhbGUyLmRvbWFpbi5ldmVyeSgodikgPT4gTnVtYmVyLmlzRmluaXRlKHYpIHx8IHYgaW5zdGFuY2VvZiBEYXRlKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9saW5lVXRpbC50c1xuZnVuY3Rpb24qIHBhdGhSYW5nZXMocG9pbnRzKSB7XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gMDtcbiAgZm9yIChjb25zdCB7IHBvaW50IH0gb2YgcG9pbnRzKSB7XG4gICAgaWYgKHBvaW50Lm1vdmVUbykge1xuICAgICAgY29uc3QgcmFuZ2UzID0gc3RhcnQgPj0gMCA/IHsgc3RhcnQsIGVuZCB9IDogdm9pZCAwO1xuICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICAgIGlmIChyYW5nZTMgIT09IHZvaWQgMCkge1xuICAgICAgICB5aWVsZCByYW5nZTM7XG4gICAgICB9XG4gICAgfVxuICAgIGVuZCArPSAxO1xuICB9XG4gIGlmIChzdGFydCAhPT0gLTEpIHtcbiAgICB5aWVsZCB7IHN0YXJ0LCBlbmQgfTtcbiAgfVxufVxuZnVuY3Rpb24qIHBhdGhSYW5nZVBvaW50cyhwb2ludHMsIHsgc3RhcnQsIGVuZCB9KSB7XG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAxKSB7XG4gICAgeWllbGQgcG9pbnRzW2ldLnBvaW50O1xuICB9XG59XG5mdW5jdGlvbiogcGF0aFJhbmdlUG9pbnRzUmV2ZXJzZShwb2ludHMsIHsgc3RhcnQsIGVuZCB9KSB7XG4gIGZvciAobGV0IGkgPSBlbmQgLSAxOyBpID49IHN0YXJ0OyBpIC09IDEpIHtcbiAgICB5aWVsZCBwb2ludHNbaV0ucG9pbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVncmF0ZWRDYXRlZ29yeU1hdGNoKGEsIGIpIHtcbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIGEgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGIgIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAoXCJpZFwiIGluIGEgJiYgXCJpZFwiIGluIGIpIHtcbiAgICByZXR1cm4gYS5pZCA9PT0gYi5pZDtcbiAgfVxuICByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBzY2FsZSh2YWwsIHNjYWxpbmcpIHtcbiAgaWYgKCFzY2FsaW5nKVxuICAgIHJldHVybiBOYU47XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgdmFsID0gdmFsLmdldFRpbWUoKTtcbiAgfVxuICBpZiAoc2NhbGluZy50eXBlID09PSBcImNvbnRpbnVvdXNcIiAmJiB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiKSB7XG4gICAgY29uc3QgZG9tYWluUmF0aW8gPSAodmFsIC0gc2NhbGluZy5kb21haW5bMF0pIC8gKHNjYWxpbmcuZG9tYWluWzFdIC0gc2NhbGluZy5kb21haW5bMF0pO1xuICAgIHJldHVybiBkb21haW5SYXRpbyAqIChzY2FsaW5nLnJhbmdlWzFdIC0gc2NhbGluZy5yYW5nZVswXSkgKyBzY2FsaW5nLnJhbmdlWzBdO1xuICB9XG4gIGlmIChzY2FsaW5nLnR5cGUgPT09IFwibG9nXCIgJiYgdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgIHJldHVybiBzY2FsaW5nLmNvbnZlcnQodmFsKTtcbiAgfVxuICBjb25zdCBtYXRjaGluZ0luZGV4ID0gc2NhbGluZy5kb21haW4uZmluZEluZGV4KChkKSA9PiBkID09PSB2YWwpO1xuICBpZiAobWF0Y2hpbmdJbmRleCA+PSAwKSB7XG4gICAgcmV0dXJuIHNjYWxpbmcucmFuZ2VbbWF0Y2hpbmdJbmRleF07XG4gIH1cbiAgY29uc3QgbWF0Y2hpbmdJbnRlZ3JhdGVkSW5kZXggPSBzY2FsaW5nLmRvbWFpbi5maW5kSW5kZXgoKGQpID0+IGludGVncmF0ZWRDYXRlZ29yeU1hdGNoKHZhbCwgZCkpO1xuICBpZiAobWF0Y2hpbmdJbnRlZ3JhdGVkSW5kZXggPj0gMCkge1xuICAgIHJldHVybiBzY2FsaW5nLnJhbmdlW21hdGNoaW5nSW50ZWdyYXRlZEluZGV4XTtcbiAgfVxuICByZXR1cm4gTmFOO1xufVxuZnVuY3Rpb24gc2NhbGVzQ2hhbmdlZChuZXdEYXRhLCBvbGREYXRhKSB7XG4gIHJldHVybiAhYXJlU2NhbGluZ0VxdWFsKG5ld0RhdGEuc2NhbGVzLngsIG9sZERhdGEuc2NhbGVzLngpIHx8ICFhcmVTY2FsaW5nRXF1YWwobmV3RGF0YS5zY2FsZXMueSwgb2xkRGF0YS5zY2FsZXMueSk7XG59XG5mdW5jdGlvbiBjbG9zZU1hdGNoKGEsIGIpIHtcbiAgY29uc3QgYW4gPSBOdW1iZXIoYSk7XG4gIGNvbnN0IGJuID0gTnVtYmVyKGIpO1xuICBpZiAoIWlzTmFOKGFuKSAmJiAhaXNOYU4oYm4pKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKGJuIC0gYW4pIDwgMC4yNTtcbiAgfVxuICByZXR1cm4gYSA9PT0gYjtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZU1vdmVUbyhmcm9tMiA9IGZhbHNlLCB0byA9IGZhbHNlKSB7XG4gIGlmIChmcm9tMiA9PT0gdG8pIHtcbiAgICByZXR1cm4gQm9vbGVhbihmcm9tMik7XG4gIH1cbiAgcmV0dXJuIGZyb20yID8gXCJpblwiIDogXCJvdXRcIjtcbn1cbmZ1bmN0aW9uIHBhaXJDb250aW51b3VzRGF0YShuZXdEYXRhLCBvbGREYXRhLCBvcHRzID0ge30pIHtcbiAgY29uc3QgeyBiYWNrZmlsbFNwbGl0TW9kZSA9IFwiaW50ZXJzZWN0XCIgfSA9IG9wdHM7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCByZXN1bHRNYXAgPSB7XG4gICAgYWRkZWQ6IHt9LFxuICAgIG1vdmVkOiB7fSxcbiAgICByZW1vdmVkOiB7fVxuICB9O1xuICBjb25zdCBwYWlyVXAgPSAoZnJvbTIsIHRvLCB4VmFsdWUsIGNoYW5nZSA9IFwibW92ZVwiKSA9PiB7XG4gICAgaWYgKGZyb20yICYmIChpc05hTihmcm9tMi5wb2ludC54KSB8fCBpc05hTihmcm9tMi5wb2ludC55KSkpIHtcbiAgICAgIGZyb20yID0gdG87XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdFBvaW50ID0ge1xuICAgICAgZnJvbTogZnJvbTI/LnBvaW50LFxuICAgICAgdG86IHRvPy5wb2ludCxcbiAgICAgIG1vdmVUbzogY2FsY3VsYXRlTW92ZVRvKGZyb20yPy5wb2ludC5tb3ZlVG8sIHRvPy5wb2ludC5tb3ZlVG8pLFxuICAgICAgY2hhbmdlXG4gICAgfTtcbiAgICBpZiAoY2hhbmdlID09PSBcIm1vdmVcIikge1xuICAgICAgcmVzdWx0TWFwLm1vdmVkW3hWYWx1ZV0gPSByZXN1bHRQb2ludDtcbiAgICAgIG9sZElkeCsrO1xuICAgICAgbmV3SWR4Kys7XG4gICAgfSBlbHNlIGlmIChjaGFuZ2UgPT09IFwiaW5cIikge1xuICAgICAgcmVzdWx0TWFwLmFkZGVkW3hWYWx1ZV0gPSByZXN1bHRQb2ludDtcbiAgICAgIG5ld0lkeCsrO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlID09PSBcIm91dFwiKSB7XG4gICAgICByZXN1bHRNYXAucmVtb3ZlZFt4VmFsdWVdID0gcmVzdWx0UG9pbnQ7XG4gICAgICBvbGRJZHgrKztcbiAgICB9XG4gICAgcmVzdWx0LnB1c2gocmVzdWx0UG9pbnQpO1xuICB9O1xuICBjb25zdCB7IG1pbjogbWluRnJvbU5vZGUsIG1heDogbWF4RnJvbU5vZGUgfSA9IG1pbk1heChvbGREYXRhLm5vZGVEYXRhKTtcbiAgY29uc3QgeyBtaW46IG1pblRvTm9kZSwgbWF4OiBtYXhUb05vZGUgfSA9IG1pbk1heChuZXdEYXRhLm5vZGVEYXRhKTtcbiAgbGV0IG9sZElkeCA9IDA7XG4gIGxldCBuZXdJZHggPSAwO1xuICB3aGlsZSAob2xkSWR4IDwgb2xkRGF0YS5ub2RlRGF0YS5sZW5ndGggfHwgbmV3SWR4IDwgbmV3RGF0YS5ub2RlRGF0YS5sZW5ndGgpIHtcbiAgICBjb25zdCBmcm9tMiA9IG9sZERhdGEubm9kZURhdGFbb2xkSWR4XTtcbiAgICBjb25zdCB0byA9IG5ld0RhdGEubm9kZURhdGFbbmV3SWR4XTtcbiAgICBjb25zdCBmcm9tU2hpZnRlZCA9IGZyb20yID8gc2NhbGUoZnJvbTIueFZhbHVlID8/IE5hTiwgbmV3RGF0YS5zY2FsZXMueCkgOiB2b2lkIDA7XG4gICAgY29uc3QgdG9VbnNoaWZ0ZWQgPSB0byA/IHNjYWxlKHRvLnhWYWx1ZSA/PyBOYU4sIG9sZERhdGEuc2NhbGVzLngpIDogdm9pZCAwO1xuICAgIGNvbnN0IE5BID0gdm9pZCAwO1xuICAgIGlmIChmcm9tU2hpZnRlZCAhPSBudWxsICYmIGNsb3NlTWF0Y2goZnJvbVNoaWZ0ZWQsIHRvPy5wb2ludC54KSkge1xuICAgICAgcGFpclVwKGZyb20yLCB0bywgdG8ueFZhbHVlLCBcIm1vdmVcIik7XG4gICAgfSBlbHNlIGlmIChmcm9tU2hpZnRlZCAhPSBudWxsICYmIGZyb21TaGlmdGVkIDwgKG1pblRvTm9kZT8ucG9pbnQueCA/PyAtSW5maW5pdHkpKSB7XG4gICAgICBwYWlyVXAoZnJvbTIsIE5BLCBmcm9tMi54VmFsdWUsIFwib3V0XCIpO1xuICAgIH0gZWxzZSBpZiAoZnJvbVNoaWZ0ZWQgIT0gbnVsbCAmJiBmcm9tU2hpZnRlZCA+IChtYXhUb05vZGU/LnBvaW50LnggPz8gSW5maW5pdHkpKSB7XG4gICAgICBwYWlyVXAoZnJvbTIsIE5BLCBmcm9tMi54VmFsdWUsIFwib3V0XCIpO1xuICAgIH0gZWxzZSBpZiAodG9VbnNoaWZ0ZWQgIT0gbnVsbCAmJiB0b1Vuc2hpZnRlZCA8IChtaW5Gcm9tTm9kZT8ucG9pbnQueCA/PyAtSW5maW5pdHkpKSB7XG4gICAgICBwYWlyVXAoTkEsIHRvLCB0by54VmFsdWUsIFwiaW5cIik7XG4gICAgfSBlbHNlIGlmICh0b1Vuc2hpZnRlZCAhPSBudWxsICYmIHRvVW5zaGlmdGVkID4gKG1heEZyb21Ob2RlPy5wb2ludC54ID8/IEluZmluaXR5KSkge1xuICAgICAgcGFpclVwKE5BLCB0bywgdG8ueFZhbHVlLCBcImluXCIpO1xuICAgIH0gZWxzZSBpZiAoZnJvbVNoaWZ0ZWQgIT0gbnVsbCAmJiBmcm9tU2hpZnRlZCA8IHRvPy5wb2ludC54KSB7XG4gICAgICBwYWlyVXAoZnJvbTIsIE5BLCBmcm9tMi54VmFsdWUsIFwib3V0XCIpO1xuICAgIH0gZWxzZSBpZiAodG9VbnNoaWZ0ZWQgIT0gbnVsbCAmJiB0b1Vuc2hpZnRlZCA8IGZyb20yPy5wb2ludC54KSB7XG4gICAgICBwYWlyVXAoTkEsIHRvLCB0by54VmFsdWUsIFwiaW5cIik7XG4gICAgfSBlbHNlIGlmIChmcm9tMikge1xuICAgICAgcGFpclVwKGZyb20yLCBOQSwgZnJvbTIueFZhbHVlLCBcIm91dFwiKTtcbiAgICB9IGVsc2UgaWYgKHRvKSB7XG4gICAgICBwYWlyVXAoTkEsIHRvLCB0by54VmFsdWUsIFwiaW5cIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBwcm9jZXNzIHBvaW50c1wiKTtcbiAgICB9XG4gIH1cbiAgYmFja2ZpbGxQYXRoUG9pbnREYXRhKHJlc3VsdCwgYmFja2ZpbGxTcGxpdE1vZGUpO1xuICByZXR1cm4geyByZXN1bHQsIHJlc3VsdE1hcCB9O1xufVxuZnVuY3Rpb24gcGFpckNhdGVnb3J5RGF0YShuZXdEYXRhLCBvbGREYXRhLCBkaWZmMiwgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHsgYmFja2ZpbGxTcGxpdE1vZGUgPSBcImludGVyc2VjdFwiLCBtdWx0aURhdHVtID0gZmFsc2UgfSA9IG9wdHM7XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBjb25zdCByZXN1bHRNYXBTaW5nbGUgPSB7XG4gICAgYWRkZWQ6IHt9LFxuICAgIG1vdmVkOiB7fSxcbiAgICByZW1vdmVkOiB7fVxuICB9O1xuICBjb25zdCByZXN1bHRNYXBNdWx0aSA9IHtcbiAgICBhZGRlZDoge30sXG4gICAgbW92ZWQ6IHt9LFxuICAgIHJlbW92ZWQ6IHt9XG4gIH07XG4gIGNvbnN0IHBvaW50UmVzdWx0TWFwcGluZyA9IHtcbiAgICBpbjogXCJhZGRlZFwiLFxuICAgIG1vdmU6IFwibW92ZWRcIixcbiAgICBvdXQ6IFwicmVtb3ZlZFwiXG4gIH07XG4gIGxldCBwcmV2aW91c1Jlc3VsdFBvaW50ID0gdm9pZCAwO1xuICBsZXQgcHJldmlvdXNYVmFsdWUgPSB2b2lkIDA7XG4gIGNvbnN0IGFkZFRvUmVzdWx0TWFwID0gKHhWYWx1ZSwgbmV3UG9pbnQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdHlwZSA9IHBvaW50UmVzdWx0TWFwcGluZ1tuZXdQb2ludC5jaGFuZ2VdO1xuICAgIGlmIChtdWx0aURhdHVtKSB7XG4gICAgICAoX2EgPSByZXN1bHRNYXBNdWx0aVt0eXBlXSlbeFZhbHVlXSA/PyAoX2FbeFZhbHVlXSA9IFtdKTtcbiAgICAgIHJlc3VsdE1hcE11bHRpW3R5cGVdW3hWYWx1ZV0ucHVzaChuZXdQb2ludCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdE1hcFNpbmdsZVt0eXBlXVt4VmFsdWVdID0gbmV3UG9pbnQ7XG4gICAgfVxuICAgIHByZXZpb3VzUmVzdWx0UG9pbnQgPSBuZXdQb2ludDtcbiAgICBwcmV2aW91c1hWYWx1ZSA9IHRyYW5zZm9ybUludGVncmF0ZWRDYXRlZ29yeVZhbHVlKHhWYWx1ZSk7XG4gIH07XG4gIGxldCBvbGRJbmRleCA9IDA7XG4gIGxldCBuZXdJbmRleCA9IDA7XG4gIGxldCBpc1hVbm9yZGVyZWQgPSBmYWxzZTtcbiAgd2hpbGUgKG9sZEluZGV4IDwgb2xkRGF0YS5ub2RlRGF0YS5sZW5ndGggfHwgbmV3SW5kZXggPCBuZXdEYXRhLm5vZGVEYXRhLmxlbmd0aCkge1xuICAgIGNvbnN0IGJlZm9yZSA9IG9sZERhdGEubm9kZURhdGFbb2xkSW5kZXhdO1xuICAgIGNvbnN0IGFmdGVyID0gbmV3RGF0YS5ub2RlRGF0YVtuZXdJbmRleF07XG4gICAgY29uc3QgYlhWYWx1ZSA9IHRyYW5zZm9ybUludGVncmF0ZWRDYXRlZ29yeVZhbHVlKGJlZm9yZT8ueFZhbHVlKTtcbiAgICBjb25zdCBhWFZhbHVlID0gdHJhbnNmb3JtSW50ZWdyYXRlZENhdGVnb3J5VmFsdWUoYWZ0ZXI/LnhWYWx1ZSk7XG4gICAgbGV0IHJlc3VsdFBvaW50O1xuICAgIGlmIChiWFZhbHVlID09PSBhWFZhbHVlKSB7XG4gICAgICByZXN1bHRQb2ludCA9IHtcbiAgICAgICAgY2hhbmdlOiBcIm1vdmVcIixcbiAgICAgICAgbW92ZVRvOiBjYWxjdWxhdGVNb3ZlVG8oYmVmb3JlLnBvaW50Lm1vdmVUbyA/PyBmYWxzZSwgYWZ0ZXIucG9pbnQubW92ZVRvKSxcbiAgICAgICAgZnJvbTogYmVmb3JlLnBvaW50LFxuICAgICAgICB0bzogYWZ0ZXIucG9pbnRcbiAgICAgIH07XG4gICAgICBhZGRUb1Jlc3VsdE1hcChiZWZvcmU/LnhWYWx1ZSwgcmVzdWx0UG9pbnQpO1xuICAgICAgb2xkSW5kZXgrKztcbiAgICAgIG5ld0luZGV4Kys7XG4gICAgfSBlbHNlIGlmIChkaWZmMj8ucmVtb3ZlZC5oYXMoU3RyaW5nKGJYVmFsdWUpKSkge1xuICAgICAgcmVzdWx0UG9pbnQgPSB7XG4gICAgICAgIGNoYW5nZTogXCJvdXRcIixcbiAgICAgICAgbW92ZVRvOiBiZWZvcmUucG9pbnQubW92ZVRvID8/IGZhbHNlLFxuICAgICAgICBmcm9tOiBiZWZvcmUucG9pbnRcbiAgICAgIH07XG4gICAgICBhZGRUb1Jlc3VsdE1hcChiZWZvcmU/LnhWYWx1ZSwgcmVzdWx0UG9pbnQpO1xuICAgICAgb2xkSW5kZXgrKztcbiAgICB9IGVsc2UgaWYgKGRpZmYyPy5hZGRlZC5oYXMoU3RyaW5nKGFYVmFsdWUpKSkge1xuICAgICAgcmVzdWx0UG9pbnQgPSB7XG4gICAgICAgIGNoYW5nZTogXCJpblwiLFxuICAgICAgICBtb3ZlVG86IGFmdGVyLnBvaW50Lm1vdmVUbyA/PyBmYWxzZSxcbiAgICAgICAgdG86IGFmdGVyLnBvaW50XG4gICAgICB9O1xuICAgICAgYWRkVG9SZXN1bHRNYXAoYWZ0ZXI/LnhWYWx1ZSwgcmVzdWx0UG9pbnQpO1xuICAgICAgbmV3SW5kZXgrKztcbiAgICB9IGVsc2UgaWYgKG11bHRpRGF0dW0gJiYgcHJldmlvdXNSZXN1bHRQb2ludCAmJiBwcmV2aW91c1hWYWx1ZSA9PT0gYlhWYWx1ZSkge1xuICAgICAgcmVzdWx0UG9pbnQgPSB7XG4gICAgICAgIC4uLnByZXZpb3VzUmVzdWx0UG9pbnRcbiAgICAgIH07XG4gICAgICBhZGRUb1Jlc3VsdE1hcChiZWZvcmU/LnhWYWx1ZSwgcmVzdWx0UG9pbnQpO1xuICAgICAgb2xkSW5kZXgrKztcbiAgICB9IGVsc2UgaWYgKG11bHRpRGF0dW0gJiYgcHJldmlvdXNSZXN1bHRQb2ludCAmJiBwcmV2aW91c1hWYWx1ZSA9PT0gYVhWYWx1ZSkge1xuICAgICAgcmVzdWx0UG9pbnQgPSB7XG4gICAgICAgIC4uLnByZXZpb3VzUmVzdWx0UG9pbnRcbiAgICAgIH07XG4gICAgICBhZGRUb1Jlc3VsdE1hcChhZnRlcj8ueFZhbHVlLCByZXN1bHRQb2ludCk7XG4gICAgICBuZXdJbmRleCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc1hVbm9yZGVyZWQgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHJlc3VsdFBvaW50KTtcbiAgfVxuICBsZXQgcHJldmlvdXNYID0gLUluZmluaXR5O1xuICBpc1hVbm9yZGVyZWQgfHwgKGlzWFVub3JkZXJlZCA9IHJlc3VsdC5zb21lKChwYXRoUG9pbnQpID0+IHtcbiAgICBjb25zdCB7IGNoYW5nZTogbWFya2VyLCB0bzogeyB4ID0gLUluZmluaXR5IH0gPSB7fSB9ID0gcGF0aFBvaW50O1xuICAgIGlmIChtYXJrZXIgPT09IFwib3V0XCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdW5vcmRlcmVkID0geCA8IHByZXZpb3VzWDtcbiAgICBwcmV2aW91c1ggPSB4O1xuICAgIHJldHVybiB1bm9yZGVyZWQ7XG4gIH0pKTtcbiAgaWYgKGlzWFVub3JkZXJlZCkge1xuICAgIHJldHVybiB7IHJlc3VsdDogdm9pZCAwLCByZXN1bHRNYXA6IHZvaWQgMCB9O1xuICB9XG4gIGJhY2tmaWxsUGF0aFBvaW50RGF0YShyZXN1bHQsIGJhY2tmaWxsU3BsaXRNb2RlKTtcbiAgcmV0dXJuIHsgcmVzdWx0LCByZXN1bHRNYXA6IG11bHRpRGF0dW0gPyByZXN1bHRNYXBNdWx0aSA6IHJlc3VsdE1hcFNpbmdsZSB9O1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lUGF0aFN0YXR1cyhuZXdEYXRhLCBvbGREYXRhLCBwYWlyRGF0YSkge1xuICBsZXQgc3RhdHVzID0gXCJ1cGRhdGVkXCI7XG4gIGNvbnN0IHZpc2libGUgPSAoZGF0YSkgPT4ge1xuICAgIHJldHVybiBkYXRhLnZpc2libGU7XG4gIH07XG4gIGlmICghdmlzaWJsZShvbGREYXRhKSAmJiB2aXNpYmxlKG5ld0RhdGEpKSB7XG4gICAgc3RhdHVzID0gXCJhZGRlZFwiO1xuICB9IGVsc2UgaWYgKHZpc2libGUob2xkRGF0YSkgJiYgIXZpc2libGUobmV3RGF0YSkpIHtcbiAgICBzdGF0dXMgPSBcInJlbW92ZWRcIjtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhaXJEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocGFpckRhdGFbaV0uY2hhbmdlICE9PSBcIm1vdmVcIilcbiAgICAgICAgYnJlYWs7XG4gICAgICBpZiAocGFpckRhdGFbaV0uZnJvbT8ueCAhPT0gcGFpckRhdGFbaV0udG8/LngpXG4gICAgICAgIGJyZWFrO1xuICAgICAgaWYgKHBhaXJEYXRhW2ldLmZyb20/LnkgIT09IHBhaXJEYXRhW2ldLnRvPy55KVxuICAgICAgICBicmVhaztcbiAgICAgIGlmIChpID09PSBwYWlyRGF0YS5sZW5ndGggLSAxKVxuICAgICAgICByZXR1cm4gXCJuby1vcFwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdHVzO1xufVxuZnVuY3Rpb24gcHJlcGFyZUxpbmVQYXRoUHJvcGVydHlBbmltYXRpb24oc3RhdHVzLCB2aXNpYmxlVG9nZ2xlTW9kZSkge1xuICBjb25zdCBwaGFzZSA9IHZpc2libGVUb2dnbGVNb2RlID09PSBcIm5vbmVcIiA/IFwidXBkYXRlZFwiIDogc3RhdHVzO1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgZnJvbUZuOiAoX3BhdGgpID0+IHtcbiAgICAgIGxldCBtaXhpbjtcbiAgICAgIGlmIChzdGF0dXMgPT09IFwicmVtb3ZlZFwiKSB7XG4gICAgICAgIG1peGluID0geyBmaW5pc2g6IHsgdmlzaWJsZTogZmFsc2UgfSB9O1xuICAgICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IFwiYWRkZWRcIikge1xuICAgICAgICBtaXhpbiA9IHsgc3RhcnQ6IHsgdmlzaWJsZTogdHJ1ZSB9IH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaXhpbiA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgcGhhc2U6IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbcGhhc2VdLCAuLi5taXhpbiB9O1xuICAgIH0sXG4gICAgdG9GbjogKF9wYXRoKSA9PiB7XG4gICAgICByZXR1cm4geyBwaGFzZTogTk9ERV9VUERBVEVfU1RBVEVfVE9fUEhBU0VfTUFQUElOR1twaGFzZV0gfTtcbiAgICB9XG4gIH07XG4gIGlmICh2aXNpYmxlVG9nZ2xlTW9kZSA9PT0gXCJmYWRlXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbUZuOiAocGF0aCkgPT4ge1xuICAgICAgICBjb25zdCBvcGFjaXR5ID0gc3RhdHVzID09PSBcImFkZGVkXCIgPyAwIDogcGF0aC5vcGFjaXR5O1xuICAgICAgICByZXR1cm4geyBvcGFjaXR5LCAuLi5yZXN1bHQuZnJvbUZuKHBhdGgpIH07XG4gICAgICB9LFxuICAgICAgdG9GbjogKHBhdGgpID0+IHtcbiAgICAgICAgY29uc3Qgb3BhY2l0eSA9IHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIgPyAwIDogMTtcbiAgICAgICAgcmV0dXJuIHsgb3BhY2l0eSwgLi4ucmVzdWx0LnRvRm4ocGF0aCkgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBwcmVwYXJlTGluZVBhdGhBbmltYXRpb25GbnMobmV3RGF0YSwgb2xkRGF0YSwgcGFpckRhdGEsIHZpc2libGVUb2dnbGVNb2RlLCBpbnRlcnBvbGF0aW9uLCByZW5kZXIpIHtcbiAgY29uc3Qgc3RhdHVzID0gZGV0ZXJtaW5lUGF0aFN0YXR1cyhuZXdEYXRhLCBvbGREYXRhLCBwYWlyRGF0YSk7XG4gIGNvbnN0IHJlbW92ZVBoYXNlRm4gPSAocmF0aW8yLCBwYXRoKSA9PiB7XG4gICAgcmVuZGVyKHBhaXJEYXRhLCB7IG1vdmU6IDAsIG91dDogcmF0aW8yIH0sIHBhdGgsIGludGVycG9sYXRpb24pO1xuICB9O1xuICBjb25zdCB1cGRhdGVQaGFzZUZuID0gKHJhdGlvMiwgcGF0aCkgPT4ge1xuICAgIHJlbmRlcihwYWlyRGF0YSwgeyBtb3ZlOiByYXRpbzIgfSwgcGF0aCwgaW50ZXJwb2xhdGlvbik7XG4gIH07XG4gIGNvbnN0IGFkZFBoYXNlRm4gPSAocmF0aW8yLCBwYXRoKSA9PiB7XG4gICAgcmVuZGVyKHBhaXJEYXRhLCB7IG1vdmU6IDEsIGluOiByYXRpbzIgfSwgcGF0aCwgaW50ZXJwb2xhdGlvbik7XG4gIH07XG4gIGNvbnN0IHBhdGhQcm9wZXJ0aWVzID0gcHJlcGFyZUxpbmVQYXRoUHJvcGVydHlBbmltYXRpb24oc3RhdHVzLCB2aXNpYmxlVG9nZ2xlTW9kZSk7XG4gIHJldHVybiB7IHN0YXR1cywgcGF0aDogeyBhZGRQaGFzZUZuLCB1cGRhdGVQaGFzZUZuLCByZW1vdmVQaGFzZUZuIH0sIHBhdGhQcm9wZXJ0aWVzIH07XG59XG5mdW5jdGlvbiBwcmVwYXJlTGluZVBhdGhBbmltYXRpb24obmV3RGF0YSwgb2xkRGF0YSwgZGlmZjIsIGludGVycG9sYXRpb24pIHtcbiAgY29uc3QgaXNDYXRlZ29yeUJhc2VkID0gbmV3RGF0YS5zY2FsZXMueD8udHlwZSA9PT0gXCJjYXRlZ29yeVwiO1xuICBjb25zdCB3YXNDYXRlZ29yeUJhc2VkID0gb2xkRGF0YS5zY2FsZXMueD8udHlwZSA9PT0gXCJjYXRlZ29yeVwiO1xuICBpZiAoaXNDYXRlZ29yeUJhc2VkICE9PSB3YXNDYXRlZ29yeUJhc2VkIHx8ICFpc1NjYWxlVmFsaWQobmV3RGF0YS5zY2FsZXMueCkgfHwgIWlzU2NhbGVWYWxpZChvbGREYXRhLnNjYWxlcy54KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7IHJlc3VsdDogcGFpckRhdGEsIHJlc3VsdE1hcDogcGFpck1hcCB9ID0gaXNDYXRlZ29yeUJhc2VkID8gcGFpckNhdGVnb3J5RGF0YShuZXdEYXRhLCBvbGREYXRhLCBkaWZmMikgOiBwYWlyQ29udGludW91c0RhdGEobmV3RGF0YSwgb2xkRGF0YSk7XG4gIGxldCBzdGF0dXMgPSBcInVwZGF0ZWRcIjtcbiAgaWYgKG9sZERhdGEudmlzaWJsZSAmJiAhbmV3RGF0YS52aXNpYmxlKSB7XG4gICAgc3RhdHVzID0gXCJyZW1vdmVkXCI7XG4gIH0gZWxzZSBpZiAoIW9sZERhdGEudmlzaWJsZSAmJiBuZXdEYXRhLnZpc2libGUpIHtcbiAgICBzdGF0dXMgPSBcImFkZGVkXCI7XG4gIH1cbiAgaWYgKHBhaXJEYXRhID09PSB2b2lkIDAgfHwgcGFpck1hcCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhhc01vdGlvbiA9IChkaWZmMj8uY2hhbmdlZCA/PyB0cnVlKSB8fCBzY2FsZXNDaGFuZ2VkKG5ld0RhdGEsIG9sZERhdGEpIHx8IHN0YXR1cyAhPT0gXCJ1cGRhdGVkXCI7XG4gIGNvbnN0IHBhdGhGbnMgPSBwcmVwYXJlTGluZVBhdGhBbmltYXRpb25GbnMobmV3RGF0YSwgb2xkRGF0YSwgcGFpckRhdGEsIFwiZmFkZVwiLCBpbnRlcnBvbGF0aW9uLCByZW5kZXJQYXJ0aWFsUGF0aCk7XG4gIGNvbnN0IG1hcmtlciA9IHByZXBhcmVNYXJrZXJBbmltYXRpb24ocGFpck1hcCwgc3RhdHVzKTtcbiAgcmV0dXJuIHsgLi4ucGF0aEZucywgbWFya2VyLCBoYXNNb3Rpb24gfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9saW5lSW50ZXJwb2xhdGlvblV0aWwudHNcbmZ1bmN0aW9uIGNsb3NlQ21wKGEsIGIsIGRlbHRhMyA9IDFlLTYpIHtcbiAgaWYgKGEgPT09IGIgfHwgMSAtIE1hdGgubWluKGEsIGIpIC8gTWF0aC5tYXgoYSwgYikgPCBkZWx0YTMpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChhIDwgYikge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMTtcbiAgfVxufVxuZnVuY3Rpb24gY2xvc2VNYXRjaDIoYSwgYiwgZGVsdGEzKSB7XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgYW4gPSBOdW1iZXIoYSk7XG4gIGNvbnN0IGJuID0gTnVtYmVyKGIpO1xuICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKGFuKSAmJiBOdW1iZXIuaXNGaW5pdGUoYm4pICYmIGNsb3NlQ21wKGFuLCBibiwgZGVsdGEzKSA9PT0gMDtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybVNwYW5zKHNwYW5EYXRhLCB7IHg6IHhTY2FsZSwgeTogeVNjYWxlIH0pIHtcbiAgbGV0IHJhbmdlU3BhbkRhdGE7XG4gIGNvbnN0IGludGVycG9sYXRpbmdJbnZhbGlkU3BhbnMgPSBbXTtcbiAgbGV0IHNoaWZ0ZWRYU3RhcnQgPSBJbmZpbml0eTtcbiAgbGV0IHNoaWZ0ZWRYRW5kID0gLUluZmluaXR5O1xuICBmb3IgKGNvbnN0IHNwYW5EYXR1bSBvZiBzcGFuRGF0YSkge1xuICAgIGNvbnN0IHgwID0gc2NhbGUoc3BhbkRhdHVtLnhWYWx1ZTAsIHhTY2FsZSk7XG4gICAgY29uc3QgeTAgPSBzY2FsZShzcGFuRGF0dW0ueVZhbHVlMCwgeVNjYWxlKTtcbiAgICBjb25zdCB4MSA9IHNjYWxlKHNwYW5EYXR1bS54VmFsdWUxLCB4U2NhbGUpO1xuICAgIGNvbnN0IHkxID0gc2NhbGUoc3BhbkRhdHVtLnlWYWx1ZTEsIHlTY2FsZSk7XG4gICAgY29uc3Qgc3RhcnRJc0Zpbml0ZSA9IE51bWJlci5pc0Zpbml0ZSh4MCk7XG4gICAgY29uc3QgZW5kSXNGaW5pdGUgPSBOdW1iZXIuaXNGaW5pdGUoeDEpO1xuICAgIGlmIChzdGFydElzRmluaXRlICYmIGVuZElzRmluaXRlICYmIHJhbmdlU3BhbkRhdGEgPT0gbnVsbCkge1xuICAgICAgY29uc3QgdW5zaGlmdGVkID0gc3BhbkRhdHVtLnNwYW47XG4gICAgICBjb25zdCBzaGlmdGVkID0gcmVzY2FsZVNwYW4odW5zaGlmdGVkLCB7IHg6IHgwLCB5OiB5MCB9LCB7IHg6IHgxLCB5OiB5MSB9KTtcbiAgICAgIGNvbnN0IHNwYW5UcmFuc2Zvcm0gPSB7IHVuc2hpZnRlZCwgc2hpZnRlZCB9O1xuICAgICAgc2hpZnRlZFhTdGFydCA9IE1hdGgubWluKHNoaWZ0ZWRYU3RhcnQsIHgwKTtcbiAgICAgIHNoaWZ0ZWRYRW5kID0gTWF0aC5tYXgoc2hpZnRlZFhFbmQsIHgxKTtcbiAgICAgIGludGVycG9sYXRpbmdJbnZhbGlkU3BhbnMucHVzaChzcGFuVHJhbnNmb3JtKTtcbiAgICB9IGVsc2UgaWYgKHN0YXJ0SXNGaW5pdGUgJiYgIWVuZElzRmluaXRlICYmIHJhbmdlU3BhbkRhdGEgPT0gbnVsbCkge1xuICAgICAgcmFuZ2VTcGFuRGF0YSA9IFtzcGFuRGF0dW1dO1xuICAgIH0gZWxzZSBpZiAoIXN0YXJ0SXNGaW5pdGUgJiYgIWVuZElzRmluaXRlICYmIHJhbmdlU3BhbkRhdGEgIT0gbnVsbCkge1xuICAgICAgaWYgKHJhbmdlU3BhbkRhdGEgIT0gbnVsbCkge1xuICAgICAgICByYW5nZVNwYW5EYXRhLnB1c2goc3BhbkRhdHVtKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFzdGFydElzRmluaXRlICYmIGVuZElzRmluaXRlICYmIHJhbmdlU3BhbkRhdGEgIT0gbnVsbCkge1xuICAgICAgcmFuZ2VTcGFuRGF0YS5wdXNoKHNwYW5EYXR1bSk7XG4gICAgICBjb25zdCBzdGFydFNwYW5EYXR1bSA9IHJhbmdlU3BhbkRhdGEuYXQoMCk7XG4gICAgICBjb25zdCBlbmRTcGFuRGF0dW0gPSByYW5nZVNwYW5EYXRhLmF0KC0xKTtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybVN0YXJ0ID0ge1xuICAgICAgICB4OiBzY2FsZShzdGFydFNwYW5EYXR1bS54VmFsdWUwLCB4U2NhbGUpLFxuICAgICAgICB5OiBzY2FsZShzdGFydFNwYW5EYXR1bS55VmFsdWUwLCB5U2NhbGUpXG4gICAgICB9O1xuICAgICAgY29uc3QgdHJhbnNmb3JtRW5kID0ge1xuICAgICAgICB4OiBzY2FsZShlbmRTcGFuRGF0dW0ueFZhbHVlMSwgeFNjYWxlKSxcbiAgICAgICAgeTogc2NhbGUoZW5kU3BhbkRhdHVtLnlWYWx1ZTEsIHlTY2FsZSlcbiAgICAgIH07XG4gICAgICBjb25zdCBzdGVwID0gKHRyYW5zZm9ybUVuZC54IC0gdHJhbnNmb3JtU3RhcnQueCkgLyAocmFuZ2VTcGFuRGF0YS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VTcGFuRGF0YS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCB7IHNwYW46IGludGVycG9sYXRpbmdVbnNoaWZ0ZWQsIHlWYWx1ZTAsIHlWYWx1ZTEgfSA9IHJhbmdlU3BhbkRhdGFbaV07XG4gICAgICAgIGNvbnN0IGludGVycG9sYXRpbmdTaGlmdGVkID0gcmVzY2FsZVNwYW4oXG4gICAgICAgICAgaW50ZXJwb2xhdGluZ1Vuc2hpZnRlZCxcbiAgICAgICAgICB7IHg6IHRyYW5zZm9ybVN0YXJ0LnggKyBzdGVwICogKGkgKyAwKSwgeTogc2NhbGUoeVZhbHVlMCwgeVNjYWxlKSB9LFxuICAgICAgICAgIHsgeDogdHJhbnNmb3JtU3RhcnQueCArIHN0ZXAgKiAoaSArIDEpLCB5OiBzY2FsZSh5VmFsdWUxLCB5U2NhbGUpIH1cbiAgICAgICAgKTtcbiAgICAgICAgaW50ZXJwb2xhdGluZ0ludmFsaWRTcGFucy5wdXNoKHsgdW5zaGlmdGVkOiBpbnRlcnBvbGF0aW5nVW5zaGlmdGVkLCBzaGlmdGVkOiBpbnRlcnBvbGF0aW5nU2hpZnRlZCB9KTtcbiAgICAgIH1cbiAgICAgIHNoaWZ0ZWRYU3RhcnQgPSBNYXRoLm1pbihzaGlmdGVkWFN0YXJ0LCB0cmFuc2Zvcm1TdGFydC54KTtcbiAgICAgIHNoaWZ0ZWRYRW5kID0gTWF0aC5tYXgoc2hpZnRlZFhFbmQsIHRyYW5zZm9ybUVuZC54KTtcbiAgICAgIHJhbmdlU3BhbkRhdGEgPSB2b2lkIDA7XG4gICAgfSBlbHNlIGlmICghc3RhcnRJc0Zpbml0ZSAmJiBlbmRJc0Zpbml0ZSAmJiByYW5nZVNwYW5EYXRhID09IG51bGwpIHtcbiAgICAgIGNvbnN0IHVuc2hpZnRlZCA9IHNwYW5EYXR1bS5zcGFuO1xuICAgICAgY29uc3Qgc2hpZnRlZCA9IHJlc2NhbGVTcGFuKHVuc2hpZnRlZCwgeyB4OiB4MSwgeTogeTAgfSwgeyB4OiB4MSwgeTogeTEgfSk7XG4gICAgICBpbnRlcnBvbGF0aW5nSW52YWxpZFNwYW5zLnB1c2goeyB1bnNoaWZ0ZWQsIHNoaWZ0ZWQgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlU3BhbkRhdGEgPSB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGlmIChyYW5nZVNwYW5EYXRhICE9IG51bGwpIHtcbiAgICBjb25zdCBzdGFydFNwYW5EYXR1bSA9IHJhbmdlU3BhbkRhdGEuYXQoMCk7XG4gICAgY29uc3QgeCA9IHNjYWxlKHN0YXJ0U3BhbkRhdHVtLnhWYWx1ZTAsIHhTY2FsZSk7XG4gICAgZm9yIChjb25zdCB7IHNwYW46IGludGVycG9sYXRpbmdVbnNoaWZ0ZWQsIHlWYWx1ZTAsIHlWYWx1ZTEgfSBvZiByYW5nZVNwYW5EYXRhKSB7XG4gICAgICBjb25zdCBpbnRlcnBvbGF0aW5nU2hpZnRlZCA9IHJlc2NhbGVTcGFuKFxuICAgICAgICBpbnRlcnBvbGF0aW5nVW5zaGlmdGVkLFxuICAgICAgICB7IHgsIHk6IHNjYWxlKHlWYWx1ZTAsIHlTY2FsZSkgfSxcbiAgICAgICAgeyB4LCB5OiBzY2FsZSh5VmFsdWUxLCB5U2NhbGUpIH1cbiAgICAgICk7XG4gICAgICBpbnRlcnBvbGF0aW5nSW52YWxpZFNwYW5zLnB1c2goeyB1bnNoaWZ0ZWQ6IGludGVycG9sYXRpbmdVbnNoaWZ0ZWQsIHNoaWZ0ZWQ6IGludGVycG9sYXRpbmdTaGlmdGVkIH0pO1xuICAgIH1cbiAgfVxuICBjb25zdCBzaGlmdGVkWFJhbmdlID0gW3NoaWZ0ZWRYU3RhcnQsIHNoaWZ0ZWRYRW5kXTtcbiAgcmV0dXJuIHsgaW50ZXJwb2xhdGluZ0ludmFsaWRTcGFucywgc2hpZnRlZFhSYW5nZSB9O1xufVxuZnVuY3Rpb24gcGFpclVwU3BhbnMobmV3RGF0YSwgb2xkRGF0YSwgc3BsaXRNb2RlKSB7XG4gIGNvbnN0IG9sZFNwYW5zID0gdHJhbnNmb3JtU3BhbnMob2xkRGF0YS5kYXRhLCBuZXdEYXRhLnNjYWxlcyk7XG4gIGNvbnN0IG5ld1NwYW5zID0gdHJhbnNmb3JtU3BhbnMobmV3RGF0YS5kYXRhLCBvbGREYXRhLnNjYWxlcyk7XG4gIGNvbnN0IFtvbGRSYW5nZVN0YXJ0TmV3U2NhbGUsIG9sZFJhbmdlRW5kTmV3U2NhbGVdID0gb2xkU3BhbnMuc2hpZnRlZFhSYW5nZTtcbiAgY29uc3QgW25ld1JhbmdlU3RhcnRPbGRTY2FsZSwgbmV3UmFuZ2VFbmRPbGRTY2FsZV0gPSBuZXdTcGFucy5zaGlmdGVkWFJhbmdlO1xuICBjb25zdCByZW1vdmVkID0gW107XG4gIGNvbnN0IG1vdmVkID0gW107XG4gIGZvciAoY29uc3Qgb2xkU3BhbkRhdHVtIG9mIG9sZFNwYW5zLmludGVycG9sYXRpbmdJbnZhbGlkU3BhbnMpIHtcbiAgICBjb25zdCBvbGRTcGFuT2xkU2NhbGUgPSBvbGRTcGFuRGF0dW0udW5zaGlmdGVkO1xuICAgIGNvbnN0IG9sZFNwYW5OZXdTY2FsZSA9IG9sZFNwYW5EYXR1bS5zaGlmdGVkO1xuICAgIGNvbnN0IFt7IHg6IGZyb21TdGFydE9sZFNjYWxlLCB5OiBmcm9tU3RhcnRPbGRTY2FsZVkgfSwgeyB4OiBmcm9tRW5kT2xkU2NhbGUsIHk6IGZyb21FbmRPbGRTY2FsZVkgfV0gPSBzcGFuUmFuZ2Uob2xkU3Bhbk9sZFNjYWxlKTtcbiAgICBsZXQgaGFzQ29ycmVzcG9uZGluZ1NwYW4gPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IG5ld1NwYW5EYXR1bSBvZiBuZXdTcGFucy5pbnRlcnBvbGF0aW5nSW52YWxpZFNwYW5zKSB7XG4gICAgICBjb25zdCBuZXdTcGFuT2xkU2NhbGUgPSBuZXdTcGFuRGF0dW0uc2hpZnRlZDtcbiAgICAgIGNvbnN0IG5ld1NwYW5OZXdTY2FsZSA9IG5ld1NwYW5EYXR1bS51bnNoaWZ0ZWQ7XG4gICAgICBjb25zdCBbeyB4OiB0b1N0YXJ0T2xkU2NhbGUgfSwgeyB4OiB0b0VuZE9sZFNjYWxlIH1dID0gc3BhblJhbmdlKG5ld1NwYW5PbGRTY2FsZSk7XG4gICAgICBpZiAoY2xvc2VDbXAoZnJvbVN0YXJ0T2xkU2NhbGUsIHRvRW5kT2xkU2NhbGUpICE9PSAtMSB8fCBjbG9zZUNtcChmcm9tRW5kT2xkU2NhbGUsIHRvU3RhcnRPbGRTY2FsZSkgIT09IDEpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoY2xvc2VNYXRjaDIoZnJvbVN0YXJ0T2xkU2NhbGUsIHRvU3RhcnRPbGRTY2FsZSkgJiYgY2xvc2VNYXRjaDIoZnJvbUVuZE9sZFNjYWxlLCB0b0VuZE9sZFNjYWxlKSkge1xuICAgICAgICByZW1vdmVkLnB1c2goeyBmcm9tOiBvbGRTcGFuT2xkU2NhbGUsIHRvOiBvbGRTcGFuT2xkU2NhbGUgfSk7XG4gICAgICAgIG1vdmVkLnB1c2goeyBmcm9tOiBvbGRTcGFuT2xkU2NhbGUsIHRvOiBuZXdTcGFuTmV3U2NhbGUgfSk7XG4gICAgICB9IGVsc2UgaWYgKGZyb21TdGFydE9sZFNjYWxlIDw9IHRvU3RhcnRPbGRTY2FsZSAmJiBmcm9tRW5kT2xkU2NhbGUgPj0gdG9FbmRPbGRTY2FsZSkge1xuICAgICAgICByZW1vdmVkLnB1c2goeyBmcm9tOiBvbGRTcGFuT2xkU2NhbGUsIHRvOiBvbGRTcGFuT2xkU2NhbGUgfSk7XG4gICAgICAgIG1vdmVkLnB1c2goeyBmcm9tOiBvbGRTcGFuT2xkU2NhbGUsIHRvOiBvbGRTcGFuTmV3U2NhbGUgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBbeyB4OiBmcm9tU3RhcnROZXdTY2FsZSB9LCB7IHg6IGZyb21FbmROZXdTY2FsZSB9XSA9IHNwYW5SYW5nZShvbGRTcGFuTmV3U2NhbGUpO1xuICAgICAgICBjb25zdCBbeyB4OiB0b1N0YXJ0TmV3U2NhbGUgfSwgeyB4OiB0b0VuZE5ld1NjYWxlIH1dID0gc3BhblJhbmdlKG5ld1NwYW5OZXdTY2FsZSk7XG4gICAgICAgIGNvbnN0IHhSYW5nZVN0YXJ0T2xkU2NhbGUgPSBNYXRoLm1heChmcm9tU3RhcnRPbGRTY2FsZSwgdG9TdGFydE9sZFNjYWxlKTtcbiAgICAgICAgY29uc3QgeFJhbmdlRW5kT2xkU2NhbGUgPSBNYXRoLm1pbihmcm9tRW5kT2xkU2NhbGUsIHRvRW5kT2xkU2NhbGUpO1xuICAgICAgICBjb25zdCBjbGlwcGVkT2xkU3Bhbk9sZFNjYWxlID0gY2xpcFNwYW5YKG9sZFNwYW5PbGRTY2FsZSwgeFJhbmdlU3RhcnRPbGRTY2FsZSwgeFJhbmdlRW5kT2xkU2NhbGUpO1xuICAgICAgICBjb25zdCBjbGlwcGVkTmV3U3Bhbk9sZFNjYWxlID0gY2xpcFNwYW5YKG5ld1NwYW5PbGRTY2FsZSwgeFJhbmdlU3RhcnRPbGRTY2FsZSwgeFJhbmdlRW5kT2xkU2NhbGUpO1xuICAgICAgICBjb25zdCB4UmFuZ2VTdGFydE5ld1NjYWxlID0gTWF0aC5tYXgoZnJvbVN0YXJ0TmV3U2NhbGUsIHRvU3RhcnROZXdTY2FsZSk7XG4gICAgICAgIGNvbnN0IHhSYW5nZUVuZE5ld1NjYWxlID0gTWF0aC5taW4oZnJvbUVuZE5ld1NjYWxlLCB0b0VuZE5ld1NjYWxlKTtcbiAgICAgICAgY29uc3QgY2xpcHBlZE5ld1NwYW5OZXdTY2FsZSA9IGNsaXBTcGFuWChuZXdTcGFuTmV3U2NhbGUsIHhSYW5nZVN0YXJ0TmV3U2NhbGUsIHhSYW5nZUVuZE5ld1NjYWxlKTtcbiAgICAgICAgcmVtb3ZlZC5wdXNoKHsgZnJvbTogY2xpcHBlZE9sZFNwYW5PbGRTY2FsZSwgdG86IGNsaXBwZWROZXdTcGFuT2xkU2NhbGUgfSk7XG4gICAgICAgIG1vdmVkLnB1c2goeyBmcm9tOiBjbGlwcGVkTmV3U3Bhbk9sZFNjYWxlLCB0bzogY2xpcHBlZE5ld1NwYW5OZXdTY2FsZSB9KTtcbiAgICAgIH1cbiAgICAgIGhhc0NvcnJlc3BvbmRpbmdTcGFuID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGhhc0NvcnJlc3BvbmRpbmdTcGFuKVxuICAgICAgY29udGludWU7XG4gICAgaWYgKGNsb3NlQ21wKGZyb21FbmRPbGRTY2FsZSwgbmV3UmFuZ2VTdGFydE9sZFNjYWxlKSAhPT0gMSkge1xuICAgICAgcmVtb3ZlZC5wdXNoKHtcbiAgICAgICAgZnJvbTogb2xkU3Bhbk9sZFNjYWxlLFxuICAgICAgICB0bzogcmVzY2FsZVNwYW4oXG4gICAgICAgICAgb2xkU3Bhbk9sZFNjYWxlLFxuICAgICAgICAgIHsgeDogbmV3UmFuZ2VTdGFydE9sZFNjYWxlLCB5OiBmcm9tU3RhcnRPbGRTY2FsZVkgfSxcbiAgICAgICAgICB7IHg6IG5ld1JhbmdlU3RhcnRPbGRTY2FsZSwgeTogZnJvbUVuZE9sZFNjYWxlWSB9XG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY2xvc2VDbXAoZnJvbVN0YXJ0T2xkU2NhbGUsIG5ld1JhbmdlRW5kT2xkU2NhbGUpICE9PSAtMSkge1xuICAgICAgcmVtb3ZlZC5wdXNoKHtcbiAgICAgICAgZnJvbTogb2xkU3Bhbk9sZFNjYWxlLFxuICAgICAgICB0bzogcmVzY2FsZVNwYW4oXG4gICAgICAgICAgb2xkU3Bhbk9sZFNjYWxlLFxuICAgICAgICAgIHsgeDogbmV3UmFuZ2VFbmRPbGRTY2FsZSwgeTogZnJvbVN0YXJ0T2xkU2NhbGVZIH0sXG4gICAgICAgICAgeyB4OiBuZXdSYW5nZUVuZE9sZFNjYWxlLCB5OiBmcm9tRW5kT2xkU2NhbGVZIH1cbiAgICAgICAgKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChzcGxpdE1vZGUgPT09IDAgLyogWmVybyAqLykge1xuICAgICAgY29uc3QgeSA9IHNjYWxlKDAsIG9sZERhdGEuc2NhbGVzLnkpO1xuICAgICAgcmVtb3ZlZC5wdXNoKHtcbiAgICAgICAgZnJvbTogb2xkU3Bhbk9sZFNjYWxlLFxuICAgICAgICB0bzogcmVzY2FsZVNwYW4ob2xkU3Bhbk9sZFNjYWxlLCB7IHg6IGZyb21TdGFydE9sZFNjYWxlLCB5IH0sIHsgeDogZnJvbUVuZE9sZFNjYWxlLCB5IH0pXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHNwbGl0TW9kZSA9PT0gMSAvKiBEaXZpZGUgKi8pIHtcbiAgICAgIGNvbnN0IFtsZWZ0LCByaWdodF0gPSBzcGxpdFNwYW5BdFgob2xkU3Bhbk9sZFNjYWxlLCAoZnJvbVN0YXJ0T2xkU2NhbGUgKyBmcm9tRW5kT2xkU2NhbGUpIC8gMik7XG4gICAgICByZW1vdmVkLnB1c2goXG4gICAgICAgIHsgZnJvbTogbGVmdCwgdG86IGNvbGxhcHNlU3BhblRvUG9pbnQobGVmdCwgeyB4OiBmcm9tU3RhcnRPbGRTY2FsZSwgeTogZnJvbVN0YXJ0T2xkU2NhbGVZIH0pIH0sXG4gICAgICAgIHsgZnJvbTogcmlnaHQsIHRvOiBjb2xsYXBzZVNwYW5Ub1BvaW50KHJpZ2h0LCB7IHg6IGZyb21FbmRPbGRTY2FsZSwgeTogZnJvbUVuZE9sZFNjYWxlWSB9KSB9XG4gICAgICApO1xuICAgIH1cbiAgfVxuICBjb25zdCBhZGRlZCA9IFtdO1xuICBmb3IgKGNvbnN0IG5ld1NwYW5EYXR1bSBvZiBuZXdEYXRhLmRhdGEpIHtcbiAgICBjb25zdCBuZXdTcGFuTmV3U2NhbGUgPSBuZXdTcGFuRGF0dW0uc3BhbjtcbiAgICBjb25zdCBbeyB4OiB0b1N0YXJ0TmV3U2NhbGUsIHk6IHRvU3RhcnROZXdTY2FsZVkgfSwgeyB4OiB0b0VuZE5ld1NjYWxlLCB5OiB0b0VuZE5ld1NjYWxlWSB9XSA9IHNwYW5SYW5nZShuZXdTcGFuTmV3U2NhbGUpO1xuICAgIGxldCBoYXNDb3JyZXNwb25kaW5nU3BhbiA9IGZhbHNlO1xuICAgIGZvciAoY29uc3Qgb2xkU3BhbkRhdHVtIG9mIG9sZFNwYW5zLmludGVycG9sYXRpbmdJbnZhbGlkU3BhbnMpIHtcbiAgICAgIGNvbnN0IG9sZFNwYW5OZXdTY2FsZSA9IG9sZFNwYW5EYXR1bS5zaGlmdGVkO1xuICAgICAgY29uc3QgW3sgeDogZnJvbVN0YXJ0TmV3U2NhbGUgfSwgeyB4OiBmcm9tRW5kTmV3U2NhbGUgfV0gPSBzcGFuUmFuZ2Uob2xkU3Bhbk5ld1NjYWxlKTtcbiAgICAgIGlmIChjbG9zZUNtcChmcm9tU3RhcnROZXdTY2FsZSwgdG9FbmROZXdTY2FsZSkgIT09IC0xIHx8IGNsb3NlQ21wKGZyb21FbmROZXdTY2FsZSwgdG9TdGFydE5ld1NjYWxlKSAhPT0gMSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjbG9zZU1hdGNoMihmcm9tU3RhcnROZXdTY2FsZSwgdG9TdGFydE5ld1NjYWxlKSAmJiBjbG9zZU1hdGNoMihmcm9tRW5kTmV3U2NhbGUsIHRvRW5kTmV3U2NhbGUpKSB7XG4gICAgICAgIGFkZGVkLnB1c2goeyBmcm9tOiBuZXdTcGFuTmV3U2NhbGUsIHRvOiBuZXdTcGFuTmV3U2NhbGUgfSk7XG4gICAgICB9IGVsc2UgaWYgKGZyb21TdGFydE5ld1NjYWxlIDw9IHRvU3RhcnROZXdTY2FsZSAmJiBmcm9tRW5kTmV3U2NhbGUgPj0gdG9FbmROZXdTY2FsZSkge1xuICAgICAgICBjb25zdCBjbGlwcGVkT2xkU3Bhbk5ld1NjYWxlID0gY2xpcFNwYW5YKG9sZFNwYW5OZXdTY2FsZSwgdG9TdGFydE5ld1NjYWxlLCB0b0VuZE5ld1NjYWxlKTtcbiAgICAgICAgYWRkZWQucHVzaCh7IGZyb206IGNsaXBwZWRPbGRTcGFuTmV3U2NhbGUsIHRvOiBuZXdTcGFuTmV3U2NhbGUgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGRlZC5wdXNoKHsgZnJvbTogbmV3U3Bhbk5ld1NjYWxlLCB0bzogbmV3U3Bhbk5ld1NjYWxlIH0pO1xuICAgICAgfVxuICAgICAgaGFzQ29ycmVzcG9uZGluZ1NwYW4gPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoaGFzQ29ycmVzcG9uZGluZ1NwYW4pXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAoY2xvc2VDbXAodG9FbmROZXdTY2FsZSwgb2xkUmFuZ2VTdGFydE5ld1NjYWxlKSAhPT0gMSkge1xuICAgICAgYWRkZWQucHVzaCh7XG4gICAgICAgIGZyb206IHJlc2NhbGVTcGFuKFxuICAgICAgICAgIG5ld1NwYW5OZXdTY2FsZSxcbiAgICAgICAgICB7IHg6IG9sZFJhbmdlU3RhcnROZXdTY2FsZSwgeTogdG9TdGFydE5ld1NjYWxlWSB9LFxuICAgICAgICAgIHsgeDogb2xkUmFuZ2VTdGFydE5ld1NjYWxlLCB5OiB0b0VuZE5ld1NjYWxlWSB9XG4gICAgICAgICksXG4gICAgICAgIHRvOiBuZXdTcGFuTmV3U2NhbGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY2xvc2VDbXAodG9TdGFydE5ld1NjYWxlLCBvbGRSYW5nZUVuZE5ld1NjYWxlKSAhPT0gLTEpIHtcbiAgICAgIGFkZGVkLnB1c2goe1xuICAgICAgICBmcm9tOiByZXNjYWxlU3BhbihcbiAgICAgICAgICBuZXdTcGFuTmV3U2NhbGUsXG4gICAgICAgICAgeyB4OiBvbGRSYW5nZUVuZE5ld1NjYWxlLCB5OiB0b1N0YXJ0TmV3U2NhbGVZIH0sXG4gICAgICAgICAgeyB4OiBvbGRSYW5nZUVuZE5ld1NjYWxlLCB5OiB0b0VuZE5ld1NjYWxlWSB9XG4gICAgICAgICksXG4gICAgICAgIHRvOiBuZXdTcGFuTmV3U2NhbGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoc3BsaXRNb2RlID09PSAwIC8qIFplcm8gKi8pIHtcbiAgICAgIGNvbnN0IHkgPSBzY2FsZSgwLCBuZXdEYXRhLnNjYWxlcy55KTtcbiAgICAgIGFkZGVkLnB1c2goe1xuICAgICAgICBmcm9tOiByZXNjYWxlU3BhbihuZXdTcGFuTmV3U2NhbGUsIHsgeDogdG9TdGFydE5ld1NjYWxlLCB5IH0sIHsgeDogdG9FbmROZXdTY2FsZSwgeSB9KSxcbiAgICAgICAgdG86IG5ld1NwYW5OZXdTY2FsZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChzcGxpdE1vZGUgPT09IDEgLyogRGl2aWRlICovKSB7XG4gICAgICBjb25zdCBbbGVmdCwgcmlnaHRdID0gc3BsaXRTcGFuQXRYKG5ld1NwYW5OZXdTY2FsZSwgKHRvU3RhcnROZXdTY2FsZSArIHRvRW5kTmV3U2NhbGUpIC8gMik7XG4gICAgICBhZGRlZC5wdXNoKFxuICAgICAgICB7IGZyb206IGNvbGxhcHNlU3BhblRvUG9pbnQobGVmdCwgeyB4OiB0b1N0YXJ0TmV3U2NhbGUsIHk6IHRvU3RhcnROZXdTY2FsZVkgfSksIHRvOiBuZXdTcGFuTmV3U2NhbGUgfSxcbiAgICAgICAgeyBmcm9tOiBjb2xsYXBzZVNwYW5Ub1BvaW50KHJpZ2h0LCB7IHg6IHRvRW5kTmV3U2NhbGUsIHk6IHRvRW5kTmV3U2NhbGVZIH0pLCB0bzogbmV3U3Bhbk5ld1NjYWxlIH1cbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IGFkZGVkLCBtb3ZlZCwgcmVtb3ZlZCB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2FyZWFVdGlsLnRzXG52YXIgQXJlYVNlcmllc1RhZyA9IC8qIEBfX1BVUkVfXyAqLyAoKEFyZWFTZXJpZXNUYWcyKSA9PiB7XG4gIEFyZWFTZXJpZXNUYWcyW0FyZWFTZXJpZXNUYWcyW1wiRmlsbFwiXSA9IDBdID0gXCJGaWxsXCI7XG4gIEFyZWFTZXJpZXNUYWcyW0FyZWFTZXJpZXNUYWcyW1wiU3Ryb2tlXCJdID0gMV0gPSBcIlN0cm9rZVwiO1xuICBBcmVhU2VyaWVzVGFnMltBcmVhU2VyaWVzVGFnMltcIk1hcmtlclwiXSA9IDJdID0gXCJNYXJrZXJcIjtcbiAgQXJlYVNlcmllc1RhZzJbQXJlYVNlcmllc1RhZzJbXCJMYWJlbFwiXSA9IDNdID0gXCJMYWJlbFwiO1xuICByZXR1cm4gQXJlYVNlcmllc1RhZzI7XG59KShBcmVhU2VyaWVzVGFnIHx8IHt9KTtcbmZ1bmN0aW9uIHBsb3RTcGFucyhyYXRpbzIsIHBhdGgsIHNwYW5zLCBwaGFudG9tU3BhbnMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGNvbnN0IHNwYW4gPSBzcGFuc1tpXTtcbiAgICBjb25zdCBwaGFudG9tU3BhbiA9IHBoYW50b21TcGFuc1tpXTtcbiAgICBwbG90U3BhbihwYXRoLnBhdGgsIGludGVycG9sYXRlU3BhbnMoc3Bhbi5mcm9tLCBzcGFuLnRvLCByYXRpbzIpLCAxIC8qIE1vdmVUbyAqLyk7XG4gICAgcGxvdFNwYW4ocGF0aC5wYXRoLCByZXZlcnNlU3BhbihpbnRlcnBvbGF0ZVNwYW5zKHBoYW50b21TcGFuLmZyb20sIHBoYW50b21TcGFuLnRvLCByYXRpbzIpKSwgMiAvKiBMaW5lVG8gKi8pO1xuICAgIHBhdGgucGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZUFyZWFQYXRoQW5pbWF0aW9uRm5zKHN0YXR1cywgc3BhbnMsIHBoYW50b21TcGFucywgdmlzaWJsZVRvZ2dsZU1vZGUpIHtcbiAgY29uc3QgcmVtb3ZlUGhhc2VGbiA9IChyYXRpbzIsIHBhdGgpID0+IHBsb3RTcGFucyhyYXRpbzIsIHBhdGgsIHNwYW5zLnJlbW92ZWQsIHBoYW50b21TcGFucy5yZW1vdmVkKTtcbiAgY29uc3QgdXBkYXRlUGhhc2VGbiA9IChyYXRpbzIsIHBhdGgpID0+IHBsb3RTcGFucyhyYXRpbzIsIHBhdGgsIHNwYW5zLm1vdmVkLCBwaGFudG9tU3BhbnMubW92ZWQpO1xuICBjb25zdCBhZGRQaGFzZUZuID0gKHJhdGlvMiwgcGF0aCkgPT4gcGxvdFNwYW5zKHJhdGlvMiwgcGF0aCwgc3BhbnMuYWRkZWQsIHBoYW50b21TcGFucy5hZGRlZCk7XG4gIGNvbnN0IHBhdGhQcm9wZXJ0aWVzID0gcHJlcGFyZUxpbmVQYXRoUHJvcGVydHlBbmltYXRpb24oc3RhdHVzLCB2aXNpYmxlVG9nZ2xlTW9kZSk7XG4gIHJldHVybiB7IHN0YXR1cywgcGF0aDogeyBhZGRQaGFzZUZuLCB1cGRhdGVQaGFzZUZuLCByZW1vdmVQaGFzZUZuIH0sIHBhdGhQcm9wZXJ0aWVzIH07XG59XG5mdW5jdGlvbiBwcmVwYXJlQXJlYVBhdGhBbmltYXRpb24obmV3RGF0YSwgb2xkRGF0YSwgZGlmZjIpIHtcbiAgY29uc3QgaXNDYXRlZ29yeUJhc2VkID0gbmV3RGF0YS5zY2FsZXMueD8udHlwZSA9PT0gXCJjYXRlZ29yeVwiO1xuICBjb25zdCB3YXNDYXRlZ29yeUJhc2VkID0gb2xkRGF0YS5zY2FsZXMueD8udHlwZSA9PT0gXCJjYXRlZ29yeVwiO1xuICBpZiAoaXNDYXRlZ29yeUJhc2VkICE9PSB3YXNDYXRlZ29yeUJhc2VkIHx8ICFpc1NjYWxlVmFsaWQobmV3RGF0YS5zY2FsZXMueCkgfHwgIWlzU2NhbGVWYWxpZChvbGREYXRhLnNjYWxlcy54KSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc3RhdHVzID0gXCJ1cGRhdGVkXCI7XG4gIGlmIChvbGREYXRhLnZpc2libGUgJiYgIW5ld0RhdGEudmlzaWJsZSkge1xuICAgIHN0YXR1cyA9IFwicmVtb3ZlZFwiO1xuICB9IGVsc2UgaWYgKCFvbGREYXRhLnZpc2libGUgJiYgbmV3RGF0YS52aXNpYmxlKSB7XG4gICAgc3RhdHVzID0gXCJhZGRlZFwiO1xuICB9XG4gIGNvbnN0IHNwYW5zID0gcGFpclVwU3BhbnMoXG4gICAgeyBzY2FsZXM6IG5ld0RhdGEuc2NhbGVzLCBkYXRhOiBuZXdEYXRhLmZpbGxEYXRhLnNwYW5zLCB2aXNpYmxlOiBuZXdEYXRhLnZpc2libGUgfSxcbiAgICB7IHNjYWxlczogb2xkRGF0YS5zY2FsZXMsIGRhdGE6IG9sZERhdGEuZmlsbERhdGEuc3BhbnMsIHZpc2libGU6IG9sZERhdGEudmlzaWJsZSB9LFxuICAgIDAgLyogWmVybyAqL1xuICApO1xuICBjb25zdCBwaGFudG9tU3BhbnMgPSBwYWlyVXBTcGFucyhcbiAgICB7IHNjYWxlczogbmV3RGF0YS5zY2FsZXMsIGRhdGE6IG5ld0RhdGEuZmlsbERhdGEucGhhbnRvbVNwYW5zLCB2aXNpYmxlOiBuZXdEYXRhLnZpc2libGUgfSxcbiAgICB7IHNjYWxlczogb2xkRGF0YS5zY2FsZXMsIGRhdGE6IG9sZERhdGEuZmlsbERhdGEucGhhbnRvbVNwYW5zLCB2aXNpYmxlOiBvbGREYXRhLnZpc2libGUgfSxcbiAgICAwIC8qIFplcm8gKi9cbiAgKTtcbiAgY29uc3QgcHJlcGFyZU1hcmtlclBhaXJzID0gKCkgPT4ge1xuICAgIGlmIChpc0NhdGVnb3J5QmFzZWQpIHtcbiAgICAgIHJldHVybiBwYWlyQ2F0ZWdvcnlEYXRhKG5ld0RhdGEsIG9sZERhdGEsIGRpZmYyLCB7IGJhY2tmaWxsU3BsaXRNb2RlOiBcInN0YXRpY1wiLCBtdWx0aURhdHVtOiB0cnVlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGFpckNvbnRpbnVvdXNEYXRhKG5ld0RhdGEsIG9sZERhdGEsIHsgYmFja2ZpbGxTcGxpdE1vZGU6IFwic3RhdGljXCIgfSk7XG4gIH07XG4gIGNvbnN0IHsgcmVzdWx0TWFwOiBtYXJrZXJQYWlyTWFwIH0gPSBwcmVwYXJlTWFya2VyUGFpcnMoKTtcbiAgaWYgKG1hcmtlclBhaXJNYXAgPT09IHZvaWQgMClcbiAgICByZXR1cm47XG4gIGNvbnN0IHN0YWNrVmlzaWJsZSA9IHRydWU7XG4gIGNvbnN0IGZhZGVNb2RlID0gc3RhY2tWaXNpYmxlID8gXCJub25lXCIgOiBcImZhZGVcIjtcbiAgY29uc3QgZmlsbCA9IHByZXBhcmVBcmVhUGF0aEFuaW1hdGlvbkZucyhzdGF0dXMsIHNwYW5zLCBwaGFudG9tU3BhbnMsIGZhZGVNb2RlKTtcbiAgY29uc3QgbWFya2VyID0gcHJlcGFyZU1hcmtlckFuaW1hdGlvbihtYXJrZXJQYWlyTWFwLCBzdGF0dXMpO1xuICByZXR1cm4geyBzdGF0dXMsIGZpbGwsIG1hcmtlciB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2FyZWFTZXJpZXMudHNcbnZhciBBcmVhU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcih7XG4gICAgICBtb2R1bGVDdHgsXG4gICAgICBkaXJlY3Rpb25LZXlzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fS0VZUyxcbiAgICAgIGRpcmVjdGlvbk5hbWVzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fTkFNRVMsXG4gICAgICBwYXRoc1BlclNlcmllczogW1wiZmlsbFwiLCBcInN0cm9rZVwiXSxcbiAgICAgIHBhdGhzWkluZGV4U3ViT3JkZXJPZmZzZXQ6IFswLCAxZTNdLFxuICAgICAgaGFzTWFya2VyczogdHJ1ZSxcbiAgICAgIG1hcmtlclNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uOiBmYWxzZSxcbiAgICAgIHBpY2tNb2RlczogWzEgLyogTkVBUkVTVF9CWV9NQUlOX0FYSVNfRklSU1QgKi8sIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9dLFxuICAgICAgYW5pbWF0aW9uUmVzZXRGbnM6IHtcbiAgICAgICAgcGF0aDogYnVpbGRSZXNldFBhdGhGbih7IGdldFZpc2libGU6ICgpID0+IHRoaXMudmlzaWJsZSwgZ2V0T3BhY2l0eTogKCkgPT4gdGhpcy5nZXRPcGFjaXR5KCkgfSksXG4gICAgICAgIGxhYmVsOiByZXNldExhYmVsRm4sXG4gICAgICAgIG1hcmtlcjogKG5vZGUsIGRhdHVtKSA9PiAoeyAuLi5yZXNldE1hcmtlckZuKG5vZGUpLCAuLi5yZXNldE1hcmtlclBvc2l0aW9uRm4obm9kZSwgZGF0dW0pIH0pXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gbmV3IEFyZWFTZXJpZXNQcm9wZXJ0aWVzKCk7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0RhdGEoZGF0YUNvbnRyb2xsZXIpIHtcbiAgICBpZiAodGhpcy5kYXRhID09IG51bGwgfHwgIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBkYXRhLCB2aXNpYmxlLCBzZXJpZXNHcm91cGluZzogeyBncm91cEluZGV4ID0gdGhpcy5pZCwgc3RhY2tDb3VudCA9IDEgfSA9IHt9IH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgY29ubmVjdE1pc3NpbmdEYXRhLCBub3JtYWxpemVkVG8gfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBhbmltYXRpb25FbmFibGVkID0gIXRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgY29uc3QgeFNjYWxlID0gdGhpcy5heGVzW1wieFwiIC8qIFggKi9dPy5zY2FsZTtcbiAgICBjb25zdCB5U2NhbGUgPSB0aGlzLmF4ZXNbXCJ5XCIgLyogWSAqL10/LnNjYWxlO1xuICAgIGNvbnN0IHsgaXNDb250aW51b3VzWCwgeFNjYWxlVHlwZSwgeVNjYWxlVHlwZSB9ID0gdGhpcy5nZXRTY2FsZUluZm9ybWF0aW9uKHsgeFNjYWxlLCB5U2NhbGUgfSk7XG4gICAgY29uc3QgY3VycmVudElkcyA9IHtcbiAgICAgIHZhbHVlOiBgYXJlYS1zdGFjay0ke2dyb3VwSW5kZXh9LXlWYWx1ZWAsXG4gICAgICB2YWx1ZXM6IGBhcmVhLXN0YWNrLSR7Z3JvdXBJbmRleH0teVZhbHVlc2AsXG4gICAgICBzdGFjazogYGFyZWEtc3RhY2stJHtncm91cEluZGV4fS15VmFsdWUtc3RhY2tgLFxuICAgICAgbWFya2VyOiBgYXJlYS1zdGFjay0ke2dyb3VwSW5kZXh9LXlWYWx1ZXMtbWFya2VyYFxuICAgIH07XG4gICAgY29uc3QgZXh0cmFQcm9wcyA9IFtdO1xuICAgIGlmIChpc0RlZmluZWQobm9ybWFsaXplZFRvKSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKG5vcm1hbGlzZUdyb3VwVG8oT2JqZWN0LnZhbHVlcyhjdXJyZW50SWRzKSwgbm9ybWFsaXplZFRvLCBcInJhbmdlXCIpKTtcbiAgICB9XG4gICAgaWYgKCFpc0NvbnRpbnVvdXNYICYmIGFuaW1hdGlvbkVuYWJsZWQgJiYgdGhpcy5wcm9jZXNzZWREYXRhKSB7XG4gICAgICBleHRyYVByb3BzLnB1c2goZGlmZih0aGlzLnByb2Nlc3NlZERhdGEpKTtcbiAgICB9XG4gICAgaWYgKGFuaW1hdGlvbkVuYWJsZWQpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaChhbmltYXRpb25WYWxpZGF0aW9uKCkpO1xuICAgIH1cbiAgICBjb25zdCBjb21tb24gPSB7IGludmFsaWRWYWx1ZTogbnVsbCB9O1xuICAgIGlmIChjb25uZWN0TWlzc2luZ0RhdGEgJiYgc3RhY2tDb3VudCA+IDEpIHtcbiAgICAgIGNvbW1vbi5pbnZhbGlkVmFsdWUgPSAwO1xuICAgIH1cbiAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgIGNvbW1vbi5mb3JjZVZhbHVlID0gMDtcbiAgICB9XG4gICAgYXdhaXQgdGhpcy5yZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCBkYXRhLCB7XG4gICAgICBwcm9wczogW1xuICAgICAgICBrZXlQcm9wZXJ0eSh4S2V5LCB4U2NhbGVUeXBlLCB7IGlkOiBcInhWYWx1ZVwiIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KHlLZXksIHlTY2FsZVR5cGUsIHsgaWQ6IGB5VmFsdWVSYXdgLCAuLi5jb21tb24gfSksXG4gICAgICAgIC4uLmdyb3VwU3RhY2tWYWx1ZVByb3BlcnR5KHlLZXksIHlTY2FsZVR5cGUsIHtcbiAgICAgICAgICBpZDogYHlWYWx1ZVN0YWNrYCxcbiAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgZ3JvdXBJZDogY3VycmVudElkcy5zdGFja1xuICAgICAgICB9KSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eSh5S2V5LCB5U2NhbGVUeXBlLCB7XG4gICAgICAgICAgaWQ6IGB5VmFsdWVgLFxuICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICBncm91cElkOiBjdXJyZW50SWRzLnZhbHVlXG4gICAgICAgIH0pLFxuICAgICAgICAuLi5ncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoXG4gICAgICAgICAgeUtleSxcbiAgICAgICAgICBcIndpbmRvd1wiLFxuICAgICAgICAgIFwiY3VycmVudFwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkOiBgeVZhbHVlRW5kYCxcbiAgICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAgIGdyb3VwSWQ6IGN1cnJlbnRJZHMudmFsdWVzXG4gICAgICAgICAgfSxcbiAgICAgICAgICB5U2NhbGVUeXBlXG4gICAgICAgICksXG4gICAgICAgIC4uLmdyb3VwQWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShcbiAgICAgICAgICB5S2V5LFxuICAgICAgICAgIFwibm9ybWFsXCIsXG4gICAgICAgICAgXCJjdXJyZW50XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWQ6IGB5VmFsdWVDdW11bGF0aXZlYCxcbiAgICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAgIGdyb3VwSWQ6IGN1cnJlbnRJZHMubWFya2VyXG4gICAgICAgICAgfSxcbiAgICAgICAgICB5U2NhbGVUeXBlXG4gICAgICAgICksXG4gICAgICAgIC4uLmV4dHJhUHJvcHNcbiAgICAgIF0sXG4gICAgICBncm91cEJ5S2V5czogdHJ1ZSxcbiAgICAgIGdyb3VwQnlEYXRhOiBmYWxzZVxuICAgIH0pO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZURhdGFcIik7XG4gIH1cbiAgZ2V0U2VyaWVzRG9tYWluKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHsgcHJvY2Vzc2VkRGF0YSwgZGF0YU1vZGVsLCBheGVzIH0gPSB0aGlzO1xuICAgIGlmICghcHJvY2Vzc2VkRGF0YSB8fCAhZGF0YU1vZGVsIHx8IHByb2Nlc3NlZERhdGEuZGF0YS5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgeEF4aXMgPSBheGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBjb25zdCBrZXlEZWYgPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZCeUlkKHRoaXMsIGB4VmFsdWVgKTtcbiAgICBjb25zdCBrZXlzID0gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBgeFZhbHVlYCwgXCJrZXlcIiwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgY29uc3QgeUV4dGVudCA9IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgYHlWYWx1ZUVuZGAsIFwidmFsdWVcIiwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLykge1xuICAgICAgaWYgKGtleURlZj8uZGVmLnR5cGUgPT09IFwia2V5XCIgJiYga2V5RGVmLmRlZi52YWx1ZVR5cGUgPT09IFwiY2F0ZWdvcnlcIikge1xuICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KGV4dGVudChrZXlzKSwgeEF4aXMpO1xuICAgIH0gZWxzZSBpZiAoeUF4aXMgaW5zdGFuY2VvZiBMb2dBeGlzIHx8IHlBeGlzIGluc3RhbmNlb2YgVGltZUF4aXMpIHtcbiAgICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KHlFeHRlbnQsIHlBeGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZml4ZWRZRXh0ZW50ID0gW3lFeHRlbnRbMF0gPiAwID8gMCA6IHlFeHRlbnRbMF0sIHlFeHRlbnRbMV0gPCAwID8gMCA6IHlFeHRlbnRbMV1dO1xuICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoZml4ZWRZRXh0ZW50LCB5QXhpcyk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNyZWF0ZU5vZGVEYXRhKCkge1xuICAgIGNvbnN0IHsgYXhlcywgZGF0YSwgcHJvY2Vzc2VkRGF0YTogeyBkYXRhOiBncm91cGVkRGF0YSB9ID0ge30sIGRhdGFNb2RlbCB9ID0gdGhpcztcbiAgICBjb25zdCB4QXhpcyA9IGF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSBheGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGlmICgheEF4aXMgfHwgIXlBeGlzIHx8ICFkYXRhIHx8ICFkYXRhTW9kZWwgfHwgIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgeUtleSxcbiAgICAgIHhLZXksXG4gICAgICBtYXJrZXIsXG4gICAgICBsYWJlbCxcbiAgICAgIGZpbGw6IHNlcmllc0ZpbGwsXG4gICAgICBzdHJva2U6IHNlcmllc1N0cm9rZSxcbiAgICAgIGNvbm5lY3RNaXNzaW5nRGF0YVxuICAgIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBzY2FsZTogeFNjYWxlIH0gPSB4QXhpcztcbiAgICBjb25zdCB7IHNjYWxlOiB5U2NhbGUgfSA9IHlBeGlzO1xuICAgIGNvbnN0IHsgaXNDb250aW51b3VzWSB9ID0gdGhpcy5nZXRTY2FsZUluZm9ybWF0aW9uKHsgeFNjYWxlLCB5U2NhbGUgfSk7XG4gICAgY29uc3QgeE9mZnNldCA9ICh4U2NhbGUuYmFuZHdpZHRoID8/IDApIC8gMjtcbiAgICBjb25zdCBkZWZzID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhRGVmc0J5SWRzKHRoaXMsIFtgeVZhbHVlRW5kYCwgYHlWYWx1ZVJhd2AsIGB5VmFsdWVDdW11bGF0aXZlYF0pO1xuICAgIGNvbnN0IHlWYWx1ZVN0YWNrSW5kZXggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgXCJ5VmFsdWVTdGFja1wiKTtcbiAgICBjb25zdCBjcmVhdGVNYXJrZXJDb29yZGluYXRlID0gKHhEYXR1bSwgeUVuZCwgcmF3WURhdHVtKSA9PiB7XG4gICAgICBsZXQgY3Vyclk7XG4gICAgICBpZiAoaXNEZWZpbmVkKHRoaXMucHJvcGVydGllcy5ub3JtYWxpemVkVG8pID8gaXNDb250aW51b3VzWSAmJiBpc0NvbnRpbnVvdXMocmF3WURhdHVtKSA6ICFpc05hTihyYXdZRGF0dW0pKSB7XG4gICAgICAgIGN1cnJZID0geUVuZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHhTY2FsZS5jb252ZXJ0KHhEYXR1bSkgKyB4T2Zmc2V0LFxuICAgICAgICB5OiB5U2NhbGUuY29udmVydChjdXJyWSksXG4gICAgICAgIHNpemU6IG1hcmtlci5zaXplXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgaXRlbUlkID0geUtleTtcbiAgICBjb25zdCBsYWJlbERhdGEgPSBbXTtcbiAgICBjb25zdCBtYXJrZXJEYXRhID0gW107XG4gICAgY29uc3QgeyB2aXNpYmxlU2FtZVN0YWNrQ291bnQgfSA9IHRoaXMuY3R4LnNlcmllc1N0YXRlTWFuYWdlci5nZXRWaXNpYmxlUGVlckdyb3VwSW5kZXgodGhpcyk7XG4gICAgbGV0IGRhdHVtSWR4ID0gLTE7XG4gICAgZ3JvdXBlZERhdGE/LmZvckVhY2goKGRhdHVtR3JvdXApID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAga2V5cyxcbiAgICAgICAga2V5czogW3hEYXR1bV0sXG4gICAgICAgIGRhdHVtOiBkYXR1bUFycmF5LFxuICAgICAgICB2YWx1ZXM6IHZhbHVlc0FycmF5XG4gICAgICB9ID0gZGF0dW1Hcm91cDtcbiAgICAgIHZhbHVlc0FycmF5LmZvckVhY2goKHZhbHVlcywgdmFsdWVJZHgpID0+IHtcbiAgICAgICAgZGF0dW1JZHgrKztcbiAgICAgICAgY29uc3Qgc2VyaWVzRGF0dW0gPSBkYXR1bUFycmF5W3ZhbHVlSWR4XTtcbiAgICAgICAgY29uc3QgZGF0YVZhbHVlczIgPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZzVmFsdWVzKGRlZnMsIHsga2V5cywgdmFsdWVzIH0pO1xuICAgICAgICBjb25zdCB7IHlWYWx1ZVJhdzogeURhdHVtLCB5VmFsdWVDdW11bGF0aXZlLCB5VmFsdWVFbmQgfSA9IGRhdGFWYWx1ZXMyO1xuICAgICAgICBjb25zdCB2YWxpZFBvaW50ID0gTnVtYmVyLmlzRmluaXRlKHlEYXR1bSk7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gY3JlYXRlTWFya2VyQ29vcmRpbmF0ZSh4RGF0dW0sICt5VmFsdWVDdW11bGF0aXZlLCB5RGF0dW0pO1xuICAgICAgICBpZiAodmFsaWRQb2ludCAmJiBtYXJrZXIpIHtcbiAgICAgICAgICBtYXJrZXJEYXRhLnB1c2goe1xuICAgICAgICAgICAgaW5kZXg6IGRhdHVtSWR4LFxuICAgICAgICAgICAgc2VyaWVzOiB0aGlzLFxuICAgICAgICAgICAgaXRlbUlkLFxuICAgICAgICAgICAgZGF0dW06IHNlcmllc0RhdHVtLFxuICAgICAgICAgICAgbWlkUG9pbnQ6IHsgeDogcG9pbnQueCwgeTogcG9pbnQueSB9LFxuICAgICAgICAgICAgY3VtdWxhdGl2ZVZhbHVlOiB5VmFsdWVFbmQsXG4gICAgICAgICAgICB5VmFsdWU6IHlEYXR1bSxcbiAgICAgICAgICAgIHhWYWx1ZTogeERhdHVtLFxuICAgICAgICAgICAgeUtleSxcbiAgICAgICAgICAgIHhLZXksXG4gICAgICAgICAgICBwb2ludCxcbiAgICAgICAgICAgIGZpbGw6IG1hcmtlci5maWxsID8/IHNlcmllc0ZpbGwsXG4gICAgICAgICAgICBzdHJva2U6IG1hcmtlci5zdHJva2UgPz8gc2VyaWVzU3Ryb2tlLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IG1hcmtlci5zdHJva2VXaWR0aCA/PyB0aGlzLmdldFN0cm9rZVdpZHRoKHRoaXMucHJvcGVydGllcy5zdHJva2VXaWR0aClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsaWRQb2ludCAmJiBsYWJlbCkge1xuICAgICAgICAgIGNvbnN0IGxhYmVsVGV4dCA9IHRoaXMuZ2V0TGFiZWxUZXh0KFxuICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhbHVlOiB5RGF0dW0sXG4gICAgICAgICAgICAgIGRhdHVtOiBzZXJpZXNEYXR1bSxcbiAgICAgICAgICAgICAgeEtleSxcbiAgICAgICAgICAgICAgeUtleSxcbiAgICAgICAgICAgICAgeE5hbWU6IHRoaXMucHJvcGVydGllcy54TmFtZSxcbiAgICAgICAgICAgICAgeU5hbWU6IHRoaXMucHJvcGVydGllcy55TmFtZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICh2YWx1ZSkgPT4gaXNGaW5pdGVOdW1iZXIodmFsdWUpID8gdmFsdWUudG9GaXhlZCgyKSA6IFN0cmluZyh2YWx1ZSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGxhYmVsRGF0YS5wdXNoKHtcbiAgICAgICAgICAgIGluZGV4OiBkYXR1bUlkeCxcbiAgICAgICAgICAgIHNlcmllczogdGhpcyxcbiAgICAgICAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgICAgICAgIGRhdHVtOiBzZXJpZXNEYXR1bSxcbiAgICAgICAgICAgIHg6IHBvaW50LngsXG4gICAgICAgICAgICB5OiBwb2ludC55LFxuICAgICAgICAgICAgbGFiZWw6IGxhYmVsVGV4dCA/IHtcbiAgICAgICAgICAgICAgdGV4dDogbGFiZWxUZXh0LFxuICAgICAgICAgICAgICBmb250U3R5bGU6IGxhYmVsLmZvbnRTdHlsZSxcbiAgICAgICAgICAgICAgZm9udFdlaWdodDogbGFiZWwuZm9udFdlaWdodCxcbiAgICAgICAgICAgICAgZm9udFNpemU6IGxhYmVsLmZvbnRTaXplLFxuICAgICAgICAgICAgICBmb250RmFtaWx5OiBsYWJlbC5mb250RmFtaWx5LFxuICAgICAgICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgICAgICAgIHRleHRCYXNlbGluZTogXCJib3R0b21cIixcbiAgICAgICAgICAgICAgZmlsbDogbGFiZWwuY29sb3JcbiAgICAgICAgICAgIH0gOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3QgeyBpbnRlcnBvbGF0aW9uIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgaW50ZXJwb2xhdGVQb2ludHMgPSAocG9pbnRzKSA9PiB7XG4gICAgICBsZXQgc3BhbnM7XG4gICAgICBjb25zdCBwb2ludHNJdGVyID0gcG9pbnRzLm1hcCgocG9pbnQpID0+IHBvaW50LnBvaW50KTtcbiAgICAgIHN3aXRjaCAoaW50ZXJwb2xhdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJsaW5lYXJcIjpcbiAgICAgICAgICBzcGFucyA9IGxpbmVhclBvaW50cyhwb2ludHNJdGVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNtb290aFwiOlxuICAgICAgICAgIHNwYW5zID0gc21vb3RoUG9pbnRzKHBvaW50c0l0ZXIsIGludGVycG9sYXRpb24udGVuc2lvbik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdGVwXCI6XG4gICAgICAgICAgc3BhbnMgPSBzdGVwUG9pbnRzKHBvaW50c0l0ZXIsIGludGVycG9sYXRpb24ucG9zaXRpb24pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNwYW5zLm1hcCgoc3BhbiwgaSkgPT4gKHtcbiAgICAgICAgc3BhbixcbiAgICAgICAgeFZhbHVlMDogcG9pbnRzW2ldLnhEYXR1bSxcbiAgICAgICAgeVZhbHVlMDogcG9pbnRzW2ldLnlEYXR1bSxcbiAgICAgICAgeFZhbHVlMTogcG9pbnRzW2kgKyAxXS54RGF0dW0sXG4gICAgICAgIHlWYWx1ZTE6IHBvaW50c1tpICsgMV0ueURhdHVtXG4gICAgICB9KSk7XG4gICAgfTtcbiAgICBjb25zdCBzcGFuc0ZvclBvaW50cyA9IChwb2ludHMpID0+IHtcbiAgICAgIHJldHVybiBwb2ludHMuZmxhdE1hcCgocCkgPT4ge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwKSA/IGludGVycG9sYXRlUG9pbnRzKHApIDogbmV3IEFycmF5KHAuc2tpcCkuZmlsbChudWxsKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgZGF0YVZhbHVlcyA9IGdyb3VwZWREYXRhPy5mbGF0TWFwKChkYXR1bUdyb3VwKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGtleXM6IFt4RGF0dW1dLFxuICAgICAgICB2YWx1ZXM6IHZhbHVlc0FycmF5XG4gICAgICB9ID0gZGF0dW1Hcm91cDtcbiAgICAgIHJldHVybiB2YWx1ZXNBcnJheS5tYXAoKHZhbHVlcykgPT4gKHsgeERhdHVtLCB2YWx1ZXMgfSkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGNyZWF0ZVBvaW50ID0gKHhEYXR1bSwgeURhdHVtKSA9PiAoe1xuICAgICAgcG9pbnQ6IHtcbiAgICAgICAgeDogeFNjYWxlLmNvbnZlcnQoeERhdHVtKSArIHhPZmZzZXQsXG4gICAgICAgIHk6IHlTY2FsZS5jb252ZXJ0KHlEYXR1bSlcbiAgICAgIH0sXG4gICAgICB4RGF0dW0sXG4gICAgICB5RGF0dW1cbiAgICB9KTtcbiAgICBjb25zdCBnZXRTZXJpZXNTcGFucyA9IChpbmRleCkgPT4ge1xuICAgICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgICBpZiAoZGF0YVZhbHVlcyA9PSBudWxsKVxuICAgICAgICByZXR1cm4gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGFWYWx1ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgeyB4RGF0dW0sIHZhbHVlcyB9ID0gZGF0YVZhbHVlc1tpXTtcbiAgICAgICAgY29uc3QgeVZhbHVlU3RhY2sgPSB2YWx1ZXNbeVZhbHVlU3RhY2tJbmRleF07XG4gICAgICAgIGNvbnN0IHlEYXR1bSA9IHlWYWx1ZVN0YWNrW2luZGV4XTtcbiAgICAgICAgY29uc3QgeURhdHVtSXNGaW5pdGUgPSBOdW1iZXIuaXNGaW5pdGUoeURhdHVtKTtcbiAgICAgICAgaWYgKGNvbm5lY3RNaXNzaW5nRGF0YSAmJiAheURhdHVtSXNGaW5pdGUpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGxhc3RZVmFsdWVTdGFjayA9IGRhdGFWYWx1ZXNbaSAtIDFdPy52YWx1ZXNbeVZhbHVlU3RhY2tJbmRleF07XG4gICAgICAgIGNvbnN0IG5leHRZVmFsdWVTdGFjayA9IGRhdGFWYWx1ZXNbaSArIDFdPy52YWx1ZXNbeVZhbHVlU3RhY2tJbmRleF07XG4gICAgICAgIGxldCB5VmFsdWVFbmRCYWNrd2FyZHMgPSAwO1xuICAgICAgICBsZXQgeVZhbHVlRW5kRm9yd2FyZHMgPSAwO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8PSBpbmRleDsgaiArPSAxKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSB5VmFsdWVTdGFja1tqXTtcbiAgICAgICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgbGFzdFdhc0Zpbml0ZSA9IGxhc3RZVmFsdWVTdGFjayA9PSBudWxsIHx8IE51bWJlci5pc0Zpbml0ZShsYXN0WVZhbHVlU3RhY2tbal0pO1xuICAgICAgICAgICAgY29uc3QgbmV4dFdhc0Zpbml0ZSA9IG5leHRZVmFsdWVTdGFjayA9PSBudWxsIHx8IE51bWJlci5pc0Zpbml0ZShuZXh0WVZhbHVlU3RhY2tbal0pO1xuICAgICAgICAgICAgaWYgKGxhc3RXYXNGaW5pdGUpIHtcbiAgICAgICAgICAgICAgeVZhbHVlRW5kQmFja3dhcmRzICs9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5leHRXYXNGaW5pdGUpIHtcbiAgICAgICAgICAgICAgeVZhbHVlRW5kRm9yd2FyZHMgKz0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQb2ludHMgPSBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoIWNvbm5lY3RNaXNzaW5nRGF0YSAmJiAoeVZhbHVlRW5kQmFja3dhcmRzICE9PSB5VmFsdWVFbmRGb3J3YXJkcyB8fCAheURhdHVtSXNGaW5pdGUpKSB7XG4gICAgICAgICAgaWYgKCF5RGF0dW1Jc0Zpbml0ZSAmJiBBcnJheS5pc0FycmF5KGN1cnJlbnRQb2ludHMpICYmIGN1cnJlbnRQb2ludHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdID0geyBza2lwOiAxIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50QmFja3dhcmRzID0gY3JlYXRlUG9pbnQoeERhdHVtLCB5VmFsdWVFbmRCYWNrd2FyZHMpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRGb3J3YXJkcyA9IGNyZWF0ZVBvaW50KHhEYXR1bSwgeVZhbHVlRW5kRm9yd2FyZHMpO1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudFBvaW50cykpIHtcbiAgICAgICAgICAgICAgY3VycmVudFBvaW50cy5wdXNoKHBvaW50QmFja3dhcmRzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFBvaW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRQb2ludHMuc2tpcCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRzLnB1c2goeURhdHVtSXNGaW5pdGUgPyBbcG9pbnRGb3J3YXJkc10gOiB7IHNraXA6IDAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHlWYWx1ZUVuZCA9IE1hdGgubWF4KHlWYWx1ZUVuZEJhY2t3YXJkcywgeVZhbHVlRW5kRm9yd2FyZHMpO1xuICAgICAgICAgIGNvbnN0IHBvaW50ID0gY3JlYXRlUG9pbnQoeERhdHVtLCB5VmFsdWVFbmQpO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRQb2ludHMpKSB7XG4gICAgICAgICAgICBjdXJyZW50UG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFBvaW50cyAhPSBudWxsKSB7XG4gICAgICAgICAgICBjdXJyZW50UG9pbnRzLnNraXAgKz0gMTtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKFtwb2ludF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb2ludHMucHVzaChbcG9pbnRdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzcGFuc0ZvclBvaW50cyhwb2ludHMpO1xuICAgIH07XG4gICAgY29uc3Qgc3RhY2tJbmRleCA9IHRoaXMuc2VyaWVzR3JvdXBpbmc/LnN0YWNrSW5kZXggPz8gMDtcbiAgICBjb25zdCBnZXRBeGlzU3BhbnMgPSAoKSA9PiB7XG4gICAgICBpZiAoZGF0YVZhbHVlcyA9PSBudWxsKVxuICAgICAgICByZXR1cm4gW107XG4gICAgICBjb25zdCB5VmFsdWVaZXJvUG9pbnRzID0gZGF0YVZhbHVlcy5tYXAoKHsgeERhdHVtLCB2YWx1ZXMgfSkgPT4ge1xuICAgICAgICBjb25zdCB5VmFsdWVTdGFjayA9IHZhbHVlc1t5VmFsdWVTdGFja0luZGV4XTtcbiAgICAgICAgY29uc3QgeURhdHVtID0geVZhbHVlU3RhY2tbc3RhY2tJbmRleF07XG4gICAgICAgIGlmIChjb25uZWN0TWlzc2luZ0RhdGEgJiYgIU51bWJlci5pc0Zpbml0ZSh5RGF0dW0pKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBvaW50KHhEYXR1bSwgMCk7XG4gICAgICB9KS5maWx0ZXIoKHgpID0+IHggIT0gbnVsbCk7XG4gICAgICByZXR1cm4gaW50ZXJwb2xhdGVQb2ludHMoeVZhbHVlWmVyb1BvaW50cyk7XG4gICAgfTtcbiAgICBjb25zdCBjdXJyZW50U2VyaWVzU3BhbnMgPSBnZXRTZXJpZXNTcGFucyhzdGFja0luZGV4KTtcbiAgICBjb25zdCBwaGFudG9tU3BhbnMgPSBjdXJyZW50U2VyaWVzU3BhbnMubWFwKCgpID0+IG51bGwpO1xuICAgIGZvciAobGV0IGogPSBzdGFja0luZGV4IC0gMTsgaiA+PSAtMTsgaiAtPSAxKSB7XG4gICAgICBsZXQgc3BhbnM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBoYW50b21TcGFucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAocGhhbnRvbVNwYW5zW2ldICE9IG51bGwpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIHNwYW5zID8/IChzcGFucyA9IGogIT09IC0xID8gZ2V0U2VyaWVzU3BhbnMoaikgOiBnZXRBeGlzU3BhbnMoKSk7XG4gICAgICAgIHBoYW50b21TcGFuc1tpXSA9IHNwYW5zW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmaWxsU3BhbnMgPSBjdXJyZW50U2VyaWVzU3BhbnMubWFwKChzcGFuLCBpbmRleCkgPT4gc3BhbiA/PyBwaGFudG9tU3BhbnNbaW5kZXhdKTtcbiAgICBjb25zdCBzdHJva2VTcGFucyA9IGN1cnJlbnRTZXJpZXNTcGFucy5maWx0ZXIoKHNwYW4pID0+IHNwYW4gIT0gbnVsbCk7XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgIGl0ZW1JZCxcbiAgICAgIGZpbGxEYXRhOiB7IGl0ZW1JZCwgc3BhbnM6IGZpbGxTcGFucywgcGhhbnRvbVNwYW5zIH0sXG4gICAgICBzdHJva2VEYXRhOiB7IGl0ZW1JZCwgc3BhbnM6IHN0cm9rZVNwYW5zIH0sXG4gICAgICBsYWJlbERhdGEsXG4gICAgICBub2RlRGF0YTogbWFya2VyRGF0YSxcbiAgICAgIHNjYWxlczogdGhpcy5jYWxjdWxhdGVTY2FsaW5nKCksXG4gICAgICB2aXNpYmxlOiB0aGlzLnZpc2libGUsXG4gICAgICBzdGFja1Zpc2libGU6IHZpc2libGVTYW1lU3RhY2tDb3VudCA+IDBcbiAgICB9O1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG4gIGlzUGF0aE9yU2VsZWN0aW9uRGlydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5tYXJrZXIuaXNEaXJ0eSgpO1xuICB9XG4gIG1hcmtlckZhY3RvcnkoKSB7XG4gICAgY29uc3QgeyBzaGFwZSB9ID0gdGhpcy5wcm9wZXJ0aWVzLm1hcmtlcjtcbiAgICBjb25zdCBNYXJrZXJTaGFwZSA9IGdldE1hcmtlcihzaGFwZSk7XG4gICAgcmV0dXJuIG5ldyBNYXJrZXJTaGFwZSgpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVBhdGhOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBvcGFjaXR5LCB2aXNpYmxlLCBhbmltYXRpb25FbmFibGVkIH0gPSBvcHRzO1xuICAgIGNvbnN0IFtmaWxsLCBzdHJva2VdID0gb3B0cy5wYXRocztcbiAgICBjb25zdCBzdHJva2VXaWR0aCA9IHRoaXMuZ2V0U3Ryb2tlV2lkdGgodGhpcy5wcm9wZXJ0aWVzLnN0cm9rZVdpZHRoKTtcbiAgICBzdHJva2Uuc2V0UHJvcGVydGllcyh7XG4gICAgICB0YWc6IDEgLyogU3Ryb2tlICovLFxuICAgICAgZmlsbDogdm9pZCAwLFxuICAgICAgbGluZUpvaW46IHN0cm9rZS5saW5lQ2FwID0gXCJyb3VuZFwiLFxuICAgICAgcG9pbnRlckV2ZW50czogMSAvKiBOb25lICovLFxuICAgICAgc3Ryb2tlOiB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VPcGFjaXR5OiB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlT3BhY2l0eSxcbiAgICAgIGxpbmVEYXNoOiB0aGlzLnByb3BlcnRpZXMubGluZURhc2gsXG4gICAgICBsaW5lRGFzaE9mZnNldDogdGhpcy5wcm9wZXJ0aWVzLmxpbmVEYXNoT2Zmc2V0LFxuICAgICAgb3BhY2l0eSxcbiAgICAgIHZpc2libGVcbiAgICB9KTtcbiAgICBmaWxsLnNldFByb3BlcnRpZXMoe1xuICAgICAgdGFnOiAwIC8qIEZpbGwgKi8sXG4gICAgICBzdHJva2U6IHZvaWQgMCxcbiAgICAgIGxpbmVKb2luOiBcInJvdW5kXCIsXG4gICAgICBwb2ludGVyRXZlbnRzOiAxIC8qIE5vbmUgKi8sXG4gICAgICBmaWxsOiB0aGlzLnByb3BlcnRpZXMuZmlsbCxcbiAgICAgIGZpbGxPcGFjaXR5OiB0aGlzLnByb3BlcnRpZXMuZmlsbE9wYWNpdHksXG4gICAgICBsaW5lRGFzaDogdGhpcy5wcm9wZXJ0aWVzLmxpbmVEYXNoLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IHRoaXMucHJvcGVydGllcy5saW5lRGFzaE9mZnNldCxcbiAgICAgIHN0cm9rZU9wYWNpdHk6IHRoaXMucHJvcGVydGllcy5zdHJva2VPcGFjaXR5LFxuICAgICAgZmlsbFNoYWRvdzogdGhpcy5wcm9wZXJ0aWVzLnNoYWRvdyxcbiAgICAgIG9wYWNpdHksXG4gICAgICB2aXNpYmxlOiB2aXNpYmxlIHx8IGFuaW1hdGlvbkVuYWJsZWQsXG4gICAgICBzdHJva2VXaWR0aFxuICAgIH0pO1xuICAgIHVwZGF0ZUNsaXBQYXRoKHRoaXMsIHN0cm9rZSk7XG4gICAgdXBkYXRlQ2xpcFBhdGgodGhpcywgZmlsbCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlUGF0aHMob3B0cykge1xuICAgIHRoaXMudXBkYXRlQXJlYVBhdGhzKG9wdHMucGF0aHMsIG9wdHMuY29udGV4dERhdGEpO1xuICB9XG4gIHVwZGF0ZUFyZWFQYXRocyhwYXRocywgY29udGV4dERhdGEpIHtcbiAgICB0aGlzLnVwZGF0ZUZpbGxQYXRoKHBhdGhzLCBjb250ZXh0RGF0YSk7XG4gICAgdGhpcy51cGRhdGVTdHJva2VQYXRoKHBhdGhzLCBjb250ZXh0RGF0YSk7XG4gIH1cbiAgdXBkYXRlRmlsbFBhdGgocGF0aHMsIGNvbnRleHREYXRhKSB7XG4gICAgY29uc3QgeyBzcGFucywgcGhhbnRvbVNwYW5zIH0gPSBjb250ZXh0RGF0YS5maWxsRGF0YTtcbiAgICBjb25zdCBbZmlsbF0gPSBwYXRocztcbiAgICBjb25zdCB7IHBhdGggfSA9IGZpbGw7XG4gICAgcGF0aC5jbGVhcih0cnVlKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCB7IHNwYW4gfSA9IHNwYW5zW2ldO1xuICAgICAgY29uc3QgcGhhbnRvbVNwYW4gPSBwaGFudG9tU3BhbnNbaV0uc3BhbjtcbiAgICAgIHBsb3RTcGFuKHBhdGgsIHNwYW4sIDEgLyogTW92ZVRvICovKTtcbiAgICAgIHBsb3RTcGFuKHBhdGgsIHJldmVyc2VTcGFuKHBoYW50b21TcGFuKSwgMiAvKiBMaW5lVG8gKi8pO1xuICAgICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gICAgZmlsbC5jaGVja1BhdGhEaXJ0eSgpO1xuICB9XG4gIHVwZGF0ZVN0cm9rZVBhdGgocGF0aHMsIGNvbnRleHREYXRhKSB7XG4gICAgY29uc3QgeyBzcGFucyB9ID0gY29udGV4dERhdGEuc3Ryb2tlRGF0YTtcbiAgICBjb25zdCBbLCBzdHJva2VdID0gcGF0aHM7XG4gICAgY29uc3QgeyBwYXRoIH0gPSBzdHJva2U7XG4gICAgcGF0aC5jbGVhcih0cnVlKTtcbiAgICBmb3IgKGNvbnN0IHsgc3BhbiB9IG9mIHNwYW5zKSB7XG4gICAgICBwbG90U3BhbihwYXRoLCBzcGFuKTtcbiAgICB9XG4gICAgc3Ryb2tlLmNoZWNrUGF0aERpcnR5KCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTWFya2VyU2VsZWN0aW9uKG9wdHMpIHtcbiAgICBjb25zdCB7IG5vZGVEYXRhLCBtYXJrZXJTZWxlY3Rpb24gfSA9IG9wdHM7XG4gICAgaWYgKHRoaXMucHJvcGVydGllcy5tYXJrZXIuaXNEaXJ0eSgpKSB7XG4gICAgICBtYXJrZXJTZWxlY3Rpb24uY2xlYXIoKTtcbiAgICAgIG1hcmtlclNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXJTZWxlY3Rpb24udXBkYXRlKHRoaXMucHJvcGVydGllcy5tYXJrZXIuZW5hYmxlZCA/IG5vZGVEYXRhIDogW10pO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU1hcmtlck5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbiwgaXNIaWdobGlnaHQ6IGhpZ2hsaWdodGVkIH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgbWFya2VyLCBmaWxsLCBzdHJva2UsIHN0cm9rZVdpZHRoLCBmaWxsT3BhY2l0eSwgc3Ryb2tlT3BhY2l0eSwgaGlnaGxpZ2h0U3R5bGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBiYXNlU3R5bGUgPSBtZXJnZURlZmF1bHRzKGhpZ2hsaWdodGVkICYmIGhpZ2hsaWdodFN0eWxlLml0ZW0sIG1hcmtlci5nZXRTdHlsZSgpLCB7XG4gICAgICBmaWxsLFxuICAgICAgc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICBmaWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZU9wYWNpdHlcbiAgICB9KTtcbiAgICBtYXJrZXJTZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0pID0+IHtcbiAgICAgIHRoaXMudXBkYXRlTWFya2VyU3R5bGUobm9kZSwgbWFya2VyLCB7IGRhdHVtLCBoaWdobGlnaHRlZCwgeEtleSwgeUtleSB9LCBiYXNlU3R5bGUpO1xuICAgIH0pO1xuICAgIGlmICghaGlnaGxpZ2h0ZWQpIHtcbiAgICAgIHRoaXMucHJvcGVydGllcy5tYXJrZXIubWFya0NsZWFuKCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHVwZGF0ZUxhYmVsU2VsZWN0aW9uKG9wdHMpIHtcbiAgICBjb25zdCB7IGxhYmVsRGF0YSwgbGFiZWxTZWxlY3Rpb24gfSA9IG9wdHM7XG4gICAgcmV0dXJuIGxhYmVsU2VsZWN0aW9uLnVwZGF0ZShsYWJlbERhdGEsICh0ZXh0KSA9PiB7XG4gICAgICB0ZXh0LnRhZyA9IDMgLyogTGFiZWwgKi87XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTGFiZWxOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBsYWJlbFNlbGVjdGlvbiB9ID0gb3B0cztcbiAgICBjb25zdCB7IGVuYWJsZWQ6IGxhYmVsRW5hYmxlZCwgZm9udFN0eWxlLCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSwgY29sb3IgfSA9IHRoaXMucHJvcGVydGllcy5sYWJlbDtcbiAgICBsYWJlbFNlbGVjdGlvbi5lYWNoKCh0ZXh0LCBkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgeyB4LCB5LCBsYWJlbCB9ID0gZGF0dW07XG4gICAgICBpZiAobGFiZWwgJiYgbGFiZWxFbmFibGVkICYmIHRoaXMudmlzaWJsZSkge1xuICAgICAgICB0ZXh0LmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICAgICAgdGV4dC5mb250V2VpZ2h0ID0gZm9udFdlaWdodDtcbiAgICAgICAgdGV4dC5mb250U2l6ZSA9IGZvbnRTaXplO1xuICAgICAgICB0ZXh0LmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgICAgICB0ZXh0LnRleHRBbGlnbiA9IGxhYmVsLnRleHRBbGlnbjtcbiAgICAgICAgdGV4dC50ZXh0QmFzZWxpbmUgPSBsYWJlbC50ZXh0QmFzZWxpbmU7XG4gICAgICAgIHRleHQudGV4dCA9IGxhYmVsLnRleHQ7XG4gICAgICAgIHRleHQueCA9IHg7XG4gICAgICAgIHRleHQueSA9IHkgLSAxMDtcbiAgICAgICAgdGV4dC5maWxsID0gY29sb3I7XG4gICAgICAgIHRleHQudmlzaWJsZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0LnZpc2libGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRUb29sdGlwSHRtbChub2RlRGF0dW0pIHtcbiAgICBjb25zdCB7IGlkOiBzZXJpZXNJZCwgYXhlcywgZGF0YU1vZGVsIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgeEtleSwgeE5hbWUsIHlOYW1lLCB0b29sdGlwLCBtYXJrZXIgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IHlLZXksIHhWYWx1ZSwgeVZhbHVlLCBkYXR1bSwgaXRlbUlkIH0gPSBub2RlRGF0dW07XG4gICAgY29uc3QgeEF4aXMgPSBheGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgISh4QXhpcyAmJiB5QXhpcyAmJiBpc0Zpbml0ZU51bWJlcih5VmFsdWUpKSB8fCAhZGF0YU1vZGVsKSB7XG4gICAgICByZXR1cm4gRU1QVFlfVE9PTFRJUF9DT05URU5UO1xuICAgIH1cbiAgICBjb25zdCB4U3RyaW5nID0geEF4aXMuZm9ybWF0RGF0dW0oeFZhbHVlKTtcbiAgICBjb25zdCB5U3RyaW5nID0geUF4aXMuZm9ybWF0RGF0dW0oeVZhbHVlKTtcbiAgICBjb25zdCB0aXRsZSA9IHNhbml0aXplSHRtbCh5TmFtZSk7XG4gICAgY29uc3QgY29udGVudCA9IHNhbml0aXplSHRtbCh4U3RyaW5nICsgXCI6IFwiICsgeVN0cmluZyk7XG4gICAgY29uc3QgYmFzZVN0eWxlID0gbWVyZ2VEZWZhdWx0cyh7IGZpbGw6IHRoaXMucHJvcGVydGllcy5maWxsIH0sIG1hcmtlci5nZXRTdHlsZSgpLCB7XG4gICAgICBzdHJva2U6IHRoaXMucHJvcGVydGllcy5zdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZVdpZHRoXG4gICAgfSk7XG4gICAgY29uc3QgeyBmaWxsOiBjb2xvciB9ID0gdGhpcy5nZXRNYXJrZXJTdHlsZShcbiAgICAgIG1hcmtlcixcbiAgICAgIHsgZGF0dW06IG5vZGVEYXR1bSwgeEtleSwgeUtleSwgaGlnaGxpZ2h0ZWQ6IGZhbHNlIH0sXG4gICAgICBiYXNlU3R5bGVcbiAgICApO1xuICAgIHJldHVybiB0b29sdGlwLnRvVG9vbHRpcEh0bWwoXG4gICAgICB7IHRpdGxlLCBjb250ZW50LCBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yIH0sXG4gICAgICB7XG4gICAgICAgIGRhdHVtLFxuICAgICAgICBpdGVtSWQsXG4gICAgICAgIHhLZXksXG4gICAgICAgIHhOYW1lLFxuICAgICAgICB5S2V5LFxuICAgICAgICB5TmFtZSxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHRpdGxlLFxuICAgICAgICBzZXJpZXNJZFxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgZ2V0TGVnZW5kRGF0YShsZWdlbmRUeXBlKSB7XG4gICAgaWYgKCF0aGlzLmRhdGE/Lmxlbmd0aCB8fCAhdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCAhdGhpcy5wcm9wZXJ0aWVzLnNob3dJbkxlZ2VuZCB8fCBsZWdlbmRUeXBlICE9PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgeUtleSxcbiAgICAgIHlOYW1lLFxuICAgICAgZmlsbCxcbiAgICAgIHN0cm9rZSxcbiAgICAgIGZpbGxPcGFjaXR5LFxuICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgbGluZURhc2gsXG4gICAgICBtYXJrZXIsXG4gICAgICB2aXNpYmxlLFxuICAgICAgbGVnZW5kSXRlbU5hbWVcbiAgICB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHVzZUFyZWFGaWxsID0gIW1hcmtlci5lbmFibGVkIHx8IG1hcmtlci5maWxsID09PSB2b2lkIDA7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgbGVnZW5kVHlwZSxcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIGVuYWJsZWQ6IHZpc2libGUsXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgdGV4dDogbGVnZW5kSXRlbU5hbWUgPz8geU5hbWUgPz8geUtleVxuICAgICAgICB9LFxuICAgICAgICBzeW1ib2xzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgIHNoYXBlOiBtYXJrZXIuc2hhcGUsXG4gICAgICAgICAgICAgIGZpbGw6IHVzZUFyZWFGaWxsID8gZmlsbCA6IG1hcmtlci5maWxsLFxuICAgICAgICAgICAgICBmaWxsT3BhY2l0eTogdXNlQXJlYUZpbGwgPyBmaWxsT3BhY2l0eSA6IG1hcmtlci5maWxsT3BhY2l0eSxcbiAgICAgICAgICAgICAgc3Ryb2tlOiBtYXJrZXIuc3Ryb2tlID8/IHN0cm9rZSxcbiAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogbWFya2VyLnN0cm9rZU9wYWNpdHkgPz8gc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IG1hcmtlci5zdHJva2VXaWR0aCA/PyAwLFxuICAgICAgICAgICAgICBlbmFibGVkOiBtYXJrZXIuZW5hYmxlZCB8fCBzdHJva2VXaWR0aCA8PSAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZToge1xuICAgICAgICAgICAgICBzdHJva2UsXG4gICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgICBsaW5lRGFzaFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgbGVnZW5kSXRlbU5hbWVcbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGFuaW1hdGlvbkRhdGEpIHtcbiAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbiwgbGFiZWxTZWxlY3Rpb24sIGNvbnRleHREYXRhLCBwYXRocyB9ID0gYW5pbWF0aW9uRGF0YTtcbiAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIHRoaXMudXBkYXRlQXJlYVBhdGhzKHBhdGhzLCBjb250ZXh0RGF0YSk7XG4gICAgcGF0aFN3aXBlSW5BbmltYXRpb24odGhpcywgYW5pbWF0aW9uTWFuYWdlciwgLi4ucGF0aHMpO1xuICAgIHJlc2V0TW90aW9uKFttYXJrZXJTZWxlY3Rpb25dLCByZXNldE1hcmtlclBvc2l0aW9uRm4pO1xuICAgIG1hcmtlclN3aXBlU2NhbGVJbkFuaW1hdGlvbih0aGlzLCBhbmltYXRpb25NYW5hZ2VyLCBtYXJrZXJTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9uKTtcbiAgfVxuICBhbmltYXRlUmVhZHlSZXNpemUoYW5pbWF0aW9uRGF0YSkge1xuICAgIGNvbnN0IHsgY29udGV4dERhdGEsIHBhdGhzIH0gPSBhbmltYXRpb25EYXRhO1xuICAgIHRoaXMudXBkYXRlQXJlYVBhdGhzKHBhdGhzLCBjb250ZXh0RGF0YSk7XG4gICAgc3VwZXIuYW5pbWF0ZVJlYWR5UmVzaXplKGFuaW1hdGlvbkRhdGEpO1xuICB9XG4gIGFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoYW5pbWF0aW9uRGF0YSkge1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgeyBtYXJrZXJTZWxlY3Rpb24sIGxhYmVsU2VsZWN0aW9uLCBjb250ZXh0RGF0YSwgcGF0aHMsIHByZXZpb3VzQ29udGV4dERhdGEgfSA9IGFuaW1hdGlvbkRhdGE7XG4gICAgY29uc3QgW2ZpbGwsIHN0cm9rZV0gPSBwYXRocztcbiAgICBpZiAoZmlsbCA9PSBudWxsICYmIHN0cm9rZSA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMucmVzZXRNYXJrZXJBbmltYXRpb24oYW5pbWF0aW9uRGF0YSk7XG4gICAgdGhpcy5yZXNldExhYmVsQW5pbWF0aW9uKGFuaW1hdGlvbkRhdGEpO1xuICAgIGNvbnN0IHVwZGF0ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMucmVzZXRQYXRoQW5pbWF0aW9uKGFuaW1hdGlvbkRhdGEpO1xuICAgICAgdGhpcy51cGRhdGVBcmVhUGF0aHMocGF0aHMsIGNvbnRleHREYXRhKTtcbiAgICAgIHRoaXMudXBkYXRlU3Ryb2tlUGF0aChwYXRocywgY29udGV4dERhdGEpO1xuICAgIH07XG4gICAgY29uc3Qgc2tpcCA9ICgpID0+IHtcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgICAgdXBkYXRlKCk7XG4gICAgfTtcbiAgICBpZiAoY29udGV4dERhdGEgPT0gbnVsbCB8fCBwcmV2aW91c0NvbnRleHREYXRhID09IG51bGwpIHtcbiAgICAgIHVwZGF0ZSgpO1xuICAgICAgbWFya2VyRmFkZUluQW5pbWF0aW9uKHRoaXMsIGFuaW1hdGlvbk1hbmFnZXIsIFwiYWRkZWRcIiwgbWFya2VyU2VsZWN0aW9uKTtcbiAgICAgIHBhdGhGYWRlSW5BbmltYXRpb24odGhpcywgXCJmaWxsX3BhdGhfcHJvcGVydGllc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBcImFkZFwiLCBmaWxsKTtcbiAgICAgIHBhdGhGYWRlSW5BbmltYXRpb24odGhpcywgXCJzdHJva2VcIiwgYW5pbWF0aW9uTWFuYWdlciwgXCJ0cmFpbGluZ1wiLCBzdHJva2UpO1xuICAgICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmbnMgPSBwcmVwYXJlQXJlYVBhdGhBbmltYXRpb24oY29udGV4dERhdGEsIHByZXZpb3VzQ29udGV4dERhdGEsIHRoaXMucHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uZGlmZik7XG4gICAgaWYgKGZucyA9PT0gdm9pZCAwKSB7XG4gICAgICBza2lwKCk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChmbnMuc3RhdHVzID09PSBcIm5vLW9wXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWFya2VyRmFkZUluQW5pbWF0aW9uKHRoaXMsIGFuaW1hdGlvbk1hbmFnZXIsIHZvaWQgMCwgbWFya2VyU2VsZWN0aW9uKTtcbiAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgXCJmaWxsX3BhdGhfcHJvcGVydGllc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBbZmlsbF0sIGZucy5maWxsLnBhdGhQcm9wZXJ0aWVzKTtcbiAgICBwYXRoTW90aW9uKHRoaXMuaWQsIFwiZmlsbF9wYXRoX3VwZGF0ZVwiLCBhbmltYXRpb25NYW5hZ2VyLCBbZmlsbF0sIGZucy5maWxsLnBhdGgpO1xuICAgIHRoaXMudXBkYXRlU3Ryb2tlUGF0aChwYXRocywgY29udGV4dERhdGEpO1xuICAgIHBhdGhGYWRlSW5BbmltYXRpb24odGhpcywgXCJzdHJva2VcIiwgYW5pbWF0aW9uTWFuYWdlciwgXCJ0cmFpbGluZ1wiLCBzdHJva2UpO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9uKTtcbiAgfVxuICBpc0xhYmVsRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsLmVuYWJsZWQ7XG4gIH1cbiAgbm9kZUZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBHcm91cCgpO1xuICB9XG4gIGdldEZvcm1hdHRlZE1hcmtlclN0eWxlKGRhdHVtKSB7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5IH0gPSBkYXR1bTtcbiAgICByZXR1cm4gdGhpcy5nZXRNYXJrZXJTdHlsZSh0aGlzLnByb3BlcnRpZXMubWFya2VyLCB7IGRhdHVtLCB4S2V5LCB5S2V5LCBoaWdobGlnaHRlZDogdHJ1ZSB9KTtcbiAgfVxuICBjb21wdXRlRm9jdXNCb3VuZHMob3B0cykge1xuICAgIHJldHVybiBjb21wdXRlTWFya2VyRm9jdXNCb3VuZHModGhpcywgb3B0cyk7XG4gIH1cbn07XG5BcmVhU2VyaWVzLmNsYXNzTmFtZSA9IFwiQXJlYVNlcmllc1wiO1xuQXJlYVNlcmllcy50eXBlID0gXCJhcmVhXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYXJlYVNlcmllc01vZHVsZS50c1xudmFyIEFyZWFTZXJpZXNNb2R1bGUgPSB7XG4gIHR5cGU6IFwic2VyaWVzXCIsXG4gIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSxcbiAgaWRlbnRpZmllcjogXCJhcmVhXCIsXG4gIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBBcmVhU2VyaWVzKGN0eCksXG4gIHN0YWNrYWJsZTogdHJ1ZSxcbiAgdG9vbHRpcERlZmF1bHRzOiB7IHJhbmdlOiBcIm5lYXJlc3RcIiB9LFxuICBkZWZhdWx0QXhlczogW1xuICAgIHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIgLyogTlVNQkVSICovLFxuICAgICAgcG9zaXRpb246IFwibGVmdFwiIC8qIExFRlQgKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwiY2F0ZWdvcnlcIiAvKiBDQVRFR09SWSAqLyxcbiAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiIC8qIEJPVFRPTSAqL1xuICAgIH1cbiAgXSxcbiAgdGhlbWVUZW1wbGF0ZToge1xuICAgIHNlcmllczoge1xuICAgICAgbm9kZUNsaWNrUmFuZ2U6IFwibmVhcmVzdFwiLFxuICAgICAgdG9vbHRpcDogeyBwb3NpdGlvbjogeyB0eXBlOiBcIm5vZGVcIiB9IH0sXG4gICAgICBmaWxsT3BhY2l0eTogMC44LFxuICAgICAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgICAgbGluZURhc2g6IFswXSxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiAwLFxuICAgICAgc2hhZG93OiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBjb2xvcjogREVGQVVMVF9TSEFET1dfQ09MT1VSLFxuICAgICAgICB4T2Zmc2V0OiAzLFxuICAgICAgICB5T2Zmc2V0OiAzLFxuICAgICAgICBibHVyOiA1XG4gICAgICB9LFxuICAgICAgaW50ZXJwb2xhdGlvbjoge1xuICAgICAgICB0eXBlOiBcImxpbmVhclwiLFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gdXNlcnMgc2hvdWxkbid0IHNwZWNpZnkgYWxsIG9wdGlvbnMsIGJ1dCB3ZSBoYXZlIHRvIGZvciB0aGVtaW5nIHRvIHdvcmtcbiAgICAgICAgdGVuc2lvbjogMSxcbiAgICAgICAgcG9zaXRpb246IFwiZW5kXCJcbiAgICAgIH0sXG4gICAgICBtYXJrZXI6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHNoYXBlOiBcImNpcmNsZVwiLFxuICAgICAgICBzaXplOiA3LFxuICAgICAgICBzdHJva2VXaWR0aDogMFxuICAgICAgfSxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcGFsZXR0ZUZhY3Rvcnk6IChwYXJhbXMpID0+IHtcbiAgICBjb25zdCB7IG1hcmtlciB9ID0gbWFya2VyUGFsZXR0ZUZhY3RvcnkocGFyYW1zKTtcbiAgICByZXR1cm4geyBmaWxsOiBtYXJrZXIuZmlsbCwgc3Ryb2tlOiBtYXJrZXIuc3Ryb2tlLCBtYXJrZXIgfTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9xdWFkdHJlZVV0aWwudHNcbmZ1bmN0aW9uKiBjaGlsZHJlbkl0ZXIocGFyZW50KSB7XG4gIGZvciAoY29uc3Qgbm9kZSBvZiBwYXJlbnQuY2hpbGRyZW4pIHtcbiAgICB5aWVsZCBub2RlO1xuICB9XG59XG5mdW5jdGlvbiBhZGRIaXRUZXN0ZXJzVG9RdWFkdHJlZShxdWFkdHJlZSwgaGl0VGVzdGVycykge1xuICBmb3IgKGNvbnN0IG5vZGUgb2YgaGl0VGVzdGVycykge1xuICAgIGNvbnN0IGRhdHVtID0gbm9kZS5kYXR1bTtcbiAgICBpZiAoZGF0dW0gPT09IHZvaWQgMCkge1xuICAgICAgTG9nZ2VyLmVycm9yKFwidW5kZWZpbmVkIGRhdHVtXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWFkdHJlZS5hZGRWYWx1ZShub2RlLCBkYXR1bSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBmaW5kUXVhZHRyZWVNYXRjaChzZXJpZXMsIHBvaW50KSB7XG4gIGNvbnN0IHsgeCwgeSB9ID0gc2VyaWVzLmNvbnRlbnRHcm91cC50cmFuc2Zvcm1Qb2ludChwb2ludC54LCBwb2ludC55KTtcbiAgY29uc3QgeyBuZWFyZXN0LCBkaXN0YW5jZVNxdWFyZWQ6IGRpc3RhbmNlU3F1YXJlZDMgfSA9IHNlcmllcy5nZXRRdWFkVHJlZSgpLmZpbmQoeCwgeSk7XG4gIGlmIChuZWFyZXN0ICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4geyBkYXR1bTogbmVhcmVzdC52YWx1ZSwgZGlzdGFuY2U6IE1hdGguc3FydChkaXN0YW5jZVNxdWFyZWQzKSB9O1xuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYWJzdHJhY3RCYXJTZXJpZXMudHNcbnZhciBBYnN0cmFjdEJhclNlcmllc1Byb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllc1Byb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gXCJ2ZXJ0aWNhbFwiO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRElSRUNUSU9OKVxuXSwgQWJzdHJhY3RCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJkaXJlY3Rpb25cIiwgMik7XG52YXIgQWJzdHJhY3RCYXJTZXJpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgLyoqXG4gICAgICogVXNlZCB0byBnZXQgdGhlIHBvc2l0aW9uIG9mIGJhcnMgd2l0aGluIGVhY2ggZ3JvdXAuXG4gICAgICovXG4gICAgdGhpcy5ncm91cFNjYWxlID0gbmV3IEJhbmRTY2FsZSgpO1xuICAgIHRoaXMuc21hbGxlc3REYXRhSW50ZXJ2YWwgPSB2b2lkIDA7XG4gICAgdGhpcy5sYXJnZXN0RGF0YUludGVydmFsID0gdm9pZCAwO1xuICB9XG4gIGdldEJhbmRTY2FsZVBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHsgaW5uZXI6IDAuMywgb3V0ZXI6IDAuMTUgfTtcbiAgfVxuICBzaG91bGRGbGlwWFkoKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzVmVydGljYWwoKTtcbiAgfVxuICBpc1ZlcnRpY2FsKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMuZGlyZWN0aW9uID09PSBcInZlcnRpY2FsXCI7XG4gIH1cbiAgZ2V0QmFyRGlyZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnNob3VsZEZsaXBYWSgpID8gXCJ4XCIgLyogWCAqLyA6IFwieVwiIC8qIFkgKi87XG4gIH1cbiAgZ2V0Q2F0ZWdvcnlEaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hvdWxkRmxpcFhZKCkgPyBcInlcIiAvKiBZICovIDogXCJ4XCIgLyogWCAqLztcbiAgfVxuICBnZXRWYWx1ZUF4aXMoKSB7XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXRCYXJEaXJlY3Rpb24oKTtcbiAgICByZXR1cm4gdGhpcy5heGVzW2RpcmVjdGlvbl07XG4gIH1cbiAgZ2V0Q2F0ZWdvcnlBeGlzKCkge1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IHRoaXMuZ2V0Q2F0ZWdvcnlEaXJlY3Rpb24oKTtcbiAgICByZXR1cm4gdGhpcy5heGVzW2RpcmVjdGlvbl07XG4gIH1cbiAgdXBkYXRlR3JvdXBTY2FsZSh4QXhpcykge1xuICAgIGNvbnN0IHtcbiAgICAgIGdyb3VwU2NhbGUsXG4gICAgICBzbWFsbGVzdERhdGFJbnRlcnZhbCxcbiAgICAgIGN0eDogeyBzZXJpZXNTdGF0ZU1hbmFnZXIgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHhTY2FsZSA9IHhBeGlzLnNjYWxlO1xuICAgIGNvbnN0IHhCYW5kV2lkdGggPSBDb250aW51b3VzU2NhbGUuaXMoeFNjYWxlKSA/IHhTY2FsZS5jYWxjQmFuZHdpZHRoKHNtYWxsZXN0RGF0YUludGVydmFsKSA6IHhTY2FsZS5iYW5kd2lkdGg7XG4gICAgY29uc3QgZG9tYWluID0gW107XG4gICAgY29uc3QgeyBpbmRleDogZ3JvdXBJbmRleCwgdmlzaWJsZUdyb3VwQ291bnQgfSA9IHNlcmllc1N0YXRlTWFuYWdlci5nZXRWaXNpYmxlUGVlckdyb3VwSW5kZXgodGhpcyk7XG4gICAgZm9yIChsZXQgZ3JvdXBJZHggPSAwOyBncm91cElkeCA8IHZpc2libGVHcm91cENvdW50OyBncm91cElkeCsrKSB7XG4gICAgICBkb21haW4ucHVzaChTdHJpbmcoZ3JvdXBJZHgpKTtcbiAgICB9XG4gICAgZ3JvdXBTY2FsZS5kb21haW4gPSBkb21haW47XG4gICAgZ3JvdXBTY2FsZS5yYW5nZSA9IFswLCB4QmFuZFdpZHRoID8/IDBdO1xuICAgIGlmICh4QXhpcyBpbnN0YW5jZW9mIENhdGVnb3J5QXhpcykge1xuICAgICAgZ3JvdXBTY2FsZS5wYWRkaW5nSW5uZXIgPSB4QXhpcy5ncm91cFBhZGRpbmdJbm5lcjtcbiAgICB9IGVsc2UgaWYgKHhBeGlzIGluc3RhbmNlb2YgR3JvdXBlZENhdGVnb3J5QXhpcykge1xuICAgICAgZ3JvdXBTY2FsZS5wYWRkaW5nID0gMC4xO1xuICAgIH0gZWxzZSB7XG4gICAgICBncm91cFNjYWxlLnBhZGRpbmcgPSAwO1xuICAgIH1cbiAgICBncm91cFNjYWxlLnJvdW5kID0gZ3JvdXBTY2FsZS5wYWRkaW5nICE9PSAwO1xuICAgIGNvbnN0IGJhcldpZHRoID0gZ3JvdXBTY2FsZS5iYW5kd2lkdGggPj0gMSA/IChcbiAgICAgIC8vIFBpeGVsLXJvdW5kZWQgdmFsdWUgZm9yIGxvdy12b2x1bWUgYmFyIGNoYXJ0cy5cbiAgICAgIGdyb3VwU2NhbGUuYmFuZHdpZHRoXG4gICAgKSA6IChcbiAgICAgIC8vIEhhbmRsZSBoaWdoLXZvbHVtZSBiYXIgY2hhcnRzIGdyYWNlZnVsbHkuXG4gICAgICBncm91cFNjYWxlLnJhd0JhbmR3aWR0aFxuICAgICk7XG4gICAgcmV0dXJuIHsgYmFyV2lkdGgsIGdyb3VwSW5kZXggfTtcbiAgfVxuICByZXNvbHZlS2V5RGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgIGlmICh0aGlzLmdldEJhckRpcmVjdGlvbigpID09PSBcInhcIiAvKiBYICovKSB7XG4gICAgICBpZiAoZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovKSB7XG4gICAgICAgIHJldHVybiBcInlcIiAvKiBZICovO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwieFwiIC8qIFggKi87XG4gICAgfVxuICAgIHJldHVybiBkaXJlY3Rpb247XG4gIH1cbiAgaW5pdFF1YWRUcmVlKHF1YWR0cmVlKSB7XG4gICAgYWRkSGl0VGVzdGVyc1RvUXVhZHRyZWUocXVhZHRyZWUsIHRoaXMuZGF0dW1Ob2Rlc0l0ZXIoKSk7XG4gIH1cbiAgcGlja05vZGVDbG9zZXN0RGF0dW0ocG9pbnQpIHtcbiAgICByZXR1cm4gZmluZFF1YWR0cmVlTWF0Y2godGhpcywgcG9pbnQpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2JhclNlcmllc1Byb3BlcnRpZXMudHNcbnZhciBCYXJTZXJpZXNMYWJlbCA9IGNsYXNzIGV4dGVuZHMgTGFiZWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMucGxhY2VtZW50ID0gXCJpbnNpZGVcIjtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBMQUNFTUVOVClcbl0sIEJhclNlcmllc0xhYmVsLnByb3RvdHlwZSwgXCJwbGFjZW1lbnRcIiwgMik7XG52YXIgQmFyU2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RCYXJTZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmZpbGwgPSBcIiNjMTYwNjhcIjtcbiAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcbiAgICB0aGlzLnN0cm9rZSA9IFwiIzg3NDM0OVwiO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5saW5lRGFzaCA9IFswXTtcbiAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmNvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5jcmlzcCA9IHZvaWQgMDtcbiAgICB0aGlzLnNoYWRvdyA9IG5ldyBEcm9wU2hhZG93KCk7XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBCYXJTZXJpZXNMYWJlbCgpO1xuICAgIHRoaXMudG9vbHRpcCA9IG5ldyBTZXJpZXNUb29sdGlwKCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5RmlsdGVyS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdGFja0dyb3VwXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJub3JtYWxpemVkVG9cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcpXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORylcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTElORV9EQVNIKVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBCYXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaE9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNyaXNwXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoRlVOQ1RJT04sIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIml0ZW1TdHlsZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNoYWRvd1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEJhclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQmFyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9iYXJVdGlsLnRzXG5mdW5jdGlvbiB1cGRhdGVSZWN0KHJlY3QsIGNvbmZpZykge1xuICByZWN0LmNyaXNwID0gY29uZmlnLmNyaXNwID8/IHRydWU7XG4gIHJlY3QuZmlsbCA9IGNvbmZpZy5maWxsO1xuICByZWN0LnN0cm9rZSA9IGNvbmZpZy5zdHJva2U7XG4gIHJlY3Quc3Ryb2tlV2lkdGggPSBjb25maWcuc3Ryb2tlV2lkdGg7XG4gIHJlY3QuZmlsbE9wYWNpdHkgPSBjb25maWcuZmlsbE9wYWNpdHk7XG4gIHJlY3Quc3Ryb2tlT3BhY2l0eSA9IGNvbmZpZy5zdHJva2VPcGFjaXR5O1xuICByZWN0LmxpbmVEYXNoID0gY29uZmlnLmxpbmVEYXNoO1xuICByZWN0LmxpbmVEYXNoT2Zmc2V0ID0gY29uZmlnLmxpbmVEYXNoT2Zmc2V0O1xuICByZWN0LmZpbGxTaGFkb3cgPSBjb25maWcuZmlsbFNoYWRvdztcbiAgcmVjdC50b3BMZWZ0Q29ybmVyUmFkaXVzID0gY29uZmlnLnRvcExlZnRDb3JuZXJSYWRpdXMgIT09IGZhbHNlID8gY29uZmlnLmNvcm5lclJhZGl1cyA/PyAwIDogMDtcbiAgcmVjdC50b3BSaWdodENvcm5lclJhZGl1cyA9IGNvbmZpZy50b3BSaWdodENvcm5lclJhZGl1cyAhPT0gZmFsc2UgPyBjb25maWcuY29ybmVyUmFkaXVzID8/IDAgOiAwO1xuICByZWN0LmJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzID0gY29uZmlnLmJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzICE9PSBmYWxzZSA/IGNvbmZpZy5jb3JuZXJSYWRpdXMgPz8gMCA6IDA7XG4gIHJlY3QuYm90dG9tTGVmdENvcm5lclJhZGl1cyA9IGNvbmZpZy5ib3R0b21MZWZ0Q29ybmVyUmFkaXVzICE9PSBmYWxzZSA/IGNvbmZpZy5jb3JuZXJSYWRpdXMgPz8gMCA6IDA7XG4gIHJlY3QudmlzaWJsZSA9IGNvbmZpZy52aXNpYmxlID8/IHRydWU7XG59XG5mdW5jdGlvbiBnZXRSZWN0Q29uZmlnKHtcbiAgZGF0dW0sXG4gIGlzSGlnaGxpZ2h0ZWQsXG4gIHN0eWxlLFxuICBoaWdobGlnaHRTdHlsZSxcbiAgaXRlbVN0eWxlcixcbiAgc2VyaWVzSWQsXG4gIGN0eDogeyBjYWxsYmFja0NhY2hlIH0sXG4gIC4uLm9wdHNcbn0pIHtcbiAgY29uc3Qge1xuICAgIGZpbGwsXG4gICAgZmlsbE9wYWNpdHksXG4gICAgc3Ryb2tlLFxuICAgIHN0cm9rZVdpZHRoLFxuICAgIHN0cm9rZU9wYWNpdHksXG4gICAgbGluZURhc2gsXG4gICAgbGluZURhc2hPZmZzZXQsXG4gICAgY29ybmVyUmFkaXVzID0gMFxuICB9ID0gbWVyZ2VEZWZhdWx0cyhpc0hpZ2hsaWdodGVkICYmIGhpZ2hsaWdodFN0eWxlLCBzdHlsZSk7XG4gIGxldCBmb3JtYXQ7XG4gIGlmIChpdGVtU3R5bGVyKSB7XG4gICAgZm9ybWF0ID0gY2FsbGJhY2tDYWNoZS5jYWxsKGl0ZW1TdHlsZXIsIHtcbiAgICAgIGRhdHVtOiBkYXR1bS5kYXR1bSxcbiAgICAgIHhLZXk6IGRhdHVtLnhLZXksXG4gICAgICBmaWxsLFxuICAgICAgZmlsbE9wYWNpdHksXG4gICAgICBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICBsaW5lRGFzaCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgaGlnaGxpZ2h0ZWQ6IGlzSGlnaGxpZ2h0ZWQsXG4gICAgICBzZXJpZXNJZCxcbiAgICAgIC4uLm9wdHNcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGZpbGw6IGZvcm1hdD8uZmlsbCA/PyBmaWxsLFxuICAgIGZpbGxPcGFjaXR5OiBmb3JtYXQ/LmZpbGxPcGFjaXR5ID8/IGZpbGxPcGFjaXR5LFxuICAgIHN0cm9rZTogZm9ybWF0Py5zdHJva2UgPz8gc3Ryb2tlLFxuICAgIHN0cm9rZVdpZHRoOiBmb3JtYXQ/LnN0cm9rZVdpZHRoID8/IHN0cm9rZVdpZHRoLFxuICAgIHN0cm9rZU9wYWNpdHk6IGZvcm1hdD8uc3Ryb2tlT3BhY2l0eSA/PyBzdHJva2VPcGFjaXR5LFxuICAgIGxpbmVEYXNoOiBmb3JtYXQ/LmxpbmVEYXNoID8/IGxpbmVEYXNoLFxuICAgIGxpbmVEYXNoT2Zmc2V0OiBmb3JtYXQ/LmxpbmVEYXNoT2Zmc2V0ID8/IGxpbmVEYXNoT2Zmc2V0LFxuICAgIGNvcm5lclJhZGl1czogZm9ybWF0Py5jb3JuZXJSYWRpdXMgPz8gY29ybmVyUmFkaXVzLFxuICAgIHRvcExlZnRDb3JuZXJSYWRpdXM6IHN0eWxlLnRvcExlZnRDb3JuZXJSYWRpdXMsXG4gICAgdG9wUmlnaHRDb3JuZXJSYWRpdXM6IHN0eWxlLnRvcFJpZ2h0Q29ybmVyUmFkaXVzLFxuICAgIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzOiBzdHlsZS5ib3R0b21SaWdodENvcm5lclJhZGl1cyxcbiAgICBib3R0b21MZWZ0Q29ybmVyUmFkaXVzOiBzdHlsZS5ib3R0b21MZWZ0Q29ybmVyUmFkaXVzLFxuICAgIGZpbGxTaGFkb3c6IHN0eWxlLmZpbGxTaGFkb3dcbiAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrQ3Jpc3Aoc2NhbGUyLCB2aXNpYmxlUmFuZ2UsIHNtYWxsZXN0RGF0YUludGVydmFsLCBsYXJnZXN0RGF0YUludGVydmFsKSB7XG4gIGlmICh2aXNpYmxlUmFuZ2UgIT0gbnVsbCkge1xuICAgIGNvbnN0IFt2aXNpYmxlTWluLCB2aXNpYmxlTWF4XSA9IHZpc2libGVSYW5nZTtcbiAgICBjb25zdCBpc1pvb21lZCA9IHZpc2libGVNaW4gIT09IDAgfHwgdmlzaWJsZU1heCAhPT0gMTtcbiAgICBpZiAoaXNab29tZWQpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKENvbnRpbnVvdXNTY2FsZS5pcyhzY2FsZTIpKSB7XG4gICAgY29uc3Qgc3BhY2luZyA9IHNjYWxlMi5jYWxjQmFuZHdpZHRoKGxhcmdlc3REYXRhSW50ZXJ2YWwpIC0gc2NhbGUyLmNhbGNCYW5kd2lkdGgoc21hbGxlc3REYXRhSW50ZXJ2YWwpO1xuICAgIGlmIChzcGFjaW5nID4gMCAmJiBzcGFjaW5nIDwgMSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbnZhciBpc0RhdHVtTmVnYXRpdmUgPSAoZGF0dW0pID0+IHtcbiAgcmV0dXJuIGlzTmVnYXRpdmUoZGF0dW0ueVZhbHVlID8/IDApO1xufTtcbmZ1bmN0aW9uIGNvbGxhcHNlZFN0YXJ0aW5nQmFyUG9zaXRpb24oaXNWZXJ0aWNhbCwgYXhlcywgbW9kZSkge1xuICBjb25zdCB7IHN0YXJ0aW5nWCwgc3RhcnRpbmdZIH0gPSBnZXRTdGFydGluZ1ZhbHVlcyhpc1ZlcnRpY2FsLCBheGVzKTtcbiAgY29uc3QgY2FsY3VsYXRlID0gKGRhdHVtLCBwcmV2RGF0dW0pID0+IHtcbiAgICBsZXQgeCA9IGlzVmVydGljYWwgPyBkYXR1bS54IDogc3RhcnRpbmdYO1xuICAgIGxldCB5ID0gaXNWZXJ0aWNhbCA/IHN0YXJ0aW5nWSA6IGRhdHVtLnk7XG4gICAgbGV0IHdpZHRoID0gaXNWZXJ0aWNhbCA/IGRhdHVtLndpZHRoIDogMDtcbiAgICBsZXQgaGVpZ2h0ID0gaXNWZXJ0aWNhbCA/IDAgOiBkYXR1bS5oZWlnaHQ7XG4gICAgY29uc3QgeyBvcGFjaXR5IH0gPSBkYXR1bTtcbiAgICBpZiAocHJldkRhdHVtICYmIChpc05hTih4KSB8fCBpc05hTih5KSkpIHtcbiAgICAgICh7IHgsIHkgfSA9IHByZXZEYXR1bSk7XG4gICAgICB3aWR0aCA9IGlzVmVydGljYWwgPyBwcmV2RGF0dW0ud2lkdGggOiAwO1xuICAgICAgaGVpZ2h0ID0gaXNWZXJ0aWNhbCA/IDAgOiBwcmV2RGF0dW0uaGVpZ2h0O1xuICAgICAgaWYgKGlzVmVydGljYWwgJiYgIWlzRGF0dW1OZWdhdGl2ZShwcmV2RGF0dW0pKSB7XG4gICAgICAgIHkgKz0gcHJldkRhdHVtLmhlaWdodDtcbiAgICAgIH0gZWxzZSBpZiAoIWlzVmVydGljYWwgJiYgaXNEYXR1bU5lZ2F0aXZlKHByZXZEYXR1bSkpIHtcbiAgICAgICAgeCArPSBwcmV2RGF0dW0ud2lkdGg7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBjbGlwQkJveDtcbiAgICBpZiAoZGF0dW0uY2xpcEJCb3ggPT0gbnVsbCkge1xuICAgICAgY2xpcEJCb3ggPSB2b2lkIDA7XG4gICAgfSBlbHNlIGlmIChpc0RhdHVtTmVnYXRpdmUoZGF0dW0pKSB7XG4gICAgICBjbGlwQkJveCA9IGlzVmVydGljYWwgPyBuZXcgQkJveCh4LCB5IC0gaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0KSA6IG5ldyBCQm94KHggLSB3aWR0aCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsaXBCQm94ID0gbmV3IEJCb3goeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIHJldHVybiB7IHgsIHksIHdpZHRoLCBoZWlnaHQsIGNsaXBCQm94LCBvcGFjaXR5IH07XG4gIH07XG4gIHJldHVybiB7IGlzVmVydGljYWwsIGNhbGN1bGF0ZSwgbW9kZSB9O1xufVxuZnVuY3Rpb24gbWlkcG9pbnRTdGFydGluZ0JhclBvc2l0aW9uKGlzVmVydGljYWwsIG1vZGUpIHtcbiAgcmV0dXJuIHtcbiAgICBpc1ZlcnRpY2FsLFxuICAgIGNhbGN1bGF0ZTogKGRhdHVtKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBpc1ZlcnRpY2FsID8gZGF0dW0ueCA6IGRhdHVtLnggKyBkYXR1bS53aWR0aCAvIDIsXG4gICAgICAgIHk6IGlzVmVydGljYWwgPyBkYXR1bS55ICsgZGF0dW0uaGVpZ2h0IC8gMiA6IGRhdHVtLnksXG4gICAgICAgIHdpZHRoOiBpc1ZlcnRpY2FsID8gZGF0dW0ud2lkdGggOiAwLFxuICAgICAgICBoZWlnaHQ6IGlzVmVydGljYWwgPyAwIDogZGF0dW0uaGVpZ2h0LFxuICAgICAgICBjbGlwQkJveDogZGF0dW0uY2xpcEJCb3gsXG4gICAgICAgIG9wYWNpdHk6IGRhdHVtLm9wYWNpdHlcbiAgICAgIH07XG4gICAgfSxcbiAgICBtb2RlXG4gIH07XG59XG5mdW5jdGlvbiBwcmVwYXJlQmFyQW5pbWF0aW9uRnVuY3Rpb25zKGluaXRQb3MpIHtcbiAgY29uc3QgaXNSZW1vdmVkID0gKGRhdHVtKSA9PiBkYXR1bSA9PSBudWxsIHx8IGlzTmFOKGRhdHVtLngpIHx8IGlzTmFOKGRhdHVtLnkpO1xuICBjb25zdCBmcm9tRm4gPSAocmVjdCwgZGF0dW0sIHN0YXR1cykgPT4ge1xuICAgIGlmIChzdGF0dXMgPT09IFwidXBkYXRlZFwiICYmIGlzUmVtb3ZlZChkYXR1bSkpIHtcbiAgICAgIHN0YXR1cyA9IFwicmVtb3ZlZFwiO1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBcInVwZGF0ZWRcIiAmJiBpc1JlbW92ZWQocmVjdC5wcmV2aW91c0RhdHVtKSkge1xuICAgICAgc3RhdHVzID0gXCJhZGRlZFwiO1xuICAgIH1cbiAgICBsZXQgc291cmNlO1xuICAgIGlmIChzdGF0dXMgPT09IFwiYWRkZWRcIiAmJiByZWN0LnByZXZpb3VzRGF0dW0gPT0gbnVsbCAmJiBpbml0UG9zLm1vZGUgPT09IFwiZmFkZVwiKSB7XG4gICAgICBzb3VyY2UgPSB7IC4uLnJlc2V0QmFyU2VsZWN0aW9uc0ZuKHJlY3QsIGRhdHVtKSwgb3BhY2l0eTogMCB9O1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBcInVua25vd25cIiB8fCBzdGF0dXMgPT09IFwiYWRkZWRcIikge1xuICAgICAgc291cmNlID0gaW5pdFBvcy5jYWxjdWxhdGUoZGF0dW0sIHJlY3QucHJldmlvdXNEYXR1bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNvdXJjZSA9IHtcbiAgICAgICAgeDogcmVjdC54LFxuICAgICAgICB5OiByZWN0LnksXG4gICAgICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgICAgICBjbGlwQkJveDogcmVjdC5jbGlwQkJveCxcbiAgICAgICAgb3BhY2l0eTogcmVjdC5vcGFjaXR5XG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBwaGFzZSA9IE5PREVfVVBEQVRFX1NUQVRFX1RPX1BIQVNFX01BUFBJTkdbc3RhdHVzXTtcbiAgICByZXR1cm4geyAuLi5zb3VyY2UsIHBoYXNlIH07XG4gIH07XG4gIGNvbnN0IHRvRm4gPSAocmVjdCwgZGF0dW0sIHN0YXR1cykgPT4ge1xuICAgIGxldCBzb3VyY2U7XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJyZW1vdmVkXCIgJiYgcmVjdC5kYXR1bSA9PSBudWxsICYmIGluaXRQb3MubW9kZSA9PT0gXCJmYWRlXCIpIHtcbiAgICAgIHNvdXJjZSA9IHsgLi4ucmVzZXRCYXJTZWxlY3Rpb25zRm4ocmVjdCwgZGF0dW0pLCBvcGFjaXR5OiAwIH07XG4gICAgfSBlbHNlIGlmIChzdGF0dXMgPT09IFwicmVtb3ZlZFwiIHx8IGlzUmVtb3ZlZChkYXR1bSkpIHtcbiAgICAgIHNvdXJjZSA9IGluaXRQb3MuY2FsY3VsYXRlKGRhdHVtLCByZWN0LnByZXZpb3VzRGF0dW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzb3VyY2UgPSB7XG4gICAgICAgIHg6IGRhdHVtLngsXG4gICAgICAgIHk6IGRhdHVtLnksXG4gICAgICAgIHdpZHRoOiBkYXR1bS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBkYXR1bS5oZWlnaHQsXG4gICAgICAgIGNsaXBCQm94OiBkYXR1bS5jbGlwQkJveCxcbiAgICAgICAgb3BhY2l0eTogZGF0dW0ub3BhY2l0eVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfTtcbiAgcmV0dXJuIHsgdG9GbiwgZnJvbUZuIH07XG59XG5mdW5jdGlvbiBnZXRTdGFydGluZ1ZhbHVlcyhpc1ZlcnRpY2FsLCBheGVzKSB7XG4gIGNvbnN0IGF4aXMgPSBheGVzW2lzVmVydGljYWwgPyBcInlcIiAvKiBZICovIDogXCJ4XCIgLyogWCAqL107XG4gIGxldCBzdGFydGluZ1ggPSBJbmZpbml0eTtcbiAgbGV0IHN0YXJ0aW5nWSA9IDA7XG4gIGlmICghYXhpcykge1xuICAgIHJldHVybiB7IHN0YXJ0aW5nWCwgc3RhcnRpbmdZIH07XG4gIH1cbiAgaWYgKGlzVmVydGljYWwpIHtcbiAgICBzdGFydGluZ1kgPSBheGlzLnNjYWxlLmNvbnZlcnQoQ29udGludW91c1NjYWxlLmlzKGF4aXMuc2NhbGUpID8gMCA6IE1hdGgubWF4KC4uLmF4aXMucmFuZ2UpKTtcbiAgfSBlbHNlIHtcbiAgICBzdGFydGluZ1ggPSBheGlzLnNjYWxlLmNvbnZlcnQoQ29udGludW91c1NjYWxlLmlzKGF4aXMuc2NhbGUpID8gMCA6IE1hdGgubWluKC4uLmF4aXMucmFuZ2UpKTtcbiAgfVxuICByZXR1cm4geyBzdGFydGluZ1gsIHN0YXJ0aW5nWSB9O1xufVxuZnVuY3Rpb24gcmVzZXRCYXJTZWxlY3Rpb25zRm4oX25vZGUsIHsgeCwgeSwgd2lkdGgsIGhlaWdodCwgY2xpcEJCb3gsIG9wYWNpdHkgfSkge1xuICByZXR1cm4geyB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjbGlwQkJveCwgb3BhY2l0eSB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUJhckZvY3VzQm91bmRzKGRhdHVtLCBiYXJHcm91cCwgc2VyaWVzUmVjdCkge1xuICBpZiAoZGF0dW0gPT09IHZvaWQgMClcbiAgICByZXR1cm4gdm9pZCAwO1xuICBjb25zdCB7IHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IGRhdHVtO1xuICByZXR1cm4gYmFyR3JvdXAuaW52ZXJzZVRyYW5zZm9ybUJCb3gobmV3IEJCb3goeCwgeSwgd2lkdGgsIGhlaWdodCkpLmNsaXAoc2VyaWVzUmVjdCk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vbGFiZWxVdGlsLnRzXG5mdW5jdGlvbiB1cGRhdGVMYWJlbE5vZGUodGV4dE5vZGUsIGxhYmVsLCBsYWJlbERhdHVtKSB7XG4gIGlmIChsYWJlbC5lbmFibGVkICYmIGxhYmVsRGF0dW0pIHtcbiAgICBjb25zdCB7IHgsIHksIHRleHQsIHRleHRBbGlnbiwgdGV4dEJhc2VsaW5lIH0gPSBsYWJlbERhdHVtO1xuICAgIGNvbnN0IHsgY29sb3I6IGZpbGwsIGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udFNpemUsIGZvbnRGYW1pbHkgfSA9IGxhYmVsO1xuICAgIHRleHROb2RlLnNldFByb3BlcnRpZXMoe1xuICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgdGV4dCxcbiAgICAgIGZpbGwsXG4gICAgICBmb250U3R5bGUsXG4gICAgICBmb250V2VpZ2h0LFxuICAgICAgZm9udFNpemUsXG4gICAgICBmb250RmFtaWx5LFxuICAgICAgdGV4dEFsaWduLFxuICAgICAgdGV4dEJhc2VsaW5lXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGV4dE5vZGUudmlzaWJsZSA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBhZGp1c3RMYWJlbFBsYWNlbWVudCh7XG4gIGlzUG9zaXRpdmUsXG4gIGlzVmVydGljYWwsXG4gIHBsYWNlbWVudCxcbiAgcGFkZGluZyA9IDAsXG4gIHJlY3Rcbn0pIHtcbiAgbGV0IHggPSByZWN0LnggKyByZWN0LndpZHRoIC8gMjtcbiAgbGV0IHkgPSByZWN0LnkgKyByZWN0LmhlaWdodCAvIDI7XG4gIGxldCB0ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICBsZXQgdGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgc3dpdGNoIChwbGFjZW1lbnQpIHtcbiAgICBjYXNlIFwic3RhcnRcIjoge1xuICAgICAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAgICAgeSA9IGlzUG9zaXRpdmUgPyByZWN0LnkgKyByZWN0LmhlaWdodCArIHBhZGRpbmcgOiByZWN0LnkgLSBwYWRkaW5nO1xuICAgICAgICB0ZXh0QmFzZWxpbmUgPSBpc1Bvc2l0aXZlID8gXCJ0b3BcIiA6IFwiYm90dG9tXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gaXNQb3NpdGl2ZSA/IHJlY3QueCAtIHBhZGRpbmcgOiByZWN0LnggKyByZWN0LndpZHRoICsgcGFkZGluZztcbiAgICAgICAgdGV4dEFsaWduID0gaXNQb3NpdGl2ZSA/IFwic3RhcnRcIiA6IFwiZW5kXCI7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcIm91dHNpZGVcIjpcbiAgICBjYXNlIFwiZW5kXCI6IHtcbiAgICAgIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgICAgIHkgPSBpc1Bvc2l0aXZlID8gcmVjdC55IC0gcGFkZGluZyA6IHJlY3QueSArIHJlY3QuaGVpZ2h0ICsgcGFkZGluZztcbiAgICAgICAgdGV4dEJhc2VsaW5lID0gaXNQb3NpdGl2ZSA/IFwiYm90dG9tXCIgOiBcInRvcFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeCA9IGlzUG9zaXRpdmUgPyByZWN0LnggKyByZWN0LndpZHRoICsgcGFkZGluZyA6IHJlY3QueCAtIHBhZGRpbmc7XG4gICAgICAgIHRleHRBbGlnbiA9IGlzUG9zaXRpdmUgPyBcInN0YXJ0XCIgOiBcImVuZFwiO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB7IHgsIHksIHRleHRBbGlnbiwgdGV4dEJhc2VsaW5lIH07XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYmFyU2VyaWVzLnRzXG52YXIgQmFyU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdEJhclNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1vZHVsZUN0eCxcbiAgICAgIGRpcmVjdGlvbktleXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9LRVlTLFxuICAgICAgZGlyZWN0aW9uTmFtZXM6IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9OQU1FUyxcbiAgICAgIHBpY2tNb2RlczogWzMgLyogTkVBUkVTVF9OT0RFICovLCAwIC8qIEVYQUNUX1NIQVBFX01BVENIICovXSxcbiAgICAgIHBhdGhzUGVyU2VyaWVzOiBbXSxcbiAgICAgIGhhc0hpZ2hsaWdodGVkTGFiZWxzOiB0cnVlLFxuICAgICAgZGF0dW1TZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvbjogZmFsc2UsXG4gICAgICBhbmltYXRpb25BbHdheXNVcGRhdGVTZWxlY3Rpb25zOiB0cnVlLFxuICAgICAgYW5pbWF0aW9uUmVzZXRGbnM6IHtcbiAgICAgICAgZGF0dW06IHJlc2V0QmFyU2VsZWN0aW9uc0ZuLFxuICAgICAgICBsYWJlbDogcmVzZXRMYWJlbEZuXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gbmV3IEJhclNlcmllc1Byb3BlcnRpZXMoKTtcbiAgfVxuICBjcm9zc0ZpbHRlcmluZ0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy55RmlsdGVyS2V5ICE9IG51bGwgJiYgKHRoaXMuc2VyaWVzR3JvdXBpbmcgPT0gbnVsbCB8fCB0aGlzLnNlcmllc0dyb3VwaW5nLnN0YWNrSW5kZXggPT09IDApO1xuICB9XG4gIGFzeW5jIHByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSB7XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8ICF0aGlzLmRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBzZXJpZXNHcm91cGluZzogeyBncm91cEluZGV4ID0gdGhpcy5pZCB9ID0ge30sIGRhdGEgPSBbXSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHlGaWx0ZXJLZXksIG5vcm1hbGl6ZWRUbyB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGFuaW1hdGlvbkVuYWJsZWQgPSAhdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKTtcbiAgICBjb25zdCB4U2NhbGUgPSB0aGlzLmdldENhdGVnb3J5QXhpcygpPy5zY2FsZTtcbiAgICBjb25zdCB5U2NhbGUgPSB0aGlzLmdldFZhbHVlQXhpcygpPy5zY2FsZTtcbiAgICBjb25zdCB7IGlzQ29udGludW91c1gsIHhTY2FsZVR5cGUsIHlTY2FsZVR5cGUgfSA9IHRoaXMuZ2V0U2NhbGVJbmZvcm1hdGlvbih7IHhTY2FsZSwgeVNjYWxlIH0pO1xuICAgIGNvbnN0IHN0YWNrR3JvdXBOYW1lID0gYGJhci1zdGFjay0ke2dyb3VwSW5kZXh9LXlWYWx1ZXNgO1xuICAgIGNvbnN0IHN0YWNrR3JvdXBUcmFpbGluZ05hbWUgPSBgJHtzdGFja0dyb3VwTmFtZX0tdHJhaWxpbmdgO1xuICAgIGNvbnN0IGV4dHJhUHJvcHMgPSBbXTtcbiAgICBpZiAoaXNGaW5pdGVOdW1iZXIobm9ybWFsaXplZFRvKSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKFxuICAgICAgICBub3JtYWxpc2VHcm91cFRvKFtzdGFja0dyb3VwTmFtZSwgc3RhY2tHcm91cFRyYWlsaW5nTmFtZV0sIE1hdGguYWJzKG5vcm1hbGl6ZWRUbyksIFwicmFuZ2VcIilcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChhbmltYXRpb25FbmFibGVkICYmIHRoaXMucHJvY2Vzc2VkRGF0YSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKGRpZmYodGhpcy5wcm9jZXNzZWREYXRhKSk7XG4gICAgfVxuICAgIGlmIChhbmltYXRpb25FbmFibGVkKSB7XG4gICAgICBleHRyYVByb3BzLnB1c2goYW5pbWF0aW9uVmFsaWRhdGlvbigpKTtcbiAgICB9XG4gICAgY29uc3QgdmlzaWJsZVByb3BzID0gdGhpcy52aXNpYmxlID8ge30gOiB7IGZvcmNlVmFsdWU6IDAgfTtcbiAgICBjb25zdCB7IHByb2Nlc3NlZERhdGEgfSA9IGF3YWl0IHRoaXMucmVxdWVzdERhdGFNb2RlbChkYXRhQ29udHJvbGxlciwgZGF0YSwge1xuICAgICAgcHJvcHM6IFtcbiAgICAgICAga2V5UHJvcGVydHkoeEtleSwgeFNjYWxlVHlwZSwgeyBpZDogXCJ4VmFsdWVcIiB9KSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eSh5S2V5LCB5U2NhbGVUeXBlLCB7IGlkOiBgeVZhbHVlLXJhd2AsIGludmFsaWRWYWx1ZTogbnVsbCwgLi4udmlzaWJsZVByb3BzIH0pLFxuICAgICAgICAuLi50aGlzLmNyb3NzRmlsdGVyaW5nRW5hYmxlZCgpID8gW1xuICAgICAgICAgIHZhbHVlUHJvcGVydHkoeUZpbHRlcktleSwgeVNjYWxlVHlwZSwge1xuICAgICAgICAgICAgaWQ6IGB5RmlsdGVyVmFsdWVgLFxuICAgICAgICAgICAgaW52YWxpZFZhbHVlOiBudWxsLFxuICAgICAgICAgICAgLi4udmlzaWJsZVByb3BzXG4gICAgICAgICAgfSlcbiAgICAgICAgXSA6IFtdLFxuICAgICAgICAuLi5ncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoXG4gICAgICAgICAgeUtleSxcbiAgICAgICAgICBcIm5vcm1hbFwiLFxuICAgICAgICAgIFwiY3VycmVudFwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkOiBgeVZhbHVlLWVuZGAsXG4gICAgICAgICAgICByYW5nZUlkOiBgeVZhbHVlLXJhbmdlYCxcbiAgICAgICAgICAgIGludmFsaWRWYWx1ZTogbnVsbCxcbiAgICAgICAgICAgIG1pc3NpbmdWYWx1ZTogMCxcbiAgICAgICAgICAgIGdyb3VwSWQ6IHN0YWNrR3JvdXBOYW1lLFxuICAgICAgICAgICAgc2VwYXJhdGVOZWdhdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIC4uLnZpc2libGVQcm9wc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgeVNjYWxlVHlwZVxuICAgICAgICApLFxuICAgICAgICAuLi5ncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoXG4gICAgICAgICAgeUtleSxcbiAgICAgICAgICBcInRyYWlsaW5nXCIsXG4gICAgICAgICAgXCJjdXJyZW50XCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWQ6IGB5VmFsdWUtc3RhcnRgLFxuICAgICAgICAgICAgaW52YWxpZFZhbHVlOiBudWxsLFxuICAgICAgICAgICAgbWlzc2luZ1ZhbHVlOiAwLFxuICAgICAgICAgICAgZ3JvdXBJZDogc3RhY2tHcm91cFRyYWlsaW5nTmFtZSxcbiAgICAgICAgICAgIHNlcGFyYXRlTmVnYXRpdmU6IHRydWUsXG4gICAgICAgICAgICAuLi52aXNpYmxlUHJvcHNcbiAgICAgICAgICB9LFxuICAgICAgICAgIHlTY2FsZVR5cGVcbiAgICAgICAgKSxcbiAgICAgICAgLi4uaXNDb250aW51b3VzWCA/IFtTTUFMTEVTVF9LRVlfSU5URVJWQUwsIExBUkdFU1RfS0VZX0lOVEVSVkFMXSA6IFtdLFxuICAgICAgICAuLi5leHRyYVByb3BzXG4gICAgICBdLFxuICAgICAgZ3JvdXBCeUtleXM6IHRydWUsXG4gICAgICBncm91cEJ5RGF0YTogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLnNtYWxsZXN0RGF0YUludGVydmFsID0gcHJvY2Vzc2VkRGF0YS5yZWR1Y2VkPy5zbWFsbGVzdEtleUludGVydmFsO1xuICAgIHRoaXMubGFyZ2VzdERhdGFJbnRlcnZhbCA9IHByb2Nlc3NlZERhdGEucmVkdWNlZD8ubGFyZ2VzdEtleUludGVydmFsO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZURhdGFcIik7XG4gIH1cbiAgZ2V0U2VyaWVzRG9tYWluKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHsgcHJvY2Vzc2VkRGF0YSwgZGF0YU1vZGVsLCBzbWFsbGVzdERhdGFJbnRlcnZhbCB9ID0gdGhpcztcbiAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIWRhdGFNb2RlbCB8fCBwcm9jZXNzZWREYXRhLmRhdGEubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IGNhdGVnb3J5QXhpcyA9IHRoaXMuZ2V0Q2F0ZWdvcnlBeGlzKCk7XG4gICAgY29uc3QgdmFsdWVBeGlzID0gdGhpcy5nZXRWYWx1ZUF4aXMoKTtcbiAgICBjb25zdCBrZXlEZWYgPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZCeUlkKHRoaXMsIGB4VmFsdWVgKTtcbiAgICBjb25zdCBrZXlzID0gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBgeFZhbHVlYCwgXCJrZXlcIiwgcHJvY2Vzc2VkRGF0YSk7XG4gICAgbGV0IHlFeHRlbnQgPSBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGB5VmFsdWUtZW5kYCwgXCJ2YWx1ZVwiLCBwcm9jZXNzZWREYXRhKTtcbiAgICBjb25zdCB5RmlsdGVyRXh0ZW50ID0gdGhpcy5jcm9zc0ZpbHRlcmluZ0VuYWJsZWQoKSA/IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgYHlGaWx0ZXJWYWx1ZWAsIFwidmFsdWVcIiwgcHJvY2Vzc2VkRGF0YSkgOiB2b2lkIDA7XG4gICAgaWYgKHlGaWx0ZXJFeHRlbnQgIT0gbnVsbCkge1xuICAgICAgeUV4dGVudCA9IFtNYXRoLm1pbih5RXh0ZW50WzBdLCB5RmlsdGVyRXh0ZW50WzBdKSwgTWF0aC5tYXgoeUV4dGVudFsxXSwgeUZpbHRlckV4dGVudFsxXSldO1xuICAgIH1cbiAgICBpZiAoZGlyZWN0aW9uID09PSB0aGlzLmdldENhdGVnb3J5RGlyZWN0aW9uKCkpIHtcbiAgICAgIGlmIChrZXlEZWY/LmRlZi50eXBlID09PSBcImtleVwiICYmIGtleURlZi5kZWYudmFsdWVUeXBlID09PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICB9XG4gICAgICBjb25zdCBzY2FsZVBhZGRpbmcgPSBpc0Zpbml0ZU51bWJlcihzbWFsbGVzdERhdGFJbnRlcnZhbCkgPyBzbWFsbGVzdERhdGFJbnRlcnZhbCAqIDAuNSA6IDA7XG4gICAgICBjb25zdCBrZXlzRXh0ZW50ID0gZXh0ZW50KGtleXMpID8/IFtOYU4sIE5hTl07XG4gICAgICBjb25zdCBkMCA9IGtleXNFeHRlbnRbMF0gKyAtc2NhbGVQYWRkaW5nO1xuICAgICAgY29uc3QgZDEgPSBrZXlzRXh0ZW50WzFdICsgc2NhbGVQYWRkaW5nO1xuICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoW2QwLCBkMV0sIGNhdGVnb3J5QXhpcyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmdldFZhbHVlQXhpcygpIGluc3RhbmNlb2YgTG9nQXhpcykge1xuICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoeUV4dGVudCwgdmFsdWVBeGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZml4ZWRZRXh0ZW50ID0gW01hdGgubWluKDAsIHlFeHRlbnRbMF0pLCBNYXRoLm1heCgwLCB5RXh0ZW50WzFdKV07XG4gICAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudChmaXhlZFlFeHRlbnQsIHZhbHVlQXhpcyk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNyZWF0ZU5vZGVEYXRhKCkge1xuICAgIGNvbnN0IHsgZGF0YU1vZGVsIH0gPSB0aGlzO1xuICAgIGNvbnN0IHhBeGlzID0gdGhpcy5nZXRDYXRlZ29yeUF4aXMoKTtcbiAgICBjb25zdCB5QXhpcyA9IHRoaXMuZ2V0VmFsdWVBeGlzKCk7XG4gICAgaWYgKCFkYXRhTW9kZWwgfHwgIXhBeGlzIHx8ICF5QXhpcyB8fCAhdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB4U2NhbGUgPSB4QXhpcy5zY2FsZTtcbiAgICBjb25zdCB5U2NhbGUgPSB5QXhpcy5zY2FsZTtcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHhOYW1lLCB5TmFtZSwgZmlsbCwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgY29ybmVyUmFkaXVzLCBsZWdlbmRJdGVtTmFtZSwgbGFiZWwgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB5UmV2ZXJzZWQgPSB5QXhpcy5pc1JldmVyc2VkKCk7XG4gICAgY29uc3QgeyBiYXJXaWR0aCwgZ3JvdXBJbmRleCB9ID0gdGhpcy51cGRhdGVHcm91cFNjYWxlKHhBeGlzKTtcbiAgICBjb25zdCBiYXJPZmZzZXQgPSBDb250aW51b3VzU2NhbGUuaXMoeFNjYWxlKSA/IGJhcldpZHRoICogLTAuNSA6IDA7XG4gICAgY29uc3QgeEluZGV4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB4VmFsdWVgKTtcbiAgICBjb25zdCB5UmF3SW5kZXggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHlWYWx1ZS1yYXdgKTtcbiAgICBjb25zdCB5RmlsdGVySW5kZXggPSB0aGlzLmNyb3NzRmlsdGVyaW5nRW5hYmxlZCgpID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB5RmlsdGVyVmFsdWVgKSA6IHZvaWQgMDtcbiAgICBjb25zdCB5U3RhcnRJbmRleCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeVZhbHVlLXN0YXJ0YCk7XG4gICAgY29uc3QgeUVuZEluZGV4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB5VmFsdWUtZW5kYCk7XG4gICAgY29uc3QgeVJhbmdlSW5kZXggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHlWYWx1ZS1yYW5nZWApO1xuICAgIGNvbnN0IGFuaW1hdGlvbkVuYWJsZWQgPSAhdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKTtcbiAgICBjb25zdCBub2RlRGF0dW0gPSAoe1xuICAgICAgZGF0dW0sXG4gICAgICB2YWx1ZUluZGV4LFxuICAgICAgeFZhbHVlLFxuICAgICAgeVZhbHVlLFxuICAgICAgY3VtdWxhdGl2ZVZhbHVlLFxuICAgICAgcGhhbnRvbSxcbiAgICAgIGN1cnJZLFxuICAgICAgcHJldlksXG4gICAgICBpc1Bvc2l0aXZlLFxuICAgICAgeVJhbmdlLFxuICAgICAgbGFiZWxUZXh0LFxuICAgICAgY3Jvc3NTY2FsZSA9IDFcbiAgICB9KSA9PiB7XG4gICAgICBjb25zdCB4ID0geFNjYWxlLmNvbnZlcnQoeFZhbHVlKTtcbiAgICAgIGNvbnN0IGlzVXB3YXJkID0gaXNQb3NpdGl2ZSAhPT0geVJldmVyc2VkO1xuICAgICAgY29uc3QgYmFyWCA9IHggKyBncm91cFNjYWxlLmNvbnZlcnQoU3RyaW5nKGdyb3VwSW5kZXgpKSArIGJhck9mZnNldDtcbiAgICAgIGNvbnN0IHkgPSB5U2NhbGUuY29udmVydChjdXJyWSk7XG4gICAgICBjb25zdCBib3R0b21ZID0geVNjYWxlLmNvbnZlcnQocHJldlkpO1xuICAgICAgY29uc3QgYmFyQWxvbmdYID0gdGhpcy5nZXRCYXJEaXJlY3Rpb24oKSA9PT0gXCJ4XCIgLyogWCAqLztcbiAgICAgIGNvbnN0IGJib3hIZWlnaHQgPSB5U2NhbGUuY29udmVydCh5UmFuZ2UpO1xuICAgICAgY29uc3QgYmJveEJvdHRvbSA9IHlTY2FsZS5jb252ZXJ0KDApO1xuICAgICAgY29uc3QgeE9mZnNldCA9IGJhcldpZHRoICogMC41ICogKDEgLSBjcm9zc1NjYWxlKTtcbiAgICAgIGNvbnN0IHJlY3QgPSB7XG4gICAgICAgIHg6IGJhckFsb25nWCA/IE1hdGgubWluKHksIGJvdHRvbVkpIDogYmFyWCArIHhPZmZzZXQsXG4gICAgICAgIHk6IGJhckFsb25nWCA/IGJhclggKyB4T2Zmc2V0IDogTWF0aC5taW4oeSwgYm90dG9tWSksXG4gICAgICAgIHdpZHRoOiBiYXJBbG9uZ1ggPyBNYXRoLmFicyhib3R0b21ZIC0geSkgOiBiYXJXaWR0aCAqIGNyb3NzU2NhbGUsXG4gICAgICAgIGhlaWdodDogYmFyQWxvbmdYID8gYmFyV2lkdGggKiBjcm9zc1NjYWxlIDogTWF0aC5hYnMoYm90dG9tWSAtIHkpXG4gICAgICB9O1xuICAgICAgY29uc3QgY2xpcEJCb3ggPSBuZXcgQkJveChyZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgICAgY29uc3QgYmFyUmVjdCA9IHtcbiAgICAgICAgeDogYmFyQWxvbmdYID8gTWF0aC5taW4oYmJveEJvdHRvbSwgYmJveEhlaWdodCkgOiBiYXJYICsgeE9mZnNldCxcbiAgICAgICAgeTogYmFyQWxvbmdYID8gYmFyWCArIHhPZmZzZXQgOiBNYXRoLm1pbihiYm94Qm90dG9tLCBiYm94SGVpZ2h0KSxcbiAgICAgICAgd2lkdGg6IGJhckFsb25nWCA/IE1hdGguYWJzKGJib3hCb3R0b20gLSBiYm94SGVpZ2h0KSA6IGJhcldpZHRoICogY3Jvc3NTY2FsZSxcbiAgICAgICAgaGVpZ2h0OiBiYXJBbG9uZ1ggPyBiYXJXaWR0aCAqIGNyb3NzU2NhbGUgOiBNYXRoLmFicyhiYm94Qm90dG9tIC0gYmJveEhlaWdodClcbiAgICAgIH07XG4gICAgICBjb25zdCB7XG4gICAgICAgIGZvbnRTdHlsZTogbGFiZWxGb250U3R5bGUsXG4gICAgICAgIGZvbnRXZWlnaHQ6IGxhYmVsRm9udFdlaWdodCxcbiAgICAgICAgZm9udFNpemU6IGxhYmVsRm9udFNpemUsXG4gICAgICAgIGZvbnRGYW1pbHk6IGxhYmVsRm9udEZhbWlseSxcbiAgICAgICAgY29sb3I6IGxhYmVsQ29sb3IsXG4gICAgICAgIHBsYWNlbWVudFxuICAgICAgfSA9IGxhYmVsO1xuICAgICAgY29uc3QgbGVuZ3RoUmF0aW9NdWx0aXBsaWVyID0gdGhpcy5zaG91bGRGbGlwWFkoKSA/IHJlY3QuaGVpZ2h0IDogcmVjdC53aWR0aDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlcmllczogdGhpcyxcbiAgICAgICAgaXRlbUlkOiBwaGFudG9tID8gY3JlYXRlRGF0dW1JZCh5S2V5LCBwaGFudG9tKSA6IHlLZXksXG4gICAgICAgIGRhdHVtLFxuICAgICAgICB2YWx1ZUluZGV4LFxuICAgICAgICBjdW11bGF0aXZlVmFsdWUsXG4gICAgICAgIHBoYW50b20sXG4gICAgICAgIHhWYWx1ZSxcbiAgICAgICAgeVZhbHVlLFxuICAgICAgICB5S2V5LFxuICAgICAgICB4S2V5LFxuICAgICAgICBjYXBEZWZhdWx0czoge1xuICAgICAgICAgIGxlbmd0aFJhdGlvTXVsdGlwbGllcixcbiAgICAgICAgICBsZW5ndGhNYXg6IGxlbmd0aFJhdGlvTXVsdGlwbGllclxuICAgICAgICB9LFxuICAgICAgICB4OiBiYXJSZWN0LngsXG4gICAgICAgIHk6IGJhclJlY3QueSxcbiAgICAgICAgd2lkdGg6IGJhclJlY3Qud2lkdGgsXG4gICAgICAgIGhlaWdodDogYmFyUmVjdC5oZWlnaHQsXG4gICAgICAgIG1pZFBvaW50OiB7IHg6IHJlY3QueCArIHJlY3Qud2lkdGggLyAyLCB5OiByZWN0LnkgKyByZWN0LmhlaWdodCAvIDIgfSxcbiAgICAgICAgZmlsbCxcbiAgICAgICAgc3Ryb2tlLFxuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICB0b3BMZWZ0Q29ybmVyUmFkaXVzOiBiYXJBbG9uZ1ggIT09IGlzVXB3YXJkLFxuICAgICAgICB0b3BSaWdodENvcm5lclJhZGl1czogaXNVcHdhcmQsXG4gICAgICAgIGJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzOiBiYXJBbG9uZ1ggPT09IGlzVXB3YXJkLFxuICAgICAgICBib3R0b21MZWZ0Q29ybmVyUmFkaXVzOiAhaXNVcHdhcmQsXG4gICAgICAgIGNsaXBCQm94LFxuICAgICAgICBsYWJlbDogbGFiZWxUZXh0ICE9IG51bGwgPyB7XG4gICAgICAgICAgdGV4dDogbGFiZWxUZXh0LFxuICAgICAgICAgIGZpbGw6IGxhYmVsQ29sb3IsXG4gICAgICAgICAgZm9udFN0eWxlOiBsYWJlbEZvbnRTdHlsZSxcbiAgICAgICAgICBmb250V2VpZ2h0OiBsYWJlbEZvbnRXZWlnaHQsXG4gICAgICAgICAgZm9udFNpemU6IGxhYmVsRm9udFNpemUsXG4gICAgICAgICAgZm9udEZhbWlseTogbGFiZWxGb250RmFtaWx5LFxuICAgICAgICAgIC4uLmFkanVzdExhYmVsUGxhY2VtZW50KHtcbiAgICAgICAgICAgIGlzUG9zaXRpdmUsXG4gICAgICAgICAgICBpc1ZlcnRpY2FsOiAhYmFyQWxvbmdYLFxuICAgICAgICAgICAgcGxhY2VtZW50LFxuICAgICAgICAgICAgcmVjdFxuICAgICAgICAgIH0pXG4gICAgICAgIH0gOiB2b2lkIDAsXG4gICAgICAgIG1pc3Npbmc6IHlWYWx1ZSA9PSBudWxsLFxuICAgICAgICBmb2N1c2FibGU6ICFwaGFudG9tXG4gICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgeyBncm91cFNjYWxlLCBwcm9jZXNzZWREYXRhIH0gPSB0aGlzO1xuICAgIGNvbnN0IHBoYW50b21Ob2RlcyA9IFtdO1xuICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgY29uc3QgbGFiZWxzID0gW107XG4gICAgcHJvY2Vzc2VkRGF0YT8uZGF0YS5mb3JFYWNoKCh7IGtleXMsIGRhdHVtOiBzZXJpZXNEYXR1bSwgdmFsdWVzLCBhZ2dWYWx1ZXMgfSkgPT4ge1xuICAgICAgdmFsdWVzLmZvckVhY2goKHZhbHVlLCB2YWx1ZUluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IHhWYWx1ZSA9IGtleXNbeEluZGV4XTtcbiAgICAgICAgY29uc3QgeVJhd1ZhbHVlID0gdmFsdWVbeVJhd0luZGV4XTtcbiAgICAgICAgY29uc3QgeVN0YXJ0ID0gTnVtYmVyKHZhbHVlW3lTdGFydEluZGV4XSk7XG4gICAgICAgIGNvbnN0IHlGaWx0ZXJWYWx1ZSA9IHlGaWx0ZXJJbmRleCAhPSBudWxsID8gTnVtYmVyKHZhbHVlW3lGaWx0ZXJJbmRleF0pIDogdm9pZCAwO1xuICAgICAgICBjb25zdCB5RW5kID0gTnVtYmVyKHZhbHVlW3lFbmRJbmRleF0pO1xuICAgICAgICBjb25zdCBpc1Bvc2l0aXZlID0geVJhd1ZhbHVlID49IDAgJiYgIU9iamVjdC5pcyh5UmF3VmFsdWUsIC0wKTtcbiAgICAgICAgY29uc3QgeVJhbmdlID0gYWdnVmFsdWVzPy5beVJhbmdlSW5kZXhdW2lzUG9zaXRpdmUgPyAxIDogMF0gPz8gMDtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoeUVuZCkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoeUZpbHRlclZhbHVlICE9IG51bGwgJiYgIU51bWJlci5pc0Zpbml0ZSh5RmlsdGVyVmFsdWUpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbGFiZWxUZXh0ID0geVJhd1ZhbHVlICE9IG51bGwgPyB0aGlzLmdldExhYmVsVGV4dChcbiAgICAgICAgICB0aGlzLnByb3BlcnRpZXMubGFiZWwsXG4gICAgICAgICAge1xuICAgICAgICAgICAgZGF0dW06IHNlcmllc0RhdHVtW3ZhbHVlSW5kZXhdLFxuICAgICAgICAgICAgdmFsdWU6IHlGaWx0ZXJWYWx1ZSA/PyB5UmF3VmFsdWUsXG4gICAgICAgICAgICB4S2V5LFxuICAgICAgICAgICAgeUtleSxcbiAgICAgICAgICAgIHhOYW1lLFxuICAgICAgICAgICAgeU5hbWUsXG4gICAgICAgICAgICBsZWdlbmRJdGVtTmFtZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgKHYpID0+IGlzRmluaXRlTnVtYmVyKHYpID8gdi50b0ZpeGVkKDIpIDogU3RyaW5nKHYpXG4gICAgICAgICkgOiB2b2lkIDA7XG4gICAgICAgIGNvbnN0IGluc2V0ID0geUZpbHRlclZhbHVlICE9IG51bGwgJiYgeUZpbHRlclZhbHVlID4geVJhd1ZhbHVlO1xuICAgICAgICBjb25zdCBub2RlRGF0YSA9IG5vZGVEYXR1bSh7XG4gICAgICAgICAgZGF0dW06IHNlcmllc0RhdHVtW3ZhbHVlSW5kZXhdLFxuICAgICAgICAgIHZhbHVlSW5kZXgsXG4gICAgICAgICAgeFZhbHVlLFxuICAgICAgICAgIHlWYWx1ZTogeUZpbHRlclZhbHVlID8/IHlSYXdWYWx1ZSxcbiAgICAgICAgICBjdW11bGF0aXZlVmFsdWU6IHlGaWx0ZXJWYWx1ZSA/PyB5RW5kLFxuICAgICAgICAgIHBoYW50b206IGZhbHNlLFxuICAgICAgICAgIGN1cnJZOiB5RmlsdGVyVmFsdWUgIT0gbnVsbCA/IHlTdGFydCArIHlGaWx0ZXJWYWx1ZSA6IHlFbmQsXG4gICAgICAgICAgcHJldlk6IHlTdGFydCxcbiAgICAgICAgICBpc1Bvc2l0aXZlLFxuICAgICAgICAgIHlSYW5nZTogTWF0aC5tYXgoeVN0YXJ0ICsgKHlGaWx0ZXJWYWx1ZSA/PyAtSW5maW5pdHkpLCB5UmFuZ2UpLFxuICAgICAgICAgIGxhYmVsVGV4dCxcbiAgICAgICAgICBjcm9zc1NjYWxlOiBpbnNldCA/IDAuNiA6IHZvaWQgMFxuICAgICAgICB9KTtcbiAgICAgICAgbm9kZXMucHVzaChub2RlRGF0YSk7XG4gICAgICAgIGxhYmVscy5wdXNoKG5vZGVEYXRhKTtcbiAgICAgICAgaWYgKHlGaWx0ZXJWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgY29uc3QgcGhhbnRvbU5vZGVEYXRhID0gbm9kZURhdHVtKHtcbiAgICAgICAgICAgIGRhdHVtOiBzZXJpZXNEYXR1bVt2YWx1ZUluZGV4XSxcbiAgICAgICAgICAgIHZhbHVlSW5kZXgsXG4gICAgICAgICAgICB4VmFsdWUsXG4gICAgICAgICAgICB5VmFsdWU6IHlGaWx0ZXJWYWx1ZSxcbiAgICAgICAgICAgIGN1bXVsYXRpdmVWYWx1ZTogeUZpbHRlclZhbHVlLFxuICAgICAgICAgICAgcGhhbnRvbTogdHJ1ZSxcbiAgICAgICAgICAgIGN1cnJZOiB5RW5kLFxuICAgICAgICAgICAgcHJldlk6IHlTdGFydCxcbiAgICAgICAgICAgIGlzUG9zaXRpdmUsXG4gICAgICAgICAgICB5UmFuZ2UsXG4gICAgICAgICAgICBsYWJlbFRleHQ6IHZvaWQgMCxcbiAgICAgICAgICAgIGNyb3NzU2NhbGU6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHBoYW50b21Ob2Rlcy5wdXNoKHBoYW50b21Ob2RlRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICBub2RlRGF0YTogcGhhbnRvbU5vZGVzLmxlbmd0aCA+IDAgPyBbLi4ucGhhbnRvbU5vZGVzLCAuLi5ub2Rlc10gOiBub2RlcyxcbiAgICAgIGxhYmVsRGF0YTogbGFiZWxzLFxuICAgICAgc2NhbGVzOiB0aGlzLmNhbGN1bGF0ZVNjYWxpbmcoKSxcbiAgICAgIHZpc2libGU6IHRoaXMudmlzaWJsZSB8fCBhbmltYXRpb25FbmFibGVkXG4gICAgfTtcbiAgfVxuICBub2RlRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IFJlY3QoKTtcbiAgfVxuICBnZXRIaWdobGlnaHREYXRhKG5vZGVEYXRhLCBoaWdobGlnaHRlZEl0ZW0pIHtcbiAgICBjb25zdCBoaWdobGlnaHRJdGVtID0gbm9kZURhdGEuZmluZChcbiAgICAgIChub2RlRGF0dW0pID0+IG5vZGVEYXR1bS5kYXR1bSA9PT0gaGlnaGxpZ2h0ZWRJdGVtLmRhdHVtICYmICFub2RlRGF0dW0ucGhhbnRvbVxuICAgICk7XG4gICAgcmV0dXJuIGhpZ2hsaWdodEl0ZW0gIT0gbnVsbCA/IFtoaWdobGlnaHRJdGVtXSA6IHZvaWQgMDtcbiAgfVxuICBhc3luYyB1cGRhdGVEYXR1bVNlbGVjdGlvbihvcHRzKSB7XG4gICAgcmV0dXJuIG9wdHMuZGF0dW1TZWxlY3Rpb24udXBkYXRlKFxuICAgICAgb3B0cy5ub2RlRGF0YSxcbiAgICAgIHZvaWQgMCxcbiAgICAgIChkYXR1bSkgPT4gY3JlYXRlRGF0dW1JZChkYXR1bS54VmFsdWUsIGRhdHVtLnZhbHVlSW5kZXgsIGRhdHVtLnBoYW50b20pXG4gICAgKTtcbiAgfVxuICBhc3luYyB1cGRhdGVEYXR1bU5vZGVzKG9wdHMpIHtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgeUtleSxcbiAgICAgIHN0YWNrR3JvdXAsXG4gICAgICBmaWxsLFxuICAgICAgZmlsbE9wYWNpdHksXG4gICAgICBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICBsaW5lRGFzaCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgaXRlbVN0eWxlcixcbiAgICAgIHNoYWRvdyxcbiAgICAgIGhpZ2hsaWdodFN0eWxlOiB7IGl0ZW06IGl0ZW1IaWdobGlnaHRTdHlsZSB9XG4gICAgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB4QXhpcyA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCBjcmlzcCA9IHRoaXMucHJvcGVydGllcy5jcmlzcCA/PyBjaGVja0NyaXNwKHhBeGlzPy5zY2FsZSwgeEF4aXM/LnZpc2libGVSYW5nZSwgdGhpcy5zbWFsbGVzdERhdGFJbnRlcnZhbCwgdGhpcy5sYXJnZXN0RGF0YUludGVydmFsKTtcbiAgICBjb25zdCBjYXRlZ29yeUFsb25nWCA9IHRoaXMuZ2V0Q2F0ZWdvcnlEaXJlY3Rpb24oKSA9PT0gXCJ4XCIgLyogWCAqLztcbiAgICBjb25zdCBzdHlsZSA9IHtcbiAgICAgIGZpbGwsXG4gICAgICBzdHJva2UsXG4gICAgICBsaW5lRGFzaCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgZmlsbFNoYWRvdzogc2hhZG93LFxuICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuZ2V0U3Ryb2tlV2lkdGgoc3Ryb2tlV2lkdGgpLFxuICAgICAgZmlsbE9wYWNpdHk6IDAsXG4gICAgICBzdHJva2VPcGFjaXR5OiAwXG4gICAgfTtcbiAgICBjb25zdCByZWN0UGFyYW1zID0ge1xuICAgICAgZGF0dW06IHZvaWQgMCxcbiAgICAgIGN0eDogdGhpcy5jdHgsXG4gICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgIGlzSGlnaGxpZ2h0ZWQ6IG9wdHMuaXNIaWdobGlnaHQsXG4gICAgICBoaWdobGlnaHRTdHlsZTogaXRlbUhpZ2hsaWdodFN0eWxlLFxuICAgICAgeUtleSxcbiAgICAgIHN0eWxlLFxuICAgICAgaXRlbVN0eWxlcixcbiAgICAgIHN0YWNrR3JvdXBcbiAgICB9O1xuICAgIG9wdHMuZGF0dW1TZWxlY3Rpb24uZWFjaCgocmVjdCwgZGF0dW0pID0+IHtcbiAgICAgIHN0eWxlLmZpbGxPcGFjaXR5ID0gZmlsbE9wYWNpdHkgKiAoZGF0dW0ucGhhbnRvbSA/IDAuMiA6IDEpO1xuICAgICAgc3R5bGUuc3Ryb2tlT3BhY2l0eSA9IHN0cm9rZU9wYWNpdHkgKiAoZGF0dW0ucGhhbnRvbSA/IDAuMiA6IDEpO1xuICAgICAgc3R5bGUuY29ybmVyUmFkaXVzID0gZGF0dW0uY29ybmVyUmFkaXVzO1xuICAgICAgc3R5bGUudG9wTGVmdENvcm5lclJhZGl1cyA9IGRhdHVtLnRvcExlZnRDb3JuZXJSYWRpdXM7XG4gICAgICBzdHlsZS50b3BSaWdodENvcm5lclJhZGl1cyA9IGRhdHVtLnRvcFJpZ2h0Q29ybmVyUmFkaXVzO1xuICAgICAgc3R5bGUuYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMgPSBkYXR1bS5ib3R0b21SaWdodENvcm5lclJhZGl1cztcbiAgICAgIHN0eWxlLmJvdHRvbUxlZnRDb3JuZXJSYWRpdXMgPSBkYXR1bS5ib3R0b21MZWZ0Q29ybmVyUmFkaXVzO1xuICAgICAgY29uc3QgdmlzaWJsZSA9IGNhdGVnb3J5QWxvbmdYID8gKGRhdHVtLmNsaXBCQm94Py53aWR0aCA/PyBkYXR1bS53aWR0aCkgPiAwIDogKGRhdHVtLmNsaXBCQm94Py5oZWlnaHQgPz8gZGF0dW0uaGVpZ2h0KSA+IDA7XG4gICAgICByZWN0UGFyYW1zLmRhdHVtID0gZGF0dW07XG4gICAgICBjb25zdCBjb25maWcgPSBnZXRSZWN0Q29uZmlnKHJlY3RQYXJhbXMpO1xuICAgICAgY29uZmlnLmNyaXNwID0gY3Jpc3A7XG4gICAgICBjb25maWcudmlzaWJsZSA9IHZpc2libGU7XG4gICAgICB1cGRhdGVSZWN0KHJlY3QsIGNvbmZpZyk7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTGFiZWxTZWxlY3Rpb24ob3B0cykge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmlzTGFiZWxFbmFibGVkKCkgPyBvcHRzLmxhYmVsRGF0YSA6IFtdO1xuICAgIHJldHVybiBvcHRzLmxhYmVsU2VsZWN0aW9uLnVwZGF0ZShkYXRhLCAodGV4dCkgPT4ge1xuICAgICAgdGV4dC5wb2ludGVyRXZlbnRzID0gMSAvKiBOb25lICovO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUxhYmVsTm9kZXMob3B0cykge1xuICAgIG9wdHMubGFiZWxTZWxlY3Rpb24uZWFjaCgodGV4dE5vZGUsIGRhdHVtKSA9PiB7XG4gICAgICB1cGRhdGVMYWJlbE5vZGUodGV4dE5vZGUsIHRoaXMucHJvcGVydGllcy5sYWJlbCwgZGF0dW0ubGFiZWwpO1xuICAgIH0pO1xuICB9XG4gIGdldFRvb2x0aXBIdG1sKG5vZGVEYXR1bSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgIHByb2Nlc3NlZERhdGEsXG4gICAgICBjdHg6IHsgY2FsbGJhY2tDYWNoZSB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgeEF4aXMgPSB0aGlzLmdldENhdGVnb3J5QXhpcygpO1xuICAgIGNvbnN0IHlBeGlzID0gdGhpcy5nZXRWYWx1ZUF4aXMoKTtcbiAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgIXhBeGlzIHx8ICF5QXhpcykge1xuICAgICAgcmV0dXJuIEVNUFRZX1RPT0xUSVBfQ09OVEVOVDtcbiAgICB9XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCB4TmFtZSwgeU5hbWUsIGZpbGwsIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHRvb2x0aXAsIGl0ZW1TdHlsZXIsIHN0YWNrR3JvdXAsIGxlZ2VuZEl0ZW1OYW1lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyB4VmFsdWUsIHlWYWx1ZSwgZGF0dW0sIGl0ZW1JZCB9ID0gbm9kZURhdHVtO1xuICAgIGNvbnN0IHhTdHJpbmcgPSB4QXhpcy5mb3JtYXREYXR1bSh4VmFsdWUpO1xuICAgIGNvbnN0IHlTdHJpbmcgPSB5QXhpcy5mb3JtYXREYXR1bSh5VmFsdWUpO1xuICAgIGNvbnN0IHRpdGxlID0gc2FuaXRpemVIdG1sKHlOYW1lKTtcbiAgICBjb25zdCBjb250ZW50ID0gc2FuaXRpemVIdG1sKHhTdHJpbmcgKyBcIjogXCIgKyB5U3RyaW5nKTtcbiAgICBsZXQgZm9ybWF0O1xuICAgIGlmIChpdGVtU3R5bGVyKSB7XG4gICAgICBmb3JtYXQgPSBjYWxsYmFja0NhY2hlLmNhbGwoaXRlbVN0eWxlciwge1xuICAgICAgICBzZXJpZXNJZCxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHhLZXksXG4gICAgICAgIHlLZXksXG4gICAgICAgIHN0YWNrR3JvdXAsXG4gICAgICAgIGZpbGwsXG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuZ2V0U3Ryb2tlV2lkdGgoc3Ryb2tlV2lkdGgpLFxuICAgICAgICBoaWdobGlnaHRlZDogZmFsc2UsXG4gICAgICAgIGNvcm5lclJhZGl1czogdGhpcy5wcm9wZXJ0aWVzLmNvcm5lclJhZGl1cyxcbiAgICAgICAgZmlsbE9wYWNpdHk6IHRoaXMucHJvcGVydGllcy5maWxsT3BhY2l0eSxcbiAgICAgICAgc3Ryb2tlT3BhY2l0eTogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZU9wYWNpdHksXG4gICAgICAgIGxpbmVEYXNoOiB0aGlzLnByb3BlcnRpZXMubGluZURhc2ggPz8gW10sXG4gICAgICAgIGxpbmVEYXNoT2Zmc2V0OiB0aGlzLnByb3BlcnRpZXMubGluZURhc2hPZmZzZXRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBjb2xvciA9IGZvcm1hdD8uZmlsbCA/PyBmaWxsO1xuICAgIHJldHVybiB0b29sdGlwLnRvVG9vbHRpcEh0bWwoXG4gICAgICB7IHRpdGxlLCBjb250ZW50LCBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yIH0sXG4gICAgICB7XG4gICAgICAgIHNlcmllc0lkLFxuICAgICAgICBpdGVtSWQsXG4gICAgICAgIGRhdHVtLFxuICAgICAgICB4S2V5LFxuICAgICAgICB5S2V5LFxuICAgICAgICB4TmFtZSxcbiAgICAgICAgeU5hbWUsXG4gICAgICAgIHN0YWNrR3JvdXAsXG4gICAgICAgIHRpdGxlLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgbGVnZW5kSXRlbU5hbWUsXG4gICAgICAgIC4uLnRoaXMuZ2V0TW9kdWxlVG9vbHRpcFBhcmFtcygpXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpIHtcbiAgICBjb25zdCB7IHNob3dJbkxlZ2VuZCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGlmIChsZWdlbmRUeXBlICE9PSBcImNhdGVnb3J5XCIgfHwgIXRoaXMuZGF0YT8ubGVuZ3RoIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpIHx8ICFzaG93SW5MZWdlbmQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgeyB5S2V5LCB5TmFtZSwgZmlsbCwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgZmlsbE9wYWNpdHksIHN0cm9rZU9wYWNpdHksIGxlZ2VuZEl0ZW1OYW1lLCB2aXNpYmxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgbGVnZW5kVHlwZTogXCJjYXRlZ29yeVwiLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgaXRlbUlkOiB5S2V5LFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZCxcbiAgICAgICAgZW5hYmxlZDogdmlzaWJsZSxcbiAgICAgICAgbGFiZWw6IHsgdGV4dDogbGVnZW5kSXRlbU5hbWUgPz8geU5hbWUgPz8geUtleSB9LFxuICAgICAgICBzeW1ib2xzOiBbeyBtYXJrZXI6IHsgZmlsbCwgZmlsbE9wYWNpdHksIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0cm9rZU9wYWNpdHkgfSB9XSxcbiAgICAgICAgbGVnZW5kSXRlbU5hbWVcbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KHsgZGF0dW1TZWxlY3Rpb24sIGxhYmVsU2VsZWN0aW9uLCBhbm5vdGF0aW9uU2VsZWN0aW9ucyB9KSB7XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZUJhckFuaW1hdGlvbkZ1bmN0aW9ucyhjb2xsYXBzZWRTdGFydGluZ0JhclBvc2l0aW9uKHRoaXMuaXNWZXJ0aWNhbCgpLCB0aGlzLmF4ZXMsIFwibm9ybWFsXCIpKTtcbiAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgXCJub2Rlc1wiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBbZGF0dW1TZWxlY3Rpb25dLCBmbnMpO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImFubm90YXRpb25zXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIC4uLmFubm90YXRpb25TZWxlY3Rpb25zKTtcbiAgfVxuICBhbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KGRhdGEpIHtcbiAgICBjb25zdCB7IGRhdHVtU2VsZWN0aW9uLCBsYWJlbFNlbGVjdGlvbiwgYW5ub3RhdGlvblNlbGVjdGlvbnMsIHByZXZpb3VzQ29udGV4dERhdGEgfSA9IGRhdGE7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5zdG9wQnlBbmltYXRpb25Hcm91cElkKHRoaXMuaWQpO1xuICAgIGNvbnN0IGRhdGFEaWZmID0gdGhpcy5wcm9jZXNzZWREYXRhPy5yZWR1Y2VkPy5kaWZmO1xuICAgIGNvbnN0IG1vZGUgPSBwcmV2aW91c0NvbnRleHREYXRhID09IG51bGwgPyBcImZhZGVcIiA6IFwibm9ybWFsXCI7XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZUJhckFuaW1hdGlvbkZ1bmN0aW9ucyhjb2xsYXBzZWRTdGFydGluZ0JhclBvc2l0aW9uKHRoaXMuaXNWZXJ0aWNhbCgpLCB0aGlzLmF4ZXMsIG1vZGUpKTtcbiAgICBmcm9tVG9Nb3Rpb24oXG4gICAgICB0aGlzLmlkLFxuICAgICAgXCJub2Rlc1wiLFxuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFtkYXR1bVNlbGVjdGlvbl0sXG4gICAgICBmbnMsXG4gICAgICAoXywgZGF0dW0pID0+IGNyZWF0ZURhdHVtSWQoZGF0dW0ueFZhbHVlLCBkYXR1bS52YWx1ZUluZGV4LCBkYXR1bS5waGFudG9tKSxcbiAgICAgIGRhdGFEaWZmXG4gICAgKTtcbiAgICBjb25zdCBoYXNNb3Rpb24gPSBkYXRhRGlmZj8uY2hhbmdlZCA/PyB0cnVlO1xuICAgIGlmIChoYXNNb3Rpb24pIHtcbiAgICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9uKTtcbiAgICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiYW5ub3RhdGlvbnNcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgLi4uYW5ub3RhdGlvblNlbGVjdGlvbnMpO1xuICAgIH1cbiAgfVxuICBpc0xhYmVsRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsLmVuYWJsZWQ7XG4gIH1cbiAgY29tcHV0ZUZvY3VzQm91bmRzKHsgZGF0dW1JbmRleCwgc2VyaWVzUmVjdCB9KSB7XG4gICAgY29uc3QgZGF0dW1Cb3ggPSB0aGlzLmNvbnRleHROb2RlRGF0YT8ubm9kZURhdGFbZGF0dW1JbmRleF0uY2xpcEJCb3g7XG4gICAgcmV0dXJuIGNvbXB1dGVCYXJGb2N1c0JvdW5kcyhkYXR1bUJveCwgdGhpcy5jb250ZW50R3JvdXAsIHNlcmllc1JlY3QpO1xuICB9XG59O1xuQmFyU2VyaWVzLmNsYXNzTmFtZSA9IFwiQmFyU2VyaWVzXCI7XG5CYXJTZXJpZXMudHlwZSA9IFwiYmFyXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vYmFyU2VyaWVzTW9kdWxlLnRzXG52YXIgQmFyU2VyaWVzTW9kdWxlID0ge1xuICB0eXBlOiBcInNlcmllc1wiLFxuICBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sXG4gIGlkZW50aWZpZXI6IFwiYmFyXCIsXG4gIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBCYXJTZXJpZXMoY3R4KSxcbiAgc3RhY2thYmxlOiB0cnVlLFxuICBncm91cGFibGU6IHRydWUsXG4gIHRvb2x0aXBEZWZhdWx0czogeyByYW5nZTogXCJleGFjdFwiIH0sXG4gIGRlZmF1bHRBeGVzOiBbXG4gICAge1xuICAgICAgdHlwZTogXCJudW1iZXJcIiAvKiBOVU1CRVIgKi8sXG4gICAgICBwb3NpdGlvbjogXCJsZWZ0XCIgLyogTEVGVCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJjYXRlZ29yeVwiIC8qIENBVEVHT1JZICovLFxuICAgICAgcG9zaXRpb246IFwiYm90dG9tXCIgLyogQk9UVE9NICovXG4gICAgfVxuICBdLFxuICBzd2FwRGVmYXVsdEF4ZXNDb25kaXRpb246IChzZXJpZXMpID0+IHNlcmllcz8uZGlyZWN0aW9uID09PSBcImhvcml6b250YWxcIixcbiAgdGhlbWVUZW1wbGF0ZToge1xuICAgIHNlcmllczoge1xuICAgICAgZGlyZWN0aW9uOiBcInZlcnRpY2FsXCIsXG4gICAgICBmaWxsT3BhY2l0eTogMSxcbiAgICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgICAgbGluZURhc2g6IFswXSxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiAwLFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIgLyogTk9STUFMICovLFxuICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX0lOU0lERV9TRVJJRVNfTEFCRUxfQ09MT1VSLFxuICAgICAgICBwbGFjZW1lbnQ6IFwiaW5zaWRlXCJcbiAgICAgIH0sXG4gICAgICBzaGFkb3c6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX1NIQURPV19DT0xPVVIsXG4gICAgICAgIHhPZmZzZXQ6IDMsXG4gICAgICAgIHlPZmZzZXQ6IDMsXG4gICAgICAgIGJsdXI6IDVcbiAgICAgIH0sXG4gICAgICBlcnJvckJhcjoge1xuICAgICAgICBjYXA6IHtcbiAgICAgICAgICBsZW5ndGhSYXRpbzogMC4zXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBhbGV0dGVGYWN0b3J5OiBzaW5nbGVTZXJpZXNQYWxldHRlRmFjdG9yeVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc2NhbGUvY29sb3JTY2FsZS50c1xudmFyIGNvbnZlcnRDb2xvclN0cmluZ1RvT2tsY2hhID0gKHYpID0+IHtcbiAgY29uc3QgY29sb3IgPSBDb2xvci5mcm9tU3RyaW5nKHYpO1xuICBjb25zdCBbbCwgYywgaF0gPSBDb2xvci5SR0J0b09LTENIKGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIpO1xuICByZXR1cm4geyBsLCBjLCBoLCBhOiBjb2xvci5hIH07XG59O1xudmFyIGRlbHRhID0gMWUtNjtcbnZhciBpc0FjaHJvbWF0aWMgPSAoeCkgPT4geC5jIDwgZGVsdGEgfHwgeC5sIDwgZGVsdGEgfHwgeC5sID4gMSAtIGRlbHRhO1xudmFyIGludGVycG9sYXRlT2tsY2ggPSAoeCwgeSwgZCkgPT4ge1xuICBkID0gY2xhbXAoMCwgZCwgMSk7XG4gIGxldCBoO1xuICBpZiAoaXNBY2hyb21hdGljKHgpKSB7XG4gICAgaCA9IHkuaDtcbiAgfSBlbHNlIGlmIChpc0FjaHJvbWF0aWMoeSkpIHtcbiAgICBoID0geC5oO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHhIID0geC5oO1xuICAgIGxldCB5SCA9IHkuaDtcbiAgICBjb25zdCBkZWx0YUggPSB5LmggLSB4Lmg7XG4gICAgaWYgKGRlbHRhSCA+IDE4MCkge1xuICAgICAgeUggLT0gMzYwO1xuICAgIH0gZWxzZSBpZiAoZGVsdGFIIDwgLTE4MCkge1xuICAgICAgeUggKz0gMzYwO1xuICAgIH1cbiAgICBoID0geEggKiAoMSAtIGQpICsgeUggKiBkO1xuICB9XG4gIGNvbnN0IGMgPSB4LmMgKiAoMSAtIGQpICsgeS5jICogZDtcbiAgY29uc3QgbCA9IHgubCAqICgxIC0gZCkgKyB5LmwgKiBkO1xuICBjb25zdCBhID0geC5hICogKDEgLSBkKSArIHkuYSAqIGQ7XG4gIHJldHVybiBDb2xvci5mcm9tT0tMQ0gobCwgYywgaCwgYSk7XG59O1xudmFyIENvbG9yU2NhbGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudHlwZSA9IFwiY29sb3JcIjtcbiAgICB0aGlzLmludmFsaWQgPSB0cnVlO1xuICAgIHRoaXMuZG9tYWluID0gWzAsIDFdO1xuICAgIHRoaXMucmFuZ2UgPSBbXCJyZWRcIiwgXCJibHVlXCJdO1xuICAgIHRoaXMucGFyc2VkUmFuZ2UgPSB0aGlzLnJhbmdlLm1hcChjb252ZXJ0Q29sb3JTdHJpbmdUb09rbGNoYSk7XG4gIH1cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IHsgZG9tYWluLCByYW5nZTogcmFuZ2UzIH0gPSB0aGlzO1xuICAgIGlmIChkb21haW4ubGVuZ3RoIDwgMikge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKFwiYGNvbG9yRG9tYWluYCBzaG91bGQgaGF2ZSBhdCBsZWFzdCAyIHZhbHVlcy5cIik7XG4gICAgICBpZiAoZG9tYWluLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkb21haW4ucHVzaCgwLCAxKTtcbiAgICAgIH0gZWxzZSBpZiAoZG9tYWluLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBkb21haW4ucHVzaChkb21haW5bMF0gKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBkb21haW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGEgPSBkb21haW5baSAtIDFdO1xuICAgICAgY29uc3QgYiA9IGRvbWFpbltpXTtcbiAgICAgIGlmIChhID49IGIpIHtcbiAgICAgICAgTG9nZ2VyLndhcm5PbmNlKFwiYGNvbG9yRG9tYWluYCB2YWx1ZXMgc2hvdWxkIGJlIHN1cHBsaWVkIGluIGFzY2VuZGluZyBvcmRlci5cIik7XG4gICAgICAgIGRvbWFpbi5zb3J0KChhMiwgYjIpID0+IGEyIC0gYjIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJhbmdlMy5sZW5ndGggPCBkb21haW4ubGVuZ3RoKSB7XG4gICAgICBmb3IgKGxldCBpID0gcmFuZ2UzLmxlbmd0aDsgaSA8IGRvbWFpbi5sZW5ndGg7IGkrKykge1xuICAgICAgICByYW5nZTMucHVzaChyYW5nZTMubGVuZ3RoID4gMCA/IHJhbmdlM1swXSA6IFwiYmxhY2tcIik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucGFyc2VkUmFuZ2UgPSB0aGlzLnJhbmdlLm1hcChjb252ZXJ0Q29sb3JTdHJpbmdUb09rbGNoYSk7XG4gIH1cbiAgY29udmVydCh4KSB7XG4gICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgY29uc3QgeyBkb21haW4sIHJhbmdlOiByYW5nZTMsIHBhcnNlZFJhbmdlIH0gPSB0aGlzO1xuICAgIGNvbnN0IGQwID0gZG9tYWluWzBdO1xuICAgIGNvbnN0IGQxID0gZG9tYWluLmF0KC0xKTtcbiAgICBjb25zdCByMCA9IHJhbmdlM1swXTtcbiAgICBjb25zdCByMSA9IHJhbmdlM1tyYW5nZTMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHggPD0gZDApIHtcbiAgICAgIHJldHVybiByMDtcbiAgICB9XG4gICAgaWYgKHggPj0gZDEpIHtcbiAgICAgIHJldHVybiByMTtcbiAgICB9XG4gICAgbGV0IGluZGV4O1xuICAgIGxldCBxO1xuICAgIGlmIChkb21haW4ubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCB0ID0gKHggLSBkMCkgLyAoZDEgLSBkMCk7XG4gICAgICBjb25zdCBzdGVwID0gMSAvIChyYW5nZTMubGVuZ3RoIC0gMSk7XG4gICAgICBpbmRleCA9IHJhbmdlMy5sZW5ndGggPD0gMiA/IDAgOiBNYXRoLm1pbihNYXRoLmZsb29yKHQgKiAocmFuZ2UzLmxlbmd0aCAtIDEpKSwgcmFuZ2UzLmxlbmd0aCAtIDIpO1xuICAgICAgcSA9ICh0IC0gaW5kZXggKiBzdGVwKSAvIHN0ZXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGRvbWFpbi5sZW5ndGggLSAyOyBpbmRleCsrKSB7XG4gICAgICAgIGlmICh4IDwgZG9tYWluW2luZGV4ICsgMV0pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgYSA9IGRvbWFpbltpbmRleF07XG4gICAgICBjb25zdCBiID0gZG9tYWluW2luZGV4ICsgMV07XG4gICAgICBxID0gKHggLSBhKSAvIChiIC0gYSk7XG4gICAgfVxuICAgIGNvbnN0IGMwID0gcGFyc2VkUmFuZ2VbaW5kZXhdO1xuICAgIGNvbnN0IGMxID0gcGFyc2VkUmFuZ2VbaW5kZXggKyAxXTtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGVPa2xjaChjMCwgYzEsIHEpLnRvUmdiYVN0cmluZygpO1xuICB9XG4gIHJlZnJlc2goKSB7XG4gICAgaWYgKCF0aGlzLmludmFsaWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5pbnZhbGlkID0gZmFsc2U7XG4gICAgdGhpcy51cGRhdGUoKTtcbiAgICBpZiAodGhpcy5pbnZhbGlkKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoXCJFeHBlY3RlZCB1cGRhdGUgdG8gbm90IGludmFsaWRhdGUgc2NhbGVcIik7XG4gICAgfVxuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgSW52YWxpZGF0aW5nXG5dLCBDb2xvclNjYWxlLnByb3RvdHlwZSwgXCJkb21haW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBJbnZhbGlkYXRpbmdcbl0sIENvbG9yU2NhbGUucHJvdG90eXBlLCBcInJhbmdlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2J1YmJsZVNlcmllc1Byb3BlcnRpZXMudHNcbnZhciBCdWJibGVTZXJpZXNNYXJrZXIgPSBjbGFzcyBleHRlbmRzIFNlcmllc01hcmtlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5tYXhTaXplID0gMzA7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgQnViYmxlU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJtYXhTaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSX0FSUkFZLCB7IG9wdGlvbmFsOiB0cnVlIH0pLFxuICBTY2VuZUNoYW5nZURldGVjdGlvbih7IHJlZHJhdzogMyAvKiBNQUpPUiAqLyB9KVxuXSwgQnViYmxlU2VyaWVzTWFya2VyLnByb3RvdHlwZSwgXCJkb21haW5cIiwgMik7XG52YXIgQnViYmxlU2VyaWVzTGFiZWwgPSBjbGFzcyBleHRlbmRzIExhYmVsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnBsYWNlbWVudCA9IFwidG9wXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShMQUJFTF9QTEFDRU1FTlQpXG5dLCBCdWJibGVTZXJpZXNMYWJlbC5wcm90b3R5cGUsIFwicGxhY2VtZW50XCIsIDIpO1xudmFyIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllc1Byb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuY29sb3JSYW5nZSA9IFtcIiNmZmZmMDBcIiwgXCIjMDBmZjAwXCIsIFwiIzAwMDBmZlwiXTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IEJ1YmJsZVNlcmllc0xhYmVsKCk7XG4gICAgdGhpcy50b29sdGlwID0gbmV3IFNlcmllc1Rvb2x0aXAoKTtcbiAgICAvLyBObyB2YWxpZGF0aW9uLiBOb3QgYSBwYXJ0IG9mIHRoZSBvcHRpb25zIGNvbnRyYWN0LlxuICAgIHRoaXMubWFya2VyID0gbmV3IEJ1YmJsZVNlcmllc01hcmtlcigpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieEtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaXplS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsYWJlbEtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29sb3JLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2l6ZU5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxhYmVsTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29sb3JOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSX0FSUkFZLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb2xvckRvbWFpblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklOR19BUlJBWSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbG9yUmFuZ2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInRpdGxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5zaGFwZVwiKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2hhcGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLnNpemVcIilcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLm1heFNpemVcIilcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIm1heFNpemVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLmRvbWFpblwiLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBCdWJibGVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJkb21haW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLmZpbGxcIiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuZmlsbE9wYWNpdHlcIilcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5zdHJva2VcIiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5zdHJva2VXaWR0aFwiKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLnN0cm9rZU9wYWNpdHlcIilcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLml0ZW1TdHlsZXJcIiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaXRlbVN0eWxlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgQnViYmxlU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9idWJibGVTZXJpZXMudHNcbnZhciBCdWJibGVTZXJpZXNOb2RlRXZlbnQgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllc05vZGVFdmVudCB7XG4gIGNvbnN0cnVjdG9yKHR5cGUsIG5hdGl2ZUV2ZW50LCBkYXR1bSwgc2VyaWVzKSB7XG4gICAgc3VwZXIodHlwZSwgbmF0aXZlRXZlbnQsIGRhdHVtLCBzZXJpZXMpO1xuICAgIHRoaXMuc2l6ZUtleSA9IHNlcmllcy5wcm9wZXJ0aWVzLnNpemVLZXk7XG4gIH1cbn07XG52YXIgQnViYmxlU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBDYXJ0ZXNpYW5TZXJpZXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcih7XG4gICAgICBtb2R1bGVDdHgsXG4gICAgICBkaXJlY3Rpb25LZXlzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fS0VZUyxcbiAgICAgIGRpcmVjdGlvbk5hbWVzOiBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fTkFNRVMsXG4gICAgICBwaWNrTW9kZXM6IFtcbiAgICAgICAgMiAvKiBORUFSRVNUX0JZX01BSU5fQ0FURUdPUllfQVhJU19GSVJTVCAqLyxcbiAgICAgICAgMyAvKiBORUFSRVNUX05PREUgKi8sXG4gICAgICAgIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9cbiAgICAgIF0sXG4gICAgICBwYXRoc1BlclNlcmllczogW10sXG4gICAgICBoYXNNYXJrZXJzOiB0cnVlLFxuICAgICAgbWFya2VyU2VsZWN0aW9uR2FyYmFnZUNvbGxlY3Rpb246IGZhbHNlLFxuICAgICAgYW5pbWF0aW9uUmVzZXRGbnM6IHtcbiAgICAgICAgbGFiZWw6IHJlc2V0TGFiZWxGbixcbiAgICAgICAgbWFya2VyOiByZXNldE1hcmtlckZuXG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5Ob2RlRXZlbnQgPSBCdWJibGVTZXJpZXNOb2RlRXZlbnQ7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gbmV3IEJ1YmJsZVNlcmllc1Byb3BlcnRpZXMoKTtcbiAgICB0aGlzLnNpemVTY2FsZSA9IG5ldyBMaW5lYXJTY2FsZSgpO1xuICAgIHRoaXMuY29sb3JTY2FsZSA9IG5ldyBDb2xvclNjYWxlKCk7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0RhdGEoZGF0YUNvbnRyb2xsZXIpIHtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgdGhpcy5kYXRhID09IG51bGwgfHwgIXRoaXMudmlzaWJsZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB4U2NhbGUgPSB0aGlzLmF4ZXNbXCJ4XCIgLyogWCAqL10/LnNjYWxlO1xuICAgIGNvbnN0IHlTY2FsZSA9IHRoaXMuYXhlc1tcInlcIiAvKiBZICovXT8uc2NhbGU7XG4gICAgY29uc3QgeyB4U2NhbGVUeXBlLCB5U2NhbGVUeXBlIH0gPSB0aGlzLmdldFNjYWxlSW5mb3JtYXRpb24oeyB4U2NhbGUsIHlTY2FsZSB9KTtcbiAgICBjb25zdCBjb2xvclNjYWxlVHlwZSA9IHRoaXMuY29sb3JTY2FsZS50eXBlO1xuICAgIGNvbnN0IHNpemVTY2FsZVR5cGUgPSB0aGlzLnNpemVTY2FsZS50eXBlO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgc2l6ZUtleSwgbGFiZWxLZXksIGNvbG9yRG9tYWluLCBjb2xvclJhbmdlLCBjb2xvcktleSwgbWFya2VyIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEgfSA9IGF3YWl0IHRoaXMucmVxdWVzdERhdGFNb2RlbChkYXRhQ29udHJvbGxlciwgdGhpcy5kYXRhLCB7XG4gICAgICBwcm9wczogW1xuICAgICAgICBrZXlQcm9wZXJ0eSh4S2V5LCB4U2NhbGVUeXBlLCB7IGlkOiBcInhLZXktcmF3XCIgfSksXG4gICAgICAgIGtleVByb3BlcnR5KHlLZXksIHlTY2FsZVR5cGUsIHsgaWQ6IFwieUtleS1yYXdcIiB9KSxcbiAgICAgICAgLi4ubGFiZWxLZXkgPyBba2V5UHJvcGVydHkobGFiZWxLZXksIFwiYmFuZFwiLCB7IGlkOiBgbGFiZWxLZXktcmF3YCB9KV0gOiBbXSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eSh4S2V5LCB4U2NhbGVUeXBlLCB7IGlkOiBgeFZhbHVlYCB9KSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eSh5S2V5LCB5U2NhbGVUeXBlLCB7IGlkOiBgeVZhbHVlYCB9KSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eShzaXplS2V5LCBzaXplU2NhbGVUeXBlLCB7IGlkOiBgc2l6ZVZhbHVlYCB9KSxcbiAgICAgICAgLi4uY29sb3JLZXkgPyBbdmFsdWVQcm9wZXJ0eShjb2xvcktleSwgY29sb3JTY2FsZVR5cGUsIHsgaWQ6IGBjb2xvclZhbHVlYCB9KV0gOiBbXSxcbiAgICAgICAgLi4ubGFiZWxLZXkgPyBbdmFsdWVQcm9wZXJ0eShsYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBsYWJlbFZhbHVlYCB9KV0gOiBbXVxuICAgICAgXVxuICAgIH0pO1xuICAgIGNvbnN0IHNpemVLZXlJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHNpemVWYWx1ZWApO1xuICAgIGNvbnN0IHByb2Nlc3NlZFNpemUgPSBwcm9jZXNzZWREYXRhLmRvbWFpbi52YWx1ZXNbc2l6ZUtleUlkeF0gPz8gW107XG4gICAgdGhpcy5zaXplU2NhbGUuZG9tYWluID0gbWFya2VyLmRvbWFpbiA/IG1hcmtlci5kb21haW4gOiBwcm9jZXNzZWRTaXplO1xuICAgIGlmIChjb2xvcktleSkge1xuICAgICAgY29uc3QgY29sb3JLZXlJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGNvbG9yVmFsdWVgKTtcbiAgICAgIHRoaXMuY29sb3JTY2FsZS5kb21haW4gPSBjb2xvckRvbWFpbiA/PyBwcm9jZXNzZWREYXRhLmRvbWFpbi52YWx1ZXNbY29sb3JLZXlJZHhdID8/IFtdO1xuICAgICAgdGhpcy5jb2xvclNjYWxlLnJhbmdlID0gY29sb3JSYW5nZTtcbiAgICAgIHRoaXMuY29sb3JTY2FsZS51cGRhdGUoKTtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlRGF0YVwiKTtcbiAgfVxuICBnZXRTZXJpZXNEb21haW4oZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgeyBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEgfSA9IHRoaXM7XG4gICAgaWYgKCFwcm9jZXNzZWREYXRhIHx8ICFkYXRhTW9kZWwpXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgaWQgPSBkaXJlY3Rpb24gPT09IFwieFwiIC8qIFggKi8gPyBgeFZhbHVlYCA6IGB5VmFsdWVgO1xuICAgIGNvbnN0IGRhdGFEZWYgPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZCeUlkKHRoaXMsIGlkKTtcbiAgICBjb25zdCBkb21haW4gPSBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGlkLCBcInZhbHVlXCIsIHByb2Nlc3NlZERhdGEpO1xuICAgIGlmIChkYXRhRGVmPy5kZWYudHlwZSA9PT0gXCJ2YWx1ZVwiICYmIGRhdGFEZWY/LmRlZi52YWx1ZVR5cGUgPT09IFwiY2F0ZWdvcnlcIikge1xuICAgICAgcmV0dXJuIGRvbWFpbjtcbiAgICB9XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhlc1tkaXJlY3Rpb25dO1xuICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KGV4dGVudChkb21haW4pLCBheGlzKTtcbiAgfVxuICBhc3luYyBjcmVhdGVOb2RlRGF0YSgpIHtcbiAgICBjb25zdCB7IGF4ZXMsIGRhdGFNb2RlbCwgcHJvY2Vzc2VkRGF0YSwgY29sb3JTY2FsZSwgc2l6ZVNjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgc2l6ZUtleSwgbGFiZWxLZXksIHhOYW1lLCB5TmFtZSwgc2l6ZU5hbWUsIGxhYmVsTmFtZSwgbGFiZWwsIGNvbG9yS2V5LCBtYXJrZXIsIHZpc2libGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBtYXJrZXJTaGFwZSA9IGdldE1hcmtlcihtYXJrZXIuc2hhcGUpO1xuICAgIGNvbnN0IHsgcGxhY2VtZW50IH0gPSBsYWJlbDtcbiAgICBjb25zdCB4QXhpcyA9IGF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSBheGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGlmICghKGRhdGFNb2RlbCAmJiBwcm9jZXNzZWREYXRhICYmIHZpc2libGUgJiYgeEF4aXMgJiYgeUF4aXMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHhEYXRhSWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGB4VmFsdWVgKTtcbiAgICBjb25zdCB5RGF0YUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeVZhbHVlYCk7XG4gICAgY29uc3Qgc2l6ZURhdGFJZHggPSBzaXplS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBzaXplVmFsdWVgKSA6IC0xO1xuICAgIGNvbnN0IGNvbG9yRGF0YUlkeCA9IGNvbG9yS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBjb2xvclZhbHVlYCkgOiAtMTtcbiAgICBjb25zdCBsYWJlbERhdGFJZHggPSBsYWJlbEtleSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgbGFiZWxWYWx1ZWApIDogLTE7XG4gICAgY29uc3QgeFNjYWxlID0geEF4aXMuc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0geUF4aXMuc2NhbGU7XG4gICAgY29uc3QgeE9mZnNldCA9ICh4U2NhbGUuYmFuZHdpZHRoID8/IDApIC8gMjtcbiAgICBjb25zdCB5T2Zmc2V0ID0gKHlTY2FsZS5iYW5kd2lkdGggPz8gMCkgLyAyO1xuICAgIGNvbnN0IG5vZGVEYXRhID0gW107XG4gICAgc2l6ZVNjYWxlLnJhbmdlID0gW21hcmtlci5zaXplLCBtYXJrZXIubWF4U2l6ZV07XG4gICAgY29uc3QgZm9udCA9IGxhYmVsLmdldEZvbnQoKTtcbiAgICBjb25zdCB0ZXh0TWVhc3VyZXIgPSBDYWNoZWRUZXh0TWVhc3VyZXJQb29sLmdldE1lYXN1cmVyKHsgZm9udCB9KTtcbiAgICBmb3IgKGNvbnN0IHsgdmFsdWVzLCBkYXR1bSB9IG9mIHByb2Nlc3NlZERhdGEuZGF0YSA/PyBbXSkge1xuICAgICAgY29uc3QgeERhdHVtID0gdmFsdWVzW3hEYXRhSWR4XTtcbiAgICAgIGNvbnN0IHlEYXR1bSA9IHZhbHVlc1t5RGF0YUlkeF07XG4gICAgICBjb25zdCB4ID0geFNjYWxlLmNvbnZlcnQoeERhdHVtKSArIHhPZmZzZXQ7XG4gICAgICBjb25zdCB5ID0geVNjYWxlLmNvbnZlcnQoeURhdHVtKSArIHlPZmZzZXQ7XG4gICAgICBjb25zdCBsYWJlbFRleHQgPSB0aGlzLmdldExhYmVsVGV4dChsYWJlbCwge1xuICAgICAgICB2YWx1ZTogbGFiZWxLZXkgPyB2YWx1ZXNbbGFiZWxEYXRhSWR4XSA6IHlEYXR1bSxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHhLZXksXG4gICAgICAgIHlLZXksXG4gICAgICAgIHNpemVLZXksXG4gICAgICAgIGxhYmVsS2V5LFxuICAgICAgICB4TmFtZSxcbiAgICAgICAgeU5hbWUsXG4gICAgICAgIHNpemVOYW1lLFxuICAgICAgICBsYWJlbE5hbWVcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgc2l6ZSA9IHRleHRNZWFzdXJlci5tZWFzdXJlVGV4dChTdHJpbmcobGFiZWxUZXh0KSk7XG4gICAgICBjb25zdCBtYXJrZXJTaXplID0gc2l6ZUtleSA/IHNpemVTY2FsZS5jb252ZXJ0KHZhbHVlc1tzaXplRGF0YUlkeF0pIDogbWFya2VyLnNpemU7XG4gICAgICBjb25zdCBmaWxsID0gY29sb3JLZXkgPyBjb2xvclNjYWxlLmNvbnZlcnQodmFsdWVzW2NvbG9yRGF0YUlkeF0pIDogdm9pZCAwO1xuICAgICAgbm9kZURhdGEucHVzaCh7XG4gICAgICAgIHNlcmllczogdGhpcyxcbiAgICAgICAgaXRlbUlkOiB5S2V5LFxuICAgICAgICB5S2V5LFxuICAgICAgICB4S2V5LFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgeFZhbHVlOiB4RGF0dW0sXG4gICAgICAgIHlWYWx1ZTogeURhdHVtLFxuICAgICAgICBzaXplVmFsdWU6IHZhbHVlc1tzaXplRGF0YUlkeF0sXG4gICAgICAgIHBvaW50OiB7IHgsIHksIHNpemU6IG1hcmtlclNpemUgfSxcbiAgICAgICAgbWlkUG9pbnQ6IHsgeCwgeSB9LFxuICAgICAgICBmaWxsLFxuICAgICAgICBsYWJlbDogeyB0ZXh0OiBsYWJlbFRleHQsIC4uLnNpemUgfSxcbiAgICAgICAgbWFya2VyOiBtYXJrZXJTaGFwZSxcbiAgICAgICAgcGxhY2VtZW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgIG5vZGVEYXRhLFxuICAgICAgbGFiZWxEYXRhOiBub2RlRGF0YSxcbiAgICAgIHNjYWxlczogdGhpcy5jYWxjdWxhdGVTY2FsaW5nKCksXG4gICAgICB2aXNpYmxlOiB0aGlzLnZpc2libGVcbiAgICB9O1xuICB9XG4gIGlzUGF0aE9yU2VsZWN0aW9uRGlydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5tYXJrZXIuaXNEaXJ0eSgpO1xuICB9XG4gIGdldExhYmVsRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0Tm9kZURhdGE/LmxhYmVsRGF0YSA/PyBbXTtcbiAgfVxuICBtYXJrZXJGYWN0b3J5KCkge1xuICAgIGNvbnN0IHsgc2hhcGUgfSA9IHRoaXMucHJvcGVydGllcy5tYXJrZXI7XG4gICAgY29uc3QgTWFya2VyU2hhcGUgPSBnZXRNYXJrZXIoc2hhcGUpO1xuICAgIHJldHVybiBuZXcgTWFya2VyU2hhcGUoKTtcbiAgfVxuICBhc3luYyB1cGRhdGVNYXJrZXJTZWxlY3Rpb24ob3B0cykge1xuICAgIGNvbnN0IHsgbm9kZURhdGEsIG1hcmtlclNlbGVjdGlvbiB9ID0gb3B0cztcbiAgICBpZiAodGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5pc0RpcnR5KCkpIHtcbiAgICAgIG1hcmtlclNlbGVjdGlvbi5jbGVhcigpO1xuICAgICAgbWFya2VyU2VsZWN0aW9uLmNsZWFudXAoKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IHRoaXMucHJvcGVydGllcy5tYXJrZXIuZW5hYmxlZCA/IG5vZGVEYXRhIDogW107XG4gICAgcmV0dXJuIG1hcmtlclNlbGVjdGlvbi51cGRhdGUoXG4gICAgICBkYXRhLFxuICAgICAgdm9pZCAwLFxuICAgICAgKGRhdHVtKSA9PiBjcmVhdGVEYXR1bUlkKFtkYXR1bS54VmFsdWUsIGRhdHVtLnlWYWx1ZSwgZGF0dW0ubGFiZWwudGV4dF0pXG4gICAgKTtcbiAgfVxuICBhc3luYyB1cGRhdGVNYXJrZXJOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBtYXJrZXJTZWxlY3Rpb24sIGlzSGlnaGxpZ2h0OiBoaWdobGlnaHRlZCB9ID0gb3B0cztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHNpemVLZXksIGxhYmVsS2V5LCBtYXJrZXIgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IHNpemUsIHNoYXBlLCBmaWxsLCBmaWxsT3BhY2l0eSwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlT3BhY2l0eSB9ID0gbWVyZ2VEZWZhdWx0cyhcbiAgICAgIGhpZ2hsaWdodGVkICYmIHRoaXMucHJvcGVydGllcy5oaWdobGlnaHRTdHlsZS5pdGVtLFxuICAgICAgbWFya2VyLmdldFN0eWxlKClcbiAgICApO1xuICAgIGNvbnN0IGJhc2VTdHlsZSA9IHsgc2l6ZSwgc2hhcGUsIGZpbGwsIGZpbGxPcGFjaXR5LCBzdHJva2UsIHN0cm9rZVdpZHRoLCBzdHJva2VPcGFjaXR5IH07XG4gICAgdGhpcy5zaXplU2NhbGUucmFuZ2UgPSBbbWFya2VyLnNpemUsIG1hcmtlci5tYXhTaXplXTtcbiAgICBtYXJrZXJTZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0pID0+IHtcbiAgICAgIHRoaXMudXBkYXRlTWFya2VyU3R5bGUobm9kZSwgbWFya2VyLCB7IGRhdHVtLCBoaWdobGlnaHRlZCwgeEtleSwgeUtleSwgc2l6ZUtleSwgbGFiZWxLZXkgfSwgYmFzZVN0eWxlKTtcbiAgICB9KTtcbiAgICBpZiAoIWhpZ2hsaWdodGVkKSB7XG4gICAgICB0aGlzLnByb3BlcnRpZXMubWFya2VyLm1hcmtDbGVhbigpO1xuICAgIH1cbiAgfVxuICBhc3luYyB1cGRhdGVMYWJlbFNlbGVjdGlvbihvcHRzKSB7XG4gICAgY29uc3QgcGxhY2VkTGFiZWxzID0gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsLmVuYWJsZWQgPyB0aGlzLmNoYXJ0Py5wbGFjZUxhYmVscygpLmdldCh0aGlzKSA/PyBbXSA6IFtdO1xuICAgIHJldHVybiBvcHRzLmxhYmVsU2VsZWN0aW9uLnVwZGF0ZShcbiAgICAgIHBsYWNlZExhYmVscy5tYXAoKHYpID0+ICh7XG4gICAgICAgIC4uLnYuZGF0dW0sXG4gICAgICAgIHBvaW50OiB7XG4gICAgICAgICAgeDogdi54LFxuICAgICAgICAgIHk6IHYueSxcbiAgICAgICAgICBzaXplOiB2LmRhdHVtLnBvaW50LnNpemVcbiAgICAgICAgfVxuICAgICAgfSkpXG4gICAgKTtcbiAgfVxuICBhc3luYyB1cGRhdGVMYWJlbE5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IGxhYmVsIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgb3B0cy5sYWJlbFNlbGVjdGlvbi5lYWNoKCh0ZXh0LCBkYXR1bSkgPT4ge1xuICAgICAgdGV4dC50ZXh0ID0gZGF0dW0ubGFiZWwudGV4dDtcbiAgICAgIHRleHQuZmlsbCA9IGxhYmVsLmNvbG9yO1xuICAgICAgdGV4dC54ID0gZGF0dW0ucG9pbnQ/LnggPz8gMDtcbiAgICAgIHRleHQueSA9IGRhdHVtLnBvaW50Py55ID8/IDA7XG4gICAgICB0ZXh0LmZvbnRTdHlsZSA9IGxhYmVsLmZvbnRTdHlsZTtcbiAgICAgIHRleHQuZm9udFdlaWdodCA9IGxhYmVsLmZvbnRXZWlnaHQ7XG4gICAgICB0ZXh0LmZvbnRTaXplID0gbGFiZWwuZm9udFNpemU7XG4gICAgICB0ZXh0LmZvbnRGYW1pbHkgPSBsYWJlbC5mb250RmFtaWx5O1xuICAgICAgdGV4dC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gXCJ0b3BcIjtcbiAgICB9KTtcbiAgfVxuICBnZXRUb29sdGlwSHRtbChub2RlRGF0dW0pIHtcbiAgICBjb25zdCB4QXhpcyA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IHRoaXMuYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgIXhBeGlzIHx8ICF5QXhpcykge1xuICAgICAgcmV0dXJuIEVNUFRZX1RPT0xUSVBfQ09OVEVOVDtcbiAgICB9XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCBzaXplS2V5LCBsYWJlbEtleSwgeE5hbWUsIHlOYW1lLCBzaXplTmFtZSwgbGFiZWxOYW1lLCBtYXJrZXIsIHRvb2x0aXAgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB0aXRsZSA9IHRoaXMucHJvcGVydGllcy50aXRsZSA/PyB5TmFtZTtcbiAgICBjb25zdCBiYXNlU3R5bGUgPSBtZXJnZURlZmF1bHRzKFxuICAgICAgeyBmaWxsOiBub2RlRGF0dW0uZmlsbCwgc3Ryb2tlV2lkdGg6IHRoaXMuZ2V0U3Ryb2tlV2lkdGgobWFya2VyLnN0cm9rZVdpZHRoKSB9LFxuICAgICAgbWFya2VyLmdldFN0eWxlKClcbiAgICApO1xuICAgIGNvbnN0IHsgZmlsbDogY29sb3IgPSBcImdyYXlcIiB9ID0gdGhpcy5nZXRNYXJrZXJTdHlsZShcbiAgICAgIG1hcmtlcixcbiAgICAgIHsgZGF0dW06IG5vZGVEYXR1bSwgaGlnaGxpZ2h0ZWQ6IGZhbHNlLCB4S2V5LCB5S2V5LCBzaXplS2V5LCBsYWJlbEtleSB9LFxuICAgICAgYmFzZVN0eWxlXG4gICAgKTtcbiAgICBjb25zdCB7XG4gICAgICBkYXR1bSxcbiAgICAgIHhWYWx1ZSxcbiAgICAgIHlWYWx1ZSxcbiAgICAgIHNpemVWYWx1ZSxcbiAgICAgIGxhYmVsOiB7IHRleHQ6IGxhYmVsVGV4dCB9LFxuICAgICAgaXRlbUlkXG4gICAgfSA9IG5vZGVEYXR1bTtcbiAgICBjb25zdCB4U3RyaW5nID0gc2FuaXRpemVIdG1sKHhBeGlzLmZvcm1hdERhdHVtKHhWYWx1ZSkpO1xuICAgIGNvbnN0IHlTdHJpbmcgPSBzYW5pdGl6ZUh0bWwoeUF4aXMuZm9ybWF0RGF0dW0oeVZhbHVlKSk7XG4gICAgbGV0IGNvbnRlbnQgPSBgPGI+JHtzYW5pdGl6ZUh0bWwoeE5hbWUgPz8geEtleSl9PC9iPjogJHt4U3RyaW5nfTxicj48Yj4ke3Nhbml0aXplSHRtbCh5TmFtZSA/PyB5S2V5KX08L2I+OiAke3lTdHJpbmd9YDtcbiAgICBpZiAoc2l6ZUtleSkge1xuICAgICAgY29udGVudCArPSBgPGJyPjxiPiR7c2FuaXRpemVIdG1sKHNpemVOYW1lID8/IHNpemVLZXkpfTwvYj46ICR7c2FuaXRpemVIdG1sKFN0cmluZyhzaXplVmFsdWUpKX1gO1xuICAgIH1cbiAgICBpZiAobGFiZWxLZXkpIHtcbiAgICAgIGNvbnRlbnQgPSBgPGI+JHtzYW5pdGl6ZUh0bWwobGFiZWxOYW1lID8/IGxhYmVsS2V5KX08L2I+OiAke3Nhbml0aXplSHRtbChsYWJlbFRleHQpfTxicj5gICsgY29udGVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRvb2x0aXAudG9Ub29sdGlwSHRtbChcbiAgICAgIHsgdGl0bGUsIGNvbnRlbnQsIGJhY2tncm91bmRDb2xvcjogY29sb3IgfSxcbiAgICAgIHtcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGl0ZW1JZCxcbiAgICAgICAgeEtleSxcbiAgICAgICAgeE5hbWUsXG4gICAgICAgIHlLZXksXG4gICAgICAgIHlOYW1lLFxuICAgICAgICBzaXplS2V5LFxuICAgICAgICBzaXplTmFtZSxcbiAgICAgICAgbGFiZWxLZXksXG4gICAgICAgIGxhYmVsTmFtZSxcbiAgICAgICAgdGl0bGUsXG4gICAgICAgIGNvbG9yLFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZFxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgZ2V0TGVnZW5kRGF0YSgpIHtcbiAgICBpZiAoIXRoaXMuZGF0YT8ubGVuZ3RoIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IHsgeUtleSwgeU5hbWUsIHRpdGxlLCBtYXJrZXIsIHZpc2libGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IHNoYXBlLCBmaWxsLCBzdHJva2UsIGZpbGxPcGFjaXR5LCBzdHJva2VPcGFjaXR5LCBzdHJva2VXaWR0aCB9ID0gbWFya2VyO1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIGxlZ2VuZFR5cGU6IFwiY2F0ZWdvcnlcIixcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIGVuYWJsZWQ6IHZpc2libGUsXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgdGV4dDogdGl0bGUgPz8geU5hbWUgPz8geUtleVxuICAgICAgICB9LFxuICAgICAgICBzeW1ib2xzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgIHNoYXBlLFxuICAgICAgICAgICAgICBmaWxsOiBmaWxsID8/IFwicmdiYSgwLCAwLCAwLCAwKVwiLFxuICAgICAgICAgICAgICBzdHJva2U6IHN0cm9rZSA/PyBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgICAgICAgICAgZmlsbE9wYWNpdHk6IGZpbGxPcGFjaXR5ID8/IDEsXG4gICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHN0cm9rZU9wYWNpdHkgPz8gMSxcbiAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoID8/IDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH1cbiAgICBdO1xuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KHsgbWFya2VyU2VsZWN0aW9uLCBsYWJlbFNlbGVjdGlvbiB9KSB7XG4gICAgbWFya2VyU2NhbGVJbkFuaW1hdGlvbih0aGlzLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBtYXJrZXJTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9uKTtcbiAgfVxuICBpc0xhYmVsRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsLmVuYWJsZWQ7XG4gIH1cbiAgbm9kZUZhY3RvcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBHcm91cCgpO1xuICB9XG4gIGdldEZvcm1hdHRlZE1hcmtlclN0eWxlKGRhdHVtKSB7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCBzaXplS2V5LCBsYWJlbEtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIHJldHVybiB0aGlzLmdldE1hcmtlclN0eWxlKHRoaXMucHJvcGVydGllcy5tYXJrZXIsIHtcbiAgICAgIGRhdHVtLFxuICAgICAgeEtleSxcbiAgICAgIHlLZXksXG4gICAgICBzaXplS2V5LFxuICAgICAgbGFiZWxLZXksXG4gICAgICBoaWdobGlnaHRlZDogZmFsc2VcbiAgICB9KTtcbiAgfVxuICBjb21wdXRlRm9jdXNCb3VuZHMob3B0cykge1xuICAgIHJldHVybiBjb21wdXRlTWFya2VyRm9jdXNCb3VuZHModGhpcywgb3B0cyk7XG4gIH1cbn07XG5CdWJibGVTZXJpZXMuY2xhc3NOYW1lID0gXCJCdWJibGVTZXJpZXNcIjtcbkJ1YmJsZVNlcmllcy50eXBlID0gXCJidWJibGVcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9idWJibGVTZXJpZXNNb2R1bGUudHNcbnZhciBCdWJibGVTZXJpZXNNb2R1bGUgPSB7XG4gIHR5cGU6IFwic2VyaWVzXCIsXG4gIG9wdGlvbnNLZXk6IFwic2VyaWVzW11cIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSxcbiAgaWRlbnRpZmllcjogXCJidWJibGVcIixcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IEJ1YmJsZVNlcmllcyhjdHgpLFxuICB0b29sdGlwRGVmYXVsdHM6IHsgcmFuZ2U6IFwibmVhcmVzdFwiIH0sXG4gIGRlZmF1bHRBeGVzOiBbXG4gICAge1xuICAgICAgdHlwZTogXCJudW1iZXJcIiAvKiBOVU1CRVIgKi8sXG4gICAgICBwb3NpdGlvbjogXCJib3R0b21cIiAvKiBCT1RUT00gKi9cbiAgICB9LFxuICAgIHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIgLyogTlVNQkVSICovLFxuICAgICAgcG9zaXRpb246IFwibGVmdFwiIC8qIExFRlQgKi9cbiAgICB9XG4gIF0sXG4gIHRoZW1lVGVtcGxhdGU6IHtcbiAgICBzZXJpZXM6IHtcbiAgICAgIHNoYXBlOiBcImNpcmNsZVwiLFxuICAgICAgc2l6ZTogNyxcbiAgICAgIG1heFNpemU6IDMwLFxuICAgICAgZmlsbE9wYWNpdHk6IDAuOCxcbiAgICAgIHRvb2x0aXA6IHsgcG9zaXRpb246IHsgdHlwZTogXCJub2RlXCIgfSB9LFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwYWxldHRlRmFjdG9yeTogc2luZ2xlU2VyaWVzUGFsZXR0ZUZhY3Rvcnlcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vaGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy50c1xudmFyIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllc1Byb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuZmlsbE9wYWNpdHkgPSAxO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5saW5lRGFzaCA9IFswXTtcbiAgICB0aGlzLmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgICB0aGlzLmNvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5hcmVhUGxvdCA9IGZhbHNlO1xuICAgIHRoaXMuYWdncmVnYXRpb24gPSBcInN1bVwiO1xuICAgIHRoaXMuc2hhZG93ID0gbmV3IERyb3BTaGFkb3coKTtcbiAgICB0aGlzLmxhYmVsID0gbmV3IExhYmVsKCk7XG4gICAgdGhpcy50b29sdGlwID0gbmV3IFNlcmllc1Rvb2x0aXAoKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTElORV9EQVNIKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsaW5lRGFzaE9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJhcmVhUGxvdFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEFSUkFZLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJiaW5zXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVU5JT04oW1wiY291bnRcIiwgXCJzdW1cIiwgXCJtZWFuXCJdLCBcImEgaGlzdG9ncmFtIGFnZ3JlZ2F0aW9uXCIpKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYWdncmVnYXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpc3RvZ3JhbVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImJpbkNvdW50XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2hhZG93XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBIaXN0b2dyYW1TZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2hpc3RvZ3JhbVNlcmllcy50c1xudmFyIGRlZmF1bHRCaW5Db3VudCA9IDEwO1xudmFyIEhpc3RvZ3JhbVNlcmllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbW9kdWxlQ3R4LFxuICAgICAgZGlyZWN0aW9uS2V5czogREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX0tFWVMsXG4gICAgICBkaXJlY3Rpb25OYW1lczogREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX05BTUVTLFxuICAgICAgcGlja01vZGVzOiBbMyAvKiBORUFSRVNUX05PREUgKi8sIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9dLFxuICAgICAgZGF0dW1TZWxlY3Rpb25HYXJiYWdlQ29sbGVjdGlvbjogZmFsc2UsXG4gICAgICBhbmltYXRpb25SZXNldEZuczoge1xuICAgICAgICBkYXR1bTogcmVzZXRCYXJTZWxlY3Rpb25zRm4sXG4gICAgICAgIGxhYmVsOiByZXNldExhYmVsRm5cbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBuZXcgSGlzdG9ncmFtU2VyaWVzUHJvcGVydGllcygpO1xuICAgIHRoaXMuY2FsY3VsYXRlZEJpbnMgPSBbXTtcbiAgfVxuICAvLyBEdXJpbmcgcHJvY2Vzc0RhdGEgcGhhc2UsIHVzZWQgdG8gdW5pZnkgZGlmZmVyZW50IHdheXMgb2YgdGhlIHVzZXIgc3BlY2lmeWluZ1xuICAvLyB0aGUgYmlucy4gUmV0dXJucyBiaW5zIGluIGZvcm1hdFtbbWluMSwgbWF4MV0sIFttaW4yLCBtYXgyXSwgLi4uIF0uXG4gIGRlcml2ZUJpbnMoeERvbWFpbikge1xuICAgIGNvbnN0IGJpblN0YXJ0cyA9IGNyZWF0ZVRpY2tzKHhEb21haW5bMF0sIHhEb21haW5bMV0sIGRlZmF1bHRCaW5Db3VudCk7XG4gICAgY29uc3QgYmluU2l6ZSA9IHRpY2tTdGVwKHhEb21haW5bMF0sIHhEb21haW5bMV0sIGRlZmF1bHRCaW5Db3VudCk7XG4gICAgY29uc3QgW2ZpcnN0QmluRW5kXSA9IGJpblN0YXJ0cztcbiAgICBjb25zdCBleHBhbmRTdGFydFRvQmluID0gKG4pID0+IFtuLCBuICsgYmluU2l6ZV07XG4gICAgcmV0dXJuIFtbZmlyc3RCaW5FbmQgLSBiaW5TaXplLCBmaXJzdEJpbkVuZF0sIC4uLmJpblN0YXJ0cy5tYXAoZXhwYW5kU3RhcnRUb0JpbildO1xuICB9XG4gIGNhbGN1bGF0ZU5pY2VCaW5zKGRvbWFpbiwgYmluQ291bnQpIHtcbiAgICBjb25zdCBzdGFydEd1ZXNzID0gTWF0aC5mbG9vcihkb21haW5bMF0pO1xuICAgIGNvbnN0IHN0b3AgPSBkb21haW5bMV07XG4gICAgY29uc3Qgc2VnbWVudHMgPSBiaW5Db3VudCB8fCAxO1xuICAgIGNvbnN0IHsgc3RhcnQsIGJpblNpemUgfSA9IHRoaXMuY2FsY3VsYXRlTmljZVN0YXJ0KHN0YXJ0R3Vlc3MsIHN0b3AsIHNlZ21lbnRzKTtcbiAgICByZXR1cm4gdGhpcy5nZXRCaW5zKHN0YXJ0LCBzdG9wLCBiaW5TaXplLCBzZWdtZW50cyk7XG4gIH1cbiAgZ2V0QmlucyhzdGFydCwgc3RvcCwgc3RlcCwgY291bnQpIHtcbiAgICBjb25zdCBiaW5zID0gW107XG4gICAgY29uc3QgcHJlY2lzaW9uID0gdGhpcy5jYWxjdWxhdGVQcmVjaXNpb24oc3RlcCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBhID0gTWF0aC5yb3VuZCgoc3RhcnQgKyBpICogc3RlcCkgKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICAgICAgbGV0IGIgPSBNYXRoLnJvdW5kKChzdGFydCArIChpICsgMSkgKiBzdGVwKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gICAgICBpZiAoaSA9PT0gY291bnQgLSAxKSB7XG4gICAgICAgIGIgPSBNYXRoLm1heChiLCBzdG9wKTtcbiAgICAgIH1cbiAgICAgIGJpbnNbaV0gPSBbYSwgYl07XG4gICAgfVxuICAgIHJldHVybiBiaW5zO1xuICB9XG4gIGNhbGN1bGF0ZVByZWNpc2lvbihzdGVwKSB7XG4gICAgbGV0IHByZWNpc2lvbiA9IDEwO1xuICAgIGlmIChpc0Zpbml0ZShzdGVwKSAmJiBzdGVwID4gMCkge1xuICAgICAgd2hpbGUgKHN0ZXAgPCAxKSB7XG4gICAgICAgIHByZWNpc2lvbiAqPSAxMDtcbiAgICAgICAgc3RlcCAqPSAxMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByZWNpc2lvbjtcbiAgfVxuICBjYWxjdWxhdGVOaWNlU3RhcnQoYSwgYiwgc2VnbWVudHMpIHtcbiAgICBjb25zdCBiaW5TaXplID0gTWF0aC5hYnMoYiAtIGEpIC8gc2VnbWVudHM7XG4gICAgY29uc3Qgb3JkZXIgPSBNYXRoLmZsb29yKE1hdGgubG9nMTAoYmluU2l6ZSkpO1xuICAgIGNvbnN0IG1hZ25pdHVkZSA9IE1hdGgucG93KDEwLCBvcmRlcik7XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLmZsb29yKGEgLyBtYWduaXR1ZGUpICogbWFnbml0dWRlO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydCxcbiAgICAgIGJpblNpemVcbiAgICB9O1xuICB9XG4gIGFzeW5jIHByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSB7XG4gICAgaWYgKCF0aGlzLnZpc2libGUpIHtcbiAgICAgIHRoaXMucHJvY2Vzc2VkRGF0YSA9IHZvaWQgMDtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZURhdGFcIik7XG4gICAgfVxuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgYXJlYVBsb3QsIGFnZ3JlZ2F0aW9uIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeFNjYWxlID0gdGhpcy5heGVzW1wieFwiIC8qIFggKi9dPy5zY2FsZTtcbiAgICBjb25zdCB5U2NhbGUgPSB0aGlzLmF4ZXNbXCJ5XCIgLyogWSAqL10/LnNjYWxlO1xuICAgIGNvbnN0IHsgeFNjYWxlVHlwZSwgeVNjYWxlVHlwZSB9ID0gdGhpcy5nZXRTY2FsZUluZm9ybWF0aW9uKHsgeVNjYWxlLCB4U2NhbGUgfSk7XG4gICAgY29uc3QgcHJvcHMgPSBba2V5UHJvcGVydHkoeEtleSwgeFNjYWxlVHlwZSksIFNPUlRfRE9NQUlOX0dST1VQU107XG4gICAgaWYgKHlLZXkpIHtcbiAgICAgIGxldCBhZ2dQcm9wID0gZ3JvdXBDb3VudChcImdyb3VwQWdnXCIpO1xuICAgICAgaWYgKGFnZ3JlZ2F0aW9uID09PSBcImNvdW50XCIpIHtcbiAgICAgIH0gZWxzZSBpZiAoYWdncmVnYXRpb24gPT09IFwic3VtXCIpIHtcbiAgICAgICAgYWdnUHJvcCA9IGdyb3VwU3VtKFwiZ3JvdXBBZ2dcIik7XG4gICAgICB9IGVsc2UgaWYgKGFnZ3JlZ2F0aW9uID09PSBcIm1lYW5cIikge1xuICAgICAgICBhZ2dQcm9wID0gZ3JvdXBBdmVyYWdlKFwiZ3JvdXBBZ2dcIik7XG4gICAgICB9XG4gICAgICBpZiAoYXJlYVBsb3QpIHtcbiAgICAgICAgYWdnUHJvcCA9IGFyZWEoXCJncm91cEFnZ1wiLCBhZ2dQcm9wKTtcbiAgICAgIH1cbiAgICAgIHByb3BzLnB1c2godmFsdWVQcm9wZXJ0eSh5S2V5LCB5U2NhbGVUeXBlLCB7IGludmFsaWRWYWx1ZTogdm9pZCAwIH0pLCBhZ2dQcm9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGFnZ1Byb3AgPSBncm91cENvdW50KFwiZ3JvdXBBZ2dcIik7XG4gICAgICBpZiAoYXJlYVBsb3QpIHtcbiAgICAgICAgYWdnUHJvcCA9IGFyZWEoXCJncm91cEFnZ1wiLCBhZ2dQcm9wKTtcbiAgICAgIH1cbiAgICAgIHByb3BzLnB1c2goYWdnUHJvcCk7XG4gICAgfVxuICAgIGNvbnN0IGdyb3VwQnlGbiA9IChkYXRhU2V0KSA9PiB7XG4gICAgICBjb25zdCB4RXh0ZW50ID0gZml4TnVtZXJpY0V4dGVudChkYXRhU2V0LmRvbWFpbi5rZXlzWzBdKTtcbiAgICAgIGlmICh4RXh0ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkYXRhU2V0LmRvbWFpbi5ncm91cHMgPSBbXTtcbiAgICAgICAgcmV0dXJuICgpID0+IFtdO1xuICAgICAgfVxuICAgICAgY29uc3QgYmlucyA9IGlzTnVtYmVyKHRoaXMucHJvcGVydGllcy5iaW5Db3VudCkgPyB0aGlzLmNhbGN1bGF0ZU5pY2VCaW5zKHhFeHRlbnQsIHRoaXMucHJvcGVydGllcy5iaW5Db3VudCkgOiB0aGlzLnByb3BlcnRpZXMuYmlucyA/PyB0aGlzLmRlcml2ZUJpbnMoeEV4dGVudCk7XG4gICAgICBjb25zdCBiaW5Db3VudCA9IGJpbnMubGVuZ3RoO1xuICAgICAgdGhpcy5jYWxjdWxhdGVkQmlucyA9IFsuLi5iaW5zXTtcbiAgICAgIHJldHVybiAoaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCB4VmFsdWUgPSBpdGVtLmtleXNbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluQ291bnQ7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG5leHRCaW4gPSBiaW5zW2ldO1xuICAgICAgICAgIGlmICh4VmFsdWUgPj0gbmV4dEJpblswXSAmJiB4VmFsdWUgPCBuZXh0QmluWzFdKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV4dEJpbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPT09IGJpbkNvdW50IC0gMSAmJiB4VmFsdWUgPD0gbmV4dEJpblsxXSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRCaW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH07XG4gICAgfTtcbiAgICBpZiAoIXRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCkgJiYgdGhpcy5wcm9jZXNzZWREYXRhKSB7XG4gICAgICBwcm9wcy5wdXNoKGRpZmYodGhpcy5wcm9jZXNzZWREYXRhLCBmYWxzZSkpO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLnJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIHRoaXMuZGF0YSwgeyBwcm9wcywgZ3JvdXBCeUZuIH0pO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZURhdGFcIik7XG4gIH1cbiAgZ2V0U2VyaWVzRG9tYWluKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHsgcHJvY2Vzc2VkRGF0YSwgZGF0YU1vZGVsIH0gPSB0aGlzO1xuICAgIGlmICghcHJvY2Vzc2VkRGF0YSB8fCAhZGF0YU1vZGVsIHx8ICF0aGlzLmNhbGN1bGF0ZWRCaW5zLmxlbmd0aClcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCB5RG9tYWluID0gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBgZ3JvdXBBZ2dgLCBcImFnZ3JlZ2F0ZVwiLCBwcm9jZXNzZWREYXRhKTtcbiAgICBjb25zdCB4RG9tYWluTWluID0gdGhpcy5jYWxjdWxhdGVkQmlucz8uWzBdWzBdO1xuICAgIGNvbnN0IHhEb21haW5NYXggPSB0aGlzLmNhbGN1bGF0ZWRCaW5zPy5bKHRoaXMuY2FsY3VsYXRlZEJpbnM/Lmxlbmd0aCA/PyAwKSAtIDFdWzFdO1xuICAgIGlmIChkaXJlY3Rpb24gPT09IFwieFwiIC8qIFggKi8pIHtcbiAgICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KFt4RG9tYWluTWluLCB4RG9tYWluTWF4XSk7XG4gICAgfVxuICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KHlEb21haW4pO1xuICB9XG4gIGFzeW5jIGNyZWF0ZU5vZGVEYXRhKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkOiBzZXJpZXNJZCxcbiAgICAgIGF4ZXMsXG4gICAgICBwcm9jZXNzZWREYXRhLFxuICAgICAgY3R4OiB7IGNhbGxiYWNrQ2FjaGUgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHhBeGlzID0gYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IGF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgaWYgKCF4QXhpcyB8fCAheUF4aXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBzY2FsZTogeFNjYWxlIH0gPSB4QXhpcztcbiAgICBjb25zdCB7IHNjYWxlOiB5U2NhbGUgfSA9IHlBeGlzO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgeE5hbWUsIHlOYW1lLCBmaWxsLCBzdHJva2UsIHN0cm9rZVdpZHRoLCBjb3JuZXJSYWRpdXMgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7XG4gICAgICBmb3JtYXR0ZXI6IGxhYmVsRm9ybWF0dGVyID0gKHBhcmFtcykgPT4gU3RyaW5nKHBhcmFtcy52YWx1ZSksXG4gICAgICBmb250U3R5bGU6IGxhYmVsRm9udFN0eWxlLFxuICAgICAgZm9udFdlaWdodDogbGFiZWxGb250V2VpZ2h0LFxuICAgICAgZm9udFNpemU6IGxhYmVsRm9udFNpemUsXG4gICAgICBmb250RmFtaWx5OiBsYWJlbEZvbnRGYW1pbHksXG4gICAgICBjb2xvcjogbGFiZWxDb2xvclxuICAgIH0gPSB0aGlzLnByb3BlcnRpZXMubGFiZWw7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBbXTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgaXRlbUlkOiB0aGlzLnByb3BlcnRpZXMueUtleSA/PyB0aGlzLmlkLFxuICAgICAgbm9kZURhdGEsXG4gICAgICBsYWJlbERhdGE6IG5vZGVEYXRhLFxuICAgICAgc2NhbGVzOiB0aGlzLmNhbGN1bGF0ZVNjYWxpbmcoKSxcbiAgICAgIGFuaW1hdGlvblZhbGlkOiB0cnVlLFxuICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlXG4gICAgfTtcbiAgICBpZiAoIXRoaXMudmlzaWJsZSB8fCAhcHJvY2Vzc2VkRGF0YSB8fCBwcm9jZXNzZWREYXRhLnR5cGUgIT09IFwiZ3JvdXBlZFwiKVxuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgcHJvY2Vzc2VkRGF0YS5kYXRhLmZvckVhY2goKGdyb3VwKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFnZ1ZhbHVlczogW1tuZWdhdGl2ZUFnZywgcG9zaXRpdmVBZ2ddXSA9IFtbMCwgMF1dLFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgZGF0dW06IHsgbGVuZ3RoOiBmcmVxdWVuY3kgfSxcbiAgICAgICAga2V5czogZG9tYWluLFxuICAgICAgICBrZXlzOiBbeERvbWFpbk1pbiwgeERvbWFpbk1heF1cbiAgICAgIH0gPSBncm91cDtcbiAgICAgIGNvbnN0IHhNaW5QeCA9IHhTY2FsZS5jb252ZXJ0KHhEb21haW5NaW4pO1xuICAgICAgY29uc3QgeE1heFB4ID0geFNjYWxlLmNvbnZlcnQoeERvbWFpbk1heCk7XG4gICAgICBjb25zdCB0b3RhbCA9IG5lZ2F0aXZlQWdnICsgcG9zaXRpdmVBZ2c7XG4gICAgICBjb25zdCB5WmVyb1B4ID0geVNjYWxlLmNvbnZlcnQoMCk7XG4gICAgICBjb25zdCB5TWF4UHggPSB5U2NhbGUuY29udmVydCh0b3RhbCk7XG4gICAgICBjb25zdCB3ID0gTWF0aC5hYnMoeE1heFB4IC0geE1pblB4KTtcbiAgICAgIGNvbnN0IGggPSBNYXRoLmFicyh5TWF4UHggLSB5WmVyb1B4KTtcbiAgICAgIGNvbnN0IHggPSBNYXRoLm1pbih4TWluUHgsIHhNYXhQeCk7XG4gICAgICBjb25zdCB5ID0gTWF0aC5taW4oeVplcm9QeCwgeU1heFB4KTtcbiAgICAgIGxldCBzZWxlY3Rpb25EYXR1bUxhYmVsID0gdm9pZCAwO1xuICAgICAgaWYgKHRvdGFsICE9PSAwKSB7XG4gICAgICAgIHNlbGVjdGlvbkRhdHVtTGFiZWwgPSB7XG4gICAgICAgICAgdGV4dDogY2FsbGJhY2tDYWNoZS5jYWxsKGxhYmVsRm9ybWF0dGVyLCB7XG4gICAgICAgICAgICB2YWx1ZTogdG90YWwsXG4gICAgICAgICAgICBkYXR1bSxcbiAgICAgICAgICAgIHNlcmllc0lkLFxuICAgICAgICAgICAgeEtleSxcbiAgICAgICAgICAgIHlLZXksXG4gICAgICAgICAgICB4TmFtZSxcbiAgICAgICAgICAgIHlOYW1lXG4gICAgICAgICAgfSkgPz8gU3RyaW5nKHRvdGFsKSxcbiAgICAgICAgICBmb250U3R5bGU6IGxhYmVsRm9udFN0eWxlLFxuICAgICAgICAgIGZvbnRXZWlnaHQ6IGxhYmVsRm9udFdlaWdodCxcbiAgICAgICAgICBmb250U2l6ZTogbGFiZWxGb250U2l6ZSxcbiAgICAgICAgICBmb250RmFtaWx5OiBsYWJlbEZvbnRGYW1pbHksXG4gICAgICAgICAgZmlsbDogbGFiZWxDb2xvcixcbiAgICAgICAgICB4OiB4ICsgdyAvIDIsXG4gICAgICAgICAgeTogeSArIGggLyAyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBub2RlTWlkUG9pbnQgPSB7XG4gICAgICAgIHg6IHggKyB3IC8gMixcbiAgICAgICAgeTogeSArIGggLyAyXG4gICAgICB9O1xuICAgICAgY29uc3QgeUF4aXNSZXZlcnNlZCA9IHlBeGlzLmlzUmV2ZXJzZWQoKTtcbiAgICAgIG5vZGVEYXRhLnB1c2goe1xuICAgICAgICBzZXJpZXM6IHRoaXMsXG4gICAgICAgIGRhdHVtLFxuICAgICAgICAvLyByZXF1aXJlZCBieSBTZXJpZXNOb2RlRGF0dW0sIGJ1dCBtaWdodCBub3QgbWFrZSBzZW5zZSBoZXJlXG4gICAgICAgIC8vIHNpbmNlIGVhY2ggc2VsZWN0aW9uIGlzIGFuIGFnZ3JlZ2F0aW9uIG9mIG11bHRpcGxlIGRhdGEuXG4gICAgICAgIGFnZ3JlZ2F0ZWRWYWx1ZTogdG90YWwsXG4gICAgICAgIGZyZXF1ZW5jeSxcbiAgICAgICAgZG9tYWluLFxuICAgICAgICB5S2V5LFxuICAgICAgICB4S2V5LFxuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB4VmFsdWU6IHhNaW5QeCxcbiAgICAgICAgeVZhbHVlOiB5TWF4UHgsXG4gICAgICAgIHdpZHRoOiB3LFxuICAgICAgICBoZWlnaHQ6IGgsXG4gICAgICAgIG1pZFBvaW50OiBub2RlTWlkUG9pbnQsXG4gICAgICAgIGZpbGwsXG4gICAgICAgIHN0cm9rZSxcbiAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICB0b3BMZWZ0Q29ybmVyUmFkaXVzOiAheUF4aXNSZXZlcnNlZCxcbiAgICAgICAgdG9wUmlnaHRDb3JuZXJSYWRpdXM6ICF5QXhpc1JldmVyc2VkLFxuICAgICAgICBib3R0b21SaWdodENvcm5lclJhZGl1czogeUF4aXNSZXZlcnNlZCxcbiAgICAgICAgYm90dG9tTGVmdENvcm5lclJhZGl1czogeUF4aXNSZXZlcnNlZCxcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIGxhYmVsOiBzZWxlY3Rpb25EYXR1bUxhYmVsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBub2RlRGF0YS5zb3J0KChhLCBiKSA9PiBhLnggLSBiLngpO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG4gIG5vZGVGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgUmVjdCgpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZURhdHVtU2VsZWN0aW9uKG9wdHMpIHtcbiAgICBjb25zdCB7IG5vZGVEYXRhLCBkYXR1bVNlbGVjdGlvbiB9ID0gb3B0cztcbiAgICByZXR1cm4gZGF0dW1TZWxlY3Rpb24udXBkYXRlKFxuICAgICAgbm9kZURhdGEsXG4gICAgICAocmVjdCkgPT4ge1xuICAgICAgICByZWN0LnRhZyA9IDAgLyogQmluICovO1xuICAgICAgICByZWN0LmNyaXNwID0gdHJ1ZTtcbiAgICAgIH0sXG4gICAgICAoZGF0dW0pID0+IGRhdHVtLmRvbWFpbi5qb2luKFwiX1wiKVxuICAgICk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlRGF0dW1Ob2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBpc0hpZ2hsaWdodDogaXNEYXR1bUhpZ2hsaWdodGVkIH0gPSBvcHRzO1xuICAgIGNvbnN0IHtcbiAgICAgIGZpbGxPcGFjaXR5OiBzZXJpZXNGaWxsT3BhY2l0eSxcbiAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICBsaW5lRGFzaCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgc2hhZG93LFxuICAgICAgaGlnaGxpZ2h0U3R5bGU6IHtcbiAgICAgICAgaXRlbToge1xuICAgICAgICAgIGZpbGw6IGhpZ2hsaWdodGVkRmlsbCxcbiAgICAgICAgICBmaWxsT3BhY2l0eTogaGlnaGxpZ2h0RmlsbE9wYWNpdHkgPSBzZXJpZXNGaWxsT3BhY2l0eSxcbiAgICAgICAgICBzdHJva2U6IGhpZ2hsaWdodGVkU3Ryb2tlLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiBoaWdobGlnaHRlZERhdHVtU3Ryb2tlV2lkdGhcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgb3B0cy5kYXR1bVNlbGVjdGlvbi5lYWNoKChyZWN0LCBkYXR1bSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29ybmVyUmFkaXVzLFxuICAgICAgICB0b3BMZWZ0Q29ybmVyUmFkaXVzLFxuICAgICAgICB0b3BSaWdodENvcm5lclJhZGl1cyxcbiAgICAgICAgYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMsXG4gICAgICAgIGJvdHRvbUxlZnRDb3JuZXJSYWRpdXNcbiAgICAgIH0gPSBkYXR1bTtcbiAgICAgIGNvbnN0IHN0cm9rZVdpZHRoID0gaXNEYXR1bUhpZ2hsaWdodGVkICYmIGhpZ2hsaWdodGVkRGF0dW1TdHJva2VXaWR0aCAhPT0gdm9pZCAwID8gaGlnaGxpZ2h0ZWREYXR1bVN0cm9rZVdpZHRoIDogZGF0dW0uc3Ryb2tlV2lkdGg7XG4gICAgICBjb25zdCBmaWxsT3BhY2l0eSA9IGlzRGF0dW1IaWdobGlnaHRlZCA/IGhpZ2hsaWdodEZpbGxPcGFjaXR5IDogc2VyaWVzRmlsbE9wYWNpdHk7XG4gICAgICByZWN0LmZpbGwgPSAoaXNEYXR1bUhpZ2hsaWdodGVkID8gaGlnaGxpZ2h0ZWRGaWxsIDogdm9pZCAwKSA/PyBkYXR1bS5maWxsO1xuICAgICAgcmVjdC5zdHJva2UgPSAoaXNEYXR1bUhpZ2hsaWdodGVkID8gaGlnaGxpZ2h0ZWRTdHJva2UgOiB2b2lkIDApID8/IGRhdHVtLnN0cm9rZTtcbiAgICAgIHJlY3QuZmlsbE9wYWNpdHkgPSBmaWxsT3BhY2l0eTtcbiAgICAgIHJlY3Quc3Ryb2tlT3BhY2l0eSA9IHN0cm9rZU9wYWNpdHk7XG4gICAgICByZWN0LnN0cm9rZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG4gICAgICByZWN0LmxpbmVEYXNoID0gbGluZURhc2g7XG4gICAgICByZWN0LmxpbmVEYXNoT2Zmc2V0ID0gbGluZURhc2hPZmZzZXQ7XG4gICAgICByZWN0LnRvcExlZnRDb3JuZXJSYWRpdXMgPSB0b3BMZWZ0Q29ybmVyUmFkaXVzID8gY29ybmVyUmFkaXVzIDogMDtcbiAgICAgIHJlY3QudG9wUmlnaHRDb3JuZXJSYWRpdXMgPSB0b3BSaWdodENvcm5lclJhZGl1cyA/IGNvcm5lclJhZGl1cyA6IDA7XG4gICAgICByZWN0LmJvdHRvbVJpZ2h0Q29ybmVyUmFkaXVzID0gYm90dG9tUmlnaHRDb3JuZXJSYWRpdXMgPyBjb3JuZXJSYWRpdXMgOiAwO1xuICAgICAgcmVjdC5ib3R0b21MZWZ0Q29ybmVyUmFkaXVzID0gYm90dG9tTGVmdENvcm5lclJhZGl1cyA/IGNvcm5lclJhZGl1cyA6IDA7XG4gICAgICByZWN0LmZpbGxTaGFkb3cgPSBzaGFkb3c7XG4gICAgICByZWN0LnpJbmRleCA9IGlzRGF0dW1IaWdobGlnaHRlZCA/IFNlcmllcy5oaWdobGlnaHRlZFpJbmRleCA6IGluZGV4O1xuICAgICAgcmVjdC52aXNpYmxlID0gZGF0dW0uaGVpZ2h0ID4gMDtcbiAgICB9KTtcbiAgfVxuICBhc3luYyB1cGRhdGVMYWJlbFNlbGVjdGlvbihvcHRzKSB7XG4gICAgY29uc3QgeyBsYWJlbERhdGEsIGxhYmVsU2VsZWN0aW9uIH0gPSBvcHRzO1xuICAgIHJldHVybiBsYWJlbFNlbGVjdGlvbi51cGRhdGUobGFiZWxEYXRhLCAodGV4dCkgPT4ge1xuICAgICAgdGV4dC50YWcgPSAxIC8qIExhYmVsICovO1xuICAgICAgdGV4dC5wb2ludGVyRXZlbnRzID0gMSAvKiBOb25lICovO1xuICAgICAgdGV4dC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgdGV4dC50ZXh0QmFzZWxpbmUgPSBcIm1pZGRsZVwiO1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUxhYmVsTm9kZXMob3B0cykge1xuICAgIGNvbnN0IGxhYmVsRW5hYmxlZCA9IHRoaXMuaXNMYWJlbEVuYWJsZWQoKTtcbiAgICBvcHRzLmxhYmVsU2VsZWN0aW9uLmVhY2goKHRleHQsIGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmxhYmVsO1xuICAgICAgaWYgKGxhYmVsICYmIGxhYmVsRW5hYmxlZCkge1xuICAgICAgICB0ZXh0LnRleHQgPSBsYWJlbC50ZXh0O1xuICAgICAgICB0ZXh0LnggPSBsYWJlbC54O1xuICAgICAgICB0ZXh0LnkgPSBsYWJlbC55O1xuICAgICAgICB0ZXh0LmZvbnRTdHlsZSA9IGxhYmVsLmZvbnRTdHlsZTtcbiAgICAgICAgdGV4dC5mb250V2VpZ2h0ID0gbGFiZWwuZm9udFdlaWdodDtcbiAgICAgICAgdGV4dC5mb250U2l6ZSA9IGxhYmVsLmZvbnRTaXplO1xuICAgICAgICB0ZXh0LmZvbnRGYW1pbHkgPSBsYWJlbC5mb250RmFtaWx5O1xuICAgICAgICB0ZXh0LmZpbGwgPSBsYWJlbC5maWxsO1xuICAgICAgICB0ZXh0LnZpc2libGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGV4dC52aXNpYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaW5pdFF1YWRUcmVlKHF1YWR0cmVlKSB7XG4gICAgYWRkSGl0VGVzdGVyc1RvUXVhZHRyZWUocXVhZHRyZWUsIGNoaWxkcmVuSXRlcih0aGlzLmNvbnRlbnRHcm91cC5jaGlsZHJlblswXSkpO1xuICB9XG4gIHBpY2tOb2RlQ2xvc2VzdERhdHVtKHBvaW50KSB7XG4gICAgcmV0dXJuIGZpbmRRdWFkdHJlZU1hdGNoKHRoaXMsIHBvaW50KTtcbiAgfVxuICBnZXRUb29sdGlwSHRtbChub2RlRGF0dW0pIHtcbiAgICBjb25zdCB4QXhpcyA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IHRoaXMuYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgIXhBeGlzIHx8ICF5QXhpcykge1xuICAgICAgcmV0dXJuIEVNUFRZX1RPT0xUSVBfQ09OVEVOVDtcbiAgICB9XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCB4TmFtZSwgeU5hbWUsIGZpbGw6IGNvbG9yLCBhZ2dyZWdhdGlvbiwgdG9vbHRpcCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHtcbiAgICAgIGFnZ3JlZ2F0ZWRWYWx1ZSxcbiAgICAgIGZyZXF1ZW5jeSxcbiAgICAgIGRvbWFpbjogW3JhbmdlTWluLCByYW5nZU1heF0sXG4gICAgICBpdGVtSWRcbiAgICB9ID0gbm9kZURhdHVtO1xuICAgIGNvbnN0IHRpdGxlID0gYCR7c2FuaXRpemVIdG1sKHhOYW1lID8/IHhLZXkpfTogJHt4QXhpcy5mb3JtYXREYXR1bShyYW5nZU1pbil9IC0gJHt4QXhpcy5mb3JtYXREYXR1bShyYW5nZU1heCl9YDtcbiAgICBsZXQgY29udGVudCA9IHlLZXkgPyBgPGI+JHtzYW5pdGl6ZUh0bWwoeU5hbWUgPz8geUtleSl9ICgke2FnZ3JlZ2F0aW9ufSk8L2I+OiAke3lBeGlzLmZvcm1hdERhdHVtKGFnZ3JlZ2F0ZWRWYWx1ZSl9PGJyPmAgOiBcIlwiO1xuICAgIGNvbnRlbnQgKz0gYDxiPkZyZXF1ZW5jeTwvYj46ICR7ZnJlcXVlbmN5fWA7XG4gICAgY29uc3QgZGVmYXVsdHMgPSB7XG4gICAgICB0aXRsZSxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3IsXG4gICAgICBjb250ZW50XG4gICAgfTtcbiAgICByZXR1cm4gdG9vbHRpcC50b1Rvb2x0aXBIdG1sKGRlZmF1bHRzLCB7XG4gICAgICBkYXR1bToge1xuICAgICAgICBkYXRhOiBub2RlRGF0dW0uZGF0dW0sXG4gICAgICAgIGFnZ3JlZ2F0ZWRWYWx1ZTogbm9kZURhdHVtLmFnZ3JlZ2F0ZWRWYWx1ZSxcbiAgICAgICAgZG9tYWluOiBub2RlRGF0dW0uZG9tYWluLFxuICAgICAgICBmcmVxdWVuY3k6IG5vZGVEYXR1bS5mcmVxdWVuY3lcbiAgICAgIH0sXG4gICAgICBpdGVtSWQsXG4gICAgICB4S2V5LFxuICAgICAgeE5hbWUsXG4gICAgICB5S2V5LFxuICAgICAgeU5hbWUsXG4gICAgICBjb2xvcixcbiAgICAgIHRpdGxlLFxuICAgICAgc2VyaWVzSWQ6IHRoaXMuaWRcbiAgICB9KTtcbiAgfVxuICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpIHtcbiAgICBpZiAoIXRoaXMuZGF0YT8ubGVuZ3RoIHx8IGxlZ2VuZFR5cGUgIT09IFwiY2F0ZWdvcnlcIikge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCB7IHhLZXksIHlOYW1lLCBmaWxsLCBmaWxsT3BhY2l0eSwgc3Ryb2tlLCBzdHJva2VXaWR0aCwgc3Ryb2tlT3BhY2l0eSwgdmlzaWJsZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIGxlZ2VuZFR5cGU6IFwiY2F0ZWdvcnlcIixcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIGl0ZW1JZDogeEtleSxcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIGVuYWJsZWQ6IHZpc2libGUsXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgdGV4dDogeU5hbWUgPz8geEtleSA/PyBcIkZyZXF1ZW5jeVwiXG4gICAgICAgIH0sXG4gICAgICAgIHN5bWJvbHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYXJrZXI6IHtcbiAgICAgICAgICAgICAgZmlsbDogZmlsbCA/PyBcInJnYmEoMCwgMCwgMCwgMClcIixcbiAgICAgICAgICAgICAgc3Ryb2tlOiBzdHJva2UgPz8gXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG4gICAgICAgICAgICAgIGZpbGxPcGFjaXR5LFxuICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5LFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIF07XG4gIH1cbiAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoeyBkYXR1bVNlbGVjdGlvbiwgbGFiZWxTZWxlY3Rpb24gfSkge1xuICAgIGNvbnN0IGZucyA9IHByZXBhcmVCYXJBbmltYXRpb25GdW5jdGlvbnMoY29sbGFwc2VkU3RhcnRpbmdCYXJQb3NpdGlvbih0cnVlLCB0aGlzLmF4ZXMsIFwibm9ybWFsXCIpKTtcbiAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgXCJkYXR1bXNcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgW2RhdHVtU2VsZWN0aW9uXSwgZm5zKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbik7XG4gIH1cbiAgYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShkYXRhKSB7XG4gICAgY29uc3QgZGF0YURpZmYgPSB0aGlzLnByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmRpZmY7XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZUJhckFuaW1hdGlvbkZ1bmN0aW9ucyhjb2xsYXBzZWRTdGFydGluZ0JhclBvc2l0aW9uKHRydWUsIHRoaXMuYXhlcywgXCJub3JtYWxcIikpO1xuICAgIGZyb21Ub01vdGlvbihcbiAgICAgIHRoaXMuaWQsXG4gICAgICBcImRhdHVtc1wiLFxuICAgICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFtkYXRhLmRhdHVtU2VsZWN0aW9uXSxcbiAgICAgIGZucyxcbiAgICAgIChfLCBkYXR1bSkgPT4gY3JlYXRlRGF0dW1JZChkYXR1bS5kb21haW4pLFxuICAgICAgZGF0YURpZmZcbiAgICApO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIGRhdGEubGFiZWxTZWxlY3Rpb24pO1xuICB9XG4gIGlzTGFiZWxFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubGFiZWwuZW5hYmxlZDtcbiAgfVxuICBjb21wdXRlRm9jdXNCb3VuZHMoeyBkYXR1bUluZGV4LCBzZXJpZXNSZWN0IH0pIHtcbiAgICByZXR1cm4gY29tcHV0ZUJhckZvY3VzQm91bmRzKHRoaXMuY29udGV4dE5vZGVEYXRhPy5ub2RlRGF0YVtkYXR1bUluZGV4XSwgdGhpcy5jb250ZW50R3JvdXAsIHNlcmllc1JlY3QpO1xuICB9XG59O1xuSGlzdG9ncmFtU2VyaWVzLmNsYXNzTmFtZSA9IFwiSGlzdG9ncmFtU2VyaWVzXCI7XG5IaXN0b2dyYW1TZXJpZXMudHlwZSA9IFwiaGlzdG9ncmFtXCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vaGlzdG9ncmFtU2VyaWVzTW9kdWxlLnRzXG52YXIgSGlzdG9ncmFtU2VyaWVzTW9kdWxlID0ge1xuICB0eXBlOiBcInNlcmllc1wiLFxuICBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJjYXJ0ZXNpYW5cIl0sXG4gIGlkZW50aWZpZXI6IFwiaGlzdG9ncmFtXCIsXG4gIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBIaXN0b2dyYW1TZXJpZXMoY3R4KSxcbiAgdG9vbHRpcERlZmF1bHRzOiB7IHJhbmdlOiBcImV4YWN0XCIgfSxcbiAgZGVmYXVsdEF4ZXM6IFtcbiAgICB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiIC8qIE5VTUJFUiAqLyxcbiAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiIC8qIEJPVFRPTSAqL1xuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJudW1iZXJcIiAvKiBOVU1CRVIgKi8sXG4gICAgICBwb3NpdGlvbjogXCJsZWZ0XCIgLyogTEVGVCAqL1xuICAgIH1cbiAgXSxcbiAgdGhlbWVUZW1wbGF0ZToge1xuICAgIHNlcmllczoge1xuICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICBmaWxsT3BhY2l0eTogMSxcbiAgICAgIHN0cm9rZU9wYWNpdHk6IDEsXG4gICAgICBsaW5lRGFzaDogWzBdLFxuICAgICAgbGluZURhc2hPZmZzZXQ6IDAsXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgICBjb2xvcjogREVGQVVMVF9JTlNJREVfU0VSSUVTX0xBQkVMX0NPTE9VUlxuICAgICAgfSxcbiAgICAgIHNoYWRvdzoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfU0hBRE9XX0NPTE9VUixcbiAgICAgICAgeE9mZnNldDogMyxcbiAgICAgICAgeU9mZnNldDogMyxcbiAgICAgICAgYmx1cjogNVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcGFsZXR0ZUZhY3Rvcnk6ICh7IHRha2VDb2xvcnMgfSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGZpbGxzOiBbZmlsbF0sXG4gICAgICBzdHJva2VzOiBbc3Ryb2tlXVxuICAgIH0gPSB0YWtlQ29sb3JzKDEpO1xuICAgIHJldHVybiB7IGZpbGwsIHN0cm9rZSB9O1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvY2FydGVzaWFuL2xpbmVTZXJpZXNQcm9wZXJ0aWVzLnRzXG52YXIgTGluZVNlcmllc1Byb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIENhcnRlc2lhblNlcmllc1Byb3BlcnRpZXMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuc3Ryb2tlID0gXCIjODc0MzQ5XCI7XG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDI7XG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICB0aGlzLmxpbmVEYXNoID0gWzBdO1xuICAgIHRoaXMubGluZURhc2hPZmZzZXQgPSAwO1xuICAgIHRoaXMuaW50ZXJwb2xhdGlvbiA9IG5ldyBJbnRlcnBvbGF0aW9uUHJvcGVydGllcygpO1xuICAgIHRoaXMubWFya2VyID0gbmV3IFNlcmllc01hcmtlcigpO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgTGFiZWwoKTtcbiAgICB0aGlzLnRvb2x0aXAgPSBuZXcgU2VyaWVzVG9vbHRpcCgpO1xuICAgIHRoaXMuY29ubmVjdE1pc3NpbmdEYXRhID0gZmFsc2U7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieEtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORylcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5S2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ5TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0YWNrR3JvdXBcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJub3JtYWxpemVkVG9cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklORylcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIExpbmVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VPcGFjaXR5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTElORV9EQVNIKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImludGVycG9sYXRpb25cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBMaW5lU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibWFya2VyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInRvb2x0aXBcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgTGluZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbm5lY3RNaXNzaW5nRGF0YVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9saW5lU2VyaWVzLnRzXG52YXIgTGluZVNlcmllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbW9kdWxlQ3R4LFxuICAgICAgZGlyZWN0aW9uS2V5czogREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX0tFWVMsXG4gICAgICBkaXJlY3Rpb25OYW1lczogREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX05BTUVTLFxuICAgICAgaGFzTWFya2VyczogdHJ1ZSxcbiAgICAgIHBpY2tNb2RlczogW1xuICAgICAgICAyIC8qIE5FQVJFU1RfQllfTUFJTl9DQVRFR09SWV9BWElTX0ZJUlNUICovLFxuICAgICAgICAzIC8qIE5FQVJFU1RfTk9ERSAqLyxcbiAgICAgICAgMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqL1xuICAgICAgXSxcbiAgICAgIG1hcmtlclNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uOiBmYWxzZSxcbiAgICAgIGFuaW1hdGlvblJlc2V0Rm5zOiB7XG4gICAgICAgIHBhdGg6IGJ1aWxkUmVzZXRQYXRoRm4oeyBnZXRWaXNpYmxlOiAoKSA9PiB0aGlzLnZpc2libGUsIGdldE9wYWNpdHk6ICgpID0+IHRoaXMuZ2V0T3BhY2l0eSgpIH0pLFxuICAgICAgICBsYWJlbDogcmVzZXRMYWJlbEZuLFxuICAgICAgICBtYXJrZXI6IChub2RlLCBkYXR1bSkgPT4gKHsgLi4ucmVzZXRNYXJrZXJGbihub2RlKSwgLi4ucmVzZXRNYXJrZXJQb3NpdGlvbkZuKG5vZGUsIGRhdHVtKSB9KVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucHJvcGVydGllcyA9IG5ldyBMaW5lU2VyaWVzUHJvcGVydGllcygpO1xuICB9XG4gIGFzeW5jIHByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSB7XG4gICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgZGF0YSwgdmlzaWJsZSwgc2VyaWVzR3JvdXBpbmc6IHsgZ3JvdXBJbmRleCA9IHRoaXMuaWQsIHN0YWNrQ291bnQgPSAxIH0gPSB7fSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIGNvbm5lY3RNaXNzaW5nRGF0YSwgbm9ybWFsaXplZFRvIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgYW5pbWF0aW9uRW5hYmxlZCA9ICF0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xuICAgIGNvbnN0IHhTY2FsZSA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXT8uc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dPy5zY2FsZTtcbiAgICBjb25zdCB7IGlzQ29udGludW91c1gsIHhTY2FsZVR5cGUsIHlTY2FsZVR5cGUgfSA9IHRoaXMuZ2V0U2NhbGVJbmZvcm1hdGlvbih7IHhTY2FsZSwgeVNjYWxlIH0pO1xuICAgIGNvbnN0IGNvbW1vbiA9IHsgaW52YWxpZFZhbHVlOiBudWxsIH07XG4gICAgaWYgKGNvbm5lY3RNaXNzaW5nRGF0YSAmJiBzdGFja0NvdW50ID4gMSkge1xuICAgICAgY29tbW9uLmludmFsaWRWYWx1ZSA9IDA7XG4gICAgfVxuICAgIGlmICghdmlzaWJsZSkge1xuICAgICAgY29tbW9uLmZvcmNlVmFsdWUgPSAwO1xuICAgIH1cbiAgICBjb25zdCBwcm9wcyA9IFtdO1xuICAgIGlmICghaXNDb250aW51b3VzWCkge1xuICAgICAgcHJvcHMucHVzaChrZXlQcm9wZXJ0eSh4S2V5LCB4U2NhbGVUeXBlLCB7IGlkOiBcInhLZXlcIiB9KSk7XG4gICAgfVxuICAgIHByb3BzLnB1c2goXG4gICAgICB2YWx1ZVByb3BlcnR5KHhLZXksIHhTY2FsZVR5cGUsIHsgaWQ6IFwieFZhbHVlXCIgfSksXG4gICAgICB2YWx1ZVByb3BlcnR5KHlLZXksIHlTY2FsZVR5cGUsIHtcbiAgICAgICAgaWQ6IGB5VmFsdWVSYXdgLFxuICAgICAgICAuLi5jb21tb24sXG4gICAgICAgIGludmFsaWRWYWx1ZTogdm9pZCAwXG4gICAgICB9KVxuICAgICk7XG4gICAgaWYgKHN0YWNrQ291bnQgPiAxKSB7XG4gICAgICBjb25zdCBpZHMgPSBbXG4gICAgICAgIGBsaW5lLXN0YWNrLSR7Z3JvdXBJbmRleH0teVZhbHVlc2AsXG4gICAgICAgIGBsaW5lLXN0YWNrLSR7Z3JvdXBJbmRleH0teVZhbHVlcy10cmFpbGluZ2AsXG4gICAgICAgIGBsaW5lLXN0YWNrLSR7Z3JvdXBJbmRleH0teVZhbHVlcy1tYXJrZXJgXG4gICAgICBdO1xuICAgICAgcHJvcHMucHVzaChcbiAgICAgICAgLi4uZ3JvdXBBY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KFxuICAgICAgICAgIHlLZXksXG4gICAgICAgICAgXCJ3aW5kb3dcIixcbiAgICAgICAgICBcImN1cnJlbnRcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogYHlWYWx1ZUVuZGAsXG4gICAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgICBncm91cElkOiBpZHNbMF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHlTY2FsZVR5cGVcbiAgICAgICAgKSxcbiAgICAgICAgLi4uZ3JvdXBBY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KFxuICAgICAgICAgIHlLZXksXG4gICAgICAgICAgXCJ3aW5kb3ctdHJhaWxpbmdcIixcbiAgICAgICAgICBcImN1cnJlbnRcIixcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZDogYHlWYWx1ZVN0YXJ0YCxcbiAgICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAgIGdyb3VwSWQ6IGlkc1sxXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeVNjYWxlVHlwZVxuICAgICAgICApLFxuICAgICAgICAuLi5ncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoXG4gICAgICAgICAgeUtleSxcbiAgICAgICAgICBcIm5vcm1hbFwiLFxuICAgICAgICAgIFwiY3VycmVudFwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlkOiBgeVZhbHVlQ3VtdWxhdGl2ZWAsXG4gICAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgICBncm91cElkOiBpZHNbMl1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHlTY2FsZVR5cGVcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICAgIGlmIChpc0RlZmluZWQobm9ybWFsaXplZFRvKSkge1xuICAgICAgICBwcm9wcy5wdXNoKG5vcm1hbGlzZUdyb3VwVG8oW2lkc1swXSwgaWRzWzFdLCBpZHNbMl1dLCBub3JtYWxpemVkVG8sIFwicmFuZ2VcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYW5pbWF0aW9uRW5hYmxlZCkge1xuICAgICAgcHJvcHMucHVzaChhbmltYXRpb25WYWxpZGF0aW9uKGlzQ29udGludW91c1ggPyBbXCJ4VmFsdWVcIl0gOiB2b2lkIDApKTtcbiAgICAgIGlmICh0aGlzLnByb2Nlc3NlZERhdGEpIHtcbiAgICAgICAgcHJvcHMucHVzaChkaWZmKHRoaXMucHJvY2Vzc2VkRGF0YSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBhd2FpdCB0aGlzLnJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIGRhdGEsIHsgcHJvcHMgfSk7XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlRGF0YVwiKTtcbiAgfVxuICBnZXRTZXJpZXNEb21haW4oZGlyZWN0aW9uKSB7XG4gICAgY29uc3QgeyBwcm9jZXNzZWREYXRhLCBkYXRhTW9kZWwsIGF4ZXMgfSA9IHRoaXM7XG4gICAgaWYgKCFwcm9jZXNzZWREYXRhIHx8ICFkYXRhTW9kZWwgfHwgcHJvY2Vzc2VkRGF0YS5kYXRhLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCB4QXhpcyA9IGF4ZXNbXCJ4XCIgLyogWCAqL107XG4gICAgY29uc3QgeUF4aXMgPSBheGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGNvbnN0IHhEZWYgPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFEZWZCeUlkKHRoaXMsIGB4VmFsdWVgKTtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovKSB7XG4gICAgICBjb25zdCBkb21haW4gPSBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGB4VmFsdWVgLCBcInZhbHVlXCIsIHByb2Nlc3NlZERhdGEpO1xuICAgICAgaWYgKHhEZWY/LmRlZi50eXBlID09PSBcInZhbHVlXCIgJiYgeERlZi5kZWYudmFsdWVUeXBlID09PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgICAgcmV0dXJuIGRvbWFpbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaXhOdW1lcmljRXh0ZW50KGV4dGVudChkb21haW4pLCB4QXhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0YWNrQ291bnQgPSB0aGlzLnNlcmllc0dyb3VwaW5nPy5zdGFja0NvdW50ID8/IDE7XG4gICAgICBjb25zdCBkb21haW4gPSBzdGFja0NvdW50ID4gMSA/IGRhdGFNb2RlbC5nZXREb21haW4odGhpcywgYHlWYWx1ZUVuZGAsIFwidmFsdWVcIiwgcHJvY2Vzc2VkRGF0YSkgOiBkYXRhTW9kZWwuZ2V0RG9tYWluKHRoaXMsIGB5VmFsdWVSYXdgLCBcInZhbHVlXCIsIHByb2Nlc3NlZERhdGEpO1xuICAgICAgcmV0dXJuIGZpeE51bWVyaWNFeHRlbnQoZG9tYWluLCB5QXhpcyk7XG4gICAgfVxuICB9XG4gIGFzeW5jIGNyZWF0ZU5vZGVEYXRhKCkge1xuICAgIGNvbnN0IHsgcHJvY2Vzc2VkRGF0YSwgZGF0YU1vZGVsLCBheGVzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHhBeGlzID0gYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IGF4ZXNbXCJ5XCIgLyogWSAqL107XG4gICAgaWYgKCFwcm9jZXNzZWREYXRhIHx8ICFkYXRhTW9kZWwgfHwgIXhBeGlzIHx8ICF5QXhpcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHhOYW1lLCB5TmFtZSwgbWFya2VyLCBsYWJlbCwgY29ubmVjdE1pc3NpbmdEYXRhLCBsZWdlbmRJdGVtTmFtZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHN0YWNrZWQgPSAodGhpcy5zZXJpZXNHcm91cGluZz8uc3RhY2tDb3VudCA/PyAxKSA+IDE7XG4gICAgY29uc3QgeFNjYWxlID0geEF4aXMuc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0geUF4aXMuc2NhbGU7XG4gICAgY29uc3QgeE9mZnNldCA9ICh4U2NhbGUuYmFuZHdpZHRoID8/IDApIC8gMjtcbiAgICBjb25zdCB5T2Zmc2V0ID0gKHlTY2FsZS5iYW5kd2lkdGggPz8gMCkgLyAyO1xuICAgIGNvbnN0IG5vZGVEYXRhID0gW107XG4gICAgY29uc3Qgc2l6ZSA9IG1hcmtlci5lbmFibGVkID8gbWFya2VyLnNpemUgOiAwO1xuICAgIGNvbnN0IHhJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHhWYWx1ZWApO1xuICAgIGNvbnN0IHlJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHlWYWx1ZVJhd2ApO1xuICAgIGNvbnN0IHlDdW11bGF0aXZlSWR4ID0gc3RhY2tlZCA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeVZhbHVlQ3VtdWxhdGl2ZWApIDogeUlkeDtcbiAgICBjb25zdCB5RW5kSWR4ID0gc3RhY2tlZCA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeVZhbHVlRW5kYCkgOiB2b2lkIDA7XG4gICAgbGV0IG1vdmVUbyA9IHRydWU7XG4gICAgcHJvY2Vzc2VkRGF0YS5kYXRhPy5mb3JFYWNoKCh7IGRhdHVtLCB2YWx1ZXMgfSkgPT4ge1xuICAgICAgY29uc3QgeERhdHVtID0gdmFsdWVzW3hJZHhdO1xuICAgICAgY29uc3QgeURhdHVtID0gdmFsdWVzW3lJZHhdO1xuICAgICAgY29uc3QgeUN1bXVsYXRpdmVEYXR1bSA9IHZhbHVlc1t5Q3VtdWxhdGl2ZUlkeF07XG4gICAgICBjb25zdCB5RW5kRGF0dW0gPSB5RW5kSWR4ICE9IG51bGwgPyB2YWx1ZXNbeUVuZElkeF0gOiB2b2lkIDA7XG4gICAgICBpZiAoeURhdHVtID09IG51bGwpIHtcbiAgICAgICAgbW92ZVRvIHx8IChtb3ZlVG8gPSAhY29ubmVjdE1pc3NpbmdEYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgeCA9IHhTY2FsZS5jb252ZXJ0KHhEYXR1bSkgKyB4T2Zmc2V0O1xuICAgICAgaWYgKGlzTmFOKHgpKSB7XG4gICAgICAgIG1vdmVUbyB8fCAobW92ZVRvID0gIWNvbm5lY3RNaXNzaW5nRGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHkgPSB5U2NhbGUuY29udmVydCh5Q3VtdWxhdGl2ZURhdHVtKSArIHlPZmZzZXQ7XG4gICAgICBjb25zdCBsYWJlbFRleHQgPSB0aGlzLmdldExhYmVsVGV4dChcbiAgICAgICAgbGFiZWwsXG4gICAgICAgIHsgdmFsdWU6IHlEYXR1bSwgZGF0dW0sIHhLZXksIHlLZXksIHhOYW1lLCB5TmFtZSwgbGVnZW5kSXRlbU5hbWUgfSxcbiAgICAgICAgKHZhbHVlKSA9PiBpc0Zpbml0ZU51bWJlcih2YWx1ZSkgPyB2YWx1ZS50b0ZpeGVkKDIpIDogU3RyaW5nKHZhbHVlKVxuICAgICAgKTtcbiAgICAgIG5vZGVEYXRhLnB1c2goe1xuICAgICAgICBzZXJpZXM6IHRoaXMsXG4gICAgICAgIGRhdHVtLFxuICAgICAgICB5S2V5LFxuICAgICAgICB4S2V5LFxuICAgICAgICBwb2ludDogeyB4LCB5LCBtb3ZlVG8sIHNpemUgfSxcbiAgICAgICAgbWlkUG9pbnQ6IHsgeCwgeSB9LFxuICAgICAgICBjdW11bGF0aXZlVmFsdWU6IHlFbmREYXR1bSxcbiAgICAgICAgeVZhbHVlOiB5RGF0dW0sXG4gICAgICAgIHhWYWx1ZTogeERhdHVtLFxuICAgICAgICBjYXBEZWZhdWx0czoge1xuICAgICAgICAgIGxlbmd0aFJhdGlvTXVsdGlwbGllcjogdGhpcy5wcm9wZXJ0aWVzLm1hcmtlci5nZXREaWFtZXRlcigpLFxuICAgICAgICAgIGxlbmd0aE1heDogSW5maW5pdHlcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWw6IGxhYmVsVGV4dCA/IHtcbiAgICAgICAgICB0ZXh0OiBsYWJlbFRleHQsXG4gICAgICAgICAgZm9udFN0eWxlOiBsYWJlbC5mb250U3R5bGUsXG4gICAgICAgICAgZm9udFdlaWdodDogbGFiZWwuZm9udFdlaWdodCxcbiAgICAgICAgICBmb250U2l6ZTogbGFiZWwuZm9udFNpemUsXG4gICAgICAgICAgZm9udEZhbWlseTogbGFiZWwuZm9udEZhbWlseSxcbiAgICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgICAgdGV4dEJhc2VsaW5lOiBcImJvdHRvbVwiLFxuICAgICAgICAgIGZpbGw6IGxhYmVsLmNvbG9yXG4gICAgICAgIH0gOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgICAgbW92ZVRvID0gZmFsc2U7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgIG5vZGVEYXRhLFxuICAgICAgbGFiZWxEYXRhOiBub2RlRGF0YSxcbiAgICAgIHNjYWxlczogdGhpcy5jYWxjdWxhdGVTY2FsaW5nKCksXG4gICAgICB2aXNpYmxlOiB0aGlzLnZpc2libGVcbiAgICB9O1xuICB9XG4gIGlzUGF0aE9yU2VsZWN0aW9uRGlydHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvcGVydGllcy5tYXJrZXIuaXNEaXJ0eSgpO1xuICB9XG4gIG1hcmtlckZhY3RvcnkoKSB7XG4gICAgY29uc3QgeyBzaGFwZSB9ID0gdGhpcy5wcm9wZXJ0aWVzLm1hcmtlcjtcbiAgICBjb25zdCBNYXJrZXJTaGFwZSA9IGdldE1hcmtlcihzaGFwZSk7XG4gICAgcmV0dXJuIG5ldyBNYXJrZXJTaGFwZSgpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVBhdGhOb2RlcyhvcHRzKSB7XG4gICAgY29uc3Qge1xuICAgICAgcGF0aHM6IFtsaW5lTm9kZV0sXG4gICAgICBvcGFjaXR5LFxuICAgICAgdmlzaWJsZSxcbiAgICAgIGFuaW1hdGlvbkVuYWJsZWRcbiAgICB9ID0gb3B0cztcbiAgICBsaW5lTm9kZS5zZXRQcm9wZXJ0aWVzKHtcbiAgICAgIGZpbGw6IHZvaWQgMCxcbiAgICAgIGxpbmVKb2luOiBcInJvdW5kXCIsXG4gICAgICBwb2ludGVyRXZlbnRzOiAxIC8qIE5vbmUgKi8sXG4gICAgICBvcGFjaXR5LFxuICAgICAgc3Ryb2tlOiB0aGlzLnByb3BlcnRpZXMuc3Ryb2tlLFxuICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuZ2V0U3Ryb2tlV2lkdGgodGhpcy5wcm9wZXJ0aWVzLnN0cm9rZVdpZHRoKSxcbiAgICAgIHN0cm9rZU9wYWNpdHk6IHRoaXMucHJvcGVydGllcy5zdHJva2VPcGFjaXR5LFxuICAgICAgbGluZURhc2g6IHRoaXMucHJvcGVydGllcy5saW5lRGFzaCxcbiAgICAgIGxpbmVEYXNoT2Zmc2V0OiB0aGlzLnByb3BlcnRpZXMubGluZURhc2hPZmZzZXRcbiAgICB9KTtcbiAgICBpZiAoIWFuaW1hdGlvbkVuYWJsZWQpIHtcbiAgICAgIGxpbmVOb2RlLnZpc2libGUgPSB2aXNpYmxlO1xuICAgIH1cbiAgICB1cGRhdGVDbGlwUGF0aCh0aGlzLCBsaW5lTm9kZSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTWFya2VyU2VsZWN0aW9uKG9wdHMpIHtcbiAgICBsZXQgeyBub2RlRGF0YSB9ID0gb3B0cztcbiAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbiB9ID0gb3B0cztcbiAgICBjb25zdCB7IHNoYXBlLCBlbmFibGVkIH0gPSB0aGlzLnByb3BlcnRpZXMubWFya2VyO1xuICAgIG5vZGVEYXRhID0gc2hhcGUgJiYgZW5hYmxlZCA/IG5vZGVEYXRhIDogW107XG4gICAgaWYgKHRoaXMucHJvcGVydGllcy5tYXJrZXIuaXNEaXJ0eSgpKSB7XG4gICAgICBtYXJrZXJTZWxlY3Rpb24uY2xlYXIoKTtcbiAgICAgIG1hcmtlclNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXJTZWxlY3Rpb24udXBkYXRlKG5vZGVEYXRhLCB2b2lkIDAsIChkYXR1bSkgPT4gY3JlYXRlRGF0dW1JZChkYXR1bS54VmFsdWUpKTtcbiAgfVxuICBhc3luYyB1cGRhdGVNYXJrZXJOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBtYXJrZXJTZWxlY3Rpb24sIGlzSGlnaGxpZ2h0OiBoaWdobGlnaHRlZCB9ID0gb3B0cztcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0cm9rZU9wYWNpdHksIG1hcmtlciwgaGlnaGxpZ2h0U3R5bGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBiYXNlU3R5bGUgPSBtZXJnZURlZmF1bHRzKGhpZ2hsaWdodGVkICYmIGhpZ2hsaWdodFN0eWxlLml0ZW0sIG1hcmtlci5nZXRTdHlsZSgpLCB7XG4gICAgICBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZU9wYWNpdHlcbiAgICB9KTtcbiAgICBjb25zdCBhcHBseVRyYW5zbGF0aW9uID0gdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKTtcbiAgICBtYXJrZXJTZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0pID0+IHtcbiAgICAgIHRoaXMudXBkYXRlTWFya2VyU3R5bGUobm9kZSwgbWFya2VyLCB7IGRhdHVtLCBoaWdobGlnaHRlZCwgeEtleSwgeUtleSB9LCBiYXNlU3R5bGUsIHsgYXBwbHlUcmFuc2xhdGlvbiB9KTtcbiAgICB9KTtcbiAgICBpZiAoIWhpZ2hsaWdodGVkKSB7XG4gICAgICBtYXJrZXIubWFya0NsZWFuKCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHVwZGF0ZUxhYmVsU2VsZWN0aW9uKG9wdHMpIHtcbiAgICByZXR1cm4gb3B0cy5sYWJlbFNlbGVjdGlvbi51cGRhdGUodGhpcy5pc0xhYmVsRW5hYmxlZCgpID8gb3B0cy5sYWJlbERhdGEgOiBbXSk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTGFiZWxOb2RlcyhvcHRzKSB7XG4gICAgY29uc3QgeyBlbmFibGVkLCBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5LCBjb2xvciB9ID0gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsO1xuICAgIG9wdHMubGFiZWxTZWxlY3Rpb24uZWFjaCgodGV4dCwgZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IHsgcG9pbnQsIGxhYmVsIH0gPSBkYXR1bTtcbiAgICAgIGlmIChkYXR1bSAmJiBsYWJlbCAmJiBlbmFibGVkKSB7XG4gICAgICAgIHRleHQuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgICB0ZXh0LmZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xuICAgICAgICB0ZXh0LmZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICAgIHRleHQuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICAgIHRleHQudGV4dEFsaWduID0gbGFiZWwudGV4dEFsaWduO1xuICAgICAgICB0ZXh0LnRleHRCYXNlbGluZSA9IGxhYmVsLnRleHRCYXNlbGluZTtcbiAgICAgICAgdGV4dC50ZXh0ID0gbGFiZWwudGV4dDtcbiAgICAgICAgdGV4dC54ID0gcG9pbnQueDtcbiAgICAgICAgdGV4dC55ID0gcG9pbnQueSAtIDEwO1xuICAgICAgICB0ZXh0LmZpbGwgPSBjb2xvcjtcbiAgICAgICAgdGV4dC52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRleHQudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldFRvb2x0aXBIdG1sKG5vZGVEYXR1bSkge1xuICAgIGNvbnN0IHhBeGlzID0gdGhpcy5heGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gdGhpcy5heGVzW1wieVwiIC8qIFkgKi9dO1xuICAgIGlmICghdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCAheEF4aXMgfHwgIXlBeGlzKSB7XG4gICAgICByZXR1cm4gRU1QVFlfVE9PTFRJUF9DT05URU5UO1xuICAgIH1cbiAgICBjb25zdCB7IHhLZXksIHlLZXksIHhOYW1lLCB5TmFtZSwgc3Ryb2tlV2lkdGgsIG1hcmtlciwgdG9vbHRpcCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgZGF0dW0sIHhWYWx1ZSwgeVZhbHVlLCBpdGVtSWQgfSA9IG5vZGVEYXR1bTtcbiAgICBjb25zdCB4U3RyaW5nID0geEF4aXMuZm9ybWF0RGF0dW0oeFZhbHVlKTtcbiAgICBjb25zdCB5U3RyaW5nID0geUF4aXMuZm9ybWF0RGF0dW0oeVZhbHVlKTtcbiAgICBjb25zdCB0aXRsZSA9IHNhbml0aXplSHRtbCh0aGlzLnByb3BlcnRpZXMudGl0bGUgPz8geU5hbWUpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBzYW5pdGl6ZUh0bWwoeFN0cmluZyArIFwiOiBcIiArIHlTdHJpbmcpO1xuICAgIGNvbnN0IGJhc2VTdHlsZSA9IG1lcmdlRGVmYXVsdHMoeyBmaWxsOiBtYXJrZXIuc3Ryb2tlIH0sIG1hcmtlci5nZXRTdHlsZSgpLCB7IHN0cm9rZVdpZHRoIH0pO1xuICAgIGNvbnN0IHsgZmlsbDogY29sb3IgfSA9IHRoaXMuZ2V0TWFya2VyU3R5bGUoXG4gICAgICBtYXJrZXIsXG4gICAgICB7IGRhdHVtOiBub2RlRGF0dW0sIHhLZXksIHlLZXksIGhpZ2hsaWdodGVkOiBmYWxzZSB9LFxuICAgICAgYmFzZVN0eWxlXG4gICAgKTtcbiAgICByZXR1cm4gdG9vbHRpcC50b1Rvb2x0aXBIdG1sKFxuICAgICAgeyB0aXRsZSwgY29udGVudCwgYmFja2dyb3VuZENvbG9yOiBjb2xvciB9LFxuICAgICAge1xuICAgICAgICBkYXR1bSxcbiAgICAgICAgaXRlbUlkLFxuICAgICAgICB4S2V5LFxuICAgICAgICB4TmFtZSxcbiAgICAgICAgeUtleSxcbiAgICAgICAgeU5hbWUsXG4gICAgICAgIHRpdGxlLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIC4uLnRoaXMuZ2V0TW9kdWxlVG9vbHRpcFBhcmFtcygpXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpIHtcbiAgICBpZiAoISh0aGlzLmRhdGE/Lmxlbmd0aCAmJiB0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpICYmIGxlZ2VuZFR5cGUgPT09IFwiY2F0ZWdvcnlcIikpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgeyB5S2V5LCB5TmFtZSwgc3Ryb2tlLCBzdHJva2VPcGFjaXR5LCBzdHJva2VXaWR0aCwgbGluZURhc2gsIHRpdGxlLCBtYXJrZXIsIHZpc2libGUsIGxlZ2VuZEl0ZW1OYW1lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgY29sb3IwID0gXCJyZ2JhKDAsIDAsIDAsIDApXCI7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAgbGVnZW5kVHlwZTogXCJjYXRlZ29yeVwiLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgaXRlbUlkOiB5S2V5LFxuICAgICAgICBsZWdlbmRJdGVtTmFtZSxcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIGVuYWJsZWQ6IHZpc2libGUsXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgdGV4dDogbGVnZW5kSXRlbU5hbWUgPz8gdGl0bGUgPz8geU5hbWUgPz8geUtleVxuICAgICAgICB9LFxuICAgICAgICBzeW1ib2xzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgIHNoYXBlOiBtYXJrZXIuc2hhcGUsXG4gICAgICAgICAgICAgIGZpbGw6IG1hcmtlci5maWxsID8/IGNvbG9yMCxcbiAgICAgICAgICAgICAgc3Ryb2tlOiBtYXJrZXIuc3Ryb2tlID8/IHN0cm9rZSA/PyBjb2xvcjAsXG4gICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBtYXJrZXIuZmlsbE9wYWNpdHkgPz8gMSxcbiAgICAgICAgICAgICAgc3Ryb2tlT3BhY2l0eTogbWFya2VyLnN0cm9rZU9wYWNpdHkgPz8gc3Ryb2tlT3BhY2l0eSA/PyAxLFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogbWFya2VyLnN0cm9rZVdpZHRoID8/IDAsXG4gICAgICAgICAgICAgIGVuYWJsZWQ6IG1hcmtlci5lbmFibGVkXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZToge1xuICAgICAgICAgICAgICBzdHJva2U6IHN0cm9rZSA/PyBjb2xvcjAsXG4gICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICAgICAgICBsaW5lRGFzaFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIF07XG4gIH1cbiAgYXN5bmMgdXBkYXRlUGF0aHMob3B0cykge1xuICAgIHRoaXMudXBkYXRlTGluZVBhdGhzKG9wdHMucGF0aHMsIG9wdHMuY29udGV4dERhdGEpO1xuICB9XG4gIHVwZGF0ZUxpbmVQYXRocyhwYXRocywgY29udGV4dERhdGEpIHtcbiAgICBjb25zdCB7IGludGVycG9sYXRpb24gfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IG5vZGVEYXRhIH0gPSBjb250ZXh0RGF0YTtcbiAgICBjb25zdCBbbGluZU5vZGVdID0gcGF0aHM7XG4gICAgbGluZU5vZGUucGF0aC5jbGVhcih0cnVlKTtcbiAgICBmb3IgKGNvbnN0IHJhbmdlMyBvZiBwYXRoUmFuZ2VzKG5vZGVEYXRhKSkge1xuICAgICAgcGxvdFBhdGgocGF0aFJhbmdlUG9pbnRzKG5vZGVEYXRhLCByYW5nZTMpLCBsaW5lTm9kZSwgaW50ZXJwb2xhdGlvbik7XG4gICAgfVxuICAgIGxpbmVOb2RlLmNoZWNrUGF0aERpcnR5KCk7XG4gIH1cbiAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoYW5pbWF0aW9uRGF0YSkge1xuICAgIGNvbnN0IHsgbWFya2VyU2VsZWN0aW9uLCBsYWJlbFNlbGVjdGlvbiwgYW5ub3RhdGlvblNlbGVjdGlvbnMsIGNvbnRleHREYXRhLCBwYXRocyB9ID0gYW5pbWF0aW9uRGF0YTtcbiAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIHRoaXMudXBkYXRlTGluZVBhdGhzKHBhdGhzLCBjb250ZXh0RGF0YSk7XG4gICAgcGF0aFN3aXBlSW5BbmltYXRpb24odGhpcywgYW5pbWF0aW9uTWFuYWdlciwgLi4ucGF0aHMpO1xuICAgIHJlc2V0TW90aW9uKFttYXJrZXJTZWxlY3Rpb25dLCByZXNldE1hcmtlclBvc2l0aW9uRm4pO1xuICAgIG1hcmtlclN3aXBlU2NhbGVJbkFuaW1hdGlvbih0aGlzLCBhbmltYXRpb25NYW5hZ2VyLCBtYXJrZXJTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwibGFiZWxzXCIsIGFuaW1hdGlvbk1hbmFnZXIsIGxhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImFubm90YXRpb25zXCIsIGFuaW1hdGlvbk1hbmFnZXIsIC4uLmFubm90YXRpb25TZWxlY3Rpb25zKTtcbiAgfVxuICBhbmltYXRlUmVhZHlSZXNpemUoYW5pbWF0aW9uRGF0YSkge1xuICAgIGNvbnN0IHsgY29udGV4dERhdGEsIHBhdGhzIH0gPSBhbmltYXRpb25EYXRhO1xuICAgIHRoaXMudXBkYXRlTGluZVBhdGhzKHBhdGhzLCBjb250ZXh0RGF0YSk7XG4gICAgc3VwZXIuYW5pbWF0ZVJlYWR5UmVzaXplKGFuaW1hdGlvbkRhdGEpO1xuICB9XG4gIGFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoYW5pbWF0aW9uRGF0YSkge1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qge1xuICAgICAgbWFya2VyU2VsZWN0aW9uOiBtYXJrZXJTZWxlY3Rpb25zLFxuICAgICAgbGFiZWxTZWxlY3Rpb246IGxhYmVsU2VsZWN0aW9ucyxcbiAgICAgIGFubm90YXRpb25TZWxlY3Rpb25zLFxuICAgICAgY29udGV4dERhdGEsXG4gICAgICBwYXRocyxcbiAgICAgIHByZXZpb3VzQ29udGV4dERhdGFcbiAgICB9ID0gYW5pbWF0aW9uRGF0YTtcbiAgICBjb25zdCBbcGF0aF0gPSBwYXRocztcbiAgICB0aGlzLnJlc2V0TWFya2VyQW5pbWF0aW9uKGFuaW1hdGlvbkRhdGEpO1xuICAgIHRoaXMucmVzZXRMYWJlbEFuaW1hdGlvbihhbmltYXRpb25EYXRhKTtcbiAgICBjb25zdCB1cGRhdGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLnJlc2V0UGF0aEFuaW1hdGlvbihhbmltYXRpb25EYXRhKTtcbiAgICAgIHRoaXMudXBkYXRlTGluZVBhdGhzKHBhdGhzLCBjb250ZXh0RGF0YSk7XG4gICAgfTtcbiAgICBjb25zdCBza2lwID0gKCkgPT4ge1xuICAgICAgYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgICB1cGRhdGUoKTtcbiAgICB9O1xuICAgIGlmIChjb250ZXh0RGF0YSA9PSBudWxsIHx8IHByZXZpb3VzQ29udGV4dERhdGEgPT0gbnVsbCkge1xuICAgICAgdXBkYXRlKCk7XG4gICAgICBtYXJrZXJGYWRlSW5BbmltYXRpb24odGhpcywgYW5pbWF0aW9uTWFuYWdlciwgXCJhZGRlZFwiLCBtYXJrZXJTZWxlY3Rpb25zKTtcbiAgICAgIHBhdGhGYWRlSW5BbmltYXRpb24odGhpcywgXCJwYXRoX3Byb3BlcnRpZXNcIiwgYW5pbWF0aW9uTWFuYWdlciwgXCJhZGRcIiwgcGF0aCk7XG4gICAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImxhYmVsc1wiLCBhbmltYXRpb25NYW5hZ2VyLCBsYWJlbFNlbGVjdGlvbnMpO1xuICAgICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJhbm5vdGF0aW9uc1wiLCBhbmltYXRpb25NYW5hZ2VyLCAuLi5hbm5vdGF0aW9uU2VsZWN0aW9ucyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGZucyA9IHByZXBhcmVMaW5lUGF0aEFuaW1hdGlvbihcbiAgICAgIGNvbnRleHREYXRhLFxuICAgICAgcHJldmlvdXNDb250ZXh0RGF0YSxcbiAgICAgIHRoaXMucHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uZGlmZixcbiAgICAgIHRoaXMucHJvcGVydGllcy5pbnRlcnBvbGF0aW9uXG4gICAgKTtcbiAgICBpZiAoZm5zID09PSB2b2lkIDApIHtcbiAgICAgIHNraXAoKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKGZucy5zdGF0dXMgPT09IFwibm8tb3BcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtYXJrZXJGYWRlSW5BbmltYXRpb24odGhpcywgYW5pbWF0aW9uTWFuYWdlciwgdm9pZCAwLCBtYXJrZXJTZWxlY3Rpb25zKTtcbiAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgXCJwYXRoX3Byb3BlcnRpZXNcIiwgYW5pbWF0aW9uTWFuYWdlciwgW3BhdGhdLCBmbnMucGF0aFByb3BlcnRpZXMpO1xuICAgIHBhdGhNb3Rpb24odGhpcy5pZCwgXCJwYXRoX3VwZGF0ZVwiLCBhbmltYXRpb25NYW5hZ2VyLCBbcGF0aF0sIGZucy5wYXRoKTtcbiAgICBpZiAoZm5zLmhhc01vdGlvbikge1xuICAgICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb25zKTtcbiAgICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiYW5ub3RhdGlvbnNcIiwgYW5pbWF0aW9uTWFuYWdlciwgLi4uYW5ub3RhdGlvblNlbGVjdGlvbnMpO1xuICAgIH1cbiAgfVxuICBpc0xhYmVsRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLmxhYmVsLmVuYWJsZWQ7XG4gIH1cbiAgZ2V0QmFuZFNjYWxlUGFkZGluZygpIHtcbiAgICByZXR1cm4geyBpbm5lcjogMSwgb3V0ZXI6IDAuMSB9O1xuICB9XG4gIG5vZGVGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgR3JvdXAoKTtcbiAgfVxuICBnZXRGb3JtYXR0ZWRNYXJrZXJTdHlsZShkYXR1bSkge1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIHJldHVybiB0aGlzLmdldE1hcmtlclN0eWxlKHRoaXMucHJvcGVydGllcy5tYXJrZXIsIHsgZGF0dW0sIHhLZXksIHlLZXksIGhpZ2hsaWdodGVkOiB0cnVlIH0pO1xuICB9XG4gIGNvbXB1dGVGb2N1c0JvdW5kcyhvcHRzKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVNYXJrZXJGb2N1c0JvdW5kcyh0aGlzLCBvcHRzKTtcbiAgfVxufTtcbkxpbmVTZXJpZXMuY2xhc3NOYW1lID0gXCJMaW5lU2VyaWVzXCI7XG5MaW5lU2VyaWVzLnR5cGUgPSBcImxpbmVcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9saW5lU2VyaWVzTW9kdWxlLnRzXG52YXIgTGluZVNlcmllc01vZHVsZSA9IHtcbiAgdHlwZTogXCJzZXJpZXNcIixcbiAgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLFxuICBpZGVudGlmaWVyOiBcImxpbmVcIixcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IExpbmVTZXJpZXMoY3R4KSxcbiAgc3RhY2thYmxlOiB0cnVlLFxuICB0b29sdGlwRGVmYXVsdHM6IHsgcmFuZ2U6IFwibmVhcmVzdFwiIH0sXG4gIGRlZmF1bHRBeGVzOiBbXG4gICAge1xuICAgICAgdHlwZTogXCJudW1iZXJcIiAvKiBOVU1CRVIgKi8sXG4gICAgICBwb3NpdGlvbjogXCJsZWZ0XCIgLyogTEVGVCAqL1xuICAgIH0sXG4gICAge1xuICAgICAgdHlwZTogXCJjYXRlZ29yeVwiIC8qIENBVEVHT1JZICovLFxuICAgICAgcG9zaXRpb246IFwiYm90dG9tXCIgLyogQk9UVE9NICovXG4gICAgfVxuICBdLFxuICB0aGVtZVRlbXBsYXRlOiB7XG4gICAgc2VyaWVzOiB7XG4gICAgICB0b29sdGlwOiB7IHBvc2l0aW9uOiB7IHR5cGU6IFwibm9kZVwiIH0gfSxcbiAgICAgIHN0cm9rZVdpZHRoOiAyLFxuICAgICAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgICAgIGxpbmVEYXNoOiBbMF0sXG4gICAgICBsaW5lRGFzaE9mZnNldDogMCxcbiAgICAgIGludGVycG9sYXRpb246IHtcbiAgICAgICAgdHlwZTogXCJsaW5lYXJcIixcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIHVzZXJzIHNob3VsZG4ndCBzcGVjaWZ5IGFsbCBvcHRpb25zLCBidXQgd2UgaGF2ZSB0byBmb3IgdGhlbWluZyB0byB3b3JrXG4gICAgICAgIHRlbnNpb246IDEsXG4gICAgICAgIHBvc2l0aW9uOiBcImVuZFwiXG4gICAgICB9LFxuICAgICAgbWFya2VyOiB7XG4gICAgICAgIHNoYXBlOiBcImNpcmNsZVwiLFxuICAgICAgICBzaXplOiA3LFxuICAgICAgICBzdHJva2VXaWR0aDogMFxuICAgICAgfSxcbiAgICAgIGxhYmVsOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBmb250U2l6ZTogMTIsXG4gICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX0xBQkVMX0NPTE9VUlxuICAgICAgfSxcbiAgICAgIGVycm9yQmFyOiB7XG4gICAgICAgIGNhcDoge1xuICAgICAgICAgIGxlbmd0aFJhdGlvOiAxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHBhbGV0dGVGYWN0b3J5OiAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgeyBtYXJrZXIgfSA9IG1hcmtlclBhbGV0dGVGYWN0b3J5KHBhcmFtcyk7XG4gICAgcmV0dXJuIHsgc3Ryb2tlOiBtYXJrZXIuZmlsbCwgbWFya2VyIH07XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9jYXJ0ZXNpYW4vc2NhdHRlclNlcmllc1Byb3BlcnRpZXMudHNcbnZhciBTY2F0dGVyU2VyaWVzTGFiZWwgPSBjbGFzcyBleHRlbmRzIExhYmVsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnBsYWNlbWVudCA9IFwidG9wXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShMQUJFTF9QTEFDRU1FTlQpXG5dLCBTY2F0dGVyU2VyaWVzTGFiZWwucHJvdG90eXBlLCBcInBsYWNlbWVudFwiLCAyKTtcbnZhciBTY2F0dGVyU2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jb2xvclJhbmdlID0gW1wiI2ZmZmYwMFwiLCBcIiMwMGZmMDBcIiwgXCIjMDAwMGZmXCJdO1xuICAgIHRoaXMubGFiZWwgPSBuZXcgU2NhdHRlclNlcmllc0xhYmVsKCk7XG4gICAgdGhpcy50b29sdGlwID0gbmV3IFNlcmllc1Rvb2x0aXAoKTtcbiAgICAvLyBObyB2YWxpZGF0aW9uLiBOb3QgYSBwYXJ0IG9mIHRoZSBvcHRpb25zIGNvbnRyYWN0LlxuICAgIHRoaXMubWFya2VyID0gbmV3IFNlcmllc01hcmtlcigpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInhLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwieUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxhYmVsS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29sb3JLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ4TmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInlOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGFiZWxOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29sb3JOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSX0FSUkFZLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29sb3JEb21haW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVkpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29sb3JSYW5nZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInRpdGxlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5zaGFwZVwiKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNoYXBlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgUHJveHlQcm9wZXJ0eShcIm1hcmtlci5zaXplXCIpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2l6ZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuZmlsbFwiKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLmZpbGxPcGFjaXR5XCIpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLnN0cm9rZVwiKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc3Ryb2tlV2lkdGhcIilcbl0sIFNjYXR0ZXJTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFByb3h5UHJvcGVydHkoXCJtYXJrZXIuc3Ryb2tlT3BhY2l0eVwiKVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZU9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBQcm94eVByb3BlcnR5KFwibWFya2VyLml0ZW1TdHlsZXJcIiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgU2NhdHRlclNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIml0ZW1TdHlsZXJcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBTY2F0dGVyU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9zY2F0dGVyU2VyaWVzLnRzXG52YXIgU2NhdHRlclNlcmllcyA9IGNsYXNzIGV4dGVuZHMgQ2FydGVzaWFuU2VyaWVzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbW9kdWxlQ3R4LFxuICAgICAgZGlyZWN0aW9uS2V5czogREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX0tFWVMsXG4gICAgICBkaXJlY3Rpb25OYW1lczogREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX05BTUVTLFxuICAgICAgcGlja01vZGVzOiBbXG4gICAgICAgIDIgLyogTkVBUkVTVF9CWV9NQUlOX0NBVEVHT1JZX0FYSVNfRklSU1QgKi8sXG4gICAgICAgIDMgLyogTkVBUkVTVF9OT0RFICovLFxuICAgICAgICAwIC8qIEVYQUNUX1NIQVBFX01BVENIICovXG4gICAgICBdLFxuICAgICAgcGF0aHNQZXJTZXJpZXM6IFtdLFxuICAgICAgaGFzTWFya2VyczogdHJ1ZSxcbiAgICAgIG1hcmtlclNlbGVjdGlvbkdhcmJhZ2VDb2xsZWN0aW9uOiBmYWxzZSxcbiAgICAgIGFuaW1hdGlvblJlc2V0Rm5zOiB7XG4gICAgICAgIG1hcmtlcjogcmVzZXRNYXJrZXJGbixcbiAgICAgICAgbGFiZWw6IHJlc2V0TGFiZWxGblxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucHJvcGVydGllcyA9IG5ldyBTY2F0dGVyU2VyaWVzUHJvcGVydGllcygpO1xuICAgIHRoaXMuY29sb3JTY2FsZSA9IG5ldyBDb2xvclNjYWxlKCk7XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0RhdGEoZGF0YUNvbnRyb2xsZXIpIHtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgdGhpcy5kYXRhID09IG51bGwgfHwgIXRoaXMudmlzaWJsZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB4U2NhbGUgPSB0aGlzLmF4ZXNbXCJ4XCIgLyogWCAqL10/LnNjYWxlO1xuICAgIGNvbnN0IHlTY2FsZSA9IHRoaXMuYXhlc1tcInlcIiAvKiBZICovXT8uc2NhbGU7XG4gICAgY29uc3QgeyB4U2NhbGVUeXBlLCB5U2NhbGVUeXBlIH0gPSB0aGlzLmdldFNjYWxlSW5mb3JtYXRpb24oeyB4U2NhbGUsIHlTY2FsZSB9KTtcbiAgICBjb25zdCBjb2xvclNjYWxlVHlwZSA9IHRoaXMuY29sb3JTY2FsZS50eXBlO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgbGFiZWxLZXksIGNvbG9yS2V5LCBjb2xvckRvbWFpbiwgY29sb3JSYW5nZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH0gPSBhd2FpdCB0aGlzLnJlcXVlc3REYXRhTW9kZWwoZGF0YUNvbnRyb2xsZXIsIHRoaXMuZGF0YSwge1xuICAgICAgcHJvcHM6IFtcbiAgICAgICAga2V5UHJvcGVydHkoeEtleSwgeFNjYWxlVHlwZSwgeyBpZDogXCJ4S2V5LXJhd1wiIH0pLFxuICAgICAgICBrZXlQcm9wZXJ0eSh5S2V5LCB5U2NhbGVUeXBlLCB7IGlkOiBcInlLZXktcmF3XCIgfSksXG4gICAgICAgIC4uLmxhYmVsS2V5ID8gW2tleVByb3BlcnR5KGxhYmVsS2V5LCBcImJhbmRcIiwgeyBpZDogYGxhYmVsS2V5LXJhd2AgfSldIDogW10sXG4gICAgICAgIHZhbHVlUHJvcGVydHkoeEtleSwgeFNjYWxlVHlwZSwgeyBpZDogYHhWYWx1ZWAgfSksXG4gICAgICAgIHZhbHVlUHJvcGVydHkoeUtleSwgeVNjYWxlVHlwZSwgeyBpZDogYHlWYWx1ZWAgfSksXG4gICAgICAgIC4uLmNvbG9yS2V5ID8gW3ZhbHVlUHJvcGVydHkoY29sb3JLZXksIGNvbG9yU2NhbGVUeXBlLCB7IGlkOiBgY29sb3JWYWx1ZWAgfSldIDogW10sXG4gICAgICAgIC4uLmxhYmVsS2V5ID8gW3ZhbHVlUHJvcGVydHkobGFiZWxLZXksIFwiYmFuZFwiLCB7IGlkOiBgbGFiZWxWYWx1ZWAgfSldIDogW11cbiAgICAgIF1cbiAgICB9KTtcbiAgICBpZiAoY29sb3JLZXkpIHtcbiAgICAgIGNvbnN0IGNvbG9yS2V5SWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBjb2xvclZhbHVlYCk7XG4gICAgICB0aGlzLmNvbG9yU2NhbGUuZG9tYWluID0gY29sb3JEb21haW4gPz8gcHJvY2Vzc2VkRGF0YS5kb21haW4udmFsdWVzW2NvbG9yS2V5SWR4XSA/PyBbXTtcbiAgICAgIHRoaXMuY29sb3JTY2FsZS5yYW5nZSA9IGNvbG9yUmFuZ2U7XG4gICAgICB0aGlzLmNvbG9yU2NhbGUudXBkYXRlKCk7XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZURhdGFcIik7XG4gIH1cbiAgZ2V0U2VyaWVzRG9tYWluKGRpcmVjdGlvbikge1xuICAgIGNvbnN0IHsgZGF0YU1vZGVsLCBwcm9jZXNzZWREYXRhIH0gPSB0aGlzO1xuICAgIGlmICghcHJvY2Vzc2VkRGF0YSB8fCAhZGF0YU1vZGVsKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IGlkID0gZGlyZWN0aW9uID09PSBcInhcIiAvKiBYICovID8gYHhWYWx1ZWAgOiBgeVZhbHVlYDtcbiAgICBjb25zdCBkYXRhRGVmID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhRGVmQnlJZCh0aGlzLCBpZCk7XG4gICAgY29uc3QgZG9tYWluID0gZGF0YU1vZGVsLmdldERvbWFpbih0aGlzLCBpZCwgXCJ2YWx1ZVwiLCBwcm9jZXNzZWREYXRhKTtcbiAgICBpZiAoZGF0YURlZj8uZGVmLnR5cGUgPT09IFwidmFsdWVcIiAmJiBkYXRhRGVmPy5kZWYudmFsdWVUeXBlID09PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgIHJldHVybiBkb21haW47XG4gICAgfVxuICAgIGNvbnN0IGF4aXMgPSB0aGlzLmF4ZXNbZGlyZWN0aW9uXTtcbiAgICByZXR1cm4gZml4TnVtZXJpY0V4dGVudChleHRlbnQoZG9tYWluKSwgYXhpcyk7XG4gIH1cbiAgYXN5bmMgY3JlYXRlTm9kZURhdGEoKSB7XG4gICAgY29uc3QgeyBheGVzLCBkYXRhTW9kZWwsIHByb2Nlc3NlZERhdGEsIGNvbG9yU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCBsYWJlbEtleSwgY29sb3JLZXksIHhOYW1lLCB5TmFtZSwgbGFiZWxOYW1lLCBtYXJrZXIsIGxhYmVsLCB2aXNpYmxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBwbGFjZW1lbnQgfSA9IGxhYmVsO1xuICAgIGNvbnN0IG1hcmtlclNoYXBlID0gZ2V0TWFya2VyKG1hcmtlci5zaGFwZSk7XG4gICAgY29uc3QgeEF4aXMgPSBheGVzW1wieFwiIC8qIFggKi9dO1xuICAgIGNvbnN0IHlBeGlzID0gYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBpZiAoIShkYXRhTW9kZWwgJiYgcHJvY2Vzc2VkRGF0YSAmJiB2aXNpYmxlICYmIHhBeGlzICYmIHlBeGlzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB4RGF0YUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgeFZhbHVlYCk7XG4gICAgY29uc3QgeURhdGFJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHlWYWx1ZWApO1xuICAgIGNvbnN0IGNvbG9yRGF0YUlkeCA9IGNvbG9yS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBjb2xvclZhbHVlYCkgOiAtMTtcbiAgICBjb25zdCBsYWJlbERhdGFJZHggPSBsYWJlbEtleSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgbGFiZWxWYWx1ZWApIDogLTE7XG4gICAgY29uc3QgeFNjYWxlID0geEF4aXMuc2NhbGU7XG4gICAgY29uc3QgeVNjYWxlID0geUF4aXMuc2NhbGU7XG4gICAgY29uc3QgeE9mZnNldCA9ICh4U2NhbGUuYmFuZHdpZHRoID8/IDApIC8gMjtcbiAgICBjb25zdCB5T2Zmc2V0ID0gKHlTY2FsZS5iYW5kd2lkdGggPz8gMCkgLyAyO1xuICAgIGNvbnN0IG5vZGVEYXRhID0gW107XG4gICAgY29uc3QgZm9udCA9IGxhYmVsLmdldEZvbnQoKTtcbiAgICBjb25zdCB0ZXh0TWVhc3VyZXIgPSBDYWNoZWRUZXh0TWVhc3VyZXJQb29sLmdldE1lYXN1cmVyKHsgZm9udCB9KTtcbiAgICBmb3IgKGNvbnN0IHsgdmFsdWVzLCBkYXR1bSB9IG9mIHByb2Nlc3NlZERhdGEuZGF0YSA/PyBbXSkge1xuICAgICAgY29uc3QgeERhdHVtID0gdmFsdWVzW3hEYXRhSWR4XTtcbiAgICAgIGNvbnN0IHlEYXR1bSA9IHZhbHVlc1t5RGF0YUlkeF07XG4gICAgICBjb25zdCB4ID0geFNjYWxlLmNvbnZlcnQoeERhdHVtKSArIHhPZmZzZXQ7XG4gICAgICBjb25zdCB5ID0geVNjYWxlLmNvbnZlcnQoeURhdHVtKSArIHlPZmZzZXQ7XG4gICAgICBjb25zdCBsYWJlbFRleHQgPSB0aGlzLmdldExhYmVsVGV4dChsYWJlbCwge1xuICAgICAgICB2YWx1ZTogbGFiZWxLZXkgPyB2YWx1ZXNbbGFiZWxEYXRhSWR4XSA6IHlEYXR1bSxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIHhLZXksXG4gICAgICAgIHlLZXksXG4gICAgICAgIGxhYmVsS2V5LFxuICAgICAgICB4TmFtZSxcbiAgICAgICAgeU5hbWUsXG4gICAgICAgIGxhYmVsTmFtZVxuICAgICAgfSk7XG4gICAgICBjb25zdCBzaXplID0gdGV4dE1lYXN1cmVyLm1lYXN1cmVUZXh0KGxhYmVsVGV4dCk7XG4gICAgICBjb25zdCBmaWxsID0gY29sb3JLZXkgPyBjb2xvclNjYWxlLmNvbnZlcnQodmFsdWVzW2NvbG9yRGF0YUlkeF0pIDogdm9pZCAwO1xuICAgICAgbm9kZURhdGEucHVzaCh7XG4gICAgICAgIHNlcmllczogdGhpcyxcbiAgICAgICAgaXRlbUlkOiB5S2V5LFxuICAgICAgICB5S2V5LFxuICAgICAgICB4S2V5LFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgeFZhbHVlOiB4RGF0dW0sXG4gICAgICAgIHlWYWx1ZTogeURhdHVtLFxuICAgICAgICBjYXBEZWZhdWx0czogeyBsZW5ndGhSYXRpb011bHRpcGxpZXI6IG1hcmtlci5nZXREaWFtZXRlcigpLCBsZW5ndGhNYXg6IEluZmluaXR5IH0sXG4gICAgICAgIHBvaW50OiB7IHgsIHksIHNpemU6IG1hcmtlci5zaXplIH0sXG4gICAgICAgIG1pZFBvaW50OiB7IHgsIHkgfSxcbiAgICAgICAgZmlsbCxcbiAgICAgICAgbGFiZWw6IHsgdGV4dDogbGFiZWxUZXh0LCAuLi5zaXplIH0sXG4gICAgICAgIG1hcmtlcjogbWFya2VyU2hhcGUsXG4gICAgICAgIHBsYWNlbWVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpdGVtSWQ6IHlLZXksXG4gICAgICBub2RlRGF0YSxcbiAgICAgIGxhYmVsRGF0YTogbm9kZURhdGEsXG4gICAgICBzY2FsZXM6IHRoaXMuY2FsY3VsYXRlU2NhbGluZygpLFxuICAgICAgdmlzaWJsZTogdGhpcy52aXNpYmxlXG4gICAgfTtcbiAgfVxuICBpc1BhdGhPclNlbGVjdGlvbkRpcnR5KCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubWFya2VyLmlzRGlydHkoKTtcbiAgfVxuICBnZXRMYWJlbERhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGV4dE5vZGVEYXRhPy5sYWJlbERhdGEgPz8gW107XG4gIH1cbiAgbWFya2VyRmFjdG9yeSgpIHtcbiAgICBjb25zdCB7IHNoYXBlIH0gPSB0aGlzLnByb3BlcnRpZXMubWFya2VyO1xuICAgIGNvbnN0IE1hcmtlclNoYXBlID0gZ2V0TWFya2VyKHNoYXBlKTtcbiAgICByZXR1cm4gbmV3IE1hcmtlclNoYXBlKCk7XG4gIH1cbiAgYXN5bmMgdXBkYXRlTWFya2VyU2VsZWN0aW9uKG9wdHMpIHtcbiAgICBjb25zdCB7IG5vZGVEYXRhLCBtYXJrZXJTZWxlY3Rpb24gfSA9IG9wdHM7XG4gICAgaWYgKHRoaXMucHJvcGVydGllcy5tYXJrZXIuaXNEaXJ0eSgpKSB7XG4gICAgICBtYXJrZXJTZWxlY3Rpb24uY2xlYXIoKTtcbiAgICAgIG1hcmtlclNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXJTZWxlY3Rpb24udXBkYXRlKHRoaXMucHJvcGVydGllcy5tYXJrZXIuZW5hYmxlZCA/IG5vZGVEYXRhIDogW10pO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU1hcmtlck5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IG1hcmtlclNlbGVjdGlvbiwgaXNIaWdobGlnaHQ6IGhpZ2hsaWdodGVkIH0gPSBvcHRzO1xuICAgIGNvbnN0IHsgeEtleSwgeUtleSwgbGFiZWxLZXksIG1hcmtlciwgaGlnaGxpZ2h0U3R5bGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBiYXNlU3R5bGUgPSBtZXJnZURlZmF1bHRzKGhpZ2hsaWdodGVkICYmIGhpZ2hsaWdodFN0eWxlLml0ZW0sIG1hcmtlci5nZXRTdHlsZSgpKTtcbiAgICBtYXJrZXJTZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0pID0+IHtcbiAgICAgIHRoaXMudXBkYXRlTWFya2VyU3R5bGUobm9kZSwgbWFya2VyLCB7IGRhdHVtLCBoaWdobGlnaHRlZCwgeEtleSwgeUtleSwgbGFiZWxLZXkgfSwgYmFzZVN0eWxlKTtcbiAgICB9KTtcbiAgICBpZiAoIWhpZ2hsaWdodGVkKSB7XG4gICAgICBtYXJrZXIubWFya0NsZWFuKCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIHVwZGF0ZUxhYmVsU2VsZWN0aW9uKG9wdHMpIHtcbiAgICBjb25zdCBwbGFjZWRMYWJlbHMgPSB0aGlzLmlzTGFiZWxFbmFibGVkKCkgPyB0aGlzLmNoYXJ0Py5wbGFjZUxhYmVscygpLmdldCh0aGlzKSA/PyBbXSA6IFtdO1xuICAgIHJldHVybiBvcHRzLmxhYmVsU2VsZWN0aW9uLnVwZGF0ZShcbiAgICAgIHBsYWNlZExhYmVscy5tYXAoKHsgZGF0dW0sIHgsIHkgfSkgPT4gKHtcbiAgICAgICAgLi4uZGF0dW0sXG4gICAgICAgIHBvaW50OiB7IHgsIHksIHNpemU6IGRhdHVtLnBvaW50LnNpemUgfSxcbiAgICAgICAgcGxhY2VtZW50OiBcInRvcFwiXG4gICAgICB9KSksXG4gICAgICAodGV4dCkgPT4ge1xuICAgICAgICB0ZXh0LnBvaW50ZXJFdmVudHMgPSAxIC8qIE5vbmUgKi87XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyB1cGRhdGVMYWJlbE5vZGVzKG9wdHMpIHtcbiAgICBjb25zdCB7IGxhYmVsIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgb3B0cy5sYWJlbFNlbGVjdGlvbi5lYWNoKCh0ZXh0LCBkYXR1bSkgPT4ge1xuICAgICAgdGV4dC50ZXh0ID0gZGF0dW0ubGFiZWwudGV4dDtcbiAgICAgIHRleHQuZmlsbCA9IGxhYmVsLmNvbG9yO1xuICAgICAgdGV4dC54ID0gZGF0dW0ucG9pbnQ/LnggPz8gMDtcbiAgICAgIHRleHQueSA9IGRhdHVtLnBvaW50Py55ID8/IDA7XG4gICAgICB0ZXh0LmZvbnRTdHlsZSA9IGxhYmVsLmZvbnRTdHlsZTtcbiAgICAgIHRleHQuZm9udFdlaWdodCA9IGxhYmVsLmZvbnRXZWlnaHQ7XG4gICAgICB0ZXh0LmZvbnRTaXplID0gbGFiZWwuZm9udFNpemU7XG4gICAgICB0ZXh0LmZvbnRGYW1pbHkgPSBsYWJlbC5mb250RmFtaWx5O1xuICAgICAgdGV4dC50ZXh0QWxpZ24gPSBcImxlZnRcIjtcbiAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gXCJ0b3BcIjtcbiAgICB9KTtcbiAgfVxuICBnZXRUb29sdGlwSHRtbChub2RlRGF0dW0pIHtcbiAgICBjb25zdCB4QXhpcyA9IHRoaXMuYXhlc1tcInhcIiAvKiBYICovXTtcbiAgICBjb25zdCB5QXhpcyA9IHRoaXMuYXhlc1tcInlcIiAvKiBZICovXTtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgIXhBeGlzIHx8ICF5QXhpcykge1xuICAgICAgcmV0dXJuIEVNUFRZX1RPT0xUSVBfQ09OVEVOVDtcbiAgICB9XG4gICAgY29uc3QgeyB4S2V5LCB5S2V5LCBsYWJlbEtleSwgeE5hbWUsIHlOYW1lLCBsYWJlbE5hbWUsIHRpdGxlID0geU5hbWUsIG1hcmtlciwgdG9vbHRpcCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgZGF0dW0sIHhWYWx1ZSwgeVZhbHVlLCBsYWJlbCwgaXRlbUlkIH0gPSBub2RlRGF0dW07XG4gICAgY29uc3QgYmFzZVN0eWxlID0gbWVyZ2VEZWZhdWx0cyhcbiAgICAgIHsgZmlsbDogbm9kZURhdHVtLmZpbGwsIHN0cm9rZVdpZHRoOiB0aGlzLmdldFN0cm9rZVdpZHRoKG1hcmtlci5zdHJva2VXaWR0aCkgfSxcbiAgICAgIG1hcmtlci5nZXRTdHlsZSgpXG4gICAgKTtcbiAgICBjb25zdCB7IGZpbGw6IGNvbG9yID0gXCJncmF5XCIgfSA9IHRoaXMuZ2V0TWFya2VyU3R5bGUoXG4gICAgICBtYXJrZXIsXG4gICAgICB7IGRhdHVtOiBub2RlRGF0dW0sIGhpZ2hsaWdodGVkOiBmYWxzZSwgeEtleSwgeUtleSwgbGFiZWxLZXkgfSxcbiAgICAgIGJhc2VTdHlsZVxuICAgICk7XG4gICAgY29uc3QgeFN0cmluZyA9IHNhbml0aXplSHRtbCh4QXhpcy5mb3JtYXREYXR1bSh4VmFsdWUpKTtcbiAgICBjb25zdCB5U3RyaW5nID0gc2FuaXRpemVIdG1sKHlBeGlzLmZvcm1hdERhdHVtKHlWYWx1ZSkpO1xuICAgIGxldCBjb250ZW50ID0gYDxiPiR7c2FuaXRpemVIdG1sKHhOYW1lID8/IHhLZXkpfTwvYj46ICR7eFN0cmluZ308YnI+PGI+JHtzYW5pdGl6ZUh0bWwoeU5hbWUgPz8geUtleSl9PC9iPjogJHt5U3RyaW5nfWA7XG4gICAgaWYgKGxhYmVsS2V5KSB7XG4gICAgICBjb250ZW50ID0gYDxiPiR7c2FuaXRpemVIdG1sKGxhYmVsTmFtZSA/PyBsYWJlbEtleSl9PC9iPjogJHtzYW5pdGl6ZUh0bWwobGFiZWwudGV4dCl9PGJyPmAgKyBjb250ZW50O1xuICAgIH1cbiAgICByZXR1cm4gdG9vbHRpcC50b1Rvb2x0aXBIdG1sKFxuICAgICAgeyB0aXRsZSwgY29udGVudCwgYmFja2dyb3VuZENvbG9yOiBjb2xvciB9LFxuICAgICAge1xuICAgICAgICBkYXR1bSxcbiAgICAgICAgaXRlbUlkLFxuICAgICAgICB4S2V5LFxuICAgICAgICB4TmFtZSxcbiAgICAgICAgeUtleSxcbiAgICAgICAgeU5hbWUsXG4gICAgICAgIGxhYmVsS2V5LFxuICAgICAgICBsYWJlbE5hbWUsXG4gICAgICAgIHRpdGxlLFxuICAgICAgICBjb2xvcixcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIC4uLnRoaXMuZ2V0TW9kdWxlVG9vbHRpcFBhcmFtcygpXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpIHtcbiAgICBjb25zdCB7IHlLZXksIHlOYW1lLCB0aXRsZSwgbWFya2VyLCB2aXNpYmxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgeyBmaWxsLCBzdHJva2UsIGZpbGxPcGFjaXR5LCBzdHJva2VPcGFjaXR5LCBzdHJva2VXaWR0aCB9ID0gbWFya2VyO1xuICAgIGlmICghdGhpcy5kYXRhPy5sZW5ndGggfHwgIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkgfHwgbGVnZW5kVHlwZSAhPT0gXCJjYXRlZ29yeVwiKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIGxlZ2VuZFR5cGU6IFwiY2F0ZWdvcnlcIixcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIGl0ZW1JZDogeUtleSxcbiAgICAgICAgc2VyaWVzSWQ6IHRoaXMuaWQsXG4gICAgICAgIGVuYWJsZWQ6IHZpc2libGUsXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgdGV4dDogdGl0bGUgPz8geU5hbWUgPz8geUtleVxuICAgICAgICB9LFxuICAgICAgICBzeW1ib2xzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgIHNoYXBlOiBtYXJrZXIuc2hhcGUsXG4gICAgICAgICAgICAgIGZpbGw6IG1hcmtlci5maWxsID8/IGZpbGwgPz8gXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG4gICAgICAgICAgICAgIHN0cm9rZTogbWFya2VyLnN0cm9rZSA/PyBzdHJva2UgPz8gXCJyZ2JhKDAsIDAsIDAsIDApXCIsXG4gICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiBmaWxsT3BhY2l0eSA/PyAxLFxuICAgICAgICAgICAgICBzdHJva2VPcGFjaXR5OiBzdHJva2VPcGFjaXR5ID8/IDEsXG4gICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCA/PyAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBdXG4gICAgICB9XG4gICAgXTtcbiAgfVxuICBhbmltYXRlRW1wdHlVcGRhdGVSZWFkeShkYXRhKSB7XG4gICAgY29uc3QgeyBtYXJrZXJTZWxlY3Rpb24sIGxhYmVsU2VsZWN0aW9uLCBhbm5vdGF0aW9uU2VsZWN0aW9ucyB9ID0gZGF0YTtcbiAgICBtYXJrZXJTY2FsZUluQW5pbWF0aW9uKHRoaXMsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIG1hcmtlclNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJsYWJlbHNcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgbGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiYW5ub3RhdGlvbnNcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgLi4uYW5ub3RhdGlvblNlbGVjdGlvbnMpO1xuICB9XG4gIGlzTGFiZWxFbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BlcnRpZXMubGFiZWwuZW5hYmxlZDtcbiAgfVxuICBub2RlRmFjdG9yeSgpIHtcbiAgICByZXR1cm4gbmV3IEdyb3VwKCk7XG4gIH1cbiAgZ2V0Rm9ybWF0dGVkTWFya2VyU3R5bGUoZGF0dW0pIHtcbiAgICBjb25zdCB7IHhLZXksIHlLZXksIGxhYmVsS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TWFya2VyU3R5bGUodGhpcy5wcm9wZXJ0aWVzLm1hcmtlciwgeyBkYXR1bSwgeEtleSwgeUtleSwgbGFiZWxLZXksIGhpZ2hsaWdodGVkOiB0cnVlIH0pO1xuICB9XG4gIGNvbXB1dGVGb2N1c0JvdW5kcyhvcHRzKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVNYXJrZXJGb2N1c0JvdW5kcyh0aGlzLCBvcHRzKTtcbiAgfVxufTtcblNjYXR0ZXJTZXJpZXMuY2xhc3NOYW1lID0gXCJTY2F0dGVyU2VyaWVzXCI7XG5TY2F0dGVyU2VyaWVzLnR5cGUgPSBcInNjYXR0ZXJcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2NhcnRlc2lhbi9zY2F0dGVyU2VyaWVzTW9kdWxlLnRzXG52YXIgU2NhdHRlclNlcmllc01vZHVsZSA9IHtcbiAgdHlwZTogXCJzZXJpZXNcIixcbiAgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wiY2FydGVzaWFuXCJdLFxuICBpZGVudGlmaWVyOiBcInNjYXR0ZXJcIixcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IFNjYXR0ZXJTZXJpZXMoY3R4KSxcbiAgdG9vbHRpcERlZmF1bHRzOiB7IHJhbmdlOiBcIm5lYXJlc3RcIiB9LFxuICBkZWZhdWx0QXhlczogW1xuICAgIHtcbiAgICAgIHR5cGU6IFwibnVtYmVyXCIgLyogTlVNQkVSICovLFxuICAgICAgcG9zaXRpb246IFwiYm90dG9tXCIgLyogQk9UVE9NICovXG4gICAgfSxcbiAgICB7XG4gICAgICB0eXBlOiBcIm51bWJlclwiIC8qIE5VTUJFUiAqLyxcbiAgICAgIHBvc2l0aW9uOiBcImxlZnRcIiAvKiBMRUZUICovXG4gICAgfVxuICBdLFxuICB0aGVtZVRlbXBsYXRlOiB7XG4gICAgc2VyaWVzOiB7XG4gICAgICBzaGFwZTogXCJjaXJjbGVcIixcbiAgICAgIHNpemU6IDcsXG4gICAgICBmaWxsT3BhY2l0eTogMC44LFxuICAgICAgdG9vbHRpcDogeyBwb3NpdGlvbjogeyB0eXBlOiBcIm5vZGVcIiB9IH0sXG4gICAgICBsYWJlbDoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgZm9udFNpemU6IDEyLFxuICAgICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgICBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVJcbiAgICAgIH0sXG4gICAgICBlcnJvckJhcjoge1xuICAgICAgICBjYXA6IHtcbiAgICAgICAgICBsZW5ndGhSYXRpbzogMVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwYWxldHRlRmFjdG9yeTogc2luZ2xlU2VyaWVzUGFsZXR0ZUZhY3Rvcnlcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NlY3RvckJveC50c1xudmFyIFNlY3RvckJveCA9IGNsYXNzIF9TZWN0b3JCb3gge1xuICBjb25zdHJ1Y3RvcihzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzKSB7XG4gICAgdGhpcy5zdGFydEFuZ2xlID0gc3RhcnRBbmdsZTtcbiAgICB0aGlzLmVuZEFuZ2xlID0gZW5kQW5nbGU7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IGlubmVyUmFkaXVzO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cztcbiAgfVxuICBjbG9uZSgpIHtcbiAgICBjb25zdCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBfU2VjdG9yQm94KHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMpO1xuICB9XG4gIFtpbnRlcnBvbGF0ZV0ob3RoZXIsIGQpIHtcbiAgICByZXR1cm4gbmV3IF9TZWN0b3JCb3goXG4gICAgICB0aGlzLnN0YXJ0QW5nbGUgKiAoMSAtIGQpICsgb3RoZXIuc3RhcnRBbmdsZSAqIGQsXG4gICAgICB0aGlzLmVuZEFuZ2xlICogKDEgLSBkKSArIG90aGVyLmVuZEFuZ2xlICogZCxcbiAgICAgIHRoaXMuaW5uZXJSYWRpdXMgKiAoMSAtIGQpICsgb3RoZXIuaW5uZXJSYWRpdXMgKiBkLFxuICAgICAgdGhpcy5vdXRlclJhZGl1cyAqICgxIC0gZCkgKyBvdGhlci5vdXRlclJhZGl1cyAqIGRcbiAgICApO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS91dGlsL3NlY3Rvci50c1xuZnVuY3Rpb24gc2VjdG9yQm94KHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9KSB7XG4gIGxldCB4MCA9IEluZmluaXR5O1xuICBsZXQgeTAgPSBJbmZpbml0eTtcbiAgbGV0IHgxID0gLUluZmluaXR5O1xuICBsZXQgeTEgPSAtSW5maW5pdHk7XG4gIGNvbnN0IGFkZFBvaW50ID0gKHgsIHkpID0+IHtcbiAgICB4MCA9IE1hdGgubWluKHgsIHgwKTtcbiAgICB5MCA9IE1hdGgubWluKHksIHkwKTtcbiAgICB4MSA9IE1hdGgubWF4KHgsIHgxKTtcbiAgICB5MSA9IE1hdGgubWF4KHksIHkxKTtcbiAgfTtcbiAgYWRkUG9pbnQoaW5uZXJSYWRpdXMgKiBNYXRoLmNvcyhzdGFydEFuZ2xlKSwgaW5uZXJSYWRpdXMgKiBNYXRoLnNpbihzdGFydEFuZ2xlKSk7XG4gIGFkZFBvaW50KGlubmVyUmFkaXVzICogTWF0aC5jb3MoZW5kQW5nbGUpLCBpbm5lclJhZGl1cyAqIE1hdGguc2luKGVuZEFuZ2xlKSk7XG4gIGFkZFBvaW50KG91dGVyUmFkaXVzICogTWF0aC5jb3Moc3RhcnRBbmdsZSksIG91dGVyUmFkaXVzICogTWF0aC5zaW4oc3RhcnRBbmdsZSkpO1xuICBhZGRQb2ludChvdXRlclJhZGl1cyAqIE1hdGguY29zKGVuZEFuZ2xlKSwgb3V0ZXJSYWRpdXMgKiBNYXRoLnNpbihlbmRBbmdsZSkpO1xuICBpZiAoaXNCZXR3ZWVuQW5nbGVzKDAsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSkge1xuICAgIGFkZFBvaW50KG91dGVyUmFkaXVzLCAwKTtcbiAgfVxuICBpZiAoaXNCZXR3ZWVuQW5nbGVzKE1hdGguUEkgKiAwLjUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSkge1xuICAgIGFkZFBvaW50KDAsIG91dGVyUmFkaXVzKTtcbiAgfVxuICBpZiAoaXNCZXR3ZWVuQW5nbGVzKE1hdGguUEksIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSkge1xuICAgIGFkZFBvaW50KC1vdXRlclJhZGl1cywgMCk7XG4gIH1cbiAgaWYgKGlzQmV0d2VlbkFuZ2xlcyhNYXRoLlBJICogMS41LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICBhZGRQb2ludCgwLCAtb3V0ZXJSYWRpdXMpO1xuICB9XG4gIHJldHVybiBuZXcgQkJveCh4MCwgeTAsIHgxIC0geDAsIHkxIC0geTApO1xufVxuZnVuY3Rpb24gaXNQb2ludEluU2VjdG9yKHgsIHksIHNlY3Rvcikge1xuICBjb25zdCByYWRpdXMgPSBNYXRoLnNxcnQoTWF0aC5wb3coeCwgMikgKyBNYXRoLnBvdyh5LCAyKSk7XG4gIGNvbnN0IHsgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0gPSBzZWN0b3I7XG4gIGlmIChzZWN0b3Iuc3RhcnRBbmdsZSA9PT0gc2VjdG9yLmVuZEFuZ2xlIHx8IHJhZGl1cyA8IE1hdGgubWluKGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cykgfHwgcmFkaXVzID4gTWF0aC5tYXgoaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzdGFydEFuZ2xlID0gbm9ybWFsaXplQW5nbGUxODAoc2VjdG9yLnN0YXJ0QW5nbGUpO1xuICBjb25zdCBlbmRBbmdsZSA9IG5vcm1hbGl6ZUFuZ2xlMTgwKHNlY3Rvci5lbmRBbmdsZSk7XG4gIGNvbnN0IGFuZ2xlMiA9IE1hdGguYXRhbjIoeSwgeCk7XG4gIHJldHVybiBzdGFydEFuZ2xlIDwgZW5kQW5nbGUgPyBhbmdsZTIgPD0gZW5kQW5nbGUgJiYgYW5nbGUyID49IHN0YXJ0QW5nbGUgOiBhbmdsZTIgPD0gZW5kQW5nbGUgJiYgYW5nbGUyID49IC1NYXRoLlBJIHx8IGFuZ2xlMiA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlMiA8PSBNYXRoLlBJO1xufVxuZnVuY3Rpb24gbGluZUNvbGxpZGVzU2VjdG9yKGxpbmUsIHNlY3Rvcikge1xuICBjb25zdCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSA9IHNlY3RvcjtcbiAgY29uc3Qgb3V0ZXJTdGFydCA9IHsgeDogb3V0ZXJSYWRpdXMgKiBNYXRoLmNvcyhzdGFydEFuZ2xlKSwgeTogb3V0ZXJSYWRpdXMgKiBNYXRoLnNpbihzdGFydEFuZ2xlKSB9O1xuICBjb25zdCBvdXRlckVuZCA9IHsgeDogb3V0ZXJSYWRpdXMgKiBNYXRoLmNvcyhlbmRBbmdsZSksIHk6IG91dGVyUmFkaXVzICogTWF0aC5zaW4oZW5kQW5nbGUpIH07XG4gIGNvbnN0IGlubmVyU3RhcnQgPSBpbm5lclJhZGl1cyA9PT0gMCA/IHsgeDogMCwgeTogMCB9IDogeyB4OiBpbm5lclJhZGl1cyAqIE1hdGguY29zKHN0YXJ0QW5nbGUpLCB5OiBpbm5lclJhZGl1cyAqIE1hdGguc2luKHN0YXJ0QW5nbGUpIH07XG4gIGNvbnN0IGlubmVyRW5kID0gaW5uZXJSYWRpdXMgPT09IDAgPyB7IHg6IDAsIHk6IDAgfSA6IHsgeDogaW5uZXJSYWRpdXMgKiBNYXRoLmNvcyhlbmRBbmdsZSksIHk6IGlubmVyUmFkaXVzICogTWF0aC5zaW4oZW5kQW5nbGUpIH07XG4gIHJldHVybiBzZWdtZW50SW50ZXJzZWN0aW9uKFxuICAgIGxpbmUuc3RhcnQueCxcbiAgICBsaW5lLnN0YXJ0LnksXG4gICAgbGluZS5lbmQueCxcbiAgICBsaW5lLmVuZC55LFxuICAgIG91dGVyU3RhcnQueCxcbiAgICBvdXRlclN0YXJ0LnksXG4gICAgaW5uZXJTdGFydC54LFxuICAgIGlubmVyU3RhcnQueVxuICApIHx8IHNlZ21lbnRJbnRlcnNlY3Rpb24oXG4gICAgbGluZS5zdGFydC54LFxuICAgIGxpbmUuc3RhcnQueSxcbiAgICBsaW5lLmVuZC54LFxuICAgIGxpbmUuZW5kLnksXG4gICAgb3V0ZXJFbmQueCxcbiAgICBvdXRlckVuZC55LFxuICAgIGlubmVyRW5kLngsXG4gICAgaW5uZXJFbmQueVxuICApIHx8IGFyY0ludGVyc2VjdGlvbnMoXG4gICAgMCxcbiAgICAwLFxuICAgIG91dGVyUmFkaXVzLFxuICAgIHN0YXJ0QW5nbGUsXG4gICAgZW5kQW5nbGUsXG4gICAgdHJ1ZSxcbiAgICBsaW5lLnN0YXJ0LngsXG4gICAgbGluZS5zdGFydC55LFxuICAgIGxpbmUuZW5kLngsXG4gICAgbGluZS5lbmQueVxuICApO1xufVxuZnVuY3Rpb24gYm94Q29sbGlkZXNTZWN0b3IoYm94LCBzZWN0b3IpIHtcbiAgY29uc3QgdG9wTGVmdCA9IHsgeDogYm94LngsIHk6IGJveC55IH07XG4gIGNvbnN0IHRvcFJpZ2h0ID0geyB4OiBib3gueCArIGJveC53aWR0aCwgeTogYm94LnkgfTtcbiAgY29uc3QgYm90dG9tTGVmdCA9IHsgeDogYm94LngsIHk6IGJveC55ICsgYm94LmhlaWdodCB9O1xuICBjb25zdCBib3R0b21SaWdodCA9IHsgeDogYm94LnggKyBib3gud2lkdGgsIHk6IGJveC55ICsgYm94LmhlaWdodCB9O1xuICByZXR1cm4gbGluZUNvbGxpZGVzU2VjdG9yKHsgc3RhcnQ6IHRvcExlZnQsIGVuZDogdG9wUmlnaHQgfSwgc2VjdG9yKSB8fCBsaW5lQ29sbGlkZXNTZWN0b3IoeyBzdGFydDogYm90dG9tTGVmdCwgZW5kOiBib3R0b21SaWdodCB9LCBzZWN0b3IpO1xufVxuZnVuY3Rpb24gcmFkaWlTY2FsaW5nRmFjdG9yKHIsIHN3ZWVwLCBhLCBiKSB7XG4gIGlmIChhID09PSAwICYmIGIgPT09IDApXG4gICAgcmV0dXJuIDA7XG4gIGNvbnN0IGZzMSA9IE1hdGguYXNpbihNYXRoLmFicygxICogYSkgLyAociArIDEgKiBhKSkgKyBNYXRoLmFzaW4oTWF0aC5hYnMoMSAqIGIpIC8gKHIgKyAxICogYikpIC0gc3dlZXA7XG4gIGlmIChmczEgPCAwKVxuICAgIHJldHVybiAxO1xuICBsZXQgc3RhcnQgPSAwO1xuICBsZXQgZW5kID0gMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcbiAgICBjb25zdCBzID0gKHN0YXJ0ICsgZW5kKSAvIDI7XG4gICAgY29uc3QgZnMgPSBNYXRoLmFzaW4oTWF0aC5hYnMocyAqIGEpIC8gKHIgKyBzICogYSkpICsgTWF0aC5hc2luKE1hdGguYWJzKHMgKiBiKSAvIChyICsgcyAqIGIpKSAtIHN3ZWVwO1xuICAgIGlmIChmcyA8IDApIHtcbiAgICAgIHN0YXJ0ID0gcztcbiAgICB9IGVsc2Uge1xuICAgICAgZW5kID0gcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0YXJ0O1xufVxudmFyIGRlbHRhMiA9IDFlLTY7XG5mdW5jdGlvbiBjbG9ja3dpc2VBbmdsZShhbmdsZTIsIHJlbGF0aXZlVG9TdGFydEFuZ2xlKSB7XG4gIGlmIChhbmdsZUJldHdlZW4oYW5nbGUyLCByZWxhdGl2ZVRvU3RhcnRBbmdsZSkgPCBkZWx0YTIpIHtcbiAgICByZXR1cm4gcmVsYXRpdmVUb1N0YXJ0QW5nbGU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vcm1hbGl6ZUFuZ2xlMzYwKGFuZ2xlMiAtIHJlbGF0aXZlVG9TdGFydEFuZ2xlKSArIHJlbGF0aXZlVG9TdGFydEFuZ2xlO1xuICB9XG59XG5mdW5jdGlvbiBjbG9ja3dpc2VBbmdsZXMoc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHJlbGF0aXZlVG9TdGFydEFuZ2xlID0gMCkge1xuICBjb25zdCBmdWxsUGllID0gTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSA+PSAyICogTWF0aC5QSTtcbiAgY29uc3Qgc3dlZXBBbmdsZSA9IGZ1bGxQaWUgPyAyICogTWF0aC5QSSA6IG5vcm1hbGl6ZUFuZ2xlMzYwKGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSk7XG4gIHN0YXJ0QW5nbGUgPSBjbG9ja3dpc2VBbmdsZShzdGFydEFuZ2xlLCByZWxhdGl2ZVRvU3RhcnRBbmdsZSk7XG4gIGVuZEFuZ2xlID0gc3RhcnRBbmdsZSArIHN3ZWVwQW5nbGU7XG4gIHJldHVybiB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIH07XG59XG5mdW5jdGlvbiBhcmNSYWRpYWxMaW5lSW50ZXJzZWN0aW9uQW5nbGUoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY2xpcEFuZ2xlKSB7XG4gIGNvbnN0IHNpbkEgPSBNYXRoLnNpbihjbGlwQW5nbGUpO1xuICBjb25zdCBjb3NBID0gTWF0aC5jb3MoY2xpcEFuZ2xlKTtcbiAgY29uc3QgYyA9IGN4ICoqIDIgKyBjeSAqKiAyIC0gciAqKiAyO1xuICBsZXQgcDB4ID0gTmFOO1xuICBsZXQgcDB5ID0gTmFOO1xuICBsZXQgcDF4ID0gTmFOO1xuICBsZXQgcDF5ID0gTmFOO1xuICBpZiAoY29zQSA+IDAuNSkge1xuICAgIGNvbnN0IHRhbkEgPSBzaW5BIC8gY29zQTtcbiAgICBjb25zdCBhID0gMSArIHRhbkEgKiogMjtcbiAgICBjb25zdCBiID0gLTIgKiAoY3ggKyBjeSAqIHRhbkEpO1xuICAgIGNvbnN0IGQgPSBiICoqIDIgLSA0ICogYSAqIGM7XG4gICAgaWYgKGQgPCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHgwID0gKC1iICsgTWF0aC5zcXJ0KGQpKSAvICgyICogYSk7XG4gICAgY29uc3QgeDEgPSAoLWIgLSBNYXRoLnNxcnQoZCkpIC8gKDIgKiBhKTtcbiAgICBwMHggPSB4MDtcbiAgICBwMHkgPSB4MCAqIHRhbkE7XG4gICAgcDF4ID0geDE7XG4gICAgcDF5ID0geDEgKiB0YW5BO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvdEEgPSBjb3NBIC8gc2luQTtcbiAgICBjb25zdCBhID0gMSArIGNvdEEgKiogMjtcbiAgICBjb25zdCBiID0gLTIgKiAoY3kgKyBjeCAqIGNvdEEpO1xuICAgIGNvbnN0IGQgPSBiICoqIDIgLSA0ICogYSAqIGM7XG4gICAgaWYgKGQgPCAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHkwID0gKC1iICsgTWF0aC5zcXJ0KGQpKSAvICgyICogYSk7XG4gICAgY29uc3QgeTEgPSAoLWIgLSBNYXRoLnNxcnQoZCkpIC8gKDIgKiBhKTtcbiAgICBwMHggPSB5MCAqIGNvdEE7XG4gICAgcDB5ID0geTA7XG4gICAgcDF4ID0geTEgKiBjb3RBO1xuICAgIHAxeSA9IHkxO1xuICB9XG4gIGNvbnN0IG5vcm1hbGlzZWRYID0gY29zQTtcbiAgY29uc3Qgbm9ybWFsaXNlZFkgPSBzaW5BO1xuICBjb25zdCBwMERvdE5vcm1hbGl6ZWQgPSBwMHggKiBub3JtYWxpc2VkWCArIHAweSAqIG5vcm1hbGlzZWRZO1xuICBjb25zdCBwMURvdE5vcm1hbGl6ZWQgPSBwMXggKiBub3JtYWxpc2VkWCArIHAxeSAqIG5vcm1hbGlzZWRZO1xuICBjb25zdCBhMCA9IHAwRG90Tm9ybWFsaXplZCA+IDAgPyBjbG9ja3dpc2VBbmdsZShNYXRoLmF0YW4yKHAweSAtIGN5LCBwMHggLSBjeCksIHN0YXJ0QW5nbGUpIDogTmFOO1xuICBjb25zdCBhMSA9IHAxRG90Tm9ybWFsaXplZCA+IDAgPyBjbG9ja3dpc2VBbmdsZShNYXRoLmF0YW4yKHAxeSAtIGN5LCBwMXggLSBjeCksIHN0YXJ0QW5nbGUpIDogTmFOO1xuICBpZiAoYTAgPj0gc3RhcnRBbmdsZSAmJiBhMCA8PSBlbmRBbmdsZSkge1xuICAgIHJldHVybiBhMDtcbiAgfSBlbHNlIGlmIChhMSA+PSBzdGFydEFuZ2xlICYmIGExIDw9IGVuZEFuZ2xlKSB7XG4gICAgcmV0dXJuIGExO1xuICB9XG59XG5mdW5jdGlvbiBhcmNDaXJjbGVJbnRlcnNlY3Rpb25BbmdsZShjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBjaXJjbGVSKSB7XG4gIGNvbnN0IGQgPSBNYXRoLmh5cG90KGN4LCBjeSk7XG4gIGNvbnN0IGQxID0gKGQgKiogMiAtIHIgKiogMiArIGNpcmNsZVIgKiogMikgLyAoMiAqIGQpO1xuICBjb25zdCBkMiA9IGQgLSBkMTtcbiAgY29uc3QgdGhldGEgPSBNYXRoLmF0YW4yKGN5LCBjeCk7XG4gIGNvbnN0IGRlbHRhVGhldGEgPSBNYXRoLmFjb3MoLWQyIC8gcik7XG4gIGNvbnN0IGEwID0gY2xvY2t3aXNlQW5nbGUodGhldGEgKyBkZWx0YVRoZXRhLCBzdGFydEFuZ2xlKTtcbiAgY29uc3QgYTEgPSBjbG9ja3dpc2VBbmdsZSh0aGV0YSAtIGRlbHRhVGhldGEsIHN0YXJ0QW5nbGUpO1xuICBpZiAoYTAgPj0gc3RhcnRBbmdsZSAmJiBhMCA8PSBlbmRBbmdsZSkge1xuICAgIHJldHVybiBhMDtcbiAgfSBlbHNlIGlmIChhMSA+PSBzdGFydEFuZ2xlICYmIGExIDw9IGVuZEFuZ2xlKSB7XG4gICAgcmV0dXJuIGExO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NoYXBlL3NlY3Rvci50c1xudmFyIEFyYyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY3gsIGN5LCByLCBhMCwgYTEpIHtcbiAgICB0aGlzLmN4ID0gY3g7XG4gICAgdGhpcy5jeSA9IGN5O1xuICAgIHRoaXMuciA9IHI7XG4gICAgdGhpcy5hMCA9IGEwO1xuICAgIHRoaXMuYTEgPSBhMTtcbiAgICBpZiAodGhpcy5hMCA+PSB0aGlzLmExKSB7XG4gICAgICB0aGlzLmEwID0gTmFOO1xuICAgICAgdGhpcy5hMSA9IE5hTjtcbiAgICB9XG4gIH1cbiAgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHRoaXMuYTApICYmIE51bWJlci5pc0Zpbml0ZSh0aGlzLmExKTtcbiAgfVxuICBwb2ludEF0KGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdGhpcy5jeCArIHRoaXMuciAqIE1hdGguY29zKGEpLFxuICAgICAgeTogdGhpcy5jeSArIHRoaXMuciAqIE1hdGguc2luKGEpXG4gICAgfTtcbiAgfVxuICBjbGlwU3RhcnQoYSkge1xuICAgIGlmIChhID09IG51bGwgfHwgIXRoaXMuaXNWYWxpZCgpIHx8IGEgPCB0aGlzLmEwKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuYTAgPSBhO1xuICAgIGlmIChOdW1iZXIuaXNOYU4oYSkgfHwgdGhpcy5hMCA+PSB0aGlzLmExKSB7XG4gICAgICB0aGlzLmEwID0gTmFOO1xuICAgICAgdGhpcy5hMSA9IE5hTjtcbiAgICB9XG4gIH1cbiAgY2xpcEVuZChhKSB7XG4gICAgaWYgKGEgPT0gbnVsbCB8fCAhdGhpcy5pc1ZhbGlkKCkgfHwgYSA+IHRoaXMuYTEpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5hMSA9IGE7XG4gICAgaWYgKE51bWJlci5pc05hTihhKSB8fCB0aGlzLmEwID49IHRoaXMuYTEpIHtcbiAgICAgIHRoaXMuYTAgPSBOYU47XG4gICAgICB0aGlzLmExID0gTmFOO1xuICAgIH1cbiAgfVxufTtcbnZhciBTZWN0b3IgPSBjbGFzcyBleHRlbmRzIFBhdGgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuY2VudGVyWCA9IDA7XG4gICAgdGhpcy5jZW50ZXJZID0gMDtcbiAgICB0aGlzLmlubmVyUmFkaXVzID0gMTA7XG4gICAgdGhpcy5vdXRlclJhZGl1cyA9IDIwO1xuICAgIHRoaXMuc3RhcnRBbmdsZSA9IDA7XG4gICAgdGhpcy5lbmRBbmdsZSA9IE1hdGguUEkgKiAyO1xuICAgIHRoaXMuY2xpcFNlY3RvciA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmNlbnRyaWNFZGdlSW5zZXQgPSAwO1xuICAgIHRoaXMucmFkaWFsRWRnZUluc2V0ID0gMDtcbiAgICB0aGlzLnN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMuZW5kT3V0ZXJDb3JuZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMuc3RhcnRJbm5lckNvcm5lclJhZGl1cyA9IDA7XG4gICAgdGhpcy5lbmRJbm5lckNvcm5lclJhZGl1cyA9IDA7XG4gIH1cbiAgc2V0IGluc2V0KHZhbHVlKSB7XG4gICAgdGhpcy5jb25jZW50cmljRWRnZUluc2V0ID0gdmFsdWU7XG4gICAgdGhpcy5yYWRpYWxFZGdlSW5zZXQgPSB2YWx1ZTtcbiAgfVxuICBzZXQgY29ybmVyUmFkaXVzKHZhbHVlKSB7XG4gICAgdGhpcy5zdGFydE91dGVyQ29ybmVyUmFkaXVzID0gdmFsdWU7XG4gICAgdGhpcy5lbmRPdXRlckNvcm5lclJhZGl1cyA9IHZhbHVlO1xuICAgIHRoaXMuc3RhcnRJbm5lckNvcm5lclJhZGl1cyA9IHZhbHVlO1xuICAgIHRoaXMuZW5kSW5uZXJDb3JuZXJSYWRpdXMgPSB2YWx1ZTtcbiAgfVxuICBjb21wdXRlQkJveCgpIHtcbiAgICByZXR1cm4gc2VjdG9yQm94KHRoaXMpLnRyYW5zbGF0ZSh0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSk7XG4gIH1cbiAgbm9ybWFsaXplZFJhZGlpKCkge1xuICAgIGNvbnN0IHsgY29uY2VudHJpY0VkZ2VJbnNldCB9ID0gdGhpcztcbiAgICBsZXQgeyBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSA9IHRoaXM7XG4gICAgaW5uZXJSYWRpdXMgPSBpbm5lclJhZGl1cyA+IDAgPyBpbm5lclJhZGl1cyArIGNvbmNlbnRyaWNFZGdlSW5zZXQgOiAwO1xuICAgIG91dGVyUmFkaXVzID0gTWF0aC5tYXgob3V0ZXJSYWRpdXMgLSBjb25jZW50cmljRWRnZUluc2V0LCAwKTtcbiAgICByZXR1cm4geyBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfTtcbiAgfVxuICBub3JtYWxpemVkQ2xpcFNlY3RvcigpIHtcbiAgICBjb25zdCB7IGNsaXBTZWN0b3IgfSA9IHRoaXM7XG4gICAgaWYgKGNsaXBTZWN0b3IgPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIH0gPSBjbG9ja3dpc2VBbmdsZXModGhpcy5zdGFydEFuZ2xlLCB0aGlzLmVuZEFuZ2xlKTtcbiAgICBjb25zdCB7IGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gdGhpcy5ub3JtYWxpemVkUmFkaWkoKTtcbiAgICBjb25zdCBjbGlwQW5nbGVzID0gY2xvY2t3aXNlQW5nbGVzKGNsaXBTZWN0b3Iuc3RhcnRBbmdsZSwgY2xpcFNlY3Rvci5lbmRBbmdsZSwgc3RhcnRBbmdsZSk7XG4gICAgcmV0dXJuIG5ldyBTZWN0b3JCb3goXG4gICAgICBNYXRoLm1heChzdGFydEFuZ2xlLCBjbGlwQW5nbGVzLnN0YXJ0QW5nbGUpLFxuICAgICAgTWF0aC5taW4oZW5kQW5nbGUsIGNsaXBBbmdsZXMuZW5kQW5nbGUpLFxuICAgICAgTWF0aC5tYXgoaW5uZXJSYWRpdXMsIGNsaXBTZWN0b3IuaW5uZXJSYWRpdXMpLFxuICAgICAgTWF0aC5taW4ob3V0ZXJSYWRpdXMsIGNsaXBTZWN0b3Iub3V0ZXJSYWRpdXMpXG4gICAgKTtcbiAgfVxuICBnZXRBbmdsZU9mZnNldChyYWRpdXMpIHtcbiAgICByZXR1cm4gcmFkaXVzID4gMCA/IHRoaXMucmFkaWFsRWRnZUluc2V0IC8gcmFkaXVzIDogMDtcbiAgfVxuICBhcmMociwgYW5nbGVTd2VlcCwgYTAsIGExLCBvdXRlckFyYywgaW5uZXJBcmMsIHN0YXJ0LCBpbm5lcikge1xuICAgIGlmIChyIDw9IDApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBzdGFydEFuZ2xlLCBlbmRBbmdsZSB9ID0gY2xvY2t3aXNlQW5nbGVzKHRoaXMuc3RhcnRBbmdsZSwgdGhpcy5lbmRBbmdsZSk7XG4gICAgY29uc3QgeyBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSA9IHRoaXMubm9ybWFsaXplZFJhZGlpKCk7XG4gICAgY29uc3QgY2xpcFNlY3RvciA9IHRoaXMubm9ybWFsaXplZENsaXBTZWN0b3IoKTtcbiAgICBpZiAoaW5uZXIgJiYgaW5uZXJSYWRpdXMgPD0gMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpbm5lckFuZ2xlT2Zmc2V0ID0gdGhpcy5nZXRBbmdsZU9mZnNldChpbm5lclJhZGl1cyk7XG4gICAgY29uc3Qgb3V0ZXJBbmdsZU9mZnNldCA9IHRoaXMuZ2V0QW5nbGVPZmZzZXQob3V0ZXJSYWRpdXMpO1xuICAgIGNvbnN0IGFuZ2xlT2Zmc2V0ID0gaW5uZXIgPyB0aGlzLmdldEFuZ2xlT2Zmc2V0KGlubmVyUmFkaXVzICsgcikgOiB0aGlzLmdldEFuZ2xlT2Zmc2V0KG91dGVyUmFkaXVzIC0gcik7XG4gICAgY29uc3QgYW5nbGUyID0gc3RhcnQgPyBzdGFydEFuZ2xlICsgYW5nbGVPZmZzZXQgKyBhbmdsZVN3ZWVwIDogZW5kQW5nbGUgLSBhbmdsZU9mZnNldCAtIGFuZ2xlU3dlZXA7XG4gICAgY29uc3QgcmFkaXVzID0gaW5uZXIgPyBpbm5lclJhZGl1cyArIHIgOiBvdXRlclJhZGl1cyAtIHI7XG4gICAgY29uc3QgY3ggPSByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZTIpO1xuICAgIGNvbnN0IGN5ID0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUyKTtcbiAgICBpZiAoY2xpcFNlY3RvciAhPSBudWxsKSB7XG4gICAgICBjb25zdCBkZWx0YTMgPSAxZS02O1xuICAgICAgaWYgKCFzdGFydCAmJiAhKGFuZ2xlMiA+PSBzdGFydEFuZ2xlIC0gZGVsdGEzICYmIGFuZ2xlMiA8PSBjbGlwU2VjdG9yLmVuZEFuZ2xlIC0gZGVsdGEzKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHN0YXJ0ICYmICEoYW5nbGUyID49IGNsaXBTZWN0b3Iuc3RhcnRBbmdsZSArIGRlbHRhMyAmJiBhbmdsZTIgPD0gZW5kQW5nbGUgLSBkZWx0YTMpKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoaW5uZXIgJiYgIShyYWRpdXMgPj0gY2xpcFNlY3Rvci5pbm5lclJhZGl1cyAtIGRlbHRhMykpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICghaW5uZXIgJiYgIShyYWRpdXMgPD0gY2xpcFNlY3Rvci5vdXRlclJhZGl1cyArIGRlbHRhMykpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXJjID0gbmV3IEFyYyhjeCwgY3ksIHIsIGEwLCBhMSk7XG4gICAgaWYgKGNsaXBTZWN0b3IgIT0gbnVsbCkge1xuICAgICAgaWYgKGlubmVyKSB7XG4gICAgICAgIGFyYy5jbGlwU3RhcnQoXG4gICAgICAgICAgYXJjUmFkaWFsTGluZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLmVuZEFuZ2xlIC0gaW5uZXJBbmdsZU9mZnNldClcbiAgICAgICAgKTtcbiAgICAgICAgYXJjLmNsaXBFbmQoXG4gICAgICAgICAgYXJjUmFkaWFsTGluZUludGVyc2VjdGlvbkFuZ2xlKGN4LCBjeSwgciwgYTAsIGExLCBjbGlwU2VjdG9yLnN0YXJ0QW5nbGUgKyBpbm5lckFuZ2xlT2Zmc2V0KVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJjLmNsaXBTdGFydChcbiAgICAgICAgICBhcmNSYWRpYWxMaW5lSW50ZXJzZWN0aW9uQW5nbGUoY3gsIGN5LCByLCBhMCwgYTEsIGNsaXBTZWN0b3Iuc3RhcnRBbmdsZSArIG91dGVyQW5nbGVPZmZzZXQpXG4gICAgICAgICk7XG4gICAgICAgIGFyYy5jbGlwRW5kKGFyY1JhZGlhbExpbmVJbnRlcnNlY3Rpb25BbmdsZShjeCwgY3ksIHIsIGEwLCBhMSwgY2xpcFNlY3Rvci5lbmRBbmdsZSAtIG91dGVyQW5nbGVPZmZzZXQpKTtcbiAgICAgIH1cbiAgICAgIGxldCBjaXJjbGVDbGlwU3RhcnQ7XG4gICAgICBsZXQgY2lyY2xlQ2xpcEVuZDtcbiAgICAgIGlmIChzdGFydCkge1xuICAgICAgICBjaXJjbGVDbGlwU3RhcnQgPSBhcmNDaXJjbGVJbnRlcnNlY3Rpb25BbmdsZShjeCwgY3ksIHIsIGEwLCBhMSwgY2xpcFNlY3Rvci5pbm5lclJhZGl1cyk7XG4gICAgICAgIGNpcmNsZUNsaXBFbmQgPSBhcmNDaXJjbGVJbnRlcnNlY3Rpb25BbmdsZShjeCwgY3ksIHIsIGEwLCBhMSwgY2xpcFNlY3Rvci5vdXRlclJhZGl1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaXJjbGVDbGlwU3RhcnQgPSBhcmNDaXJjbGVJbnRlcnNlY3Rpb25BbmdsZShjeCwgY3ksIHIsIGEwLCBhMSwgY2xpcFNlY3Rvci5vdXRlclJhZGl1cyk7XG4gICAgICAgIGNpcmNsZUNsaXBFbmQgPSBhcmNDaXJjbGVJbnRlcnNlY3Rpb25BbmdsZShjeCwgY3ksIHIsIGEwLCBhMSwgY2xpcFNlY3Rvci5pbm5lclJhZGl1cyk7XG4gICAgICB9XG4gICAgICBhcmMuY2xpcFN0YXJ0KGNpcmNsZUNsaXBTdGFydCk7XG4gICAgICBhcmMuY2xpcEVuZChjaXJjbGVDbGlwRW5kKTtcbiAgICAgIGlmIChjaXJjbGVDbGlwU3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gYXJjLnBvaW50QXQoY2lyY2xlQ2xpcFN0YXJ0KTtcbiAgICAgICAgY29uc3QgdGhldGEyID0gY2xvY2t3aXNlQW5nbGUoTWF0aC5hdGFuMih5MiwgeDIpLCBzdGFydEFuZ2xlKTtcbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgaW5uZXJBcmM/LmNsaXBTdGFydCh0aGV0YTIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dGVyQXJjLmNsaXBFbmQodGhldGEyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNpcmNsZUNsaXBFbmQgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCB7IHg6IHgyLCB5OiB5MiB9ID0gYXJjLnBvaW50QXQoY2lyY2xlQ2xpcEVuZCk7XG4gICAgICAgIGNvbnN0IHRoZXRhMiA9IGNsb2Nrd2lzZUFuZ2xlKE1hdGguYXRhbjIoeTIsIHgyKSwgc3RhcnRBbmdsZSk7XG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgIG91dGVyQXJjLmNsaXBTdGFydCh0aGV0YTIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlubmVyQXJjPy5jbGlwRW5kKHRoZXRhMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNsaXBTZWN0b3IgIT0gbnVsbCkge1xuICAgICAgY29uc3QgeyB4OiB4MiwgeTogeTIgfSA9IGFyYy5wb2ludEF0KChhcmMuYTAgKyBhcmMuYTEpIC8gMik7XG4gICAgICBpZiAoIWlzUG9pbnRJblNlY3Rvcih4MiwgeTIsIGNsaXBTZWN0b3IpKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgeCwgeSB9ID0gYXJjLnBvaW50QXQoc3RhcnQgPT09IGlubmVyID8gYXJjLmEwIDogYXJjLmExKTtcbiAgICBjb25zdCB0aGV0YSA9IGNsb2Nrd2lzZUFuZ2xlKE1hdGguYXRhbjIoeSwgeCksIHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IHJhZGlhbEFyYyA9IGlubmVyID8gaW5uZXJBcmMgOiBvdXRlckFyYztcbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHJhZGlhbEFyYz8uY2xpcFN0YXJ0KHRoZXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFkaWFsQXJjPy5jbGlwRW5kKHRoZXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyYztcbiAgfVxuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IGRlbHRhMyA9IDFlLTY7XG4gICAgY29uc3QgeyBwYXRoLCBjZW50ZXJYLCBjZW50ZXJZLCBjb25jZW50cmljRWRnZUluc2V0LCByYWRpYWxFZGdlSW5zZXQgfSA9IHRoaXM7XG4gICAgbGV0IHsgc3RhcnRPdXRlckNvcm5lclJhZGl1cywgZW5kT3V0ZXJDb3JuZXJSYWRpdXMsIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMsIGVuZElubmVyQ29ybmVyUmFkaXVzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUgfSA9IGNsb2Nrd2lzZUFuZ2xlcyh0aGlzLnN0YXJ0QW5nbGUsIHRoaXMuZW5kQW5nbGUpO1xuICAgIGNvbnN0IHsgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH0gPSB0aGlzLm5vcm1hbGl6ZWRSYWRpaSgpO1xuICAgIGNvbnN0IGNsaXBTZWN0b3IgPSB0aGlzLm5vcm1hbGl6ZWRDbGlwU2VjdG9yKCk7XG4gICAgY29uc3Qgc3dlZXBBbmdsZSA9IGVuZEFuZ2xlIC0gc3RhcnRBbmdsZTtcbiAgICBjb25zdCBmdWxsUGllID0gc3dlZXBBbmdsZSA+PSAyICogTWF0aC5QSSAtIGRlbHRhMztcbiAgICBwYXRoLmNsZWFyKCk7XG4gICAgaWYgKGlubmVyUmFkaXVzID09PSAwICYmIG91dGVyUmFkaXVzID09PSAwIHx8IGlubmVyUmFkaXVzID4gb3V0ZXJSYWRpdXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKChjbGlwU2VjdG9yPy5zdGFydEFuZ2xlID8/IHN0YXJ0QW5nbGUpID09PSAoY2xpcFNlY3Rvcj8uZW5kQW5nbGUgPz8gZW5kQW5nbGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChmdWxsUGllICYmIHRoaXMuY2xpcFNlY3RvciA9PSBudWxsICYmIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMgPT09IDAgJiYgZW5kT3V0ZXJDb3JuZXJSYWRpdXMgPT09IDAgJiYgc3RhcnRJbm5lckNvcm5lclJhZGl1cyA9PT0gMCAmJiBlbmRJbm5lckNvcm5lclJhZGl1cyA9PT0gMCkge1xuICAgICAgcGF0aC5tb3ZlVG8oY2VudGVyWCArIG91dGVyUmFkaXVzICogTWF0aC5jb3Moc3RhcnRBbmdsZSksIGNlbnRlclkgKyBvdXRlclJhZGl1cyAqIE1hdGguc2luKHN0YXJ0QW5nbGUpKTtcbiAgICAgIHBhdGguYXJjKGNlbnRlclgsIGNlbnRlclksIG91dGVyUmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSk7XG4gICAgICBpZiAoaW5uZXJSYWRpdXMgPiBjb25jZW50cmljRWRnZUluc2V0KSB7XG4gICAgICAgIHBhdGgubW92ZVRvKGNlbnRlclggKyBpbm5lclJhZGl1cyAqIE1hdGguY29zKGVuZEFuZ2xlKSwgY2VudGVyWSArIGlubmVyUmFkaXVzICogTWF0aC5zaW4oZW5kQW5nbGUpKTtcbiAgICAgICAgcGF0aC5hcmMoY2VudGVyWCwgY2VudGVyWSwgaW5uZXJSYWRpdXMsIGVuZEFuZ2xlLCBzdGFydEFuZ2xlLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh0aGlzLmNsaXBTZWN0b3IgPT0gbnVsbCAmJiBNYXRoLmFicyhpbm5lclJhZGl1cyAtIG91dGVyUmFkaXVzKSA8IDFlLTYpIHtcbiAgICAgIHBhdGguYXJjKGNlbnRlclgsIGNlbnRlclksIG91dGVyUmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgZmFsc2UpO1xuICAgICAgcGF0aC5hcmMoY2VudGVyWCwgY2VudGVyWSwgb3V0ZXJSYWRpdXMsIGVuZEFuZ2xlLCBzdGFydEFuZ2xlLCB0cnVlKTtcbiAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlubmVyQW5nbGVPZmZzZXQgPSB0aGlzLmdldEFuZ2xlT2Zmc2V0KGlubmVyUmFkaXVzKTtcbiAgICBjb25zdCBvdXRlckFuZ2xlT2Zmc2V0ID0gdGhpcy5nZXRBbmdsZU9mZnNldChvdXRlclJhZGl1cyk7XG4gICAgY29uc3Qgb3V0ZXJBbmdsZUV4Y2VlZGVkID0gc3dlZXBBbmdsZSA8IDIgKiBvdXRlckFuZ2xlT2Zmc2V0O1xuICAgIGlmIChvdXRlckFuZ2xlRXhjZWVkZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaGFzSW5uZXJTd2VlcCA9IChjbGlwU2VjdG9yPy5pbm5lclJhZGl1cyA/PyBpbm5lclJhZGl1cykgPiBjb25jZW50cmljRWRnZUluc2V0O1xuICAgIGNvbnN0IGlubmVyQW5nbGVFeGNlZWRlZCA9IGlubmVyUmFkaXVzIDwgY29uY2VudHJpY0VkZ2VJbnNldCB8fCBzd2VlcEFuZ2xlIDwgMiAqIGlubmVyQW5nbGVPZmZzZXQ7XG4gICAgY29uc3QgcmFkaWFsTGVuZ3RoID0gb3V0ZXJSYWRpdXMgLSBpbm5lclJhZGl1cztcbiAgICBjb25zdCBtYXhSYWRpYWxMZW5ndGggPSBNYXRoLm1heChcbiAgICAgIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMsXG4gICAgICBzdGFydElubmVyQ29ybmVyUmFkaXVzLFxuICAgICAgZW5kT3V0ZXJDb3JuZXJSYWRpdXMsXG4gICAgICBlbmRJbm5lckNvcm5lclJhZGl1c1xuICAgICk7XG4gICAgY29uc3QgaW5pdGlhbFNjYWxpbmdGYWN0b3IgPSBtYXhSYWRpYWxMZW5ndGggPiAwID8gTWF0aC5taW4ocmFkaWFsTGVuZ3RoIC8gbWF4UmFkaWFsTGVuZ3RoLCAxKSA6IDE7XG4gICAgc3RhcnRPdXRlckNvcm5lclJhZGl1cyAqPSBpbml0aWFsU2NhbGluZ0ZhY3RvcjtcbiAgICBlbmRPdXRlckNvcm5lclJhZGl1cyAqPSBpbml0aWFsU2NhbGluZ0ZhY3RvcjtcbiAgICBzdGFydElubmVyQ29ybmVyUmFkaXVzICo9IGluaXRpYWxTY2FsaW5nRmFjdG9yO1xuICAgIGVuZElubmVyQ29ybmVyUmFkaXVzICo9IGluaXRpYWxTY2FsaW5nRmFjdG9yO1xuICAgIGNvbnN0IG91dGVyU2NhbGluZ0ZhY3RvciA9IHJhZGlpU2NhbGluZ0ZhY3RvcihcbiAgICAgIG91dGVyUmFkaXVzLFxuICAgICAgc3dlZXBBbmdsZSAtIDIgKiBvdXRlckFuZ2xlT2Zmc2V0LFxuICAgICAgLXN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMsXG4gICAgICAtZW5kT3V0ZXJDb3JuZXJSYWRpdXNcbiAgICApO1xuICAgIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMgKj0gb3V0ZXJTY2FsaW5nRmFjdG9yO1xuICAgIGVuZE91dGVyQ29ybmVyUmFkaXVzICo9IG91dGVyU2NhbGluZ0ZhY3RvcjtcbiAgICBpZiAoIWlubmVyQW5nbGVFeGNlZWRlZCAmJiBoYXNJbm5lclN3ZWVwKSB7XG4gICAgICBjb25zdCBpbm5lclNjYWxpbmdGYWN0b3IgPSByYWRpaVNjYWxpbmdGYWN0b3IoXG4gICAgICAgIGlubmVyUmFkaXVzLFxuICAgICAgICBzd2VlcEFuZ2xlIC0gMiAqIGlubmVyQW5nbGVPZmZzZXQsXG4gICAgICAgIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMsXG4gICAgICAgIGVuZElubmVyQ29ybmVyUmFkaXVzXG4gICAgICApO1xuICAgICAgc3RhcnRJbm5lckNvcm5lclJhZGl1cyAqPSBpbm5lclNjYWxpbmdGYWN0b3I7XG4gICAgICBlbmRJbm5lckNvcm5lclJhZGl1cyAqPSBpbm5lclNjYWxpbmdGYWN0b3I7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMgPSAwO1xuICAgICAgZW5kSW5uZXJDb3JuZXJSYWRpdXMgPSAwO1xuICAgIH1cbiAgICBjb25zdCBtYXhDb21iaW5lZFJhZGlhbExlbmd0aCA9IE1hdGgubWF4KFxuICAgICAgc3RhcnRPdXRlckNvcm5lclJhZGl1cyArIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXMsXG4gICAgICBlbmRPdXRlckNvcm5lclJhZGl1cyArIGVuZElubmVyQ29ybmVyUmFkaXVzXG4gICAgKTtcbiAgICBjb25zdCBlZGdlc1NjYWxpbmdGYWN0b3IgPSBtYXhDb21iaW5lZFJhZGlhbExlbmd0aCA+IDAgPyBNYXRoLm1pbihyYWRpYWxMZW5ndGggLyBtYXhDb21iaW5lZFJhZGlhbExlbmd0aCwgMSkgOiAxO1xuICAgIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMgKj0gZWRnZXNTY2FsaW5nRmFjdG9yO1xuICAgIGVuZE91dGVyQ29ybmVyUmFkaXVzICo9IGVkZ2VzU2NhbGluZ0ZhY3RvcjtcbiAgICBzdGFydElubmVyQ29ybmVyUmFkaXVzICo9IGVkZ2VzU2NhbGluZ0ZhY3RvcjtcbiAgICBlbmRJbm5lckNvcm5lclJhZGl1cyAqPSBlZGdlc1NjYWxpbmdGYWN0b3I7XG4gICAgbGV0IHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwID0gMDtcbiAgICBsZXQgZW5kT3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwID0gMDtcbiAgICBjb25zdCBzdGFydE91dGVyQ29ybmVyUmFkaXVzU3dlZXAgPSBzdGFydE91dGVyQ29ybmVyUmFkaXVzIC8gKG91dGVyUmFkaXVzIC0gc3RhcnRPdXRlckNvcm5lclJhZGl1cyk7XG4gICAgY29uc3QgZW5kT3V0ZXJDb3JuZXJSYWRpdXNTd2VlcCA9IGVuZE91dGVyQ29ybmVyUmFkaXVzIC8gKG91dGVyUmFkaXVzIC0gZW5kT3V0ZXJDb3JuZXJSYWRpdXMpO1xuICAgIGlmIChzdGFydE91dGVyQ29ybmVyUmFkaXVzU3dlZXAgPj0gMCAmJiBzdGFydE91dGVyQ29ybmVyUmFkaXVzU3dlZXAgPCAxIC0gZGVsdGEzKSB7XG4gICAgICBzdGFydE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCA9IE1hdGguYXNpbihzdGFydE91dGVyQ29ybmVyUmFkaXVzU3dlZXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCA9IHN3ZWVwQW5nbGUgLyAyO1xuICAgICAgY29uc3QgbWF4U3RhcnRPdXRlckNvcm5lclJhZGl1cyA9IG91dGVyUmFkaXVzIC8gKDEgLyBNYXRoLnNpbihzdGFydE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCkgKyAxKTtcbiAgICAgIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXMgPSBNYXRoLm1pbihtYXhTdGFydE91dGVyQ29ybmVyUmFkaXVzLCBzdGFydE91dGVyQ29ybmVyUmFkaXVzKTtcbiAgICB9XG4gICAgaWYgKGVuZE91dGVyQ29ybmVyUmFkaXVzU3dlZXAgPj0gMCAmJiBlbmRPdXRlckNvcm5lclJhZGl1c1N3ZWVwIDwgMSAtIGRlbHRhMykge1xuICAgICAgZW5kT3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwID0gTWF0aC5hc2luKGVuZE91dGVyQ29ybmVyUmFkaXVzU3dlZXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAgPSBzd2VlcEFuZ2xlIC8gMjtcbiAgICAgIGNvbnN0IG1heEVuZE91dGVyQ29ybmVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgLyAoMSAvIE1hdGguc2luKGVuZE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCkgKyAxKTtcbiAgICAgIGVuZE91dGVyQ29ybmVyUmFkaXVzID0gTWF0aC5taW4obWF4RW5kT3V0ZXJDb3JuZXJSYWRpdXMsIGVuZE91dGVyQ29ybmVyUmFkaXVzKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRJbm5lckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAgPSBNYXRoLmFzaW4oXG4gICAgICBzdGFydElubmVyQ29ybmVyUmFkaXVzIC8gKGlubmVyUmFkaXVzICsgc3RhcnRJbm5lckNvcm5lclJhZGl1cylcbiAgICApO1xuICAgIGNvbnN0IGVuZElubmVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCA9IE1hdGguYXNpbihlbmRJbm5lckNvcm5lclJhZGl1cyAvIChpbm5lclJhZGl1cyArIGVuZElubmVyQ29ybmVyUmFkaXVzKSk7XG4gICAgY29uc3Qgb3V0ZXJBcmNSYWRpdXMgPSBjbGlwU2VjdG9yPy5vdXRlclJhZGl1cyA/PyBvdXRlclJhZGl1cztcbiAgICBjb25zdCBvdXRlckFyY1JhZGl1c09mZnNldCA9IHRoaXMuZ2V0QW5nbGVPZmZzZXQob3V0ZXJBcmNSYWRpdXMpO1xuICAgIGNvbnN0IG91dGVyQXJjID0gbmV3IEFyYyhcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgb3V0ZXJBcmNSYWRpdXMsXG4gICAgICBzdGFydEFuZ2xlICsgb3V0ZXJBcmNSYWRpdXNPZmZzZXQsXG4gICAgICBlbmRBbmdsZSAtIG91dGVyQXJjUmFkaXVzT2Zmc2V0XG4gICAgKTtcbiAgICBjb25zdCBpbm5lckFyY1JhZGl1cyA9IGNsaXBTZWN0b3I/LmlubmVyUmFkaXVzID8/IGlubmVyUmFkaXVzO1xuICAgIGNvbnN0IGlubmVyQXJjUmFkaXVzT2Zmc2V0ID0gdGhpcy5nZXRBbmdsZU9mZnNldChpbm5lckFyY1JhZGl1cyk7XG4gICAgY29uc3QgaW5uZXJBcmMgPSBoYXNJbm5lclN3ZWVwID8gbmV3IEFyYygwLCAwLCBpbm5lckFyY1JhZGl1cywgc3RhcnRBbmdsZSArIGlubmVyQXJjUmFkaXVzT2Zmc2V0LCBlbmRBbmdsZSAtIGlubmVyQXJjUmFkaXVzT2Zmc2V0KSA6IHZvaWQgMDtcbiAgICBpZiAoY2xpcFNlY3RvciAhPSBudWxsKSB7XG4gICAgICBvdXRlckFyYy5jbGlwU3RhcnQoY2xpcFNlY3Rvci5zdGFydEFuZ2xlKTtcbiAgICAgIG91dGVyQXJjLmNsaXBFbmQoY2xpcFNlY3Rvci5lbmRBbmdsZSk7XG4gICAgICBpbm5lckFyYz8uY2xpcFN0YXJ0KGNsaXBTZWN0b3Iuc3RhcnRBbmdsZSk7XG4gICAgICBpbm5lckFyYz8uY2xpcEVuZChjbGlwU2VjdG9yLmVuZEFuZ2xlKTtcbiAgICB9XG4gICAgY29uc3Qgc3RhcnRPdXRlckFyYyA9IHRoaXMuYXJjKFxuICAgICAgc3RhcnRPdXRlckNvcm5lclJhZGl1cyxcbiAgICAgIHN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwLFxuICAgICAgc3RhcnRBbmdsZSAtIE1hdGguUEkgKiAwLjUsXG4gICAgICBzdGFydEFuZ2xlICsgc3RhcnRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAsXG4gICAgICBvdXRlckFyYyxcbiAgICAgIGlubmVyQXJjLFxuICAgICAgdHJ1ZSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICBjb25zdCBlbmRPdXRlckFyYyA9IHRoaXMuYXJjKFxuICAgICAgZW5kT3V0ZXJDb3JuZXJSYWRpdXMsXG4gICAgICBlbmRPdXRlckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAsXG4gICAgICBlbmRBbmdsZSAtIGVuZE91dGVyQ29ybmVyUmFkaXVzQW5nbGVTd2VlcCxcbiAgICAgIGVuZEFuZ2xlICsgTWF0aC5QSSAqIDAuNSxcbiAgICAgIG91dGVyQXJjLFxuICAgICAgaW5uZXJBcmMsXG4gICAgICBmYWxzZSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICBjb25zdCBlbmRJbm5lckFyYyA9IHRoaXMuYXJjKFxuICAgICAgZW5kSW5uZXJDb3JuZXJSYWRpdXMsXG4gICAgICBlbmRJbm5lckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAsXG4gICAgICBlbmRBbmdsZSArIE1hdGguUEkgKiAwLjUsXG4gICAgICBlbmRBbmdsZSArIE1hdGguUEkgLSBlbmRJbm5lckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAsXG4gICAgICBvdXRlckFyYyxcbiAgICAgIGlubmVyQXJjLFxuICAgICAgZmFsc2UsXG4gICAgICB0cnVlXG4gICAgKTtcbiAgICBjb25zdCBzdGFydElubmVyQXJjID0gdGhpcy5hcmMoXG4gICAgICBzdGFydElubmVyQ29ybmVyUmFkaXVzLFxuICAgICAgc3RhcnRJbm5lckNvcm5lclJhZGl1c0FuZ2xlU3dlZXAsXG4gICAgICBzdGFydEFuZ2xlICsgTWF0aC5QSSArIHN0YXJ0SW5uZXJDb3JuZXJSYWRpdXNBbmdsZVN3ZWVwLFxuICAgICAgc3RhcnRBbmdsZSArIE1hdGguUEkgKiAxLjUsXG4gICAgICBvdXRlckFyYyxcbiAgICAgIGlubmVyQXJjLFxuICAgICAgdHJ1ZSxcbiAgICAgIHRydWVcbiAgICApO1xuICAgIGlmIChpbm5lckFuZ2xlRXhjZWVkZWQpIHtcbiAgICAgIGNvbnN0IHggPSBzd2VlcEFuZ2xlIDwgTWF0aC5QSSAqIDAuNSA/IHJhZGlhbEVkZ2VJbnNldCAqICgxICsgTWF0aC5jb3Moc3dlZXBBbmdsZSkpIC8gTWF0aC5zaW4oc3dlZXBBbmdsZSkgOiBOYU47XG4gICAgICBsZXQgcjtcbiAgICAgIGlmICh4ID4gMCAmJiB4IDwgb3V0ZXJSYWRpdXMpIHtcbiAgICAgICAgciA9IE1hdGgubWF4KE1hdGguaHlwb3QocmFkaWFsRWRnZUluc2V0LCB4KSwgaW5uZXJSYWRpdXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciA9IHJhZGlhbEVkZ2VJbnNldDtcbiAgICAgIH1cbiAgICAgIHIgPSBNYXRoLm1heChyLCBpbm5lclJhZGl1cyk7XG4gICAgICBjb25zdCBtaWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBzd2VlcEFuZ2xlICogMC41O1xuICAgICAgcGF0aC5tb3ZlVG8oY2VudGVyWCArIHIgKiBNYXRoLmNvcyhtaWRBbmdsZSksIGNlbnRlclkgKyByICogTWF0aC5zaW4obWlkQW5nbGUpKTtcbiAgICB9IGVsc2UgaWYgKHN0YXJ0SW5uZXJBcmM/LmlzVmFsaWQoKSA9PT0gdHJ1ZSB8fCBpbm5lckFyYz8uaXNWYWxpZCgpID09PSB0cnVlKSB7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1pZEFuZ2xlID0gc3RhcnRBbmdsZSArIHN3ZWVwQW5nbGUgLyAyO1xuICAgICAgY29uc3QgY3ggPSBpbm5lclJhZGl1cyAqIE1hdGguY29zKG1pZEFuZ2xlKTtcbiAgICAgIGNvbnN0IGN5ID0gaW5uZXJSYWRpdXMgKiBNYXRoLnNpbihtaWRBbmdsZSk7XG4gICAgICBwYXRoLm1vdmVUbyhjZW50ZXJYICsgY3gsIGNlbnRlclkgKyBjeSk7XG4gICAgfVxuICAgIGlmIChzdGFydE91dGVyQXJjPy5pc1ZhbGlkKCkgPT09IHRydWUpIHtcbiAgICAgIGNvbnN0IHsgY3gsIGN5LCByLCBhMCwgYTEgfSA9IHN0YXJ0T3V0ZXJBcmM7XG4gICAgICBwYXRoLmFyYyhjZW50ZXJYICsgY3gsIGNlbnRlclkgKyBjeSwgciwgYTAsIGExKTtcbiAgICB9XG4gICAgaWYgKG91dGVyQXJjLmlzVmFsaWQoKSkge1xuICAgICAgY29uc3QgeyByLCBhMCwgYTEgfSA9IG91dGVyQXJjO1xuICAgICAgcGF0aC5hcmMoY2VudGVyWCwgY2VudGVyWSwgciwgYTAsIGExKTtcbiAgICB9XG4gICAgaWYgKGVuZE91dGVyQXJjPy5pc1ZhbGlkKCkgPT09IHRydWUpIHtcbiAgICAgIGNvbnN0IHsgY3gsIGN5LCByLCBhMCwgYTEgfSA9IGVuZE91dGVyQXJjO1xuICAgICAgcGF0aC5hcmMoY2VudGVyWCArIGN4LCBjZW50ZXJZICsgY3ksIHIsIGEwLCBhMSk7XG4gICAgfVxuICAgIGlmICghaW5uZXJBbmdsZUV4Y2VlZGVkKSB7XG4gICAgICBpZiAoZW5kSW5uZXJBcmM/LmlzVmFsaWQoKSA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGN4LCBjeSwgciwgYTAsIGExIH0gPSBlbmRJbm5lckFyYztcbiAgICAgICAgcGF0aC5hcmMoY2VudGVyWCArIGN4LCBjZW50ZXJZICsgY3ksIHIsIGEwLCBhMSk7XG4gICAgICB9XG4gICAgICBpZiAoaW5uZXJBcmM/LmlzVmFsaWQoKSA9PT0gdHJ1ZSkge1xuICAgICAgICBjb25zdCB7IHIsIGEwLCBhMSB9ID0gaW5uZXJBcmM7XG4gICAgICAgIHBhdGguYXJjKGNlbnRlclgsIGNlbnRlclksIHIsIGExLCBhMCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnRJbm5lckFyYz8uaXNWYWxpZCgpID09PSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgY3gsIGN5LCByLCBhMCwgYTEgfSA9IHN0YXJ0SW5uZXJBcmM7XG4gICAgICAgIHBhdGguYXJjKGNlbnRlclggKyBjeCwgY2VudGVyWSArIGN5LCByLCBhMCwgYTEpO1xuICAgICAgfVxuICAgIH1cbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG4gIGlzUG9pbnRJblBhdGgoeCwgeSkge1xuICAgIGNvbnN0IHBvaW50ID0gdGhpcy50cmFuc2Zvcm1Qb2ludCh4LCB5KTtcbiAgICBjb25zdCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSA9IHRoaXMuY2xpcFNlY3RvciA/PyB0aGlzO1xuICAgIHJldHVybiBpc1BvaW50SW5TZWN0b3IocG9pbnQueCAtIHRoaXMuY2VudGVyWCwgcG9pbnQueSAtIHRoaXMuY2VudGVyWSwge1xuICAgICAgc3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlLFxuICAgICAgaW5uZXJSYWRpdXM6IE1hdGgubWluKGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyksXG4gICAgICBvdXRlclJhZGl1czogTWF0aC5tYXgoaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzKVxuICAgIH0pO1xuICB9XG59O1xuU2VjdG9yLmNsYXNzTmFtZSA9IFwiU2VjdG9yXCI7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJjZW50ZXJYXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwiY2VudGVyWVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcImlubmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwib3V0ZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJzdGFydEFuZ2xlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwiZW5kQW5nbGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJjbGlwU2VjdG9yXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFNlY3Rvci5wcm90b3R5cGUsIFwiY29uY2VudHJpY0VkZ2VJbnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcInJhZGlhbEVkZ2VJbnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcInN0YXJ0T3V0ZXJDb3JuZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJlbmRPdXRlckNvcm5lclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBTZWN0b3IucHJvdG90eXBlLCBcInN0YXJ0SW5uZXJDb3JuZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU2VjdG9yLnByb3RvdHlwZSwgXCJlbmRJbm5lckNvcm5lclJhZGl1c1wiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL2RlZmF1bHRDb2xvcnMudHNcbnZhciBERUZBVUxUX0ZJTExTID0ge1xuICBCTFVFOiBcIiM1MDkwZGNcIixcbiAgT1JBTkdFOiBcIiNmZmEwM2FcIixcbiAgR1JFRU46IFwiIzQ1OWQ1NVwiLFxuICBDWUFOOiBcIiMzNGJmZTFcIixcbiAgWUVMTE9XOiBcIiNlMWNjMDBcIixcbiAgVklPTEVUOiBcIiM5NjY5Y2JcIixcbiAgR1JBWTogXCIjYjViNWI1XCIsXG4gIE1BR0VOVEE6IFwiI2JkNWFhN1wiLFxuICBCUk9XTjogXCIjOGE2MjI0XCIsXG4gIFJFRDogXCIjZWY1NDUyXCJcbn07XG52YXIgREVGQVVMVF9TVFJPS0VTID0ge1xuICBCTFVFOiBcIiMyYjVjOTVcIixcbiAgT1JBTkdFOiBcIiNjYzZmMTBcIixcbiAgR1JFRU46IFwiIzFlNjUyZVwiLFxuICBDWUFOOiBcIiMxODg1OWVcIixcbiAgWUVMTE9XOiBcIiNhNjk0MDBcIixcbiAgVklPTEVUOiBcIiM2MDNjODhcIixcbiAgR1JBWTogXCIjNTc1NzU3XCIsXG4gIE1BR0VOVEE6IFwiIzdkMmY2ZFwiLFxuICBCUk9XTjogXCIjNGYzNTA4XCIsXG4gIFJFRDogXCIjYTgyNTI5XCJcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9wb2xhci9kb251dFNlcmllc1Byb3BlcnRpZXMudHNcbnZhciBEb251dFRpdGxlID0gY2xhc3MgZXh0ZW5kcyBDYXB0aW9uIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnNob3dJbkxlZ2VuZCA9IGZhbHNlO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIERvbnV0VGl0bGUucHJvdG90eXBlLCBcInNob3dJbkxlZ2VuZFwiLCAyKTtcbnZhciBEb251dElubmVyTGFiZWwgPSBjbGFzcyBleHRlbmRzIExhYmVsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnNwYWNpbmcgPSAyO1xuICB9XG4gIHNldChwcm9wZXJ0aWVzLCBfcmVzZXQpIHtcbiAgICByZXR1cm4gc3VwZXIuc2V0KHByb3BlcnRpZXMpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgRG9udXRJbm5lckxhYmVsLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKVxuXSwgRG9udXRJbm5lckxhYmVsLnByb3RvdHlwZSwgXCJzcGFjaW5nXCIsIDIpO1xudmFyIERvbnV0SW5uZXJDaXJjbGUgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmZpbGwgPSBcInRyYW5zcGFyZW50XCI7XG4gICAgdGhpcy5maWxsT3BhY2l0eSA9IDE7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkcpXG5dLCBEb251dElubmVyQ2lyY2xlLnByb3RvdHlwZSwgXCJmaWxsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBEb251dElubmVyQ2lyY2xlLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbnZhciBEb251dFNlcmllc0NhbGxvdXRMYWJlbCA9IGNsYXNzIGV4dGVuZHMgTGFiZWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMub2Zmc2V0ID0gMztcbiAgICB0aGlzLm1pbkFuZ2xlID0gMDtcbiAgICB0aGlzLm1pblNwYWNpbmcgPSA0O1xuICAgIHRoaXMubWF4Q29sbGlzaW9uT2Zmc2V0ID0gNTA7XG4gICAgdGhpcy5hdm9pZENvbGxpc2lvbnMgPSB0cnVlO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNDYWxsb3V0TGFiZWwucHJvdG90eXBlLCBcIm9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKERFR1JFRSlcbl0sIERvbnV0U2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJtaW5BbmdsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIERvbnV0U2VyaWVzQ2FsbG91dExhYmVsLnByb3RvdHlwZSwgXCJtaW5TcGFjaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNDYWxsb3V0TGFiZWwucHJvdG90eXBlLCBcIm1heENvbGxpc2lvbk9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBEb251dFNlcmllc0NhbGxvdXRMYWJlbC5wcm90b3R5cGUsIFwiYXZvaWRDb2xsaXNpb25zXCIsIDIpO1xudmFyIERvbnV0U2VyaWVzU2VjdG9yTGFiZWwgPSBjbGFzcyBleHRlbmRzIExhYmVsIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnBvc2l0aW9uT2Zmc2V0ID0gMDtcbiAgICB0aGlzLnBvc2l0aW9uUmF0aW8gPSAwLjU7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShOVU1CRVIpXG5dLCBEb251dFNlcmllc1NlY3RvckxhYmVsLnByb3RvdHlwZSwgXCJwb3NpdGlvbk9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgRG9udXRTZXJpZXNTZWN0b3JMYWJlbC5wcm90b3R5cGUsIFwicG9zaXRpb25SYXRpb1wiLCAyKTtcbnZhciBEb251dFNlcmllc0NhbGxvdXRMaW5lID0gY2xhc3MgZXh0ZW5kcyBCYXNlUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5sZW5ndGggPSAxMDtcbiAgICB0aGlzLnN0cm9rZVdpZHRoID0gMTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklOR19BUlJBWSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNDYWxsb3V0TGluZS5wcm90b3R5cGUsIFwiY29sb3JzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNDYWxsb3V0TGluZS5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNDYWxsb3V0TGluZS5wcm90b3R5cGUsIFwic3Ryb2tlV2lkdGhcIiwgMik7XG52YXIgRG9udXRTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBTZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmZpbGxzID0gT2JqZWN0LnZhbHVlcyhERUZBVUxUX0ZJTExTKTtcbiAgICB0aGlzLnN0cm9rZXMgPSBPYmplY3QudmFsdWVzKERFRkFVTFRfU1RST0tFUyk7XG4gICAgdGhpcy5maWxsT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICB0aGlzLmxpbmVEYXNoID0gWzBdO1xuICAgIHRoaXMubGluZURhc2hPZmZzZXQgPSAwO1xuICAgIHRoaXMuY29ybmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLnJvdGF0aW9uID0gMDtcbiAgICB0aGlzLm91dGVyUmFkaXVzT2Zmc2V0ID0gMDtcbiAgICB0aGlzLm91dGVyUmFkaXVzUmF0aW8gPSAxO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xuICAgIHRoaXMuc2VjdG9yU3BhY2luZyA9IDA7XG4gICAgdGhpcy5pbm5lckxhYmVscyA9IG5ldyBQcm9wZXJ0aWVzQXJyYXkoRG9udXRJbm5lckxhYmVsKTtcbiAgICB0aGlzLnRpdGxlID0gbmV3IERvbnV0VGl0bGUoKTtcbiAgICB0aGlzLmlubmVyQ2lyY2xlID0gbmV3IERvbnV0SW5uZXJDaXJjbGUoKTtcbiAgICB0aGlzLnNoYWRvdyA9IG5ldyBEcm9wU2hhZG93KCk7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWwgPSBuZXcgRG9udXRTZXJpZXNDYWxsb3V0TGFiZWwoKTtcbiAgICB0aGlzLnNlY3RvckxhYmVsID0gbmV3IERvbnV0U2VyaWVzU2VjdG9yTGFiZWwoKTtcbiAgICB0aGlzLmNhbGxvdXRMaW5lID0gbmV3IERvbnV0U2VyaWVzQ2FsbG91dExpbmUoKTtcbiAgICB0aGlzLnRvb2x0aXAgPSBuZXcgU2VyaWVzVG9vbHRpcCgpO1xuICB9XG4gIGlzVmFsaWQoKSB7XG4gICAgY29uc3Qgc3VwZXJJc1ZhbGlkID0gc3VwZXIuaXNWYWxpZCgpO1xuICAgIGlmICh0aGlzLmlubmVyUmFkaXVzUmF0aW8gPT0gbnVsbCAmJiB0aGlzLmlubmVyUmFkaXVzT2Zmc2V0ID09IG51bGwpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShcbiAgICAgICAgXCJFaXRoZXIgYW4gW2lubmVyUmFkaXVzUmF0aW9dIG9yIGFuIFtpbm5lclJhZGl1c09mZnNldF0gbXVzdCBiZSBzZXQgdG8gcmVuZGVyIGEgZG9udXQgc2VyaWVzLlwiXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXJJc1ZhbGlkO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJhbmdsZUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJhbmdsZU5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYW5nbGVGaWx0ZXJLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwicmFkaXVzS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInJhZGl1c05hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwicmFkaXVzTWluXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInJhZGl1c01heFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjYWxsb3V0TGFiZWxLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY2FsbG91dExhYmVsTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzZWN0b3JMYWJlbEtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzZWN0b3JMYWJlbE5hbWVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGVnZW5kSXRlbUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklOR19BUlJBWSlcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbHNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVkpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbE9wYWNpdHlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKExJTkVfREFTSClcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoT2Zmc2V0XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb3JuZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpdGVtU3R5bGVyXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoREVHUkVFKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwib3V0ZXJSYWRpdXNPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwib3V0ZXJSYWRpdXNSYXRpb1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpbm5lclJhZGl1c09mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImlubmVyUmFkaXVzUmF0aW9cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInN0cm9rZVdpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzZWN0b3JTcGFjaW5nXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUX0FSUkFZKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJpbm5lckxhYmVsc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwidGl0bGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImlubmVyQ2lyY2xlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaGFkb3dcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNhbGxvdXRMYWJlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIERvbnV0U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2VjdG9yTGFiZWxcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBEb251dFNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNhbGxvdXRMaW5lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgRG9udXRTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvcGllVXRpbC50c1xuZnVuY3Rpb24gcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9ucyhpbml0aWFsTG9hZCwgcm90YXRpb25EZWdyZWVzLCBzY2FsZUZuLCBvbGRTY2FsZUZuKSB7XG4gIGNvbnN0IHNjYWxlMiA9IFtzY2FsZUZuLmNvbnZlcnQoMCksIHNjYWxlRm4uY29udmVydCgxKV07XG4gIGNvbnN0IG9sZFNjYWxlID0gW29sZFNjYWxlRm4uY29udmVydCgwKSwgb2xkU2NhbGVGbi5jb252ZXJ0KDEpXTtcbiAgY29uc3Qgcm90YXRpb24gPSBNYXRoLlBJIC8gLTIgKyB0b1JhZGlhbnMocm90YXRpb25EZWdyZWVzKTtcbiAgY29uc3QgcGhhc2UgPSBpbml0aWFsTG9hZCA/IFwiaW5pdGlhbFwiIDogXCJ1cGRhdGVcIjtcbiAgY29uc3Qgc2NhbGVUb05ld1JhZGl1cyA9ICh7IHJhZGl1cyB9KSA9PiB7XG4gICAgcmV0dXJuIHsgaW5uZXJSYWRpdXM6IHNjYWxlMlswXSwgb3V0ZXJSYWRpdXM6IHNjYWxlMlswXSArIChzY2FsZTJbMV0gLSBzY2FsZTJbMF0pICogcmFkaXVzIH07XG4gIH07XG4gIGNvbnN0IHNjYWxlVG9PbGRSYWRpdXMgPSAoeyByYWRpdXMgfSkgPT4ge1xuICAgIHJldHVybiB7IGlubmVyUmFkaXVzOiBvbGRTY2FsZVswXSwgb3V0ZXJSYWRpdXM6IG9sZFNjYWxlWzBdICsgKG9sZFNjYWxlWzFdIC0gb2xkU2NhbGVbMF0pICogcmFkaXVzIH07XG4gIH07XG4gIGNvbnN0IGZyb21GbiA9IChzZWN0LCBkYXR1bSwgc3RhdHVzLCB7IHByZXZGcm9tUHJvcHMgfSkgPT4ge1xuICAgIGxldCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfSA9IHNlY3Q7XG4gICAgbGV0IHsgZmlsbCwgc3Ryb2tlIH0gPSBkYXR1bS5zZWN0b3JGb3JtYXQ7XG4gICAgaWYgKHN0YXR1cyA9PT0gXCJ1bmtub3duXCIgfHwgc3RhdHVzID09PSBcImFkZGVkXCIgJiYgIXByZXZGcm9tUHJvcHMpIHtcbiAgICAgIHN0YXJ0QW5nbGUgPSByb3RhdGlvbjtcbiAgICAgIGVuZEFuZ2xlID0gcm90YXRpb247XG4gICAgICBpbm5lclJhZGl1cyA9IGRhdHVtLmlubmVyUmFkaXVzO1xuICAgICAgb3V0ZXJSYWRpdXMgPSBkYXR1bS5vdXRlclJhZGl1cztcbiAgICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gXCJhZGRlZFwiICYmIHByZXZGcm9tUHJvcHMpIHtcbiAgICAgIHN0YXJ0QW5nbGUgPSBwcmV2RnJvbVByb3BzLmVuZEFuZ2xlID8/IHJvdGF0aW9uO1xuICAgICAgZW5kQW5nbGUgPSBwcmV2RnJvbVByb3BzLmVuZEFuZ2xlID8/IHJvdGF0aW9uO1xuICAgICAgaW5uZXJSYWRpdXMgPSBwcmV2RnJvbVByb3BzLmlubmVyUmFkaXVzID8/IGRhdHVtLmlubmVyUmFkaXVzO1xuICAgICAgb3V0ZXJSYWRpdXMgPSBwcmV2RnJvbVByb3BzLm91dGVyUmFkaXVzID8/IGRhdHVtLm91dGVyUmFkaXVzO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSBcImFkZGVkXCIgJiYgIWluaXRpYWxMb2FkKSB7XG4gICAgICBjb25zdCByYWRpaSA9IHNjYWxlVG9PbGRSYWRpdXMoZGF0dW0pO1xuICAgICAgaW5uZXJSYWRpdXMgPSByYWRpaS5pbm5lclJhZGl1cztcbiAgICAgIG91dGVyUmFkaXVzID0gcmFkaWkub3V0ZXJSYWRpdXM7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IFwidXBkYXRlZFwiKSB7XG4gICAgICBmaWxsID0gc2VjdC5maWxsID8/IGZpbGw7XG4gICAgICBzdHJva2UgPSBzZWN0LnN0cm9rZSA/PyBzdHJva2U7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGZpbGwsIHN0cm9rZSwgcGhhc2UgfTtcbiAgfTtcbiAgY29uc3QgdG9GbiA9IChfc2VjdCwgZGF0dW0sIHN0YXR1cywgeyBwcmV2TGl2ZSB9KSA9PiB7XG4gICAgbGV0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cyB9ID0gZGF0dW07XG4gICAgY29uc3QgeyBzdHJva2UsIGZpbGwgfSA9IGRhdHVtLnNlY3RvckZvcm1hdDtcbiAgICBpZiAoc3RhdHVzID09PSBcInJlbW92ZWRcIiAmJiBwcmV2TGl2ZSkge1xuICAgICAgc3RhcnRBbmdsZSA9IHByZXZMaXZlLmRhdHVtPy5lbmRBbmdsZTtcbiAgICAgIGVuZEFuZ2xlID0gcHJldkxpdmUuZGF0dW0/LmVuZEFuZ2xlO1xuICAgIH0gZWxzZSBpZiAoc3RhdHVzID09PSBcInJlbW92ZWRcIiAmJiAhcHJldkxpdmUpIHtcbiAgICAgIHN0YXJ0QW5nbGUgPSByb3RhdGlvbjtcbiAgICAgIGVuZEFuZ2xlID0gcm90YXRpb247XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IFwicmVtb3ZlZFwiKSB7XG4gICAgICBjb25zdCByYWRpaSA9IHNjYWxlVG9OZXdSYWRpdXMoZGF0dW0pO1xuICAgICAgaW5uZXJSYWRpdXMgPSByYWRpaS5pbm5lclJhZGl1cztcbiAgICAgIG91dGVyUmFkaXVzID0gcmFkaWkub3V0ZXJSYWRpdXM7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBvdXRlclJhZGl1cywgaW5uZXJSYWRpdXMsIHN0cm9rZSwgZmlsbCB9O1xuICB9O1xuICBjb25zdCBpbm5lckNpcmNsZUZyb21GbiA9IChub2RlLCBfKSA9PiB7XG4gICAgcmV0dXJuIHsgc2l6ZTogbm9kZS5wcmV2aW91c0RhdHVtPy5yYWRpdXMgPz8gbm9kZS5zaXplID8/IDAsIHBoYXNlIH07XG4gIH07XG4gIGNvbnN0IGlubmVyQ2lyY2xlVG9GbiA9IChfLCBkYXR1bSkgPT4ge1xuICAgIHJldHVybiB7IHNpemU6IGRhdHVtLnJhZGl1cyA/PyAwIH07XG4gIH07XG4gIHJldHVybiB7IG5vZGVzOiB7IHRvRm4sIGZyb21GbiB9LCBpbm5lckNpcmNsZTogeyBmcm9tRm46IGlubmVyQ2lyY2xlRnJvbUZuLCB0b0ZuOiBpbm5lckNpcmNsZVRvRm4gfSB9O1xufVxuZnVuY3Rpb24gcmVzZXRQaWVTZWxlY3Rpb25zRm4oX25vZGUsIGRhdHVtKSB7XG4gIHJldHVybiB7XG4gICAgc3RhcnRBbmdsZTogZGF0dW0uc3RhcnRBbmdsZSxcbiAgICBlbmRBbmdsZTogZGF0dW0uZW5kQW5nbGUsXG4gICAgaW5uZXJSYWRpdXM6IGRhdHVtLmlubmVyUmFkaXVzLFxuICAgIG91dGVyUmFkaXVzOiBkYXR1bS5vdXRlclJhZGl1cyxcbiAgICBmaWxsOiBkYXR1bS5zZWN0b3JGb3JtYXQuZmlsbCxcbiAgICBzdHJva2U6IGRhdHVtLnNlY3RvckZvcm1hdC5zdHJva2VcbiAgfTtcbn1cbmZ1bmN0aW9uIHBpY2tCeU1hdGNoaW5nQW5nbGUoc2VyaWVzLCBwb2ludCkge1xuICBjb25zdCBkeSA9IHBvaW50LnkgLSBzZXJpZXMuY2VudGVyWTtcbiAgY29uc3QgZHggPSBwb2ludC54IC0gc2VyaWVzLmNlbnRlclg7XG4gIGNvbnN0IGFuZ2xlMiA9IE1hdGguYXRhbjIoZHksIGR4KTtcbiAgY29uc3Qgc2VjdG9ycyA9IHNlcmllcy5nZXRJdGVtTm9kZXMoKTtcbiAgZm9yIChjb25zdCBzZWN0b3Igb2Ygc2VjdG9ycykge1xuICAgIGlmIChzZWN0b3IuZGF0dW0ubWlzc2luZyA9PT0gdHJ1ZSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmIChpc0JldHdlZW5BbmdsZXMoYW5nbGUyLCBzZWN0b3Iuc3RhcnRBbmdsZSwgc2VjdG9yLmVuZEFuZ2xlKSkge1xuICAgICAgY29uc3QgcmFkaXVzID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgIGxldCBkaXN0YW5jZTMgPSAwO1xuICAgICAgaWYgKHJhZGl1cyA8IHNlY3Rvci5pbm5lclJhZGl1cykge1xuICAgICAgICBkaXN0YW5jZTMgPSBzZWN0b3IuaW5uZXJSYWRpdXMgLSByYWRpdXM7XG4gICAgICB9IGVsc2UgaWYgKHJhZGl1cyA+IHNlY3Rvci5vdXRlclJhZGl1cykge1xuICAgICAgICBkaXN0YW5jZTMgPSByYWRpdXMgLSBzZWN0b3Iub3V0ZXJSYWRpdXM7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBkYXR1bTogc2VjdG9yLmRhdHVtLCBkaXN0YW5jZTogZGlzdGFuY2UzIH07XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9wb2xhci9wb2xhclNlcmllcy50c1xudmFyIFBvbGFyU2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBEYXRhTW9kZWxTZXJpZXMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdXNlTGFiZWxMYXllciA9IGZhbHNlLFxuICAgIHBpY2tNb2RlcyA9IFszIC8qIE5FQVJFU1RfTk9ERSAqLywgMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqL10sXG4gICAgY2FuSGF2ZUF4ZXMgPSBmYWxzZSxcbiAgICBhbmltYXRpb25SZXNldEZucyxcbiAgICAuLi5vcHRzXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5vcHRzLFxuICAgICAgdXNlTGFiZWxMYXllcixcbiAgICAgIHBpY2tNb2RlcyxcbiAgICAgIGNvbnRlbnRHcm91cFZpcnR1YWw6IGZhbHNlLFxuICAgICAgZGlyZWN0aW9uS2V5czoge1xuICAgICAgICBbXCJ4XCIgLyogWCAqL106IFtcImFuZ2xlS2V5XCJdLFxuICAgICAgICBbXCJ5XCIgLyogWSAqL106IFtcInJhZGl1c0tleVwiXVxuICAgICAgfSxcbiAgICAgIGRpcmVjdGlvbk5hbWVzOiB7XG4gICAgICAgIFtcInhcIiAvKiBYICovXTogW1wiYW5nbGVOYW1lXCJdLFxuICAgICAgICBbXCJ5XCIgLyogWSAqL106IFtcInJhZGl1c05hbWVcIl1cbiAgICAgIH0sXG4gICAgICBjYW5IYXZlQXhlc1xuICAgIH0pO1xuICAgIHRoaXMuaXRlbUdyb3VwID0gdGhpcy5jb250ZW50R3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKCkpO1xuICAgIHRoaXMubm9kZURhdGEgPSBbXTtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy5pdGVtR3JvdXAsXG4gICAgICAoKSA9PiB0aGlzLm5vZGVGYWN0b3J5KCksXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgdGhpcy5sYWJlbFNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICB0aGlzLmxhYmVsR3JvdXAsXG4gICAgICAoKSA9PiB0aGlzLmxhYmVsRmFjdG9yeSgpLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdChcbiAgICAgIHRoaXMuaGlnaGxpZ2h0R3JvdXAsXG4gICAgICAoKSA9PiB0aGlzLm5vZGVGYWN0b3J5KClcbiAgICApO1xuICAgIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy5oaWdobGlnaHRMYWJlbCxcbiAgICAgICgpID0+IHRoaXMubGFiZWxGYWN0b3J5KClcbiAgICApO1xuICAgIC8qKlxuICAgICAqIFRoZSBjZW50ZXIgb2YgdGhlIHBvbGFyIHNlcmllcyAoZm9yIGV4YW1wbGUsIHRoZSBjZW50ZXIgb2YgYSBwaWUpLlxuICAgICAqIElmIHRoZSBwb2xhciBjaGFydCBoYXMgbXVsdGlwbGUgc2VyaWVzLCBhbGwgb2YgdGhlbSB3aWxsIGhhdmUgdGhlaXJcbiAgICAgKiBjZW50ZXIgc2V0IHRvIHRoZSBzYW1lIHZhbHVlIGFzIGEgcmVzdWx0IG9mIHRoZSBwb2xhciBjaGFydCBsYXlvdXQuXG4gICAgICogVGhlIGNlbnRlciBjb29yZGluYXRlcyBhcmUgbm90IHN1cHBvc2VkIHRvIGJlIHNldCBieSB0aGUgdXNlci5cbiAgICAgKi9cbiAgICB0aGlzLmNlbnRlclggPSAwO1xuICAgIHRoaXMuY2VudGVyWSA9IDA7XG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gcmFkaXVzIHRoZSBzZXJpZXMgY2FuIHVzZS5cbiAgICAgKiBUaGlzIHZhbHVlIGlzIHNldCBhdXRvbWF0aWNhbGx5IGFzIGEgcmVzdWx0IG9mIHRoZSBwb2xhciBjaGFydCBsYXlvdXRcbiAgICAgKiBhbmQgaXMgbm90IHN1cHBvc2VkIHRvIGJlIHNldCBieSB0aGUgdXNlci5cbiAgICAgKi9cbiAgICB0aGlzLnJhZGl1cyA9IDA7XG4gICAgdGhpcy5pdGVtR3JvdXAuekluZGV4U3ViT3JkZXIgPSBbKCkgPT4gdGhpcy5fZGVjbGFyYXRpb25PcmRlciwgMV07XG4gICAgdGhpcy5hbmltYXRpb25SZXNldEZucyA9IGFuaW1hdGlvblJlc2V0Rm5zO1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUgPSBuZXcgU3RhdGVNYWNoaW5lKFxuICAgICAgXCJlbXB0eVwiLFxuICAgICAge1xuICAgICAgICBlbXB0eToge1xuICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgdGFyZ2V0OiBcInJlYWR5XCIsXG4gICAgICAgICAgICBhY3Rpb246IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KGRhdGEpXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiLFxuICAgICAgICAgIHNraXA6IFwicmVhZHlcIlxuICAgICAgICB9LFxuICAgICAgICByZWFkeToge1xuICAgICAgICAgIHVwZGF0ZURhdGE6IFwid2FpdGluZ1wiLFxuICAgICAgICAgIGNsZWFyOiBcImNsZWFyaW5nXCIsXG4gICAgICAgICAgaGlnaGxpZ2h0OiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlUmVhZHlIaWdobGlnaHQoZGF0YSksXG4gICAgICAgICAgaGlnaGxpZ2h0TWFya2VyczogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0TWFya2VycyhkYXRhKSxcbiAgICAgICAgICByZXNpemU6IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVSZWFkeVJlc2l6ZShkYXRhKSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiLFxuICAgICAgICAgIHNraXA6IFwicmVhZHlcIlxuICAgICAgICB9LFxuICAgICAgICB3YWl0aW5nOiB7XG4gICAgICAgICAgdXBkYXRlOiB7XG4gICAgICAgICAgICB0YXJnZXQ6IFwicmVhZHlcIixcbiAgICAgICAgICAgIGFjdGlvbjogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCJcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXJpbmc6IHtcbiAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJlbXB0eVwiLFxuICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlQ2xlYXJpbmdVcGRhdGVFbXB0eShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgICgpID0+IHRoaXMuY2hlY2tQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpXG4gICAgKTtcbiAgfVxuICBnZXRJdGVtTm9kZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbUdyb3VwLmNoaWxkcmVuO1xuICB9XG4gIGdldE5vZGVEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVEYXRhO1xuICB9XG4gIHJlc2V0QW5pbWF0aW9uKHBoYXNlKSB7XG4gICAgaWYgKHBoYXNlID09PSBcImluaXRpYWxcIikge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwicmVzZXRcIik7XG4gICAgfSBlbHNlIGlmIChwaGFzZSA9PT0gXCJyZWFkeVwiKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJza2lwXCIpO1xuICAgIH1cbiAgfVxuICBsYWJlbEZhY3RvcnkoKSB7XG4gICAgY29uc3QgdGV4dCA9IG5ldyBUZXh0KCk7XG4gICAgdGV4dC5wb2ludGVyRXZlbnRzID0gMSAvKiBOb25lICovO1xuICAgIHJldHVybiB0ZXh0O1xuICB9XG4gIGdldElubmVyUmFkaXVzKCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGdldExhYmVsRGF0YSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29tcHV0ZUxhYmVsc0JCb3goX29wdGlvbnMsIF9zZXJpZXNSZWN0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmVzZXRBbGxBbmltYXRpb24oKSB7XG4gICAgY29uc3QgeyBpdGVtLCBsYWJlbCB9ID0gdGhpcy5hbmltYXRpb25SZXNldEZucyA/PyB7fTtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnN0b3BCeUFuaW1hdGlvbkdyb3VwSWQodGhpcy5pZCk7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHJlc2V0TW90aW9uKFt0aGlzLml0ZW1TZWxlY3Rpb24sIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uXSwgaXRlbSk7XG4gICAgfVxuICAgIGlmIChsYWJlbCkge1xuICAgICAgcmVzZXRNb3Rpb24oW3RoaXMubGFiZWxTZWxlY3Rpb24sIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb25dLCBsYWJlbCk7XG4gICAgfVxuICAgIHRoaXMuaXRlbVNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gICAgdGhpcy5sYWJlbFNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gICAgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb24uY2xlYW51cCgpO1xuICAgIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24uY2xlYW51cCgpO1xuICB9XG4gIGFuaW1hdGVFbXB0eVVwZGF0ZVJlYWR5KF9kYXRhKSB7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbigpO1xuICB9XG4gIGFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoX2RhdGEpIHtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKCk7XG4gIH1cbiAgYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0KF9kYXRhKSB7XG4gICAgY29uc3QgeyBpdGVtLCBsYWJlbCB9ID0gdGhpcy5hbmltYXRpb25SZXNldEZucyA/PyB7fTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgcmVzZXRNb3Rpb24oW3RoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uXSwgaXRlbSk7XG4gICAgfVxuICAgIGlmIChsYWJlbCkge1xuICAgICAgcmVzZXRNb3Rpb24oW3RoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb25dLCBsYWJlbCk7XG4gICAgfVxuICB9XG4gIGFuaW1hdGVSZWFkeUhpZ2hsaWdodE1hcmtlcnMoX2RhdGEpIHtcbiAgfVxuICBhbmltYXRlUmVhZHlSZXNpemUoX2RhdGEpIHtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKCk7XG4gIH1cbiAgYW5pbWF0ZUNsZWFyaW5nVXBkYXRlRW1wdHkoX2RhdGEpIHtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB0aGlzLnJlc2V0QWxsQW5pbWF0aW9uKCk7XG4gIH1cbiAgYW5pbWF0aW9uVHJhbnNpdGlvbkNsZWFyKCkge1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcImNsZWFyXCIsIHRoaXMuZ2V0QW5pbWF0aW9uRGF0YSgpKTtcbiAgfVxuICBnZXRBbmltYXRpb25EYXRhKHNlcmllc1JlY3QpIHtcbiAgICByZXR1cm4geyBzZXJpZXNSZWN0IH07XG4gIH1cbiAgY29tcHV0ZUZvY3VzQm91bmRzKG9wdHMpIHtcbiAgICBjb25zdCBkYXR1bSA9IHRoaXMuZ2V0Tm9kZURhdGEoKT8uW29wdHMuZGF0dW1JbmRleF07XG4gICAgaWYgKGRhdHVtICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiB0aGlzLml0ZW1TZWxlY3Rpb24uc2VsZWN0KChub2RlKSA9PiBub2RlIGluc3RhbmNlb2YgUGF0aCAmJiBub2RlLmRhdHVtID09PSBkYXR1bSlbMF07XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9wb2xhci9kb251dFNlcmllcy50c1xudmFyIERvbnV0U2VyaWVzTm9kZUV2ZW50ID0gY2xhc3MgZXh0ZW5kcyBTZXJpZXNOb2RlRXZlbnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBuYXRpdmVFdmVudCwgZGF0dW0sIHNlcmllcykge1xuICAgIHN1cGVyKHR5cGUsIG5hdGl2ZUV2ZW50LCBkYXR1bSwgc2VyaWVzKTtcbiAgICB0aGlzLmFuZ2xlS2V5ID0gc2VyaWVzLnByb3BlcnRpZXMuYW5nbGVLZXk7XG4gICAgdGhpcy5yYWRpdXNLZXkgPSBzZXJpZXMucHJvcGVydGllcy5yYWRpdXNLZXk7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWxLZXkgPSBzZXJpZXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxLZXk7XG4gICAgdGhpcy5zZWN0b3JMYWJlbEtleSA9IHNlcmllcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsS2V5O1xuICB9XG59O1xudmFyIERvbnV0U2VyaWVzID0gY2xhc3MgZXh0ZW5kcyBQb2xhclNlcmllcyB7XG4gIGNvbnN0cnVjdG9yKG1vZHVsZUN0eCkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1vZHVsZUN0eCxcbiAgICAgIHBpY2tNb2RlczogWzMgLyogTkVBUkVTVF9OT0RFICovLCAwIC8qIEVYQUNUX1NIQVBFX01BVENIICovXSxcbiAgICAgIHVzZUxhYmVsTGF5ZXI6IHRydWUsXG4gICAgICBhbmltYXRpb25SZXNldEZuczogeyBpdGVtOiByZXNldFBpZVNlbGVjdGlvbnNGbiwgbGFiZWw6IHJlc2V0TGFiZWxGbiB9XG4gICAgfSk7XG4gICAgdGhpcy5wcm9wZXJ0aWVzID0gbmV3IERvbnV0U2VyaWVzUHJvcGVydGllcygpO1xuICAgIHRoaXMucGhhbnRvbU5vZGVEYXRhID0gdm9pZCAwO1xuICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZSA9IG5ldyBMaW5lYXJTY2FsZSgpO1xuICAgIHRoaXMucmFkaXVzU2NhbGUgPSBuZXcgTGluZWFyU2NhbGUoKTtcbiAgICB0aGlzLnBoYW50b21Hcm91cCA9IHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCgpKTtcbiAgICB0aGlzLnBoYW50b21TZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KFxuICAgICAgdGhpcy5waGFudG9tR3JvdXAsXG4gICAgICAoKSA9PiB0aGlzLm5vZGVGYWN0b3J5KCksXG4gICAgICBmYWxzZVxuICAgICk7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWxHcm91cCA9IHRoaXMuY29udGVudEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCh7IG5hbWU6IFwicGllQ2FsbG91dExhYmVsc1wiIH0pKTtcbiAgICB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbiA9IG5ldyBTZWxlY3Rpb24oXG4gICAgICB0aGlzLmNhbGxvdXRMYWJlbEdyb3VwLFxuICAgICAgR3JvdXBcbiAgICApO1xuICAgIC8vIFRoZSBncm91cCBub2RlIHRoYXQgY29udGFpbnMgdGhlIGJhY2tncm91bmQgZ3JhcGhpY3MuXG4gICAgdGhpcy5iYWNrZ3JvdW5kR3JvdXAgPSB0aGlzLnJvb3RHcm91cC5hcHBlbmRDaGlsZChcbiAgICAgIG5ldyBHcm91cCh7XG4gICAgICAgIG5hbWU6IGAke3RoaXMuaWR9LWJhY2tncm91bmRgLFxuICAgICAgICBsYXllcjogdHJ1ZSxcbiAgICAgICAgekluZGV4OiAwIC8qIFNFUklFU19CQUNLR1JPVU5EX1pJTkRFWCAqL1xuICAgICAgfSlcbiAgICApO1xuICAgIC8vIEFHLTYxOTMgSWYgdGhlIHN1bSBvZiBhbGwgZGF0dW1zIGlzIDAsIHRoZW4gd2UnbGwgZHJhdyAxIG9yIDIgcmluZ3MgdG8gcmVwcmVzZW50IHRoZSBlbXB0eSBzZXJpZXMuXG4gICAgdGhpcy56ZXJvc3VtUmluZ3NHcm91cCA9IHRoaXMuYmFja2dyb3VuZEdyb3VwLmFwcGVuZENoaWxkKG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LXplcm9zdW1SaW5nc2AgfSkpO1xuICAgIHRoaXMuemVyb3N1bU91dGVyUmluZyA9IHRoaXMuemVyb3N1bVJpbmdzR3JvdXAuYXBwZW5kQ2hpbGQobmV3IENpcmNsZSgpKTtcbiAgICB0aGlzLnplcm9zdW1Jbm5lclJpbmcgPSB0aGlzLnplcm9zdW1SaW5nc0dyb3VwLmFwcGVuZENoaWxkKG5ldyBDaXJjbGUoKSk7XG4gICAgdGhpcy5pbm5lckxhYmVsc0dyb3VwID0gdGhpcy5jb250ZW50R3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKHsgbmFtZTogXCJpbm5lckxhYmVsc1wiIH0pKTtcbiAgICB0aGlzLmlubmVyQ2lyY2xlR3JvdXAgPSB0aGlzLmJhY2tncm91bmRHcm91cC5hcHBlbmRDaGlsZChuZXcgR3JvdXAoeyBuYW1lOiBgJHt0aGlzLmlkfS1pbm5lckNpcmNsZWAgfSkpO1xuICAgIHRoaXMuaW5uZXJMYWJlbHNTZWxlY3Rpb24gPSBTZWxlY3Rpb24uc2VsZWN0KHRoaXMuaW5uZXJMYWJlbHNHcm91cCwgVGV4dCk7XG4gICAgdGhpcy5pbm5lckNpcmNsZVNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICB0aGlzLmlubmVyQ2lyY2xlR3JvdXAsXG4gICAgICBDaXJjbGVcbiAgICApO1xuICAgIC8vIFdoZW4gYSB1c2VyIHRvZ2dsZXMgYSBzZXJpZXMgaXRlbSAoZS5nLiBmcm9tIHRoZSBsZWdlbmQpLCBpdHMgYm9vbGVhbiBzdGF0ZSBpcyByZWNvcmRlZCBoZXJlLlxuICAgIHRoaXMuc2VyaWVzSXRlbUVuYWJsZWQgPSBbXTtcbiAgICB0aGlzLnN1cnJvdW5kaW5nUmFkaXVzID0gdm9pZCAwO1xuICAgIHRoaXMuTm9kZUV2ZW50ID0gRG9udXRTZXJpZXNOb2RlRXZlbnQ7XG4gICAgdGhpcy5hbmdsZVNjYWxlID0gbmV3IExpbmVhclNjYWxlKCk7XG4gICAgdGhpcy5hbmdsZVNjYWxlLmRvbWFpbiA9IFswLCAxXTtcbiAgICB0aGlzLmFuZ2xlU2NhbGUucmFuZ2UgPSBbLU1hdGguUEksIE1hdGguUEldLm1hcCgoYW5nbGUyKSA9PiBhbmdsZTIgKyBNYXRoLlBJIC8gMik7XG4gICAgdGhpcy5waGFudG9tR3JvdXAub3BhY2l0eSA9IDAuMjtcbiAgICB0aGlzLnBoYW50b21Hcm91cC56SW5kZXhTdWJPcmRlciA9IFsoKSA9PiB0aGlzLl9kZWNsYXJhdGlvbk9yZGVyLCAwXTtcbiAgfVxuICBnZXQgY2FsbG91dE5vZGVEYXRhKCkge1xuICAgIHJldHVybiB0aGlzLnBoYW50b21Ob2RlRGF0YSA/PyB0aGlzLm5vZGVEYXRhO1xuICB9XG4gIGFkZENoYXJ0RXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICB0aGlzLmN0eC5jaGFydEV2ZW50TWFuYWdlcj8uYWRkTGlzdGVuZXIoXCJsZWdlbmQtaXRlbS1jbGlja1wiLCAoZXZlbnQpID0+IHRoaXMub25MZWdlbmRJdGVtQ2xpY2soZXZlbnQpKVxuICAgICk7XG4gIH1cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnZpc2libGUgJiYgKHRoaXMuc2VyaWVzSXRlbUVuYWJsZWQubGVuZ3RoID09PSAwIHx8IHRoaXMuc2VyaWVzSXRlbUVuYWJsZWQuc29tZSgodmlzaWJsZSkgPT4gdmlzaWJsZSkpO1xuICB9XG4gIG5vZGVGYWN0b3J5KCkge1xuICAgIHJldHVybiBuZXcgU2VjdG9yKCk7XG4gIH1cbiAgZ2V0U2VyaWVzRG9tYWluKGRpcmVjdGlvbikge1xuICAgIGlmIChkaXJlY3Rpb24gPT09IFwieFwiIC8qIFggKi8pIHtcbiAgICAgIHJldHVybiB0aGlzLmFuZ2xlU2NhbGUuZG9tYWluO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5yYWRpdXNTY2FsZS5kb21haW47XG4gICAgfVxuICB9XG4gIGFzeW5jIHByb2Nlc3NEYXRhKGRhdGFDb250cm9sbGVyKSB7XG4gICAgaWYgKHRoaXMuZGF0YSA9PSBudWxsIHx8ICF0aGlzLnByb3BlcnRpZXMuaXNWYWxpZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB7IGRhdGEgfSA9IHRoaXM7XG4gICAgY29uc3QgeyB2aXNpYmxlLCBzZXJpZXNJdGVtRW5hYmxlZCB9ID0gdGhpcztcbiAgICBjb25zdCB7IGFuZ2xlS2V5LCBhbmdsZUZpbHRlcktleSwgcmFkaXVzS2V5LCBjYWxsb3V0TGFiZWxLZXksIHNlY3RvckxhYmVsS2V5LCBsZWdlbmRJdGVtS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgYW5pbWF0aW9uRW5hYmxlZCA9ICF0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xuICAgIGNvbnN0IGV4dHJhS2V5UHJvcHMgPSBbXTtcbiAgICBjb25zdCBleHRyYVByb3BzID0gW107XG4gICAgaWYgKGxlZ2VuZEl0ZW1LZXkpIHtcbiAgICAgIGV4dHJhS2V5UHJvcHMucHVzaChrZXlQcm9wZXJ0eShsZWdlbmRJdGVtS2V5LCBcImJhbmRcIiwgeyBpZDogYGxlZ2VuZEl0ZW1LZXlgIH0pKTtcbiAgICB9IGVsc2UgaWYgKGNhbGxvdXRMYWJlbEtleSkge1xuICAgICAgZXh0cmFLZXlQcm9wcy5wdXNoKGtleVByb3BlcnR5KGNhbGxvdXRMYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBjYWxsb3V0TGFiZWxLZXlgIH0pKTtcbiAgICB9IGVsc2UgaWYgKHNlY3RvckxhYmVsS2V5KSB7XG4gICAgICBleHRyYUtleVByb3BzLnB1c2goa2V5UHJvcGVydHkoc2VjdG9yTGFiZWxLZXksIFwiYmFuZFwiLCB7IGlkOiBgc2VjdG9yTGFiZWxLZXlgIH0pKTtcbiAgICB9XG4gICAgY29uc3QgcmFkaXVzU2NhbGVUeXBlID0gdGhpcy5yYWRpdXNTY2FsZS50eXBlO1xuICAgIGNvbnN0IGFuZ2xlU2NhbGVUeXBlID0gdGhpcy5yYWRpdXNTY2FsZS50eXBlO1xuICAgIGlmIChyYWRpdXNLZXkpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaChcbiAgICAgICAgcmFuZ2VkVmFsdWVQcm9wZXJ0eShyYWRpdXNLZXksIHtcbiAgICAgICAgICBpZDogXCJyYWRpdXNWYWx1ZVwiLFxuICAgICAgICAgIG1pbjogdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c01pbiA/PyAwLFxuICAgICAgICAgIG1heDogdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c01heFxuICAgICAgICB9KSxcbiAgICAgICAgdmFsdWVQcm9wZXJ0eShyYWRpdXNLZXksIHJhZGl1c1NjYWxlVHlwZSwgeyBpZDogYHJhZGl1c1Jhd2AgfSksXG4gICAgICAgIC8vIFJhdyB2YWx1ZSBwYXNzLXRocm91Z2guXG4gICAgICAgIG5vcm1hbGlzZVByb3BlcnR5VG8oXCJyYWRpdXNWYWx1ZVwiLCBbMCwgMV0sIDEsIHRoaXMucHJvcGVydGllcy5yYWRpdXNNaW4gPz8gMCwgdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c01heClcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChjYWxsb3V0TGFiZWxLZXkpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaCh2YWx1ZVByb3BlcnR5KGNhbGxvdXRMYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBjYWxsb3V0TGFiZWxWYWx1ZWAgfSkpO1xuICAgIH1cbiAgICBpZiAoc2VjdG9yTGFiZWxLZXkpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaCh2YWx1ZVByb3BlcnR5KHNlY3RvckxhYmVsS2V5LCBcImJhbmRcIiwgeyBpZDogYHNlY3RvckxhYmVsVmFsdWVgIH0pKTtcbiAgICB9XG4gICAgaWYgKGxlZ2VuZEl0ZW1LZXkpIHtcbiAgICAgIGV4dHJhUHJvcHMucHVzaCh2YWx1ZVByb3BlcnR5KGxlZ2VuZEl0ZW1LZXksIFwiYmFuZFwiLCB7IGlkOiBgbGVnZW5kSXRlbVZhbHVlYCB9KSk7XG4gICAgfVxuICAgIGlmIChhbmdsZUZpbHRlcktleSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKFxuICAgICAgICBhY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KGFuZ2xlRmlsdGVyS2V5LCBhbmdsZVNjYWxlVHlwZSwge1xuICAgICAgICAgIGlkOiBgYW5nbGVGaWx0ZXJWYWx1ZWAsXG4gICAgICAgICAgb25seVBvc2l0aXZlOiB0cnVlXG4gICAgICAgIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KGFuZ2xlRmlsdGVyS2V5LCBhbmdsZVNjYWxlVHlwZSwgeyBpZDogYGFuZ2xlRmlsdGVyUmF3YCB9KSxcbiAgICAgICAgbm9ybWFsaXNlUHJvcGVydHlUbyhcImFuZ2xlRmlsdGVyVmFsdWVcIiwgWzAsIDFdLCAwLCAwKVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGFuaW1hdGlvbkVuYWJsZWQgJiYgdGhpcy5wcm9jZXNzZWREYXRhICYmIGV4dHJhS2V5UHJvcHMubGVuZ3RoID4gMCkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKGRpZmYodGhpcy5wcm9jZXNzZWREYXRhKSk7XG4gICAgfVxuICAgIGV4dHJhUHJvcHMucHVzaChhbmltYXRpb25WYWxpZGF0aW9uKCkpO1xuICAgIGRhdGEgPSBkYXRhLm1hcCgoZCwgaWR4KSA9PiB2aXNpYmxlICYmIHNlcmllc0l0ZW1FbmFibGVkW2lkeF0gPyBkIDogeyAuLi5kLCBbYW5nbGVLZXldOiAwIH0pO1xuICAgIGF3YWl0IHRoaXMucmVxdWVzdERhdGFNb2RlbChkYXRhQ29udHJvbGxlciwgZGF0YSwge1xuICAgICAgcHJvcHM6IFtcbiAgICAgICAgLi4uZXh0cmFLZXlQcm9wcyxcbiAgICAgICAgYWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eShhbmdsZUtleSwgYW5nbGVTY2FsZVR5cGUsIHsgaWQ6IGBhbmdsZVZhbHVlYCwgb25seVBvc2l0aXZlOiB0cnVlIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KGFuZ2xlS2V5LCBhbmdsZVNjYWxlVHlwZSwgeyBpZDogYGFuZ2xlUmF3YCB9KSxcbiAgICAgICAgLy8gUmF3IHZhbHVlIHBhc3MtdGhyb3VnaC5cbiAgICAgICAgbm9ybWFsaXNlUHJvcGVydHlUbyhcImFuZ2xlVmFsdWVcIiwgWzAsIDFdLCAwLCAwKSxcbiAgICAgICAgLi4uZXh0cmFQcm9wc1xuICAgICAgXVxuICAgIH0pO1xuICAgIGZvciAoY29uc3QgdmFsdWVEZWYgb2YgdGhpcy5wcm9jZXNzZWREYXRhPy5kZWZzPy52YWx1ZXMgPz8gW10pIHtcbiAgICAgIGNvbnN0IHsgaWQsIG1pc3NpbmcsIHByb3BlcnR5IH0gPSB2YWx1ZURlZjtcbiAgICAgIGNvbnN0IG1pc3NDb3VudCA9IGdldE1pc3NDb3VudCh0aGlzLCBtaXNzaW5nKTtcbiAgICAgIGlmIChpZCAhPT0gXCJhbmdsZVJhd1wiICYmIG1pc3NDb3VudCA+IDApIHtcbiAgICAgICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgICAgIGBubyB2YWx1ZSB3YXMgZm91bmQgZm9yIHRoZSBrZXkgJyR7U3RyaW5nKHByb3BlcnR5KX0nIG9uICR7bWlzc0NvdW50fSBkYXRhIGVsZW1lbnQke21pc3NDb3VudCA+IDEgPyBcInNcIiA6IFwiXCJ9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVEYXRhXCIpO1xuICB9XG4gIGFzeW5jIG1heWJlUmVmcmVzaE5vZGVEYXRhKCkge1xuICAgIGlmICghdGhpcy5ub2RlRGF0YVJlZnJlc2gpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgeyBub2RlRGF0YSA9IFtdLCBwaGFudG9tTm9kZURhdGEgfSA9IGF3YWl0IHRoaXMuY3JlYXRlTm9kZURhdGEoKSA/PyB7fTtcbiAgICB0aGlzLm5vZGVEYXRhID0gbm9kZURhdGE7XG4gICAgdGhpcy5waGFudG9tTm9kZURhdGEgPSBwaGFudG9tTm9kZURhdGE7XG4gICAgdGhpcy5ub2RlRGF0YVJlZnJlc2ggPSBmYWxzZTtcbiAgfVxuICBnZXRQcm9jZXNzZWREYXRhSW5kZXhlcyhkYXRhTW9kZWwpIHtcbiAgICBjb25zdCBhbmdsZUlkeCA9IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgYW5nbGVWYWx1ZWApO1xuICAgIGNvbnN0IGFuZ2xlUmF3SWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBhbmdsZVJhd2ApO1xuICAgIGNvbnN0IGFuZ2xlRmlsdGVySWR4ID0gdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlRmlsdGVyS2V5ICE9IG51bGwgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGFuZ2xlRmlsdGVyVmFsdWVgKSA6IHZvaWQgMDtcbiAgICBjb25zdCBhbmdsZUZpbHRlclJhd0lkeCA9IHRoaXMucHJvcGVydGllcy5hbmdsZUZpbHRlcktleSAhPSBudWxsID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBhbmdsZUZpbHRlclJhd2ApIDogdm9pZCAwO1xuICAgIGNvbnN0IHJhZGl1c0lkeCA9IHRoaXMucHJvcGVydGllcy5yYWRpdXNLZXkgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYHJhZGl1c1ZhbHVlYCkgOiB2b2lkIDA7XG4gICAgY29uc3QgcmFkaXVzUmF3SWR4ID0gdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c0tleSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgcmFkaXVzUmF3YCkgOiB2b2lkIDA7XG4gICAgY29uc3QgY2FsbG91dExhYmVsSWR4ID0gdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbEtleSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgY2FsbG91dExhYmVsVmFsdWVgKSA6IHZvaWQgMDtcbiAgICBjb25zdCBzZWN0b3JMYWJlbElkeCA9IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbEtleSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgc2VjdG9yTGFiZWxWYWx1ZWApIDogdm9pZCAwO1xuICAgIGNvbnN0IGxlZ2VuZEl0ZW1JZHggPSB0aGlzLnByb3BlcnRpZXMubGVnZW5kSXRlbUtleSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgbGVnZW5kSXRlbVZhbHVlYCkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuZ2xlSWR4LFxuICAgICAgYW5nbGVSYXdJZHgsXG4gICAgICBhbmdsZUZpbHRlcklkeCxcbiAgICAgIGFuZ2xlRmlsdGVyUmF3SWR4LFxuICAgICAgcmFkaXVzSWR4LFxuICAgICAgcmFkaXVzUmF3SWR4LFxuICAgICAgY2FsbG91dExhYmVsSWR4LFxuICAgICAgc2VjdG9yTGFiZWxJZHgsXG4gICAgICBsZWdlbmRJdGVtSWR4XG4gICAgfTtcbiAgfVxuICBhc3luYyBjcmVhdGVOb2RlRGF0YSgpIHtcbiAgICBjb25zdCB7IGlkOiBzZXJpZXNJZCwgcHJvY2Vzc2VkRGF0YSwgZGF0YU1vZGVsLCBhbmdsZVNjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgcm90YXRpb24sIGlubmVyUmFkaXVzUmF0aW8gfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkpIHtcbiAgICAgIHRoaXMuemVyb3N1bU91dGVyUmluZy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuemVyb3N1bUlubmVyUmluZy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIHJldHVybiB7IGl0ZW1JZDogc2VyaWVzSWQsIG5vZGVEYXRhOiBbXSwgbGFiZWxEYXRhOiBbXSB9O1xuICAgIH1cbiAgICBpZiAoIXByb2Nlc3NlZERhdGEgfHwgIWRhdGFNb2RlbCB8fCBwcm9jZXNzZWREYXRhLnR5cGUgIT09IFwidW5ncm91cGVkXCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgYW5nbGVJZHgsXG4gICAgICBhbmdsZVJhd0lkeCxcbiAgICAgIGFuZ2xlRmlsdGVySWR4LFxuICAgICAgYW5nbGVGaWx0ZXJSYXdJZHgsXG4gICAgICByYWRpdXNJZHgsXG4gICAgICByYWRpdXNSYXdJZHgsXG4gICAgICBjYWxsb3V0TGFiZWxJZHgsXG4gICAgICBzZWN0b3JMYWJlbElkeCxcbiAgICAgIGxlZ2VuZEl0ZW1JZHhcbiAgICB9ID0gdGhpcy5nZXRQcm9jZXNzZWREYXRhSW5kZXhlcyhkYXRhTW9kZWwpO1xuICAgIGNvbnN0IHVzZUZpbHRlckFuZ2xlcyA9IGFuZ2xlRmlsdGVyUmF3SWR4ICE9IG51bGwgJiYgcHJvY2Vzc2VkRGF0YS5kYXRhLnNvbWUoKHsgdmFsdWVzIH0pID0+IHtcbiAgICAgIHJldHVybiB2YWx1ZXNbYW5nbGVGaWx0ZXJSYXdJZHhdID4gdmFsdWVzW2FuZ2xlUmF3SWR4XTtcbiAgICB9KTtcbiAgICBsZXQgY3VycmVudFN0YXJ0ID0gMDtcbiAgICBsZXQgc3VtMiA9IDA7XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICBjb25zdCBwaGFudG9tTm9kZXMgPSBhbmdsZUZpbHRlclJhd0lkeCAhPSBudWxsID8gW10gOiB2b2lkIDA7XG4gICAgcHJvY2Vzc2VkRGF0YS5kYXRhLmZvckVhY2goKGdyb3VwLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgeyBkYXR1bSwgdmFsdWVzIH0gPSBncm91cDtcbiAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHVzZUZpbHRlckFuZ2xlcyA/IHZhbHVlc1thbmdsZUZpbHRlcklkeF0gOiB2YWx1ZXNbYW5nbGVJZHhdO1xuICAgICAgY29uc3QgY3Jvc3NGaWx0ZXJTY2FsZSA9IGFuZ2xlRmlsdGVyUmF3SWR4ICE9IG51bGwgJiYgIXVzZUZpbHRlckFuZ2xlcyA/IE1hdGguc3FydCh2YWx1ZXNbYW5nbGVGaWx0ZXJSYXdJZHhdIC8gdmFsdWVzW2FuZ2xlUmF3SWR4XSkgOiAxO1xuICAgICAgY29uc3Qgc3RhcnRBbmdsZSA9IGFuZ2xlU2NhbGUuY29udmVydChjdXJyZW50U3RhcnQpICsgdG9SYWRpYW5zKHJvdGF0aW9uKTtcbiAgICAgIGN1cnJlbnRTdGFydCA9IGN1cnJlbnRWYWx1ZTtcbiAgICAgIHN1bTIgKz0gY3VycmVudFZhbHVlO1xuICAgICAgY29uc3QgZW5kQW5nbGUgPSBhbmdsZVNjYWxlLmNvbnZlcnQoY3VycmVudFN0YXJ0KSArIHRvUmFkaWFucyhyb3RhdGlvbik7XG4gICAgICBjb25zdCBzcGFuID0gTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKTtcbiAgICAgIGNvbnN0IG1pZEFuZ2xlID0gc3RhcnRBbmdsZSArIHNwYW4gLyAyO1xuICAgICAgY29uc3QgYW5nbGVWYWx1ZSA9IHZhbHVlc1thbmdsZVJhd0lkeF07XG4gICAgICBjb25zdCByYWRpdXNSYXcgPSByYWRpdXNJZHggIT0gbnVsbCA/IHZhbHVlc1tyYWRpdXNJZHhdID8/IDEgOiAxO1xuICAgICAgY29uc3QgcmFkaXVzID0gcmFkaXVzUmF3ICogY3Jvc3NGaWx0ZXJTY2FsZTtcbiAgICAgIGNvbnN0IHJhZGl1c1ZhbHVlID0gcmFkaXVzUmF3SWR4ICE9IG51bGwgPyB2YWx1ZXNbcmFkaXVzUmF3SWR4XSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IGxlZ2VuZEl0ZW1WYWx1ZSA9IGxlZ2VuZEl0ZW1JZHggIT0gbnVsbCA/IHZhbHVlc1tsZWdlbmRJdGVtSWR4XSA6IHZvaWQgMDtcbiAgICAgIGNvbnN0IG5vZGVMYWJlbHMgPSB0aGlzLmdldExhYmVscyhcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIG1pZEFuZ2xlLFxuICAgICAgICBzcGFuLFxuICAgICAgICB0cnVlLFxuICAgICAgICBjYWxsb3V0TGFiZWxJZHggIT0gbnVsbCA/IHZhbHVlc1tjYWxsb3V0TGFiZWxJZHhdIDogdm9pZCAwLFxuICAgICAgICBzZWN0b3JMYWJlbElkeCAhPSBudWxsID8gdmFsdWVzW3NlY3RvckxhYmVsSWR4XSA6IHZvaWQgMCxcbiAgICAgICAgbGVnZW5kSXRlbVZhbHVlXG4gICAgICApO1xuICAgICAgY29uc3Qgc2VjdG9yRm9ybWF0ID0gdGhpcy5nZXRTZWN0b3JGb3JtYXQoZGF0dW0sIGluZGV4LCBmYWxzZSk7XG4gICAgICBjb25zdCBub2RlID0ge1xuICAgICAgICBpdGVtSWQ6IGluZGV4LFxuICAgICAgICBzZXJpZXM6IHRoaXMsXG4gICAgICAgIGRhdHVtLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgYW5nbGVWYWx1ZSxcbiAgICAgICAgbWlkQW5nbGUsXG4gICAgICAgIG1pZENvczogTWF0aC5jb3MobWlkQW5nbGUpLFxuICAgICAgICBtaWRTaW46IE1hdGguc2luKG1pZEFuZ2xlKSxcbiAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGUsXG4gICAgICAgIHJhZGl1cyxcbiAgICAgICAgaW5uZXJSYWRpdXM6IE1hdGgubWF4KHRoaXMucmFkaXVzU2NhbGUuY29udmVydCgwKSwgMCksXG4gICAgICAgIG91dGVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQocmFkaXVzKSwgMCksXG4gICAgICAgIHNlY3RvckZvcm1hdCxcbiAgICAgICAgcmFkaXVzVmFsdWUsXG4gICAgICAgIGxlZ2VuZEl0ZW1WYWx1ZSxcbiAgICAgICAgZW5hYmxlZDogdGhpcy5zZXJpZXNJdGVtRW5hYmxlZFtpbmRleF0sXG4gICAgICAgIGZvY3VzYWJsZTogdHJ1ZSxcbiAgICAgICAgLi4ubm9kZUxhYmVsc1xuICAgICAgfTtcbiAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICBpZiAocGhhbnRvbU5vZGVzICE9IG51bGwpIHtcbiAgICAgICAgcGhhbnRvbU5vZGVzLnB1c2goe1xuICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgcmFkaXVzOiAxLFxuICAgICAgICAgIGlubmVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQoMCksIDApLFxuICAgICAgICAgIG91dGVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQoMSksIDApLFxuICAgICAgICAgIGZvY3VzYWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy56ZXJvc3VtT3V0ZXJSaW5nLnZpc2libGUgPSBzdW0yID09PSAwO1xuICAgIHRoaXMuemVyb3N1bUlubmVyUmluZy52aXNpYmxlID0gc3VtMiA9PT0gMCAmJiBpbm5lclJhZGl1c1JhdGlvICE9IG51bGwgJiYgaW5uZXJSYWRpdXNSYXRpbyAhPT0gMSAmJiBpbm5lclJhZGl1c1JhdGlvID4gMDtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbUlkOiBzZXJpZXNJZCxcbiAgICAgIG5vZGVEYXRhOiBub2RlcyxcbiAgICAgIGxhYmVsRGF0YTogbm9kZXMsXG4gICAgICBwaGFudG9tTm9kZURhdGE6IHBoYW50b21Ob2Rlc1xuICAgIH07XG4gIH1cbiAgZ2V0TGFiZWxzKGRhdHVtLCBtaWRBbmdsZSwgc3Bhbiwgc2tpcERpc2FibGVkLCBjYWxsb3V0TGFiZWxWYWx1ZSwgc2VjdG9yTGFiZWxWYWx1ZSwgbGVnZW5kSXRlbVZhbHVlKSB7XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWwsIHNlY3RvckxhYmVsLCBsZWdlbmRJdGVtS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgY2FsbG91dExhYmVsS2V5ID0gIXNraXBEaXNhYmxlZCB8fCBjYWxsb3V0TGFiZWwuZW5hYmxlZCA/IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxLZXkgOiB2b2lkIDA7XG4gICAgY29uc3Qgc2VjdG9yTGFiZWxLZXkgPSAhc2tpcERpc2FibGVkIHx8IHNlY3RvckxhYmVsLmVuYWJsZWQgPyB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxLZXkgOiB2b2lkIDA7XG4gICAgaWYgKCFjYWxsb3V0TGFiZWxLZXkgJiYgIXNlY3RvckxhYmVsS2V5ICYmICFsZWdlbmRJdGVtS2V5KSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsRm9ybWF0dGVyUGFyYW1zID0ge1xuICAgICAgZGF0dW0sXG4gICAgICBhbmdsZUtleTogdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlS2V5LFxuICAgICAgYW5nbGVOYW1lOiB0aGlzLnByb3BlcnRpZXMuYW5nbGVOYW1lLFxuICAgICAgcmFkaXVzS2V5OiB0aGlzLnByb3BlcnRpZXMucmFkaXVzS2V5LFxuICAgICAgcmFkaXVzTmFtZTogdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c05hbWUsXG4gICAgICBjYWxsb3V0TGFiZWxLZXk6IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxLZXksXG4gICAgICBjYWxsb3V0TGFiZWxOYW1lOiB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsTmFtZSxcbiAgICAgIHNlY3RvckxhYmVsS2V5OiB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxLZXksXG4gICAgICBzZWN0b3JMYWJlbE5hbWU6IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbE5hbWUsXG4gICAgICBsZWdlbmRJdGVtS2V5OiB0aGlzLnByb3BlcnRpZXMubGVnZW5kSXRlbUtleVxuICAgIH07XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgaWYgKGNhbGxvdXRMYWJlbEtleSAmJiBzcGFuID4gdG9SYWRpYW5zKGNhbGxvdXRMYWJlbC5taW5BbmdsZSkpIHtcbiAgICAgIHJlc3VsdC5jYWxsb3V0TGFiZWwgPSB7XG4gICAgICAgIC4uLnRoaXMuZ2V0VGV4dEFsaWdubWVudChtaWRBbmdsZSksXG4gICAgICAgIHRleHQ6IHRoaXMuZ2V0TGFiZWxUZXh0KGNhbGxvdXRMYWJlbCwge1xuICAgICAgICAgIC4uLmxhYmVsRm9ybWF0dGVyUGFyYW1zLFxuICAgICAgICAgIHZhbHVlOiBjYWxsb3V0TGFiZWxWYWx1ZVxuICAgICAgICB9KSxcbiAgICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgICAgY29sbGlzaW9uVGV4dEFsaWduOiB2b2lkIDAsXG4gICAgICAgIGNvbGxpc2lvbk9mZnNldFk6IDAsXG4gICAgICAgIGJveDogdm9pZCAwXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoc2VjdG9yTGFiZWxLZXkpIHtcbiAgICAgIHJlc3VsdC5zZWN0b3JMYWJlbCA9IHtcbiAgICAgICAgdGV4dDogdGhpcy5nZXRMYWJlbFRleHQoc2VjdG9yTGFiZWwsIHtcbiAgICAgICAgICAuLi5sYWJlbEZvcm1hdHRlclBhcmFtcyxcbiAgICAgICAgICB2YWx1ZTogc2VjdG9yTGFiZWxWYWx1ZVxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGxlZ2VuZEl0ZW1LZXkgIT0gbnVsbCAmJiBsZWdlbmRJdGVtVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmVzdWx0LmxlZ2VuZEl0ZW0gPSB7IGtleTogbGVnZW5kSXRlbUtleSwgdGV4dDogbGVnZW5kSXRlbVZhbHVlIH07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZ2V0VGV4dEFsaWdubWVudChtaWRBbmdsZSkge1xuICAgIGNvbnN0IHF1YWRyYW50VGV4dE9wdHMgPSBbXG4gICAgICB7IHRleHRBbGlnbjogXCJjZW50ZXJcIiwgdGV4dEJhc2VsaW5lOiBcImJvdHRvbVwiIH0sXG4gICAgICB7IHRleHRBbGlnbjogXCJsZWZ0XCIsIHRleHRCYXNlbGluZTogXCJtaWRkbGVcIiB9LFxuICAgICAgeyB0ZXh0QWxpZ246IFwiY2VudGVyXCIsIHRleHRCYXNlbGluZTogXCJoYW5naW5nXCIgfSxcbiAgICAgIHsgdGV4dEFsaWduOiBcInJpZ2h0XCIsIHRleHRCYXNlbGluZTogXCJtaWRkbGVcIiB9XG4gICAgXTtcbiAgICBjb25zdCBtaWRBbmdsZTE4MCA9IG5vcm1hbGl6ZUFuZ2xlMTgwKG1pZEFuZ2xlKTtcbiAgICBjb25zdCBxdWFkcmFudFN0YXJ0ID0gLTAuNzUgKiBNYXRoLlBJO1xuICAgIGNvbnN0IHF1YWRyYW50T2Zmc2V0ID0gbWlkQW5nbGUxODAgLSBxdWFkcmFudFN0YXJ0O1xuICAgIGNvbnN0IHF1YWRyYW50ID0gTWF0aC5mbG9vcihxdWFkcmFudE9mZnNldCAvIChNYXRoLlBJIC8gMikpO1xuICAgIGNvbnN0IHF1YWRyYW50SW5kZXggPSBtb2QocXVhZHJhbnQsIHF1YWRyYW50VGV4dE9wdHMubGVuZ3RoKTtcbiAgICByZXR1cm4gcXVhZHJhbnRUZXh0T3B0c1txdWFkcmFudEluZGV4XTtcbiAgfVxuICBnZXRTZWN0b3JGb3JtYXQoZGF0dW0sIGZvcm1hdEluZGV4LCBoaWdobGlnaHRlZCkge1xuICAgIGNvbnN0IHsgY2FsbGJhY2tDYWNoZSB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgeyBhbmdsZUtleSwgcmFkaXVzS2V5LCBjYWxsb3V0TGFiZWxLZXksIHNlY3RvckxhYmVsS2V5LCBsZWdlbmRJdGVtS2V5LCBmaWxscywgc3Ryb2tlcywgaXRlbVN0eWxlciB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGRlZmF1bHRTdHJva2UgPSBzdHJva2VzW2Zvcm1hdEluZGV4ICUgc3Ryb2tlcy5sZW5ndGhdO1xuICAgIGNvbnN0IHsgZmlsbCwgZmlsbE9wYWNpdHksIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0cm9rZU9wYWNpdHksIGxpbmVEYXNoLCBsaW5lRGFzaE9mZnNldCwgY29ybmVyUmFkaXVzIH0gPSBtZXJnZURlZmF1bHRzKFxuICAgICAgaGlnaGxpZ2h0ZWQgJiYgdGhpcy5wcm9wZXJ0aWVzLmhpZ2hsaWdodFN0eWxlLml0ZW0sXG4gICAgICB7XG4gICAgICAgIGZpbGw6IGZpbGxzLmxlbmd0aCA+IDAgPyBmaWxsc1tmb3JtYXRJbmRleCAlIGZpbGxzLmxlbmd0aF0gOiB2b2lkIDAsXG4gICAgICAgIHN0cm9rZTogZGVmYXVsdFN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuZ2V0U3Ryb2tlV2lkdGgodGhpcy5wcm9wZXJ0aWVzLnN0cm9rZVdpZHRoKSxcbiAgICAgICAgc3Ryb2tlT3BhY2l0eTogdGhpcy5nZXRPcGFjaXR5KClcbiAgICAgIH0sXG4gICAgICB0aGlzLnByb3BlcnRpZXNcbiAgICApO1xuICAgIGxldCBmb3JtYXQ7XG4gICAgaWYgKGl0ZW1TdHlsZXIpIHtcbiAgICAgIGZvcm1hdCA9IGNhbGxiYWNrQ2FjaGUuY2FsbChpdGVtU3R5bGVyLCB7XG4gICAgICAgIGRhdHVtLFxuICAgICAgICBhbmdsZUtleSxcbiAgICAgICAgcmFkaXVzS2V5LFxuICAgICAgICBjYWxsb3V0TGFiZWxLZXksXG4gICAgICAgIHNlY3RvckxhYmVsS2V5LFxuICAgICAgICBsZWdlbmRJdGVtS2V5LFxuICAgICAgICBmaWxsLFxuICAgICAgICBmaWxsT3BhY2l0eSxcbiAgICAgICAgc3Ryb2tlLFxuICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgc3Ryb2tlT3BhY2l0eSxcbiAgICAgICAgbGluZURhc2gsXG4gICAgICAgIGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGhpZ2hsaWdodGVkLFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBmaWxsOiBmb3JtYXQ/LmZpbGwgPz8gZmlsbCxcbiAgICAgIGZpbGxPcGFjaXR5OiBmb3JtYXQ/LmZpbGxPcGFjaXR5ID8/IGZpbGxPcGFjaXR5LFxuICAgICAgc3Ryb2tlOiBmb3JtYXQ/LnN0cm9rZSA/PyBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogZm9ybWF0Py5zdHJva2VXaWR0aCA/PyBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZU9wYWNpdHk6IGZvcm1hdD8uc3Ryb2tlT3BhY2l0eSA/PyBzdHJva2VPcGFjaXR5LFxuICAgICAgbGluZURhc2g6IGZvcm1hdD8ubGluZURhc2ggPz8gbGluZURhc2gsXG4gICAgICBsaW5lRGFzaE9mZnNldDogZm9ybWF0Py5saW5lRGFzaE9mZnNldCA/PyBsaW5lRGFzaE9mZnNldCxcbiAgICAgIGNvcm5lclJhZGl1czogZm9ybWF0Py5jb3JuZXJSYWRpdXMgPz8gY29ybmVyUmFkaXVzXG4gICAgfTtcbiAgfVxuICBnZXRJbm5lclJhZGl1cygpIHtcbiAgICBjb25zdCB7IHJhZGl1cyB9ID0gdGhpcztcbiAgICBjb25zdCB7IGlubmVyUmFkaXVzUmF0aW8gPSAxLCBpbm5lclJhZGl1c09mZnNldCA9IDAgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IHJhZGl1cyAqIGlubmVyUmFkaXVzUmF0aW8gKyBpbm5lclJhZGl1c09mZnNldDtcbiAgICBpZiAoaW5uZXJSYWRpdXMgPT09IHJhZGl1cyB8fCBpbm5lclJhZGl1cyA8IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXR1cm4gaW5uZXJSYWRpdXM7XG4gIH1cbiAgZ2V0T3V0ZXJSYWRpdXMoKSB7XG4gICAgY29uc3QgeyBvdXRlclJhZGl1c1JhdGlvLCBvdXRlclJhZGl1c09mZnNldCB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLnJhZGl1cyAqIG91dGVyUmFkaXVzUmF0aW8gKyBvdXRlclJhZGl1c09mZnNldCwgMCk7XG4gIH1cbiAgdXBkYXRlUmFkaXVzU2NhbGUocmVzaXplKSB7XG4gICAgY29uc3QgbmV3UmFuZ2UgPSBbdGhpcy5nZXRJbm5lclJhZGl1cygpLCB0aGlzLmdldE91dGVyUmFkaXVzKCldO1xuICAgIHRoaXMucmFkaXVzU2NhbGUucmFuZ2UgPSBuZXdSYW5nZTtcbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUucmFuZ2UgPSBuZXdSYW5nZTtcbiAgICB9XG4gICAgY29uc3Qgc2V0UmFkaWkgPSAoZCkgPT4gKHtcbiAgICAgIC4uLmQsXG4gICAgICBpbm5lclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KDApLCAwKSxcbiAgICAgIG91dGVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQoZC5yYWRpdXMpLCAwKVxuICAgIH0pO1xuICAgIHRoaXMubm9kZURhdGEgPSB0aGlzLm5vZGVEYXRhLm1hcChzZXRSYWRpaSk7XG4gICAgdGhpcy5waGFudG9tTm9kZURhdGEgPSB0aGlzLnBoYW50b21Ob2RlRGF0YT8ubWFwKHNldFJhZGlpKTtcbiAgfVxuICBnZXRUaXRsZVRyYW5zbGF0aW9uWSgpIHtcbiAgICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KDAsIHRoaXMucmFkaXVzU2NhbGUucmFuZ2VbMV0pO1xuICAgIGlmIChvdXRlclJhZGl1cyA9PT0gMCkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgY29uc3Qgc3BhY2luZyA9IHRoaXMucHJvcGVydGllcy50aXRsZT8uc3BhY2luZyA/PyAwO1xuICAgIGNvbnN0IHRpdGxlT2Zmc2V0ID0gMiArIHNwYWNpbmc7XG4gICAgY29uc3QgZHkgPSBNYXRoLm1heCgwLCAtb3V0ZXJSYWRpdXMpO1xuICAgIHJldHVybiAtb3V0ZXJSYWRpdXMgLSB0aXRsZU9mZnNldCAtIGR5O1xuICB9XG4gIGFzeW5jIHVwZGF0ZSh7IHNlcmllc1JlY3QgfSkge1xuICAgIGNvbnN0IHsgdGl0bGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBuZXdOb2RlRGF0YURlcGVuZGVuY2llcyA9IHtcbiAgICAgIHNlcmllc1JlY3RXaWR0aDogc2VyaWVzUmVjdD8ud2lkdGgsXG4gICAgICBzZXJpZXNSZWN0SGVpZ2h0OiBzZXJpZXNSZWN0Py5oZWlnaHRcbiAgICB9O1xuICAgIGNvbnN0IHJlc2l6ZSA9IGpzb25EaWZmKHRoaXMubm9kZURhdGFEZXBlbmRlbmNpZXMsIG5ld05vZGVEYXRhRGVwZW5kZW5jaWVzKSAhPSBudWxsO1xuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHRoaXMuX25vZGVEYXRhRGVwZW5kZW5jaWVzID0gbmV3Tm9kZURhdGFEZXBlbmRlbmNpZXM7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMubWF5YmVSZWZyZXNoTm9kZURhdGEoKTtcbiAgICB0aGlzLnVwZGF0ZVRpdGxlTm9kZXMoKTtcbiAgICB0aGlzLnVwZGF0ZVJhZGl1c1NjYWxlKHJlc2l6ZSk7XG4gICAgdGhpcy5jb250ZW50R3JvdXAudHJhbnNsYXRpb25YID0gdGhpcy5jZW50ZXJYO1xuICAgIHRoaXMuY29udGVudEdyb3VwLnRyYW5zbGF0aW9uWSA9IHRoaXMuY2VudGVyWTtcbiAgICB0aGlzLmhpZ2hsaWdodEdyb3VwLnRyYW5zbGF0aW9uWCA9IHRoaXMuY2VudGVyWDtcbiAgICB0aGlzLmhpZ2hsaWdodEdyb3VwLnRyYW5zbGF0aW9uWSA9IHRoaXMuY2VudGVyWTtcbiAgICB0aGlzLmJhY2tncm91bmRHcm91cC50cmFuc2xhdGlvblggPSB0aGlzLmNlbnRlclg7XG4gICAgdGhpcy5iYWNrZ3JvdW5kR3JvdXAudHJhbnNsYXRpb25ZID0gdGhpcy5jZW50ZXJZO1xuICAgIGlmICh0aGlzLmxhYmVsR3JvdXApIHtcbiAgICAgIHRoaXMubGFiZWxHcm91cC50cmFuc2xhdGlvblggPSB0aGlzLmNlbnRlclg7XG4gICAgICB0aGlzLmxhYmVsR3JvdXAudHJhbnNsYXRpb25ZID0gdGhpcy5jZW50ZXJZO1xuICAgIH1cbiAgICBpZiAodGl0bGUpIHtcbiAgICAgIGNvbnN0IGR5ID0gdGhpcy5nZXRUaXRsZVRyYW5zbGF0aW9uWSgpO1xuICAgICAgY29uc3QgdGl0bGVCb3ggPSB0aXRsZS5ub2RlLmdldEJCb3goKTtcbiAgICAgIHRpdGxlLm5vZGUudmlzaWJsZSA9IHRpdGxlLmVuYWJsZWQgJiYgaXNGaW5pdGUoZHkpICYmICF0aGlzLmJib3hJbnRlcnNlY3RzU3Vycm91bmRpbmdTZXJpZXModGl0bGVCb3gsIDAsIGR5KTtcbiAgICAgIHRpdGxlLm5vZGUudHJhbnNsYXRpb25ZID0gaXNGaW5pdGUoZHkpID8gZHkgOiAwO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNpcmNsZSBvZiBbdGhpcy56ZXJvc3VtSW5uZXJSaW5nLCB0aGlzLnplcm9zdW1PdXRlclJpbmddKSB7XG4gICAgICBjaXJjbGUuZmlsbE9wYWNpdHkgPSAwO1xuICAgICAgY2lyY2xlLnN0cm9rZSA9IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWwuY29sb3I7XG4gICAgICBjaXJjbGUuc3Ryb2tlV2lkdGggPSAxO1xuICAgICAgY2lyY2xlLnN0cm9rZU9wYWNpdHkgPSAxO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZU5vZGVNaWRQb2ludCgpO1xuICAgIGF3YWl0IHRoaXMudXBkYXRlU2VsZWN0aW9ucygpO1xuICAgIGF3YWl0IHRoaXMudXBkYXRlTm9kZXMoc2VyaWVzUmVjdCk7XG4gIH1cbiAgdXBkYXRlVGl0bGVOb2RlcygpIHtcbiAgICBjb25zdCB7IG9sZFRpdGxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgdGl0bGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAob2xkVGl0bGUgIT09IHRpdGxlKSB7XG4gICAgICBpZiAob2xkVGl0bGUpIHtcbiAgICAgICAgdGhpcy5sYWJlbEdyb3VwPy5yZW1vdmVDaGlsZChvbGRUaXRsZS5ub2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICB0aXRsZS5ub2RlLnRleHRCYXNlbGluZSA9IFwiYm90dG9tXCI7XG4gICAgICAgIHRoaXMubGFiZWxHcm91cD8uYXBwZW5kQ2hpbGQodGl0bGUubm9kZSk7XG4gICAgICB9XG4gICAgICB0aGlzLm9sZFRpdGxlID0gdGl0bGU7XG4gICAgfVxuICB9XG4gIHVwZGF0ZU5vZGVNaWRQb2ludCgpIHtcbiAgICBjb25zdCBzZXRNaWRQb2ludCA9IChkKSA9PiB7XG4gICAgICBjb25zdCByYWRpdXMgPSBkLmlubmVyUmFkaXVzICsgKGQub3V0ZXJSYWRpdXMgLSBkLmlubmVyUmFkaXVzKSAvIDI7XG4gICAgICBkLm1pZFBvaW50ID0ge1xuICAgICAgICB4OiBkLm1pZENvcyAqIE1hdGgubWF4KDAsIHJhZGl1cyksXG4gICAgICAgIHk6IGQubWlkU2luICogTWF0aC5tYXgoMCwgcmFkaXVzKVxuICAgICAgfTtcbiAgICB9O1xuICAgIHRoaXMubm9kZURhdGEuZm9yRWFjaChzZXRNaWRQb2ludCk7XG4gICAgdGhpcy5waGFudG9tTm9kZURhdGE/LmZvckVhY2goc2V0TWlkUG9pbnQpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVNlbGVjdGlvbnMoKSB7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVHcm91cFNlbGVjdGlvbigpO1xuICAgIHRoaXMudXBkYXRlSW5uZXJDaXJjbGVTZWxlY3Rpb24oKTtcbiAgfVxuICBhc3luYyB1cGRhdGVHcm91cFNlbGVjdGlvbigpIHtcbiAgICBjb25zdCB7XG4gICAgICBpdGVtU2VsZWN0aW9uLFxuICAgICAgaGlnaGxpZ2h0U2VsZWN0aW9uLFxuICAgICAgcGhhbnRvbVNlbGVjdGlvbixcbiAgICAgIGhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLFxuICAgICAgY2FsbG91dExhYmVsU2VsZWN0aW9uLFxuICAgICAgbGFiZWxTZWxlY3Rpb24sXG4gICAgICBpbm5lckxhYmVsc1NlbGVjdGlvblxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGhpZ2hsaWdodGVkTm9kZURhdGEgPSB0aGlzLm5vZGVEYXRhLm1hcCgoZGF0dW0pID0+ICh7XG4gICAgICAuLi5kYXR1bSxcbiAgICAgIC8vIEFsbG93IG11dGFibGUgc2VjdG9yRm9ybWF0LCBzbyBmb3JtYXR0ZWQgc2VjdG9yIHN0eWxlcyBjYW4gYmUgdXBkYXRlZCBhbmQgdmFyaWVkXG4gICAgICAvLyBiZXR3ZWVuIG5vcm1hbCBhbmQgaGlnaGxpZ2h0ZWQgY2FzZXMuXG4gICAgICBzZWN0b3JGb3JtYXQ6IHsgLi4uZGF0dW0uc2VjdG9yRm9ybWF0IH1cbiAgICB9KSk7XG4gICAgY29uc3QgdXBkYXRlID0gKHNlbGVjdGlvbiwgbm9kZURhdGEpID0+IHtcbiAgICAgIHNlbGVjdGlvbi51cGRhdGUobm9kZURhdGEsIHZvaWQgMCwgKGRhdHVtKSA9PiB0aGlzLmdldERhdHVtSWQoZGF0dW0pKTtcbiAgICAgIGlmICh0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpKSB7XG4gICAgICAgIHNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB1cGRhdGUoaXRlbVNlbGVjdGlvbiwgdGhpcy5ub2RlRGF0YSk7XG4gICAgdXBkYXRlKGhpZ2hsaWdodFNlbGVjdGlvbiwgaGlnaGxpZ2h0ZWROb2RlRGF0YSk7XG4gICAgdXBkYXRlKHBoYW50b21TZWxlY3Rpb24sIHRoaXMucGhhbnRvbU5vZGVEYXRhID8/IFtdKTtcbiAgICBjYWxsb3V0TGFiZWxTZWxlY3Rpb24udXBkYXRlKHRoaXMuY2FsbG91dE5vZGVEYXRhLCAoZ3JvdXApID0+IHtcbiAgICAgIGNvbnN0IGxpbmUgPSBuZXcgTGluZSgpO1xuICAgICAgbGluZS50YWcgPSAwIC8qIENhbGxvdXQgKi87XG4gICAgICBsaW5lLnBvaW50ZXJFdmVudHMgPSAxIC8qIE5vbmUgKi87XG4gICAgICBncm91cC5hcHBlbmRDaGlsZChsaW5lKTtcbiAgICAgIGNvbnN0IHRleHQgPSBuZXcgVGV4dCgpO1xuICAgICAgdGV4dC50YWcgPSAxIC8qIExhYmVsICovO1xuICAgICAgdGV4dC5wb2ludGVyRXZlbnRzID0gMSAvKiBOb25lICovO1xuICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQodGV4dCk7XG4gICAgfSk7XG4gICAgbGFiZWxTZWxlY3Rpb24udXBkYXRlKHRoaXMubm9kZURhdGEpO1xuICAgIGhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLnVwZGF0ZShoaWdobGlnaHRlZE5vZGVEYXRhKTtcbiAgICBpbm5lckxhYmVsc1NlbGVjdGlvbi51cGRhdGUodGhpcy5wcm9wZXJ0aWVzLmlubmVyTGFiZWxzLCAobm9kZSkgPT4ge1xuICAgICAgbm9kZS5wb2ludGVyRXZlbnRzID0gMSAvKiBOb25lICovO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUlubmVyQ2lyY2xlU2VsZWN0aW9uKCkge1xuICAgIGNvbnN0IHsgaW5uZXJDaXJjbGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBsZXQgcmFkaXVzID0gMDtcbiAgICBjb25zdCBpbm5lclJhZGl1cyA9IHRoaXMuZ2V0SW5uZXJSYWRpdXMoKTtcbiAgICBpZiAoaW5uZXJSYWRpdXMgPiAwKSB7XG4gICAgICBjb25zdCBjaXJjbGVSYWRpdXMgPSBNYXRoLm1pbihpbm5lclJhZGl1cywgdGhpcy5nZXRPdXRlclJhZGl1cygpKTtcbiAgICAgIGNvbnN0IGFudGlBbGlhc2luZ1BhZGRpbmcgPSAxO1xuICAgICAgcmFkaXVzID0gTWF0aC5jZWlsKGNpcmNsZVJhZGl1cyAqIDIgKyBhbnRpQWxpYXNpbmdQYWRkaW5nKTtcbiAgICB9XG4gICAgY29uc3QgZGF0dW1zID0gaW5uZXJDaXJjbGUgPyBbeyByYWRpdXMgfV0gOiBbXTtcbiAgICB0aGlzLmlubmVyQ2lyY2xlU2VsZWN0aW9uLnVwZGF0ZShkYXR1bXMpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZU5vZGVzKHNlcmllc1JlY3QpIHtcbiAgICBjb25zdCBoaWdobGlnaHRlZERhdHVtID0gdGhpcy5jdHguaGlnaGxpZ2h0TWFuYWdlci5nZXRBY3RpdmVIaWdobGlnaHQoKTtcbiAgICBjb25zdCBpc1Zpc2libGUgPSB0aGlzLnZpc2libGUgJiYgdGhpcy5zZXJpZXNJdGVtRW5hYmxlZC5pbmRleE9mKHRydWUpID49IDA7XG4gICAgdGhpcy5yb290R3JvdXAudmlzaWJsZSA9IGlzVmlzaWJsZTtcbiAgICB0aGlzLmJhY2tncm91bmRHcm91cC52aXNpYmxlID0gaXNWaXNpYmxlO1xuICAgIHRoaXMuY29udGVudEdyb3VwLnZpc2libGUgPSBpc1Zpc2libGU7XG4gICAgdGhpcy5oaWdobGlnaHRHcm91cC52aXNpYmxlID0gaXNWaXNpYmxlICYmIGhpZ2hsaWdodGVkRGF0dW0/LnNlcmllcyA9PT0gdGhpcztcbiAgICB0aGlzLmhpZ2hsaWdodExhYmVsLnZpc2libGUgPSBpc1Zpc2libGUgJiYgaGlnaGxpZ2h0ZWREYXR1bT8uc2VyaWVzID09PSB0aGlzO1xuICAgIGlmICh0aGlzLmxhYmVsR3JvdXApIHtcbiAgICAgIHRoaXMubGFiZWxHcm91cC52aXNpYmxlID0gaXNWaXNpYmxlO1xuICAgIH1cbiAgICB0aGlzLmNvbnRlbnRHcm91cC5vcGFjaXR5ID0gdGhpcy5nZXRPcGFjaXR5KCk7XG4gICAgdGhpcy5pbm5lckNpcmNsZVNlbGVjdGlvbi5lYWNoKChub2RlLCB7IHJhZGl1cyB9KSA9PiB7XG4gICAgICBub2RlLnNldFByb3BlcnRpZXMoe1xuICAgICAgICBmaWxsOiB0aGlzLnByb3BlcnRpZXMuaW5uZXJDaXJjbGU/LmZpbGwsXG4gICAgICAgIG9wYWNpdHk6IHRoaXMucHJvcGVydGllcy5pbm5lckNpcmNsZT8uZmlsbE9wYWNpdHksXG4gICAgICAgIHNpemU6IHJhZGl1c1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3QgYW5pbWF0aW9uRGlzYWJsZWQgPSB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpO1xuICAgIGNvbnN0IHVwZGF0ZVNlY3RvckZuID0gKHNlY3RvciwgZGF0dW0sIF9pbmRleCwgaXNEYXR1bUhpZ2hsaWdodGVkKSA9PiB7XG4gICAgICBjb25zdCBmb3JtYXQgPSB0aGlzLmdldFNlY3RvckZvcm1hdChkYXR1bS5kYXR1bSwgZGF0dW0uaXRlbUlkLCBpc0RhdHVtSGlnaGxpZ2h0ZWQpO1xuICAgICAgZGF0dW0uc2VjdG9yRm9ybWF0LmZpbGwgPSBmb3JtYXQuZmlsbDtcbiAgICAgIGRhdHVtLnNlY3RvckZvcm1hdC5zdHJva2UgPSBmb3JtYXQuc3Ryb2tlO1xuICAgICAgaWYgKGFuaW1hdGlvbkRpc2FibGVkKSB7XG4gICAgICAgIHNlY3Rvci5zdGFydEFuZ2xlID0gZGF0dW0uc3RhcnRBbmdsZTtcbiAgICAgICAgc2VjdG9yLmVuZEFuZ2xlID0gZGF0dW0uZW5kQW5nbGU7XG4gICAgICAgIHNlY3Rvci5pbm5lclJhZGl1cyA9IGRhdHVtLmlubmVyUmFkaXVzO1xuICAgICAgICBzZWN0b3Iub3V0ZXJSYWRpdXMgPSBkYXR1bS5vdXRlclJhZGl1cztcbiAgICAgIH1cbiAgICAgIGlmIChpc0RhdHVtSGlnaGxpZ2h0ZWQgfHwgYW5pbWF0aW9uRGlzYWJsZWQpIHtcbiAgICAgICAgc2VjdG9yLmZpbGwgPSBmb3JtYXQuZmlsbDtcbiAgICAgICAgc2VjdG9yLnN0cm9rZSA9IGZvcm1hdC5zdHJva2U7XG4gICAgICB9XG4gICAgICBzZWN0b3Iuc3Ryb2tlV2lkdGggPSBmb3JtYXQuc3Ryb2tlV2lkdGg7XG4gICAgICBzZWN0b3IuZmlsbE9wYWNpdHkgPSBmb3JtYXQuZmlsbE9wYWNpdHk7XG4gICAgICBzZWN0b3Iuc3Ryb2tlT3BhY2l0eSA9IGZvcm1hdC5zdHJva2VPcGFjaXR5O1xuICAgICAgc2VjdG9yLmxpbmVEYXNoID0gZm9ybWF0LmxpbmVEYXNoO1xuICAgICAgc2VjdG9yLmxpbmVEYXNoT2Zmc2V0ID0gZm9ybWF0LmxpbmVEYXNoT2Zmc2V0O1xuICAgICAgc2VjdG9yLmNvcm5lclJhZGl1cyA9IGZvcm1hdC5jb3JuZXJSYWRpdXM7XG4gICAgICBzZWN0b3IuZmlsbFNoYWRvdyA9IHRoaXMucHJvcGVydGllcy5zaGFkb3c7XG4gICAgICBjb25zdCBpbnNldCA9IE1hdGgubWF4KFxuICAgICAgICAodGhpcy5wcm9wZXJ0aWVzLnNlY3RvclNwYWNpbmcgKyAoZm9ybWF0LnN0cm9rZSAhPSBudWxsID8gZm9ybWF0LnN0cm9rZVdpZHRoIDogMCkpIC8gMixcbiAgICAgICAgMFxuICAgICAgKTtcbiAgICAgIHNlY3Rvci5pbnNldCA9IGluc2V0O1xuICAgICAgc2VjdG9yLmxpbmVKb2luID0gdGhpcy5wcm9wZXJ0aWVzLnNlY3RvclNwYWNpbmcgPj0gMCB8fCBpbnNldCA+IDAgPyBcIm1pdGVyXCIgOiBcInJvdW5kXCI7XG4gICAgfTtcbiAgICB0aGlzLml0ZW1TZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0sIGluZGV4KSA9PiB1cGRhdGVTZWN0b3JGbihub2RlLCBkYXR1bSwgaW5kZXgsIGZhbHNlKSk7XG4gICAgdGhpcy5oaWdobGlnaHRTZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0sIGluZGV4KSA9PiB7XG4gICAgICBpZiAoZGF0dW0uaXRlbUlkID09PSBoaWdobGlnaHRlZERhdHVtPy5pdGVtSWQpIHtcbiAgICAgICAgbm9kZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgdXBkYXRlU2VjdG9yRm4obm9kZSwgZGF0dW0sIGluZGV4LCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucGhhbnRvbVNlbGVjdGlvbi5lYWNoKChub2RlLCBkYXR1bSwgaW5kZXgpID0+IHVwZGF0ZVNlY3RvckZuKG5vZGUsIGRhdHVtLCBpbmRleCwgZmFsc2UpKTtcbiAgICB0aGlzLnVwZGF0ZUNhbGxvdXRMaW5lTm9kZXMoKTtcbiAgICB0aGlzLnVwZGF0ZUNhbGxvdXRMYWJlbE5vZGVzKHNlcmllc1JlY3QpO1xuICAgIHRoaXMudXBkYXRlU2VjdG9yTGFiZWxOb2RlcygpO1xuICAgIHRoaXMudXBkYXRlSW5uZXJMYWJlbE5vZGVzKCk7XG4gICAgdGhpcy51cGRhdGVaZXJvc3VtUmluZ3MoKTtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVcIik7XG4gIH1cbiAgdXBkYXRlQ2FsbG91dExpbmVOb2RlcygpIHtcbiAgICBjb25zdCB7IGNhbGxvdXRMaW5lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgY2FsbG91dExlbmd0aCA9IGNhbGxvdXRMaW5lLmxlbmd0aDtcbiAgICBjb25zdCBjYWxsb3V0U3Ryb2tlV2lkdGggPSBjYWxsb3V0TGluZS5zdHJva2VXaWR0aDtcbiAgICBjb25zdCBjYWxsb3V0Q29sb3JzID0gY2FsbG91dExpbmUuY29sb3JzID8/IHRoaXMucHJvcGVydGllcy5zdHJva2VzO1xuICAgIGNvbnN0IHsgb2Zmc2V0OiBvZmZzZXQ0IH0gPSB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsO1xuICAgIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uLnNlbGVjdEJ5VGFnKDAgLyogQ2FsbG91dCAqLykuZm9yRWFjaCgobGluZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGRhdHVtID0gbGluZS5kYXR1bTtcbiAgICAgIGNvbnN0IHsgY2FsbG91dExhYmVsOiBsYWJlbCwgb3V0ZXJSYWRpdXMgfSA9IGRhdHVtO1xuICAgICAgaWYgKGxhYmVsPy50ZXh0ICYmICFsYWJlbC5oaWRkZW4gJiYgb3V0ZXJSYWRpdXMgIT09IDApIHtcbiAgICAgICAgbGluZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgbGluZS5zdHJva2VXaWR0aCA9IGNhbGxvdXRTdHJva2VXaWR0aDtcbiAgICAgICAgbGluZS5zdHJva2UgPSBjYWxsb3V0Q29sb3JzW2luZGV4ICUgY2FsbG91dENvbG9ycy5sZW5ndGhdO1xuICAgICAgICBsaW5lLmZpbGwgPSB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHgxID0gZGF0dW0ubWlkQ29zICogb3V0ZXJSYWRpdXM7XG4gICAgICAgIGNvbnN0IHkxID0gZGF0dW0ubWlkU2luICogb3V0ZXJSYWRpdXM7XG4gICAgICAgIGxldCB4MiA9IGRhdHVtLm1pZENvcyAqIChvdXRlclJhZGl1cyArIGNhbGxvdXRMZW5ndGgpO1xuICAgICAgICBsZXQgeTIgPSBkYXR1bS5taWRTaW4gKiAob3V0ZXJSYWRpdXMgKyBjYWxsb3V0TGVuZ3RoKTtcbiAgICAgICAgY29uc3QgaXNNb3ZlZCA9IGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA/PyBsYWJlbC5jb2xsaXNpb25PZmZzZXRZICE9PSAwO1xuICAgICAgICBpZiAoaXNNb3ZlZCAmJiBsYWJlbC5ib3ggIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGJveCA9IGxhYmVsLmJveDtcbiAgICAgICAgICBsZXQgY3ggPSB4MjtcbiAgICAgICAgICBsZXQgY3kgPSB5MjtcbiAgICAgICAgICBpZiAoeDIgPCBib3gueCkge1xuICAgICAgICAgICAgY3ggPSBib3gueDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHgyID4gYm94LnggKyBib3gud2lkdGgpIHtcbiAgICAgICAgICAgIGN4ID0gYm94LnggKyBib3gud2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh5MiA8IGJveC55KSB7XG4gICAgICAgICAgICBjeSA9IGJveC55O1xuICAgICAgICAgIH0gZWxzZSBpZiAoeTIgPiBib3gueSArIGJveC5oZWlnaHQpIHtcbiAgICAgICAgICAgIGN5ID0gYm94LnkgKyBib3guaGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkeCA9IGN4IC0geDI7XG4gICAgICAgICAgY29uc3QgZHkgPSBjeSAtIHkyO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aDIgPSBNYXRoLnNxcnQoTWF0aC5wb3coZHgsIDIpICsgTWF0aC5wb3coZHksIDIpKTtcbiAgICAgICAgICBjb25zdCBwYWRkZWRMZW5ndGggPSBsZW5ndGgyIC0gb2Zmc2V0NDtcbiAgICAgICAgICBpZiAocGFkZGVkTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgeDIgPSB4MiArIGR4ICogcGFkZGVkTGVuZ3RoIC8gbGVuZ3RoMjtcbiAgICAgICAgICAgIHkyID0geTIgKyBkeSAqIHBhZGRlZExlbmd0aCAvIGxlbmd0aDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxpbmUueDEgPSB4MTtcbiAgICAgICAgbGluZS55MSA9IHkxO1xuICAgICAgICBsaW5lLngyID0geDI7XG4gICAgICAgIGxpbmUueTIgPSB5MjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmUudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldExhYmVsT3ZlcmZsb3codGV4dCwgYm94LCBzZXJpZXNSZWN0KSB7XG4gICAgY29uc3Qgc2VyaWVzTGVmdCA9IHNlcmllc1JlY3QueCAtIHRoaXMuY2VudGVyWDtcbiAgICBjb25zdCBzZXJpZXNSaWdodCA9IHNlcmllc1JlY3QueCArIHNlcmllc1JlY3Qud2lkdGggLSB0aGlzLmNlbnRlclg7XG4gICAgY29uc3Qgc2VyaWVzVG9wID0gc2VyaWVzUmVjdC55IC0gdGhpcy5jZW50ZXJZO1xuICAgIGNvbnN0IHNlcmllc0JvdHRvbSA9IHNlcmllc1JlY3QueSArIHNlcmllc1JlY3QuaGVpZ2h0IC0gdGhpcy5jZW50ZXJZO1xuICAgIGNvbnN0IGVyclB4ID0gMTtcbiAgICBsZXQgdmlzaWJsZVRleHRQYXJ0ID0gMTtcbiAgICBpZiAoYm94LnggKyBlcnJQeCA8IHNlcmllc0xlZnQpIHtcbiAgICAgIHZpc2libGVUZXh0UGFydCA9IChib3gueCArIGJveC53aWR0aCAtIHNlcmllc0xlZnQpIC8gYm94LndpZHRoO1xuICAgIH0gZWxzZSBpZiAoYm94LnggKyBib3gud2lkdGggLSBlcnJQeCA+IHNlcmllc1JpZ2h0KSB7XG4gICAgICB2aXNpYmxlVGV4dFBhcnQgPSAoc2VyaWVzUmlnaHQgLSBib3gueCkgLyBib3gud2lkdGg7XG4gICAgfVxuICAgIGNvbnN0IGhhc1ZlcnRpY2FsT3ZlcmZsb3cgPSBib3gueSArIGVyclB4IDwgc2VyaWVzVG9wIHx8IGJveC55ICsgYm94LmhlaWdodCAtIGVyclB4ID4gc2VyaWVzQm90dG9tO1xuICAgIGNvbnN0IHRleHRMZW5ndGggPSB2aXNpYmxlVGV4dFBhcnQgPT09IDEgPyB0ZXh0Lmxlbmd0aCA6IE1hdGguZmxvb3IodGV4dC5sZW5ndGggKiB2aXNpYmxlVGV4dFBhcnQpIC0gMTtcbiAgICBjb25zdCBoYXNTdXJyb3VuZGluZ1Nlcmllc092ZXJmbG93ID0gdGhpcy5iYm94SW50ZXJzZWN0c1N1cnJvdW5kaW5nU2VyaWVzKGJveCk7XG4gICAgcmV0dXJuIHsgdGV4dExlbmd0aCwgaGFzVmVydGljYWxPdmVyZmxvdywgaGFzU3Vycm91bmRpbmdTZXJpZXNPdmVyZmxvdyB9O1xuICB9XG4gIGJib3hJbnRlcnNlY3RzU3Vycm91bmRpbmdTZXJpZXMoYm94LCBkeCA9IDAsIGR5ID0gMCkge1xuICAgIGNvbnN0IHsgc3Vycm91bmRpbmdSYWRpdXMgfSA9IHRoaXM7XG4gICAgaWYgKHN1cnJvdW5kaW5nUmFkaXVzID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgY29ybmVycyA9IFtcbiAgICAgIHsgeDogYm94LnggKyBkeCwgeTogYm94LnkgKyBkeSB9LFxuICAgICAgeyB4OiBib3gueCArIGJveC53aWR0aCArIGR4LCB5OiBib3gueSArIGR5IH0sXG4gICAgICB7IHg6IGJveC54ICsgYm94LndpZHRoICsgZHgsIHk6IGJveC55ICsgYm94LmhlaWdodCArIGR5IH0sXG4gICAgICB7IHg6IGJveC54ICsgZHgsIHk6IGJveC55ICsgYm94LmhlaWdodCArIGR5IH1cbiAgICBdO1xuICAgIGNvbnN0IHN1cjIgPSBzdXJyb3VuZGluZ1JhZGl1cyAqKiAyO1xuICAgIHJldHVybiBjb3JuZXJzLnNvbWUoKGNvcm5lcikgPT4gY29ybmVyLnggKiogMiArIGNvcm5lci55ICoqIDIgPiBzdXIyKTtcbiAgfVxuICBjb21wdXRlQ2FsbG91dExhYmVsQ29sbGlzaW9uT2Zmc2V0cygpIHtcbiAgICBjb25zdCB7IHJhZGl1c1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsLCBjYWxsb3V0TGluZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgb2Zmc2V0OiBvZmZzZXQ0LCBtaW5TcGFjaW5nIH0gPSBjYWxsb3V0TGFiZWw7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSByYWRpdXNTY2FsZS5jb252ZXJ0KDApO1xuICAgIGNvbnN0IHNob3VsZFNraXAgPSAoZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsID0gZGF0dW0uY2FsbG91dExhYmVsO1xuICAgICAgcmV0dXJuICFsYWJlbCB8fCBkYXR1bS5vdXRlclJhZGl1cyA9PT0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGZ1bGxEYXRhID0gdGhpcy5jYWxsb3V0Tm9kZURhdGE7XG4gICAgY29uc3QgZGF0YSA9IGZ1bGxEYXRhLmZpbHRlcigodCkgPT4gIXNob3VsZFNraXAodCkpO1xuICAgIGRhdGEuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsID0gZGF0dW0uY2FsbG91dExhYmVsO1xuICAgICAgaWYgKGxhYmVsID09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxhYmVsLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID0gdm9pZCAwO1xuICAgICAgbGFiZWwuY29sbGlzaW9uT2Zmc2V0WSA9IDA7XG4gICAgfSk7XG4gICAgaWYgKGRhdGEubGVuZ3RoIDw9IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGVmdExhYmVscyA9IGRhdGEuZmlsdGVyKChkKSA9PiBkLm1pZENvcyA8IDApLnNvcnQoKGEsIGIpID0+IGEubWlkU2luIC0gYi5taWRTaW4pO1xuICAgIGNvbnN0IHJpZ2h0TGFiZWxzID0gZGF0YS5maWx0ZXIoKGQpID0+IGQubWlkQ29zID49IDApLnNvcnQoKGEsIGIpID0+IGEubWlkU2luIC0gYi5taWRTaW4pO1xuICAgIGNvbnN0IHRvcExhYmVscyA9IGRhdGEuZmlsdGVyKChkKSA9PiBkLm1pZFNpbiA8IDAgJiYgZC5jYWxsb3V0TGFiZWw/LnRleHRBbGlnbiA9PT0gXCJjZW50ZXJcIikuc29ydCgoYSwgYikgPT4gYS5taWRDb3MgLSBiLm1pZENvcyk7XG4gICAgY29uc3QgYm90dG9tTGFiZWxzID0gZGF0YS5maWx0ZXIoKGQpID0+IGQubWlkU2luID49IDAgJiYgZC5jYWxsb3V0TGFiZWw/LnRleHRBbGlnbiA9PT0gXCJjZW50ZXJcIikuc29ydCgoYSwgYikgPT4gYS5taWRDb3MgLSBiLm1pZENvcyk7XG4gICAgY29uc3QgZ2V0VGV4dEJCb3ggPSAoZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsID0gZGF0dW0uY2FsbG91dExhYmVsO1xuICAgICAgaWYgKGxhYmVsID09IG51bGwpXG4gICAgICAgIHJldHVybiBCQm94Lnplcm8uY2xvbmUoKTtcbiAgICAgIGNvbnN0IGxhYmVsUmFkaXVzID0gZGF0dW0ub3V0ZXJSYWRpdXMgKyBjYWxsb3V0TGluZS5sZW5ndGggKyBvZmZzZXQ0O1xuICAgICAgY29uc3QgeCA9IGRhdHVtLm1pZENvcyAqIGxhYmVsUmFkaXVzO1xuICAgICAgY29uc3QgeSA9IGRhdHVtLm1pZFNpbiAqIGxhYmVsUmFkaXVzICsgbGFiZWwuY29sbGlzaW9uT2Zmc2V0WTtcbiAgICAgIGNvbnN0IHRleHRBbGlnbiA9IGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA/PyBsYWJlbC50ZXh0QWxpZ247XG4gICAgICBjb25zdCB0ZXh0QmFzZWxpbmUgPSBsYWJlbC50ZXh0QmFzZWxpbmU7XG4gICAgICByZXR1cm4gVGV4dC5jb21wdXRlQkJveChsYWJlbC50ZXh0LCB4LCB5LCB7XG4gICAgICAgIGZvbnQ6IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWwsXG4gICAgICAgIHRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGF2b2lkTmVpZ2hib3VyWUNvbGxpc2lvbiA9IChsYWJlbCwgbmV4dCwgZGlyZWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCBib3ggPSBnZXRUZXh0QkJveChsYWJlbCkuZ3JvdyhtaW5TcGFjaW5nIC8gMik7XG4gICAgICBjb25zdCBvdGhlciA9IGdldFRleHRCQm94KG5leHQpLmdyb3cobWluU3BhY2luZyAvIDIpO1xuICAgICAgY29uc3QgY29sbGlkZXNPckJlaGluZCA9IGJveC54IDwgb3RoZXIueCArIG90aGVyLndpZHRoICYmIGJveC54ICsgYm94LndpZHRoID4gb3RoZXIueCAmJiAoZGlyZWN0aW9uID09PSBcInRvLXRvcFwiID8gYm94LnkgPCBvdGhlci55ICsgb3RoZXIuaGVpZ2h0IDogYm94LnkgKyBib3guaGVpZ2h0ID4gb3RoZXIueSk7XG4gICAgICBpZiAoY29sbGlkZXNPckJlaGluZCkge1xuICAgICAgICBjb25zdCBkeSA9IGRpcmVjdGlvbiA9PT0gXCJ0by10b3BcIiA/IGJveC55IC0gb3RoZXIueSAtIG90aGVyLmhlaWdodCA6IGJveC55ICsgYm94LmhlaWdodCAtIG90aGVyLnk7XG4gICAgICAgIG5leHQuY2FsbG91dExhYmVsLmNvbGxpc2lvbk9mZnNldFkgPSBkeTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGF2b2lkWUNvbGxpc2lvbnMgPSAobGFiZWxzKSA9PiB7XG4gICAgICBjb25zdCBtaWRMYWJlbCA9IGxhYmVscy5zbGljZSgpLnNvcnQoKGEsIGIpID0+IE1hdGguYWJzKGEubWlkU2luKSAtIE1hdGguYWJzKGIubWlkU2luKSlbMF07XG4gICAgICBjb25zdCBtaWRJbmRleCA9IGxhYmVscy5pbmRleE9mKG1pZExhYmVsKTtcbiAgICAgIGZvciAobGV0IGkgPSBtaWRJbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBsYWJlbHNbaSArIDFdO1xuICAgICAgICBjb25zdCBuZXh0ID0gbGFiZWxzW2ldO1xuICAgICAgICBhdm9pZE5laWdoYm91cllDb2xsaXNpb24ocHJldiwgbmV4dCwgXCJ0by10b3BcIik7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gbWlkSW5kZXggKyAxOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBsYWJlbHNbaSAtIDFdO1xuICAgICAgICBjb25zdCBuZXh0ID0gbGFiZWxzW2ldO1xuICAgICAgICBhdm9pZE5laWdoYm91cllDb2xsaXNpb24ocHJldiwgbmV4dCwgXCJ0by1ib3R0b21cIik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBhdm9pZFhDb2xsaXNpb25zID0gKGxhYmVscykgPT4ge1xuICAgICAgY29uc3QgbGFiZWxzQ29sbGlkZUxhYmVsc0J5WSA9IGRhdGEuc29tZSgoZGF0dW0pID0+IGRhdHVtLmNhbGxvdXRMYWJlbC5jb2xsaXNpb25PZmZzZXRZICE9PSAwKTtcbiAgICAgIGNvbnN0IGJveGVzID0gbGFiZWxzLm1hcCgobGFiZWwpID0+IGdldFRleHRCQm94KGxhYmVsKSk7XG4gICAgICBjb25zdCBwYWRkZWRCb3hlcyA9IGJveGVzLm1hcCgoYm94KSA9PiBib3guY2xvbmUoKS5ncm93KG1pblNwYWNpbmcgLyAyKSk7XG4gICAgICBsZXQgbGFiZWxzQ29sbGlkZUxhYmVsc0J5WCA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWRkZWRCb3hlcy5sZW5ndGggJiYgIWxhYmVsc0NvbGxpZGVMYWJlbHNCeVg7IGkrKykge1xuICAgICAgICBjb25zdCBib3ggPSBwYWRkZWRCb3hlc1tpXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbGFiZWxzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3Qgb3RoZXIgPSBwYWRkZWRCb3hlc1tqXTtcbiAgICAgICAgICBpZiAoYm94LmNvbGxpZGVzQkJveChvdGhlcikpIHtcbiAgICAgICAgICAgIGxhYmVsc0NvbGxpZGVMYWJlbHNCeVggPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzZWN0b3JzID0gZnVsbERhdGEubWFwKChkYXR1bSkgPT4ge1xuICAgICAgICBjb25zdCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBvdXRlclJhZGl1cyB9ID0gZGF0dW07XG4gICAgICAgIHJldHVybiB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbGFiZWxzQ29sbGlkZVNlY3RvcnMgPSBib3hlcy5zb21lKChib3gpID0+IHtcbiAgICAgICAgcmV0dXJuIHNlY3RvcnMuc29tZSgoc2VjdG9yKSA9PiBib3hDb2xsaWRlc1NlY3Rvcihib3gsIHNlY3RvcikpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWxhYmVsc0NvbGxpZGVMYWJlbHNCeVggJiYgIWxhYmVsc0NvbGxpZGVMYWJlbHNCeVkgJiYgIWxhYmVsc0NvbGxpZGVTZWN0b3JzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxhYmVscy5maWx0ZXIoKGQpID0+IGQuY2FsbG91dExhYmVsLnRleHRBbGlnbiA9PT0gXCJjZW50ZXJcIikuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICBjb25zdCBsYWJlbCA9IGQuY2FsbG91dExhYmVsO1xuICAgICAgICBpZiAoZC5taWRDb3MgPCAwKSB7XG4gICAgICAgICAgbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID0gXCJyaWdodFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGQubWlkQ29zID4gMCkge1xuICAgICAgICAgIGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgYXZvaWRZQ29sbGlzaW9ucyhsZWZ0TGFiZWxzKTtcbiAgICBhdm9pZFlDb2xsaXNpb25zKHJpZ2h0TGFiZWxzKTtcbiAgICBhdm9pZFhDb2xsaXNpb25zKHRvcExhYmVscyk7XG4gICAgYXZvaWRYQ29sbGlzaW9ucyhib3R0b21MYWJlbHMpO1xuICB9XG4gIHVwZGF0ZUNhbGxvdXRMYWJlbE5vZGVzKHNlcmllc1JlY3QpIHtcbiAgICBjb25zdCB7IHJhZGl1c1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsLCBjYWxsb3V0TGluZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNhbGxvdXRMZW5ndGggPSBjYWxsb3V0TGluZS5sZW5ndGg7XG4gICAgY29uc3QgeyBvZmZzZXQ6IG9mZnNldDQsIGNvbG9yIH0gPSBjYWxsb3V0TGFiZWw7XG4gICAgY29uc3QgdGVtcFRleHROb2RlID0gbmV3IFRleHQoKTtcbiAgICB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbi5zZWxlY3RCeVRhZygxIC8qIExhYmVsICovKS5mb3JFYWNoKCh0ZXh0KSA9PiB7XG4gICAgICBjb25zdCB7IGRhdHVtIH0gPSB0ZXh0O1xuICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XG4gICAgICBjb25zdCByYWRpdXMgPSByYWRpdXNTY2FsZS5jb252ZXJ0KGRhdHVtLnJhZGl1cyk7XG4gICAgICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KDAsIHJhZGl1cyk7XG4gICAgICBpZiAoIWxhYmVsPy50ZXh0IHx8IG91dGVyUmFkaXVzID09PSAwIHx8IGxhYmVsLmhpZGRlbikge1xuICAgICAgICB0ZXh0LnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFiZWxSYWRpdXMgPSBvdXRlclJhZGl1cyArIGNhbGxvdXRMZW5ndGggKyBvZmZzZXQ0O1xuICAgICAgY29uc3QgeCA9IGRhdHVtLm1pZENvcyAqIGxhYmVsUmFkaXVzO1xuICAgICAgY29uc3QgeSA9IGRhdHVtLm1pZFNpbiAqIGxhYmVsUmFkaXVzICsgbGFiZWwuY29sbGlzaW9uT2Zmc2V0WTtcbiAgICAgIGNvbnN0IGFsaWduID0ge1xuICAgICAgICB0ZXh0QWxpZ246IGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA/PyBsYWJlbC50ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogbGFiZWwudGV4dEJhc2VsaW5lXG4gICAgICB9O1xuICAgICAgdGVtcFRleHROb2RlLnRleHQgPSBsYWJlbC50ZXh0O1xuICAgICAgdGVtcFRleHROb2RlLnggPSB4O1xuICAgICAgdGVtcFRleHROb2RlLnkgPSB5O1xuICAgICAgdGVtcFRleHROb2RlLnNldEZvbnQodGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbCk7XG4gICAgICB0ZW1wVGV4dE5vZGUuc2V0QWxpZ24oYWxpZ24pO1xuICAgICAgY29uc3QgYm94ID0gdGVtcFRleHROb2RlLmdldEJCb3goKTtcbiAgICAgIGxldCBkaXNwbGF5VGV4dCA9IGxhYmVsLnRleHQ7XG4gICAgICBsZXQgdmlzaWJsZSA9IHRydWU7XG4gICAgICBpZiAoY2FsbG91dExhYmVsLmF2b2lkQ29sbGlzaW9ucykge1xuICAgICAgICBjb25zdCB7IHRleHRMZW5ndGgsIGhhc1ZlcnRpY2FsT3ZlcmZsb3cgfSA9IHRoaXMuZ2V0TGFiZWxPdmVyZmxvdyhsYWJlbC50ZXh0LCBib3gsIHNlcmllc1JlY3QpO1xuICAgICAgICBkaXNwbGF5VGV4dCA9IGxhYmVsLnRleHQubGVuZ3RoID09PSB0ZXh0TGVuZ3RoID8gbGFiZWwudGV4dCA6IGAke2xhYmVsLnRleHQuc3Vic3RyaW5nKDAsIHRleHRMZW5ndGgpfVxcdTIwMjZgO1xuICAgICAgICB2aXNpYmxlID0gIWhhc1ZlcnRpY2FsT3ZlcmZsb3c7XG4gICAgICB9XG4gICAgICB0ZXh0LnRleHQgPSBkaXNwbGF5VGV4dDtcbiAgICAgIHRleHQueCA9IHg7XG4gICAgICB0ZXh0LnkgPSB5O1xuICAgICAgdGV4dC5zZXRGb250KHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWwpO1xuICAgICAgdGV4dC5zZXRBbGlnbihhbGlnbik7XG4gICAgICB0ZXh0LmZpbGwgPSBjb2xvcjtcbiAgICAgIHRleHQudmlzaWJsZSA9IHZpc2libGU7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgY29tcHV0ZUxhYmVsc0JCb3gob3B0aW9ucywgc2VyaWVzUmVjdCkge1xuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsLCBjYWxsb3V0TGluZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNhbGxvdXRMZW5ndGggPSBjYWxsb3V0TGluZS5sZW5ndGg7XG4gICAgY29uc3QgeyBvZmZzZXQ6IG9mZnNldDQsIG1heENvbGxpc2lvbk9mZnNldCwgbWluU3BhY2luZyB9ID0gY2FsbG91dExhYmVsO1xuICAgIGlmICghY2FsbG91dExhYmVsLmF2b2lkQ29sbGlzaW9ucykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMubWF5YmVSZWZyZXNoTm9kZURhdGEoKTtcbiAgICB0aGlzLnVwZGF0ZVJhZGl1c1NjYWxlKGZhbHNlKTtcbiAgICB0aGlzLmNvbXB1dGVDYWxsb3V0TGFiZWxDb2xsaXNpb25PZmZzZXRzKCk7XG4gICAgY29uc3QgdGV4dEJveGVzID0gW107XG4gICAgY29uc3QgdGV4dCA9IG5ldyBUZXh0KCk7XG4gICAgbGV0IHRpdGxlQm94O1xuICAgIGNvbnN0IHsgdGl0bGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAodGl0bGU/LnRleHQgJiYgdGl0bGUuZW5hYmxlZCkge1xuICAgICAgY29uc3QgZHkgPSB0aGlzLmdldFRpdGxlVHJhbnNsYXRpb25ZKCk7XG4gICAgICBpZiAoaXNGaW5pdGUoZHkpKSB7XG4gICAgICAgIHRleHQudGV4dCA9IHRpdGxlLnRleHQ7XG4gICAgICAgIHRleHQueCA9IDA7XG4gICAgICAgIHRleHQueSA9IGR5O1xuICAgICAgICB0ZXh0LnNldEZvbnQodGl0bGUpO1xuICAgICAgICB0ZXh0LnNldEFsaWduKHtcbiAgICAgICAgICB0ZXh0QmFzZWxpbmU6IFwiYm90dG9tXCIsXG4gICAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aXRsZUJveCA9IHRleHQuZ2V0QkJveCgpO1xuICAgICAgICB0ZXh0Qm94ZXMucHVzaCh0aXRsZUJveCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2FsbG91dE5vZGVEYXRhLmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmNhbGxvdXRMYWJlbDtcbiAgICAgIGlmICghbGFiZWwgfHwgZGF0dW0ub3V0ZXJSYWRpdXMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBsYWJlbFJhZGl1cyA9IGRhdHVtLm91dGVyUmFkaXVzICsgY2FsbG91dExlbmd0aCArIG9mZnNldDQ7XG4gICAgICBjb25zdCB4ID0gZGF0dW0ubWlkQ29zICogbGFiZWxSYWRpdXM7XG4gICAgICBjb25zdCB5ID0gZGF0dW0ubWlkU2luICogbGFiZWxSYWRpdXMgKyBsYWJlbC5jb2xsaXNpb25PZmZzZXRZO1xuICAgICAgdGV4dC50ZXh0ID0gbGFiZWwudGV4dDtcbiAgICAgIHRleHQueCA9IHg7XG4gICAgICB0ZXh0LnkgPSB5O1xuICAgICAgdGV4dC5zZXRGb250KHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWwpO1xuICAgICAgdGV4dC5zZXRBbGlnbih7XG4gICAgICAgIHRleHRBbGlnbjogbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID8/IGxhYmVsLnRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiBsYWJlbC50ZXh0QmFzZWxpbmVcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYm94ID0gdGV4dC5nZXRCQm94KCk7XG4gICAgICBsYWJlbC5ib3ggPSBib3g7XG4gICAgICBpZiAoTWF0aC5hYnMobGFiZWwuY29sbGlzaW9uT2Zmc2V0WSkgPiBtYXhDb2xsaXNpb25PZmZzZXQpIHtcbiAgICAgICAgbGFiZWwuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRpdGxlQm94KSB7XG4gICAgICAgIGNvbnN0IHNlcmllc1RvcCA9IHNlcmllc1JlY3QueSAtIHRoaXMuY2VudGVyWTtcbiAgICAgICAgY29uc3QgdGl0bGVDbGVhbkFyZWEgPSBuZXcgQkJveChcbiAgICAgICAgICB0aXRsZUJveC54IC0gbWluU3BhY2luZyxcbiAgICAgICAgICBzZXJpZXNUb3AsXG4gICAgICAgICAgdGl0bGVCb3gud2lkdGggKyAyICogbWluU3BhY2luZyxcbiAgICAgICAgICB0aXRsZUJveC55ICsgdGl0bGVCb3guaGVpZ2h0ICsgbWluU3BhY2luZyAtIHNlcmllc1RvcFxuICAgICAgICApO1xuICAgICAgICBpZiAoYm94LmNvbGxpZGVzQkJveCh0aXRsZUNsZWFuQXJlYSkpIHtcbiAgICAgICAgICBsYWJlbC5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuaGlkZVdoZW5OZWNlc3NhcnkpIHtcbiAgICAgICAgY29uc3QgeyB0ZXh0TGVuZ3RoLCBoYXNWZXJ0aWNhbE92ZXJmbG93LCBoYXNTdXJyb3VuZGluZ1Nlcmllc092ZXJmbG93IH0gPSB0aGlzLmdldExhYmVsT3ZlcmZsb3coXG4gICAgICAgICAgbGFiZWwudGV4dCxcbiAgICAgICAgICBib3gsXG4gICAgICAgICAgc2VyaWVzUmVjdFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBpc1Rvb1Nob3J0ID0gbGFiZWwudGV4dC5sZW5ndGggPiAyICYmIHRleHRMZW5ndGggPCAyO1xuICAgICAgICBpZiAoaGFzVmVydGljYWxPdmVyZmxvdyB8fCBpc1Rvb1Nob3J0IHx8IGhhc1N1cnJvdW5kaW5nU2VyaWVzT3ZlcmZsb3cpIHtcbiAgICAgICAgICBsYWJlbC5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFiZWwuaGlkZGVuID0gZmFsc2U7XG4gICAgICB0ZXh0Qm94ZXMucHVzaChib3gpO1xuICAgIH0pO1xuICAgIGlmICh0ZXh0Qm94ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEJCb3gubWVyZ2UodGV4dEJveGVzKTtcbiAgfVxuICB1cGRhdGVTZWN0b3JMYWJlbE5vZGVzKCkge1xuICAgIGNvbnN0IHsgcmFkaXVzU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSByYWRpdXNTY2FsZS5jb252ZXJ0KDApO1xuICAgIGNvbnN0IHsgZm9udFNpemUsIGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udEZhbWlseSwgcG9zaXRpb25PZmZzZXQsIHBvc2l0aW9uUmF0aW8sIGNvbG9yIH0gPSB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWw7XG4gICAgY29uc3QgdXBkYXRlU2VjdG9yTGFiZWwgPSAodGV4dCwgZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IHsgc2VjdG9yTGFiZWwsIG91dGVyUmFkaXVzIH0gPSBkYXR1bTtcbiAgICAgIGxldCBpc1RleHRWaXNpYmxlID0gZmFsc2U7XG4gICAgICBpZiAoc2VjdG9yTGFiZWwgJiYgb3V0ZXJSYWRpdXMgIT09IDApIHtcbiAgICAgICAgY29uc3QgbGFiZWxSYWRpdXMgPSBpbm5lclJhZGl1cyAqICgxIC0gcG9zaXRpb25SYXRpbykgKyBvdXRlclJhZGl1cyAqIHBvc2l0aW9uUmF0aW8gKyBwb3NpdGlvbk9mZnNldDtcbiAgICAgICAgdGV4dC5maWxsID0gY29sb3I7XG4gICAgICAgIHRleHQuZm9udFN0eWxlID0gZm9udFN0eWxlO1xuICAgICAgICB0ZXh0LmZvbnRXZWlnaHQgPSBmb250V2VpZ2h0O1xuICAgICAgICB0ZXh0LmZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICAgIHRleHQuZm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgICAgIHRleHQudGV4dCA9IHNlY3RvckxhYmVsLnRleHQ7XG4gICAgICAgIHRleHQueCA9IGRhdHVtLm1pZENvcyAqIGxhYmVsUmFkaXVzO1xuICAgICAgICB0ZXh0LnkgPSBkYXR1bS5taWRTaW4gKiBsYWJlbFJhZGl1cztcbiAgICAgICAgdGV4dC50ZXh0QWxpZ24gPSBcImNlbnRlclwiO1xuICAgICAgICB0ZXh0LnRleHRCYXNlbGluZSA9IFwibWlkZGxlXCI7XG4gICAgICAgIGNvbnN0IGJib3ggPSB0ZXh0LmdldEJCb3goKTtcbiAgICAgICAgY29uc3QgY29ybmVycyA9IFtcbiAgICAgICAgICBbYmJveC54LCBiYm94LnldLFxuICAgICAgICAgIFtiYm94LnggKyBiYm94LndpZHRoLCBiYm94LnldLFxuICAgICAgICAgIFtiYm94LnggKyBiYm94LndpZHRoLCBiYm94LnkgKyBiYm94LmhlaWdodF0sXG4gICAgICAgICAgW2Jib3gueCwgYmJveC55ICsgYmJveC5oZWlnaHRdXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHsgc3RhcnRBbmdsZSwgZW5kQW5nbGUgfSA9IGRhdHVtO1xuICAgICAgICBjb25zdCBzZWN0b3JCb3VuZHMgPSB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfTtcbiAgICAgICAgaWYgKGNvcm5lcnMuZXZlcnkoKFt4LCB5XSkgPT4gaXNQb2ludEluU2VjdG9yKHgsIHksIHNlY3RvckJvdW5kcykpKSB7XG4gICAgICAgICAgaXNUZXh0VmlzaWJsZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRleHQudmlzaWJsZSA9IGlzVGV4dFZpc2libGU7XG4gICAgfTtcbiAgICB0aGlzLmxhYmVsU2VsZWN0aW9uLmVhY2godXBkYXRlU2VjdG9yTGFiZWwpO1xuICAgIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24uZWFjaCh1cGRhdGVTZWN0b3JMYWJlbCk7XG4gIH1cbiAgdXBkYXRlSW5uZXJMYWJlbE5vZGVzKCkge1xuICAgIGNvbnN0IHRleHRCQm94ZXMgPSBbXTtcbiAgICBjb25zdCBtYXJnaW5zID0gW107XG4gICAgdGhpcy5pbm5lckxhYmVsc1NlbGVjdGlvbi5lYWNoKCh0ZXh0LCBkYXR1bSkgPT4ge1xuICAgICAgY29uc3QgeyBmb250U3R5bGUsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5LCBjb2xvciB9ID0gZGF0dW07XG4gICAgICB0ZXh0LmZvbnRTdHlsZSA9IGZvbnRTdHlsZTtcbiAgICAgIHRleHQuZm9udFdlaWdodCA9IGZvbnRXZWlnaHQ7XG4gICAgICB0ZXh0LmZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICB0ZXh0LmZvbnRGYW1pbHkgPSBmb250RmFtaWx5O1xuICAgICAgdGV4dC50ZXh0ID0gZGF0dW0udGV4dDtcbiAgICAgIHRleHQueCA9IDA7XG4gICAgICB0ZXh0LnkgPSAwO1xuICAgICAgdGV4dC5maWxsID0gY29sb3I7XG4gICAgICB0ZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICB0ZXh0LnRleHRCYXNlbGluZSA9IFwiYWxwaGFiZXRpY1wiO1xuICAgICAgdGV4dEJCb3hlcy5wdXNoKHRleHQuZ2V0QkJveCgpKTtcbiAgICAgIG1hcmdpbnMucHVzaChkYXR1bS5zcGFjaW5nKTtcbiAgICB9KTtcbiAgICBjb25zdCBnZXRNYXJnaW5Ub3AgPSAoaW5kZXgpID0+IGluZGV4ID09PSAwID8gMCA6IG1hcmdpbnNbaW5kZXhdO1xuICAgIGNvbnN0IGdldE1hcmdpbkJvdHRvbSA9IChpbmRleCkgPT4gaW5kZXggPT09IG1hcmdpbnMubGVuZ3RoIC0gMSA/IDAgOiBtYXJnaW5zW2luZGV4XTtcbiAgICBjb25zdCB0b3RhbEhlaWdodCA9IHRleHRCQm94ZXMucmVkdWNlKChzdW0yLCBiYm94LCBpKSA9PiB7XG4gICAgICByZXR1cm4gc3VtMiArIGJib3guaGVpZ2h0ICsgZ2V0TWFyZ2luVG9wKGkpICsgZ2V0TWFyZ2luQm90dG9tKGkpO1xuICAgIH0sIDApO1xuICAgIGNvbnN0IHRvdGFsV2lkdGggPSBNYXRoLm1heCguLi50ZXh0QkJveGVzLm1hcCgoYmJveCkgPT4gYmJveC53aWR0aCkpO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzID0gdGhpcy5nZXRJbm5lclJhZGl1cygpO1xuICAgIGNvbnN0IGxhYmVsUmFkaXVzID0gTWF0aC5zcXJ0KE1hdGgucG93KHRvdGFsV2lkdGggLyAyLCAyKSArIE1hdGgucG93KHRvdGFsSGVpZ2h0IC8gMiwgMikpO1xuICAgIGNvbnN0IGxhYmVsc1Zpc2libGUgPSBsYWJlbFJhZGl1cyA8PSAoaW5uZXJSYWRpdXMgPiAwID8gaW5uZXJSYWRpdXMgOiB0aGlzLmdldE91dGVyUmFkaXVzKCkpO1xuICAgIGNvbnN0IHRleHRCb3R0b21zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDAsIHByZXYgPSAtdG90YWxIZWlnaHQgLyAyOyBpIDwgdGV4dEJCb3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYmJveCA9IHRleHRCQm94ZXNbaV07XG4gICAgICBjb25zdCBib3R0b20gPSBiYm94LmhlaWdodCArIHByZXYgKyBnZXRNYXJnaW5Ub3AoaSk7XG4gICAgICB0ZXh0Qm90dG9tcy5wdXNoKGJvdHRvbSk7XG4gICAgICBwcmV2ID0gYm90dG9tICsgZ2V0TWFyZ2luQm90dG9tKGkpO1xuICAgIH1cbiAgICB0aGlzLmlubmVyTGFiZWxzU2VsZWN0aW9uLmVhY2goKHRleHQsIF9kYXR1bSwgaW5kZXgpID0+IHtcbiAgICAgIHRleHQueSA9IHRleHRCb3R0b21zW2luZGV4XTtcbiAgICAgIHRleHQudmlzaWJsZSA9IGxhYmVsc1Zpc2libGU7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlWmVyb3N1bVJpbmdzKCkge1xuICAgIHRoaXMuemVyb3N1bU91dGVyUmluZy5zaXplID0gdGhpcy5nZXRPdXRlclJhZGl1cygpICogMjtcbiAgICB0aGlzLnplcm9zdW1Jbm5lclJpbmcuc2l6ZSA9IHRoaXMuZ2V0SW5uZXJSYWRpdXMoKSAqIDI7XG4gIH1cbiAgZ2V0RGF0dW1MZWdlbmROYW1lKG5vZGVEYXR1bSkge1xuICAgIGNvbnN0IHsgYW5nbGVLZXksIGNhbGxvdXRMYWJlbEtleSwgc2VjdG9yTGFiZWxLZXksIGxlZ2VuZEl0ZW1LZXkgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IHNlY3RvckxhYmVsLCBjYWxsb3V0TGFiZWwsIGxlZ2VuZEl0ZW0gfSA9IG5vZGVEYXR1bTtcbiAgICBpZiAobGVnZW5kSXRlbUtleSAmJiBsZWdlbmRJdGVtICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBsZWdlbmRJdGVtLnRleHQ7XG4gICAgfSBlbHNlIGlmIChjYWxsb3V0TGFiZWxLZXkgJiYgY2FsbG91dExhYmVsS2V5ICE9PSBhbmdsZUtleSAmJiBjYWxsb3V0TGFiZWw/LnRleHQgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGNhbGxvdXRMYWJlbC50ZXh0O1xuICAgIH0gZWxzZSBpZiAoc2VjdG9yTGFiZWxLZXkgJiYgc2VjdG9yTGFiZWxLZXkgIT09IGFuZ2xlS2V5ICYmIHNlY3RvckxhYmVsPy50ZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBzZWN0b3JMYWJlbC50ZXh0O1xuICAgIH1cbiAgfVxuICBwaWNrTm9kZUNsb3Nlc3REYXR1bShwb2ludCkge1xuICAgIHJldHVybiBwaWNrQnlNYXRjaGluZ0FuZ2xlKHRoaXMsIHBvaW50KTtcbiAgfVxuICBnZXRUb29sdGlwSHRtbChub2RlRGF0dW0pIHtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybiBFTVBUWV9UT09MVElQX0NPTlRFTlQ7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRhdHVtLFxuICAgICAgYW5nbGVWYWx1ZSxcbiAgICAgIHNlY3RvckZvcm1hdDogeyBmaWxsOiBjb2xvciB9LFxuICAgICAgaXRlbUlkXG4gICAgfSA9IG5vZGVEYXR1bTtcbiAgICBjb25zdCB0aXRsZSA9IHNhbml0aXplSHRtbCh0aGlzLnByb3BlcnRpZXMudGl0bGU/LnRleHQpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBpc0Zpbml0ZU51bWJlcihhbmdsZVZhbHVlKSA/IHRvRml4ZWQoYW5nbGVWYWx1ZSkgOiBTdHJpbmcoYW5nbGVWYWx1ZSk7XG4gICAgY29uc3QgbGFiZWxUZXh0ID0gdGhpcy5nZXREYXR1bUxlZ2VuZE5hbWUobm9kZURhdHVtKTtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnRvb2x0aXAudG9Ub29sdGlwSHRtbChcbiAgICAgIHtcbiAgICAgICAgdGl0bGU6IHRpdGxlID8/IGxhYmVsVGV4dCxcbiAgICAgICAgY29udGVudDogdGl0bGUgJiYgbGFiZWxUZXh0ID8gYCR7bGFiZWxUZXh0fTogJHtjb250ZW50fWAgOiBjb250ZW50LFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBkYXR1bSxcbiAgICAgICAgaXRlbUlkLFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICBhbmdsZUtleTogdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlS2V5LFxuICAgICAgICBhbmdsZU5hbWU6IHRoaXMucHJvcGVydGllcy5hbmdsZU5hbWUsXG4gICAgICAgIHJhZGl1c0tleTogdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c0tleSxcbiAgICAgICAgcmFkaXVzTmFtZTogdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c05hbWUsXG4gICAgICAgIGNhbGxvdXRMYWJlbEtleTogdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbEtleSxcbiAgICAgICAgY2FsbG91dExhYmVsTmFtZTogdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbE5hbWUsXG4gICAgICAgIHNlY3RvckxhYmVsS2V5OiB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxLZXksXG4gICAgICAgIHNlY3RvckxhYmVsTmFtZTogdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsTmFtZSxcbiAgICAgICAgbGVnZW5kSXRlbUtleTogdGhpcy5wcm9wZXJ0aWVzLmxlZ2VuZEl0ZW1LZXlcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGdldExlZ2VuZERhdGEobGVnZW5kVHlwZSkge1xuICAgIGNvbnN0IHsgdmlzaWJsZSwgcHJvY2Vzc2VkRGF0YSwgZGF0YU1vZGVsIH0gPSB0aGlzO1xuICAgIGlmICghZGF0YU1vZGVsIHx8ICFwcm9jZXNzZWREYXRhPy5kYXRhLmxlbmd0aCB8fCAhdGhpcy5wcm9wZXJ0aWVzLmlzVmFsaWQoKSB8fCBsZWdlbmRUeXBlICE9PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgeyBhbmdsZUtleSwgY2FsbG91dExhYmVsS2V5LCBzZWN0b3JMYWJlbEtleSwgbGVnZW5kSXRlbUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGlmICghbGVnZW5kSXRlbUtleSAmJiAoIWNhbGxvdXRMYWJlbEtleSB8fCBjYWxsb3V0TGFiZWxLZXkgPT09IGFuZ2xlS2V5KSAmJiAoIXNlY3RvckxhYmVsS2V5IHx8IHNlY3RvckxhYmVsS2V5ID09PSBhbmdsZUtleSkpXG4gICAgICByZXR1cm4gW107XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWxJZHgsIHNlY3RvckxhYmVsSWR4LCBsZWdlbmRJdGVtSWR4IH0gPSB0aGlzLmdldFByb2Nlc3NlZERhdGFJbmRleGVzKGRhdGFNb2RlbCk7XG4gICAgY29uc3QgdGl0bGVUZXh0ID0gdGhpcy5wcm9wZXJ0aWVzLnRpdGxlPy5zaG93SW5MZWdlbmQgJiYgdGhpcy5wcm9wZXJ0aWVzLnRpdGxlLnRleHQ7XG4gICAgY29uc3QgbGVnZW5kRGF0YSA9IFtdO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwcm9jZXNzZWREYXRhLmRhdGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCB7IGRhdHVtLCB2YWx1ZXMgfSA9IHByb2Nlc3NlZERhdGEuZGF0YVtpbmRleF07XG4gICAgICBjb25zdCBsYWJlbFBhcnRzID0gW107XG4gICAgICBpZiAodGl0bGVUZXh0KSB7XG4gICAgICAgIGxhYmVsUGFydHMucHVzaCh0aXRsZVRleHQpO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoXG4gICAgICAgIGRhdHVtLFxuICAgICAgICAyICogTWF0aC5QSSxcbiAgICAgICAgMiAqIE1hdGguUEksXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBjYWxsb3V0TGFiZWxJZHggIT0gbnVsbCA/IHZhbHVlc1tjYWxsb3V0TGFiZWxJZHhdIDogdm9pZCAwLFxuICAgICAgICBzZWN0b3JMYWJlbElkeCAhPSBudWxsID8gdmFsdWVzW3NlY3RvckxhYmVsSWR4XSA6IHZvaWQgMCxcbiAgICAgICAgbGVnZW5kSXRlbUlkeCAhPSBudWxsID8gdmFsdWVzW2xlZ2VuZEl0ZW1JZHhdIDogdm9pZCAwXG4gICAgICApO1xuICAgICAgaWYgKGxlZ2VuZEl0ZW1LZXkgJiYgbGFiZWxzLmxlZ2VuZEl0ZW0gIT09IHZvaWQgMCkge1xuICAgICAgICBsYWJlbFBhcnRzLnB1c2gobGFiZWxzLmxlZ2VuZEl0ZW0udGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKGNhbGxvdXRMYWJlbEtleSAmJiBjYWxsb3V0TGFiZWxLZXkgIT09IGFuZ2xlS2V5ICYmIGxhYmVscy5jYWxsb3V0TGFiZWw/LnRleHQgIT09IHZvaWQgMCkge1xuICAgICAgICBsYWJlbFBhcnRzLnB1c2gobGFiZWxzLmNhbGxvdXRMYWJlbD8udGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKHNlY3RvckxhYmVsS2V5ICYmIHNlY3RvckxhYmVsS2V5ICE9PSBhbmdsZUtleSAmJiBsYWJlbHMuc2VjdG9yTGFiZWw/LnRleHQgIT09IHZvaWQgMCkge1xuICAgICAgICBsYWJlbFBhcnRzLnB1c2gobGFiZWxzLnNlY3RvckxhYmVsPy50ZXh0KTtcbiAgICAgIH1cbiAgICAgIGlmIChsYWJlbFBhcnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBzZWN0b3JGb3JtYXQgPSB0aGlzLmdldFNlY3RvckZvcm1hdChkYXR1bSwgaW5kZXgsIGZhbHNlKTtcbiAgICAgIGxlZ2VuZERhdGEucHVzaCh7XG4gICAgICAgIGxlZ2VuZFR5cGU6IFwiY2F0ZWdvcnlcIixcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIGl0ZW1JZDogaW5kZXgsXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICBlbmFibGVkOiB2aXNpYmxlICYmIHRoaXMuc2VyaWVzSXRlbUVuYWJsZWRbaW5kZXhdLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6IGxhYmVsUGFydHMuam9pbihcIiAtIFwiKVxuICAgICAgICB9LFxuICAgICAgICBzeW1ib2xzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgIGZpbGw6IHNlY3RvckZvcm1hdC5maWxsLFxuICAgICAgICAgICAgICBzdHJva2U6IHNlY3RvckZvcm1hdC5zdHJva2UsXG4gICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiB0aGlzLnByb3BlcnRpZXMuZmlsbE9wYWNpdHksXG4gICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHRoaXMucHJvcGVydGllcy5zdHJva2VPcGFjaXR5LFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZVdpZHRoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBsZWdlbmRJdGVtTmFtZTogbGVnZW5kSXRlbUtleSAhPSBudWxsID8gZGF0dW1bbGVnZW5kSXRlbUtleV0gOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kRGF0YTtcbiAgfVxuICBvbkxlZ2VuZEl0ZW1DbGljayhldmVudCkge1xuICAgIGNvbnN0IHsgZW5hYmxlZCwgaXRlbUlkLCBzZXJpZXMsIGxlZ2VuZEl0ZW1OYW1lIH0gPSBldmVudDtcbiAgICBpZiAoc2VyaWVzLmlkID09PSB0aGlzLmlkKSB7XG4gICAgICB0aGlzLnRvZ2dsZVNlcmllc0l0ZW0oaXRlbUlkLCBlbmFibGVkKTtcbiAgICB9IGVsc2UgaWYgKGxlZ2VuZEl0ZW1OYW1lICE9IG51bGwpIHtcbiAgICAgIHRoaXMudG9nZ2xlT3RoZXJTZXJpZXNJdGVtcyhsZWdlbmRJdGVtTmFtZSwgZW5hYmxlZCk7XG4gICAgfVxuICB9XG4gIHRvZ2dsZVNlcmllc0l0ZW0oaXRlbUlkLCBlbmFibGVkKSB7XG4gICAgdGhpcy5zZXJpZXNJdGVtRW5hYmxlZFtpdGVtSWRdID0gZW5hYmxlZDtcbiAgICBpZiAodGhpcy5ub2RlRGF0YVtpdGVtSWRdKSB7XG4gICAgICB0aGlzLm5vZGVEYXRhW2l0ZW1JZF0uZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgfVxuICAgIHRoaXMubm9kZURhdGFSZWZyZXNoID0gdHJ1ZTtcbiAgfVxuICB0b2dnbGVPdGhlclNlcmllc0l0ZW1zKGxlZ2VuZEl0ZW1OYW1lLCBlbmFibGVkKSB7XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMubGVnZW5kSXRlbUtleSB8fCAhdGhpcy5kYXRhTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGVnZW5kSXRlbUlkeCA9IHRoaXMuZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBsZWdlbmRJdGVtVmFsdWVgKTtcbiAgICB0aGlzLnByb2Nlc3NlZERhdGE/LmRhdGEuZm9yRWFjaCgoeyB2YWx1ZXMgfSwgZGF0dW1JdGVtSWQpID0+IHtcbiAgICAgIGlmICh2YWx1ZXNbbGVnZW5kSXRlbUlkeF0gPT09IGxlZ2VuZEl0ZW1OYW1lKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlU2VyaWVzSXRlbShkYXR1bUl0ZW1JZCwgZW5hYmxlZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoX2RhdGEpIHtcbiAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGZucyA9IHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnMoXG4gICAgICB0cnVlLFxuICAgICAgdGhpcy5wcm9wZXJ0aWVzLnJvdGF0aW9uLFxuICAgICAgdGhpcy5yYWRpdXNTY2FsZSxcbiAgICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZVxuICAgICk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwibm9kZXNcIixcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICBbdGhpcy5pdGVtU2VsZWN0aW9uLCB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbiwgdGhpcy5waGFudG9tU2VsZWN0aW9uXSxcbiAgICAgIGZucy5ub2RlcyxcbiAgICAgIChfLCBkYXR1bSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtKVxuICAgICk7XG4gICAgZnJvbVRvTW90aW9uKHRoaXMuaWQsIGBpbm5lckNpcmNsZWAsIGFuaW1hdGlvbk1hbmFnZXIsIFt0aGlzLmlubmVyQ2lyY2xlU2VsZWN0aW9uXSwgZm5zLmlubmVyQ2lyY2xlKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImNhbGxvdXRcIiwgYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwic2VjdG9yXCIsIGFuaW1hdGlvbk1hbmFnZXIsIHRoaXMubGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiaGlnaGxpZ2h0XCIsIGFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZUluQW5pbWF0aW9uKHRoaXMsIFwiaW5uZXJcIiwgYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5pbm5lckxhYmVsc1NlbGVjdGlvbik7XG4gICAgdGhpcy5wcmV2aW91c1JhZGl1c1NjYWxlLnJhbmdlID0gdGhpcy5yYWRpdXNTY2FsZS5yYW5nZTtcbiAgfVxuICBhbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KCkge1xuICAgIGNvbnN0IHsgaXRlbVNlbGVjdGlvbiwgaGlnaGxpZ2h0U2VsZWN0aW9uLCBwaGFudG9tU2VsZWN0aW9uLCBwcm9jZXNzZWREYXRhLCByYWRpdXNTY2FsZSwgcHJldmlvdXNSYWRpdXNTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGRhdGFEaWZmID0gcHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uZGlmZjtcbiAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnN0b3BCeUFuaW1hdGlvbkdyb3VwSWQodGhpcy5pZCk7XG4gICAgY29uc3Qgc3VwcG9ydGVkRGlmZiA9IChkYXRhRGlmZj8ubW92ZWQuc2l6ZSA/PyAwKSA9PT0gMDtcbiAgICBjb25zdCBoYXNLZXlzID0gKHByb2Nlc3NlZERhdGE/LmRlZnMua2V5cy5sZW5ndGggPz8gMCkgPiAwO1xuICAgIGNvbnN0IGhhc1VuaXF1ZUtleXMgPSBwcm9jZXNzZWREYXRhPy5yZWR1Y2VkPy5hbmltYXRpb25WYWxpZGF0aW9uPy51bmlxdWVLZXlzID8/IHRydWU7XG4gICAgaWYgKCFzdXBwb3J0ZWREaWZmIHx8ICFoYXNLZXlzIHx8ICFoYXNVbmlxdWVLZXlzKSB7XG4gICAgICB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLnNraXBDdXJyZW50QmF0Y2goKTtcbiAgICB9XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9ucyhcbiAgICAgIGZhbHNlLFxuICAgICAgdGhpcy5wcm9wZXJ0aWVzLnJvdGF0aW9uLFxuICAgICAgcmFkaXVzU2NhbGUsXG4gICAgICBwcmV2aW91c1JhZGl1c1NjYWxlXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24oXG4gICAgICB0aGlzLmlkLFxuICAgICAgXCJub2Rlc1wiLFxuICAgICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFtpdGVtU2VsZWN0aW9uLCBoaWdobGlnaHRTZWxlY3Rpb24sIHBoYW50b21TZWxlY3Rpb25dLFxuICAgICAgZm5zLm5vZGVzLFxuICAgICAgKF8sIGRhdHVtKSA9PiB0aGlzLmdldERhdHVtSWQoZGF0dW0pLFxuICAgICAgZGF0YURpZmZcbiAgICApO1xuICAgIGZyb21Ub01vdGlvbih0aGlzLmlkLCBgaW5uZXJDaXJjbGVgLCBhbmltYXRpb25NYW5hZ2VyLCBbdGhpcy5pbm5lckNpcmNsZVNlbGVjdGlvbl0sIGZucy5pbm5lckNpcmNsZSk7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJjYWxsb3V0XCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcInNlY3RvclwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmxhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImhpZ2hsaWdodFwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImlubmVyXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuaW5uZXJMYWJlbHNTZWxlY3Rpb24pO1xuICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZS5yYW5nZSA9IHRoaXMucmFkaXVzU2NhbGUucmFuZ2U7XG4gIH1cbiAgYW5pbWF0ZUNsZWFyaW5nVXBkYXRlRW1wdHkoKSB7XG4gICAgY29uc3QgeyBpdGVtU2VsZWN0aW9uLCBoaWdobGlnaHRTZWxlY3Rpb24sIHBoYW50b21TZWxlY3Rpb24sIHJhZGl1c1NjYWxlLCBwcmV2aW91c1JhZGl1c1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZm5zID0gcHJlcGFyZVBpZVNlcmllc0FuaW1hdGlvbkZ1bmN0aW9ucyhcbiAgICAgIGZhbHNlLFxuICAgICAgdGhpcy5wcm9wZXJ0aWVzLnJvdGF0aW9uLFxuICAgICAgcmFkaXVzU2NhbGUsXG4gICAgICBwcmV2aW91c1JhZGl1c1NjYWxlXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24oXG4gICAgICB0aGlzLmlkLFxuICAgICAgXCJub2Rlc1wiLFxuICAgICAgYW5pbWF0aW9uTWFuYWdlcixcbiAgICAgIFtpdGVtU2VsZWN0aW9uLCBoaWdobGlnaHRTZWxlY3Rpb24sIHBoYW50b21TZWxlY3Rpb25dLFxuICAgICAgZm5zLm5vZGVzLFxuICAgICAgKF8sIGRhdHVtKSA9PiB0aGlzLmdldERhdHVtSWQoZGF0dW0pXG4gICAgKTtcbiAgICBmcm9tVG9Nb3Rpb24odGhpcy5pZCwgYGlubmVyQ2lyY2xlYCwgYW5pbWF0aW9uTWFuYWdlciwgW3RoaXMuaW5uZXJDaXJjbGVTZWxlY3Rpb25dLCBmbnMuaW5uZXJDaXJjbGUpO1xuICAgIHNlcmllc0xhYmVsRmFkZU91dEFuaW1hdGlvbih0aGlzLCBcImNhbGxvdXRcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5jYWxsb3V0TGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZU91dEFuaW1hdGlvbih0aGlzLCBcInNlY3RvclwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmxhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVPdXRBbmltYXRpb24odGhpcywgXCJoaWdobGlnaHRcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5oaWdobGlnaHRMYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlT3V0QW5pbWF0aW9uKHRoaXMsIFwiaW5uZXJcIiwgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlciwgdGhpcy5pbm5lckxhYmVsc1NlbGVjdGlvbik7XG4gICAgdGhpcy5wcmV2aW91c1JhZGl1c1NjYWxlLnJhbmdlID0gdGhpcy5yYWRpdXNTY2FsZS5yYW5nZTtcbiAgfVxuICBnZXREYXR1bUlkRnJvbURhdGEoZGF0dW0pIHtcbiAgICBjb25zdCB7IGNhbGxvdXRMYWJlbEtleSwgc2VjdG9yTGFiZWxLZXksIGxlZ2VuZEl0ZW1LZXkgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAoIXRoaXMucHJvY2Vzc2VkRGF0YT8ucmVkdWNlZD8uYW5pbWF0aW9uVmFsaWRhdGlvbj8udW5pcXVlS2V5cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobGVnZW5kSXRlbUtleSkge1xuICAgICAgcmV0dXJuIGRhdHVtW2xlZ2VuZEl0ZW1LZXldO1xuICAgIH0gZWxzZSBpZiAoY2FsbG91dExhYmVsS2V5KSB7XG4gICAgICByZXR1cm4gZGF0dW1bY2FsbG91dExhYmVsS2V5XTtcbiAgICB9IGVsc2UgaWYgKHNlY3RvckxhYmVsS2V5KSB7XG4gICAgICByZXR1cm4gZGF0dW1bc2VjdG9yTGFiZWxLZXldO1xuICAgIH1cbiAgfVxuICBnZXREYXR1bUlkKGRhdHVtKSB7XG4gICAgY29uc3QgeyBpbmRleCB9ID0gZGF0dW07XG4gICAgY29uc3QgZGF0dW1JZCA9IHRoaXMuZ2V0RGF0dW1JZEZyb21EYXRhKGRhdHVtLmRhdHVtKTtcbiAgICByZXR1cm4gZGF0dW1JZCAhPSBudWxsID8gU3RyaW5nKGRhdHVtSWQpIDogYCR7aW5kZXh9YDtcbiAgfVxuICBvbkRhdGFDaGFuZ2UoKSB7XG4gICAgY29uc3QgeyBkYXRhLCBzZXJpZXNJdGVtRW5hYmxlZCB9ID0gdGhpcztcbiAgICB0aGlzLnNlcmllc0l0ZW1FbmFibGVkID0gZGF0YT8ubWFwKChfLCBpbmRleCkgPT4gc2VyaWVzSXRlbUVuYWJsZWRbaW5kZXhdID8/IHRydWUpID8/IFtdO1xuICB9XG59O1xuRG9udXRTZXJpZXMuY2xhc3NOYW1lID0gXCJEb251dFNlcmllc1wiO1xuRG9udXRTZXJpZXMudHlwZSA9IFwiZG9udXRcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3BvbGFyL2RvbnV0VGhlbWUudHNcbnZhciBkb251dFRoZW1lID0ge1xuICBzZXJpZXM6IHtcbiAgICB0aXRsZToge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIgLyogTk9STUFMICovLFxuICAgICAgZm9udFNpemU6IDE0LFxuICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgIGNvbG9yOiBERUZBVUxUX01VVEVEX0xBQkVMX0NPTE9VUixcbiAgICAgIHNwYWNpbmc6IDVcbiAgICB9LFxuICAgIGNhbGxvdXRMYWJlbDoge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIGZvbnRTaXplOiAxMiAvKiBTTUFMTCAqLyxcbiAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVIsXG4gICAgICBvZmZzZXQ6IDMsXG4gICAgICBtaW5BbmdsZTogMFxuICAgIH0sXG4gICAgc2VjdG9yTGFiZWw6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiIC8qIE5PUk1BTCAqLyxcbiAgICAgIGZvbnRTaXplOiAxMiAvKiBTTUFMTCAqLyxcbiAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICBjb2xvcjogREVGQVVMVF9JTlNJREVfU0VSSUVTX0xBQkVMX0NPTE9VUixcbiAgICAgIHBvc2l0aW9uT2Zmc2V0OiAwLFxuICAgICAgcG9zaXRpb25SYXRpbzogMC41XG4gICAgfSxcbiAgICBjYWxsb3V0TGluZToge1xuICAgICAgbGVuZ3RoOiAxMCxcbiAgICAgIHN0cm9rZVdpZHRoOiAyXG4gICAgfSxcbiAgICBmaWxsT3BhY2l0eTogMSxcbiAgICBzdHJva2VPcGFjaXR5OiAxLFxuICAgIHN0cm9rZVdpZHRoOiAwLFxuICAgIGxpbmVEYXNoOiBbMF0sXG4gICAgbGluZURhc2hPZmZzZXQ6IDAsXG4gICAgcm90YXRpb246IDAsXG4gICAgc2VjdG9yU3BhY2luZzogMSxcbiAgICBzaGFkb3c6IHtcbiAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgY29sb3I6IERFRkFVTFRfU0hBRE9XX0NPTE9VUixcbiAgICAgIHhPZmZzZXQ6IDMsXG4gICAgICB5T2Zmc2V0OiAzLFxuICAgICAgYmx1cjogNVxuICAgIH0sXG4gICAgaW5uZXJMYWJlbHM6IHtcbiAgICAgIGZvbnRTaXplOiAxMiAvKiBTTUFMTCAqLyxcbiAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVIsXG4gICAgICBzcGFjaW5nOiAyXG4gICAgfVxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvcGllVGhlbWUudHNcbnZhciBwaWVUaGVtZSA9IHtcbiAgc2VyaWVzOiB7XG4gICAgdGl0bGU6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiIC8qIE5PUk1BTCAqLyxcbiAgICAgIGZvbnRTaXplOiAxNCxcbiAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICBjb2xvcjogREVGQVVMVF9NVVRFRF9MQUJFTF9DT0xPVVIsXG4gICAgICBzcGFjaW5nOiA1XG4gICAgfSxcbiAgICBjYWxsb3V0TGFiZWw6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBmb250U2l6ZTogMTIgLyogU01BTEwgKi8sXG4gICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSLFxuICAgICAgb2Zmc2V0OiAzLFxuICAgICAgbWluQW5nbGU6IDBcbiAgICB9LFxuICAgIHNlY3RvckxhYmVsOiB7XG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgZm9udFdlaWdodDogXCJub3JtYWxcIiAvKiBOT1JNQUwgKi8sXG4gICAgICBmb250U2l6ZTogMTIgLyogU01BTEwgKi8sXG4gICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgY29sb3I6IERFRkFVTFRfSU5TSURFX1NFUklFU19MQUJFTF9DT0xPVVIsXG4gICAgICBwb3NpdGlvbk9mZnNldDogMCxcbiAgICAgIHBvc2l0aW9uUmF0aW86IDAuNVxuICAgIH0sXG4gICAgY2FsbG91dExpbmU6IHtcbiAgICAgIGxlbmd0aDogMTAsXG4gICAgICBzdHJva2VXaWR0aDogMlxuICAgIH0sXG4gICAgZmlsbE9wYWNpdHk6IDEsXG4gICAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgICBzdHJva2VXaWR0aDogMCxcbiAgICBsaW5lRGFzaDogWzBdLFxuICAgIGxpbmVEYXNoT2Zmc2V0OiAwLFxuICAgIHJvdGF0aW9uOiAwLFxuICAgIHNlY3RvclNwYWNpbmc6IDEsXG4gICAgc2hhZG93OiB7XG4gICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgIGNvbG9yOiBERUZBVUxUX1NIQURPV19DT0xPVVIsXG4gICAgICB4T2Zmc2V0OiAzLFxuICAgICAgeU9mZnNldDogMyxcbiAgICAgIGJsdXI6IDVcbiAgICB9XG4gIH1cbn07XG52YXIgcGllUGFsZXR0ZUZhY3RvcnkgPSAoeyB0YWtlQ29sb3JzLCBjb2xvcnNDb3VudCB9KSA9PiB7XG4gIGNvbnN0IHsgZmlsbHMsIHN0cm9rZXMgfSA9IHRha2VDb2xvcnMoY29sb3JzQ291bnQpO1xuICByZXR1cm4geyBmaWxscywgc3Ryb2tlcywgY2FsbG91dExpbmU6IHsgY29sb3JzOiBzdHJva2VzIH0gfTtcbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Nlcmllcy9wb2xhci9kb251dFNlcmllc01vZHVsZS50c1xudmFyIERvbnV0U2VyaWVzTW9kdWxlID0ge1xuICB0eXBlOiBcInNlcmllc1wiLFxuICBvcHRpb25zS2V5OiBcInNlcmllc1tdXCIsXG4gIHBhY2thZ2VUeXBlOiBcImNvbW11bml0eVwiLFxuICBjaGFydFR5cGVzOiBbXCJwb2xhclwiXSxcbiAgaWRlbnRpZmllcjogXCJkb251dFwiLFxuICBtb2R1bGVGYWN0b3J5OiAoY3R4KSA9PiBuZXcgRG9udXRTZXJpZXMoY3R4KSxcbiAgdG9vbHRpcERlZmF1bHRzOiB7IHJhbmdlOiBcImV4YWN0XCIgfSxcbiAgdGhlbWVUZW1wbGF0ZTogZG9udXRUaGVtZSxcbiAgcGFsZXR0ZUZhY3Rvcnk6IHBpZVBhbGV0dGVGYWN0b3J5XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvcGllU2VyaWVzUHJvcGVydGllcy50c1xudmFyIFBpZVRpdGxlID0gY2xhc3MgZXh0ZW5kcyBDYXB0aW9uIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnNob3dJbkxlZ2VuZCA9IGZhbHNlO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIFBpZVRpdGxlLnByb3RvdHlwZSwgXCJzaG93SW5MZWdlbmRcIiwgMik7XG52YXIgUGllU2VyaWVzQ2FsbG91dExhYmVsID0gY2xhc3MgZXh0ZW5kcyBMYWJlbCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5vZmZzZXQgPSAzO1xuICAgIHRoaXMubWluQW5nbGUgPSAwO1xuICAgIHRoaXMubWluU3BhY2luZyA9IDQ7XG4gICAgdGhpcy5tYXhDb2xsaXNpb25PZmZzZXQgPSA1MDtcbiAgICB0aGlzLmF2b2lkQ29sbGlzaW9ucyA9IHRydWU7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQaWVTZXJpZXNDYWxsb3V0TGFiZWwucHJvdG90eXBlLCBcIm9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKERFR1JFRSlcbl0sIFBpZVNlcmllc0NhbGxvdXRMYWJlbC5wcm90b3R5cGUsIFwibWluQW5nbGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQaWVTZXJpZXNDYWxsb3V0TGFiZWwucHJvdG90eXBlLCBcIm1pblNwYWNpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQaWVTZXJpZXNDYWxsb3V0TGFiZWwucHJvdG90eXBlLCBcIm1heENvbGxpc2lvbk9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKEJPT0xFQU4pXG5dLCBQaWVTZXJpZXNDYWxsb3V0TGFiZWwucHJvdG90eXBlLCBcImF2b2lkQ29sbGlzaW9uc1wiLCAyKTtcbnZhciBQaWVTZXJpZXNTZWN0b3JMYWJlbCA9IGNsYXNzIGV4dGVuZHMgTGFiZWwge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMucG9zaXRpb25PZmZzZXQgPSAwO1xuICAgIHRoaXMucG9zaXRpb25SYXRpbyA9IDAuNTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIFBpZVNlcmllc1NlY3RvckxhYmVsLnByb3RvdHlwZSwgXCJwb3NpdGlvbk9mZnNldFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgUGllU2VyaWVzU2VjdG9yTGFiZWwucHJvdG90eXBlLCBcInBvc2l0aW9uUmF0aW9cIiwgMik7XG52YXIgUGllU2VyaWVzQ2FsbG91dExpbmUgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmxlbmd0aCA9IDEwO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNDYWxsb3V0TGluZS5wcm90b3R5cGUsIFwiY29sb3JzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGllU2VyaWVzQ2FsbG91dExpbmUucHJvdG90eXBlLCBcImxlbmd0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFBPU0lUSVZFX05VTUJFUilcbl0sIFBpZVNlcmllc0NhbGxvdXRMaW5lLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbnZhciBQaWVTZXJpZXNQcm9wZXJ0aWVzID0gY2xhc3MgZXh0ZW5kcyBTZXJpZXNQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmZpbGxzID0gT2JqZWN0LnZhbHVlcyhERUZBVUxUX0ZJTExTKTtcbiAgICB0aGlzLnN0cm9rZXMgPSBPYmplY3QudmFsdWVzKERFRkFVTFRfU1RST0tFUyk7XG4gICAgdGhpcy5maWxsT3BhY2l0eSA9IDE7XG4gICAgdGhpcy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICB0aGlzLmxpbmVEYXNoID0gWzBdO1xuICAgIHRoaXMubGluZURhc2hPZmZzZXQgPSAwO1xuICAgIHRoaXMuY29ybmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLnJvdGF0aW9uID0gMDtcbiAgICB0aGlzLm91dGVyUmFkaXVzT2Zmc2V0ID0gMDtcbiAgICB0aGlzLm91dGVyUmFkaXVzUmF0aW8gPSAxO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGggPSAxO1xuICAgIHRoaXMuc2VjdG9yU3BhY2luZyA9IDA7XG4gICAgdGhpcy50aXRsZSA9IG5ldyBQaWVUaXRsZSgpO1xuICAgIHRoaXMuc2hhZG93ID0gbmV3IERyb3BTaGFkb3coKTtcbiAgICB0aGlzLmNhbGxvdXRMYWJlbCA9IG5ldyBQaWVTZXJpZXNDYWxsb3V0TGFiZWwoKTtcbiAgICB0aGlzLnNlY3RvckxhYmVsID0gbmV3IFBpZVNlcmllc1NlY3RvckxhYmVsKCk7XG4gICAgdGhpcy5jYWxsb3V0TGluZSA9IG5ldyBQaWVTZXJpZXNDYWxsb3V0TGluZSgpO1xuICAgIHRoaXMudG9vbHRpcCA9IG5ldyBTZXJpZXNUb29sdGlwKCk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJhbmdsZUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYW5nbGVOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJhbmdsZUZpbHRlcktleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwicmFkaXVzS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJyYWRpdXNOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJyYWRpdXNNaW5cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInJhZGl1c01heFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY2FsbG91dExhYmVsS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjYWxsb3V0TGFiZWxOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzZWN0b3JMYWJlbEtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2VjdG9yTGFiZWxOYW1lXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoU1RSSU5HLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJsZWdlbmRJdGVtS2V5XCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZmlsbHNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShDT0xPUl9TVFJJTkdfQVJSQVkpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJmaWxsT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFJBVElPKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlT3BhY2l0eVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKExJTkVfREFTSClcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImxpbmVEYXNoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUE9TSVRJVkVfTlVNQkVSKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwibGluZURhc2hPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjb3JuZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShGVU5DVElPTiwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiaXRlbVN0eWxlclwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKERFR1JFRSlcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoTlVNQkVSKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwib3V0ZXJSYWRpdXNPZmZzZXRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShSQVRJTylcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcIm91dGVyUmFkaXVzUmF0aW9cIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShQT1NJVElWRV9OVU1CRVIpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzdHJva2VXaWR0aFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE5VTUJFUilcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNlY3RvclNwYWNpbmdcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNoYWRvd1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNhbGxvdXRMYWJlbFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKE9CSkVDVClcbl0sIFBpZVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcInNlY3RvckxhYmVsXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoT0JKRUNUKVxuXSwgUGllU2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY2FsbG91dExpbmVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShPQkpFQ1QpXG5dLCBQaWVTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvcG9sYXIvcGllU2VyaWVzLnRzXG52YXIgUGllU2VyaWVzTm9kZUV2ZW50ID0gY2xhc3MgZXh0ZW5kcyBTZXJpZXNOb2RlRXZlbnQge1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBuYXRpdmVFdmVudCwgZGF0dW0sIHNlcmllcykge1xuICAgIHN1cGVyKHR5cGUsIG5hdGl2ZUV2ZW50LCBkYXR1bSwgc2VyaWVzKTtcbiAgICB0aGlzLmFuZ2xlS2V5ID0gc2VyaWVzLnByb3BlcnRpZXMuYW5nbGVLZXk7XG4gICAgdGhpcy5yYWRpdXNLZXkgPSBzZXJpZXMucHJvcGVydGllcy5yYWRpdXNLZXk7XG4gICAgdGhpcy5jYWxsb3V0TGFiZWxLZXkgPSBzZXJpZXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxLZXk7XG4gICAgdGhpcy5zZWN0b3JMYWJlbEtleSA9IHNlcmllcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsS2V5O1xuICB9XG59O1xudmFyIFBpZVNlcmllcyA9IGNsYXNzIGV4dGVuZHMgUG9sYXJTZXJpZXMge1xuICBjb25zdHJ1Y3Rvcihtb2R1bGVDdHgpIHtcbiAgICBzdXBlcih7XG4gICAgICBtb2R1bGVDdHgsXG4gICAgICBwaWNrTW9kZXM6IFszIC8qIE5FQVJFU1RfTk9ERSAqLywgMCAvKiBFWEFDVF9TSEFQRV9NQVRDSCAqL10sXG4gICAgICB1c2VMYWJlbExheWVyOiB0cnVlLFxuICAgICAgYW5pbWF0aW9uUmVzZXRGbnM6IHsgaXRlbTogcmVzZXRQaWVTZWxlY3Rpb25zRm4sIGxhYmVsOiByZXNldExhYmVsRm4gfVxuICAgIH0pO1xuICAgIHRoaXMucHJvcGVydGllcyA9IG5ldyBQaWVTZXJpZXNQcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy5waGFudG9tTm9kZURhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5wcmV2aW91c1JhZGl1c1NjYWxlID0gbmV3IExpbmVhclNjYWxlKCk7XG4gICAgdGhpcy5yYWRpdXNTY2FsZSA9IG5ldyBMaW5lYXJTY2FsZSgpO1xuICAgIHRoaXMucGhhbnRvbUdyb3VwID0gdGhpcy5jb250ZW50R3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKCkpO1xuICAgIHRoaXMucGhhbnRvbVNlbGVjdGlvbiA9IFNlbGVjdGlvbi5zZWxlY3QoXG4gICAgICB0aGlzLnBoYW50b21Hcm91cCxcbiAgICAgICgpID0+IHRoaXMubm9kZUZhY3RvcnkoKSxcbiAgICAgIGZhbHNlXG4gICAgKTtcbiAgICB0aGlzLmNhbGxvdXRMYWJlbEdyb3VwID0gdGhpcy5jb250ZW50R3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKHsgbmFtZTogXCJwaWVDYWxsb3V0TGFiZWxzXCIgfSkpO1xuICAgIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvbihcbiAgICAgIHRoaXMuY2FsbG91dExhYmVsR3JvdXAsXG4gICAgICBHcm91cFxuICAgICk7XG4gICAgLy8gVGhlIGdyb3VwIG5vZGUgdGhhdCBjb250YWlucyB0aGUgYmFja2dyb3VuZCBncmFwaGljcy5cbiAgICB0aGlzLmJhY2tncm91bmRHcm91cCA9IHRoaXMucm9vdEdyb3VwLmFwcGVuZENoaWxkKFxuICAgICAgbmV3IEdyb3VwKHtcbiAgICAgICAgbmFtZTogYCR7dGhpcy5pZH0tYmFja2dyb3VuZGAsXG4gICAgICAgIGxheWVyOiB0cnVlLFxuICAgICAgICB6SW5kZXg6IDAgLyogU0VSSUVTX0JBQ0tHUk9VTkRfWklOREVYICovXG4gICAgICB9KVxuICAgICk7XG4gICAgLy8gQUctNjE5MyBJZiB0aGUgc3VtIG9mIGFsbCBkYXR1bXMgaXMgMCwgdGhlbiB3ZSdsbCBkcmF3IDEgb3IgMiByaW5ncyB0byByZXByZXNlbnQgdGhlIGVtcHR5IHNlcmllcy5cbiAgICB0aGlzLnplcm9zdW1SaW5nc0dyb3VwID0gdGhpcy5iYWNrZ3JvdW5kR3JvdXAuYXBwZW5kQ2hpbGQobmV3IEdyb3VwKHsgbmFtZTogYCR7dGhpcy5pZH0temVyb3N1bVJpbmdzYCB9KSk7XG4gICAgdGhpcy56ZXJvc3VtT3V0ZXJSaW5nID0gdGhpcy56ZXJvc3VtUmluZ3NHcm91cC5hcHBlbmRDaGlsZChuZXcgQ2lyY2xlKCkpO1xuICAgIC8vIFdoZW4gYSB1c2VyIHRvZ2dsZXMgYSBzZXJpZXMgaXRlbSAoZS5nLiBmcm9tIHRoZSBsZWdlbmQpLCBpdHMgYm9vbGVhbiBzdGF0ZSBpcyByZWNvcmRlZCBoZXJlLlxuICAgIHRoaXMuc2VyaWVzSXRlbUVuYWJsZWQgPSBbXTtcbiAgICB0aGlzLnN1cnJvdW5kaW5nUmFkaXVzID0gdm9pZCAwO1xuICAgIHRoaXMuTm9kZUV2ZW50ID0gUGllU2VyaWVzTm9kZUV2ZW50O1xuICAgIHRoaXMuYW5nbGVTY2FsZSA9IG5ldyBMaW5lYXJTY2FsZSgpO1xuICAgIHRoaXMuYW5nbGVTY2FsZS5kb21haW4gPSBbMCwgMV07XG4gICAgdGhpcy5hbmdsZVNjYWxlLnJhbmdlID0gWy1NYXRoLlBJLCBNYXRoLlBJXS5tYXAoKGFuZ2xlMikgPT4gYW5nbGUyICsgTWF0aC5QSSAvIDIpO1xuICAgIHRoaXMucGhhbnRvbUdyb3VwLm9wYWNpdHkgPSAwLjI7XG4gICAgdGhpcy5waGFudG9tR3JvdXAuekluZGV4U3ViT3JkZXIgPSBbKCkgPT4gdGhpcy5fZGVjbGFyYXRpb25PcmRlciwgMF07XG4gIH1cbiAgZ2V0IGNhbGxvdXROb2RlRGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5waGFudG9tTm9kZURhdGEgPz8gdGhpcy5ub2RlRGF0YTtcbiAgfVxuICBhZGRDaGFydEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKFxuICAgICAgdGhpcy5jdHguY2hhcnRFdmVudE1hbmFnZXI/LmFkZExpc3RlbmVyKFwibGVnZW5kLWl0ZW0tY2xpY2tcIiwgKGV2ZW50KSA9PiB0aGlzLm9uTGVnZW5kSXRlbUNsaWNrKGV2ZW50KSlcbiAgICApO1xuICB9XG4gIGdldCB2aXNpYmxlKCkge1xuICAgIHJldHVybiBzdXBlci52aXNpYmxlICYmICh0aGlzLnNlcmllc0l0ZW1FbmFibGVkLmxlbmd0aCA9PT0gMCB8fCB0aGlzLnNlcmllc0l0ZW1FbmFibGVkLnNvbWUoKHZpc2libGUpID0+IHZpc2libGUpKTtcbiAgfVxuICBub2RlRmFjdG9yeSgpIHtcbiAgICBjb25zdCBzZWN0b3IgPSBuZXcgU2VjdG9yKCk7XG4gICAgc2VjdG9yLm1pdGVyTGltaXQgPSAxZTk7XG4gICAgcmV0dXJuIHNlY3RvcjtcbiAgfVxuICBnZXRTZXJpZXNEb21haW4oZGlyZWN0aW9uKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJ4XCIgLyogWCAqLykge1xuICAgICAgcmV0dXJuIHRoaXMuYW5nbGVTY2FsZS5kb21haW47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnJhZGl1c1NjYWxlLmRvbWFpbjtcbiAgICB9XG4gIH1cbiAgYXN5bmMgcHJvY2Vzc0RhdGEoZGF0YUNvbnRyb2xsZXIpIHtcbiAgICBpZiAodGhpcy5kYXRhID09IG51bGwgfHwgIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHsgZGF0YSB9ID0gdGhpcztcbiAgICBjb25zdCB7IHZpc2libGUsIHNlcmllc0l0ZW1FbmFibGVkIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgYW5nbGVLZXksIGFuZ2xlRmlsdGVyS2V5LCByYWRpdXNLZXksIGNhbGxvdXRMYWJlbEtleSwgc2VjdG9yTGFiZWxLZXksIGxlZ2VuZEl0ZW1LZXkgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCBhbmltYXRpb25FbmFibGVkID0gIXRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuaXNTa2lwcGVkKCk7XG4gICAgY29uc3QgZXh0cmFLZXlQcm9wcyA9IFtdO1xuICAgIGNvbnN0IGV4dHJhUHJvcHMgPSBbXTtcbiAgICBpZiAobGVnZW5kSXRlbUtleSkge1xuICAgICAgZXh0cmFLZXlQcm9wcy5wdXNoKGtleVByb3BlcnR5KGxlZ2VuZEl0ZW1LZXksIFwiYmFuZFwiLCB7IGlkOiBgbGVnZW5kSXRlbUtleWAgfSkpO1xuICAgIH0gZWxzZSBpZiAoY2FsbG91dExhYmVsS2V5KSB7XG4gICAgICBleHRyYUtleVByb3BzLnB1c2goa2V5UHJvcGVydHkoY2FsbG91dExhYmVsS2V5LCBcImJhbmRcIiwgeyBpZDogYGNhbGxvdXRMYWJlbEtleWAgfSkpO1xuICAgIH0gZWxzZSBpZiAoc2VjdG9yTGFiZWxLZXkpIHtcbiAgICAgIGV4dHJhS2V5UHJvcHMucHVzaChrZXlQcm9wZXJ0eShzZWN0b3JMYWJlbEtleSwgXCJiYW5kXCIsIHsgaWQ6IGBzZWN0b3JMYWJlbEtleWAgfSkpO1xuICAgIH1cbiAgICBjb25zdCByYWRpdXNTY2FsZVR5cGUgPSB0aGlzLnJhZGl1c1NjYWxlLnR5cGU7XG4gICAgY29uc3QgYW5nbGVTY2FsZVR5cGUgPSB0aGlzLnJhZGl1c1NjYWxlLnR5cGU7XG4gICAgaWYgKHJhZGl1c0tleSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKFxuICAgICAgICByYW5nZWRWYWx1ZVByb3BlcnR5KHJhZGl1c0tleSwge1xuICAgICAgICAgIGlkOiBcInJhZGl1c1ZhbHVlXCIsXG4gICAgICAgICAgbWluOiB0aGlzLnByb3BlcnRpZXMucmFkaXVzTWluID8/IDAsXG4gICAgICAgICAgbWF4OiB0aGlzLnByb3BlcnRpZXMucmFkaXVzTWF4XG4gICAgICAgIH0pLFxuICAgICAgICB2YWx1ZVByb3BlcnR5KHJhZGl1c0tleSwgcmFkaXVzU2NhbGVUeXBlLCB7IGlkOiBgcmFkaXVzUmF3YCB9KSxcbiAgICAgICAgLy8gUmF3IHZhbHVlIHBhc3MtdGhyb3VnaC5cbiAgICAgICAgbm9ybWFsaXNlUHJvcGVydHlUbyhcInJhZGl1c1ZhbHVlXCIsIFswLCAxXSwgMSwgdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c01pbiA/PyAwLCB0aGlzLnByb3BlcnRpZXMucmFkaXVzTWF4KVxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNhbGxvdXRMYWJlbEtleSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKHZhbHVlUHJvcGVydHkoY2FsbG91dExhYmVsS2V5LCBcImJhbmRcIiwgeyBpZDogYGNhbGxvdXRMYWJlbFZhbHVlYCB9KSk7XG4gICAgfVxuICAgIGlmIChzZWN0b3JMYWJlbEtleSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKHZhbHVlUHJvcGVydHkoc2VjdG9yTGFiZWxLZXksIFwiYmFuZFwiLCB7IGlkOiBgc2VjdG9yTGFiZWxWYWx1ZWAgfSkpO1xuICAgIH1cbiAgICBpZiAobGVnZW5kSXRlbUtleSkge1xuICAgICAgZXh0cmFQcm9wcy5wdXNoKHZhbHVlUHJvcGVydHkobGVnZW5kSXRlbUtleSwgXCJiYW5kXCIsIHsgaWQ6IGBsZWdlbmRJdGVtVmFsdWVgIH0pKTtcbiAgICB9XG4gICAgaWYgKGFuZ2xlRmlsdGVyS2V5KSB7XG4gICAgICBleHRyYVByb3BzLnB1c2goXG4gICAgICAgIGFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHkoYW5nbGVGaWx0ZXJLZXksIGFuZ2xlU2NhbGVUeXBlLCB7XG4gICAgICAgICAgaWQ6IGBhbmdsZUZpbHRlclZhbHVlYCxcbiAgICAgICAgICBvbmx5UG9zaXRpdmU6IHRydWVcbiAgICAgICAgfSksXG4gICAgICAgIHZhbHVlUHJvcGVydHkoYW5nbGVGaWx0ZXJLZXksIGFuZ2xlU2NhbGVUeXBlLCB7IGlkOiBgYW5nbGVGaWx0ZXJSYXdgIH0pLFxuICAgICAgICBub3JtYWxpc2VQcm9wZXJ0eVRvKFwiYW5nbGVGaWx0ZXJWYWx1ZVwiLCBbMCwgMV0sIDAsIDApXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoYW5pbWF0aW9uRW5hYmxlZCAmJiB0aGlzLnByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmFuaW1hdGlvblZhbGlkYXRpb24/LnVuaXF1ZUtleXMgJiYgZXh0cmFLZXlQcm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICBleHRyYVByb3BzLnB1c2goZGlmZih0aGlzLnByb2Nlc3NlZERhdGEpKTtcbiAgICB9XG4gICAgZXh0cmFQcm9wcy5wdXNoKGFuaW1hdGlvblZhbGlkYXRpb24oKSk7XG4gICAgZGF0YSA9IGRhdGEubWFwKChkLCBpZHgpID0+IHZpc2libGUgJiYgc2VyaWVzSXRlbUVuYWJsZWRbaWR4XSA/IGQgOiB7IC4uLmQsIFthbmdsZUtleV06IDAgfSk7XG4gICAgYXdhaXQgdGhpcy5yZXF1ZXN0RGF0YU1vZGVsKGRhdGFDb250cm9sbGVyLCBkYXRhLCB7XG4gICAgICBwcm9wczogW1xuICAgICAgICAuLi5leHRyYUtleVByb3BzLFxuICAgICAgICBhY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5KGFuZ2xlS2V5LCBhbmdsZVNjYWxlVHlwZSwgeyBpZDogYGFuZ2xlVmFsdWVgLCBvbmx5UG9zaXRpdmU6IHRydWUgfSksXG4gICAgICAgIHZhbHVlUHJvcGVydHkoYW5nbGVLZXksIGFuZ2xlU2NhbGVUeXBlLCB7IGlkOiBgYW5nbGVSYXdgIH0pLFxuICAgICAgICAvLyBSYXcgdmFsdWUgcGFzcy10aHJvdWdoLlxuICAgICAgICBub3JtYWxpc2VQcm9wZXJ0eVRvKFwiYW5nbGVWYWx1ZVwiLCBbMCwgMV0sIDAsIDApLFxuICAgICAgICAuLi5leHRyYVByb3BzXG4gICAgICBdXG4gICAgfSk7XG4gICAgZm9yIChjb25zdCB2YWx1ZURlZiBvZiB0aGlzLnByb2Nlc3NlZERhdGE/LmRlZnM/LnZhbHVlcyA/PyBbXSkge1xuICAgICAgY29uc3QgeyBpZCwgbWlzc2luZywgcHJvcGVydHkgfSA9IHZhbHVlRGVmO1xuICAgICAgY29uc3QgbWlzc0NvdW50ID0gZ2V0TWlzc0NvdW50KHRoaXMsIG1pc3NpbmcpO1xuICAgICAgaWYgKGlkICE9PSBcImFuZ2xlUmF3XCIgJiYgbWlzc0NvdW50ID4gMCkge1xuICAgICAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICAgICAgYG5vIHZhbHVlIHdhcyBmb3VuZCBmb3IgdGhlIGtleSAnJHtTdHJpbmcocHJvcGVydHkpfScgb24gJHttaXNzQ291bnR9IGRhdGEgZWxlbWVudCR7bWlzc0NvdW50ID4gMSA/IFwic1wiIDogXCJcIn1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInVwZGF0ZURhdGFcIik7XG4gIH1cbiAgYXN5bmMgbWF5YmVSZWZyZXNoTm9kZURhdGEoKSB7XG4gICAgaWYgKCF0aGlzLm5vZGVEYXRhUmVmcmVzaClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IG5vZGVEYXRhID0gW10sIHBoYW50b21Ob2RlRGF0YSB9ID0gYXdhaXQgdGhpcy5jcmVhdGVOb2RlRGF0YSgpID8/IHt9O1xuICAgIHRoaXMubm9kZURhdGEgPSBub2RlRGF0YTtcbiAgICB0aGlzLnBoYW50b21Ob2RlRGF0YSA9IHBoYW50b21Ob2RlRGF0YTtcbiAgICB0aGlzLm5vZGVEYXRhUmVmcmVzaCA9IGZhbHNlO1xuICB9XG4gIGdldFByb2Nlc3NlZERhdGFJbmRleGVzKGRhdGFNb2RlbCkge1xuICAgIGNvbnN0IGFuZ2xlSWR4ID0gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBhbmdsZVZhbHVlYCk7XG4gICAgY29uc3QgYW5nbGVSYXdJZHggPSBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGFuZ2xlUmF3YCk7XG4gICAgY29uc3QgYW5nbGVGaWx0ZXJJZHggPSB0aGlzLnByb3BlcnRpZXMuYW5nbGVGaWx0ZXJLZXkgIT0gbnVsbCA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgYW5nbGVGaWx0ZXJWYWx1ZWApIDogdm9pZCAwO1xuICAgIGNvbnN0IGFuZ2xlRmlsdGVyUmF3SWR4ID0gdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlRmlsdGVyS2V5ICE9IG51bGwgPyBkYXRhTW9kZWwucmVzb2x2ZVByb2Nlc3NlZERhdGFJbmRleEJ5SWQodGhpcywgYGFuZ2xlRmlsdGVyUmF3YCkgOiB2b2lkIDA7XG4gICAgY29uc3QgcmFkaXVzSWR4ID0gdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c0tleSA/IGRhdGFNb2RlbC5yZXNvbHZlUHJvY2Vzc2VkRGF0YUluZGV4QnlJZCh0aGlzLCBgcmFkaXVzVmFsdWVgKSA6IHZvaWQgMDtcbiAgICBjb25zdCByYWRpdXNSYXdJZHggPSB0aGlzLnByb3BlcnRpZXMucmFkaXVzS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGByYWRpdXNSYXdgKSA6IHZvaWQgMDtcbiAgICBjb25zdCBjYWxsb3V0TGFiZWxJZHggPSB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBjYWxsb3V0TGFiZWxWYWx1ZWApIDogdm9pZCAwO1xuICAgIGNvbnN0IHNlY3RvckxhYmVsSWR4ID0gdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBzZWN0b3JMYWJlbFZhbHVlYCkgOiB2b2lkIDA7XG4gICAgY29uc3QgbGVnZW5kSXRlbUlkeCA9IHRoaXMucHJvcGVydGllcy5sZWdlbmRJdGVtS2V5ID8gZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBsZWdlbmRJdGVtVmFsdWVgKSA6IHZvaWQgMDtcbiAgICByZXR1cm4ge1xuICAgICAgYW5nbGVJZHgsXG4gICAgICBhbmdsZVJhd0lkeCxcbiAgICAgIGFuZ2xlRmlsdGVySWR4LFxuICAgICAgYW5nbGVGaWx0ZXJSYXdJZHgsXG4gICAgICByYWRpdXNJZHgsXG4gICAgICByYWRpdXNSYXdJZHgsXG4gICAgICBjYWxsb3V0TGFiZWxJZHgsXG4gICAgICBzZWN0b3JMYWJlbElkeCxcbiAgICAgIGxlZ2VuZEl0ZW1JZHhcbiAgICB9O1xuICB9XG4gIGFzeW5jIGNyZWF0ZU5vZGVEYXRhKCkge1xuICAgIGNvbnN0IHsgaWQ6IHNlcmllc0lkLCBwcm9jZXNzZWREYXRhLCBkYXRhTW9kZWwsIGFuZ2xlU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgeyByb3RhdGlvbiB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGlmICghcHJvY2Vzc2VkRGF0YSB8fCAhZGF0YU1vZGVsIHx8IHByb2Nlc3NlZERhdGEudHlwZSAhPT0gXCJ1bmdyb3VwZWRcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBhbmdsZUlkeCxcbiAgICAgIGFuZ2xlUmF3SWR4LFxuICAgICAgYW5nbGVGaWx0ZXJJZHgsXG4gICAgICBhbmdsZUZpbHRlclJhd0lkeCxcbiAgICAgIHJhZGl1c0lkeCxcbiAgICAgIHJhZGl1c1Jhd0lkeCxcbiAgICAgIGNhbGxvdXRMYWJlbElkeCxcbiAgICAgIHNlY3RvckxhYmVsSWR4LFxuICAgICAgbGVnZW5kSXRlbUlkeFxuICAgIH0gPSB0aGlzLmdldFByb2Nlc3NlZERhdGFJbmRleGVzKGRhdGFNb2RlbCk7XG4gICAgY29uc3QgdXNlRmlsdGVyQW5nbGVzID0gYW5nbGVGaWx0ZXJSYXdJZHggIT0gbnVsbCAmJiBwcm9jZXNzZWREYXRhLmRhdGEuc29tZSgoeyB2YWx1ZXMgfSkgPT4ge1xuICAgICAgcmV0dXJuIHZhbHVlc1thbmdsZUZpbHRlclJhd0lkeF0gPiB2YWx1ZXNbYW5nbGVSYXdJZHhdO1xuICAgIH0pO1xuICAgIGxldCBjdXJyZW50U3RhcnQgPSAwO1xuICAgIGxldCBzdW0yID0gMDtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGNvbnN0IHBoYW50b21Ob2RlcyA9IGFuZ2xlRmlsdGVyUmF3SWR4ICE9IG51bGwgPyBbXSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzZWREYXRhLmRhdGEuZm9yRWFjaCgoZ3JvdXAsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB7IGRhdHVtLCB2YWx1ZXMgfSA9IGdyb3VwO1xuICAgICAgY29uc3QgY3VycmVudFZhbHVlID0gdXNlRmlsdGVyQW5nbGVzID8gdmFsdWVzW2FuZ2xlRmlsdGVySWR4XSA6IHZhbHVlc1thbmdsZUlkeF07XG4gICAgICBjb25zdCBjcm9zc0ZpbHRlclNjYWxlID0gYW5nbGVGaWx0ZXJSYXdJZHggIT0gbnVsbCAmJiAhdXNlRmlsdGVyQW5nbGVzID8gTWF0aC5zcXJ0KHZhbHVlc1thbmdsZUZpbHRlclJhd0lkeF0gLyB2YWx1ZXNbYW5nbGVSYXdJZHhdKSA6IDE7XG4gICAgICBjb25zdCBzdGFydEFuZ2xlID0gYW5nbGVTY2FsZS5jb252ZXJ0KGN1cnJlbnRTdGFydCkgKyB0b1JhZGlhbnMocm90YXRpb24pO1xuICAgICAgY3VycmVudFN0YXJ0ID0gY3VycmVudFZhbHVlO1xuICAgICAgc3VtMiArPSBjdXJyZW50VmFsdWU7XG4gICAgICBjb25zdCBlbmRBbmdsZSA9IGFuZ2xlU2NhbGUuY29udmVydChjdXJyZW50U3RhcnQpICsgdG9SYWRpYW5zKHJvdGF0aW9uKTtcbiAgICAgIGNvbnN0IHNwYW4gPSBNYXRoLmFicyhlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuICAgICAgY29uc3QgbWlkQW5nbGUgPSBzdGFydEFuZ2xlICsgc3BhbiAvIDI7XG4gICAgICBjb25zdCBhbmdsZVZhbHVlID0gdmFsdWVzW2FuZ2xlUmF3SWR4XTtcbiAgICAgIGNvbnN0IHJhZGl1c1JhdyA9IHJhZGl1c0lkeCAhPSBudWxsID8gdmFsdWVzW3JhZGl1c0lkeF0gPz8gMSA6IDE7XG4gICAgICBjb25zdCByYWRpdXMgPSByYWRpdXNSYXcgKiBjcm9zc0ZpbHRlclNjYWxlO1xuICAgICAgY29uc3QgcmFkaXVzVmFsdWUgPSByYWRpdXNSYXdJZHggIT0gbnVsbCA/IHZhbHVlc1tyYWRpdXNSYXdJZHhdIDogdm9pZCAwO1xuICAgICAgY29uc3QgbGVnZW5kSXRlbVZhbHVlID0gbGVnZW5kSXRlbUlkeCAhPSBudWxsID8gdmFsdWVzW2xlZ2VuZEl0ZW1JZHhdIDogdm9pZCAwO1xuICAgICAgY29uc3Qgbm9kZUxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKFxuICAgICAgICBkYXR1bSxcbiAgICAgICAgbWlkQW5nbGUsXG4gICAgICAgIHNwYW4sXG4gICAgICAgIHRydWUsXG4gICAgICAgIGNhbGxvdXRMYWJlbElkeCAhPSBudWxsID8gdmFsdWVzW2NhbGxvdXRMYWJlbElkeF0gOiB2b2lkIDAsXG4gICAgICAgIHNlY3RvckxhYmVsSWR4ICE9IG51bGwgPyB2YWx1ZXNbc2VjdG9yTGFiZWxJZHhdIDogdm9pZCAwLFxuICAgICAgICBsZWdlbmRJdGVtVmFsdWVcbiAgICAgICk7XG4gICAgICBjb25zdCBzZWN0b3JGb3JtYXQgPSB0aGlzLmdldFNlY3RvckZvcm1hdChkYXR1bSwgaW5kZXgsIGZhbHNlKTtcbiAgICAgIGNvbnN0IG5vZGUgPSB7XG4gICAgICAgIGl0ZW1JZDogaW5kZXgsXG4gICAgICAgIHNlcmllczogdGhpcyxcbiAgICAgICAgZGF0dW0sXG4gICAgICAgIGluZGV4LFxuICAgICAgICBhbmdsZVZhbHVlLFxuICAgICAgICBtaWRBbmdsZSxcbiAgICAgICAgbWlkQ29zOiBNYXRoLmNvcyhtaWRBbmdsZSksXG4gICAgICAgIG1pZFNpbjogTWF0aC5zaW4obWlkQW5nbGUpLFxuICAgICAgICBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZSxcbiAgICAgICAgcmFkaXVzLFxuICAgICAgICBpbm5lclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KDApLCAwKSxcbiAgICAgICAgb3V0ZXJSYWRpdXM6IE1hdGgubWF4KHRoaXMucmFkaXVzU2NhbGUuY29udmVydChyYWRpdXMpLCAwKSxcbiAgICAgICAgc2VjdG9yRm9ybWF0LFxuICAgICAgICByYWRpdXNWYWx1ZSxcbiAgICAgICAgbGVnZW5kSXRlbVZhbHVlLFxuICAgICAgICBlbmFibGVkOiB0aGlzLnNlcmllc0l0ZW1FbmFibGVkW2luZGV4XSxcbiAgICAgICAgLi4ubm9kZUxhYmVsc1xuICAgICAgfTtcbiAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICBpZiAocGhhbnRvbU5vZGVzICE9IG51bGwpIHtcbiAgICAgICAgcGhhbnRvbU5vZGVzLnB1c2goe1xuICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgcmFkaXVzOiAxLFxuICAgICAgICAgIGlubmVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQoMCksIDApLFxuICAgICAgICAgIG91dGVyUmFkaXVzOiBNYXRoLm1heCh0aGlzLnJhZGl1c1NjYWxlLmNvbnZlcnQoMSksIDApXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuemVyb3N1bU91dGVyUmluZy52aXNpYmxlID0gc3VtMiA9PT0gMDtcbiAgICByZXR1cm4ge1xuICAgICAgaXRlbUlkOiBzZXJpZXNJZCxcbiAgICAgIG5vZGVEYXRhOiBub2RlcyxcbiAgICAgIGxhYmVsRGF0YTogbm9kZXMsXG4gICAgICBwaGFudG9tTm9kZURhdGE6IHBoYW50b21Ob2Rlc1xuICAgIH07XG4gIH1cbiAgZ2V0TGFiZWxzKGRhdHVtLCBtaWRBbmdsZSwgc3Bhbiwgc2tpcERpc2FibGVkLCBjYWxsb3V0TGFiZWxWYWx1ZSwgc2VjdG9yTGFiZWxWYWx1ZSwgbGVnZW5kSXRlbVZhbHVlKSB7XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWwsIHNlY3RvckxhYmVsLCBsZWdlbmRJdGVtS2V5IH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgY2FsbG91dExhYmVsS2V5ID0gIXNraXBEaXNhYmxlZCB8fCBjYWxsb3V0TGFiZWwuZW5hYmxlZCA/IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxLZXkgOiB2b2lkIDA7XG4gICAgY29uc3Qgc2VjdG9yTGFiZWxLZXkgPSAhc2tpcERpc2FibGVkIHx8IHNlY3RvckxhYmVsLmVuYWJsZWQgPyB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxLZXkgOiB2b2lkIDA7XG4gICAgaWYgKCFjYWxsb3V0TGFiZWxLZXkgJiYgIXNlY3RvckxhYmVsS2V5ICYmICFsZWdlbmRJdGVtS2V5KSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IGxhYmVsRm9ybWF0dGVyUGFyYW1zID0ge1xuICAgICAgZGF0dW0sXG4gICAgICBhbmdsZUtleTogdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlS2V5LFxuICAgICAgYW5nbGVOYW1lOiB0aGlzLnByb3BlcnRpZXMuYW5nbGVOYW1lLFxuICAgICAgcmFkaXVzS2V5OiB0aGlzLnByb3BlcnRpZXMucmFkaXVzS2V5LFxuICAgICAgcmFkaXVzTmFtZTogdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c05hbWUsXG4gICAgICBjYWxsb3V0TGFiZWxLZXk6IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWxLZXksXG4gICAgICBjYWxsb3V0TGFiZWxOYW1lOiB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsTmFtZSxcbiAgICAgIHNlY3RvckxhYmVsS2V5OiB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxLZXksXG4gICAgICBzZWN0b3JMYWJlbE5hbWU6IHRoaXMucHJvcGVydGllcy5zZWN0b3JMYWJlbE5hbWUsXG4gICAgICBsZWdlbmRJdGVtS2V5OiB0aGlzLnByb3BlcnRpZXMubGVnZW5kSXRlbUtleVxuICAgIH07XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgaWYgKGNhbGxvdXRMYWJlbEtleSAmJiBzcGFuID4gdG9SYWRpYW5zKGNhbGxvdXRMYWJlbC5taW5BbmdsZSkpIHtcbiAgICAgIHJlc3VsdC5jYWxsb3V0TGFiZWwgPSB7XG4gICAgICAgIC4uLnRoaXMuZ2V0VGV4dEFsaWdubWVudChtaWRBbmdsZSksXG4gICAgICAgIHRleHQ6IHRoaXMuZ2V0TGFiZWxUZXh0KGNhbGxvdXRMYWJlbCwge1xuICAgICAgICAgIC4uLmxhYmVsRm9ybWF0dGVyUGFyYW1zLFxuICAgICAgICAgIHZhbHVlOiBjYWxsb3V0TGFiZWxWYWx1ZVxuICAgICAgICB9KSxcbiAgICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgICAgY29sbGlzaW9uVGV4dEFsaWduOiB2b2lkIDAsXG4gICAgICAgIGNvbGxpc2lvbk9mZnNldFk6IDAsXG4gICAgICAgIGJveDogdm9pZCAwXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoc2VjdG9yTGFiZWxLZXkpIHtcbiAgICAgIHJlc3VsdC5zZWN0b3JMYWJlbCA9IHtcbiAgICAgICAgdGV4dDogdGhpcy5nZXRMYWJlbFRleHQoc2VjdG9yTGFiZWwsIHtcbiAgICAgICAgICAuLi5sYWJlbEZvcm1hdHRlclBhcmFtcyxcbiAgICAgICAgICB2YWx1ZTogc2VjdG9yTGFiZWxWYWx1ZVxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGxlZ2VuZEl0ZW1LZXkgIT0gbnVsbCAmJiBsZWdlbmRJdGVtVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmVzdWx0LmxlZ2VuZEl0ZW0gPSB7IGtleTogbGVnZW5kSXRlbUtleSwgdGV4dDogbGVnZW5kSXRlbVZhbHVlIH07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZ2V0VGV4dEFsaWdubWVudChtaWRBbmdsZSkge1xuICAgIGNvbnN0IHF1YWRyYW50VGV4dE9wdHMgPSBbXG4gICAgICB7IHRleHRBbGlnbjogXCJjZW50ZXJcIiwgdGV4dEJhc2VsaW5lOiBcImJvdHRvbVwiIH0sXG4gICAgICB7IHRleHRBbGlnbjogXCJsZWZ0XCIsIHRleHRCYXNlbGluZTogXCJtaWRkbGVcIiB9LFxuICAgICAgeyB0ZXh0QWxpZ246IFwiY2VudGVyXCIsIHRleHRCYXNlbGluZTogXCJoYW5naW5nXCIgfSxcbiAgICAgIHsgdGV4dEFsaWduOiBcInJpZ2h0XCIsIHRleHRCYXNlbGluZTogXCJtaWRkbGVcIiB9XG4gICAgXTtcbiAgICBjb25zdCBtaWRBbmdsZTE4MCA9IG5vcm1hbGl6ZUFuZ2xlMTgwKG1pZEFuZ2xlKTtcbiAgICBjb25zdCBxdWFkcmFudFN0YXJ0ID0gLTAuNzUgKiBNYXRoLlBJO1xuICAgIGNvbnN0IHF1YWRyYW50T2Zmc2V0ID0gbWlkQW5nbGUxODAgLSBxdWFkcmFudFN0YXJ0O1xuICAgIGNvbnN0IHF1YWRyYW50ID0gTWF0aC5mbG9vcihxdWFkcmFudE9mZnNldCAvIChNYXRoLlBJIC8gMikpO1xuICAgIGNvbnN0IHF1YWRyYW50SW5kZXggPSBtb2QocXVhZHJhbnQsIHF1YWRyYW50VGV4dE9wdHMubGVuZ3RoKTtcbiAgICByZXR1cm4gcXVhZHJhbnRUZXh0T3B0c1txdWFkcmFudEluZGV4XTtcbiAgfVxuICBnZXRTZWN0b3JGb3JtYXQoZGF0dW0sIGZvcm1hdEluZGV4LCBoaWdobGlnaHRlZCkge1xuICAgIGNvbnN0IHsgY2FsbGJhY2tDYWNoZSB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgeyBhbmdsZUtleSwgcmFkaXVzS2V5LCBjYWxsb3V0TGFiZWxLZXksIHNlY3RvckxhYmVsS2V5LCBsZWdlbmRJdGVtS2V5LCBmaWxscywgc3Ryb2tlcywgaXRlbVN0eWxlciB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGRlZmF1bHRTdHJva2UgPSBzdHJva2VzW2Zvcm1hdEluZGV4ICUgc3Ryb2tlcy5sZW5ndGhdO1xuICAgIGNvbnN0IHsgZmlsbCwgZmlsbE9wYWNpdHksIHN0cm9rZSwgc3Ryb2tlV2lkdGgsIHN0cm9rZU9wYWNpdHksIGxpbmVEYXNoLCBsaW5lRGFzaE9mZnNldCwgY29ybmVyUmFkaXVzIH0gPSBtZXJnZURlZmF1bHRzKFxuICAgICAgaGlnaGxpZ2h0ZWQgJiYgdGhpcy5wcm9wZXJ0aWVzLmhpZ2hsaWdodFN0eWxlLml0ZW0sXG4gICAgICB7XG4gICAgICAgIGZpbGw6IGZpbGxzLmxlbmd0aCA+IDAgPyBmaWxsc1tmb3JtYXRJbmRleCAlIGZpbGxzLmxlbmd0aF0gOiB2b2lkIDAsXG4gICAgICAgIHN0cm9rZTogZGVmYXVsdFN0cm9rZSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IHRoaXMuZ2V0U3Ryb2tlV2lkdGgodGhpcy5wcm9wZXJ0aWVzLnN0cm9rZVdpZHRoKSxcbiAgICAgICAgc3Ryb2tlT3BhY2l0eTogdGhpcy5nZXRPcGFjaXR5KClcbiAgICAgIH0sXG4gICAgICB0aGlzLnByb3BlcnRpZXNcbiAgICApO1xuICAgIGxldCBmb3JtYXQ7XG4gICAgaWYgKGl0ZW1TdHlsZXIpIHtcbiAgICAgIGZvcm1hdCA9IGNhbGxiYWNrQ2FjaGUuY2FsbChpdGVtU3R5bGVyLCB7XG4gICAgICAgIGRhdHVtLFxuICAgICAgICBhbmdsZUtleSxcbiAgICAgICAgcmFkaXVzS2V5LFxuICAgICAgICBjYWxsb3V0TGFiZWxLZXksXG4gICAgICAgIHNlY3RvckxhYmVsS2V5LFxuICAgICAgICBsZWdlbmRJdGVtS2V5LFxuICAgICAgICBmaWxsLFxuICAgICAgICBzdHJva2VPcGFjaXR5LFxuICAgICAgICBzdHJva2UsXG4gICAgICAgIHN0cm9rZVdpZHRoLFxuICAgICAgICBmaWxsT3BhY2l0eSxcbiAgICAgICAgbGluZURhc2gsXG4gICAgICAgIGxpbmVEYXNoT2Zmc2V0LFxuICAgICAgICBjb3JuZXJSYWRpdXMsXG4gICAgICAgIGhpZ2hsaWdodGVkLFxuICAgICAgICBzZXJpZXNJZDogdGhpcy5pZFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBmaWxsOiBmb3JtYXQ/LmZpbGwgPz8gZmlsbCxcbiAgICAgIGZpbGxPcGFjaXR5OiBmb3JtYXQ/LmZpbGxPcGFjaXR5ID8/IGZpbGxPcGFjaXR5LFxuICAgICAgc3Ryb2tlOiBmb3JtYXQ/LnN0cm9rZSA/PyBzdHJva2UsXG4gICAgICBzdHJva2VXaWR0aDogZm9ybWF0Py5zdHJva2VXaWR0aCA/PyBzdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZU9wYWNpdHk6IGZvcm1hdD8uc3Ryb2tlT3BhY2l0eSA/PyBzdHJva2VPcGFjaXR5LFxuICAgICAgbGluZURhc2g6IGZvcm1hdD8ubGluZURhc2ggPz8gbGluZURhc2gsXG4gICAgICBsaW5lRGFzaE9mZnNldDogZm9ybWF0Py5saW5lRGFzaE9mZnNldCA/PyBsaW5lRGFzaE9mZnNldCxcbiAgICAgIGNvcm5lclJhZGl1czogZm9ybWF0Py5jb3JuZXJSYWRpdXMgPz8gY29ybmVyUmFkaXVzXG4gICAgfTtcbiAgfVxuICBnZXRPdXRlclJhZGl1cygpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5yYWRpdXMgKiB0aGlzLnByb3BlcnRpZXMub3V0ZXJSYWRpdXNSYXRpbyArIHRoaXMucHJvcGVydGllcy5vdXRlclJhZGl1c09mZnNldCwgMCk7XG4gIH1cbiAgdXBkYXRlUmFkaXVzU2NhbGUocmVzaXplKSB7XG4gICAgY29uc3QgbmV3UmFuZ2UgPSBbMCwgdGhpcy5nZXRPdXRlclJhZGl1cygpXTtcbiAgICB0aGlzLnJhZGl1c1NjYWxlLnJhbmdlID0gbmV3UmFuZ2U7XG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgdGhpcy5wcmV2aW91c1JhZGl1c1NjYWxlLnJhbmdlID0gbmV3UmFuZ2U7XG4gICAgfVxuICAgIGNvbnN0IHNldFJhZGlpID0gKGQpID0+ICh7XG4gICAgICAuLi5kLFxuICAgICAgaW5uZXJSYWRpdXM6IE1hdGgubWF4KHRoaXMucmFkaXVzU2NhbGUuY29udmVydCgwKSwgMCksXG4gICAgICBvdXRlclJhZGl1czogTWF0aC5tYXgodGhpcy5yYWRpdXNTY2FsZS5jb252ZXJ0KGQucmFkaXVzKSwgMClcbiAgICB9KTtcbiAgICB0aGlzLm5vZGVEYXRhID0gdGhpcy5ub2RlRGF0YS5tYXAoc2V0UmFkaWkpO1xuICAgIHRoaXMucGhhbnRvbU5vZGVEYXRhID0gdGhpcy5waGFudG9tTm9kZURhdGE/Lm1hcChzZXRSYWRpaSk7XG4gIH1cbiAgZ2V0VGl0bGVUcmFuc2xhdGlvblkoKSB7XG4gICAgY29uc3Qgb3V0ZXJSYWRpdXMgPSBNYXRoLm1heCgwLCB0aGlzLnJhZGl1c1NjYWxlLnJhbmdlWzFdKTtcbiAgICBpZiAob3V0ZXJSYWRpdXMgPT09IDApIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGNvbnN0IHNwYWNpbmcgPSB0aGlzLnByb3BlcnRpZXMudGl0bGU/LnNwYWNpbmcgPz8gMDtcbiAgICBjb25zdCB0aXRsZU9mZnNldCA9IDIgKyBzcGFjaW5nO1xuICAgIGNvbnN0IGR5ID0gTWF0aC5tYXgoMCwgLW91dGVyUmFkaXVzKTtcbiAgICByZXR1cm4gLW91dGVyUmFkaXVzIC0gdGl0bGVPZmZzZXQgLSBkeTtcbiAgfVxuICBhc3luYyB1cGRhdGUoeyBzZXJpZXNSZWN0IH0pIHtcbiAgICBjb25zdCB7IHRpdGxlIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgbmV3Tm9kZURhdGFEZXBlbmRlbmNpZXMgPSB7XG4gICAgICBzZXJpZXNSZWN0V2lkdGg6IHNlcmllc1JlY3Q/LndpZHRoLFxuICAgICAgc2VyaWVzUmVjdEhlaWdodDogc2VyaWVzUmVjdD8uaGVpZ2h0XG4gICAgfTtcbiAgICBjb25zdCByZXNpemUgPSBqc29uRGlmZih0aGlzLm5vZGVEYXRhRGVwZW5kZW5jaWVzLCBuZXdOb2RlRGF0YURlcGVuZGVuY2llcykgIT0gbnVsbDtcbiAgICBpZiAocmVzaXplKSB7XG4gICAgICB0aGlzLl9ub2RlRGF0YURlcGVuZGVuY2llcyA9IG5ld05vZGVEYXRhRGVwZW5kZW5jaWVzO1xuICAgIH1cbiAgICBhd2FpdCB0aGlzLm1heWJlUmVmcmVzaE5vZGVEYXRhKCk7XG4gICAgdGhpcy51cGRhdGVUaXRsZU5vZGVzKCk7XG4gICAgdGhpcy51cGRhdGVSYWRpdXNTY2FsZShyZXNpemUpO1xuICAgIHRoaXMuY29udGVudEdyb3VwLnRyYW5zbGF0aW9uWCA9IHRoaXMuY2VudGVyWDtcbiAgICB0aGlzLmNvbnRlbnRHcm91cC50cmFuc2xhdGlvblkgPSB0aGlzLmNlbnRlclk7XG4gICAgdGhpcy5oaWdobGlnaHRHcm91cC50cmFuc2xhdGlvblggPSB0aGlzLmNlbnRlclg7XG4gICAgdGhpcy5oaWdobGlnaHRHcm91cC50cmFuc2xhdGlvblkgPSB0aGlzLmNlbnRlclk7XG4gICAgdGhpcy5iYWNrZ3JvdW5kR3JvdXAudHJhbnNsYXRpb25YID0gdGhpcy5jZW50ZXJYO1xuICAgIHRoaXMuYmFja2dyb3VuZEdyb3VwLnRyYW5zbGF0aW9uWSA9IHRoaXMuY2VudGVyWTtcbiAgICBpZiAodGhpcy5sYWJlbEdyb3VwKSB7XG4gICAgICB0aGlzLmxhYmVsR3JvdXAudHJhbnNsYXRpb25YID0gdGhpcy5jZW50ZXJYO1xuICAgICAgdGhpcy5sYWJlbEdyb3VwLnRyYW5zbGF0aW9uWSA9IHRoaXMuY2VudGVyWTtcbiAgICB9XG4gICAgaWYgKHRpdGxlKSB7XG4gICAgICBjb25zdCBkeSA9IHRoaXMuZ2V0VGl0bGVUcmFuc2xhdGlvblkoKTtcbiAgICAgIGNvbnN0IHRpdGxlQm94ID0gdGl0bGUubm9kZS5nZXRCQm94KCk7XG4gICAgICB0aXRsZS5ub2RlLnZpc2libGUgPSB0aXRsZS5lbmFibGVkICYmIGlzRmluaXRlKGR5KSAmJiAhdGhpcy5iYm94SW50ZXJzZWN0c1N1cnJvdW5kaW5nU2VyaWVzKHRpdGxlQm94LCAwLCBkeSk7XG4gICAgICB0aXRsZS5ub2RlLnRyYW5zbGF0aW9uWSA9IGlzRmluaXRlKGR5KSA/IGR5IDogMDtcbiAgICB9XG4gICAgdGhpcy56ZXJvc3VtT3V0ZXJSaW5nLmZpbGxPcGFjaXR5ID0gMDtcbiAgICB0aGlzLnplcm9zdW1PdXRlclJpbmcuc3Ryb2tlID0gdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbC5jb2xvcjtcbiAgICB0aGlzLnplcm9zdW1PdXRlclJpbmcuc3Ryb2tlV2lkdGggPSAxO1xuICAgIHRoaXMuemVyb3N1bU91dGVyUmluZy5zdHJva2VPcGFjaXR5ID0gMTtcbiAgICB0aGlzLnVwZGF0ZU5vZGVNaWRQb2ludCgpO1xuICAgIGF3YWl0IHRoaXMudXBkYXRlU2VsZWN0aW9ucygpO1xuICAgIGF3YWl0IHRoaXMudXBkYXRlTm9kZXMoc2VyaWVzUmVjdCk7XG4gIH1cbiAgdXBkYXRlVGl0bGVOb2RlcygpIHtcbiAgICBjb25zdCB7IG9sZFRpdGxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgdGl0bGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAob2xkVGl0bGUgIT09IHRpdGxlKSB7XG4gICAgICBpZiAob2xkVGl0bGUpIHtcbiAgICAgICAgdGhpcy5sYWJlbEdyb3VwPy5yZW1vdmVDaGlsZChvbGRUaXRsZS5ub2RlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICB0aXRsZS5ub2RlLnRleHRCYXNlbGluZSA9IFwiYm90dG9tXCI7XG4gICAgICAgIHRoaXMubGFiZWxHcm91cD8uYXBwZW5kQ2hpbGQodGl0bGUubm9kZSk7XG4gICAgICB9XG4gICAgICB0aGlzLm9sZFRpdGxlID0gdGl0bGU7XG4gICAgfVxuICB9XG4gIHVwZGF0ZU5vZGVNaWRQb2ludCgpIHtcbiAgICBjb25zdCBzZXRNaWRQb2ludCA9IChkKSA9PiB7XG4gICAgICBjb25zdCByYWRpdXMgPSBkLmlubmVyUmFkaXVzICsgKGQub3V0ZXJSYWRpdXMgLSBkLmlubmVyUmFkaXVzKSAvIDI7XG4gICAgICBkLm1pZFBvaW50ID0ge1xuICAgICAgICB4OiBkLm1pZENvcyAqIE1hdGgubWF4KDAsIHJhZGl1cyksXG4gICAgICAgIHk6IGQubWlkU2luICogTWF0aC5tYXgoMCwgcmFkaXVzKVxuICAgICAgfTtcbiAgICB9O1xuICAgIHRoaXMubm9kZURhdGEuZm9yRWFjaChzZXRNaWRQb2ludCk7XG4gICAgdGhpcy5waGFudG9tTm9kZURhdGE/LmZvckVhY2goc2V0TWlkUG9pbnQpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZVNlbGVjdGlvbnMoKSB7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVHcm91cFNlbGVjdGlvbigpO1xuICB9XG4gIGFzeW5jIHVwZGF0ZUdyb3VwU2VsZWN0aW9uKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGl0ZW1TZWxlY3Rpb24sXG4gICAgICBoaWdobGlnaHRTZWxlY3Rpb24sXG4gICAgICBwaGFudG9tU2VsZWN0aW9uLFxuICAgICAgaGlnaGxpZ2h0TGFiZWxTZWxlY3Rpb24sXG4gICAgICBjYWxsb3V0TGFiZWxTZWxlY3Rpb24sXG4gICAgICBsYWJlbFNlbGVjdGlvblxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGhpZ2hsaWdodGVkTm9kZURhdGEgPSB0aGlzLm5vZGVEYXRhLm1hcCgoZGF0dW0pID0+ICh7XG4gICAgICAuLi5kYXR1bSxcbiAgICAgIC8vIEFsbG93IG11dGFibGUgc2VjdG9yRm9ybWF0LCBzbyBmb3JtYXR0ZWQgc2VjdG9yIHN0eWxlcyBjYW4gYmUgdXBkYXRlZCBhbmQgdmFyaWVkXG4gICAgICAvLyBiZXR3ZWVuIG5vcm1hbCBhbmQgaGlnaGxpZ2h0ZWQgY2FzZXMuXG4gICAgICBzZWN0b3JGb3JtYXQ6IHsgLi4uZGF0dW0uc2VjdG9yRm9ybWF0IH1cbiAgICB9KSk7XG4gICAgY29uc3QgdXBkYXRlID0gKHNlbGVjdGlvbiwgbm9kZURhdGEpID0+IHtcbiAgICAgIHNlbGVjdGlvbi51cGRhdGUobm9kZURhdGEsIHZvaWQgMCwgKGRhdHVtKSA9PiB0aGlzLmdldERhdHVtSWQoZGF0dW0pKTtcbiAgICAgIGlmICh0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLmlzU2tpcHBlZCgpKSB7XG4gICAgICAgIHNlbGVjdGlvbi5jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB1cGRhdGUoaXRlbVNlbGVjdGlvbiwgdGhpcy5ub2RlRGF0YSk7XG4gICAgdXBkYXRlKGhpZ2hsaWdodFNlbGVjdGlvbiwgaGlnaGxpZ2h0ZWROb2RlRGF0YSk7XG4gICAgdXBkYXRlKHBoYW50b21TZWxlY3Rpb24sIHRoaXMucGhhbnRvbU5vZGVEYXRhID8/IFtdKTtcbiAgICBjYWxsb3V0TGFiZWxTZWxlY3Rpb24udXBkYXRlKHRoaXMuY2FsbG91dE5vZGVEYXRhLCAoZ3JvdXApID0+IHtcbiAgICAgIGNvbnN0IGxpbmUgPSBuZXcgTGluZSgpO1xuICAgICAgbGluZS50YWcgPSAwIC8qIENhbGxvdXQgKi87XG4gICAgICBsaW5lLnBvaW50ZXJFdmVudHMgPSAxIC8qIE5vbmUgKi87XG4gICAgICBncm91cC5hcHBlbmRDaGlsZChsaW5lKTtcbiAgICAgIGNvbnN0IHRleHQgPSBuZXcgVGV4dCgpO1xuICAgICAgdGV4dC50YWcgPSAxIC8qIExhYmVsICovO1xuICAgICAgdGV4dC5wb2ludGVyRXZlbnRzID0gMSAvKiBOb25lICovO1xuICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQodGV4dCk7XG4gICAgfSk7XG4gICAgbGFiZWxTZWxlY3Rpb24udXBkYXRlKHRoaXMubm9kZURhdGEpO1xuICAgIGhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLnVwZGF0ZShoaWdobGlnaHRlZE5vZGVEYXRhKTtcbiAgfVxuICBhc3luYyB1cGRhdGVOb2RlcyhzZXJpZXNSZWN0KSB7XG4gICAgY29uc3QgaGlnaGxpZ2h0ZWREYXR1bSA9IHRoaXMuY3R4LmhpZ2hsaWdodE1hbmFnZXIuZ2V0QWN0aXZlSGlnaGxpZ2h0KCk7XG4gICAgY29uc3QgaXNWaXNpYmxlID0gdGhpcy52aXNpYmxlICYmIHRoaXMuc2VyaWVzSXRlbUVuYWJsZWQuaW5kZXhPZih0cnVlKSA+PSAwO1xuICAgIHRoaXMucm9vdEdyb3VwLnZpc2libGUgPSBpc1Zpc2libGU7XG4gICAgdGhpcy5iYWNrZ3JvdW5kR3JvdXAudmlzaWJsZSA9IGlzVmlzaWJsZTtcbiAgICB0aGlzLmNvbnRlbnRHcm91cC52aXNpYmxlID0gaXNWaXNpYmxlO1xuICAgIHRoaXMuaGlnaGxpZ2h0R3JvdXAudmlzaWJsZSA9IGlzVmlzaWJsZSAmJiBoaWdobGlnaHRlZERhdHVtPy5zZXJpZXMgPT09IHRoaXM7XG4gICAgdGhpcy5oaWdobGlnaHRMYWJlbC52aXNpYmxlID0gaXNWaXNpYmxlICYmIGhpZ2hsaWdodGVkRGF0dW0/LnNlcmllcyA9PT0gdGhpcztcbiAgICBpZiAodGhpcy5sYWJlbEdyb3VwKSB7XG4gICAgICB0aGlzLmxhYmVsR3JvdXAudmlzaWJsZSA9IGlzVmlzaWJsZTtcbiAgICB9XG4gICAgdGhpcy5jb250ZW50R3JvdXAub3BhY2l0eSA9IHRoaXMuZ2V0T3BhY2l0eSgpO1xuICAgIGNvbnN0IGFuaW1hdGlvbkRpc2FibGVkID0gdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5pc1NraXBwZWQoKTtcbiAgICBjb25zdCB1cGRhdGVTZWN0b3JGbiA9IChzZWN0b3IsIGRhdHVtLCBfaW5kZXgsIGlzRGF0dW1IaWdobGlnaHRlZCkgPT4ge1xuICAgICAgY29uc3QgZm9ybWF0ID0gdGhpcy5nZXRTZWN0b3JGb3JtYXQoZGF0dW0uZGF0dW0sIGRhdHVtLml0ZW1JZCwgaXNEYXR1bUhpZ2hsaWdodGVkKTtcbiAgICAgIGRhdHVtLnNlY3RvckZvcm1hdC5maWxsID0gZm9ybWF0LmZpbGw7XG4gICAgICBkYXR1bS5zZWN0b3JGb3JtYXQuc3Ryb2tlID0gZm9ybWF0LnN0cm9rZTtcbiAgICAgIGlmIChhbmltYXRpb25EaXNhYmxlZCkge1xuICAgICAgICBzZWN0b3Iuc3RhcnRBbmdsZSA9IGRhdHVtLnN0YXJ0QW5nbGU7XG4gICAgICAgIHNlY3Rvci5lbmRBbmdsZSA9IGRhdHVtLmVuZEFuZ2xlO1xuICAgICAgICBzZWN0b3IuaW5uZXJSYWRpdXMgPSBkYXR1bS5pbm5lclJhZGl1cztcbiAgICAgICAgc2VjdG9yLm91dGVyUmFkaXVzID0gZGF0dW0ub3V0ZXJSYWRpdXM7XG4gICAgICB9XG4gICAgICBpZiAoaXNEYXR1bUhpZ2hsaWdodGVkIHx8IGFuaW1hdGlvbkRpc2FibGVkKSB7XG4gICAgICAgIHNlY3Rvci5maWxsID0gZm9ybWF0LmZpbGw7XG4gICAgICAgIHNlY3Rvci5zdHJva2UgPSBmb3JtYXQuc3Ryb2tlO1xuICAgICAgfVxuICAgICAgc2VjdG9yLnN0cm9rZVdpZHRoID0gZm9ybWF0LnN0cm9rZVdpZHRoO1xuICAgICAgc2VjdG9yLmZpbGxPcGFjaXR5ID0gZm9ybWF0LmZpbGxPcGFjaXR5O1xuICAgICAgc2VjdG9yLnN0cm9rZU9wYWNpdHkgPSBmb3JtYXQuc3Ryb2tlT3BhY2l0eTtcbiAgICAgIHNlY3Rvci5saW5lRGFzaCA9IGZvcm1hdC5saW5lRGFzaDtcbiAgICAgIHNlY3Rvci5saW5lRGFzaE9mZnNldCA9IGZvcm1hdC5saW5lRGFzaE9mZnNldDtcbiAgICAgIHNlY3Rvci5jb3JuZXJSYWRpdXMgPSBmb3JtYXQuY29ybmVyUmFkaXVzO1xuICAgICAgc2VjdG9yLmZpbGxTaGFkb3cgPSB0aGlzLnByb3BlcnRpZXMuc2hhZG93O1xuICAgICAgY29uc3QgaW5zZXQgPSBNYXRoLm1heChcbiAgICAgICAgKHRoaXMucHJvcGVydGllcy5zZWN0b3JTcGFjaW5nICsgKGZvcm1hdC5zdHJva2UgIT0gbnVsbCA/IGZvcm1hdC5zdHJva2VXaWR0aCA6IDApKSAvIDIsXG4gICAgICAgIDBcbiAgICAgICk7XG4gICAgICBzZWN0b3IuaW5zZXQgPSBpbnNldDtcbiAgICAgIHNlY3Rvci5saW5lSm9pbiA9IHRoaXMucHJvcGVydGllcy5zZWN0b3JTcGFjaW5nID49IDAgfHwgaW5zZXQgPiAwID8gXCJtaXRlclwiIDogXCJyb3VuZFwiO1xuICAgIH07XG4gICAgdGhpcy5pdGVtU2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtLCBpbmRleCkgPT4gdXBkYXRlU2VjdG9yRm4obm9kZSwgZGF0dW0sIGluZGV4LCBmYWxzZSkpO1xuICAgIHRoaXMuaGlnaGxpZ2h0U2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtLCBpbmRleCkgPT4ge1xuICAgICAgdXBkYXRlU2VjdG9yRm4obm9kZSwgZGF0dW0sIGluZGV4LCB0cnVlKTtcbiAgICAgIGlmIChkYXR1bS5pdGVtSWQgPT09IGhpZ2hsaWdodGVkRGF0dW0/Lml0ZW1JZCkge1xuICAgICAgICBub2RlLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB1cGRhdGVTZWN0b3JGbihub2RlLCBkYXR1bSwgaW5kZXgsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS52aXNpYmxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5waGFudG9tU2VsZWN0aW9uLmVhY2goKG5vZGUsIGRhdHVtLCBpbmRleCkgPT4gdXBkYXRlU2VjdG9yRm4obm9kZSwgZGF0dW0sIGluZGV4LCBmYWxzZSkpO1xuICAgIHRoaXMudXBkYXRlQ2FsbG91dExpbmVOb2RlcygpO1xuICAgIHRoaXMudXBkYXRlQ2FsbG91dExhYmVsTm9kZXMoc2VyaWVzUmVjdCk7XG4gICAgdGhpcy51cGRhdGVTZWN0b3JMYWJlbE5vZGVzKCk7XG4gICAgdGhpcy51cGRhdGVaZXJvc3VtUmluZ3MoKTtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJ1cGRhdGVcIik7XG4gIH1cbiAgdXBkYXRlQ2FsbG91dExpbmVOb2RlcygpIHtcbiAgICBjb25zdCB7IGNhbGxvdXRMaW5lIH0gPSB0aGlzLnByb3BlcnRpZXM7XG4gICAgY29uc3QgY2FsbG91dExlbmd0aCA9IGNhbGxvdXRMaW5lLmxlbmd0aDtcbiAgICBjb25zdCBjYWxsb3V0U3Ryb2tlV2lkdGggPSBjYWxsb3V0TGluZS5zdHJva2VXaWR0aDtcbiAgICBjb25zdCBjYWxsb3V0Q29sb3JzID0gY2FsbG91dExpbmUuY29sb3JzID8/IHRoaXMucHJvcGVydGllcy5zdHJva2VzO1xuICAgIGNvbnN0IHsgb2Zmc2V0OiBvZmZzZXQ0IH0gPSB0aGlzLnByb3BlcnRpZXMuY2FsbG91dExhYmVsO1xuICAgIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uLnNlbGVjdEJ5VGFnKDAgLyogQ2FsbG91dCAqLykuZm9yRWFjaCgobGluZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGRhdHVtID0gbGluZS5kYXR1bTtcbiAgICAgIGNvbnN0IHsgY2FsbG91dExhYmVsOiBsYWJlbCwgb3V0ZXJSYWRpdXMgfSA9IGRhdHVtO1xuICAgICAgaWYgKGxhYmVsPy50ZXh0ICYmICFsYWJlbC5oaWRkZW4gJiYgb3V0ZXJSYWRpdXMgIT09IDApIHtcbiAgICAgICAgbGluZS52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgbGluZS5zdHJva2VXaWR0aCA9IGNhbGxvdXRTdHJva2VXaWR0aDtcbiAgICAgICAgbGluZS5zdHJva2UgPSBjYWxsb3V0Q29sb3JzW2luZGV4ICUgY2FsbG91dENvbG9ycy5sZW5ndGhdO1xuICAgICAgICBsaW5lLmZpbGwgPSB2b2lkIDA7XG4gICAgICAgIGNvbnN0IHgxID0gZGF0dW0ubWlkQ29zICogb3V0ZXJSYWRpdXM7XG4gICAgICAgIGNvbnN0IHkxID0gZGF0dW0ubWlkU2luICogb3V0ZXJSYWRpdXM7XG4gICAgICAgIGxldCB4MiA9IGRhdHVtLm1pZENvcyAqIChvdXRlclJhZGl1cyArIGNhbGxvdXRMZW5ndGgpO1xuICAgICAgICBsZXQgeTIgPSBkYXR1bS5taWRTaW4gKiAob3V0ZXJSYWRpdXMgKyBjYWxsb3V0TGVuZ3RoKTtcbiAgICAgICAgY29uc3QgaXNNb3ZlZCA9IGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA/PyBsYWJlbC5jb2xsaXNpb25PZmZzZXRZICE9PSAwO1xuICAgICAgICBpZiAoaXNNb3ZlZCAmJiBsYWJlbC5ib3ggIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGJveCA9IGxhYmVsLmJveDtcbiAgICAgICAgICBsZXQgY3ggPSB4MjtcbiAgICAgICAgICBsZXQgY3kgPSB5MjtcbiAgICAgICAgICBpZiAoeDIgPCBib3gueCkge1xuICAgICAgICAgICAgY3ggPSBib3gueDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHgyID4gYm94LnggKyBib3gud2lkdGgpIHtcbiAgICAgICAgICAgIGN4ID0gYm94LnggKyBib3gud2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh5MiA8IGJveC55KSB7XG4gICAgICAgICAgICBjeSA9IGJveC55O1xuICAgICAgICAgIH0gZWxzZSBpZiAoeTIgPiBib3gueSArIGJveC5oZWlnaHQpIHtcbiAgICAgICAgICAgIGN5ID0gYm94LnkgKyBib3guaGVpZ2h0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBkeCA9IGN4IC0geDI7XG4gICAgICAgICAgY29uc3QgZHkgPSBjeSAtIHkyO1xuICAgICAgICAgIGNvbnN0IGxlbmd0aDIgPSBNYXRoLnNxcnQoTWF0aC5wb3coZHgsIDIpICsgTWF0aC5wb3coZHksIDIpKTtcbiAgICAgICAgICBjb25zdCBwYWRkZWRMZW5ndGggPSBsZW5ndGgyIC0gb2Zmc2V0NDtcbiAgICAgICAgICBpZiAocGFkZGVkTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgeDIgPSB4MiArIGR4ICogcGFkZGVkTGVuZ3RoIC8gbGVuZ3RoMjtcbiAgICAgICAgICAgIHkyID0geTIgKyBkeSAqIHBhZGRlZExlbmd0aCAvIGxlbmd0aDI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxpbmUueDEgPSB4MTtcbiAgICAgICAgbGluZS55MSA9IHkxO1xuICAgICAgICBsaW5lLngyID0geDI7XG4gICAgICAgIGxpbmUueTIgPSB5MjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmUudmlzaWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldExhYmVsT3ZlcmZsb3codGV4dCwgYm94LCBzZXJpZXNSZWN0KSB7XG4gICAgY29uc3Qgc2VyaWVzTGVmdCA9IHNlcmllc1JlY3QueCAtIHRoaXMuY2VudGVyWDtcbiAgICBjb25zdCBzZXJpZXNSaWdodCA9IHNlcmllc1JlY3QueCArIHNlcmllc1JlY3Qud2lkdGggLSB0aGlzLmNlbnRlclg7XG4gICAgY29uc3Qgc2VyaWVzVG9wID0gc2VyaWVzUmVjdC55IC0gdGhpcy5jZW50ZXJZO1xuICAgIGNvbnN0IHNlcmllc0JvdHRvbSA9IHNlcmllc1JlY3QueSArIHNlcmllc1JlY3QuaGVpZ2h0IC0gdGhpcy5jZW50ZXJZO1xuICAgIGNvbnN0IGVyclB4ID0gMTtcbiAgICBsZXQgdmlzaWJsZVRleHRQYXJ0ID0gMTtcbiAgICBpZiAoYm94LnggKyBlcnJQeCA8IHNlcmllc0xlZnQpIHtcbiAgICAgIHZpc2libGVUZXh0UGFydCA9IChib3gueCArIGJveC53aWR0aCAtIHNlcmllc0xlZnQpIC8gYm94LndpZHRoO1xuICAgIH0gZWxzZSBpZiAoYm94LnggKyBib3gud2lkdGggLSBlcnJQeCA+IHNlcmllc1JpZ2h0KSB7XG4gICAgICB2aXNpYmxlVGV4dFBhcnQgPSAoc2VyaWVzUmlnaHQgLSBib3gueCkgLyBib3gud2lkdGg7XG4gICAgfVxuICAgIGNvbnN0IGhhc1ZlcnRpY2FsT3ZlcmZsb3cgPSBib3gueSArIGVyclB4IDwgc2VyaWVzVG9wIHx8IGJveC55ICsgYm94LmhlaWdodCAtIGVyclB4ID4gc2VyaWVzQm90dG9tO1xuICAgIGNvbnN0IHRleHRMZW5ndGggPSB2aXNpYmxlVGV4dFBhcnQgPT09IDEgPyB0ZXh0Lmxlbmd0aCA6IE1hdGguZmxvb3IodGV4dC5sZW5ndGggKiB2aXNpYmxlVGV4dFBhcnQpIC0gMTtcbiAgICBjb25zdCBoYXNTdXJyb3VuZGluZ1Nlcmllc092ZXJmbG93ID0gdGhpcy5iYm94SW50ZXJzZWN0c1N1cnJvdW5kaW5nU2VyaWVzKGJveCk7XG4gICAgcmV0dXJuIHsgdGV4dExlbmd0aCwgaGFzVmVydGljYWxPdmVyZmxvdywgaGFzU3Vycm91bmRpbmdTZXJpZXNPdmVyZmxvdyB9O1xuICB9XG4gIGJib3hJbnRlcnNlY3RzU3Vycm91bmRpbmdTZXJpZXMoYm94LCBkeCA9IDAsIGR5ID0gMCkge1xuICAgIGNvbnN0IHsgc3Vycm91bmRpbmdSYWRpdXMgfSA9IHRoaXM7XG4gICAgaWYgKHN1cnJvdW5kaW5nUmFkaXVzID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgY29ybmVycyA9IFtcbiAgICAgIHsgeDogYm94LnggKyBkeCwgeTogYm94LnkgKyBkeSB9LFxuICAgICAgeyB4OiBib3gueCArIGJveC53aWR0aCArIGR4LCB5OiBib3gueSArIGR5IH0sXG4gICAgICB7IHg6IGJveC54ICsgYm94LndpZHRoICsgZHgsIHk6IGJveC55ICsgYm94LmhlaWdodCArIGR5IH0sXG4gICAgICB7IHg6IGJveC54ICsgZHgsIHk6IGJveC55ICsgYm94LmhlaWdodCArIGR5IH1cbiAgICBdO1xuICAgIGNvbnN0IHN1cjIgPSBzdXJyb3VuZGluZ1JhZGl1cyAqKiAyO1xuICAgIHJldHVybiBjb3JuZXJzLnNvbWUoKGNvcm5lcikgPT4gY29ybmVyLnggKiogMiArIGNvcm5lci55ICoqIDIgPiBzdXIyKTtcbiAgfVxuICBjb21wdXRlQ2FsbG91dExhYmVsQ29sbGlzaW9uT2Zmc2V0cygpIHtcbiAgICBjb25zdCB7IHJhZGl1c1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsLCBjYWxsb3V0TGluZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IHsgb2Zmc2V0OiBvZmZzZXQ0LCBtaW5TcGFjaW5nIH0gPSBjYWxsb3V0TGFiZWw7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSByYWRpdXNTY2FsZS5jb252ZXJ0KDApO1xuICAgIGNvbnN0IHNob3VsZFNraXAgPSAoZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsID0gZGF0dW0uY2FsbG91dExhYmVsO1xuICAgICAgcmV0dXJuICFsYWJlbCB8fCBkYXR1bS5vdXRlclJhZGl1cyA9PT0gMDtcbiAgICB9O1xuICAgIGNvbnN0IGZ1bGxEYXRhID0gdGhpcy5jYWxsb3V0Tm9kZURhdGE7XG4gICAgY29uc3QgZGF0YSA9IGZ1bGxEYXRhLmZpbHRlcigodCkgPT4gIXNob3VsZFNraXAodCkpO1xuICAgIGRhdGEuZm9yRWFjaCgoZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsID0gZGF0dW0uY2FsbG91dExhYmVsO1xuICAgICAgaWYgKGxhYmVsID09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxhYmVsLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID0gdm9pZCAwO1xuICAgICAgbGFiZWwuY29sbGlzaW9uT2Zmc2V0WSA9IDA7XG4gICAgfSk7XG4gICAgaWYgKGRhdGEubGVuZ3RoIDw9IDEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGVmdExhYmVscyA9IGRhdGEuZmlsdGVyKChkKSA9PiBkLm1pZENvcyA8IDApLnNvcnQoKGEsIGIpID0+IGEubWlkU2luIC0gYi5taWRTaW4pO1xuICAgIGNvbnN0IHJpZ2h0TGFiZWxzID0gZGF0YS5maWx0ZXIoKGQpID0+IGQubWlkQ29zID49IDApLnNvcnQoKGEsIGIpID0+IGEubWlkU2luIC0gYi5taWRTaW4pO1xuICAgIGNvbnN0IHRvcExhYmVscyA9IGRhdGEuZmlsdGVyKChkKSA9PiBkLm1pZFNpbiA8IDAgJiYgZC5jYWxsb3V0TGFiZWw/LnRleHRBbGlnbiA9PT0gXCJjZW50ZXJcIikuc29ydCgoYSwgYikgPT4gYS5taWRDb3MgLSBiLm1pZENvcyk7XG4gICAgY29uc3QgYm90dG9tTGFiZWxzID0gZGF0YS5maWx0ZXIoKGQpID0+IGQubWlkU2luID49IDAgJiYgZC5jYWxsb3V0TGFiZWw/LnRleHRBbGlnbiA9PT0gXCJjZW50ZXJcIikuc29ydCgoYSwgYikgPT4gYS5taWRDb3MgLSBiLm1pZENvcyk7XG4gICAgY29uc3QgZ2V0VGV4dEJCb3ggPSAoZGF0dW0pID0+IHtcbiAgICAgIGNvbnN0IGxhYmVsID0gZGF0dW0uY2FsbG91dExhYmVsO1xuICAgICAgaWYgKGxhYmVsID09IG51bGwpXG4gICAgICAgIHJldHVybiBCQm94Lnplcm8uY2xvbmUoKTtcbiAgICAgIGNvbnN0IGxhYmVsUmFkaXVzID0gZGF0dW0ub3V0ZXJSYWRpdXMgKyBjYWxsb3V0TGluZS5sZW5ndGggKyBvZmZzZXQ0O1xuICAgICAgY29uc3QgeCA9IGRhdHVtLm1pZENvcyAqIGxhYmVsUmFkaXVzO1xuICAgICAgY29uc3QgeSA9IGRhdHVtLm1pZFNpbiAqIGxhYmVsUmFkaXVzICsgbGFiZWwuY29sbGlzaW9uT2Zmc2V0WTtcbiAgICAgIGNvbnN0IHRleHRBbGlnbiA9IGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA/PyBsYWJlbC50ZXh0QWxpZ247XG4gICAgICBjb25zdCB0ZXh0QmFzZWxpbmUgPSBsYWJlbC50ZXh0QmFzZWxpbmU7XG4gICAgICByZXR1cm4gVGV4dC5jb21wdXRlQkJveChsYWJlbC50ZXh0LCB4LCB5LCB7XG4gICAgICAgIGZvbnQ6IHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWwsXG4gICAgICAgIHRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IGF2b2lkTmVpZ2hib3VyWUNvbGxpc2lvbiA9IChsYWJlbCwgbmV4dCwgZGlyZWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCBib3ggPSBnZXRUZXh0QkJveChsYWJlbCkuZ3JvdyhtaW5TcGFjaW5nIC8gMik7XG4gICAgICBjb25zdCBvdGhlciA9IGdldFRleHRCQm94KG5leHQpLmdyb3cobWluU3BhY2luZyAvIDIpO1xuICAgICAgY29uc3QgY29sbGlkZXNPckJlaGluZCA9IGJveC54IDwgb3RoZXIueCArIG90aGVyLndpZHRoICYmIGJveC54ICsgYm94LndpZHRoID4gb3RoZXIueCAmJiAoZGlyZWN0aW9uID09PSBcInRvLXRvcFwiID8gYm94LnkgPCBvdGhlci55ICsgb3RoZXIuaGVpZ2h0IDogYm94LnkgKyBib3guaGVpZ2h0ID4gb3RoZXIueSk7XG4gICAgICBpZiAoY29sbGlkZXNPckJlaGluZCkge1xuICAgICAgICBjb25zdCBkeSA9IGRpcmVjdGlvbiA9PT0gXCJ0by10b3BcIiA/IGJveC55IC0gb3RoZXIueSAtIG90aGVyLmhlaWdodCA6IGJveC55ICsgYm94LmhlaWdodCAtIG90aGVyLnk7XG4gICAgICAgIG5leHQuY2FsbG91dExhYmVsLmNvbGxpc2lvbk9mZnNldFkgPSBkeTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IGF2b2lkWUNvbGxpc2lvbnMgPSAobGFiZWxzKSA9PiB7XG4gICAgICBjb25zdCBtaWRMYWJlbCA9IGxhYmVscy5zbGljZSgpLnNvcnQoKGEsIGIpID0+IE1hdGguYWJzKGEubWlkU2luKSAtIE1hdGguYWJzKGIubWlkU2luKSlbMF07XG4gICAgICBjb25zdCBtaWRJbmRleCA9IGxhYmVscy5pbmRleE9mKG1pZExhYmVsKTtcbiAgICAgIGZvciAobGV0IGkgPSBtaWRJbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBsYWJlbHNbaSArIDFdO1xuICAgICAgICBjb25zdCBuZXh0ID0gbGFiZWxzW2ldO1xuICAgICAgICBhdm9pZE5laWdoYm91cllDb2xsaXNpb24ocHJldiwgbmV4dCwgXCJ0by10b3BcIik7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gbWlkSW5kZXggKyAxOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHByZXYgPSBsYWJlbHNbaSAtIDFdO1xuICAgICAgICBjb25zdCBuZXh0ID0gbGFiZWxzW2ldO1xuICAgICAgICBhdm9pZE5laWdoYm91cllDb2xsaXNpb24ocHJldiwgbmV4dCwgXCJ0by1ib3R0b21cIik7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBhdm9pZFhDb2xsaXNpb25zID0gKGxhYmVscykgPT4ge1xuICAgICAgY29uc3QgbGFiZWxzQ29sbGlkZUxhYmVsc0J5WSA9IGRhdGEuc29tZSgoZGF0dW0pID0+IGRhdHVtLmNhbGxvdXRMYWJlbC5jb2xsaXNpb25PZmZzZXRZICE9PSAwKTtcbiAgICAgIGNvbnN0IGJveGVzID0gbGFiZWxzLm1hcCgobGFiZWwpID0+IGdldFRleHRCQm94KGxhYmVsKSk7XG4gICAgICBjb25zdCBwYWRkZWRCb3hlcyA9IGJveGVzLm1hcCgoYm94KSA9PiBib3guY2xvbmUoKS5ncm93KG1pblNwYWNpbmcgLyAyKSk7XG4gICAgICBsZXQgbGFiZWxzQ29sbGlkZUxhYmVsc0J5WCA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWRkZWRCb3hlcy5sZW5ndGggJiYgIWxhYmVsc0NvbGxpZGVMYWJlbHNCeVg7IGkrKykge1xuICAgICAgICBjb25zdCBib3ggPSBwYWRkZWRCb3hlc1tpXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgbGFiZWxzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3Qgb3RoZXIgPSBwYWRkZWRCb3hlc1tqXTtcbiAgICAgICAgICBpZiAoYm94LmNvbGxpZGVzQkJveChvdGhlcikpIHtcbiAgICAgICAgICAgIGxhYmVsc0NvbGxpZGVMYWJlbHNCeVggPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBzZWN0b3JzID0gZnVsbERhdGEubWFwKChkYXR1bSkgPT4ge1xuICAgICAgICBjb25zdCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBvdXRlclJhZGl1cyB9ID0gZGF0dW07XG4gICAgICAgIHJldHVybiB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMgfTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbGFiZWxzQ29sbGlkZVNlY3RvcnMgPSBib3hlcy5zb21lKChib3gpID0+IHtcbiAgICAgICAgcmV0dXJuIHNlY3RvcnMuc29tZSgoc2VjdG9yKSA9PiBib3hDb2xsaWRlc1NlY3Rvcihib3gsIHNlY3RvcikpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIWxhYmVsc0NvbGxpZGVMYWJlbHNCeVggJiYgIWxhYmVsc0NvbGxpZGVMYWJlbHNCeVkgJiYgIWxhYmVsc0NvbGxpZGVTZWN0b3JzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxhYmVscy5maWx0ZXIoKGQpID0+IGQuY2FsbG91dExhYmVsLnRleHRBbGlnbiA9PT0gXCJjZW50ZXJcIikuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgICBjb25zdCBsYWJlbCA9IGQuY2FsbG91dExhYmVsO1xuICAgICAgICBpZiAoZC5taWRDb3MgPCAwKSB7XG4gICAgICAgICAgbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID0gXCJyaWdodFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGQubWlkQ29zID4gMCkge1xuICAgICAgICAgIGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA9IFwibGVmdFwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgYXZvaWRZQ29sbGlzaW9ucyhsZWZ0TGFiZWxzKTtcbiAgICBhdm9pZFlDb2xsaXNpb25zKHJpZ2h0TGFiZWxzKTtcbiAgICBhdm9pZFhDb2xsaXNpb25zKHRvcExhYmVscyk7XG4gICAgYXZvaWRYQ29sbGlzaW9ucyhib3R0b21MYWJlbHMpO1xuICB9XG4gIHVwZGF0ZUNhbGxvdXRMYWJlbE5vZGVzKHNlcmllc1JlY3QpIHtcbiAgICBjb25zdCB7IHJhZGl1c1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsLCBjYWxsb3V0TGluZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNhbGxvdXRMZW5ndGggPSBjYWxsb3V0TGluZS5sZW5ndGg7XG4gICAgY29uc3QgeyBvZmZzZXQ6IG9mZnNldDQsIGNvbG9yIH0gPSBjYWxsb3V0TGFiZWw7XG4gICAgY29uc3QgdGVtcFRleHROb2RlID0gbmV3IFRleHQoKTtcbiAgICB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbi5zZWxlY3RCeVRhZygxIC8qIExhYmVsICovKS5mb3JFYWNoKCh0ZXh0KSA9PiB7XG4gICAgICBjb25zdCB7IGRhdHVtIH0gPSB0ZXh0O1xuICAgICAgY29uc3QgbGFiZWwgPSBkYXR1bS5jYWxsb3V0TGFiZWw7XG4gICAgICBjb25zdCByYWRpdXMgPSByYWRpdXNTY2FsZS5jb252ZXJ0KGRhdHVtLnJhZGl1cyk7XG4gICAgICBjb25zdCBvdXRlclJhZGl1cyA9IE1hdGgubWF4KDAsIHJhZGl1cyk7XG4gICAgICBpZiAoIWxhYmVsPy50ZXh0IHx8IG91dGVyUmFkaXVzID09PSAwIHx8IGxhYmVsLmhpZGRlbikge1xuICAgICAgICB0ZXh0LnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFiZWxSYWRpdXMgPSBvdXRlclJhZGl1cyArIGNhbGxvdXRMZW5ndGggKyBvZmZzZXQ0O1xuICAgICAgY29uc3QgeCA9IGRhdHVtLm1pZENvcyAqIGxhYmVsUmFkaXVzO1xuICAgICAgY29uc3QgeSA9IGRhdHVtLm1pZFNpbiAqIGxhYmVsUmFkaXVzICsgbGFiZWwuY29sbGlzaW9uT2Zmc2V0WTtcbiAgICAgIGNvbnN0IGFsaWduID0ge1xuICAgICAgICB0ZXh0QWxpZ246IGxhYmVsLmNvbGxpc2lvblRleHRBbGlnbiA/PyBsYWJlbC50ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZTogbGFiZWwudGV4dEJhc2VsaW5lXG4gICAgICB9O1xuICAgICAgdGVtcFRleHROb2RlLnRleHQgPSBsYWJlbC50ZXh0O1xuICAgICAgdGVtcFRleHROb2RlLnggPSB4O1xuICAgICAgdGVtcFRleHROb2RlLnkgPSB5O1xuICAgICAgdGVtcFRleHROb2RlLnNldEZvbnQodGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbCk7XG4gICAgICB0ZW1wVGV4dE5vZGUuc2V0QWxpZ24oYWxpZ24pO1xuICAgICAgY29uc3QgYm94ID0gdGVtcFRleHROb2RlLmdldEJCb3goKTtcbiAgICAgIGxldCBkaXNwbGF5VGV4dCA9IGxhYmVsLnRleHQ7XG4gICAgICBsZXQgdmlzaWJsZSA9IHRydWU7XG4gICAgICBpZiAoY2FsbG91dExhYmVsLmF2b2lkQ29sbGlzaW9ucykge1xuICAgICAgICBjb25zdCB7IHRleHRMZW5ndGgsIGhhc1ZlcnRpY2FsT3ZlcmZsb3cgfSA9IHRoaXMuZ2V0TGFiZWxPdmVyZmxvdyhsYWJlbC50ZXh0LCBib3gsIHNlcmllc1JlY3QpO1xuICAgICAgICBkaXNwbGF5VGV4dCA9IGxhYmVsLnRleHQubGVuZ3RoID09PSB0ZXh0TGVuZ3RoID8gbGFiZWwudGV4dCA6IGAke2xhYmVsLnRleHQuc3Vic3RyaW5nKDAsIHRleHRMZW5ndGgpfVxcdTIwMjZgO1xuICAgICAgICB2aXNpYmxlID0gIWhhc1ZlcnRpY2FsT3ZlcmZsb3c7XG4gICAgICB9XG4gICAgICB0ZXh0LnRleHQgPSBkaXNwbGF5VGV4dDtcbiAgICAgIHRleHQueCA9IHg7XG4gICAgICB0ZXh0LnkgPSB5O1xuICAgICAgdGV4dC5zZXRGb250KHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWwpO1xuICAgICAgdGV4dC5zZXRBbGlnbihhbGlnbik7XG4gICAgICB0ZXh0LmZpbGwgPSBjb2xvcjtcbiAgICAgIHRleHQudmlzaWJsZSA9IHZpc2libGU7XG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgY29tcHV0ZUxhYmVsc0JCb3gob3B0aW9ucywgc2VyaWVzUmVjdCkge1xuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsLCBjYWxsb3V0TGluZSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGNvbnN0IGNhbGxvdXRMZW5ndGggPSBjYWxsb3V0TGluZS5sZW5ndGg7XG4gICAgY29uc3QgeyBvZmZzZXQ6IG9mZnNldDQsIG1heENvbGxpc2lvbk9mZnNldCwgbWluU3BhY2luZyB9ID0gY2FsbG91dExhYmVsO1xuICAgIGlmICghY2FsbG91dExhYmVsLmF2b2lkQ29sbGlzaW9ucykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGF3YWl0IHRoaXMubWF5YmVSZWZyZXNoTm9kZURhdGEoKTtcbiAgICB0aGlzLnVwZGF0ZVJhZGl1c1NjYWxlKGZhbHNlKTtcbiAgICB0aGlzLmNvbXB1dGVDYWxsb3V0TGFiZWxDb2xsaXNpb25PZmZzZXRzKCk7XG4gICAgY29uc3QgdGV4dEJveGVzID0gW107XG4gICAgY29uc3QgdGV4dCA9IG5ldyBUZXh0KCk7XG4gICAgbGV0IHRpdGxlQm94O1xuICAgIGNvbnN0IHsgdGl0bGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBpZiAodGl0bGU/LnRleHQgJiYgdGl0bGUuZW5hYmxlZCkge1xuICAgICAgY29uc3QgZHkgPSB0aGlzLmdldFRpdGxlVHJhbnNsYXRpb25ZKCk7XG4gICAgICBpZiAoaXNGaW5pdGUoZHkpKSB7XG4gICAgICAgIHRleHQudGV4dCA9IHRpdGxlLnRleHQ7XG4gICAgICAgIHRleHQueCA9IDA7XG4gICAgICAgIHRleHQueSA9IGR5O1xuICAgICAgICB0ZXh0LnNldEZvbnQodGl0bGUpO1xuICAgICAgICB0ZXh0LnNldEFsaWduKHtcbiAgICAgICAgICB0ZXh0QmFzZWxpbmU6IFwiYm90dG9tXCIsXG4gICAgICAgICAgdGV4dEFsaWduOiBcImNlbnRlclwiXG4gICAgICAgIH0pO1xuICAgICAgICB0aXRsZUJveCA9IHRleHQuZ2V0QkJveCgpO1xuICAgICAgICB0ZXh0Qm94ZXMucHVzaCh0aXRsZUJveCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2FsbG91dE5vZGVEYXRhLmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCBsYWJlbCA9IGRhdHVtLmNhbGxvdXRMYWJlbDtcbiAgICAgIGlmICghbGFiZWwgfHwgZGF0dW0ub3V0ZXJSYWRpdXMgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBsYWJlbFJhZGl1cyA9IGRhdHVtLm91dGVyUmFkaXVzICsgY2FsbG91dExlbmd0aCArIG9mZnNldDQ7XG4gICAgICBjb25zdCB4ID0gZGF0dW0ubWlkQ29zICogbGFiZWxSYWRpdXM7XG4gICAgICBjb25zdCB5ID0gZGF0dW0ubWlkU2luICogbGFiZWxSYWRpdXMgKyBsYWJlbC5jb2xsaXNpb25PZmZzZXRZO1xuICAgICAgdGV4dC50ZXh0ID0gbGFiZWwudGV4dDtcbiAgICAgIHRleHQueCA9IHg7XG4gICAgICB0ZXh0LnkgPSB5O1xuICAgICAgdGV4dC5zZXRGb250KHRoaXMucHJvcGVydGllcy5jYWxsb3V0TGFiZWwpO1xuICAgICAgdGV4dC5zZXRBbGlnbih7XG4gICAgICAgIHRleHRBbGlnbjogbGFiZWwuY29sbGlzaW9uVGV4dEFsaWduID8/IGxhYmVsLnRleHRBbGlnbixcbiAgICAgICAgdGV4dEJhc2VsaW5lOiBsYWJlbC50ZXh0QmFzZWxpbmVcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYm94ID0gdGV4dC5nZXRCQm94KCk7XG4gICAgICBsYWJlbC5ib3ggPSBib3g7XG4gICAgICBpZiAoTWF0aC5hYnMobGFiZWwuY29sbGlzaW9uT2Zmc2V0WSkgPiBtYXhDb2xsaXNpb25PZmZzZXQpIHtcbiAgICAgICAgbGFiZWwuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRpdGxlQm94KSB7XG4gICAgICAgIGNvbnN0IHNlcmllc1RvcCA9IHNlcmllc1JlY3QueSAtIHRoaXMuY2VudGVyWTtcbiAgICAgICAgY29uc3QgdGl0bGVDbGVhbkFyZWEgPSBuZXcgQkJveChcbiAgICAgICAgICB0aXRsZUJveC54IC0gbWluU3BhY2luZyxcbiAgICAgICAgICBzZXJpZXNUb3AsXG4gICAgICAgICAgdGl0bGVCb3gud2lkdGggKyAyICogbWluU3BhY2luZyxcbiAgICAgICAgICB0aXRsZUJveC55ICsgdGl0bGVCb3guaGVpZ2h0ICsgbWluU3BhY2luZyAtIHNlcmllc1RvcFxuICAgICAgICApO1xuICAgICAgICBpZiAoYm94LmNvbGxpZGVzQkJveCh0aXRsZUNsZWFuQXJlYSkpIHtcbiAgICAgICAgICBsYWJlbC5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMuaGlkZVdoZW5OZWNlc3NhcnkpIHtcbiAgICAgICAgY29uc3QgeyB0ZXh0TGVuZ3RoLCBoYXNWZXJ0aWNhbE92ZXJmbG93LCBoYXNTdXJyb3VuZGluZ1Nlcmllc092ZXJmbG93IH0gPSB0aGlzLmdldExhYmVsT3ZlcmZsb3coXG4gICAgICAgICAgbGFiZWwudGV4dCxcbiAgICAgICAgICBib3gsXG4gICAgICAgICAgc2VyaWVzUmVjdFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBpc1Rvb1Nob3J0ID0gbGFiZWwudGV4dC5sZW5ndGggPiAyICYmIHRleHRMZW5ndGggPCAyO1xuICAgICAgICBpZiAoaGFzVmVydGljYWxPdmVyZmxvdyB8fCBpc1Rvb1Nob3J0IHx8IGhhc1N1cnJvdW5kaW5nU2VyaWVzT3ZlcmZsb3cpIHtcbiAgICAgICAgICBsYWJlbC5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFiZWwuaGlkZGVuID0gZmFsc2U7XG4gICAgICB0ZXh0Qm94ZXMucHVzaChib3gpO1xuICAgIH0pO1xuICAgIGlmICh0ZXh0Qm94ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEJCb3gubWVyZ2UodGV4dEJveGVzKTtcbiAgfVxuICB1cGRhdGVTZWN0b3JMYWJlbE5vZGVzKCkge1xuICAgIGNvbnN0IHsgcmFkaXVzU2NhbGUgfSA9IHRoaXM7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSByYWRpdXNTY2FsZS5jb252ZXJ0KDApO1xuICAgIGNvbnN0IHsgZm9udFNpemUsIGZvbnRTdHlsZSwgZm9udFdlaWdodCwgZm9udEZhbWlseSwgcG9zaXRpb25PZmZzZXQsIHBvc2l0aW9uUmF0aW8sIGNvbG9yIH0gPSB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWw7XG4gICAgY29uc3QgaXNEb251dCA9IGlubmVyUmFkaXVzID4gMDtcbiAgICBjb25zdCBzaW5nbGVWaXNpYmxlU2VjdG9yID0gdGhpcy5zZXJpZXNJdGVtRW5hYmxlZC5maWx0ZXIoQm9vbGVhbikubGVuZ3RoID09PSAxO1xuICAgIGNvbnN0IHVwZGF0ZVNlY3RvckxhYmVsID0gKHRleHQsIGRhdHVtKSA9PiB7XG4gICAgICBjb25zdCB7IHNlY3RvckxhYmVsLCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUgfSA9IGRhdHVtO1xuICAgICAgbGV0IGlzVGV4dFZpc2libGUgPSBmYWxzZTtcbiAgICAgIGlmIChzZWN0b3JMYWJlbCAmJiBvdXRlclJhZGl1cyAhPT0gMCkge1xuICAgICAgICBjb25zdCBsYWJlbFJhZGl1cyA9IGlubmVyUmFkaXVzICogKDEgLSBwb3NpdGlvblJhdGlvKSArIG91dGVyUmFkaXVzICogcG9zaXRpb25SYXRpbyArIHBvc2l0aW9uT2Zmc2V0O1xuICAgICAgICB0ZXh0LmZpbGwgPSBjb2xvcjtcbiAgICAgICAgdGV4dC5mb250U3R5bGUgPSBmb250U3R5bGU7XG4gICAgICAgIHRleHQuZm9udFdlaWdodCA9IGZvbnRXZWlnaHQ7XG4gICAgICAgIHRleHQuZm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgICAgdGV4dC5mb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgICAgdGV4dC50ZXh0ID0gc2VjdG9yTGFiZWwudGV4dDtcbiAgICAgICAgY29uc3Qgc2hvdWxkUHV0VGV4dEluQ2VudGVyID0gIWlzRG9udXQgJiYgc2luZ2xlVmlzaWJsZVNlY3RvcjtcbiAgICAgICAgaWYgKHNob3VsZFB1dFRleHRJbkNlbnRlcikge1xuICAgICAgICAgIHRleHQueCA9IDA7XG4gICAgICAgICAgdGV4dC55ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0LnggPSBkYXR1bS5taWRDb3MgKiBsYWJlbFJhZGl1cztcbiAgICAgICAgICB0ZXh0LnkgPSBkYXR1bS5taWRTaW4gKiBsYWJlbFJhZGl1cztcbiAgICAgICAgfVxuICAgICAgICB0ZXh0LnRleHRBbGlnbiA9IFwiY2VudGVyXCI7XG4gICAgICAgIHRleHQudGV4dEJhc2VsaW5lID0gXCJtaWRkbGVcIjtcbiAgICAgICAgY29uc3QgYmJveCA9IHRleHQuZ2V0QkJveCgpO1xuICAgICAgICBjb25zdCBjb3JuZXJzID0gW1xuICAgICAgICAgIFtiYm94LngsIGJib3gueV0sXG4gICAgICAgICAgW2Jib3gueCArIGJib3gud2lkdGgsIGJib3gueV0sXG4gICAgICAgICAgW2Jib3gueCArIGJib3gud2lkdGgsIGJib3gueSArIGJib3guaGVpZ2h0XSxcbiAgICAgICAgICBbYmJveC54LCBiYm94LnkgKyBiYm94LmhlaWdodF1cbiAgICAgICAgXTtcbiAgICAgICAgY29uc3Qgc2VjdG9yQm91bmRzID0geyBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzIH07XG4gICAgICAgIGlmIChjb3JuZXJzLmV2ZXJ5KChbeCwgeV0pID0+IGlzUG9pbnRJblNlY3Rvcih4LCB5LCBzZWN0b3JCb3VuZHMpKSkge1xuICAgICAgICAgIGlzVGV4dFZpc2libGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0ZXh0LnZpc2libGUgPSBpc1RleHRWaXNpYmxlO1xuICAgIH07XG4gICAgdGhpcy5sYWJlbFNlbGVjdGlvbi5lYWNoKHVwZGF0ZVNlY3RvckxhYmVsKTtcbiAgICB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uLmVhY2godXBkYXRlU2VjdG9yTGFiZWwpO1xuICB9XG4gIHVwZGF0ZVplcm9zdW1SaW5ncygpIHtcbiAgICB0aGlzLnplcm9zdW1PdXRlclJpbmcuc2l6ZSA9IHRoaXMuZ2V0T3V0ZXJSYWRpdXMoKSAqIDI7XG4gIH1cbiAgZ2V0RGF0dW1MZWdlbmROYW1lKG5vZGVEYXR1bSkge1xuICAgIGNvbnN0IHsgYW5nbGVLZXksIGNhbGxvdXRMYWJlbEtleSwgc2VjdG9yTGFiZWxLZXksIGxlZ2VuZEl0ZW1LZXkgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBjb25zdCB7IHNlY3RvckxhYmVsLCBjYWxsb3V0TGFiZWwsIGxlZ2VuZEl0ZW0gfSA9IG5vZGVEYXR1bTtcbiAgICBpZiAobGVnZW5kSXRlbUtleSAmJiBsZWdlbmRJdGVtICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBsZWdlbmRJdGVtLnRleHQ7XG4gICAgfSBlbHNlIGlmIChjYWxsb3V0TGFiZWxLZXkgJiYgY2FsbG91dExhYmVsS2V5ICE9PSBhbmdsZUtleSAmJiBjYWxsb3V0TGFiZWw/LnRleHQgIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGNhbGxvdXRMYWJlbC50ZXh0O1xuICAgIH0gZWxzZSBpZiAoc2VjdG9yTGFiZWxLZXkgJiYgc2VjdG9yTGFiZWxLZXkgIT09IGFuZ2xlS2V5ICYmIHNlY3RvckxhYmVsPy50ZXh0ICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBzZWN0b3JMYWJlbC50ZXh0O1xuICAgIH1cbiAgfVxuICBwaWNrTm9kZUNsb3Nlc3REYXR1bShwb2ludCkge1xuICAgIHJldHVybiBwaWNrQnlNYXRjaGluZ0FuZ2xlKHRoaXMsIHBvaW50KTtcbiAgfVxuICBnZXRUb29sdGlwSHRtbChub2RlRGF0dW0pIHtcbiAgICBpZiAoIXRoaXMucHJvcGVydGllcy5pc1ZhbGlkKCkpIHtcbiAgICAgIHJldHVybiBFTVBUWV9UT09MVElQX0NPTlRFTlQ7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGRhdHVtLFxuICAgICAgYW5nbGVWYWx1ZSxcbiAgICAgIHNlY3RvckZvcm1hdDogeyBmaWxsOiBjb2xvciB9LFxuICAgICAgaXRlbUlkXG4gICAgfSA9IG5vZGVEYXR1bTtcbiAgICBjb25zdCB0aXRsZSA9IHNhbml0aXplSHRtbCh0aGlzLnByb3BlcnRpZXMudGl0bGU/LnRleHQpO1xuICAgIGNvbnN0IGNvbnRlbnQgPSBpc0Zpbml0ZU51bWJlcihhbmdsZVZhbHVlKSA/IHRvRml4ZWQoYW5nbGVWYWx1ZSkgOiBTdHJpbmcoYW5nbGVWYWx1ZSk7XG4gICAgY29uc3QgbGFiZWxUZXh0ID0gdGhpcy5nZXREYXR1bUxlZ2VuZE5hbWUobm9kZURhdHVtKTtcbiAgICByZXR1cm4gdGhpcy5wcm9wZXJ0aWVzLnRvb2x0aXAudG9Ub29sdGlwSHRtbChcbiAgICAgIHtcbiAgICAgICAgdGl0bGU6IHRpdGxlID8/IGxhYmVsVGV4dCxcbiAgICAgICAgY29udGVudDogdGl0bGUgJiYgbGFiZWxUZXh0ID8gYCR7bGFiZWxUZXh0fTogJHtjb250ZW50fWAgOiBjb250ZW50LFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9yXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBkYXR1bSxcbiAgICAgICAgaXRlbUlkLFxuICAgICAgICB0aXRsZSxcbiAgICAgICAgY29sb3IsXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICBhbmdsZUtleTogdGhpcy5wcm9wZXJ0aWVzLmFuZ2xlS2V5LFxuICAgICAgICBhbmdsZU5hbWU6IHRoaXMucHJvcGVydGllcy5hbmdsZU5hbWUsXG4gICAgICAgIHJhZGl1c0tleTogdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c0tleSxcbiAgICAgICAgcmFkaXVzTmFtZTogdGhpcy5wcm9wZXJ0aWVzLnJhZGl1c05hbWUsXG4gICAgICAgIGNhbGxvdXRMYWJlbEtleTogdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbEtleSxcbiAgICAgICAgY2FsbG91dExhYmVsTmFtZTogdGhpcy5wcm9wZXJ0aWVzLmNhbGxvdXRMYWJlbE5hbWUsXG4gICAgICAgIHNlY3RvckxhYmVsS2V5OiB0aGlzLnByb3BlcnRpZXMuc2VjdG9yTGFiZWxLZXksXG4gICAgICAgIHNlY3RvckxhYmVsTmFtZTogdGhpcy5wcm9wZXJ0aWVzLnNlY3RvckxhYmVsTmFtZSxcbiAgICAgICAgbGVnZW5kSXRlbUtleTogdGhpcy5wcm9wZXJ0aWVzLmxlZ2VuZEl0ZW1LZXlcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGdldExlZ2VuZERhdGEobGVnZW5kVHlwZSkge1xuICAgIGNvbnN0IHsgdmlzaWJsZSwgcHJvY2Vzc2VkRGF0YSwgZGF0YU1vZGVsIH0gPSB0aGlzO1xuICAgIGlmICghZGF0YU1vZGVsIHx8ICFwcm9jZXNzZWREYXRhPy5kYXRhLmxlbmd0aCB8fCBsZWdlbmRUeXBlICE9PSBcImNhdGVnb3J5XCIpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgeyBhbmdsZUtleSwgY2FsbG91dExhYmVsS2V5LCBzZWN0b3JMYWJlbEtleSwgbGVnZW5kSXRlbUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGlmICghbGVnZW5kSXRlbUtleSAmJiAoIWNhbGxvdXRMYWJlbEtleSB8fCBjYWxsb3V0TGFiZWxLZXkgPT09IGFuZ2xlS2V5KSAmJiAoIXNlY3RvckxhYmVsS2V5IHx8IHNlY3RvckxhYmVsS2V5ID09PSBhbmdsZUtleSkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgeyBjYWxsb3V0TGFiZWxJZHgsIHNlY3RvckxhYmVsSWR4LCBsZWdlbmRJdGVtSWR4IH0gPSB0aGlzLmdldFByb2Nlc3NlZERhdGFJbmRleGVzKGRhdGFNb2RlbCk7XG4gICAgY29uc3QgdGl0bGVUZXh0ID0gdGhpcy5wcm9wZXJ0aWVzLnRpdGxlPy5zaG93SW5MZWdlbmQgJiYgdGhpcy5wcm9wZXJ0aWVzLnRpdGxlLnRleHQ7XG4gICAgY29uc3QgbGVnZW5kRGF0YSA9IFtdO1xuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBwcm9jZXNzZWREYXRhLmRhdGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCB7IGRhdHVtLCB2YWx1ZXMgfSA9IHByb2Nlc3NlZERhdGEuZGF0YVtpbmRleF07XG4gICAgICBjb25zdCBsYWJlbFBhcnRzID0gW107XG4gICAgICBpZiAodGl0bGVUZXh0KSB7XG4gICAgICAgIGxhYmVsUGFydHMucHVzaCh0aXRsZVRleHQpO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoXG4gICAgICAgIGRhdHVtLFxuICAgICAgICAyICogTWF0aC5QSSxcbiAgICAgICAgMiAqIE1hdGguUEksXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBjYWxsb3V0TGFiZWxJZHggIT0gbnVsbCA/IHZhbHVlc1tjYWxsb3V0TGFiZWxJZHhdIDogdm9pZCAwLFxuICAgICAgICBzZWN0b3JMYWJlbElkeCAhPSBudWxsID8gdmFsdWVzW3NlY3RvckxhYmVsSWR4XSA6IHZvaWQgMCxcbiAgICAgICAgbGVnZW5kSXRlbUlkeCAhPSBudWxsID8gdmFsdWVzW2xlZ2VuZEl0ZW1JZHhdIDogdm9pZCAwXG4gICAgICApO1xuICAgICAgaWYgKGxlZ2VuZEl0ZW1LZXkgJiYgbGFiZWxzLmxlZ2VuZEl0ZW0gIT09IHZvaWQgMCkge1xuICAgICAgICBsYWJlbFBhcnRzLnB1c2gobGFiZWxzLmxlZ2VuZEl0ZW0udGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKGNhbGxvdXRMYWJlbEtleSAmJiBjYWxsb3V0TGFiZWxLZXkgIT09IGFuZ2xlS2V5ICYmIGxhYmVscy5jYWxsb3V0TGFiZWw/LnRleHQgIT09IHZvaWQgMCkge1xuICAgICAgICBsYWJlbFBhcnRzLnB1c2gobGFiZWxzLmNhbGxvdXRMYWJlbD8udGV4dCk7XG4gICAgICB9IGVsc2UgaWYgKHNlY3RvckxhYmVsS2V5ICYmIHNlY3RvckxhYmVsS2V5ICE9PSBhbmdsZUtleSAmJiBsYWJlbHMuc2VjdG9yTGFiZWw/LnRleHQgIT09IHZvaWQgMCkge1xuICAgICAgICBsYWJlbFBhcnRzLnB1c2gobGFiZWxzLnNlY3RvckxhYmVsPy50ZXh0KTtcbiAgICAgIH1cbiAgICAgIGlmIChsYWJlbFBhcnRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBzZWN0b3JGb3JtYXQgPSB0aGlzLmdldFNlY3RvckZvcm1hdChkYXR1bSwgaW5kZXgsIGZhbHNlKTtcbiAgICAgIGxlZ2VuZERhdGEucHVzaCh7XG4gICAgICAgIGxlZ2VuZFR5cGU6IFwiY2F0ZWdvcnlcIixcbiAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgIGl0ZW1JZDogaW5kZXgsXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICBlbmFibGVkOiB2aXNpYmxlICYmIHRoaXMuc2VyaWVzSXRlbUVuYWJsZWRbaW5kZXhdLFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIHRleHQ6IGxhYmVsUGFydHMuam9pbihcIiAtIFwiKVxuICAgICAgICB9LFxuICAgICAgICBzeW1ib2xzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgbWFya2VyOiB7XG4gICAgICAgICAgICAgIGZpbGw6IHNlY3RvckZvcm1hdC5maWxsLFxuICAgICAgICAgICAgICBzdHJva2U6IHNlY3RvckZvcm1hdC5zdHJva2UsXG4gICAgICAgICAgICAgIGZpbGxPcGFjaXR5OiB0aGlzLnByb3BlcnRpZXMuZmlsbE9wYWNpdHksXG4gICAgICAgICAgICAgIHN0cm9rZU9wYWNpdHk6IHRoaXMucHJvcGVydGllcy5zdHJva2VPcGFjaXR5LFxuICAgICAgICAgICAgICBzdHJva2VXaWR0aDogdGhpcy5wcm9wZXJ0aWVzLnN0cm9rZVdpZHRoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBsZWdlbmRJdGVtTmFtZTogbGVnZW5kSXRlbUtleSAhPSBudWxsID8gZGF0dW1bbGVnZW5kSXRlbUtleV0gOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kRGF0YTtcbiAgfVxuICBvbkxlZ2VuZEl0ZW1DbGljayhldmVudCkge1xuICAgIGNvbnN0IHsgZW5hYmxlZCwgaXRlbUlkLCBzZXJpZXMsIGxlZ2VuZEl0ZW1OYW1lIH0gPSBldmVudDtcbiAgICBpZiAoc2VyaWVzLmlkID09PSB0aGlzLmlkKSB7XG4gICAgICB0aGlzLnRvZ2dsZVNlcmllc0l0ZW0oaXRlbUlkLCBlbmFibGVkKTtcbiAgICB9IGVsc2UgaWYgKGxlZ2VuZEl0ZW1OYW1lICE9IG51bGwpIHtcbiAgICAgIHRoaXMudG9nZ2xlT3RoZXJTZXJpZXNJdGVtcyhsZWdlbmRJdGVtTmFtZSwgZW5hYmxlZCk7XG4gICAgfVxuICB9XG4gIHRvZ2dsZVNlcmllc0l0ZW0oaXRlbUlkLCBlbmFibGVkKSB7XG4gICAgdGhpcy5zZXJpZXNJdGVtRW5hYmxlZFtpdGVtSWRdID0gZW5hYmxlZDtcbiAgICBpZiAodGhpcy5ub2RlRGF0YVtpdGVtSWRdKSB7XG4gICAgICB0aGlzLm5vZGVEYXRhW2l0ZW1JZF0uZW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgfVxuICAgIHRoaXMubm9kZURhdGFSZWZyZXNoID0gdHJ1ZTtcbiAgfVxuICB0b2dnbGVPdGhlclNlcmllc0l0ZW1zKGxlZ2VuZEl0ZW1OYW1lLCBlbmFibGVkKSB7XG4gICAgaWYgKCF0aGlzLnByb3BlcnRpZXMubGVnZW5kSXRlbUtleSB8fCAhdGhpcy5kYXRhTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbGVnZW5kSXRlbUlkeCA9IHRoaXMuZGF0YU1vZGVsLnJlc29sdmVQcm9jZXNzZWREYXRhSW5kZXhCeUlkKHRoaXMsIGBsZWdlbmRJdGVtVmFsdWVgKTtcbiAgICB0aGlzLnByb2Nlc3NlZERhdGE/LmRhdGEuZm9yRWFjaCgoeyB2YWx1ZXMgfSwgZGF0dW1JdGVtSWQpID0+IHtcbiAgICAgIGlmICh2YWx1ZXNbbGVnZW5kSXRlbUlkeF0gPT09IGxlZ2VuZEl0ZW1OYW1lKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlU2VyaWVzSXRlbShkYXR1bUl0ZW1JZCwgZW5hYmxlZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoX2RhdGEpIHtcbiAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGZucyA9IHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnMoXG4gICAgICB0cnVlLFxuICAgICAgdGhpcy5wcm9wZXJ0aWVzLnJvdGF0aW9uLFxuICAgICAgdGhpcy5yYWRpdXNTY2FsZSxcbiAgICAgIHRoaXMucHJldmlvdXNSYWRpdXNTY2FsZVxuICAgICk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwibm9kZXNcIixcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICBbdGhpcy5pdGVtU2VsZWN0aW9uLCB0aGlzLmhpZ2hsaWdodFNlbGVjdGlvbiwgdGhpcy5waGFudG9tU2VsZWN0aW9uXSxcbiAgICAgIGZucy5ub2RlcyxcbiAgICAgIChfLCBkYXR1bSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtKVxuICAgICk7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJjYWxsb3V0XCIsIGFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcInNlY3RvclwiLCBhbmltYXRpb25NYW5hZ2VyLCB0aGlzLmxhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImhpZ2hsaWdodFwiLCBhbmltYXRpb25NYW5hZ2VyLCB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uKTtcbiAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUucmFuZ2UgPSB0aGlzLnJhZGl1c1NjYWxlLnJhbmdlO1xuICB9XG4gIGFuaW1hdGVXYWl0aW5nVXBkYXRlUmVhZHkoKSB7XG4gICAgY29uc3QgeyBpdGVtU2VsZWN0aW9uLCBoaWdobGlnaHRTZWxlY3Rpb24sIHBoYW50b21TZWxlY3Rpb24sIHByb2Nlc3NlZERhdGEsIHJhZGl1c1NjYWxlLCBwcmV2aW91c1JhZGl1c1NjYWxlIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgYW5pbWF0aW9uTWFuYWdlciB9ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZGF0YURpZmYgPSBwcm9jZXNzZWREYXRhPy5yZWR1Y2VkPy5kaWZmO1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc3RvcEJ5QW5pbWF0aW9uR3JvdXBJZCh0aGlzLmlkKTtcbiAgICBjb25zdCBzdXBwb3J0ZWREaWZmID0gKGRhdGFEaWZmPy5tb3ZlZC5zaXplID8/IDApID09PSAwO1xuICAgIGNvbnN0IGhhc0tleXMgPSAocHJvY2Vzc2VkRGF0YT8uZGVmcy5rZXlzLmxlbmd0aCA/PyAwKSA+IDA7XG4gICAgY29uc3QgaGFzVW5pcXVlS2V5cyA9IHByb2Nlc3NlZERhdGE/LnJlZHVjZWQ/LmFuaW1hdGlvblZhbGlkYXRpb24/LnVuaXF1ZUtleXMgPz8gdHJ1ZTtcbiAgICBpZiAoIXN1cHBvcnRlZERpZmYgfHwgIWhhc0tleXMgfHwgIWhhc1VuaXF1ZUtleXMpIHtcbiAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIH1cbiAgICBjb25zdCBmbnMgPSBwcmVwYXJlUGllU2VyaWVzQW5pbWF0aW9uRnVuY3Rpb25zKFxuICAgICAgZmFsc2UsXG4gICAgICB0aGlzLnByb3BlcnRpZXMucm90YXRpb24sXG4gICAgICByYWRpdXNTY2FsZSxcbiAgICAgIHByZXZpb3VzUmFkaXVzU2NhbGVcbiAgICApO1xuICAgIGZyb21Ub01vdGlvbihcbiAgICAgIHRoaXMuaWQsXG4gICAgICBcIm5vZGVzXCIsXG4gICAgICBhbmltYXRpb25NYW5hZ2VyLFxuICAgICAgW2l0ZW1TZWxlY3Rpb24sIGhpZ2hsaWdodFNlbGVjdGlvbiwgcGhhbnRvbVNlbGVjdGlvbl0sXG4gICAgICBmbnMubm9kZXMsXG4gICAgICAoXywgZGF0dW0pID0+IHRoaXMuZ2V0RGF0dW1JZChkYXR1bSksXG4gICAgICBkYXRhRGlmZlxuICAgICk7XG4gICAgc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24odGhpcywgXCJjYWxsb3V0XCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMuY2FsbG91dExhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcInNlY3RvclwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmxhYmVsU2VsZWN0aW9uKTtcbiAgICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbih0aGlzLCBcImhpZ2hsaWdodFwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uKTtcbiAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUucmFuZ2UgPSB0aGlzLnJhZGl1c1NjYWxlLnJhbmdlO1xuICB9XG4gIGFuaW1hdGVDbGVhcmluZ1VwZGF0ZUVtcHR5KCkge1xuICAgIGNvbnN0IHsgaXRlbVNlbGVjdGlvbiwgaGlnaGxpZ2h0U2VsZWN0aW9uLCBwaGFudG9tU2VsZWN0aW9uLCByYWRpdXNTY2FsZSwgcHJldmlvdXNSYWRpdXNTY2FsZSB9ID0gdGhpcztcbiAgICBjb25zdCB7IGFuaW1hdGlvbk1hbmFnZXIgfSA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGZucyA9IHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnMoXG4gICAgICBmYWxzZSxcbiAgICAgIHRoaXMucHJvcGVydGllcy5yb3RhdGlvbixcbiAgICAgIHJhZGl1c1NjYWxlLFxuICAgICAgcHJldmlvdXNSYWRpdXNTY2FsZVxuICAgICk7XG4gICAgZnJvbVRvTW90aW9uKFxuICAgICAgdGhpcy5pZCxcbiAgICAgIFwibm9kZXNcIixcbiAgICAgIGFuaW1hdGlvbk1hbmFnZXIsXG4gICAgICBbaXRlbVNlbGVjdGlvbiwgaGlnaGxpZ2h0U2VsZWN0aW9uLCBwaGFudG9tU2VsZWN0aW9uXSxcbiAgICAgIGZucy5ub2RlcyxcbiAgICAgIChfLCBkYXR1bSkgPT4gdGhpcy5nZXREYXR1bUlkKGRhdHVtKVxuICAgICk7XG4gICAgc2VyaWVzTGFiZWxGYWRlT3V0QW5pbWF0aW9uKHRoaXMsIFwiY2FsbG91dFwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmNhbGxvdXRMYWJlbFNlbGVjdGlvbik7XG4gICAgc2VyaWVzTGFiZWxGYWRlT3V0QW5pbWF0aW9uKHRoaXMsIFwic2VjdG9yXCIsIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIsIHRoaXMubGFiZWxTZWxlY3Rpb24pO1xuICAgIHNlcmllc0xhYmVsRmFkZU91dEFuaW1hdGlvbih0aGlzLCBcImhpZ2hsaWdodFwiLCB0aGlzLmN0eC5hbmltYXRpb25NYW5hZ2VyLCB0aGlzLmhpZ2hsaWdodExhYmVsU2VsZWN0aW9uKTtcbiAgICB0aGlzLnByZXZpb3VzUmFkaXVzU2NhbGUucmFuZ2UgPSB0aGlzLnJhZGl1c1NjYWxlLnJhbmdlO1xuICB9XG4gIGdldERhdHVtSWRGcm9tRGF0YShkYXR1bSkge1xuICAgIGNvbnN0IHsgY2FsbG91dExhYmVsS2V5LCBzZWN0b3JMYWJlbEtleSwgbGVnZW5kSXRlbUtleSB9ID0gdGhpcy5wcm9wZXJ0aWVzO1xuICAgIGlmICghdGhpcy5wcm9jZXNzZWREYXRhPy5yZWR1Y2VkPy5hbmltYXRpb25WYWxpZGF0aW9uPy51bmlxdWVLZXlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChsZWdlbmRJdGVtS2V5KSB7XG4gICAgICByZXR1cm4gZGF0dW1bbGVnZW5kSXRlbUtleV07XG4gICAgfSBlbHNlIGlmIChjYWxsb3V0TGFiZWxLZXkpIHtcbiAgICAgIHJldHVybiBkYXR1bVtjYWxsb3V0TGFiZWxLZXldO1xuICAgIH0gZWxzZSBpZiAoc2VjdG9yTGFiZWxLZXkpIHtcbiAgICAgIHJldHVybiBkYXR1bVtzZWN0b3JMYWJlbEtleV07XG4gICAgfVxuICB9XG4gIGdldERhdHVtSWQoZGF0dW0pIHtcbiAgICBjb25zdCB7IGluZGV4IH0gPSBkYXR1bTtcbiAgICBjb25zdCBkYXR1bUlkID0gdGhpcy5nZXREYXR1bUlkRnJvbURhdGEoZGF0dW0uZGF0dW0pO1xuICAgIHJldHVybiBkYXR1bUlkICE9IG51bGwgPyBTdHJpbmcoZGF0dW1JZCkgOiBgJHtpbmRleH1gO1xuICB9XG4gIG9uRGF0YUNoYW5nZSgpIHtcbiAgICBjb25zdCB7IGRhdGEsIHNlcmllc0l0ZW1FbmFibGVkIH0gPSB0aGlzO1xuICAgIHRoaXMuc2VyaWVzSXRlbUVuYWJsZWQgPSBkYXRhPy5tYXAoKF8sIGluZGV4KSA9PiBzZXJpZXNJdGVtRW5hYmxlZFtpbmRleF0gPz8gdHJ1ZSkgPz8gW107XG4gIH1cbn07XG5QaWVTZXJpZXMuY2xhc3NOYW1lID0gXCJQaWVTZXJpZXNcIjtcblBpZVNlcmllcy50eXBlID0gXCJwaWVcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3BvbGFyL3BpZVNlcmllc01vZHVsZS50c1xudmFyIFBpZVNlcmllc01vZHVsZSA9IHtcbiAgdHlwZTogXCJzZXJpZXNcIixcbiAgb3B0aW9uc0tleTogXCJzZXJpZXNbXVwiLFxuICBwYWNrYWdlVHlwZTogXCJjb21tdW5pdHlcIixcbiAgY2hhcnRUeXBlczogW1wicG9sYXJcIl0sXG4gIGlkZW50aWZpZXI6IFwicGllXCIsXG4gIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBQaWVTZXJpZXMoY3R4KSxcbiAgdG9vbHRpcERlZmF1bHRzOiB7IHJhbmdlOiBcImV4YWN0XCIgfSxcbiAgdGhlbWVUZW1wbGF0ZTogcGllVGhlbWUsXG4gIHBhbGV0dGVGYWN0b3J5OiBwaWVQYWxldHRlRmFjdG9yeVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdG9vbGJhci90b29sYmFyUHJvcGVydGllcy50c1xudmFyIFRvb2xiYXJHcm91cFByb3BlcnRpZXMgPSBjbGFzcyBleHRlbmRzIEJhc2VQcm9wZXJ0aWVzIHtcbiAgY29uc3RydWN0b3Iob25DaGFuZ2UsIG9uQnV0dG9uc0NoYW5nZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vbkNoYW5nZSA9IG9uQ2hhbmdlO1xuICAgIHRoaXMub25CdXR0b25zQ2hhbmdlID0gb25CdXR0b25zQ2hhbmdlO1xuICAgIHRoaXMuYWxpZ24gPSBcInN0YXJ0XCI7XG4gICAgdGhpcy5wb3NpdGlvbiA9IFwidG9wXCIgLyogVG9wICovO1xuICAgIHRoaXMuc2l6ZSA9IFwibm9ybWFsXCI7XG4gICAgdGhpcy5idXR0b25PdmVycmlkZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICB9XG4gIGJ1dHRvbkNvbmZpZ3VyYXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmJ1dHRvbnM/Lm1hcCgoYnV0dG9uKSA9PiB7XG4gICAgICBjb25zdCBpZCA9IGJ1dHRvbi5pZCA/PyBidXR0b24udmFsdWU7XG4gICAgICBjb25zdCBvdmVycmlkZXMgPSB0aGlzLmJ1dHRvbk92ZXJyaWRlcy5nZXQoaWQpO1xuICAgICAgcmV0dXJuIG92ZXJyaWRlcyAhPSBudWxsID8geyAuLi5idXR0b24sIC4uLm92ZXJyaWRlcyB9IDogYnV0dG9uO1xuICAgIH0pID8/IFtdO1xuICB9XG4gIGJ1dHRvbnNDaGFuZ2VkKGNvbmZpZ3VyYXRpb25Pbmx5KSB7XG4gICAgdGhpcy5vbkJ1dHRvbnNDaGFuZ2UodGhpcy5idXR0b25Db25maWd1cmF0aW9ucygpLCBjb25maWd1cmF0aW9uT25seSk7XG4gIH1cbiAgb3ZlcnJpZGVCdXR0b25Db25maWd1cmF0aW9uKGlkLCBvcHRpb25zKSB7XG4gICAgbGV0IG92ZXJyaWRlcyA9IHRoaXMuYnV0dG9uT3ZlcnJpZGVzLmdldChpZCk7XG4gICAgaWYgKG92ZXJyaWRlcyA9PSBudWxsKSB7XG4gICAgICBvdmVycmlkZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuYnV0dG9uT3ZlcnJpZGVzLnNldChpZCwgb3ZlcnJpZGVzKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzW2tleV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdmVycmlkZXNba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmJ1dHRvbnNDaGFuZ2VkKHRydWUpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCkgPT4ge1xuICAgIHRhcmdldC5vbkNoYW5nZSh0YXJnZXQuZW5hYmxlZCk7XG4gIH0pLFxuICBWYWxpZGF0ZShCT09MRUFOKVxuXSwgVG9vbGJhckdyb3VwUHJvcGVydGllcy5wcm90b3R5cGUsIFwiZW5hYmxlZFwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHtcbiAgICB0YXJnZXQub25DaGFuZ2UodGFyZ2V0LmVuYWJsZWQpO1xuICB9KSxcbiAgVmFsaWRhdGUoVU5JT04oWy4uLlRPT0xCQVJfQUxJR05NRU5UU10pLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBUb29sYmFyR3JvdXBQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJhbGlnblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHtcbiAgICB0YXJnZXQub25DaGFuZ2UodGFyZ2V0LmVuYWJsZWQpO1xuICB9KSxcbiAgVmFsaWRhdGUoVU5JT04oVE9PTEJBUl9QT1NJVElPTlMpLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBUb29sYmFyR3JvdXBQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIE9ic2VydmVDaGFuZ2VzKCh0YXJnZXQpID0+IHtcbiAgICB0YXJnZXQub25DaGFuZ2UodGFyZ2V0LmVuYWJsZWQpO1xuICB9KSxcbiAgVmFsaWRhdGUoVU5JT04oW1wic21hbGxcIiwgXCJub3JtYWxcIl0pLCB7IG9wdGlvbmFsOiB0cnVlIH0pXG5dLCBUb29sYmFyR3JvdXBQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJzaXplXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgT2JzZXJ2ZUNoYW5nZXMoKHRhcmdldCkgPT4ge1xuICAgIGZvciAoY29uc3QgYnV0dG9uIG9mIHRhcmdldC5idXR0b25zID8/IFtdKSB7XG4gICAgICBpZiAoYnV0dG9uLmljb24gIT0gbnVsbCAmJiBJQ09OU19MRUdBQ1kuaW5jbHVkZXMoYnV0dG9uLmljb24pKSB7XG4gICAgICAgIExvZ2dlci53YXJuT25jZShgSWNvbiAnJHtidXR0b24uaWNvbn0nIGlzIGRlcHJlY2F0ZWQsIHVzZSBhbm90aGVyIGljb24gaW5zdGVhZC5gKTtcbiAgICAgIH1cbiAgICAgIGlmIChidXR0b24uYXJpYUxhYmVsID09PSBcInRvb2xiYXJBbm5vdGF0aW9uc0NvbG9yXCIpIHtcbiAgICAgICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgICAgIGBBcmlhIGxhYmVsICcke2J1dHRvbi5hcmlhTGFiZWx9JyBpcyBkZXByZWNhdGVkLCB1c2UgJ3Rvb2xiYXJBbm5vdGF0aW9uc0xpbmVDb2xvcicgaW5zdGVhZC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHRhcmdldC5idXR0b25zQ2hhbmdlZChmYWxzZSk7XG4gIH0pLFxuICBWYWxpZGF0ZShBUlJBWSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgVG9vbGJhckdyb3VwUHJvcGVydGllcy5wcm90b3R5cGUsIFwiYnV0dG9uc1wiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdG9vbGJhci90b29sYmFyU3R5bGVzLnRzXG52YXIgYmxvY2syID0gXCJhZy1jaGFydHMtdG9vbGJhclwiO1xudmFyIGVsZW1lbnRzMiA9IHtcbiAgYWxpZ246IFwiYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduXCIsXG4gIHNlY3Rpb246IFwiYWctY2hhcnRzLXRvb2xiYXJfX3NlY3Rpb25cIixcbiAgYnV0dG9uOiBcImFnLWNoYXJ0cy10b29sYmFyX19idXR0b25cIixcbiAgaWNvbjogXCJhZy1jaGFydHMtdG9vbGJhcl9faWNvblwiLFxuICBsYWJlbDogXCJhZy1jaGFydHMtdG9vbGJhcl9fbGFiZWxcIlxufTtcbnZhciBtb2RpZmllcnMyID0ge1xuICBbXCJ0b3BcIiAvKiBUb3AgKi9dOiBcImFnLWNoYXJ0cy10b29sYmFyLS10b3BcIixcbiAgW1wicmlnaHRcIiAvKiBSaWdodCAqL106IFwiYWctY2hhcnRzLXRvb2xiYXItLXJpZ2h0XCIsXG4gIFtcImJvdHRvbVwiIC8qIEJvdHRvbSAqL106IFwiYWctY2hhcnRzLXRvb2xiYXItLWJvdHRvbVwiLFxuICBbXCJsZWZ0XCIgLyogTGVmdCAqL106IFwiYWctY2hhcnRzLXRvb2xiYXItLWxlZnRcIixcbiAgW1wiZmxvYXRpbmdcIiAvKiBGbG9hdGluZyAqL106IFwiYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nXCIsXG4gIFtcImZsb2F0aW5nLXRvcFwiIC8qIEZsb2F0aW5nVG9wICovXTogXCJhZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmctdG9wXCIsXG4gIFtcImZsb2F0aW5nLWJvdHRvbVwiIC8qIEZsb2F0aW5nQm90dG9tICovXTogXCJhZy1jaGFydHMtdG9vbGJhci0tZmxvYXRpbmctYm90dG9tXCIsXG4gIHNtYWxsOiBcImFnLWNoYXJ0cy10b29sYmFyLS1zbWFsbFwiLFxuICBub3JtYWw6IFwiYWctY2hhcnRzLXRvb2xiYXItLW5vcm1hbFwiLFxuICBoaWRkZW46IFwiYWctY2hhcnRzLXRvb2xiYXItLWhpZGRlblwiLFxuICBwcmV2ZW50Rmxhc2g6IFwiYWctY2hhcnRzLXRvb2xiYXItLXByZXZlbnQtZmxhc2hcIixcbiAgZmxvYXRpbmdIaWRkZW46IFwiYWctY2hhcnRzLXRvb2xiYXItLWZsb2F0aW5nLWhpZGRlblwiLFxuICBhbGlnbjoge1xuICAgIHN0YXJ0OiBcImFnLWNoYXJ0cy10b29sYmFyX19hbGlnbi0tc3RhcnRcIixcbiAgICBjZW50ZXI6IFwiYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduLS1jZW50ZXJcIixcbiAgICBlbmQ6IFwiYWctY2hhcnRzLXRvb2xiYXJfX2FsaWduLS1lbmRcIlxuICB9LFxuICBidXR0b246IHtcbiAgICBhY3RpdmU6IGBhZy1jaGFydHMtdG9vbGJhcl9fYnV0dG9uLS1hY3RpdmVgLFxuICAgIGhpZGRlblZhbHVlOiBgYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0taGlkZGVuLXZhbHVlYCxcbiAgICBoaWRkZW5Ub2dnbGVkOiBgYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0taGlkZGVuLXRvZ2dsZWRgLFxuICAgIGZpbGxWaXNpYmxlOiBgYWctY2hhcnRzLXRvb2xiYXJfX2J1dHRvbi0tZmlsbC12aXNpYmxlYFxuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90b29sYmFyL3Rvb2xiYXIudHNcbnZhciBUb29sYmFyID0gY2xhc3MgZXh0ZW5kcyBCYXNlTW9kdWxlSW5zdGFuY2Uge1xuICBjb25zdHJ1Y3RvcihjdHgpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgdGhpcy5zZXJpZXNUeXBlID0gbmV3IFRvb2xiYXJHcm91cFByb3BlcnRpZXMoXG4gICAgICB0aGlzLm9uR3JvdXBDaGFuZ2VkLmJpbmQodGhpcywgXCJzZXJpZXNUeXBlXCIpLFxuICAgICAgdGhpcy5vbkdyb3VwQnV0dG9uc0NoYW5nZWQuYmluZCh0aGlzLCBcInNlcmllc1R5cGVcIilcbiAgICApO1xuICAgIHRoaXMuYW5ub3RhdGlvbnMgPSBuZXcgVG9vbGJhckdyb3VwUHJvcGVydGllcyhcbiAgICAgIHRoaXMub25Hcm91cENoYW5nZWQuYmluZCh0aGlzLCBcImFubm90YXRpb25zXCIpLFxuICAgICAgdGhpcy5vbkdyb3VwQnV0dG9uc0NoYW5nZWQuYmluZCh0aGlzLCBcImFubm90YXRpb25zXCIpXG4gICAgKTtcbiAgICB0aGlzLmFubm90YXRpb25PcHRpb25zID0gbmV3IFRvb2xiYXJHcm91cFByb3BlcnRpZXMoXG4gICAgICB0aGlzLm9uR3JvdXBDaGFuZ2VkLmJpbmQodGhpcywgXCJhbm5vdGF0aW9uT3B0aW9uc1wiKSxcbiAgICAgIHRoaXMub25Hcm91cEJ1dHRvbnNDaGFuZ2VkLmJpbmQodGhpcywgXCJhbm5vdGF0aW9uT3B0aW9uc1wiKVxuICAgICk7XG4gICAgdGhpcy5yYW5nZXMgPSBuZXcgVG9vbGJhckdyb3VwUHJvcGVydGllcyhcbiAgICAgIHRoaXMub25Hcm91cENoYW5nZWQuYmluZCh0aGlzLCBcInJhbmdlc1wiKSxcbiAgICAgIHRoaXMub25Hcm91cEJ1dHRvbnNDaGFuZ2VkLmJpbmQodGhpcywgXCJyYW5nZXNcIilcbiAgICApO1xuICAgIHRoaXMuem9vbSA9IG5ldyBUb29sYmFyR3JvdXBQcm9wZXJ0aWVzKFxuICAgICAgdGhpcy5vbkdyb3VwQ2hhbmdlZC5iaW5kKHRoaXMsIFwiem9vbVwiKSxcbiAgICAgIHRoaXMub25Hcm91cEJ1dHRvbnNDaGFuZ2VkLmJpbmQodGhpcywgXCJ6b29tXCIpXG4gICAgKTtcbiAgICB0aGlzLmhvcml6b250YWxTcGFjaW5nID0gMTA7XG4gICAgdGhpcy52ZXJ0aWNhbFNwYWNpbmcgPSAxMDtcbiAgICB0aGlzLmZsb2F0aW5nRGV0ZWN0aW9uUmFuZ2UgPSAzODtcbiAgICB0aGlzLnBvc2l0aW9ucyA9IHtcbiAgICAgIFtcInRvcFwiIC8qIFRvcCAqL106IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICBbXCJyaWdodFwiIC8qIFJpZ2h0ICovXTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgIFtcImJvdHRvbVwiIC8qIEJvdHRvbSAqL106IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICBbXCJsZWZ0XCIgLyogTGVmdCAqL106IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICBbXCJmbG9hdGluZ1wiIC8qIEZsb2F0aW5nICovXTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgIFtcImZsb2F0aW5nLXRvcFwiIC8qIEZsb2F0aW5nVG9wICovXTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgIFtcImZsb2F0aW5nLWJvdHRvbVwiIC8qIEZsb2F0aW5nQm90dG9tICovXTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgIH07XG4gICAgdGhpcy5wb3NpdGlvbkFsaWdubWVudHMgPSB7XG4gICAgICBbXCJ0b3BcIiAvKiBUb3AgKi9dOiB7fSxcbiAgICAgIFtcInJpZ2h0XCIgLyogUmlnaHQgKi9dOiB7fSxcbiAgICAgIFtcImJvdHRvbVwiIC8qIEJvdHRvbSAqL106IHt9LFxuICAgICAgW1wibGVmdFwiIC8qIExlZnQgKi9dOiB7fSxcbiAgICAgIFtcImZsb2F0aW5nXCIgLyogRmxvYXRpbmcgKi9dOiB7fSxcbiAgICAgIFtcImZsb2F0aW5nLXRvcFwiIC8qIEZsb2F0aW5nVG9wICovXToge30sXG4gICAgICBbXCJmbG9hdGluZy1ib3R0b21cIiAvKiBGbG9hdGluZ0JvdHRvbSAqL106IHt9XG4gICAgfTtcbiAgICB0aGlzLmdyb3VwQ2FsbGVycyA9IHtcbiAgICAgIHNlcmllc1R5cGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICBhbm5vdGF0aW9uczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgIGFubm90YXRpb25PcHRpb25zOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgcmFuZ2VzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgem9vbTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgIH07XG4gICAgdGhpcy5ncm91cEJ1dHRvbnMgPSB7XG4gICAgICBzZXJpZXNUeXBlOiBbXSxcbiAgICAgIGFubm90YXRpb25zOiBbXSxcbiAgICAgIGFubm90YXRpb25PcHRpb25zOiBbXSxcbiAgICAgIHJhbmdlczogW10sXG4gICAgICB6b29tOiBbXVxuICAgIH07XG4gICAgdGhpcy5hcmlhVG9vbGJhcnMgPSBbXG4gICAgICB7IGdyb3VwczogW1wic2VyaWVzVHlwZVwiLCBcImFubm90YXRpb25zXCJdLCBkZXN0cm95Rm5zOiBbXSB9LFxuICAgICAgeyBncm91cHM6IFtcImFubm90YXRpb25PcHRpb25zXCJdLCBkZXN0cm95Rm5zOiBbXSB9LFxuICAgICAgeyBncm91cHM6IFtcInJhbmdlc1wiXSwgZGVzdHJveUZuczogW10gfSxcbiAgICAgIHsgZ3JvdXBzOiBbXCJ6b29tXCJdLCBkZXN0cm95Rm5zOiBbXSB9XG4gICAgXTtcbiAgICB0aGlzLnBlbmRpbmdCdXR0b25Ub2dnbGVkRXZlbnRzID0gW107XG4gICAgdGhpcy5ncm91cFByb3hpZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMuaGFzTmV3TG9jYWxlID0gdHJ1ZTtcbiAgICB0aGlzLmVsZW1lbnRzID0ge307XG4gICAgZm9yIChjb25zdCBwb3NpdGlvbiBvZiBUT09MQkFSX1BPU0lUSU9OUykge1xuICAgICAgdGhpcy5lbGVtZW50c1twb3NpdGlvbl0gPSBjdHguZG9tTWFuYWdlci5hZGRDaGlsZChcImNhbnZhcy1vdmVybGF5XCIsIGB0b29sYmFyLSR7cG9zaXRpb259YCk7XG4gICAgICB0aGlzLmVsZW1lbnRzW3Bvc2l0aW9uXS5yb2xlID0gXCJwcmVzZW50YXRpb25cIjtcbiAgICAgIHRoaXMucmVuZGVyVG9vbGJhcihwb3NpdGlvbik7XG4gICAgfVxuICAgIHRoaXMudG9nZ2xlVmlzaWJpbGl0aWVzKCk7XG4gICAgdGhpcy5kZXN0cm95Rm5zLnB1c2goXG4gICAgICBjdHguaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwiaG92ZXJcIiwgdGhpcy5vbkhvdmVyLmJpbmQodGhpcyksIDMxIC8qIEFsbCAqLyksXG4gICAgICBjdHguaW50ZXJhY3Rpb25NYW5hZ2VyLmFkZExpc3RlbmVyKFwibGVhdmVcIiwgdGhpcy5vbkxlYXZlLmJpbmQodGhpcyksIDMxIC8qIEFsbCAqLyksXG4gICAgICBjdHgudG9vbGJhck1hbmFnZXIuYWRkTGlzdGVuZXIoXCJidXR0b24tdG9nZ2xlZFwiLCB0aGlzLm9uQnV0dG9uVG9nZ2xlZC5iaW5kKHRoaXMpKSxcbiAgICAgIGN0eC50b29sYmFyTWFuYWdlci5hZGRMaXN0ZW5lcihcImJ1dHRvbi11cGRhdGVkXCIsIHRoaXMub25CdXR0b25VcGRhdGVkLmJpbmQodGhpcykpLFxuICAgICAgY3R4LnRvb2xiYXJNYW5hZ2VyLmFkZExpc3RlbmVyKFwiZ3JvdXAtdG9nZ2xlZFwiLCB0aGlzLm9uR3JvdXBUb2dnbGVkLmJpbmQodGhpcykpLFxuICAgICAgY3R4LnRvb2xiYXJNYW5hZ2VyLmFkZExpc3RlbmVyKFwiZmxvYXRpbmctYW5jaG9yLWNoYW5nZWRcIiwgdGhpcy5vbkZsb2F0aW5nQW5jaG9yQ2hhbmdlZC5iaW5kKHRoaXMpKSxcbiAgICAgIGN0eC50b29sYmFyTWFuYWdlci5hZGRMaXN0ZW5lcihcInByb3h5LWdyb3VwLW9wdGlvbnNcIiwgdGhpcy5vblByb3h5R3JvdXBPcHRpb25zLmJpbmQodGhpcykpLFxuICAgICAgY3R4LmxheW91dFNlcnZpY2UuYWRkTGlzdGVuZXIoXCJsYXlvdXQtY29tcGxldGVcIiwgdGhpcy5vbkxheW91dENvbXBsZXRlLmJpbmQodGhpcykpLFxuICAgICAgY3R4LmxvY2FsZU1hbmFnZXIuYWRkTGlzdGVuZXIoXCJsb2NhbGUtY2hhbmdlZFwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuaGFzTmV3TG9jYWxlID0gdHJ1ZTtcbiAgICAgIH0pLFxuICAgICAgKCkgPT4gdGhpcy5kZXN0cm95RWxlbWVudHMoKVxuICAgICk7XG4gIH1cbiAgZGVzdHJveUVsZW1lbnRzKCkge1xuICAgIHRoaXMuY3R4LmRvbU1hbmFnZXIucmVtb3ZlU3R5bGVzKGJsb2NrMik7XG4gICAgZm9yIChjb25zdCBlbGVtZW50MiBvZiBPYmplY3Qua2V5cyh0aGlzLmVsZW1lbnRzKSkge1xuICAgICAgdGhpcy5jdHguZG9tTWFuYWdlci5yZW1vdmVDaGlsZChcImNhbnZhcy1vdmVybGF5XCIsIGB0b29sYmFyLSR7ZWxlbWVudDJ9YCk7XG4gICAgfVxuICB9XG4gIG9uSG92ZXIoZXZlbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbmFibGVkLFxuICAgICAgZWxlbWVudHM6IGVsZW1lbnRzMyxcbiAgICAgIGZsb2F0aW5nRGV0ZWN0aW9uUmFuZ2UsXG4gICAgICBjdHg6IHsgc2NlbmUgfVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHtcbiAgICAgIG9mZnNldFksXG4gICAgICBzb3VyY2VFdmVudDogeyB0YXJnZXQgfVxuICAgIH0gPSBldmVudDtcbiAgICBjb25zdCB7IEZsb2F0aW5nQm90dG9tLCBGbG9hdGluZ1RvcCB9ID0gVG9vbGJhclBvc2l0aW9uO1xuICAgIGlmICghZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBib3R0b20gPSBlbGVtZW50czNbRmxvYXRpbmdCb3R0b21dO1xuICAgIGNvbnN0IHRvcCA9IGVsZW1lbnRzM1tGbG9hdGluZ1RvcF07XG4gICAgY29uc3QgYm90dG9tRGV0ZWN0aW9uWSA9IGJvdHRvbS5vZmZzZXRUb3AgLSBmbG9hdGluZ0RldGVjdGlvblJhbmdlO1xuICAgIGNvbnN0IGJvdHRvbVZpc2libGUgPSBvZmZzZXRZID4gYm90dG9tRGV0ZWN0aW9uWSAmJiBvZmZzZXRZIDwgc2NlbmUuY2FudmFzLmVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IHRhcmdldCA9PT0gYm90dG9tO1xuICAgIGNvbnN0IHRvcERldGVjdGlvblkgPSB0b3Aub2Zmc2V0VG9wICsgdG9wLm9mZnNldEhlaWdodCArIGZsb2F0aW5nRGV0ZWN0aW9uUmFuZ2U7XG4gICAgY29uc3QgdG9wVmlzaWJsZSA9IG9mZnNldFkgPiAwICYmIG9mZnNldFkgPCB0b3BEZXRlY3Rpb25ZIHx8IHRhcmdldCA9PT0gdG9wO1xuICAgIHRoaXMudHJhbnNsYXRlRmxvYXRpbmdFbGVtZW50cyhGbG9hdGluZ0JvdHRvbSwgYm90dG9tVmlzaWJsZSk7XG4gICAgdGhpcy50cmFuc2xhdGVGbG9hdGluZ0VsZW1lbnRzKEZsb2F0aW5nVG9wLCB0b3BWaXNpYmxlKTtcbiAgfVxuICBvbkxlYXZlKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgZW5hYmxlZCxcbiAgICAgIGN0eDogeyBzY2VuZSB9XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgeyByZWxhdGVkRWxlbWVudCwgdGFyZ2V0RWxlbWVudCB9ID0gZXZlbnQ7XG4gICAgY29uc3QgeyBGbG9hdGluZ0JvdHRvbSwgRmxvYXRpbmdUb3AgfSA9IFRvb2xiYXJQb3NpdGlvbjtcbiAgICBpZiAoIWVuYWJsZWQgfHwgdGFyZ2V0RWxlbWVudCAhPT0gc2NlbmUuY2FudmFzLmVsZW1lbnQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaXNUYXJnZXRCdXR0b24gPSBUT09MQkFSX0dST1VQUy5zb21lKFxuICAgICAgKGdyb3VwKSA9PiB0aGlzLmdyb3VwQnV0dG9uc1tncm91cF0uc29tZSgoYnV0dG9uKSA9PiBidXR0b24gPT09IHJlbGF0ZWRFbGVtZW50KVxuICAgICk7XG4gICAgaWYgKGlzVGFyZ2V0QnV0dG9uKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMudHJhbnNsYXRlRmxvYXRpbmdFbGVtZW50cyhGbG9hdGluZ0JvdHRvbSwgZmFsc2UpO1xuICAgIHRoaXMudHJhbnNsYXRlRmxvYXRpbmdFbGVtZW50cyhGbG9hdGluZ1RvcCwgZmFsc2UpO1xuICB9XG4gIG9uR3JvdXBDaGFuZ2VkKGdyb3VwKSB7XG4gICAgaWYgKHRoaXNbZ3JvdXBdID09IG51bGwgfHwgdGhpcy5ncm91cFByb3hpZWQuaGFzKGdyb3VwKSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmNyZWF0ZUdyb3VwKGdyb3VwKTtcbiAgICB0aGlzLnRvZ2dsZVZpc2liaWxpdGllcygpO1xuICB9XG4gIG9uR3JvdXBCdXR0b25zQ2hhbmdlZChncm91cCwgYnV0dG9ucywgY29uZmlndXJhdGlvbk9ubHkpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCB0aGlzLmdyb3VwUHJveGllZC5oYXMoZ3JvdXApKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChjb25maWd1cmF0aW9uT25seSkge1xuICAgICAgZm9yIChjb25zdCBidXR0b25PcHRpb25zIG9mIHRoaXNbZ3JvdXBdLmJ1dHRvbkNvbmZpZ3VyYXRpb25zKCkpIHtcbiAgICAgICAgdGhpcy5yZWZyZXNoQnV0dG9uQ29udGVudChncm91cCwgYnV0dG9uT3B0aW9ucyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3JlYXRlR3JvdXBCdXR0b25zKGdyb3VwLCBidXR0b25zKTtcbiAgICB9XG4gICAgdGhpcy50b2dnbGVWaXNpYmlsaXRpZXMoKTtcbiAgfVxuICBvbkxheW91dENvbXBsZXRlKCkge1xuICAgIGZvciAoY29uc3QgcG9zaXRpb24gb2YgVE9PTEJBUl9QT1NJVElPTlMpIHtcbiAgICAgIHRoaXMuZWxlbWVudHNbcG9zaXRpb25dLmNsYXNzTGlzdC5yZW1vdmUobW9kaWZpZXJzMi5wcmV2ZW50Rmxhc2gpO1xuICAgIH1cbiAgfVxuICBvbkJ1dHRvblVwZGF0ZWQoZXZlbnQpIHtcbiAgICBjb25zdCB7IHR5cGU6IF90eXBlLCBncm91cCwgaWQsIC4uLnBhcmFtcyB9ID0gZXZlbnQ7XG4gICAgdGhpc1tncm91cF0ub3ZlcnJpZGVCdXR0b25Db25maWd1cmF0aW9uKGlkLCB7IC4uLnBhcmFtcyB9KTtcbiAgfVxuICBzZXRCdXR0b25BY3RpdmUoYnV0dG9uLCBhY3RpdmUpIHtcbiAgICBidXR0b24uY2xhc3NMaXN0LnRvZ2dsZShtb2RpZmllcnMyLmJ1dHRvbi5hY3RpdmUsIGFjdGl2ZSk7XG4gIH1cbiAgb25CdXR0b25Ub2dnbGVkKGV2ZW50KSB7XG4gICAgY29uc3QgeyBncm91cCwgaWQsIGFjdGl2ZSwgZW5hYmxlZCwgdmlzaWJsZSB9ID0gZXZlbnQ7XG4gICAgaWYgKHRoaXMuZ3JvdXBCdXR0b25zW2dyb3VwXS5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMucGVuZGluZ0J1dHRvblRvZ2dsZWRFdmVudHMucHVzaChldmVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgYnV0dG9uIG9mIHRoaXMuZ3JvdXBCdXR0b25zW2dyb3VwXSkge1xuICAgICAgaWYgKGJ1dHRvbi5kYXRhc2V0LnRvb2xiYXJJZCAhPT0gYCR7aWR9YClcbiAgICAgICAgY29udGludWU7XG4gICAgICBidXR0b24uYXJpYURpc2FibGVkID0gYCR7IWVuYWJsZWR9YDtcbiAgICAgIHNldFZpc2liaWxpdHkoYnV0dG9uLCBtb2RpZmllcnMyLmJ1dHRvbi5oaWRkZW5Ub2dnbGVkLCAhdmlzaWJsZSk7XG4gICAgICB0aGlzLnNldEJ1dHRvbkFjdGl2ZShidXR0b24sIGFjdGl2ZSk7XG4gICAgfVxuICB9XG4gIG9uR3JvdXBUb2dnbGVkKGV2ZW50KSB7XG4gICAgY29uc3QgeyBjYWxsZXIsIGdyb3VwLCBhY3RpdmUsIHZpc2libGUgfSA9IGV2ZW50O1xuICAgIHRoaXMudG9nZ2xlR3JvdXAoY2FsbGVyLCBncm91cCwgYWN0aXZlLCB2aXNpYmxlKTtcbiAgICB0aGlzLnRvZ2dsZVZpc2liaWxpdGllcygpO1xuICB9XG4gIG9uRmxvYXRpbmdBbmNob3JDaGFuZ2VkKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgZWxlbWVudHM6IGVsZW1lbnRzMyxcbiAgICAgIGdyb3VwQnV0dG9ucyxcbiAgICAgIHBvc2l0aW9ucyxcbiAgICAgIGhvcml6b250YWxTcGFjaW5nLFxuICAgICAgdmVydGljYWxTcGFjaW5nLFxuICAgICAgY3R4OiB7IGRvbU1hbmFnZXIsIHRvb2xiYXJNYW5hZ2VyIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7IGdyb3VwLCBhbmNob3IgfSA9IGV2ZW50O1xuICAgIGlmICghcG9zaXRpb25zW1wiZmxvYXRpbmdcIiAvKiBGbG9hdGluZyAqL10uaGFzKGdyb3VwKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBlbGVtZW50MiA9IGVsZW1lbnRzM1tcImZsb2F0aW5nXCIgLyogRmxvYXRpbmcgKi9dO1xuICAgIGlmIChlbGVtZW50Mi5jbGFzc0xpc3QuY29udGFpbnMobW9kaWZpZXJzMi5oaWRkZW4pKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHBvc2l0aW9uID0gYW5jaG9yLnBvc2l0aW9uID8/IFwiYWJvdmVcIjtcbiAgICBjb25zdCB7IG9mZnNldFdpZHRoOiB3aWR0aCwgb2Zmc2V0SGVpZ2h0OiBoZWlnaHQgfSA9IGVsZW1lbnQyO1xuICAgIGxldCB0b3AgPSBhbmNob3IueSAtIGhlaWdodCAtIHZlcnRpY2FsU3BhY2luZztcbiAgICBsZXQgbGVmdCA9IGFuY2hvci54IC0gd2lkdGggLyAyO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gXCJyaWdodFwiKSB7XG4gICAgICB0b3AgPSBhbmNob3IueSAtIGhlaWdodCAvIDI7XG4gICAgICBsZWZ0ID0gYW5jaG9yLnggKyBob3Jpem9udGFsU3BhY2luZztcbiAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSBcImFib3ZlLWxlZnRcIikge1xuICAgICAgbGVmdCA9IGFuY2hvci54O1xuICAgIH1cbiAgICBjb25zdCBjYW52YXNSZWN0ID0gZG9tTWFuYWdlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB0b3AgPSBjbGFtcCgwLCB0b3AsIGNhbnZhc1JlY3QuaGVpZ2h0IC0gaGVpZ2h0KTtcbiAgICBsZWZ0ID0gY2xhbXAoMCwgbGVmdCwgY2FudmFzUmVjdC53aWR0aCAtIHdpZHRoKTtcbiAgICBlbGVtZW50Mi5zdHlsZS50b3AgPSBgJHt0b3B9cHhgO1xuICAgIGVsZW1lbnQyLnN0eWxlLmxlZnQgPSBgJHtsZWZ0fXB4YDtcbiAgICBjb25zdCBncm91cEJCb3ggPSBuZXcgQkJveChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGZvciAoY29uc3QgYnV0dG9uIG9mIGdyb3VwQnV0dG9uc1tncm91cF0pIHtcbiAgICAgIGlmIChidXR0b24uY2xhc3NMaXN0LmNvbnRhaW5zKG1vZGlmaWVyczIuYnV0dG9uLmhpZGRlblRvZ2dsZWQpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IHBhcmVudCA9IGJ1dHRvbi5vZmZzZXRQYXJlbnQ7XG4gICAgICB0b29sYmFyTWFuYWdlci5idXR0b25Nb3ZlZChcbiAgICAgICAgZ3JvdXAsXG4gICAgICAgIGJ1dHRvbi5kYXRhc2V0LnRvb2xiYXJJZCxcbiAgICAgICAgbmV3IEJCb3goXG4gICAgICAgICAgYnV0dG9uLm9mZnNldExlZnQgKyAocGFyZW50Py5vZmZzZXRMZWZ0ID8/IDApLFxuICAgICAgICAgIGJ1dHRvbi5vZmZzZXRUb3AgKyAocGFyZW50Py5vZmZzZXRUb3AgPz8gMCksXG4gICAgICAgICAgYnV0dG9uLm9mZnNldFdpZHRoLFxuICAgICAgICAgIGJ1dHRvbi5vZmZzZXRIZWlnaHRcbiAgICAgICAgKSxcbiAgICAgICAgZ3JvdXBCQm94XG4gICAgICApO1xuICAgIH1cbiAgfVxuICBidXR0b25SZWN0KGJ1dHRvbiwgY2FudmFzUmVjdCA9IHRoaXMuY3R4LmRvbU1hbmFnZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpIHtcbiAgICBjb25zdCBidXR0b25SZWN0ID0gYnV0dG9uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiBuZXcgQkJveChcbiAgICAgIGJ1dHRvblJlY3QubGVmdCAtIGNhbnZhc1JlY3QubGVmdCxcbiAgICAgIGJ1dHRvblJlY3QudG9wIC0gY2FudmFzUmVjdC50b3AsXG4gICAgICBidXR0b25SZWN0LndpZHRoLFxuICAgICAgYnV0dG9uUmVjdC5oZWlnaHRcbiAgICApO1xuICB9XG4gIG9uUHJveHlHcm91cE9wdGlvbnMoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGNhbGxlciwgZ3JvdXAsIG9wdGlvbnMgfSA9IGV2ZW50O1xuICAgIHRoaXMuZ3JvdXBQcm94aWVkLnNldChncm91cCwgb3B0aW9ucyk7XG4gICAgdGhpc1tncm91cF0uc2V0KG9wdGlvbnMpO1xuICAgIHRoaXMudG9nZ2xlR3JvdXAoY2FsbGVyLCBncm91cCwgdm9pZCAwLCBvcHRpb25zLmVuYWJsZWQpO1xuICAgIHRoaXMuY3JlYXRlR3JvdXAoZ3JvdXAsIG9wdGlvbnMuZW5hYmxlZCwgb3B0aW9ucy5wb3NpdGlvbik7XG4gICAgaWYgKG9wdGlvbnMuZW5hYmxlZCkge1xuICAgICAgdGhpcy5jcmVhdGVHcm91cEJ1dHRvbnMoZ3JvdXAsIG9wdGlvbnMuYnV0dG9ucyk7XG4gICAgfVxuICB9XG4gIGNyZWF0ZUdyb3VwKGdyb3VwLCBlbmFibGVkLCBwb3NpdGlvbikge1xuICAgIGVuYWJsZWQgPz8gKGVuYWJsZWQgPSB0aGlzW2dyb3VwXS5lbmFibGVkKTtcbiAgICBwb3NpdGlvbiA/PyAocG9zaXRpb24gPSB0aGlzW2dyb3VwXS5wb3NpdGlvbik7XG4gICAgZm9yIChjb25zdCBwb3Mgb2YgVE9PTEJBUl9QT1NJVElPTlMpIHtcbiAgICAgIGlmIChlbmFibGVkICYmIHBvc2l0aW9uID09PSBwb3MpIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnNbcG9zXS5hZGQoZ3JvdXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbnNbcG9zXS5kZWxldGUoZ3JvdXApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjcmVhdGVHcm91cEJ1dHRvbnMoZ3JvdXAsIGJ1dHRvbnMgPSBbXSkge1xuICAgIGZvciAoY29uc3QgYnV0dG9uIG9mIHRoaXMuZ3JvdXBCdXR0b25zW2dyb3VwXSkge1xuICAgICAgYnV0dG9uLnJlbW92ZSgpO1xuICAgIH1cbiAgICBjb25zdCBhcmlhVG9vbGJhciA9IHRoaXMuZ2V0QXJpYVRvb2xiYXIoZ3JvdXApO1xuICAgIHRoaXMuZ3JvdXBCdXR0b25zW2dyb3VwXSA9IFtdO1xuICAgIGFyaWFUb29sYmFyLmRlc3Ryb3lGbnMuZm9yRWFjaCgoZCkgPT4gZCgpKTtcbiAgICBhcmlhVG9vbGJhci5kZXN0cm95Rm5zID0gW107XG4gICAgaWYgKGJ1dHRvbnMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHsgYWxpZ24sIHBvc2l0aW9uIH0gPSB0aGlzW2dyb3VwXTtcbiAgICBjb25zdCBhbGlnbkVsZW1lbnQgPSB0aGlzLnBvc2l0aW9uQWxpZ25tZW50c1twb3NpdGlvbl1bYWxpZ25dO1xuICAgIGlmICghYWxpZ25FbGVtZW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG5leHRTZWN0aW9uID0gKHNlY3Rpb24yKSA9PiB7XG4gICAgICBjb25zdCBhbGlnbkVsZW1lbnRDaGlsZHJlbiA9IEFycmF5LmZyb20oYWxpZ25FbGVtZW50LmNoaWxkcmVuKTtcbiAgICAgIGNvbnN0IGRhdGFHcm91cCA9IFwiZGF0YS1ncm91cFwiO1xuICAgICAgY29uc3QgZGF0YVNlY3Rpb24gPSBcImRhdGEtc2VjdGlvblwiO1xuICAgICAgbGV0IHNlY3Rpb25FbGVtZW50ID0gYWxpZ25FbGVtZW50Q2hpbGRyZW4uZmluZCgocHJldlNlY3Rpb24yKSA9PiB7XG4gICAgICAgIHJldHVybiBwcmV2U2VjdGlvbjIuZ2V0QXR0cmlidXRlKGRhdGFHcm91cCkgPT09IGdyb3VwICYmIHByZXZTZWN0aW9uMi5nZXRBdHRyaWJ1dGUoZGF0YVNlY3Rpb24pID09PSAoc2VjdGlvbjIgPz8gXCJcIik7XG4gICAgICB9KTtcbiAgICAgIGlmICghc2VjdGlvbkVsZW1lbnQpIHtcbiAgICAgICAgc2VjdGlvbkVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBzZWN0aW9uRWxlbWVudC5yb2xlID0gXCJwcmVzZW50YXRpb25cIjtcbiAgICAgICAgc2VjdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKGRhdGFHcm91cCwgZ3JvdXApO1xuICAgICAgICBzZWN0aW9uRWxlbWVudC5zZXRBdHRyaWJ1dGUoZGF0YVNlY3Rpb24sIHNlY3Rpb24yID8/IFwiXCIpO1xuICAgICAgICBjb25zdCBncm91cEluZGV4ID0gVE9PTEJBUl9HUk9VUF9PUkRFUklOR1tncm91cF07XG4gICAgICAgIGNvbnN0IGluc2VydEJlZm9yZUVsZW1lbnQgPSBhbGlnbkVsZW1lbnRDaGlsZHJlbi5maW5kKChwcmV2U2VjdGlvbjIpID0+IHtcbiAgICAgICAgICBjb25zdCBwcmV2R3JvdXAgPSBwcmV2U2VjdGlvbjIuZ2V0QXR0cmlidXRlKGRhdGFHcm91cCk7XG4gICAgICAgICAgY29uc3QgcHJldkdyb3VwSW5kZXggPSBUT09MQkFSX0dST1VQX09SREVSSU5HW3ByZXZHcm91cF07XG4gICAgICAgICAgcmV0dXJuIHByZXZHcm91cEluZGV4ID4gZ3JvdXBJbmRleDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbnNlcnRCZWZvcmVFbGVtZW50ICE9IG51bGwpIHtcbiAgICAgICAgICBhbGlnbkVsZW1lbnQuaW5zZXJ0QmVmb3JlKHNlY3Rpb25FbGVtZW50LCBpbnNlcnRCZWZvcmVFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhbGlnbkVsZW1lbnQuYXBwZW5kQ2hpbGQoc2VjdGlvbkVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKCgpID0+IHNlY3Rpb25FbGVtZW50LnJlbW92ZSgpKTtcbiAgICAgIH1cbiAgICAgIHNlY3Rpb25FbGVtZW50LmNsYXNzTGlzdC5hZGQoZWxlbWVudHMyLnNlY3Rpb24sIG1vZGlmaWVyczJbdGhpc1tncm91cF0uc2l6ZV0pO1xuICAgICAgcmV0dXJuIHNlY3Rpb25FbGVtZW50O1xuICAgIH07XG4gICAgbGV0IHByZXZTZWN0aW9uID0gYnV0dG9ucy5hdCgwKT8uc2VjdGlvbjtcbiAgICBsZXQgc2VjdGlvbiA9IG5leHRTZWN0aW9uKHByZXZTZWN0aW9uKTtcbiAgICBmb3IgKGNvbnN0IG9wdGlvbnMgb2YgYnV0dG9ucykge1xuICAgICAgaWYgKHByZXZTZWN0aW9uICE9PSBvcHRpb25zLnNlY3Rpb24pIHtcbiAgICAgICAgc2VjdGlvbiA9IG5leHRTZWN0aW9uKG9wdGlvbnMuc2VjdGlvbik7XG4gICAgICB9XG4gICAgICBwcmV2U2VjdGlvbiA9IG9wdGlvbnMuc2VjdGlvbjtcbiAgICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuY3JlYXRlQnV0dG9uRWxlbWVudChncm91cCwgb3B0aW9ucyk7XG4gICAgICBzZWN0aW9uLmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICB0aGlzLmdyb3VwQnV0dG9uc1tncm91cF0ucHVzaChidXR0b24pO1xuICAgIH1cbiAgICBjb25zdCBvbkVzY2FwZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuY3R4LnRvb2xiYXJNYW5hZ2VyLmNhbmNlbChncm91cCk7XG4gICAgfTtcbiAgICBsZXQgb25Gb2N1cztcbiAgICBsZXQgb25CbHVyO1xuICAgIGlmIChpc0FuaW1hdGluZ0Zsb2F0aW5nUG9zaXRpb24ocG9zaXRpb24pKSB7XG4gICAgICBvbkZvY3VzID0gKCkgPT4gdGhpcy50cmFuc2xhdGVGbG9hdGluZ0VsZW1lbnRzKHBvc2l0aW9uLCB0cnVlKTtcbiAgICAgIG9uQmx1ciA9ICgpID0+IHRoaXMudHJhbnNsYXRlRmxvYXRpbmdFbGVtZW50cyhwb3NpdGlvbiwgZmFsc2UpO1xuICAgIH1cbiAgICBjb25zdCBvcmllbnRhdGlvbiA9IHRoaXMuY29tcHV0ZUFyaWFPcmllbnRhdGlvbih0aGlzW2dyb3VwXS5wb3NpdGlvbik7XG4gICAgY29uc3QgYXJpYVRvb2xiYXJCdXR0b25zID0gYXJpYVRvb2xiYXIuZ3JvdXBzLm1hcCgoZykgPT4gdGhpcy5ncm91cEJ1dHRvbnNbZ10pLmZsYXQoKTtcbiAgICBhcmlhVG9vbGJhci5kZXN0cm95Rm5zID0gaW5pdFRvb2xiYXJLZXlOYXYoe1xuICAgICAgb3JpZW50YXRpb24sXG4gICAgICB0b29sYmFyOiBhbGlnbkVsZW1lbnQsXG4gICAgICBidXR0b25zOiBhcmlhVG9vbGJhckJ1dHRvbnMsXG4gICAgICBvbkVzY2FwZSxcbiAgICAgIG9uRm9jdXMsXG4gICAgICBvbkJsdXJcbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZVRvb2xiYXJBcmlhTGFiZWwoZ3JvdXAsIGFsaWduRWxlbWVudCk7XG4gIH1cbiAgY29tcHV0ZUFyaWFPcmllbnRhdGlvbihwb3NpdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICB0b3A6IFwiaG9yaXpvbnRhbFwiLFxuICAgICAgcmlnaHQ6IFwidmVydGljYWxcIixcbiAgICAgIGJvdHRvbTogXCJob3Jpem9udGFsXCIsXG4gICAgICBsZWZ0OiBcInZlcnRpY2FsXCIsXG4gICAgICBmbG9hdGluZzogXCJob3Jpem9udGFsXCIsXG4gICAgICBcImZsb2F0aW5nLXRvcFwiOiBcImhvcml6b250YWxcIixcbiAgICAgIFwiZmxvYXRpbmctYm90dG9tXCI6IFwiaG9yaXpvbnRhbFwiXG4gICAgfVtwb3NpdGlvbl07XG4gIH1cbiAgdG9nZ2xlR3JvdXAoY2FsbGVyLCBncm91cCwgYWN0aXZlLCBlbmFibGVkKSB7XG4gICAgaWYgKGVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuZ3JvdXBDYWxsZXJzW2dyb3VwXS5hZGQoY2FsbGVyKTtcbiAgICB9IGVsc2UgaWYgKGVuYWJsZWQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmdyb3VwQ2FsbGVyc1tncm91cF0uZGVsZXRlKGNhbGxlcik7XG4gICAgfVxuICAgIGlmIChhY3RpdmUgIT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBidXR0b24gb2YgdGhpcy5ncm91cEJ1dHRvbnNbZ3JvdXBdKSB7XG4gICAgICAgIHRoaXMuc2V0QnV0dG9uQWN0aXZlKGJ1dHRvbiwgYWN0aXZlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcHJvY2Vzc1BlbmRpbmdFdmVudHMoKSB7XG4gICAgY29uc3QgcGVuZGluZ0J1dHRvblRvZ2dsZWRFdmVudHMgPSAodGhpcy5wZW5kaW5nQnV0dG9uVG9nZ2xlZEV2ZW50cyA/PyBbXSkuc2xpY2UoKTtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIHBlbmRpbmdCdXR0b25Ub2dnbGVkRXZlbnRzKSB7XG4gICAgICB0aGlzLm9uQnV0dG9uVG9nZ2xlZChldmVudCk7XG4gICAgfVxuICAgIHRoaXMucGVuZGluZ0J1dHRvblRvZ2dsZWRFdmVudHMgPSBbXTtcbiAgfVxuICBhc3luYyBwZXJmb3JtTGF5b3V0KGN0eCkge1xuICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgcmV0dXJuIGN0eDtcbiAgICB0aGlzLnJlZnJlc2hPdXRlckxheW91dChjdHguc2hyaW5rUmVjdCk7XG4gICAgdGhpcy5yZWZyZXNoTG9jYWxlKCk7XG4gICAgcmV0dXJuIGN0eDtcbiAgfVxuICBhc3luYyBwZXJmb3JtQ2FydGVzaWFuTGF5b3V0KG9wdHMpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLnJlZnJlc2hJbm5lckxheW91dChvcHRzLnNlcmllc1JlY3QpO1xuICB9XG4gIHJlZnJlc2hPdXRlckxheW91dChzaHJpbmtSZWN0KSB7XG4gICAgY29uc3QgeyBlbGVtZW50czogZWxlbWVudHMzLCBob3Jpem9udGFsU3BhY2luZywgdmVydGljYWxTcGFjaW5nIH0gPSB0aGlzO1xuICAgIGlmICghZWxlbWVudHMzLnRvcC5jbGFzc0xpc3QuY29udGFpbnMobW9kaWZpZXJzMi5oaWRkZW4pKSB7XG4gICAgICBzaHJpbmtSZWN0LnNocmluayhlbGVtZW50czMudG9wLm9mZnNldEhlaWdodCArIHZlcnRpY2FsU3BhY2luZywgXCJ0b3BcIik7XG4gICAgfVxuICAgIGlmICghZWxlbWVudHMzLnJpZ2h0LmNsYXNzTGlzdC5jb250YWlucyhtb2RpZmllcnMyLmhpZGRlbikpIHtcbiAgICAgIHNocmlua1JlY3Quc2hyaW5rKGVsZW1lbnRzMy5yaWdodC5vZmZzZXRXaWR0aCArIGhvcml6b250YWxTcGFjaW5nLCBcInJpZ2h0XCIpO1xuICAgIH1cbiAgICBpZiAoIWVsZW1lbnRzMy5ib3R0b20uY2xhc3NMaXN0LmNvbnRhaW5zKG1vZGlmaWVyczIuaGlkZGVuKSkge1xuICAgICAgc2hyaW5rUmVjdC5zaHJpbmsoZWxlbWVudHMzLmJvdHRvbS5vZmZzZXRIZWlnaHQgKyB2ZXJ0aWNhbFNwYWNpbmcsIFwiYm90dG9tXCIpO1xuICAgICAgZWxlbWVudHMzLmJvdHRvbS5zdHlsZS50b3AgPSBgJHtzaHJpbmtSZWN0LnkgKyBzaHJpbmtSZWN0LmhlaWdodCArIHZlcnRpY2FsU3BhY2luZ31weGA7XG4gICAgfVxuICAgIGlmICghZWxlbWVudHMzLmxlZnQuY2xhc3NMaXN0LmNvbnRhaW5zKG1vZGlmaWVyczIuaGlkZGVuKSkge1xuICAgICAgc2hyaW5rUmVjdC5zaHJpbmsoZWxlbWVudHMzLmxlZnQub2Zmc2V0V2lkdGggKyBob3Jpem9udGFsU3BhY2luZywgXCJsZWZ0XCIpO1xuICAgIH1cbiAgfVxuICByZWZyZXNoTG9jYWxlKCkge1xuICAgIGNvbnN0IHsgaGFzTmV3TG9jYWxlIH0gPSB0aGlzO1xuICAgIGlmICghaGFzTmV3TG9jYWxlKVxuICAgICAgcmV0dXJuO1xuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgVE9PTEJBUl9HUk9VUFMpIHtcbiAgICAgIGNvbnN0IGJ1dHRvbnMgPSB0aGlzW2dyb3VwXS5idXR0b25Db25maWd1cmF0aW9ucygpO1xuICAgICAgZm9yIChjb25zdCBidXR0b25PcHRpb25zIG9mIGJ1dHRvbnMpIHtcbiAgICAgICAgdGhpcy5yZWZyZXNoQnV0dG9uQ29udGVudChncm91cCwgYnV0dG9uT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICB0aGlzLnVwZGF0ZVRvb2xiYXJBcmlhTGFiZWwoZ3JvdXApO1xuICAgIH1cbiAgICB0aGlzLmhhc05ld0xvY2FsZSA9IGZhbHNlO1xuICB9XG4gIHJlZnJlc2hJbm5lckxheW91dChyZWN0KSB7XG4gICAgY29uc3QgeyBlbGVtZW50czogZWxlbWVudHMzLCB2ZXJ0aWNhbFNwYWNpbmcgfSA9IHRoaXM7XG4gICAgY29uc3QgeyBGbG9hdGluZ0JvdHRvbSwgRmxvYXRpbmdUb3AgfSA9IFRvb2xiYXJQb3NpdGlvbjtcbiAgICBlbGVtZW50czMudG9wLnN0eWxlLnRvcCA9IGAke3JlY3QueSAtIGVsZW1lbnRzMy50b3Aub2Zmc2V0SGVpZ2h0IC0gdmVydGljYWxTcGFjaW5nfXB4YDtcbiAgICBlbGVtZW50czMudG9wLnN0eWxlLmxlZnQgPSBgJHtyZWN0Lnh9cHhgO1xuICAgIGVsZW1lbnRzMy50b3Auc3R5bGUud2lkdGggPSBgJHtyZWN0LndpZHRofXB4YDtcbiAgICBlbGVtZW50czMuYm90dG9tLnN0eWxlLmxlZnQgPSBgJHtyZWN0Lnh9cHhgO1xuICAgIGVsZW1lbnRzMy5ib3R0b20uc3R5bGUud2lkdGggPSBgJHtyZWN0LndpZHRofXB4YDtcbiAgICBlbGVtZW50czMucmlnaHQuc3R5bGUudG9wID0gYCR7cmVjdC55fXB4YDtcbiAgICBlbGVtZW50czMucmlnaHQuc3R5bGUucmlnaHQgPSBgMHB4YDtcbiAgICBlbGVtZW50czMucmlnaHQuc3R5bGUuaGVpZ2h0ID0gYCR7cmVjdC5oZWlnaHR9cHhgO1xuICAgIGVsZW1lbnRzMy5sZWZ0LnN0eWxlLnRvcCA9IGAke3JlY3QueX1weGA7XG4gICAgZWxlbWVudHMzLmxlZnQuc3R5bGUubGVmdCA9IGAwcHhgO1xuICAgIGVsZW1lbnRzMy5sZWZ0LnN0eWxlLmhlaWdodCA9IGAke3JlY3QuaGVpZ2h0fXB4YDtcbiAgICBlbGVtZW50czNbRmxvYXRpbmdUb3BdLnN0eWxlLnRvcCA9IGAke3JlY3QueX1weGA7XG4gICAgZWxlbWVudHMzW0Zsb2F0aW5nQm90dG9tXS5zdHlsZS50b3AgPSBgJHtyZWN0LnkgKyByZWN0LmhlaWdodCAtIGVsZW1lbnRzM1tGbG9hdGluZ0JvdHRvbV0ub2Zmc2V0SGVpZ2h0fXB4YDtcbiAgfVxuICByZWZyZXNoQnV0dG9uQ29udGVudChncm91cCwgYnV0dG9uT3B0aW9ucykge1xuICAgIGNvbnN0IGlkID0gdGhpcy5idXR0b25JZChidXR0b25PcHRpb25zKTtcbiAgICBjb25zdCBidXR0b24gPSB0aGlzLmdyb3VwUHJveGllZC5nZXQoZ3JvdXApPy5idXR0b25zPy5maW5kKChiKSA9PiB0aGlzLmJ1dHRvbklkKGIpID09PSBpZCkgPz8gYnV0dG9uT3B0aW9ucztcbiAgICBjb25zdCBlbGVtZW50MiA9IHRoaXMuZ3JvdXBCdXR0b25zW2dyb3VwXS5maW5kKChiKSA9PiBiLmdldEF0dHJpYnV0ZShcImRhdGEtdG9vbGJhci1pZFwiKSA9PT0gaWQpO1xuICAgIGlmIChlbGVtZW50MiA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMudXBkYXRlQnV0dG9uKGVsZW1lbnQyLCBidXR0b24pO1xuICB9XG4gIHRvZ2dsZVZpc2liaWxpdGllcygpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50cyA9PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGlzR3JvdXBWaXNpYmxlID0gKGdyb3VwKSA9PiB0aGlzW2dyb3VwXS5lbmFibGVkICYmIHRoaXMuZ3JvdXBDYWxsZXJzW2dyb3VwXS5zaXplID4gMDtcbiAgICBjb25zdCBpc0J1dHRvblZpc2libGUgPSAoZWxlbWVudDIpID0+IChidXR0b24pID0+IHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy5idXR0b25JZChidXR0b24pO1xuICAgICAgcmV0dXJuIGlkID09IG51bGwgfHwgaWQgPT09IGVsZW1lbnQyLmRhdGFzZXQudG9vbGJhcklkO1xuICAgIH07XG4gICAgZm9yIChjb25zdCBwb3NpdGlvbiBvZiBUT09MQkFSX1BPU0lUSU9OUykge1xuICAgICAgY29uc3QgdmlzaWJsZSA9IHRoaXMuZW5hYmxlZCAmJiBBcnJheS5mcm9tKHRoaXMucG9zaXRpb25zW3Bvc2l0aW9uXS52YWx1ZXMoKSkuc29tZShpc0dyb3VwVmlzaWJsZSk7XG4gICAgICBzZXRWaXNpYmlsaXR5KHRoaXMuZWxlbWVudHNbcG9zaXRpb25dLCBtb2RpZmllcnMyLmhpZGRlbiwgIXZpc2libGUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFRPT0xCQVJfR1JPVVBTKSB7XG4gICAgICBpZiAodGhpc1tncm91cF0gPT0gbnVsbClcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCBncm91cFZpc2libGUgPSBpc0dyb3VwVmlzaWJsZShncm91cCk7XG4gICAgICBmb3IgKGNvbnN0IGJ1dHRvbiBvZiB0aGlzLmdyb3VwQnV0dG9uc1tncm91cF0pIHtcbiAgICAgICAgY29uc3QgYnV0dG9uVmlzaWJsZSA9IGdyb3VwVmlzaWJsZSAmJiB0aGlzW2dyb3VwXS5idXR0b25Db25maWd1cmF0aW9ucygpLnNvbWUoaXNCdXR0b25WaXNpYmxlKGJ1dHRvbikpO1xuICAgICAgICBzZXRWaXNpYmlsaXR5KGJ1dHRvbiwgbW9kaWZpZXJzMi5idXR0b24uaGlkZGVuVmFsdWUsICFidXR0b25WaXNpYmxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdHJhbnNsYXRlRmxvYXRpbmdFbGVtZW50cyhwb3NpdGlvbiwgdmlzaWJsZSkge1xuICAgIGNvbnN0IHsgZWxlbWVudHM6IGVsZW1lbnRzMywgdmVydGljYWxTcGFjaW5nOiB2ZXJ0aWNhbE1hcmdpbiwgcG9zaXRpb25BbGlnbm1lbnRzIH0gPSB0aGlzO1xuICAgIGNvbnN0IGVsZW1lbnQyID0gZWxlbWVudHMzW3Bvc2l0aW9uXTtcbiAgICBjb25zdCBhbGlnbm1lbnRzID0gT2JqZWN0LnZhbHVlcyhwb3NpdGlvbkFsaWdubWVudHNbcG9zaXRpb25dKTtcbiAgICBzZXRWaXNpYmlsaXR5KGVsZW1lbnQyLCBtb2RpZmllcnMyLmZsb2F0aW5nSGlkZGVuLCAhdmlzaWJsZSk7XG4gICAgY29uc3QgZGlyID0gcG9zaXRpb24gPT09IFwiZmxvYXRpbmctYm90dG9tXCIgLyogRmxvYXRpbmdCb3R0b20gKi8gPyAxIDogLTE7XG4gICAgZm9yIChjb25zdCBhbGlnbiBvZiBhbGlnbm1lbnRzKSB7XG4gICAgICBhbGlnbi5zdHlsZS50cmFuc2Zvcm0gPSB2aXNpYmxlICYmIGFsaWduLnN0eWxlLnRyYW5zZm9ybSAhPT0gXCJcIiA/IFwidHJhbnNsYXRlWSgwKVwiIDogYHRyYW5zbGF0ZVkoJHsoZWxlbWVudDIub2Zmc2V0SGVpZ2h0ICsgdmVydGljYWxNYXJnaW4pICogZGlyfXB4KWA7XG4gICAgfVxuICB9XG4gIHJlbmRlclRvb2xiYXIocG9zaXRpb24gPSBcInRvcFwiIC8qIFRvcCAqLykge1xuICAgIGNvbnN0IGVsZW1lbnQyID0gdGhpcy5lbGVtZW50c1twb3NpdGlvbl07XG4gICAgZWxlbWVudDIuY2xhc3NMaXN0LmFkZChibG9jazIsIG1vZGlmaWVyczJbcG9zaXRpb25dLCBtb2RpZmllcnMyLnByZXZlbnRGbGFzaCk7XG4gICAgaWYgKGlzQW5pbWF0aW5nRmxvYXRpbmdQb3NpdGlvbihwb3NpdGlvbikpIHtcbiAgICAgIGVsZW1lbnQyLmNsYXNzTGlzdC5hZGQobW9kaWZpZXJzMi5mbG9hdGluZ0hpZGRlbik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgYWxpZ24gb2YgVE9PTEJBUl9BTElHTk1FTlRTKSB7XG4gICAgICBjb25zdCBhbGlnbm1lbnRFbGVtZW50ID0gY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGFsaWdubWVudEVsZW1lbnQucm9sZSA9IFwicHJlc2VudGF0aW9uXCI7XG4gICAgICBhbGlnbm1lbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoZWxlbWVudHMyLmFsaWduLCBtb2RpZmllcnMyLmFsaWduW2FsaWduXSk7XG4gICAgICBhbGlnbm1lbnRFbGVtZW50LmRhdGFzZXQucG9pbnRlckNhcHR1cmUgPSBcImV4Y2x1c2l2ZVwiO1xuICAgICAgZWxlbWVudDIuYXBwZW5kQ2hpbGQoYWxpZ25tZW50RWxlbWVudCk7XG4gICAgICB0aGlzLnBvc2l0aW9uQWxpZ25tZW50c1twb3NpdGlvbl1bYWxpZ25dID0gYWxpZ25tZW50RWxlbWVudDtcbiAgICB9XG4gIH1cbiAgY3JlYXRlQnV0dG9uRWxlbWVudChncm91cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJ1dHRvbiA9IGNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoZWxlbWVudHMyLmJ1dHRvbik7XG4gICAgYnV0dG9uLmRhdGFzZXQudG9vbGJhckdyb3VwID0gZ3JvdXA7XG4gICAgYnV0dG9uLnRhYkluZGV4ID0gLTE7XG4gICAgYnV0dG9uLmRhdGFzZXQudG9vbGJhcklkID0gdGhpcy5idXR0b25JZChvcHRpb25zKTtcbiAgICBidXR0b24ub25jbGljayA9IG1ha2VBY2Nlc3NpYmxlQ2xpY2tMaXN0ZW5lcihcbiAgICAgIGJ1dHRvbixcbiAgICAgIHRoaXMub25CdXR0b25QcmVzcy5iaW5kKHRoaXMsIGJ1dHRvbiwgZ3JvdXAsIG9wdGlvbnMuaWQsIG9wdGlvbnMudmFsdWUpXG4gICAgKTtcbiAgICB0aGlzLnVwZGF0ZUJ1dHRvbihidXR0b24sIG9wdGlvbnMpO1xuICAgIHRoaXMuZGVzdHJveUZucy5wdXNoKCgpID0+IGJ1dHRvbi5yZW1vdmUoKSk7XG4gICAgcmV0dXJuIGJ1dHRvbjtcbiAgfVxuICBnZXRBcmlhVG9vbGJhcihncm91cCkge1xuICAgIGZvciAoY29uc3QgYXJpYVRvb2xiYXIgb2YgdGhpcy5hcmlhVG9vbGJhcnMpIHtcbiAgICAgIGlmIChhcmlhVG9vbGJhci5ncm91cHMuaW5jbHVkZXMoZ3JvdXApKSB7XG4gICAgICAgIHJldHVybiBhcmlhVG9vbGJhcjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydHMgLSBjYW5ub3QgZmluZCBhcmlhLXRvb2xiYXIgb2YgJyR7Z3JvdXB9J2ApO1xuICB9XG4gIHVwZGF0ZVRvb2xiYXJBcmlhTGFiZWwoZ3JvdXAsIGFsaWduRWxlbWVudCkge1xuICAgIGlmICghYWxpZ25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7IGFsaWduLCBwb3NpdGlvbiB9ID0gdGhpc1tncm91cF07XG4gICAgICBhbGlnbkVsZW1lbnQgPSB0aGlzLnBvc2l0aW9uQWxpZ25tZW50c1twb3NpdGlvbl1bYWxpZ25dO1xuICAgICAgaWYgKCFhbGlnbkVsZW1lbnQpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWFwID0ge1xuICAgICAgc2VyaWVzVHlwZTogXCJhcmlhTGFiZWxGaW5hbmNpYWxDaGFydHNcIixcbiAgICAgIGFubm90YXRpb25zOiBcImFyaWFMYWJlbEZpbmFuY2lhbENoYXJ0c1wiLFxuICAgICAgYW5ub3RhdGlvbk9wdGlvbnM6IFwiYXJpYUxhYmVsQW5ub3RhdGlvbk9wdGlvbnNUb29sYmFyXCIsXG4gICAgICByYW5nZXM6IFwiYXJpYUxhYmVsUmFuZ2VzVG9vbGJhclwiLFxuICAgICAgem9vbTogXCJhcmlhTGFiZWxab29tVG9vbGJhclwiXG4gICAgfTtcbiAgICBhbGlnbkVsZW1lbnQuYXJpYUxhYmVsID0gdGhpcy5jdHgubG9jYWxlTWFuYWdlci50KG1hcFtncm91cF0pO1xuICB9XG4gIHVwZGF0ZUJ1dHRvbihidXR0b24sIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdHg6IHsgZG9tTWFuYWdlciwgbG9jYWxlTWFuYWdlciB9XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKG9wdGlvbnMudG9vbHRpcCkge1xuICAgICAgY29uc3QgdG9vbHRpcCA9IGxvY2FsZU1hbmFnZXIudChvcHRpb25zLnRvb2x0aXApO1xuICAgICAgYnV0dG9uLnRpdGxlID0gdG9vbHRpcDtcbiAgICB9XG4gICAgbGV0IGlubmVyID0gXCJcIjtcbiAgICBpZiAob3B0aW9ucy5pY29uICE9IG51bGwpIHtcbiAgICAgIGlubmVyID0gYDxzcGFuIGNsYXNzPVwiJHtkb21NYW5hZ2VyLmdldEljb25DbGFzc05hbWVzKG9wdGlvbnMuaWNvbil9ICR7ZWxlbWVudHMyLmljb259XCI+PC9zcGFuPmA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmxhYmVsICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGxhYmVsID0gbG9jYWxlTWFuYWdlci50KG9wdGlvbnMubGFiZWwpO1xuICAgICAgaW5uZXIgPSBgJHtpbm5lcn08c3BhbiBjbGFzcz1cIiR7ZWxlbWVudHMyLmxhYmVsfVwiPiR7bGFiZWx9PC9zcGFuPmA7XG4gICAgfVxuICAgIGJ1dHRvbi5pbm5lckhUTUwgPSBpbm5lcjtcbiAgICBidXR0b24uY2xhc3NMaXN0LnRvZ2dsZShtb2RpZmllcnMyLmJ1dHRvbi5maWxsVmlzaWJsZSwgb3B0aW9ucy5maWxsICE9IG51bGwpO1xuICAgIGJ1dHRvbi5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tZmlsbFwiLCBvcHRpb25zLmZpbGwgPz8gbnVsbCk7XG4gICAgY29uc3QgYXJpYUxhYmVsID0gb3B0aW9ucy5hcmlhTGFiZWwgPyB0aGlzLmN0eC5sb2NhbGVNYW5hZ2VyLnQob3B0aW9ucy5hcmlhTGFiZWwpIDogdm9pZCAwO1xuICAgIHNldEF0dHJpYnV0ZShidXR0b24sIFwiYXJpYS1sYWJlbFwiLCBhcmlhTGFiZWwpO1xuICB9XG4gIG9uQnV0dG9uUHJlc3MoYnV0dG9uLCBncm91cCwgaWQsIHZhbHVlKSB7XG4gICAgdGhpcy5jdHgudG9vbGJhck1hbmFnZXIucHJlc3NCdXR0b24oZ3JvdXAsIHRoaXMuYnV0dG9uSWQoeyBpZCwgdmFsdWUgfSksIHZhbHVlLCB0aGlzLmJ1dHRvblJlY3QoYnV0dG9uKSk7XG4gIH1cbiAgYnV0dG9uSWQoYnV0dG9uKSB7XG4gICAgY29uc3QgeyBpZCwgdmFsdWUsIGxhYmVsIH0gPSBidXR0b247XG4gICAgaWYgKGlkICE9IG51bGwpXG4gICAgICByZXR1cm4gaWQ7XG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKVxuICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgcmV0dXJuIGxhYmVsID8/IFwiXCI7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBPYnNlcnZlQ2hhbmdlcygodGFyZ2V0KSA9PiB7XG4gICAgdGFyZ2V0LnByb2Nlc3NQZW5kaW5nRXZlbnRzKCk7XG4gICAgdGFyZ2V0LnRvZ2dsZVZpc2liaWxpdGllcygpO1xuICB9KSxcbiAgVmFsaWRhdGUoQk9PTEVBTilcbl0sIFRvb2xiYXIucHJvdG90eXBlLCBcImVuYWJsZWRcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3Rvb2xiYXIvdG9vbGJhck1vZHVsZS50c1xudmFyIERBWSA9IDFlMyAqIDYwICogNjAgKiAyNDtcbnZhciBNT05USCA9IERBWSAqIDMwO1xudmFyIFlFQVIgPSBEQVkgKiAzNjU7XG52YXIgc2VyaWVzVHlwZSA9IHtcbiAgZW5hYmxlZDogZmFsc2UsXG4gIHBvc2l0aW9uOiBcImxlZnRcIixcbiAgYWxpZ246IFwic3RhcnRcIixcbiAgYnV0dG9uczogW1xuICAgIHtcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhclNlcmllc1R5cGVEcm9wZG93blwiLFxuICAgICAgdmFsdWU6IFwidHlwZVwiXG4gICAgfVxuICBdXG59O1xudmFyIGFubm90YXRpb25zID0ge1xuICBlbmFibGVkOiB0cnVlLFxuICBwb3NpdGlvbjogXCJsZWZ0XCIsXG4gIGFsaWduOiBcInN0YXJ0XCIsXG4gIGJ1dHRvbnM6IFtcbiAgICB7XG4gICAgICBpY29uOiBcInRyZW5kLWxpbmUtZHJhd2luZ1wiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNMaW5lQW5ub3RhdGlvbnNcIixcbiAgICAgIHZhbHVlOiBcImxpbmUtbWVudVwiLFxuICAgICAgc2VjdGlvbjogXCJsaW5lLWFubm90YXRpb25zXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGljb246IFwidGV4dC1hbm5vdGF0aW9uXCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc1RleHRBbm5vdGF0aW9uc1wiLFxuICAgICAgdmFsdWU6IFwidGV4dC1tZW51XCIsXG4gICAgICBzZWN0aW9uOiBcInRleHQtYW5ub3RhdGlvbnNcIlxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogXCJkZWxldGVcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhckFubm90YXRpb25zQ2xlYXJBbGxcIixcbiAgICAgIHZhbHVlOiBcImNsZWFyXCIsXG4gICAgICBzZWN0aW9uOiBcInRvb2xzXCJcbiAgICB9XG4gIF1cbn07XG52YXIgYW5ub3RhdGlvbk9wdGlvbnMgPSB7XG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBvc2l0aW9uOiBcImZsb2F0aW5nXCIsXG4gIGFsaWduOiBcInN0YXJ0XCIsXG4gIGJ1dHRvbnM6IFtcbiAgICB7XG4gICAgICBpY29uOiBcInRleHQtYW5ub3RhdGlvblwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyQW5ub3RhdGlvbnNUZXh0Q29sb3JcIixcbiAgICAgIHZhbHVlOiBcInRleHQtY29sb3JcIlxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogXCJsaW5lLWNvbG9yXCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc0xpbmVDb2xvclwiLFxuICAgICAgdmFsdWU6IFwibGluZS1jb2xvclwiXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcImZpbGwtY29sb3JcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhckFubm90YXRpb25zRmlsbENvbG9yXCIsXG4gICAgICB2YWx1ZTogXCJmaWxsLWNvbG9yXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhckFubm90YXRpb25zVGV4dFNpemVcIixcbiAgICAgIHZhbHVlOiBcInRleHQtc2l6ZVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcInVubG9ja2VkXCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJBbm5vdGF0aW9uc0xvY2tcIixcbiAgICAgIHZhbHVlOiBcImxvY2tcIlxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogXCJsb2NrZWRcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhckFubm90YXRpb25zVW5sb2NrXCIsXG4gICAgICB2YWx1ZTogXCJ1bmxvY2tcIlxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogXCJkZWxldGVcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhckFubm90YXRpb25zRGVsZXRlXCIsXG4gICAgICB2YWx1ZTogXCJkZWxldGVcIlxuICAgIH1cbiAgXVxufTtcbnZhciByYW5nZXMgPSB7XG4gIGVuYWJsZWQ6IGZhbHNlLFxuICBwb3NpdGlvbjogREVGQVVMVF9UT09MQkFSX1BPU0lUSU9OLFxuICBhbGlnbjogXCJzdGFydFwiLFxuICBidXR0b25zOiBbXG4gICAge1xuICAgICAgbGFiZWw6IFwidG9vbGJhclJhbmdlMU1vbnRoXCIsXG4gICAgICBhcmlhTGFiZWw6IFwidG9vbGJhclJhbmdlMU1vbnRoQXJpYVwiLFxuICAgICAgdmFsdWU6IE1PTlRIXG4gICAgfSxcbiAgICB7XG4gICAgICBsYWJlbDogXCJ0b29sYmFyUmFuZ2UzTW9udGhzXCIsXG4gICAgICBhcmlhTGFiZWw6IFwidG9vbGJhclJhbmdlM01vbnRoc0FyaWFcIixcbiAgICAgIHZhbHVlOiAzICogTU9OVEhcbiAgICB9LFxuICAgIHtcbiAgICAgIGxhYmVsOiBcInRvb2xiYXJSYW5nZTZNb250aHNcIixcbiAgICAgIGFyaWFMYWJlbDogXCJ0b29sYmFyUmFuZ2U2TW9udGhzQXJpYVwiLFxuICAgICAgdmFsdWU6IDYgKiBNT05USFxuICAgIH0sXG4gICAge1xuICAgICAgbGFiZWw6IFwidG9vbGJhclJhbmdlWWVhclRvRGF0ZVwiLFxuICAgICAgYXJpYUxhYmVsOiBcInRvb2xiYXJSYW5nZVllYXJUb0RhdGVBcmlhXCIsXG4gICAgICB2YWx1ZTogKF9zdGFydCwgZW5kKSA9PiBbKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZShgJHtuZXcgRGF0ZShlbmQpLmdldEZ1bGxZZWFyKCl9LTAxLTAxYCkpLmdldFRpbWUoKSwgZW5kXSxcbiAgICAgIGlkOiBcInllYXItdG8tZGF0ZVwiXG4gICAgfSxcbiAgICB7XG4gICAgICBsYWJlbDogXCJ0b29sYmFyUmFuZ2UxWWVhclwiLFxuICAgICAgYXJpYUxhYmVsOiBcInRvb2xiYXJSYW5nZTFZZWFyQXJpYVwiLFxuICAgICAgdmFsdWU6IFlFQVJcbiAgICB9LFxuICAgIHtcbiAgICAgIGxhYmVsOiBcInRvb2xiYXJSYW5nZUFsbFwiLFxuICAgICAgYXJpYUxhYmVsOiBcInRvb2xiYXJSYW5nZUFsbEFyaWFcIixcbiAgICAgIHZhbHVlOiAoc3RhcnQsIGVuZCkgPT4gW3N0YXJ0LCBlbmRdLFxuICAgICAgaWQ6IFwiYWxsXCJcbiAgICB9XG4gIF1cbn07XG52YXIgem9vbSA9IHtcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcG9zaXRpb246IFwidG9wXCIsXG4gIGFsaWduOiBcImVuZFwiLFxuICBidXR0b25zOiBbXG4gICAge1xuICAgICAgaWNvbjogXCJ6b29tLW91dFwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyWm9vbVpvb21PdXRcIixcbiAgICAgIHZhbHVlOiBcInpvb20tb3V0XCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGljb246IFwiem9vbS1pblwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyWm9vbVpvb21JblwiLFxuICAgICAgdmFsdWU6IFwiem9vbS1pblwiXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcInBhbi1sZWZ0XCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJab29tUGFuTGVmdFwiLFxuICAgICAgdmFsdWU6IFwicGFuLWxlZnRcIlxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogXCJwYW4tcmlnaHRcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhclpvb21QYW5SaWdodFwiLFxuICAgICAgdmFsdWU6IFwicGFuLXJpZ2h0XCJcbiAgICB9LFxuICAgIHtcbiAgICAgIGljb246IFwicGFuLXN0YXJ0XCIsXG4gICAgICB0b29sdGlwOiBcInRvb2xiYXJab29tUGFuU3RhcnRcIixcbiAgICAgIHZhbHVlOiBcInBhbi1zdGFydFwiXG4gICAgfSxcbiAgICB7XG4gICAgICBpY29uOiBcInBhbi1lbmRcIixcbiAgICAgIHRvb2x0aXA6IFwidG9vbGJhclpvb21QYW5FbmRcIixcbiAgICAgIHZhbHVlOiBcInBhbi1lbmRcIlxuICAgIH0sXG4gICAge1xuICAgICAgaWNvbjogXCJyZXNldFwiLFxuICAgICAgdG9vbHRpcDogXCJ0b29sYmFyWm9vbVJlc2V0XCIsXG4gICAgICB2YWx1ZTogXCJyZXNldFwiXG4gICAgfVxuICBdXG59O1xudmFyIFRvb2xiYXJNb2R1bGUgPSB7XG4gIHR5cGU6IFwicm9vdFwiLFxuICBvcHRpb25zS2V5OiBcInRvb2xiYXJcIixcbiAgcGFja2FnZVR5cGU6IFwiY29tbXVuaXR5XCIsXG4gIGNoYXJ0VHlwZXM6IFtcImNhcnRlc2lhblwiXSxcbiAgbW9kdWxlRmFjdG9yeTogKGN0eCkgPT4gbmV3IFRvb2xiYXIoY3R4KSxcbiAgdGhlbWVUZW1wbGF0ZToge1xuICAgIHRvb2xiYXI6IHtcbiAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICBzZXJpZXNUeXBlLFxuICAgICAgYW5ub3RhdGlvbnMsXG4gICAgICBhbm5vdGF0aW9uT3B0aW9ucyxcbiAgICAgIHJhbmdlcyxcbiAgICAgIHpvb21cbiAgICB9XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2ZhY3RvcnkvcmVnaXN0ZXJJbmJ1aWx0TW9kdWxlcy50c1xuZnVuY3Rpb24gcmVnaXN0ZXJJbmJ1aWx0TW9kdWxlcygpIHtcbiAgbW9kdWxlUmVnaXN0cnkucmVnaXN0ZXIoXG4gICAgQmFja2dyb3VuZE1vZHVsZSxcbiAgICBDb21tdW5pdHlMZWdlbmRNb2R1bGUsXG4gICAgTG9jYWxlTW9kdWxlLFxuICAgIE5hdmlnYXRvck1vZHVsZSxcbiAgICBUb29sYmFyTW9kdWxlLFxuICAgIEFyZWFTZXJpZXNNb2R1bGUsXG4gICAgQmFyU2VyaWVzTW9kdWxlLFxuICAgIEJ1YmJsZVNlcmllc01vZHVsZSxcbiAgICBMaW5lU2VyaWVzTW9kdWxlLFxuICAgIFNjYXR0ZXJTZXJpZXNNb2R1bGUsXG4gICAgRG9udXRTZXJpZXNNb2R1bGUsXG4gICAgUGllU2VyaWVzTW9kdWxlLFxuICAgIEhpc3RvZ3JhbVNlcmllc01vZHVsZVxuICApO1xuICBmb3IgKGNvbnN0IEF4aXNDb25zdHJ1Y3RvciBvZiBbTnVtYmVyQXhpcywgQ2F0ZWdvcnlBeGlzLCBUaW1lQXhpcywgR3JvdXBlZENhdGVnb3J5QXhpcywgTG9nQXhpc10pIHtcbiAgICBheGlzUmVnaXN0cnkucmVnaXN0ZXIoQXhpc0NvbnN0cnVjdG9yLnR5cGUsIHtcbiAgICAgIG1vZHVsZUZhY3Rvcnk6IChjdHgpID0+IG5ldyBBeGlzQ29uc3RydWN0b3IoY3R4KSxcbiAgICAgIGhpZGRlbjogQXhpc0NvbnN0cnVjdG9yID09PSBHcm91cGVkQ2F0ZWdvcnlBeGlzXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZmFjdG9yeS9zZXR1cE1vZHVsZXMudHNcbmZ1bmN0aW9uIHNldHVwTW9kdWxlcygpIHtcbiAgZm9yIChjb25zdCBtIG9mIG1vZHVsZVJlZ2lzdHJ5Lm1vZHVsZXMpIHtcbiAgICBpZiAobS5wYWNrYWdlVHlwZSA9PT0gXCJlbnRlcnByaXNlXCIgJiYgIXZlcmlmeUlmTW9kdWxlRXhwZWN0ZWQobSkpIHtcbiAgICAgIExvZ2dlci5lcnJvck9uY2UoXCJVbmV4cGVjdGVkIGVudGVycHJpc2UgbW9kdWxlIHJlZ2lzdGVyZWQ6IFwiICsgbS5pZGVudGlmaWVyKTtcbiAgICB9XG4gICAgaWYgKG0udHlwZSA9PT0gXCJyb290XCIgJiYgbS50aGVtZVRlbXBsYXRlKSB7XG4gICAgICBmb3IgKGNvbnN0IGNoYXJ0VHlwZTIgb2YgbS5jaGFydFR5cGVzKSB7XG4gICAgICAgIGNoYXJ0RGVmYXVsdHMuc2V0KGNoYXJ0VHlwZTIsIG0udGhlbWVUZW1wbGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtLnR5cGUgPT09IFwic2VyaWVzXCIpIHtcbiAgICAgIGlmIChtLmNoYXJ0VHlwZXMubGVuZ3RoID4gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFHIENoYXJ0cyAtIE1vZHVsZSBkZWZpbml0aW9uIGVycm9yOiAke20uaWRlbnRpZmllcn1gKTtcbiAgICAgIH1cbiAgICAgIHNlcmllc1JlZ2lzdHJ5LnJlZ2lzdGVyKG0uaWRlbnRpZmllciwgbSk7XG4gICAgfVxuICAgIGlmIChtLnR5cGUgPT09IFwic2VyaWVzLW9wdGlvblwiICYmIG0udGhlbWVUZW1wbGF0ZSkge1xuICAgICAgZm9yIChjb25zdCBzZXJpZXNUeXBlMiBvZiBtLnNlcmllc1R5cGVzKSB7XG4gICAgICAgIHNlcmllc1JlZ2lzdHJ5LnNldFRoZW1lVGVtcGxhdGUoc2VyaWVzVHlwZTIsIG0udGhlbWVUZW1wbGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtLnR5cGUgPT09IFwiYXhpcy1vcHRpb25cIiAmJiBtLnRoZW1lVGVtcGxhdGUpIHtcbiAgICAgIGZvciAoY29uc3QgYXhpc1R5cGUgb2YgbS5heGlzVHlwZXMpIHtcbiAgICAgICAgY29uc3QgYXhpc1R5cGVUaGVtZSA9IGF4aXNSZWdpc3RyeS5nZXRUaGVtZVRlbXBsYXRlKGF4aXNUeXBlKTtcbiAgICAgICAgY29uc3QgdGhlbWUgPSBtZXJnZURlZmF1bHRzKG0udGhlbWVUZW1wbGF0ZSwgYXhpc1R5cGVUaGVtZSk7XG4gICAgICAgIGF4aXNSZWdpc3RyeS5zZXRUaGVtZVRlbXBsYXRlKGF4aXNUeXBlLCB0aGVtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtLnR5cGUgPT09IFwiYXhpc1wiKSB7XG4gICAgICBheGlzUmVnaXN0cnkucmVnaXN0ZXIobS5pZGVudGlmaWVyLCBtKTtcbiAgICB9XG4gICAgaWYgKG0udHlwZSA9PT0gXCJsZWdlbmRcIikge1xuICAgICAgbGVnZW5kUmVnaXN0cnkucmVnaXN0ZXIobS5pZGVudGlmaWVyLCBtKTtcbiAgICB9XG4gIH1cbiAgaWYgKG1vZHVsZVJlZ2lzdHJ5Lmhhc0VudGVycHJpc2VNb2R1bGVzKCkpIHtcbiAgICBjb25zdCBleHBlY3RlZEJ1dFVudXNlZCA9IGdldFVudXNlZEV4cGVjdGVkTW9kdWxlcygpO1xuICAgIGlmIChleHBlY3RlZEJ1dFVudXNlZC5sZW5ndGggPiAwKSB7XG4gICAgICBMb2dnZXIuZXJyb3JPbmNlKFwiRW50ZXJwcmlzZSBtb2R1bGVzIGV4cGVjdGVkIGJ1dCBub3QgcmVnaXN0ZXJlZDogXCIsIGV4cGVjdGVkQnV0VW51c2VkKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZmxvd1Byb3BvcnRpb25DaGFydC50c1xuZnVuY3Rpb24gaXNGbG93UHJvcG9ydGlvbihzZXJpZXMpIHtcbiAgcmV0dXJuIHNlcmllcy50eXBlID09PSBcInNhbmtleVwiIHx8IHNlcmllcy50eXBlID09PSBcImNob3JkXCI7XG59XG52YXIgRmxvd1Byb3BvcnRpb25DaGFydCA9IGNsYXNzIGV4dGVuZHMgQ2hhcnQge1xuICBnZXRDaGFydFR5cGUoKSB7XG4gICAgcmV0dXJuIFwiZmxvdy1wcm9wb3J0aW9uXCI7XG4gIH1cbiAgYXN5bmMgdXBkYXRlRGF0YSgpIHtcbiAgICBhd2FpdCBzdXBlci51cGRhdGVEYXRhKCk7XG4gICAgY29uc3QgeyBub2RlcyB9ID0gdGhpcy5nZXRPcHRpb25zKCk7XG4gICAgdGhpcy5zZXJpZXMuZm9yRWFjaCgoc2VyaWVzKSA9PiB7XG4gICAgICBpZiAoaXNGbG93UHJvcG9ydGlvbihzZXJpZXMpKSB7XG4gICAgICAgIHNlcmllcy5zZXRDaGFydE5vZGVzKG5vZGVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhc3luYyBwZXJmb3JtTGF5b3V0KCkge1xuICAgIGNvbnN0IHNocmlua1JlY3QgPSBhd2FpdCBzdXBlci5wZXJmb3JtTGF5b3V0KCk7XG4gICAgY29uc3Qge1xuICAgICAgc2VyaWVzQXJlYTogeyBwYWRkaW5nIH0sXG4gICAgICBzZXJpZXNSb290LFxuICAgICAgYW5ub3RhdGlvblJvb3QsXG4gICAgICBoaWdobGlnaHRSb290XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgZnVsbFNlcmllc1JlY3QgPSBzaHJpbmtSZWN0LmNsb25lKCk7XG4gICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy5sZWZ0LCBcImxlZnRcIik7XG4gICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy50b3AsIFwidG9wXCIpO1xuICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcucmlnaHQsIFwicmlnaHRcIik7XG4gICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy5ib3R0b20sIFwiYm90dG9tXCIpO1xuICAgIHRoaXMuc2VyaWVzUmVjdCA9IHNocmlua1JlY3Q7XG4gICAgdGhpcy5hbmltYXRpb25SZWN0ID0gc2hyaW5rUmVjdDtcbiAgICBjb25zdCBzZXJpZXNWaXNpYmxlID0gdGhpcy5zZXJpZXMuc29tZSgocykgPT4gcy52aXNpYmxlKTtcbiAgICBzZXJpZXNSb290LnZpc2libGUgPSBzZXJpZXNWaXNpYmxlO1xuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgW3Nlcmllc1Jvb3QsIGFubm90YXRpb25Sb290LCBoaWdobGlnaHRSb290XSkge1xuICAgICAgZ3JvdXAudHJhbnNsYXRpb25YID0gTWF0aC5mbG9vcihzaHJpbmtSZWN0LngpO1xuICAgICAgZ3JvdXAudHJhbnNsYXRpb25ZID0gTWF0aC5mbG9vcihzaHJpbmtSZWN0LnkpO1xuICAgICAgZ3JvdXAuc2V0Q2xpcFJlY3RJbkdyb3VwQ29vcmRpbmF0ZVNwYWNlKFxuICAgICAgICBuZXcgQkJveChmdWxsU2VyaWVzUmVjdC54LCBmdWxsU2VyaWVzUmVjdC55LCBmdWxsU2VyaWVzUmVjdC53aWR0aCwgZnVsbFNlcmllc1JlY3QuaGVpZ2h0KVxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5jdHgubGF5b3V0U2VydmljZS5kaXNwYXRjaExheW91dENvbXBsZXRlKHtcbiAgICAgIHR5cGU6IFwibGF5b3V0LWNvbXBsZXRlXCIsXG4gICAgICBjaGFydDogeyB3aWR0aDogdGhpcy5jdHguc2NlbmUud2lkdGgsIGhlaWdodDogdGhpcy5jdHguc2NlbmUuaGVpZ2h0IH0sXG4gICAgICBjbGlwU2VyaWVzOiBmYWxzZSxcbiAgICAgIHNlcmllczogeyByZWN0OiBmdWxsU2VyaWVzUmVjdCwgcGFkZGVkUmVjdDogc2hyaW5rUmVjdCwgdmlzaWJsZTogc2VyaWVzVmlzaWJsZSB9LFxuICAgICAgYXhlczogW11cbiAgICB9KTtcbiAgICByZXR1cm4gc2hyaW5rUmVjdDtcbiAgfVxufTtcbkZsb3dQcm9wb3J0aW9uQ2hhcnQuY2xhc3NOYW1lID0gXCJGbG93UHJvcG9ydGlvbkNoYXJ0XCI7XG5GbG93UHJvcG9ydGlvbkNoYXJ0LnR5cGUgPSBcImZsb3ctcHJvcG9ydGlvblwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9oaWVyYXJjaHlDaGFydC50c1xudmFyIEhpZXJhcmNoeUNoYXJ0ID0gY2xhc3MgZXh0ZW5kcyBDaGFydCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHJlc291cmNlcykge1xuICAgIHN1cGVyKG9wdGlvbnMsIHJlc291cmNlcyk7XG4gIH1cbiAgZ2V0Q2hhcnRUeXBlKCkge1xuICAgIHJldHVybiBcImhpZXJhcmNoeVwiO1xuICB9XG4gIGFzeW5jIHBlcmZvcm1MYXlvdXQoKSB7XG4gICAgY29uc3Qgc2hyaW5rUmVjdCA9IGF3YWl0IHN1cGVyLnBlcmZvcm1MYXlvdXQoKTtcbiAgICBjb25zdCB7XG4gICAgICBzZXJpZXNBcmVhOiB7IHBhZGRpbmcgfSxcbiAgICAgIHNlcmllc1Jvb3QsXG4gICAgICBhbm5vdGF0aW9uUm9vdCxcbiAgICAgIGhpZ2hsaWdodFJvb3RcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBmdWxsU2VyaWVzUmVjdCA9IHNocmlua1JlY3QuY2xvbmUoKTtcbiAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLmxlZnQsIFwibGVmdFwiKTtcbiAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLnRvcCwgXCJ0b3BcIik7XG4gICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy5yaWdodCwgXCJyaWdodFwiKTtcbiAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLmJvdHRvbSwgXCJib3R0b21cIik7XG4gICAgdGhpcy5zZXJpZXNSZWN0ID0gc2hyaW5rUmVjdDtcbiAgICB0aGlzLmFuaW1hdGlvblJlY3QgPSBzaHJpbmtSZWN0O1xuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgW3Nlcmllc1Jvb3QsIGFubm90YXRpb25Sb290LCBoaWdobGlnaHRSb290XSkge1xuICAgICAgZ3JvdXAudHJhbnNsYXRpb25YID0gTWF0aC5mbG9vcihzaHJpbmtSZWN0LngpO1xuICAgICAgZ3JvdXAudHJhbnNsYXRpb25ZID0gTWF0aC5mbG9vcihzaHJpbmtSZWN0LnkpO1xuICAgIH1cbiAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIHRoaXMuc2VyaWVzLm1hcChhc3luYyAoc2VyaWVzKSA9PiB7XG4gICAgICAgIGF3YWl0IHNlcmllcy51cGRhdGUoeyBzZXJpZXNSZWN0OiBzaHJpbmtSZWN0IH0pO1xuICAgICAgfSlcbiAgICApO1xuICAgIHNlcmllc1Jvb3QudmlzaWJsZSA9IHRoaXMuc2VyaWVzWzBdLnZpc2libGU7XG4gICAgc2VyaWVzUm9vdC5zZXRDbGlwUmVjdEluR3JvdXBDb29yZGluYXRlU3BhY2UoXG4gICAgICBuZXcgQkJveChzaHJpbmtSZWN0LngsIHNocmlua1JlY3QueSwgc2hyaW5rUmVjdC53aWR0aCwgc2hyaW5rUmVjdC5oZWlnaHQpXG4gICAgKTtcbiAgICB0aGlzLmN0eC5sYXlvdXRTZXJ2aWNlLmRpc3BhdGNoTGF5b3V0Q29tcGxldGUoe1xuICAgICAgdHlwZTogXCJsYXlvdXQtY29tcGxldGVcIixcbiAgICAgIGNoYXJ0OiB7IHdpZHRoOiB0aGlzLmN0eC5zY2VuZS53aWR0aCwgaGVpZ2h0OiB0aGlzLmN0eC5zY2VuZS5oZWlnaHQgfSxcbiAgICAgIGNsaXBTZXJpZXM6IGZhbHNlLFxuICAgICAgc2VyaWVzOiB7IHJlY3Q6IGZ1bGxTZXJpZXNSZWN0LCBwYWRkZWRSZWN0OiBzaHJpbmtSZWN0LCB2aXNpYmxlOiB0cnVlIH0sXG4gICAgICBheGVzOiBbXVxuICAgIH0pO1xuICAgIHJldHVybiBzaHJpbmtSZWN0O1xuICB9XG4gIGdldEFyaWFMYWJlbCgpIHtcbiAgICBjb25zdCBjYXB0aW9uVGV4dCA9IHRoaXMuZ2V0Q2FwdGlvblRleHQoKTtcbiAgICByZXR1cm4gYGhpZXJhcmNoaWNhbCBjaGFydCwgJHtjYXB0aW9uVGV4dH1gO1xuICB9XG59O1xuSGllcmFyY2h5Q2hhcnQuY2xhc3NOYW1lID0gXCJIaWVyYXJjaHlDaGFydFwiO1xuSGllcmFyY2h5Q2hhcnQudHlwZSA9IFwiaGllcmFyY2h5XCI7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L2F4aXMvcG9sYXJBeGlzLnRzXG52YXIgUG9sYXJBeGlzID0gY2xhc3MgZXh0ZW5kcyBBeGlzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnNoYXBlID0gXCJwb2x5Z29uXCI7XG4gICAgdGhpcy5pbm5lclJhZGl1c1JhdGlvID0gMDtcbiAgICB0aGlzLmRlZmF1bHRUaWNrTWluU3BhY2luZyA9IDIwO1xuICB9XG4gIGNvbXB1dGVMYWJlbHNCQm94KF9vcHRpb25zLCBfc2VyaWVzUmVjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoVU5JT04oW1wicG9seWdvblwiLCBcImNpcmNsZVwiXSwgXCJhIHBvbGFyIGF4aXMgc2hhcGVcIikpXG5dLCBQb2xhckF4aXMucHJvdG90eXBlLCBcInNoYXBlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoUkFUSU8pXG5dLCBQb2xhckF4aXMucHJvdG90eXBlLCBcImlubmVyUmFkaXVzUmF0aW9cIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3BvbGFyQ2hhcnQudHNcbnZhciBQb2xhckNoYXJ0ID0gY2xhc3MgZXh0ZW5kcyBDaGFydCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIHJlc291cmNlcykge1xuICAgIHN1cGVyKG9wdGlvbnMsIHJlc291cmNlcyk7XG4gICAgdGhpcy5wYWRkaW5nID0gbmV3IFBhZGRpbmcoNDApO1xuICAgIHRoaXMuY3R4LmF4aXNNYW5hZ2VyLmF4aXNHcm91cC56SW5kZXggPSA2IC8qIEFYSVNfRk9SRUdST1VORF9aSU5ERVggKi87XG4gIH1cbiAgZ2V0Q2hhcnRUeXBlKCkge1xuICAgIHJldHVybiBcInBvbGFyXCI7XG4gIH1cbiAgYXN5bmMgcGVyZm9ybUxheW91dCgpIHtcbiAgICBjb25zdCBzaHJpbmtSZWN0ID0gYXdhaXQgc3VwZXIucGVyZm9ybUxheW91dCgpO1xuICAgIGNvbnN0IGZ1bGxTZXJpZXNSZWN0ID0gc2hyaW5rUmVjdC5jbG9uZSgpO1xuICAgIHRoaXMuY29tcHV0ZVNlcmllc1JlY3Qoc2hyaW5rUmVjdCk7XG4gICAgYXdhaXQgdGhpcy5jb21wdXRlQ2lyY2xlKHNocmlua1JlY3QpO1xuICAgIHRoaXMuYXhlcy5mb3JFYWNoKChheGlzKSA9PiBheGlzLnVwZGF0ZSgpKTtcbiAgICB0aGlzLmN0eC5sYXlvdXRTZXJ2aWNlLmRpc3BhdGNoTGF5b3V0Q29tcGxldGUoe1xuICAgICAgdHlwZTogXCJsYXlvdXQtY29tcGxldGVcIixcbiAgICAgIGNoYXJ0OiB7IHdpZHRoOiB0aGlzLmN0eC5zY2VuZS53aWR0aCwgaGVpZ2h0OiB0aGlzLmN0eC5zY2VuZS5oZWlnaHQgfSxcbiAgICAgIGNsaXBTZXJpZXM6IGZhbHNlLFxuICAgICAgc2VyaWVzOiB7IHJlY3Q6IGZ1bGxTZXJpZXNSZWN0LCBwYWRkZWRSZWN0OiBzaHJpbmtSZWN0LCB2aXNpYmxlOiB0cnVlIH0sXG4gICAgICBheGVzOiBbXVxuICAgIH0pO1xuICAgIHJldHVybiBzaHJpbmtSZWN0O1xuICB9XG4gIHVwZGF0ZUF4ZXMoY3gsIGN5LCByYWRpdXMpIHtcbiAgICBjb25zdCBhbmdsZUF4aXMgPSB0aGlzLmF4ZXMuZmluZCgoYXhpcykgPT4gYXhpcy5kaXJlY3Rpb24gPT09IFwieFwiIC8qIFggKi8pO1xuICAgIGNvbnN0IHJhZGl1c0F4aXMgPSB0aGlzLmF4ZXMuZmluZCgoYXhpcykgPT4gYXhpcy5kaXJlY3Rpb24gPT09IFwieVwiIC8qIFkgKi8pO1xuICAgIGlmICghKGFuZ2xlQXhpcyBpbnN0YW5jZW9mIFBvbGFyQXhpcykgfHwgIShyYWRpdXNBeGlzIGluc3RhbmNlb2YgUG9sYXJBeGlzKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhbmdsZVNjYWxlID0gYW5nbGVBeGlzLnNjYWxlO1xuICAgIGNvbnN0IGFuZ2xlcyA9IGFuZ2xlU2NhbGUudGlja3M/LigpLm1hcCgodmFsdWUpID0+IGFuZ2xlU2NhbGUuY29udmVydCh2YWx1ZSkpO1xuICAgIGNvbnN0IGlubmVyUmFkaXVzUmF0aW8gPSByYWRpdXNBeGlzLmlubmVyUmFkaXVzUmF0aW87XG4gICAgYW5nbGVBeGlzLmlubmVyUmFkaXVzUmF0aW8gPSBpbm5lclJhZGl1c1JhdGlvO1xuICAgIGFuZ2xlQXhpcy5jb21wdXRlUmFuZ2U/LigpO1xuICAgIGFuZ2xlQXhpcy5ncmlkTGVuZ3RoID0gcmFkaXVzO1xuICAgIHJhZGl1c0F4aXMuZ3JpZEFuZ2xlcyA9IGFuZ2xlcztcbiAgICByYWRpdXNBeGlzLmdyaWRSYW5nZSA9IGFuZ2xlQXhpcy5yYW5nZTtcbiAgICByYWRpdXNBeGlzLnJhbmdlID0gW3JhZGl1cywgcmFkaXVzICogaW5uZXJSYWRpdXNSYXRpb107XG4gICAgW2FuZ2xlQXhpcywgcmFkaXVzQXhpc10uZm9yRWFjaCgoYXhpcykgPT4ge1xuICAgICAgYXhpcy50cmFuc2xhdGlvbi54ID0gY3g7XG4gICAgICBheGlzLnRyYW5zbGF0aW9uLnkgPSBjeTtcbiAgICAgIGF4aXMuY2FsY3VsYXRlTGF5b3V0KCk7XG4gICAgfSk7XG4gIH1cbiAgY29tcHV0ZVNlcmllc1JlY3Qoc2hyaW5rUmVjdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNlcmllc0FyZWE6IHsgcGFkZGluZyB9XG4gICAgfSA9IHRoaXM7XG4gICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy5sZWZ0LCBcImxlZnRcIik7XG4gICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy50b3AsIFwidG9wXCIpO1xuICAgIHNocmlua1JlY3Quc2hyaW5rKHBhZGRpbmcucmlnaHQsIFwicmlnaHRcIik7XG4gICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy5ib3R0b20sIFwiYm90dG9tXCIpO1xuICAgIHRoaXMuc2VyaWVzUmVjdCA9IHNocmlua1JlY3Q7XG4gICAgdGhpcy5hbmltYXRpb25SZWN0ID0gc2hyaW5rUmVjdDtcbiAgfVxuICBhc3luYyBjb21wdXRlQ2lyY2xlKHNlcmllc0JveCkge1xuICAgIGNvbnN0IHBvbGFyU2VyaWVzID0gdGhpcy5zZXJpZXMuZmlsdGVyKChzZXJpZXMpID0+IHtcbiAgICAgIHJldHVybiBzZXJpZXMgaW5zdGFuY2VvZiBQb2xhclNlcmllcztcbiAgICB9KTtcbiAgICBjb25zdCBwb2xhckF4ZXMgPSB0aGlzLmF4ZXMuZmlsdGVyKChheGlzKSA9PiB7XG4gICAgICByZXR1cm4gYXhpcyBpbnN0YW5jZW9mIFBvbGFyQXhpcztcbiAgICB9KTtcbiAgICBjb25zdCBzZXRTZXJpZXNDaXJjbGUgPSAoY3gsIGN5LCByKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZUF4ZXMoY3gsIGN5LCByKTtcbiAgICAgIHBvbGFyU2VyaWVzLmZvckVhY2goKHNlcmllcykgPT4ge1xuICAgICAgICBzZXJpZXMuY2VudGVyWCA9IGN4O1xuICAgICAgICBzZXJpZXMuY2VudGVyWSA9IGN5O1xuICAgICAgICBzZXJpZXMucmFkaXVzID0gcjtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcGllU2VyaWVzID0gcG9sYXJTZXJpZXMuZmlsdGVyKChzKSA9PiBzLnR5cGUgPT09IFwiZG9udXRcIiB8fCBzLnR5cGUgPT09IFwicGllXCIpO1xuICAgICAgaWYgKHBpZVNlcmllcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IGlubmVyUmFkaWkgPSBwaWVTZXJpZXMubWFwKChzZXJpZXMpID0+IHtcbiAgICAgICAgICBjb25zdCBpbm5lclJhZGl1cyA9IHNlcmllcy5nZXRJbm5lclJhZGl1cygpO1xuICAgICAgICAgIHJldHVybiB7IHNlcmllcywgaW5uZXJSYWRpdXMgfTtcbiAgICAgICAgfSkuc29ydCgoYSwgYikgPT4gYS5pbm5lclJhZGl1cyAtIGIuaW5uZXJSYWRpdXMpO1xuICAgICAgICBpbm5lclJhZGlpLmF0KC0xKS5zZXJpZXMuc3Vycm91bmRpbmdSYWRpdXMgPSB2b2lkIDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5uZXJSYWRpaS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICBpbm5lclJhZGlpW2ldLnNlcmllcy5zdXJyb3VuZGluZ1JhZGl1cyA9IGlubmVyUmFkaWlbaSArIDFdLmlubmVyUmFkaXVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBjZW50ZXJYID0gc2VyaWVzQm94LnggKyBzZXJpZXNCb3gud2lkdGggLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSBzZXJpZXNCb3gueSArIHNlcmllc0JveC5oZWlnaHQgLyAyO1xuICAgIGNvbnN0IGluaXRpYWxSYWRpdXMgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihzZXJpZXNCb3gud2lkdGgsIHNlcmllc0JveC5oZWlnaHQpIC8gMik7XG4gICAgbGV0IHJhZGl1cyA9IGluaXRpYWxSYWRpdXM7XG4gICAgc2V0U2VyaWVzQ2lyY2xlKGNlbnRlclgsIGNlbnRlclksIHJhZGl1cyk7XG4gICAgY29uc3Qgc2hha2UgPSBhc3luYyAoeyBoaWRlV2hlbk5lY2Vzc2FyeSA9IGZhbHNlIH0gPSB7fSkgPT4ge1xuICAgICAgY29uc3QgbGFiZWxCb3hlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBzZXJpZXMgb2YgWy4uLnBvbGFyQXhlcywgLi4ucG9sYXJTZXJpZXNdKSB7XG4gICAgICAgIGNvbnN0IGJveCA9IGF3YWl0IHNlcmllcy5jb21wdXRlTGFiZWxzQkJveCh7IGhpZGVXaGVuTmVjZXNzYXJ5IH0sIHNlcmllc0JveCk7XG4gICAgICAgIGlmIChib3gpIHtcbiAgICAgICAgICBsYWJlbEJveGVzLnB1c2goYm94KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxhYmVsQm94ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHNldFNlcmllc0NpcmNsZShjZW50ZXJYLCBjZW50ZXJZLCBpbml0aWFsUmFkaXVzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbGFiZWxCb3ggPSBCQm94Lm1lcmdlKGxhYmVsQm94ZXMpO1xuICAgICAgY29uc3QgcmVmaW5lZCA9IHRoaXMucmVmaW5lQ2lyY2xlKGxhYmVsQm94LCByYWRpdXMsIHNlcmllc0JveCk7XG4gICAgICBzZXRTZXJpZXNDaXJjbGUocmVmaW5lZC5jZW50ZXJYLCByZWZpbmVkLmNlbnRlclksIHJlZmluZWQucmFkaXVzKTtcbiAgICAgIGlmIChyZWZpbmVkLnJhZGl1cyA9PT0gcmFkaXVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJhZGl1cyA9IHJlZmluZWQucmFkaXVzO1xuICAgIH07XG4gICAgYXdhaXQgc2hha2UoKTtcbiAgICBhd2FpdCBzaGFrZSgpO1xuICAgIGF3YWl0IHNoYWtlKCk7XG4gICAgYXdhaXQgc2hha2UoeyBoaWRlV2hlbk5lY2Vzc2FyeTogdHJ1ZSB9KTtcbiAgICBhd2FpdCBzaGFrZSh7IGhpZGVXaGVuTmVjZXNzYXJ5OiB0cnVlIH0pO1xuICAgIHJldHVybiB7IHJhZGl1cywgY2VudGVyWCwgY2VudGVyWSB9O1xuICB9XG4gIHJlZmluZUNpcmNsZShsYWJlbHNCb3gsIHJhZGl1cywgc2VyaWVzQm94KSB7XG4gICAgY29uc3QgbWluQ2lyY2xlUmF0aW8gPSAwLjU7XG4gICAgY29uc3QgY2lyY2xlTGVmdCA9IC1yYWRpdXM7XG4gICAgY29uc3QgY2lyY2xlVG9wID0gLXJhZGl1cztcbiAgICBjb25zdCBjaXJjbGVSaWdodCA9IHJhZGl1cztcbiAgICBjb25zdCBjaXJjbGVCb3R0b20gPSByYWRpdXM7XG4gICAgbGV0IHBhZExlZnQgPSBNYXRoLm1heCgwLCBjaXJjbGVMZWZ0IC0gbGFiZWxzQm94LngpO1xuICAgIGxldCBwYWRUb3AgPSBNYXRoLm1heCgwLCBjaXJjbGVUb3AgLSBsYWJlbHNCb3gueSk7XG4gICAgbGV0IHBhZFJpZ2h0ID0gTWF0aC5tYXgoMCwgbGFiZWxzQm94LnggKyBsYWJlbHNCb3gud2lkdGggLSBjaXJjbGVSaWdodCk7XG4gICAgbGV0IHBhZEJvdHRvbSA9IE1hdGgubWF4KDAsIGxhYmVsc0JveC55ICsgbGFiZWxzQm94LmhlaWdodCAtIGNpcmNsZUJvdHRvbSk7XG4gICAgcGFkTGVmdCA9IHBhZFJpZ2h0ID0gTWF0aC5tYXgocGFkTGVmdCwgcGFkUmlnaHQpO1xuICAgIHBhZFRvcCA9IHBhZEJvdHRvbSA9IE1hdGgubWF4KHBhZFRvcCwgcGFkQm90dG9tKTtcbiAgICBjb25zdCBhdmFpbENpcmNsZVdpZHRoID0gc2VyaWVzQm94LndpZHRoIC0gcGFkTGVmdCAtIHBhZFJpZ2h0O1xuICAgIGNvbnN0IGF2YWlsQ2lyY2xlSGVpZ2h0ID0gc2VyaWVzQm94LmhlaWdodCAtIHBhZFRvcCAtIHBhZEJvdHRvbTtcbiAgICBsZXQgbmV3UmFkaXVzID0gTWF0aC5taW4oYXZhaWxDaXJjbGVXaWR0aCwgYXZhaWxDaXJjbGVIZWlnaHQpIC8gMjtcbiAgICBjb25zdCBtaW5Ib3Jpem9udGFsUmFkaXVzID0gbWluQ2lyY2xlUmF0aW8gKiBzZXJpZXNCb3gud2lkdGggLyAyO1xuICAgIGNvbnN0IG1pblZlcnRpY2FsUmFkaXVzID0gbWluQ2lyY2xlUmF0aW8gKiBzZXJpZXNCb3guaGVpZ2h0IC8gMjtcbiAgICBjb25zdCBtaW5SYWRpdXMgPSBNYXRoLm1pbihtaW5Ib3Jpem9udGFsUmFkaXVzLCBtaW5WZXJ0aWNhbFJhZGl1cyk7XG4gICAgaWYgKG5ld1JhZGl1cyA8IG1pblJhZGl1cykge1xuICAgICAgbmV3UmFkaXVzID0gbWluUmFkaXVzO1xuICAgICAgY29uc3QgaG9yaXpvbnRhbFBhZGRpbmcgPSBwYWRMZWZ0ICsgcGFkUmlnaHQ7XG4gICAgICBjb25zdCB2ZXJ0aWNhbFBhZGRpbmcgPSBwYWRUb3AgKyBwYWRCb3R0b207XG4gICAgICBpZiAoMiAqIG5ld1JhZGl1cyArIHZlcnRpY2FsUGFkZGluZyA+IHNlcmllc0JveC5oZWlnaHQpIHtcbiAgICAgICAgY29uc3QgcGFkSGVpZ2h0ID0gc2VyaWVzQm94LmhlaWdodCAtIDIgKiBuZXdSYWRpdXM7XG4gICAgICAgIGlmIChNYXRoLm1pbihwYWRUb3AsIHBhZEJvdHRvbSkgKiAyID4gcGFkSGVpZ2h0KSB7XG4gICAgICAgICAgcGFkVG9wID0gcGFkSGVpZ2h0IC8gMjtcbiAgICAgICAgICBwYWRCb3R0b20gPSBwYWRIZWlnaHQgLyAyO1xuICAgICAgICB9IGVsc2UgaWYgKHBhZFRvcCA+IHBhZEJvdHRvbSkge1xuICAgICAgICAgIHBhZFRvcCA9IHBhZEhlaWdodCAtIHBhZEJvdHRvbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYWRCb3R0b20gPSBwYWRIZWlnaHQgLSBwYWRUb3A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICgyICogbmV3UmFkaXVzICsgaG9yaXpvbnRhbFBhZGRpbmcgPiBzZXJpZXNCb3gud2lkdGgpIHtcbiAgICAgICAgY29uc3QgcGFkV2lkdGggPSBzZXJpZXNCb3gud2lkdGggLSAyICogbmV3UmFkaXVzO1xuICAgICAgICBpZiAoTWF0aC5taW4ocGFkTGVmdCwgcGFkUmlnaHQpICogMiA+IHBhZFdpZHRoKSB7XG4gICAgICAgICAgcGFkTGVmdCA9IHBhZFdpZHRoIC8gMjtcbiAgICAgICAgICBwYWRSaWdodCA9IHBhZFdpZHRoIC8gMjtcbiAgICAgICAgfSBlbHNlIGlmIChwYWRMZWZ0ID4gcGFkUmlnaHQpIHtcbiAgICAgICAgICBwYWRMZWZ0ID0gcGFkV2lkdGggLSBwYWRSaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYWRSaWdodCA9IHBhZFdpZHRoIC0gcGFkTGVmdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBuZXdXaWR0aCA9IHBhZExlZnQgKyAyICogbmV3UmFkaXVzICsgcGFkUmlnaHQ7XG4gICAgY29uc3QgbmV3SGVpZ2h0ID0gcGFkVG9wICsgMiAqIG5ld1JhZGl1cyArIHBhZEJvdHRvbTtcbiAgICByZXR1cm4ge1xuICAgICAgY2VudGVyWDogc2VyaWVzQm94LnggKyAoc2VyaWVzQm94LndpZHRoIC0gbmV3V2lkdGgpIC8gMiArIHBhZExlZnQgKyBuZXdSYWRpdXMsXG4gICAgICBjZW50ZXJZOiBzZXJpZXNCb3gueSArIChzZXJpZXNCb3guaGVpZ2h0IC0gbmV3SGVpZ2h0KSAvIDIgKyBwYWRUb3AgKyBuZXdSYWRpdXMsXG4gICAgICByYWRpdXM6IG5ld1JhZGl1c1xuICAgIH07XG4gIH1cbn07XG5Qb2xhckNoYXJ0LmNsYXNzTmFtZSA9IFwiUG9sYXJDaGFydFwiO1xuUG9sYXJDaGFydC50eXBlID0gXCJwb2xhclwiO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9zZXJpZXMvdG9wb2xvZ3kvbWVyY2F0b3JTY2FsZS50c1xudmFyIHJhZHNJbkRlZyA9IE1hdGguUEkgLyAxODA7XG52YXIgbG9uWCA9IChsb24pID0+IGxvbiAqIHJhZHNJbkRlZztcbnZhciBsYXRZID0gKGxhdCkgPT4gLU1hdGgubG9nKE1hdGgudGFuKE1hdGguUEkgKiAwLjI1ICsgbGF0ICogcmFkc0luRGVnICogMC41KSk7XG52YXIgeExvbiA9ICh4KSA9PiB4IC8gcmFkc0luRGVnO1xudmFyIHlMYXQgPSAoeSkgPT4gKE1hdGguYXRhbihNYXRoLmV4cCgteSkpIC0gTWF0aC5QSSAqIDAuMjUpIC8gKHJhZHNJbkRlZyAqIDAuNSk7XG52YXIgTWVyY2F0b3JTY2FsZSA9IGNsYXNzIF9NZXJjYXRvclNjYWxlIHtcbiAgY29uc3RydWN0b3IoZG9tYWluLCByYW5nZTMpIHtcbiAgICB0aGlzLmRvbWFpbiA9IGRvbWFpbjtcbiAgICB0aGlzLnJhbmdlID0gcmFuZ2UzO1xuICAgIHRoaXMudHlwZSA9IFwibWVyY2F0b3JcIjtcbiAgICB0aGlzLmJvdW5kcyA9IF9NZXJjYXRvclNjYWxlLmJvdW5kcyhkb21haW4pO1xuICB9XG4gIHN0YXRpYyBib3VuZHMoZG9tYWluKSB7XG4gICAgY29uc3QgW1tsb24wLCBsYXQwXSwgW2xvbjEsIGxhdDFdXSA9IGRvbWFpbjtcbiAgICBjb25zdCB4MCA9IGxvblgobG9uMCk7XG4gICAgY29uc3QgeTAgPSBsYXRZKGxhdDApO1xuICAgIGNvbnN0IHgxID0gbG9uWChsb24xKTtcbiAgICBjb25zdCB5MSA9IGxhdFkobGF0MSk7XG4gICAgcmV0dXJuIG5ldyBCQm94KE1hdGgubWluKHgwLCB4MSksIE1hdGgubWluKHkwLCB5MSksIE1hdGguYWJzKHgxIC0geDApLCBNYXRoLmFicyh5MSAtIHkwKSk7XG4gIH1cbiAgc3RhdGljIGZpeGVkU2NhbGUoKSB7XG4gICAgcmV0dXJuIG5ldyBfTWVyY2F0b3JTY2FsZShcbiAgICAgIFtcbiAgICAgICAgW3hMb24oMCksIHlMYXQoMCldLFxuICAgICAgICBbeExvbigxKSwgeUxhdCgxKV1cbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgWzEsIDFdXG4gICAgICBdXG4gICAgKTtcbiAgfVxuICBjb252ZXJ0KFtsb24sIGxhdF0pIHtcbiAgICBjb25zdCBbW3gwLCB5MF0sIFt4MSwgeTFdXSA9IHRoaXMucmFuZ2U7XG4gICAgY29uc3QgeFNjYWxlID0gKHgxIC0geDApIC8gdGhpcy5ib3VuZHMud2lkdGg7XG4gICAgY29uc3QgeVNjYWxlID0gKHkxIC0geTApIC8gdGhpcy5ib3VuZHMuaGVpZ2h0O1xuICAgIHJldHVybiBbKGxvblgobG9uKSAtIHRoaXMuYm91bmRzLngpICogeFNjYWxlICsgeDAsIChsYXRZKGxhdCkgLSB0aGlzLmJvdW5kcy55KSAqIHlTY2FsZSArIHkwXTtcbiAgfVxuICBpbnZlcnQoW3gsIHldKSB7XG4gICAgY29uc3QgW1t4MCwgeTBdLCBbeDEsIHkxXV0gPSB0aGlzLnJhbmdlO1xuICAgIGNvbnN0IHhTY2FsZSA9ICh4MSAtIHgwKSAvIHRoaXMuYm91bmRzLndpZHRoO1xuICAgIGNvbnN0IHlTY2FsZSA9ICh5MSAtIHkwKSAvIHRoaXMuYm91bmRzLmhlaWdodDtcbiAgICByZXR1cm4gW3hMb24oKHggLSB4MCkgLyB4U2NhbGUgKyB0aGlzLmJvdW5kcy54KSwgeUxhdCgoeSAtIHkwKSAvIHlTY2FsZSArIHRoaXMuYm91bmRzLnkpXTtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdG9wb2xvZ3lDaGFydC50c1xuZnVuY3Rpb24gaXNUb3BvbG9neVNlcmllcyhzZXJpZXMpIHtcbiAgcmV0dXJuIHNlcmllcy50eXBlID09PSBcIm1hcC1zaGFwZVwiIHx8IHNlcmllcy50eXBlID09PSBcIm1hcC1saW5lXCIgfHwgc2VyaWVzLnR5cGUgPT09IFwibWFwLW1hcmtlclwiIHx8IHNlcmllcy50eXBlID09PSBcIm1hcC1zaGFwZS1iYWNrZ3JvdW5kXCIgfHwgc2VyaWVzLnR5cGUgPT09IFwibWFwLWxpbmUtYmFja2dyb3VuZFwiO1xufVxudmFyIFRvcG9sb2d5Q2hhcnQgPSBjbGFzcyBleHRlbmRzIENoYXJ0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucywgcmVzb3VyY2VzKSB7XG4gICAgc3VwZXIob3B0aW9ucywgcmVzb3VyY2VzKTtcbiAgICB0aGlzLnhBeGlzID0gbmV3IE51bWJlckF4aXModGhpcy5nZXRNb2R1bGVDb250ZXh0KCkpO1xuICAgIHRoaXMueEF4aXMucG9zaXRpb24gPSBcImJvdHRvbVwiO1xuICAgIHRoaXMueUF4aXMgPSBuZXcgTnVtYmVyQXhpcyh0aGlzLmdldE1vZHVsZUNvbnRleHQoKSk7XG4gICAgdGhpcy55QXhpcy5wb3NpdGlvbiA9IFwibGVmdFwiO1xuICAgIHRoaXMuY3R4Lnpvb21NYW5hZ2VyLnVwZGF0ZUF4ZXMoW3RoaXMueEF4aXMsIHRoaXMueUF4aXNdKTtcbiAgfVxuICBnZXRDaGFydFR5cGUoKSB7XG4gICAgcmV0dXJuIFwidG9wb2xvZ3lcIjtcbiAgfVxuICBhc3luYyB1cGRhdGVEYXRhKCkge1xuICAgIGF3YWl0IHN1cGVyLnVwZGF0ZURhdGEoKTtcbiAgICBjb25zdCB7IHRvcG9sb2d5IH0gPSB0aGlzLmdldE9wdGlvbnMoKTtcbiAgICB0aGlzLnNlcmllcy5mb3JFYWNoKChzZXJpZXMpID0+IHtcbiAgICAgIGlmIChpc1RvcG9sb2d5U2VyaWVzKHNlcmllcykpIHtcbiAgICAgICAgc2VyaWVzLnNldENoYXJ0VG9wb2xvZ3kodG9wb2xvZ3kpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIHBlcmZvcm1MYXlvdXQoKSB7XG4gICAgY29uc3Qgc2hyaW5rUmVjdCA9IGF3YWl0IHN1cGVyLnBlcmZvcm1MYXlvdXQoKTtcbiAgICBjb25zdCB7XG4gICAgICBzZXJpZXNBcmVhOiB7IHBhZGRpbmcgfSxcbiAgICAgIHNlcmllc1Jvb3QsXG4gICAgICBhbm5vdGF0aW9uUm9vdCxcbiAgICAgIGhpZ2hsaWdodFJvb3RcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBmdWxsU2VyaWVzUmVjdCA9IHNocmlua1JlY3QuY2xvbmUoKTtcbiAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLmxlZnQsIFwibGVmdFwiKTtcbiAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLnRvcCwgXCJ0b3BcIik7XG4gICAgc2hyaW5rUmVjdC5zaHJpbmsocGFkZGluZy5yaWdodCwgXCJyaWdodFwiKTtcbiAgICBzaHJpbmtSZWN0LnNocmluayhwYWRkaW5nLmJvdHRvbSwgXCJib3R0b21cIik7XG4gICAgdGhpcy5zZXJpZXNSZWN0ID0gc2hyaW5rUmVjdDtcbiAgICB0aGlzLmFuaW1hdGlvblJlY3QgPSBzaHJpbmtSZWN0O1xuICAgIGNvbnN0IG1hcFNlcmllcyA9IHRoaXMuc2VyaWVzLmZpbHRlcihpc1RvcG9sb2d5U2VyaWVzKTtcbiAgICBjb25zdCBjb21iaW5lZEJib3ggPSBtYXBTZXJpZXMucmVkdWNlKChjb21iaW5lZCwgc2VyaWVzKSA9PiB7XG4gICAgICBpZiAoIXNlcmllcy52aXNpYmxlKVxuICAgICAgICByZXR1cm4gY29tYmluZWQ7XG4gICAgICBjb25zdCBiYm94ID0gc2VyaWVzLnRvcG9sb2d5Qm91bmRzO1xuICAgICAgaWYgKGJib3ggPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkO1xuICAgICAgaWYgKGNvbWJpbmVkID09IG51bGwpXG4gICAgICAgIHJldHVybiBiYm94O1xuICAgICAgY29tYmluZWQubWVyZ2UoYmJveCk7XG4gICAgICByZXR1cm4gY29tYmluZWQ7XG4gICAgfSwgdm9pZCAwKTtcbiAgICBsZXQgc2NhbGUyO1xuICAgIGlmIChjb21iaW5lZEJib3ggIT0gbnVsbCkge1xuICAgICAgY29uc3QgeyBsb24wLCBsYXQwLCBsb24xLCBsYXQxIH0gPSBjb21iaW5lZEJib3g7XG4gICAgICBjb25zdCBkb21haW4gPSBbXG4gICAgICAgIFtsb24wLCBsYXQwXSxcbiAgICAgICAgW2xvbjEsIGxhdDFdXG4gICAgICBdO1xuICAgICAgY29uc3QgYm91bmRzID0gTWVyY2F0b3JTY2FsZS5ib3VuZHMoZG9tYWluKTtcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gc2hyaW5rUmVjdDtcbiAgICAgIGNvbnN0IHZpZXdCb3hTY2FsZSA9IE1hdGgubWluKHdpZHRoIC8gYm91bmRzLndpZHRoLCBoZWlnaHQgLyBib3VuZHMuaGVpZ2h0KTtcbiAgICAgIGNvbnN0IHZpZXdCb3hXaWR0aCA9IGJvdW5kcy53aWR0aCAqIHZpZXdCb3hTY2FsZTtcbiAgICAgIGNvbnN0IHZpZXdCb3hIZWlnaHQgPSBib3VuZHMuaGVpZ2h0ICogdmlld0JveFNjYWxlO1xuICAgICAgY29uc3Qgdmlld0JveE9yaWdpblggPSAod2lkdGggLSB2aWV3Qm94V2lkdGgpIC8gMjtcbiAgICAgIGNvbnN0IHZpZXdCb3hPcmlnaW5ZID0gKGhlaWdodCAtIHZpZXdCb3hIZWlnaHQpIC8gMjtcbiAgICAgIGNvbnN0IHgwID0gdmlld0JveE9yaWdpblg7XG4gICAgICBjb25zdCB5MCA9IHZpZXdCb3hPcmlnaW5ZO1xuICAgICAgY29uc3QgeDEgPSB2aWV3Qm94T3JpZ2luWCArIHZpZXdCb3hXaWR0aDtcbiAgICAgIGNvbnN0IHkxID0gdmlld0JveE9yaWdpblkgKyB2aWV3Qm94SGVpZ2h0O1xuICAgICAgY29uc3QgeFpvb20gPSB0aGlzLmN0eC56b29tTWFuYWdlci5nZXRBeGlzWm9vbSh0aGlzLnhBeGlzLmlkKTtcbiAgICAgIGNvbnN0IHlab29tID0gdGhpcy5jdHguem9vbU1hbmFnZXIuZ2V0QXhpc1pvb20odGhpcy55QXhpcy5pZCk7XG4gICAgICBjb25zdCB4U3BhbiA9ICh4MSAtIHgwKSAvICh4Wm9vbS5tYXggLSB4Wm9vbS5taW4pO1xuICAgICAgY29uc3QgeFN0YXJ0ID0geDAgLSB4U3BhbiAqIHhab29tLm1pbjtcbiAgICAgIGNvbnN0IHlTcGFuID0gKHkxIC0geTApIC8gKDEgLSB5Wm9vbS5taW4gLSAoMSAtIHlab29tLm1heCkpO1xuICAgICAgY29uc3QgeVN0YXJ0ID0geTAgLSB5U3BhbiAqICgxIC0geVpvb20ubWF4KTtcbiAgICAgIHNjYWxlMiA9IG5ldyBNZXJjYXRvclNjYWxlKGRvbWFpbiwgW1xuICAgICAgICBbeFN0YXJ0LCB5U3RhcnRdLFxuICAgICAgICBbeFN0YXJ0ICsgeFNwYW4sIHlTdGFydCArIHlTcGFuXVxuICAgICAgXSk7XG4gICAgfVxuICAgIG1hcFNlcmllcy5mb3JFYWNoKChzZXJpZXMpID0+IHtcbiAgICAgIHNlcmllcy5zY2FsZSA9IHNjYWxlMjtcbiAgICB9KTtcbiAgICBjb25zdCBzZXJpZXNWaXNpYmxlID0gdGhpcy5zZXJpZXMuc29tZSgocykgPT4gcy52aXNpYmxlKTtcbiAgICBzZXJpZXNSb290LnZpc2libGUgPSBzZXJpZXNWaXNpYmxlO1xuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgW3Nlcmllc1Jvb3QsIGFubm90YXRpb25Sb290LCBoaWdobGlnaHRSb290XSkge1xuICAgICAgZ3JvdXAudHJhbnNsYXRpb25YID0gTWF0aC5mbG9vcihzaHJpbmtSZWN0LngpO1xuICAgICAgZ3JvdXAudHJhbnNsYXRpb25ZID0gTWF0aC5mbG9vcihzaHJpbmtSZWN0LnkpO1xuICAgICAgZ3JvdXAuc2V0Q2xpcFJlY3RJbkdyb3VwQ29vcmRpbmF0ZVNwYWNlKFxuICAgICAgICBuZXcgQkJveChzaHJpbmtSZWN0LngsIHNocmlua1JlY3QueSwgc2hyaW5rUmVjdC53aWR0aCwgc2hyaW5rUmVjdC5oZWlnaHQpXG4gICAgICApO1xuICAgIH1cbiAgICB0aGlzLmN0eC5sYXlvdXRTZXJ2aWNlLmRpc3BhdGNoTGF5b3V0Q29tcGxldGUoe1xuICAgICAgdHlwZTogXCJsYXlvdXQtY29tcGxldGVcIixcbiAgICAgIGNoYXJ0OiB7IHdpZHRoOiB0aGlzLmN0eC5zY2VuZS53aWR0aCwgaGVpZ2h0OiB0aGlzLmN0eC5zY2VuZS5oZWlnaHQgfSxcbiAgICAgIGNsaXBTZXJpZXM6IGZhbHNlLFxuICAgICAgc2VyaWVzOiB7IHJlY3Q6IGZ1bGxTZXJpZXNSZWN0LCBwYWRkZWRSZWN0OiBzaHJpbmtSZWN0LCB2aXNpYmxlOiBzZXJpZXNWaXNpYmxlIH0sXG4gICAgICBheGVzOiBbXVxuICAgIH0pO1xuICAgIHJldHVybiBzaHJpbmtSZWN0O1xuICB9XG59O1xuVG9wb2xvZ3lDaGFydC5jbGFzc05hbWUgPSBcIlRvcG9sb2d5Q2hhcnRcIjtcblRvcG9sb2d5Q2hhcnQudHlwZSA9IFwidG9wb2xvZ3lcIjtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW9kdWxlL2VudGVycHJpc2VNb2R1bGUudHNcbnZhciBlbnRlcnByaXNlTW9kdWxlID0ge1xuICBpc0VudGVycHJpc2U6IGZhbHNlXG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9hcGkvcHJlc2V0L3ByaWNlVm9sdW1lUHJlc2V0LnRzXG5mdW5jdGlvbiBmcm9tVGhlbWUodGhlbWUsIGNiKSB7XG4gIGlmIChpc09iamVjdCh0aGVtZSkpIHtcbiAgICByZXR1cm4gY2IodGhlbWUpO1xuICB9XG59XG52YXIgY2hhcnRUeXBlczIgPSBbXCJvaGxjXCIsIFwibGluZVwiLCBcInN0ZXAtbGluZVwiLCBcImhsY1wiLCBcImhpZ2gtbG93XCIsIFwiY2FuZGxlc3RpY2tcIiwgXCJob2xsb3ctY2FuZGxlc3RpY2tcIl07XG5mdW5jdGlvbiBwcmljZVZvbHVtZShvcHRzLCBnZXRUaGVtZSkge1xuICBjb25zdCB7XG4gICAgeEtleSxcbiAgICBkYXRlS2V5ID0geEtleSA/PyBcImRhdGVcIixcbiAgICBoaWdoS2V5ID0gXCJoaWdoXCIsXG4gICAgb3BlbktleSA9IFwib3BlblwiLFxuICAgIGxvd0tleSA9IFwibG93XCIsXG4gICAgY2xvc2VLZXkgPSBcImNsb3NlXCIsXG4gICAgdm9sdW1lS2V5ID0gXCJ2b2x1bWVcIixcbiAgICBjaGFydFR5cGU6IGNoYXJ0VHlwZTIgPSBcImNhbmRsZXN0aWNrXCIsXG4gICAgbmF2aWdhdG9yOiBuYXZpZ2F0b3IyID0gZmFsc2UsXG4gICAgdm9sdW1lID0gdHJ1ZSxcbiAgICByYW5nZVRvb2xiYXIsXG4gICAgcmFuZ2VCdXR0b25zID0gcmFuZ2VUb29sYmFyID8/IHRydWUsXG4gICAgc3RhdHVzQmFyID0gdHJ1ZSxcbiAgICBhbm5vdGF0aW9uczogYW5ub3RhdGlvbnMyLFxuICAgIHRvb2xiYXIgPSBhbm5vdGF0aW9uczIgPz8gdHJ1ZSxcbiAgICB6b29tOiB6b29tMiA9IHRydWUsXG4gICAgdGhlbWUsXG4gICAgZGF0YSxcbiAgICAuLi51bnVzZWRPcHRzXG4gIH0gPSBvcHRzO1xuICBpZiAoeEtleSAhPSBudWxsKSB7XG4gICAgTG9nZ2VyLndhcm5PbmNlKFwiUHJvcGVydHkgW3hLZXldIGlzIGRlcHJlY2F0ZWQsIHVzZSBbZGF0ZUtleV0gaW5zdGVhZC5cIik7XG4gIH1cbiAgaWYgKHJhbmdlVG9vbGJhciAhPSBudWxsKSB7XG4gICAgTG9nZ2VyLndhcm5PbmNlKFwiUHJvcGVydHkgW3JhbmdlVG9vbGJhcl0gaXMgZGVwcmVjYXRlZCwgdXNlIFtyYW5nZUJ1dHRvbnNdIGluc3RlYWQuXCIpO1xuICB9XG4gIGlmIChhbm5vdGF0aW9uczIgIT0gbnVsbCkge1xuICAgIExvZ2dlci53YXJuT25jZShcIlByb3BlcnR5IFthbm5vdGF0aW9uc10gaXMgZGVwcmVjYXRlZCwgdXNlIFt0b29sYmFyXSBpbnN0ZWFkLlwiKTtcbiAgfVxuICBjb25zdCBwcmljZVNlcmllcyA9IGNyZWF0ZVByaWNlU2VyaWVzKHRoZW1lLCBjaGFydFR5cGUyLCBkYXRlS2V5LCBoaWdoS2V5LCBsb3dLZXksIG9wZW5LZXksIGNsb3NlS2V5KTtcbiAgY29uc3Qgdm9sdW1lU2VyaWVzID0gY3JlYXRlVm9sdW1lU2VyaWVzKHRoZW1lLCBnZXRUaGVtZSwgb3BlbktleSwgY2xvc2VLZXksIHZvbHVtZSwgdm9sdW1lS2V5KTtcbiAgY29uc3QgbWluaUNoYXJ0ID0gdm9sdW1lID8ge1xuICAgIG1pbmlDaGFydDoge1xuICAgICAgZW5hYmxlZDogbmF2aWdhdG9yMixcbiAgICAgIHNlcmllczogW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJsaW5lXCIsXG4gICAgICAgICAgeEtleTogZGF0ZUtleSxcbiAgICAgICAgICB5S2V5OiB2b2x1bWVLZXksXG4gICAgICAgICAgbWFya2VyOiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1cbiAgfSA6IG51bGw7XG4gIGNvbnN0IG5hdmlnYXRvck9wdHMgPSB7XG4gICAgbmF2aWdhdG9yOiB7XG4gICAgICBlbmFibGVkOiBuYXZpZ2F0b3IyLFxuICAgICAgLi4ubWluaUNoYXJ0XG4gICAgfVxuICB9O1xuICBjb25zdCBzdGF0dXNCYXJPcHRzID0gc3RhdHVzQmFyID8ge1xuICAgIHN0YXR1c0Jhcjoge1xuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIGRhdGEsXG4gICAgICBoaWdoS2V5LFxuICAgICAgb3BlbktleSxcbiAgICAgIGxvd0tleSxcbiAgICAgIGNsb3NlS2V5LFxuICAgICAgdm9sdW1lS2V5OiB2b2x1bWUgPyB2b2x1bWVLZXkgOiB2b2lkIDBcbiAgICB9XG4gIH0gOiBudWxsO1xuICBjb25zdCB6b29tT3B0cyA9IHtcbiAgICB6b29tOiB7XG4gICAgICBlbmFibGVkOiB6b29tMixcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIGVuYWJsZUluZGVwZW5kZW50QXhlczogdHJ1ZVxuICAgIH1cbiAgfTtcbiAgY29uc3QgdG9vbGJhck9wdHMgPSB7XG4gICAgY2hhcnRUb29sYmFyOiB7IGVuYWJsZWQ6IHRydWUgfSxcbiAgICB0b29sYmFyOiB7XG4gICAgICBzZXJpZXNUeXBlOiB7XG4gICAgICAgIGVuYWJsZWQ6IHRvb2xiYXJcbiAgICAgIH0sXG4gICAgICBhbm5vdGF0aW9uT3B0aW9uczoge1xuICAgICAgICBlbmFibGVkOiB0b29sYmFyXG4gICAgICB9LFxuICAgICAgYW5ub3RhdGlvbnM6IHtcbiAgICAgICAgZW5hYmxlZDogdG9vbGJhclxuICAgICAgfSxcbiAgICAgIHJhbmdlczoge1xuICAgICAgICBlbmFibGVkOiByYW5nZUJ1dHRvbnNcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IHZvbHVtZUF4aXMgPSB2b2x1bWUgPyBbXG4gICAge1xuICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgIHBvc2l0aW9uOiBcImxlZnRcIixcbiAgICAgIGtleXM6IFt2b2x1bWVLZXldLFxuICAgICAgbGFiZWw6IHsgZW5hYmxlZDogZmFsc2UgfSxcbiAgICAgIGNyb3NzaGFpcjogeyBlbmFibGVkOiBmYWxzZSB9LFxuICAgICAgZ3JpZExpbmU6IHsgZW5hYmxlZDogZmFsc2UgfSxcbiAgICAgIG5pY2U6IGZhbHNlLFxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgbGF5b3V0Q29uc3RyYWludHM6IHtcbiAgICAgICAgc3RhY2tlZDogZmFsc2UsXG4gICAgICAgIHdpZHRoOiAyMCxcbiAgICAgICAgdW5pdDogXCJwZXJjZW50YWdlXCIsXG4gICAgICAgIGFsaWduOiBcImVuZFwiXG4gICAgICB9XG4gICAgfVxuICBdIDogW107XG4gIHJldHVybiB7XG4gICAgdGhlbWU6IHR5cGVvZiB0aGVtZSA9PT0gXCJzdHJpbmdcIiA/IHRoZW1lIDoge1xuICAgICAgYmFzZVRoZW1lOiBcImFnLWZpbmFuY2lhbFwiLFxuICAgICAgLi4udGhlbWUgPz8ge31cbiAgICB9LFxuICAgIGFuaW1hdGlvbjogeyBlbmFibGVkOiBmYWxzZSB9LFxuICAgIGxlZ2VuZDogeyBlbmFibGVkOiBmYWxzZSB9LFxuICAgIHNlcmllczogWy4uLnZvbHVtZVNlcmllcywgLi4ucHJpY2VTZXJpZXNdLFxuICAgIHBhZGRpbmc6IHtcbiAgICAgIHRvcDogNixcbiAgICAgIHJpZ2h0OiA4LFxuICAgICAgYm90dG9tOiA1XG4gICAgfSxcbiAgICBheGVzOiBbXG4gICAgICB7XG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgIHBvc2l0aW9uOiBcInJpZ2h0XCIsXG4gICAgICAgIGtleXM6IFtvcGVuS2V5LCBjbG9zZUtleSwgaGlnaEtleSwgbG93S2V5XSxcbiAgICAgICAgaW50ZXJ2YWw6IHtcbiAgICAgICAgICBtYXhTcGFjaW5nOiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8uY29tbW9uPy5heGVzPy5udW1iZXI/LmludGVydmFsPy5tYXhTcGFjaW5nKSA/PyA0NVxuICAgICAgICB9LFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIGZvcm1hdDogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmNvbW1vbj8uYXhlcz8ubnVtYmVyPy5sYWJlbD8uZm9ybWF0KSA/PyBcIi4yZlwiXG4gICAgICAgIH0sXG4gICAgICAgIGNyb3NzaGFpcjoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgc25hcDogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBsYXlvdXRDb25zdHJhaW50czoge1xuICAgICAgICAgIHN0YWNrZWQ6IGZhbHNlLFxuICAgICAgICAgIHdpZHRoOiAxMDAsXG4gICAgICAgICAgdW5pdDogXCJwZXJjZW50YWdlXCIsXG4gICAgICAgICAgYWxpZ246IFwic3RhcnRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLi4udm9sdW1lQXhpcyxcbiAgICAgIHtcbiAgICAgICAgdHlwZTogXCJvcmRpbmFsLXRpbWVcIixcbiAgICAgICAgcG9zaXRpb246IFwiYm90dG9tXCIsXG4gICAgICAgIGxpbmU6IHtcbiAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBsYWJlbDoge1xuICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgY3Jvc3NoYWlyOiB7XG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgXSxcbiAgICBhbm5vdGF0aW9uczoge1xuICAgICAgZW5hYmxlZDogdG9vbGJhclxuICAgIH0sXG4gICAgdG9vbHRpcDogeyBlbmFibGVkOiBmYWxzZSB9LFxuICAgIGRhdGEsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHRpdGxlUGFkZGluZzogNCxcbiAgICAuLi5uYXZpZ2F0b3JPcHRzLFxuICAgIC4uLnN0YXR1c0Jhck9wdHMsXG4gICAgLi4uem9vbU9wdHMsXG4gICAgLi4udG9vbGJhck9wdHMsXG4gICAgLi4udW51c2VkT3B0c1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVm9sdW1lU2VyaWVzKHRoZW1lLCBnZXRUaGVtZSwgb3BlbktleSwgY2xvc2VLZXksIHZvbHVtZSwgdm9sdW1lS2V5KSB7XG4gIGlmICghdm9sdW1lKVxuICAgIHJldHVybiBbXTtcbiAgY29uc3QgYmFyU2VyaWVzRmlsbCA9IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5iYXI/LnNlcmllcz8uZmlsbCk7XG4gIGNvbnN0IGl0ZW1TdHlsZXIgPSBiYXJTZXJpZXNGaWxsID8geyBmaWxsOiBiYXJTZXJpZXNGaWxsIH0gOiB7XG4gICAgaXRlbVN0eWxlcih7IGRhdHVtIH0pIHtcbiAgICAgIGNvbnN0IHsgdXAsIGRvd24gfSA9IGdldFRoZW1lKCkucGFsZXR0ZTtcbiAgICAgIHJldHVybiB7IGZpbGw6IGRhdHVtW29wZW5LZXldIDwgZGF0dW1bY2xvc2VLZXldID8gdXA/LmZpbGwgOiBkb3duPy5maWxsIH07XG4gICAgfVxuICB9O1xuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHR5cGU6IFwiYmFyXCIsXG4gICAgICB4S2V5OiBcImRhdGVcIixcbiAgICAgIHlLZXk6IHZvbHVtZUtleSxcbiAgICAgIHRvb2x0aXA6IHsgZW5hYmxlZDogZmFsc2UgfSxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIGhpZ2hsaWdodDogeyBlbmFibGVkOiBmYWxzZSB9LFxuICAgICAgZmlsbE9wYWNpdHk6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5iYXI/LnNlcmllcz8uZmlsbE9wYWNpdHkpID8/IDAuNSxcbiAgICAgIC4uLml0ZW1TdHlsZXJcbiAgICB9XG4gIF07XG59XG52YXIgUkFOR0VfQVJFQV9UWVBFID0gXCJyYW5nZS1hcmVhXCI7XG5mdW5jdGlvbiBjcmVhdGVQcmljZVNlcmllcyh0aGVtZSwgY2hhcnRUeXBlMiwgeEtleSwgaGlnaEtleSwgbG93S2V5LCBvcGVuS2V5LCBjbG9zZUtleSkge1xuICBpZiAoY2hhcnRUeXBlMiA9PT0gUkFOR0VfQVJFQV9UWVBFKSB7XG4gICAgTG9nZ2VyLndhcm5PbmNlKGB0eXBlICcke2NoYXJ0VHlwZTJ9JyBpcyBkZXByZWNhdGVkLCB1c2UgJ2hsYycgY2hhcnQgdHlwZSBpbnN0ZWFkYCk7XG4gICAgY2hhcnRUeXBlMiA9IFwiaGxjXCI7XG4gIH1cbiAgY29uc3Qga2V5cyA9IHtcbiAgICB4S2V5LFxuICAgIG9wZW5LZXksXG4gICAgY2xvc2VLZXksXG4gICAgaGlnaEtleSxcbiAgICBsb3dLZXlcbiAgfTtcbiAgY29uc3Qgc2luZ2xlS2V5cyA9IHtcbiAgICB4S2V5LFxuICAgIHlLZXk6IGNsb3NlS2V5XG4gIH07XG4gIGNvbnN0IGNvbW1vbiA9IHtcbiAgICBwaWNrT3V0c2lkZVZpc2libGVNaW5vckF4aXM6IHRydWVcbiAgfTtcbiAgc3dpdGNoIChjaGFydFR5cGUyID8/IFwiY2FuZGxlc3RpY2tcIikge1xuICAgIGNhc2UgXCJvaGxjXCI6XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJvaGxjXCIsXG4gICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgIC4uLmtleXNcbiAgICAgICAgfVxuICAgICAgXTtcbiAgICBjYXNlIFwibGluZVwiOlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwibGluZVwiLFxuICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAuLi5zaW5nbGVLZXlzLFxuICAgICAgICAgIHN0cm9rZTogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmxpbmU/LnNlcmllcz8uc3Ryb2tlKSA/PyBQQUxFVFRFX05FVVRSQUxfU1RST0tFLFxuICAgICAgICAgIG1hcmtlcjogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmxpbmU/LnNlcmllcz8ubWFya2VyKSA/PyB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICBjYXNlIFwic3RlcC1saW5lXCI6XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJsaW5lXCIsXG4gICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgIC4uLnNpbmdsZUtleXMsXG4gICAgICAgICAgc3Ryb2tlOiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8ubGluZT8uc2VyaWVzPy5zdHJva2UpID8/IFBBTEVUVEVfTkVVVFJBTF9TVFJPS0UsXG4gICAgICAgICAgaW50ZXJwb2xhdGlvbjogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmxpbmU/LnNlcmllcz8uaW50ZXJwb2xhdGlvbikgPz8ge1xuICAgICAgICAgICAgdHlwZTogXCJzdGVwXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIG1hcmtlcjogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LmxpbmU/LnNlcmllcz8ubWFya2VyKSA/PyB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICBjYXNlIFwiaGxjXCI6XG4gICAgICBjb25zdCByYW5nZUFyZWFDb2xvcnMgPSBnZXRUaGVtZUNvbG9ycyhSQU5HRV9BUkVBX1RZUEUsIHRoZW1lKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBSQU5HRV9BUkVBX1RZUEUsXG4gICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgIHhLZXksXG4gICAgICAgICAgeUhpZ2hLZXk6IGhpZ2hLZXksXG4gICAgICAgICAgeUxvd0tleTogY2xvc2VLZXksXG4gICAgICAgICAgZmlsbDogcmFuZ2VBcmVhQ29sb3JzLmZpbGwgPz8gUEFMRVRURV9VUF9GSUxMLFxuICAgICAgICAgIHN0cm9rZTogcmFuZ2VBcmVhQ29sb3JzLnN0cm9rZSA/PyBQQUxFVFRFX1VQX1NUUk9LRSxcbiAgICAgICAgICBmaWxsT3BhY2l0eTogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LltcInJhbmdlLWFyZWFcIl0/LnNlcmllcz8uZmlsbE9wYWNpdHkpID8/IDAuMyxcbiAgICAgICAgICBzdHJva2VXaWR0aDogZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LltcInJhbmdlLWFyZWFcIl0/LnNlcmllcz8uc3Ryb2tlV2lkdGgpID8/IDJcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFJBTkdFX0FSRUFfVFlQRSxcbiAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgeEtleSxcbiAgICAgICAgICB5SGlnaEtleTogY2xvc2VLZXksXG4gICAgICAgICAgeUxvd0tleTogbG93S2V5LFxuICAgICAgICAgIGZpbGw6IHJhbmdlQXJlYUNvbG9ycy5maWxsID8/IFBBTEVUVEVfRE9XTl9GSUxMLFxuICAgICAgICAgIHN0cm9rZTogcmFuZ2VBcmVhQ29sb3JzLnN0cm9rZSA/PyBQQUxFVFRFX0RPV05fU1RST0tFLFxuICAgICAgICAgIGZpbGxPcGFjaXR5OiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8uW1wicmFuZ2UtYXJlYVwiXT8uc2VyaWVzPy5maWxsT3BhY2l0eSkgPz8gMC4zLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8uW1wicmFuZ2UtYXJlYVwiXT8uc2VyaWVzPy5zdHJva2VXaWR0aCkgPz8gMlxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJsaW5lXCIsXG4gICAgICAgICAgLi4uY29tbW9uLFxuICAgICAgICAgIC4uLnNpbmdsZUtleXMsXG4gICAgICAgICAgc3Ryb2tlOiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8ubGluZT8uc2VyaWVzPy5zdHJva2UpID8/IFBBTEVUVEVfQUxUX05FVVRSQUxfU1RST0tFLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8ubGluZT8uc2VyaWVzPy5zdHJva2VXaWR0aCkgPz8gMixcbiAgICAgICAgICBtYXJrZXI6IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5saW5lPy5zZXJpZXM/Lm1hcmtlcikgPz8geyBlbmFibGVkOiBmYWxzZSB9XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgY2FzZSBcImhpZ2gtbG93XCI6XG4gICAgICBjb25zdCByYW5nZUJhckNvbG9ycyA9IGdldFRoZW1lQ29sb3JzKFwicmFuZ2UtYmFyXCIsIHRoZW1lKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcInJhbmdlLWJhclwiLFxuICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICB4S2V5LFxuICAgICAgICAgIHlIaWdoS2V5OiBoaWdoS2V5LFxuICAgICAgICAgIHlMb3dLZXk6IGxvd0tleSxcbiAgICAgICAgICBmaWxsOiByYW5nZUJhckNvbG9ycy5maWxsID8/IFBBTEVUVEVfTkVVVFJBTF9GSUxMLFxuICAgICAgICAgIHN0cm9rZTogcmFuZ2VCYXJDb2xvcnMuc3Ryb2tlID8/IFBBTEVUVEVfTkVVVFJBTF9TVFJPS0UsXG4gICAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgICAgcmFuZ2U6IFwibmVhcmVzdFwiXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIGNhc2UgXCJjYW5kbGVzdGlja1wiOlxuICAgICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6IFwiY2FuZGxlc3RpY2tcIixcbiAgICAgICAgICAuLi5jb21tb24sXG4gICAgICAgICAgLi4ua2V5c1xuICAgICAgICB9XG4gICAgICBdO1xuICAgIGNhc2UgXCJob2xsb3ctY2FuZGxlc3RpY2tcIjpcbiAgICAgIGNvbnN0IGl0ZW0gPSBmcm9tVGhlbWUodGhlbWUsICh0KSA9PiB0Lm92ZXJyaWRlcz8uY2FuZGxlc3RpY2s/LnNlcmllcz8uaXRlbSk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJjYW5kbGVzdGlja1wiLFxuICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAuLi5rZXlzLFxuICAgICAgICAgIGl0ZW06IHtcbiAgICAgICAgICAgIHVwOiB7XG4gICAgICAgICAgICAgIGZpbGw6IGl0ZW0/LnVwPy5maWxsID8/IFwidHJhbnNwYXJlbnRcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXTtcbiAgICBkZWZhdWx0OlxuICAgICAgTG9nZ2VyLndhcm5PbmNlKGB1bmtub3duIGNoYXJ0IHR5cGU6ICR7Y2hhcnRUeXBlMn07IGV4cGVjdGVkIG9uZSBvZjogJHtjaGFydFR5cGVzMi5qb2luKFwiLCBcIil9YCk7XG4gICAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJjYW5kbGVzdGlja1wiLFxuICAgICAgICAgIC4uLmNvbW1vbixcbiAgICAgICAgICAuLi5rZXlzXG4gICAgICAgIH1cbiAgICAgIF07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRoZW1lQ29sb3JzKHNlcmllc1R5cGUyLCB0aGVtZSkge1xuICBjb25zdCBmaWxsID0gZnJvbVRoZW1lKHRoZW1lLCAodCkgPT4gdC5vdmVycmlkZXM/LltzZXJpZXNUeXBlMl0/LnNlcmllcz8uZmlsbCk7XG4gIGNvbnN0IHN0cm9rZSA9IGZyb21UaGVtZSh0aGVtZSwgKHQpID0+IHQub3ZlcnJpZGVzPy5bc2VyaWVzVHlwZTJdPy5zZXJpZXM/LnN0cm9rZSk7XG4gIHJldHVybiB7IGZpbGwsIHN0cm9rZSB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9hcGkvcHJlc2V0L3ByZXNldHMudHNcbnZhciBQUkVTRVRTID0ge1xuICBcInByaWNlLXZvbHVtZVwiOiBwcmljZVZvbHVtZVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvZmFjdG9yeS9wcm9jZXNzRW50ZXJwcmlzZU9wdGlvbnMudHNcbmZ1bmN0aW9uIHJlbW92ZVVzZWRFbnRlcnByaXNlT3B0aW9ucyhvcHRpb25zLCBzaWxlbnQpIHtcbiAgY29uc3QgdXNlZE9wdGlvbnMgPSBbXTtcbiAgY29uc3Qgb3B0aW9uc0NoYXJ0VHlwZSA9IGNoYXJ0VHlwZXMuZ2V0KG9wdGlvbnNUeXBlKG9wdGlvbnMpKTtcbiAgZm9yIChjb25zdCB7XG4gICAgdHlwZSxcbiAgICBjaGFydFR5cGVzOiBtb2R1bGVDaGFydFR5cGVzLFxuICAgIG9wdGlvbnNLZXksXG4gICAgb3B0aW9uc0lubmVyS2V5LFxuICAgIGlkZW50aWZpZXJcbiAgfSBvZiBFWFBFQ1RFRF9FTlRFUlBSSVNFX01PRFVMRVMpIHtcbiAgICBpZiAob3B0aW9uc0NoYXJ0VHlwZSAhPT0gXCJ1bmtub3duXCIgJiYgIW1vZHVsZUNoYXJ0VHlwZXMuaW5jbHVkZXMob3B0aW9uc0NoYXJ0VHlwZSkpXG4gICAgICBjb250aW51ZTtcbiAgICBpZiAodHlwZSA9PT0gXCJyb290XCIgfHwgdHlwZSA9PT0gXCJsZWdlbmRcIikge1xuICAgICAgY29uc3Qgb3B0aW9uVmFsdWUgPSBvcHRpb25zW29wdGlvbnNLZXldO1xuICAgICAgaWYgKG9wdGlvblZhbHVlID09IG51bGwpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKCFvcHRpb25zSW5uZXJLZXkpIHtcbiAgICAgICAgdXNlZE9wdGlvbnMucHVzaChvcHRpb25zS2V5KTtcbiAgICAgICAgZGVsZXRlIG9wdGlvbnNbb3B0aW9uc0tleV07XG4gICAgICB9IGVsc2UgaWYgKG9wdGlvblZhbHVlW29wdGlvbnNJbm5lcktleV0pIHtcbiAgICAgICAgdXNlZE9wdGlvbnMucHVzaChgJHtvcHRpb25zS2V5fS4ke29wdGlvbnNJbm5lcktleX1gKTtcbiAgICAgICAgZGVsZXRlIG9wdGlvblZhbHVlW29wdGlvbnNJbm5lcktleV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImF4aXNcIikge1xuICAgICAgaWYgKCEoXCJheGVzXCIgaW4gb3B0aW9ucykgfHwgIW9wdGlvbnMuYXhlcz8uc29tZSgoYXhpcykgPT4gYXhpcy50eXBlID09PSBpZGVudGlmaWVyKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB1c2VkT3B0aW9ucy5wdXNoKGBheGlzW3R5cGU9JHtpZGVudGlmaWVyfV1gKTtcbiAgICAgIG9wdGlvbnMuYXhlcyA9IG9wdGlvbnMuYXhlcy5maWx0ZXIoKGF4aXMpID0+IGF4aXMudHlwZSAhPT0gaWRlbnRpZmllcik7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImF4aXMtb3B0aW9uXCIpIHtcbiAgICAgIGlmICghKFwiYXhlc1wiIGluIG9wdGlvbnMpIHx8ICFvcHRpb25zLmF4ZXM/LnNvbWUoKGF4aXMpID0+IGF4aXNbb3B0aW9uc0tleV0pKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHVzZWRPcHRpb25zLnB1c2goYGF4aXMuJHtvcHRpb25zS2V5fWApO1xuICAgICAgb3B0aW9ucy5heGVzLmZvckVhY2goKGF4aXMpID0+IHtcbiAgICAgICAgaWYgKGF4aXNbb3B0aW9uc0tleV0pIHtcbiAgICAgICAgICBkZWxldGUgYXhpc1tvcHRpb25zS2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcInNlcmllc1wiKSB7XG4gICAgICBpZiAoIW9wdGlvbnMuc2VyaWVzPy5zb21lKChzZXJpZXMpID0+IHNlcmllcy50eXBlID09PSBpZGVudGlmaWVyKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB1c2VkT3B0aW9ucy5wdXNoKGBzZXJpZXNbdHlwZT0ke2lkZW50aWZpZXJ9XWApO1xuICAgICAgb3B0aW9ucy5zZXJpZXMgPSBvcHRpb25zLnNlcmllcy5maWx0ZXIoKHNlcmllcykgPT4gc2VyaWVzLnR5cGUgIT09IGlkZW50aWZpZXIpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJzZXJpZXMtb3B0aW9uXCIpIHtcbiAgICAgIGlmICghb3B0aW9ucy5zZXJpZXM/LnNvbWUoKHNlcmllcykgPT4gc2VyaWVzW29wdGlvbnNLZXldKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB1c2VkT3B0aW9ucy5wdXNoKGBzZXJpZXMuJHtvcHRpb25zS2V5fWApO1xuICAgICAgb3B0aW9ucy5zZXJpZXMuZm9yRWFjaCgoc2VyaWVzKSA9PiB7XG4gICAgICAgIGlmIChzZXJpZXNbb3B0aW9uc0tleV0pIHtcbiAgICAgICAgICBkZWxldGUgc2VyaWVzW29wdGlvbnNLZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHVzZWRPcHRpb25zLmxlbmd0aCAmJiAhc2lsZW50KSB7XG4gICAgbGV0IGVudGVycHJpc2VQYWNrYWdlTmFtZSA9IFwiYWctY2hhcnRzLWVudGVycHJpc2VcIjtcbiAgICBsZXQgZW50ZXJwcmlzZVJlZmVyZW5jZVVybCA9IFwiaHR0cHM6Ly9jaGFydHMuYWctZ3JpZC5jb20vamF2YXNjcmlwdC9pbnN0YWxsYXRpb24vXCI7XG4gICAgaWYgKG9wdGlvbnMubW9kZSA9PT0gXCJpbnRlZ3JhdGVkXCIpIHtcbiAgICAgIGVudGVycHJpc2VQYWNrYWdlTmFtZSA9IFwiYWctZ3JpZC1jaGFydHMtZW50ZXJwcmlzZScgb3IgJ2FnLWdyaWQtZW50ZXJwcmlzZS9jaGFydHMtZW50ZXJwcmlzZVwiO1xuICAgICAgZW50ZXJwcmlzZVJlZmVyZW5jZVVybCA9IFwiaHR0cHM6Ly93d3cuYWctZ3JpZC5jb20vamF2YXNjcmlwdC1kYXRhLWdyaWQvaW50ZWdyYXRlZC1jaGFydHMtaW5zdGFsbGF0aW9uL1wiO1xuICAgIH1cbiAgICBMb2dnZXIud2Fybk9uY2UoXG4gICAgICBbXG4gICAgICAgIGB1bmFibGUgdG8gdXNlIHRoZXNlIGVudGVycHJpc2UgZmVhdHVyZXMgYXMgJyR7ZW50ZXJwcmlzZVBhY2thZ2VOYW1lfScgaGFzIG5vdCBiZWVuIGxvYWRlZDpgLFxuICAgICAgICBcIlwiLFxuICAgICAgICAuLi51c2VkT3B0aW9ucyxcbiAgICAgICAgXCJcIixcbiAgICAgICAgYFNlZTogJHtlbnRlcnByaXNlUmVmZXJlbmNlVXJsfWBcbiAgICAgIF0uam9pbihcIlxcblwiKVxuICAgICk7XG4gIH1cbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9zdHJpbmcudXRpbC50c1xuZnVuY3Rpb24gc3RyaW5naWZ5VmFsdWUodmFsdWUsIG1heExlbmd0aCA9IEluZmluaXR5KSB7XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gXCJOYU5cIjtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiBcIkluZmluaXR5XCI7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgcmV0dXJuIFwiLUluZmluaXR5XCI7XG4gICAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHZhbHVlID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICByZXR1cm4gYCR7dmFsdWUuc2xpY2UoMCwgbWF4TGVuZ3RoKX0uLi4gKCske3ZhbHVlLmxlbmd0aCAtIG1heExlbmd0aH0gY2hhcmFjdGVycylgO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdmFsaWRhdGUudHNcbnZhciBkZXNjcmlwdGlvblN5bWJvbCA9IFN5bWJvbChcImRlc2NyaXB0aW9uXCIpO1xudmFyIHJlcXVpcmVkU3ltYm9sID0gU3ltYm9sKFwicmVxdWlyZWRcIik7XG5mdW5jdGlvbiBpc1ZhbGlkKG9wdGlvbnMsIG9wdGlvbnNEZWZzLCBwYXRoKSB7XG4gIGNvbnN0IHsgZXJyb3JzIH0gPSB2YWxpZGF0ZShvcHRpb25zLCBvcHRpb25zRGVmcywgcGF0aCk7XG4gIGZvciAoY29uc3QgeyBtZXNzYWdlIH0gb2YgZXJyb3JzKSB7XG4gICAgTG9nZ2VyLndhcm4obWVzc2FnZSk7XG4gIH1cbiAgcmV0dXJuIGVycm9ycy5sZW5ndGggPT09IDA7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1lc3NhZ2UocGF0aCwgdmFsdWUsIHZhbGlkYXRvck9yRGVmcykge1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IGlzU3RyaW5nKHZhbGlkYXRvck9yRGVmcykgPyB2YWxpZGF0b3JPckRlZnMgOiB2YWxpZGF0b3JPckRlZnNbZGVzY3JpcHRpb25TeW1ib2xdO1xuICBjb25zdCBleHBlY3RpbmcgPSBkZXNjcmlwdGlvbiA/IGA7IGV4cGVjdGluZyAke2Rlc2NyaXB0aW9ufWAgOiBcIlwiO1xuICBjb25zdCBwcmVmaXggPSBwYXRoID8gYE9wdGlvbiBcXGAke3BhdGh9XFxgYCA6IFwiVmFsdWVcIjtcbiAgcmV0dXJuIGAke3ByZWZpeH0gY2Fubm90IGJlIHNldCB0byBcXGAke3N0cmluZ2lmeVZhbHVlKHZhbHVlKX1cXGAke2V4cGVjdGluZ30sIGlnbm9yaW5nLmA7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZShvcHRpb25zLCBvcHRpb25zRGVmcywgcGF0aCA9IFwiXCIpIHtcbiAgaWYgKCFpc09iamVjdChvcHRpb25zKSkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWxpZDogbnVsbCxcbiAgICAgIGVycm9yczogW3sgcGF0aCwgdmFsdWU6IG9wdGlvbnMsIG1lc3NhZ2U6IHZhbGlkYXRlTWVzc2FnZShwYXRoLCBvcHRpb25zLCBcImFuIG9iamVjdFwiKSB9XVxuICAgIH07XG4gIH1cbiAgY29uc3Qgb3B0aW9uc0tleXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKG9wdGlvbnMpKTtcbiAgY29uc3QgZXJyb3JzID0gW107XG4gIGNvbnN0IHZhbGlkID0ge307XG4gIGZ1bmN0aW9uIGV4dGVuZFBhdGgoa2V5KSB7XG4gICAgaWYgKGlzQXJyYXkob3B0aW9uc0RlZnMpKSB7XG4gICAgICByZXR1cm4gYCR7cGF0aH1bJHtrZXl9XWA7XG4gICAgfVxuICAgIHJldHVybiBwYXRoID8gYCR7cGF0aH0uJHtrZXl9YCA6IGtleTtcbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHZhbGlkYXRvck9yRGVmc10gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9uc0RlZnMpKSB7XG4gICAgb3B0aW9uc0tleXMuZGVsZXRlKGtleSk7XG4gICAgY29uc3QgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgaWYgKCF2YWxpZGF0b3JPckRlZnNbcmVxdWlyZWRTeW1ib2xdICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbGlkYXRvck9yRGVmcykpIHtcbiAgICAgIGlmICh2YWxpZGF0b3JPckRlZnModmFsdWUpKSB7XG4gICAgICAgIHZhbGlkW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHsga2V5LCBwYXRoLCB2YWx1ZSwgbWVzc2FnZTogdmFsaWRhdGVNZXNzYWdlKGV4dGVuZFBhdGgoa2V5KSwgdmFsdWUsIHZhbGlkYXRvck9yRGVmcykgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5lc3RlZFJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCB2YWxpZGF0b3JPckRlZnMsIGV4dGVuZFBhdGgoa2V5KSk7XG4gICAgICB2YWxpZFtrZXldID0gbmVzdGVkUmVzdWx0LnZhbGlkO1xuICAgICAgZXJyb3JzLnB1c2goLi4ubmVzdGVkUmVzdWx0LmVycm9ycyk7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIG9wdGlvbnNLZXlzKSB7XG4gICAgZXJyb3JzLnB1c2goe1xuICAgICAga2V5LFxuICAgICAgcGF0aCxcbiAgICAgIHVua25vd246IHRydWUsXG4gICAgICBtZXNzYWdlOiBgVW5rbm93biBvcHRpb24gXFxgJHtleHRlbmRQYXRoKGtleSl9XFxgLCBpZ25vcmluZy5gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHsgdmFsaWQsIGVycm9ycyB9O1xufVxuZnVuY3Rpb24gYXR0YWNoRGVzY3JpcHRpb24odmFsaWRhdG9yLCBkZXNjcmlwdGlvbikge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbigodmFsdWUpID0+IHZhbGlkYXRvcih2YWx1ZSksIHsgW2Rlc2NyaXB0aW9uU3ltYm9sXTogZGVzY3JpcHRpb24gfSk7XG59XG52YXIgb3IgPSAoLi4udmFsaWRhdG9ycykgPT4gYXR0YWNoRGVzY3JpcHRpb24oXG4gICh2YWx1ZSkgPT4gdmFsaWRhdG9ycy5zb21lKCh2YWxpZGF0b3IpID0+IHZhbGlkYXRvcih2YWx1ZSkpLFxuICB2YWxpZGF0b3JzLm1hcCgodikgPT4gdltkZXNjcmlwdGlvblN5bWJvbF0pLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIG9yIFwiKVxuKTtcbnZhciBhcnJheSA9IGF0dGFjaERlc2NyaXB0aW9uKGlzQXJyYXksIFwiYW4gYXJyYXlcIik7XG52YXIgYm9vbGVhbiA9IGF0dGFjaERlc2NyaXB0aW9uKGlzQm9vbGVhbiwgXCJhIGJvb2xlYW5cIik7XG52YXIgY2FsbGJhY2sgPSBhdHRhY2hEZXNjcmlwdGlvbihpc0Z1bmN0aW9uLCBcImEgZnVuY3Rpb25cIik7XG52YXIgbnVtYmVyID0gYXR0YWNoRGVzY3JpcHRpb24oaXNGaW5pdGVOdW1iZXIsIFwiYSBudW1iZXJcIik7XG52YXIgb2JqZWN0ID0gYXR0YWNoRGVzY3JpcHRpb24oaXNPYmplY3QsIFwiYW4gb2JqZWN0XCIpO1xudmFyIHN0cmluZyA9IGF0dGFjaERlc2NyaXB0aW9uKGlzU3RyaW5nLCBcImEgc3RyaW5nXCIpO1xudmFyIG51bWJlck1pbiA9IChtaW4sIGluY2x1c2l2ZSA9IHRydWUpID0+IGF0dGFjaERlc2NyaXB0aW9uKFxuICAodmFsdWUpID0+IGlzRmluaXRlTnVtYmVyKHZhbHVlKSAmJiAodmFsdWUgPiBtaW4gfHwgaW5jbHVzaXZlICYmIHZhbHVlID09PSBtaW4pLFxuICBgYSBudW1iZXIgZ3JlYXRlciB0aGFuICR7aW5jbHVzaXZlID8gXCJvciBlcXVhbCB0byBcIiA6IFwiXCJ9JHttaW59YFxuKTtcbnZhciBudW1iZXJSYW5nZSA9IChtaW4sIG1heCkgPT4gYXR0YWNoRGVzY3JpcHRpb24oXG4gICh2YWx1ZSkgPT4gaXNGaW5pdGVOdW1iZXIodmFsdWUpICYmIHZhbHVlID49IG1pbiAmJiB2YWx1ZSA8PSBtYXgsXG4gIGBhIG51bWJlciBiZXR3ZWVuICR7bWlufSBhbmQgJHttYXh9IGluY2x1c2l2ZWBcbik7XG52YXIgcG9zaXRpdmVOdW1iZXIgPSBudW1iZXJNaW4oMCk7XG52YXIgbWluT25lTnVtYmVyID0gbnVtYmVyTWluKDEpO1xudmFyIHJhdGlvID0gbnVtYmVyUmFuZ2UoMCwgMSk7XG52YXIgZGVncmVlID0gbnVtYmVyUmFuZ2UoMCwgMzYwKTtcbnZhciBhcnJheU9mID0gKHZhbGlkYXRvciwgZGVzY3JpcHRpb24pID0+IGF0dGFjaERlc2NyaXB0aW9uKFxuICAodmFsdWUpID0+IGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KHZhbGlkYXRvciksXG4gIGRlc2NyaXB0aW9uID8/IGAke3ZhbGlkYXRvcltkZXNjcmlwdGlvblN5bWJvbF19IGFycmF5YFxuKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW9kdWxlL2NvcmVNb2R1bGVzVHlwZXMudHNcbmZ1bmN0aW9uIHBhbGV0dGVUeXBlKHBhcnRpYWwpIHtcbiAgaWYgKHBhcnRpYWw/LnVwIHx8IHBhcnRpYWw/LmRvd24gfHwgcGFydGlhbD8ubmV1dHJhbCkge1xuICAgIHJldHVybiBcInVzZXItZnVsbFwiO1xuICB9IGVsc2UgaWYgKHBhcnRpYWw/LmZpbGxzIHx8IHBhcnRpYWw/LnN0cm9rZXMpIHtcbiAgICByZXR1cm4gXCJ1c2VyLWluZGV4ZWRcIjtcbiAgfVxuICByZXR1cm4gXCJpbmJ1aWx0XCI7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9jaGFydFRoZW1lLnRzXG52YXIgREVGQVVMVF9CQUNLR1JPVU5EX0ZJTEwgPSBcIndoaXRlXCI7XG52YXIgQ0hBUlRfVFlQRV9DT05GSUcgPSB7XG4gIGdldCBjYXJ0ZXNpYW4oKSB7XG4gICAgcmV0dXJuIHsgc2VyaWVzVHlwZXM6IGNoYXJ0VHlwZXMuY2FydGVzaWFuVHlwZXMsIGNvbW1vbk9wdGlvbnM6IFtcInpvb21cIiwgXCJuYXZpZ2F0b3JcIl0gfTtcbiAgfSxcbiAgZ2V0IHBvbGFyKCkge1xuICAgIHJldHVybiB7IHNlcmllc1R5cGVzOiBjaGFydFR5cGVzLnBvbGFyVHlwZXMsIGNvbW1vbk9wdGlvbnM6IFtdIH07XG4gIH0sXG4gIGdldCBoaWVyYXJjaHkoKSB7XG4gICAgcmV0dXJuIHsgc2VyaWVzVHlwZXM6IGNoYXJ0VHlwZXMuaGllcmFyY2h5VHlwZXMsIGNvbW1vbk9wdGlvbnM6IFtdIH07XG4gIH0sXG4gIGdldCB0b3BvbG9neSgpIHtcbiAgICByZXR1cm4geyBzZXJpZXNUeXBlczogY2hhcnRUeXBlcy50b3BvbG9neVR5cGVzLCBjb21tb25PcHRpb25zOiBbXSB9O1xuICB9LFxuICBnZXQgXCJmbG93LXByb3BvcnRpb25cIigpIHtcbiAgICByZXR1cm4geyBzZXJpZXNUeXBlczogY2hhcnRUeXBlcy5mbG93UHJvcG9ydGlvblR5cGVzLCBjb21tb25PcHRpb25zOiBbXSB9O1xuICB9XG59O1xudmFyIENIQVJUX1RZUEVfU1BFQ0lGSUNfQ09NTU9OX09QVElPTlMgPSBPYmplY3QudmFsdWVzKENIQVJUX1RZUEVfQ09ORklHKS5yZWR1Y2UoKHIsIHsgY29tbW9uT3B0aW9ucyB9KSA9PiByLmNvbmNhdChjb21tb25PcHRpb25zKSwgW10pO1xudmFyIF9DaGFydFRoZW1lID0gY2xhc3MgX0NoYXJ0VGhlbWUge1xuICBzdGF0aWMgZ2V0QXhpc0RlZmF1bHRzKG92ZXJyaWRlRGVmYXVsdHMpIHtcbiAgICByZXR1cm4gbWVyZ2VEZWZhdWx0cyhvdmVycmlkZURlZmF1bHRzLCB7XG4gICAgICB0aXRsZToge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgdGV4dDogXCJBeGlzIFRpdGxlXCIsXG4gICAgICAgIHNwYWNpbmc6IDI1LFxuICAgICAgICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiIC8qIE5PUk1BTCAqLyxcbiAgICAgICAgZm9udFNpemU6IDEzIC8qIE1FRElVTSAqLyxcbiAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgICAgY29sb3I6IERFRkFVTFRfTEFCRUxfQ09MT1VSXG4gICAgICB9LFxuICAgICAgbGFiZWw6IHtcbiAgICAgICAgZm9udFNpemU6IDEyIC8qIFNNQUxMICovLFxuICAgICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgICBwYWRkaW5nOiA1LFxuICAgICAgICBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVIsXG4gICAgICAgIGF2b2lkQ29sbGlzaW9uczogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGxpbmU6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgIHN0cm9rZTogREVGQVVMVF9BWElTX0xJTkVfQ09MT1VSXG4gICAgICB9LFxuICAgICAgdGljazoge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgd2lkdGg6IDEsXG4gICAgICAgIHN0cm9rZTogREVGQVVMVF9BWElTX0xJTkVfQ09MT1VSXG4gICAgICB9LFxuICAgICAgZ3JpZExpbmU6IHtcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgc3R5bGU6IFt7IHN0cm9rZTogREVGQVVMVF9BWElTX0dSSURfQ09MT1VSLCBsaW5lRGFzaDogW10gfV1cbiAgICAgIH0sXG4gICAgICBjcm9zc0xpbmVzOiB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgICAgICBmaWxsOiBERUZBVUxUX0NST1NTX0xJTkVTX0NPTE9VUixcbiAgICAgICAgc3Ryb2tlOiBERUZBVUxUX0NST1NTX0xJTkVTX0NPTE9VUixcbiAgICAgICAgZmlsbE9wYWNpdHk6IDAuMSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IDEsXG4gICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgICAgZm9udFNpemU6IDEyIC8qIFNNQUxMICovLFxuICAgICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICAgICAgcGFkZGluZzogNSxcbiAgICAgICAgICBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNyb3NzaGFpcjoge1xuICAgICAgICBlbmFibGVkOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0Q2hhcnREZWZhdWx0cygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWluSGVpZ2h0OiAzMDAsXG4gICAgICBtaW5XaWR0aDogMzAwLFxuICAgICAgYmFja2dyb3VuZDogeyB2aXNpYmxlOiB0cnVlLCBmaWxsOiBERUZBVUxUX0JBQ0tHUk9VTkRfQ09MT1VSIH0sXG4gICAgICBwYWRkaW5nOiB7IHRvcDogREVGQVVMVF9QQURESU5HLCByaWdodDogREVGQVVMVF9QQURESU5HLCBib3R0b206IERFRkFVTFRfUEFERElORywgbGVmdDogREVGQVVMVF9QQURESU5HIH0sXG4gICAgICBrZXlib2FyZDogeyBlbmFibGVkOiB0cnVlIH0sXG4gICAgICB0aXRsZToge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgdGV4dDogXCJUaXRsZVwiLFxuICAgICAgICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiIC8qIE5PUk1BTCAqLyxcbiAgICAgICAgZm9udFNpemU6IDE3IC8qIExBUkdFICovLFxuICAgICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZLFxuICAgICAgICBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVIsXG4gICAgICAgIHdyYXBwaW5nOiBcImh5cGhlbmF0ZVwiLFxuICAgICAgICBsYXlvdXRTdHlsZTogREVGQVVMVF9DQVBUSU9OX0xBWU9VVF9TVFlMRSxcbiAgICAgICAgdGV4dEFsaWduOiBERUZBVUxUX0NBUFRJT05fQUxJR05NRU5UXG4gICAgICB9LFxuICAgICAgc3VidGl0bGU6IHtcbiAgICAgICAgZW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHRleHQ6IFwiU3VidGl0bGVcIixcbiAgICAgICAgc3BhY2luZzogMjAsXG4gICAgICAgIGZvbnRTaXplOiAxMyAvKiBNRURJVU0gKi8sXG4gICAgICAgIGZvbnRGYW1pbHk6IERFRkFVTFRfRk9OVF9GQU1JTFksXG4gICAgICAgIGNvbG9yOiBERUZBVUxUX01VVEVEX0xBQkVMX0NPTE9VUixcbiAgICAgICAgd3JhcHBpbmc6IFwiaHlwaGVuYXRlXCIsXG4gICAgICAgIGxheW91dFN0eWxlOiBERUZBVUxUX0NBUFRJT05fTEFZT1VUX1NUWUxFLFxuICAgICAgICB0ZXh0QWxpZ246IERFRkFVTFRfQ0FQVElPTl9BTElHTk1FTlRcbiAgICAgIH0sXG4gICAgICBmb290bm90ZToge1xuICAgICAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAgICAgdGV4dDogXCJGb290bm90ZVwiLFxuICAgICAgICBzcGFjaW5nOiAyMCxcbiAgICAgICAgZm9udFNpemU6IDEzIC8qIE1FRElVTSAqLyxcbiAgICAgICAgZm9udEZhbWlseTogREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgICAgICAgY29sb3I6IFwicmdiKDE0MCwgMTQwLCAxNDApXCIsXG4gICAgICAgIHdyYXBwaW5nOiBcImh5cGhlbmF0ZVwiLFxuICAgICAgICBsYXlvdXRTdHlsZTogREVGQVVMVF9DQVBUSU9OX0xBWU9VVF9TVFlMRSxcbiAgICAgICAgdGV4dEFsaWduOiBERUZBVUxUX0NBUFRJT05fQUxJR05NRU5UXG4gICAgICB9LFxuICAgICAgbGVnZW5kOiB7XG4gICAgICAgIHBvc2l0aW9uOiBcImJvdHRvbVwiIC8qIEJPVFRPTSAqLyxcbiAgICAgICAgc3BhY2luZzogMzAsXG4gICAgICAgIGxpc3RlbmVyczoge30sXG4gICAgICAgIHRvZ2dsZVNlcmllczogdHJ1ZSxcbiAgICAgICAgaXRlbToge1xuICAgICAgICAgIHBhZGRpbmdYOiAxNixcbiAgICAgICAgICBwYWRkaW5nWTogOCxcbiAgICAgICAgICBtYXJrZXI6IHsgc2l6ZTogMTUsIHBhZGRpbmc6IDggfSxcbiAgICAgICAgICBzaG93U2VyaWVzU3Ryb2tlOiB0cnVlLFxuICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVIsXG4gICAgICAgICAgICBmb250U2l6ZTogMTIgLyogU01BTEwgKi8sXG4gICAgICAgICAgICBmb250RmFtaWx5OiBERUZBVUxUX0ZPTlRfRkFNSUxZXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZXZlcnNlT3JkZXI6IGZhbHNlLFxuICAgICAgICBwYWdpbmF0aW9uOiB7XG4gICAgICAgICAgbWFya2VyOiB7IHNpemU6IDEyIH0sXG4gICAgICAgICAgYWN0aXZlU3R5bGU6IHsgZmlsbDogREVGQVVMVF9MQUJFTF9DT0xPVVIgfSxcbiAgICAgICAgICBpbmFjdGl2ZVN0eWxlOiB7IGZpbGw6IERFRkFVTFRfTVVURURfTEFCRUxfQ09MT1VSIH0sXG4gICAgICAgICAgaGlnaGxpZ2h0U3R5bGU6IHsgZmlsbDogREVGQVVMVF9MQUJFTF9DT0xPVVIgfSxcbiAgICAgICAgICBsYWJlbDogeyBjb2xvcjogREVGQVVMVF9MQUJFTF9DT0xPVVIgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdG9vbHRpcDoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBkYXJrVGhlbWU6IElTX0RBUktfVEhFTUUsXG4gICAgICAgIGRlbGF5OiAwXG4gICAgICB9LFxuICAgICAgb3ZlcmxheXM6IHsgZGFya1RoZW1lOiBJU19EQVJLX1RIRU1FIH0sXG4gICAgICBsaXN0ZW5lcnM6IHt9XG4gICAgfTtcbiAgfVxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IG92ZXJyaWRlcywgcGFsZXR0ZSB9ID0gZGVlcENsb25lKG9wdGlvbnMpO1xuICAgIGNvbnN0IGRlZmF1bHRzID0gdGhpcy5jcmVhdGVDaGFydENvbmZpZ1BlckNoYXJ0VHlwZSh0aGlzLmdldERlZmF1bHRzKCkpO1xuICAgIGlmIChvdmVycmlkZXMpIHtcbiAgICAgIHRoaXMubWVyZ2VPdmVycmlkZXMoZGVmYXVsdHMsIG92ZXJyaWRlcyk7XG4gICAgfVxuICAgIGNvbnN0IHsgZmlsbHMsIHN0cm9rZXMsIC4uLm90aGVyQ29sb3JzIH0gPSB0aGlzLmdldERlZmF1bHRDb2xvcnMoKTtcbiAgICB0aGlzLnBhbGV0dGUgPSBtZXJnZURlZmF1bHRzKHBhbGV0dGUsIHtcbiAgICAgIGZpbGxzOiBPYmplY3QudmFsdWVzKGZpbGxzKSxcbiAgICAgIHN0cm9rZXM6IE9iamVjdC52YWx1ZXMoc3Ryb2tlcyksXG4gICAgICAuLi5vdGhlckNvbG9yc1xuICAgIH0pO1xuICAgIHRoaXMucGFsZXR0ZVR5cGUgPSBwYWxldHRlVHlwZShwYWxldHRlKTtcbiAgICB0aGlzLmNvbmZpZyA9IE9iamVjdC5mcmVlemUodGhpcy50ZW1wbGF0ZVRoZW1lKGRlZmF1bHRzKSk7XG4gIH1cbiAgbWVyZ2VPdmVycmlkZXMoZGVmYXVsdHMsIG92ZXJyaWRlcykge1xuICAgIGZvciAoY29uc3QgeyBzZXJpZXNUeXBlcywgY29tbW9uT3B0aW9ucyB9IG9mIE9iamVjdC52YWx1ZXMoQ0hBUlRfVFlQRV9DT05GSUcpKSB7XG4gICAgICBjb25zdCBjbGVhbmVkQ29tbW9uID0geyAuLi5vdmVycmlkZXMuY29tbW9uIH07XG4gICAgICBmb3IgKGNvbnN0IGNvbW1vbktleSBvZiBDSEFSVF9UWVBFX1NQRUNJRklDX0NPTU1PTl9PUFRJT05TKSB7XG4gICAgICAgIGlmICghY29tbW9uT3B0aW9ucy5pbmNsdWRlcyhjb21tb25LZXkpKSB7XG4gICAgICAgICAgZGVsZXRlIGNsZWFuZWRDb21tb25bY29tbW9uS2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFjbGVhbmVkQ29tbW9uKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGZvciAoY29uc3QgcyBvZiBzZXJpZXNUeXBlcykge1xuICAgICAgICBjb25zdCBzZXJpZXNUeXBlMiA9IHM7XG4gICAgICAgIGRlZmF1bHRzW3Nlcmllc1R5cGUyXSA9IG1lcmdlRGVmYXVsdHMoY2xlYW5lZENvbW1vbiwgZGVmYXVsdHNbc2VyaWVzVHlwZTJdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY2hhcnRUeXBlcy5zZXJpZXNUeXBlcy5mb3JFYWNoKChzKSA9PiB7XG4gICAgICBjb25zdCBzZXJpZXNUeXBlMiA9IHM7XG4gICAgICBpZiAob3ZlcnJpZGVzW3Nlcmllc1R5cGUyXSkge1xuICAgICAgICBkZWZhdWx0c1tzZXJpZXNUeXBlMl0gPSBtZXJnZURlZmF1bHRzKG92ZXJyaWRlc1tzZXJpZXNUeXBlMl0sIGRlZmF1bHRzW3Nlcmllc1R5cGUyXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlQ2hhcnRDb25maWdQZXJDaGFydFR5cGUoY29uZmlnKSB7XG4gICAgZm9yIChjb25zdCBbbmV4dFR5cGUsIHsgc2VyaWVzVHlwZXMgfV0gb2YgT2JqZWN0LmVudHJpZXMoQ0hBUlRfVFlQRV9DT05GSUcpKSB7XG4gICAgICBjb25zdCB0eXBlRGVmYXVsdHMgPSBjaGFydERlZmF1bHRzLmdldChuZXh0VHlwZSk7XG4gICAgICBmb3IgKGNvbnN0IHNlcmllc1R5cGUyIG9mIHNlcmllc1R5cGVzKSB7XG4gICAgICAgIGNvbmZpZ1tzZXJpZXNUeXBlMl0gfHwgKGNvbmZpZ1tzZXJpZXNUeXBlMl0gPSBkZWVwQ2xvbmUodHlwZURlZmF1bHRzKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb25maWc7XG4gIH1cbiAgZ2V0RGVmYXVsdHMoKSB7XG4gICAgY29uc3QgZ2V0T3ZlcnJpZGVzQnlUeXBlID0gKGNoYXJ0VHlwZTIsIHNlcmllc1R5cGVzKSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgIGNvbnN0IGNoYXJ0VHlwZURlZmF1bHRzID0ge1xuICAgICAgICBheGVzOiB7fSxcbiAgICAgICAgLi4ubGVnZW5kUmVnaXN0cnkuZ2V0VGhlbWVUZW1wbGF0ZXMoKSxcbiAgICAgICAgLi4udGhpcy5nZXRDaGFydERlZmF1bHRzKCksXG4gICAgICAgIC4uLmNoYXJ0RGVmYXVsdHMuZ2V0KGNoYXJ0VHlwZTIpXG4gICAgICB9O1xuICAgICAgZm9yIChjb25zdCBzZXJpZXNUeXBlMiBvZiBzZXJpZXNUeXBlcykge1xuICAgICAgICByZXN1bHRbc2VyaWVzVHlwZTJdID0gbWVyZ2VEZWZhdWx0cyhcbiAgICAgICAgICBzZXJpZXNSZWdpc3RyeS5nZXRUaGVtZVRlbXBsYXRlKHNlcmllc1R5cGUyKSxcbiAgICAgICAgICByZXN1bHRbc2VyaWVzVHlwZTJdID8/IGRlZXBDbG9uZShjaGFydFR5cGVEZWZhdWx0cylcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgeyBheGVzIH0gPSByZXN1bHRbc2VyaWVzVHlwZTJdO1xuICAgICAgICBmb3IgKGNvbnN0IGF4aXNUeXBlIG9mIGF4aXNSZWdpc3RyeS5rZXlzKCkpIHtcbiAgICAgICAgICBheGVzW2F4aXNUeXBlXSA9IG1lcmdlRGVmYXVsdHMoXG4gICAgICAgICAgICBheGVzW2F4aXNUeXBlXSxcbiAgICAgICAgICAgIGF4aXNSZWdpc3RyeS5nZXRUaGVtZVRlbXBsYXRlKGF4aXNUeXBlKSxcbiAgICAgICAgICAgIF9DaGFydFRoZW1lLmNhcnRlc2lhbkF4aXNEZWZhdWx0W2F4aXNUeXBlXVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gbWVyZ2VEZWZhdWx0cyhcbiAgICAgIGdldE92ZXJyaWRlc0J5VHlwZShcImNhcnRlc2lhblwiLCBjaGFydFR5cGVzLmNhcnRlc2lhblR5cGVzKSxcbiAgICAgIGdldE92ZXJyaWRlc0J5VHlwZShcInBvbGFyXCIsIGNoYXJ0VHlwZXMucG9sYXJUeXBlcyksXG4gICAgICBnZXRPdmVycmlkZXNCeVR5cGUoXCJoaWVyYXJjaHlcIiwgY2hhcnRUeXBlcy5oaWVyYXJjaHlUeXBlcyksXG4gICAgICBnZXRPdmVycmlkZXNCeVR5cGUoXCJ0b3BvbG9neVwiLCBjaGFydFR5cGVzLnRvcG9sb2d5VHlwZXMpLFxuICAgICAgZ2V0T3ZlcnJpZGVzQnlUeXBlKFwiZmxvdy1wcm9wb3J0aW9uXCIsIGNoYXJ0VHlwZXMuZmxvd1Byb3BvcnRpb25UeXBlcylcbiAgICApO1xuICB9XG4gIHRlbXBsYXRlVGhlbWUodGhlbWVUZW1wbGF0ZSkge1xuICAgIGNvbnN0IHRoZW1lSW5zdGFuY2UgPSBkZWVwQ2xvbmUodGhlbWVUZW1wbGF0ZSk7XG4gICAgY29uc3QgcGFyYW1zID0gdGhpcy5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBqc29uV2Fsayh0aGVtZUluc3RhbmNlLCAobm9kZSkgPT4ge1xuICAgICAgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc3ltYm9sID0gbm9kZVtpXTtcbiAgICAgICAgICBpZiAocGFyYW1zLmhhcyhzeW1ib2wpKSB7XG4gICAgICAgICAgICBub2RlW2ldID0gcGFyYW1zLmdldChzeW1ib2wpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG5vZGUpKSB7XG4gICAgICAgICAgaWYgKHBhcmFtcy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICBub2RlW25hbWVdID0gcGFyYW1zLmdldCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGRlZXBDbG9uZSh0aGVtZUluc3RhbmNlKTtcbiAgfVxuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogREVGQVVMVF9GSUxMUyxcbiAgICAgIHN0cm9rZXM6IERFRkFVTFRfU1RST0tFUyxcbiAgICAgIHVwOiB7IGZpbGw6IERFRkFVTFRfRklMTFMuR1JFRU4sIHN0cm9rZTogREVGQVVMVF9TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IERFRkFVTFRfRklMTFMuUkVELCBzdHJva2U6IERFRkFVTFRfU1RST0tFUy5SRUQgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogREVGQVVMVF9GSUxMUy5HUkFZLCBzdHJva2U6IERFRkFVTFRfU1RST0tFUy5HUkFZIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBERUZBVUxUX0ZJTExTLkJMVUUsIHN0cm9rZTogREVGQVVMVF9TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogREVGQVVMVF9GSUxMUy5PUkFOR0UsIHN0cm9rZTogREVGQVVMVF9TVFJPS0VTLk9SQU5HRSB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBERUZBVUxUX0ZJTExTLkdSQVksIHN0cm9rZTogREVGQVVMVF9TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgcGFyYW1zLnNldChJU19EQVJLX1RIRU1FLCBmYWxzZSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0ZPTlRfRkFNSUxZLCBcIlZlcmRhbmEsIHNhbnMtc2VyaWZcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0xBQkVMX0NPTE9VUiwgXCJyZ2IoNzAsIDcwLCA3MClcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0lOVkVSVEVEX0xBQkVMX0NPTE9VUiwgXCJ3aGl0ZVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfTVVURURfTEFCRUxfQ09MT1VSLCBcInJnYigxNDAsIDE0MCwgMTQwKVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQVhJU19HUklEX0NPTE9VUiwgXCJyZ2IoMjI0LDIzNCwyNDEpXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BWElTX0xJTkVfQ09MT1VSLCBcInJnYigxOTUsIDE5NSwgMTk1KVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQ1JPU1NfTElORVNfQ09MT1VSLCBcInJnYig3MCwgNzAsIDcwKVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfSU5TSURFX1NFUklFU19MQUJFTF9DT0xPVVIsIERFRkFVTFRfQkFDS0dST1VORF9GSUxMKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQkFDS0dST1VORF9DT0xPVVIsIERFRkFVTFRfQkFDS0dST1VORF9GSUxMKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfU0hBRE9XX0NPTE9VUiwgXCJyZ2JhKDAsIDAsIDAsIDAuNSlcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1VSX1JBTkdFLCBbXG4gICAgICBERUZBVUxUX0ZJTExTLk9SQU5HRSxcbiAgICAgIERFRkFVTFRfRklMTFMuWUVMTE9XLFxuICAgICAgREVGQVVMVF9GSUxMUy5HUkVFTlxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9QQURESU5HLCAyMCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0NBUFRJT05fTEFZT1VUX1NUWUxFLCBcImJsb2NrXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9DQVBUSU9OX0FMSUdOTUVOVCwgXCJjZW50ZXJcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0hJRVJBUkNIWV9GSUxMUywgW1wiI2ZmZmZmZlwiLCBcIiNlMGU1ZWFcIiwgXCIjYzFjY2Q1XCIsIFwiI2EzYjRjMVwiLCBcIiM4NTljYWRcIl0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ISUVSQVJDSFlfU1RST0tFUywgW1wiI2ZmZmZmZlwiLCBcIiNjNWNiZDFcIiwgXCIjYTRiMWJkXCIsIFwiIzg0OThhOVwiLCBcIiM2NDgwOTZcIl0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9QT0xBUl9TRVJJRVNfU1RST0tFLCBERUZBVUxUX0JBQ0tHUk9VTkRfRklMTCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQ09MT1IsIERFRkFVTFRfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1RFWFRfQU5OT1RBVElPTl9DT0xPUiwgREVGQVVMVF9GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIERFRkFVTFRfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fSEFORExFX0ZJTEwsIERFRkFVTFRfQkFDS0dST1VORF9GSUxMKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVEVYVEJPWF9GSUxMLCBcIiNmYWZhZmFcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1RFWFRCT1hfU1RST0tFLCBcIiNkZGRkZGRcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1RFWFRCT1hfQ09MT1IsIFwiIzAwMDAwMFwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVE9PTEJBUl9QT1NJVElPTiwgXCJ0b3BcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0dSSURMSU5FX0VOQUJMRUQsIGZhbHNlKTtcbiAgICBjb25zdCBkZWZhdWx0Q29sb3JzID0gdGhpcy5nZXREZWZhdWx0Q29sb3JzKCk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX1VQX1NUUk9LRSwgdGhpcy5wYWxldHRlLnVwPy5zdHJva2UgPz8gZGVmYXVsdENvbG9ycy51cC5zdHJva2UpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9VUF9GSUxMLCB0aGlzLnBhbGV0dGUudXA/LmZpbGwgPz8gZGVmYXVsdENvbG9ycy51cC5maWxsKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfRE9XTl9TVFJPS0UsIHRoaXMucGFsZXR0ZS5kb3duPy5zdHJva2UgPz8gZGVmYXVsdENvbG9ycy5kb3duLnN0cm9rZSk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX0RPV05fRklMTCwgdGhpcy5wYWxldHRlLmRvd24/LmZpbGwgPz8gZGVmYXVsdENvbG9ycy5kb3duLmZpbGwpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9ORVVUUkFMX1NUUk9LRSwgdGhpcy5wYWxldHRlLm5ldXRyYWw/LnN0cm9rZSA/PyBkZWZhdWx0Q29sb3JzLm5ldXRyYWwuc3Ryb2tlKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfTkVVVFJBTF9GSUxMLCB0aGlzLnBhbGV0dGUubmV1dHJhbD8uZmlsbCA/PyBkZWZhdWx0Q29sb3JzLm5ldXRyYWwuZmlsbCk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX0FMVF9VUF9TVFJPS0UsIHRoaXMucGFsZXR0ZS5hbHRVcD8uc3Ryb2tlID8/IGRlZmF1bHRDb2xvcnMudXAuc3Ryb2tlKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfQUxUX1VQX0ZJTEwsIHRoaXMucGFsZXR0ZS5hbHRVcD8uZmlsbCA/PyBkZWZhdWx0Q29sb3JzLnVwLmZpbGwpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9BTFRfRE9XTl9TVFJPS0UsIHRoaXMucGFsZXR0ZS5hbHREb3duPy5zdHJva2UgPz8gZGVmYXVsdENvbG9ycy5kb3duLnN0cm9rZSk7XG4gICAgcGFyYW1zLnNldChQQUxFVFRFX0FMVF9ET1dOX0ZJTEwsIHRoaXMucGFsZXR0ZS5hbHREb3duPy5maWxsID8/IGRlZmF1bHRDb2xvcnMuZG93bi5maWxsKTtcbiAgICBwYXJhbXMuc2V0KFBBTEVUVEVfQUxUX05FVVRSQUxfRklMTCwgdGhpcy5wYWxldHRlLmFsdE5ldXRyYWw/LmZpbGwgPz8gZGVmYXVsdENvbG9ycy5hbHROZXV0cmFsLmZpbGwpO1xuICAgIHBhcmFtcy5zZXQoUEFMRVRURV9BTFRfTkVVVFJBTF9TVFJPS0UsIHRoaXMucGFsZXR0ZS5hbHROZXV0cmFsPy5zdHJva2UgPz8gZGVmYXVsdENvbG9ycy5hbHROZXV0cmFsLnN0cm9rZSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcbl9DaGFydFRoZW1lLmNhcnRlc2lhbkF4aXNEZWZhdWx0ID0ge1xuICBbXCJudW1iZXJcIiAvKiBOVU1CRVIgKi9dOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoe1xuICAgIGxpbmU6IHsgZW5hYmxlZDogZmFsc2UgfVxuICB9KSxcbiAgW1wibG9nXCIgLyogTE9HICovXTogX0NoYXJ0VGhlbWUuZ2V0QXhpc0RlZmF1bHRzKHtcbiAgICBiYXNlOiAxMCxcbiAgICBsaW5lOiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAgfSksXG4gIFtcImNhdGVnb3J5XCIgLyogQ0FURUdPUlkgKi9dOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoe1xuICAgIGdyb3VwUGFkZGluZ0lubmVyOiAwLjEsXG4gICAgbGFiZWw6IHsgYXV0b1JvdGF0ZTogdHJ1ZSB9LFxuICAgIGdyaWRMaW5lOiB7IGVuYWJsZWQ6IERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCB9LFxuICAgIGNyb3NzaGFpcjogeyBlbmFibGVkOiBmYWxzZSB9XG4gIH0pLFxuICBbXCJ0aW1lXCIgLyogVElNRSAqL106IF9DaGFydFRoZW1lLmdldEF4aXNEZWZhdWx0cyh7IGdyaWRMaW5lOiB7IGVuYWJsZWQ6IERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCB9IH0pLFxuICBbXCJvcmRpbmFsLXRpbWVcIiAvKiBPUkRJTkFMX1RJTUUgKi9dOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoe1xuICAgIGdyb3VwUGFkZGluZ0lubmVyOiAwLFxuICAgIGxhYmVsOiB7IGF1dG9Sb3RhdGU6IGZhbHNlIH0sXG4gICAgZ3JpZExpbmU6IHsgZW5hYmxlZDogREVGQVVMVF9HUklETElORV9FTkFCTEVEIH1cbiAgfSksXG4gIFtcImFuZ2xlLWNhdGVnb3J5XCIgLyogQU5HTEVfQ0FURUdPUlkgKi9dOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoe1xuICAgIGdyaWRMaW5lOiB7IGVuYWJsZWQ6IERFRkFVTFRfR1JJRExJTkVfRU5BQkxFRCB9XG4gIH0pLFxuICBbXCJhbmdsZS1udW1iZXJcIiAvKiBBTkdMRV9OVU1CRVIgKi9dOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoeyBncmlkTGluZTogeyBlbmFibGVkOiBERUZBVUxUX0dSSURMSU5FX0VOQUJMRUQgfSB9KSxcbiAgW1wicmFkaXVzLWNhdGVnb3J5XCIgLyogUkFESVVTX0NBVEVHT1JZICovXTogX0NoYXJ0VGhlbWUuZ2V0QXhpc0RlZmF1bHRzKHtcbiAgICBsaW5lOiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAgfSksXG4gIFtcInJhZGl1cy1udW1iZXJcIiAvKiBSQURJVVNfTlVNQkVSICovXTogX0NoYXJ0VGhlbWUuZ2V0QXhpc0RlZmF1bHRzKHtcbiAgICBsaW5lOiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAgfSksXG4gIFwiZ3JvdXBlZC1jYXRlZ29yeVwiOiBfQ2hhcnRUaGVtZS5nZXRBeGlzRGVmYXVsdHMoe1xuICAgIHRpY2s6IHsgZW5hYmxlZDogdHJ1ZSB9XG4gIH0pXG59O1xudmFyIENoYXJ0VGhlbWUgPSBfQ2hhcnRUaGVtZTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL2RhcmtUaGVtZS50c1xudmFyIERFRkFVTFRfREFSS19CQUNLR1JPVU5EX0ZJTEwgPSBcIiMxOTIyMzJcIjtcbnZhciBERUZBVUxUX0RBUktfRklMTFMgPSB7XG4gIEJMVUU6IFwiIzUwOTBkY1wiLFxuICBPUkFOR0U6IFwiI2ZmYTAzYVwiLFxuICBHUkVFTjogXCIjNDU5ZDU1XCIsXG4gIENZQU46IFwiIzM0YmZlMVwiLFxuICBZRUxMT1c6IFwiI2UxY2MwMFwiLFxuICBWSU9MRVQ6IFwiIzk2NjljYlwiLFxuICBHUkFZOiBcIiNiNWI1YjVcIixcbiAgTUFHRU5UQTogXCIjYmQ1YWE3XCIsXG4gIEJST1dOOiBcIiM4YTYyMjRcIixcbiAgUkVEOiBcIiNlZjU0NTJcIlxufTtcbnZhciBERUZBVUxUX0RBUktfU1RST0tFUyA9IHtcbiAgQkxVRTogXCIjNzRhOGU2XCIsXG4gIE9SQU5HRTogXCIjZmZiZTcwXCIsXG4gIEdSRUVOOiBcIiM2Y2IxNzZcIixcbiAgQ1lBTjogXCIjNzVkNGVmXCIsXG4gIFlFTExPVzogXCIjZjZlNTU5XCIsXG4gIFZJT0xFVDogXCIjYWE4NmQ4XCIsXG4gIEdSQVk6IFwiI2ExYTFhMVwiLFxuICBNQUdFTlRBOiBcIiNjZTdhYjlcIixcbiAgQlJPV046IFwiIzk5N2I1MlwiLFxuICBSRUQ6IFwiI2ZmNzg3MlwiXG59O1xudmFyIERhcmtUaGVtZSA9IGNsYXNzIGV4dGVuZHMgQ2hhcnRUaGVtZSB7XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiBERUZBVUxUX0RBUktfRklMTFMsXG4gICAgICBzdHJva2VzOiBERUZBVUxUX0RBUktfU1RST0tFUyxcbiAgICAgIHVwOiB7IGZpbGw6IERFRkFVTFRfREFSS19GSUxMUy5HUkVFTiwgc3Ryb2tlOiBERUZBVUxUX0RBUktfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBERUZBVUxUX0RBUktfRklMTFMuUkVELCBzdHJva2U6IERFRkFVTFRfREFSS19TVFJPS0VTLlJFRCB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBERUZBVUxUX0RBUktfRklMTFMuR1JBWSwgc3Ryb2tlOiBERUZBVUxUX0RBUktfU1RST0tFUy5HUkFZIH0sXG4gICAgICBhbHRVcDogeyBmaWxsOiBERUZBVUxUX0RBUktfRklMTFMuQkxVRSwgc3Ryb2tlOiBERUZBVUxUX0RBUktfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IERFRkFVTFRfREFSS19GSUxMUy5PUkFOR0UsIHN0cm9rZTogREVGQVVMVF9EQVJLX1NUUk9LRVMuT1JBTkdFIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IERFRkFVTFRfREFSS19GSUxMUy5HUkFZLCBzdHJva2U6IERFRkFVTFRfREFSS19TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoSVNfREFSS19USEVNRSwgdHJ1ZSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1BPTEFSX1NFUklFU19TVFJPS0UsIERFRkFVTFRfREFSS19CQUNLR1JPVU5EX0ZJTEwpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9MQUJFTF9DT0xPVVIsIFwid2hpdGVcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX01VVEVEX0xBQkVMX0NPTE9VUiwgXCIjN0Q5MUEwXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BWElTX0dSSURfQ09MT1VSLCBcIiM1NDVBNkVcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0NST1NTX0xJTkVTX0NPTE9VUiwgXCJ3aGl0ZVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPVVJfUkFOR0UsIFtcbiAgICAgIERFRkFVTFRfREFSS19GSUxMUy5PUkFOR0UsXG4gICAgICBERUZBVUxUX0RBUktfRklMTFMuWUVMTE9XLFxuICAgICAgREVGQVVMVF9EQVJLX0ZJTExTLkdSRUVOXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0hJRVJBUkNIWV9GSUxMUywgW1wiIzE5MjgzNFwiLCBcIiMyNTM3NDZcIiwgXCIjMzI0ODU5XCIsIFwiIzNmNTk2Y1wiLCBcIiM0ZDZhODBcIl0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ISUVSQVJDSFlfU1RST0tFUywgW1wiIzE5MjgzNFwiLCBcIiMzYjUxNjRcIiwgXCIjNDk2Mjc1XCIsIFwiIzU3NzI4N1wiLCBcIiM2NjgzOTlcIl0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9VUiwgREVGQVVMVF9EQVJLX0JBQ0tHUk9VTkRfRklMTCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0lOU0lERV9TRVJJRVNfTEFCRUxfQ09MT1VSLCBERUZBVUxUX0RBUktfQkFDS0dST1VORF9GSUxMKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUiwgREVGQVVMVF9EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9URVhUX0FOTk9UQVRJT05fQ09MT1IsIFwid2hpdGVcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBERUZBVUxUX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fSEFORExFX0ZJTEwsIERFRkFVTFRfREFSS19CQUNLR1JPVU5EX0ZJTEwpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9URVhUQk9YX0ZJTEwsIFwiIzI4MzEzZVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVEVYVEJPWF9TVFJPS0UsIFwiIzRiNTI1ZFwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfVEVYVEJPWF9DT0xPUiwgXCIjZmZmZmZmXCIpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvZmluYW5jaWFsRGFyay50c1xudmFyIEZJTkFOQ0lBTF9EQVJLX0ZJTExTID0ge1xuICBHUkVFTjogXCIjMDg5OTgxXCIsXG4gIFJFRDogXCIjRjIzNjQ1XCIsXG4gIEJMVUU6IFwiIzUwOTBkY1wiLFxuICBHUkFZOiBcIiNBOUE5QTlcIlxufTtcbnZhciBGSU5BTkNJQUxfREFSS19TVFJPS0VTID0ge1xuICBHUkVFTjogXCIjMDg5OTgxXCIsXG4gIFJFRDogXCIjRjIzNjQ1XCIsXG4gIEJMVUU6IFwiIzUwOTBkY1wiLFxuICBHUkFZOiBcIiM5MDkwOTBcIlxufTtcbnZhciBGaW5hbmNpYWxEYXJrID0gY2xhc3MgZXh0ZW5kcyBEYXJrVGhlbWUge1xuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogeyAuLi5GSU5BTkNJQUxfREFSS19GSUxMUyB9LFxuICAgICAgc3Ryb2tlczogeyAuLi5GSU5BTkNJQUxfREFSS19TVFJPS0VTIH0sXG4gICAgICB1cDogeyBmaWxsOiBGSU5BTkNJQUxfREFSS19GSUxMUy5HUkVFTiwgc3Ryb2tlOiBGSU5BTkNJQUxfREFSS19TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IEZJTkFOQ0lBTF9EQVJLX0ZJTExTLlJFRCwgc3Ryb2tlOiBGSU5BTkNJQUxfREFSS19TVFJPS0VTLlJFRCB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBGSU5BTkNJQUxfREFSS19GSUxMUy5CTFVFLCBzdHJva2U6IEZJTkFOQ0lBTF9EQVJLX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogRklOQU5DSUFMX0RBUktfRklMTFMuR1JFRU4sIHN0cm9rZTogRklOQU5DSUFMX0RBUktfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBGSU5BTkNJQUxfREFSS19GSUxMUy5SRUQsIHN0cm9rZTogRklOQU5DSUFMX0RBUktfU1RST0tFUy5SRUQgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogRklOQU5DSUFMX0RBUktfRklMTFMuR1JBWSwgc3Ryb2tlOiBGSU5BTkNJQUxfREFSS19TVFJPS0VTLkdSQVkgfVxuICAgIH07XG4gIH1cbiAgZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHN1cGVyLmdldFRlbXBsYXRlUGFyYW1ldGVycygpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9VUl9SQU5HRSwgW1xuICAgICAgRklOQU5DSUFMX0RBUktfRklMTFMuR1JFRU4sXG4gICAgICBGSU5BTkNJQUxfREFSS19GSUxMUy5CTFVFLFxuICAgICAgRklOQU5DSUFMX0RBUktfRklMTFMuUkVEXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQ09MT1IsIEZJTkFOQ0lBTF9EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgRklOQU5DSUFMX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FYSVNfR1JJRF9DT0xPVVIsIFwiIzM0M0E0RVwiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfUEFERElORywgMCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0NBUFRJT05fTEFZT1VUX1NUWUxFLCBcIm92ZXJsYXlcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0NBUFRJT05fQUxJR05NRU5ULCBcImxlZnRcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1RPT0xCQVJfUE9TSVRJT04sIFwiYm90dG9tXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9HUklETElORV9FTkFCTEVELCB0cnVlKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvZmluYW5jaWFsTGlnaHQudHNcbnZhciBGSU5BTkNJQUxfTElHSFRfRklMTFMgPSB7XG4gIEdSRUVOOiBcIiMwODk5ODFcIixcbiAgUkVEOiBcIiNGMjM2NDVcIixcbiAgQkxVRTogXCIjNTA5MGRjXCIsXG4gIEdSQVk6IFwiI0E5QTlBOVwiXG59O1xudmFyIEZJTkFOQ0lBTF9MSUdIVF9TVFJPS0VTID0ge1xuICBHUkVFTjogXCIjMDg5OTgxXCIsXG4gIFJFRDogXCIjRjIzNjQ1XCIsXG4gIEJMVUU6IFwiIzUwOTBkY1wiLFxuICBHUkFZOiBcIiM5MDkwOTBcIlxufTtcbnZhciBGaW5hbmNpYWxMaWdodCA9IGNsYXNzIGV4dGVuZHMgQ2hhcnRUaGVtZSB7XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiB7IC4uLkZJTkFOQ0lBTF9MSUdIVF9GSUxMUyB9LFxuICAgICAgc3Ryb2tlczogeyAuLi5GSU5BTkNJQUxfTElHSFRfU1RST0tFUyB9LFxuICAgICAgdXA6IHsgZmlsbDogRklOQU5DSUFMX0xJR0hUX0ZJTExTLkdSRUVOLCBzdHJva2U6IEZJTkFOQ0lBTF9MSUdIVF9TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5SRUQsIHN0cm9rZTogRklOQU5DSUFMX0xJR0hUX1NUUk9LRVMuUkVEIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5CTFVFLCBzdHJva2U6IEZJTkFOQ0lBTF9MSUdIVF9TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5HUkVFTiwgc3Ryb2tlOiBGSU5BTkNJQUxfTElHSFRfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBGSU5BTkNJQUxfTElHSFRfRklMTFMuUkVELCBzdHJva2U6IEZJTkFOQ0lBTF9MSUdIVF9TVFJPS0VTLlJFRCB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBGSU5BTkNJQUxfTElHSFRfRklMTFMuR1JBWSwgc3Ryb2tlOiBGSU5BTkNJQUxfTElHSFRfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPVVJfUkFOR0UsIFtcbiAgICAgIEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5HUkVFTixcbiAgICAgIEZJTkFOQ0lBTF9MSUdIVF9GSUxMUy5CTFVFLFxuICAgICAgRklOQU5DSUFMX0xJR0hUX0ZJTExTLlJFRFxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLCBGSU5BTkNJQUxfTElHSFRfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBGSU5BTkNJQUxfTElHSFRfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FYSVNfR1JJRF9DT0xPVVIsIFwiI0YyRjNGM1wiKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfUEFERElORywgMCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0NBUFRJT05fTEFZT1VUX1NUWUxFLCBcIm92ZXJsYXlcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0NBUFRJT05fQUxJR05NRU5ULCBcImxlZnRcIik7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX1RPT0xCQVJfUE9TSVRJT04sIFwiYm90dG9tXCIpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9HUklETElORV9FTkFCTEVELCB0cnVlKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvbWF0ZXJpYWxEYXJrLnRzXG52YXIgTUFURVJJQUxfREFSS19GSUxMUyA9IHtcbiAgQkxVRTogXCIjMjE5NkYzXCIsXG4gIE9SQU5HRTogXCIjRkY5ODAwXCIsXG4gIEdSRUVOOiBcIiM0Q0FGNTBcIixcbiAgQ1lBTjogXCIjMDBCQ0Q0XCIsXG4gIFlFTExPVzogXCIjRkZFQjNCXCIsXG4gIFZJT0xFVDogXCIjN0U1N0MyXCIsXG4gIEdSQVk6IFwiIzlFOUU5RVwiLFxuICBNQUdFTlRBOiBcIiNGMDYyOTJcIixcbiAgQlJPV046IFwiIzc5NTU0OFwiLFxuICBSRUQ6IFwiI0Y0NDMzNlwiXG59O1xudmFyIE1BVEVSSUFMX0RBUktfU1RST0tFUyA9IHtcbiAgQkxVRTogXCIjOTBDQUY5XCIsXG4gIE9SQU5HRTogXCIjRkZDQzgwXCIsXG4gIEdSRUVOOiBcIiNBNUQ2QTdcIixcbiAgQ1lBTjogXCIjODBERUVBXCIsXG4gIFlFTExPVzogXCIjRkZGOUM0XCIsXG4gIFZJT0xFVDogXCIjQjM5RERCXCIsXG4gIEdSQVk6IFwiI0UwRTBFMFwiLFxuICBNQUdFTlRBOiBcIiNGNDhGQjFcIixcbiAgQlJPV046IFwiI0ExODg3RlwiLFxuICBSRUQ6IFwiI0VGOUE5QVwiXG59O1xudmFyIE1hdGVyaWFsRGFyayA9IGNsYXNzIGV4dGVuZHMgRGFya1RoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IE1BVEVSSUFMX0RBUktfRklMTFMsXG4gICAgICBzdHJva2VzOiBNQVRFUklBTF9EQVJLX1NUUk9LRVMsXG4gICAgICB1cDogeyBmaWxsOiBNQVRFUklBTF9EQVJLX0ZJTExTLkdSRUVOLCBzdHJva2U6IE1BVEVSSUFMX0RBUktfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBNQVRFUklBTF9EQVJLX0ZJTExTLlJFRCwgc3Ryb2tlOiBNQVRFUklBTF9EQVJLX1NUUk9LRVMuUkVEIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IE1BVEVSSUFMX0RBUktfRklMTFMuR1JBWSwgc3Ryb2tlOiBNQVRFUklBTF9EQVJLX1NUUk9LRVMuR1JBWSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogTUFURVJJQUxfREFSS19GSUxMUy5CTFVFLCBzdHJva2U6IE1BVEVSSUFMX0RBUktfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IE1BVEVSSUFMX0RBUktfRklMTFMuUkVELCBzdHJva2U6IE1BVEVSSUFMX0RBUktfU1RST0tFUy5SRUQgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogTUFURVJJQUxfREFSS19GSUxMUy5HUkFZLCBzdHJva2U6IE1BVEVSSUFMX0RBUktfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPVVJfUkFOR0UsIFtcbiAgICAgIE1BVEVSSUFMX0RBUktfRklMTFMuT1JBTkdFLFxuICAgICAgTUFURVJJQUxfREFSS19GSUxMUy5ZRUxMT1csXG4gICAgICBNQVRFUklBTF9EQVJLX0ZJTExTLkdSRUVOXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQ09MT1IsIE1BVEVSSUFMX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBNQVRFUklBTF9EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9tYXRlcmlhbExpZ2h0LnRzXG52YXIgTUFURVJJQUxfTElHSFRfRklMTFMgPSB7XG4gIEJMVUU6IFwiIzIxOTZGM1wiLFxuICBPUkFOR0U6IFwiI0ZGOTgwMFwiLFxuICBHUkVFTjogXCIjNENBRjUwXCIsXG4gIENZQU46IFwiIzAwQkNENFwiLFxuICBZRUxMT1c6IFwiI0ZGRUIzQlwiLFxuICBWSU9MRVQ6IFwiIzdFNTdDMlwiLFxuICBHUkFZOiBcIiM5RTlFOUVcIixcbiAgTUFHRU5UQTogXCIjRjA2MjkyXCIsXG4gIEJST1dOOiBcIiM3OTU1NDhcIixcbiAgUkVEOiBcIiNGNDQzMzZcIlxufTtcbnZhciBNQVRFUklBTF9MSUdIVF9TVFJPS0VTID0ge1xuICBCTFVFOiBcIiMxNTY1QzBcIixcbiAgT1JBTkdFOiBcIiNFNjUxMDBcIixcbiAgR1JFRU46IFwiIzJFN0QzMlwiLFxuICBDWUFOOiBcIiMwMDgzOEZcIixcbiAgWUVMTE9XOiBcIiNGOUE4MjVcIixcbiAgVklPTEVUOiBcIiM0NTI3QTBcIixcbiAgR1JBWTogXCIjNjE2MTYxXCIsXG4gIE1BR0VOVEE6IFwiI0MyMTg1QlwiLFxuICBCUk9XTjogXCIjNEUzNDJFXCIsXG4gIFJFRDogXCIjQjcxQzFDXCJcbn07XG52YXIgTWF0ZXJpYWxMaWdodCA9IGNsYXNzIGV4dGVuZHMgQ2hhcnRUaGVtZSB7XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiBNQVRFUklBTF9MSUdIVF9GSUxMUyxcbiAgICAgIHN0cm9rZXM6IE1BVEVSSUFMX0xJR0hUX1NUUk9LRVMsXG4gICAgICB1cDogeyBmaWxsOiBNQVRFUklBTF9MSUdIVF9GSUxMUy5HUkVFTiwgc3Ryb2tlOiBNQVRFUklBTF9MSUdIVF9TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IE1BVEVSSUFMX0xJR0hUX0ZJTExTLlJFRCwgc3Ryb2tlOiBNQVRFUklBTF9MSUdIVF9TVFJPS0VTLlJFRCB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBNQVRFUklBTF9MSUdIVF9GSUxMUy5HUkFZLCBzdHJva2U6IE1BVEVSSUFMX0xJR0hUX1NUUk9LRVMuR1JBWSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogTUFURVJJQUxfTElHSFRfRklMTFMuQkxVRSwgc3Ryb2tlOiBNQVRFUklBTF9MSUdIVF9TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogTUFURVJJQUxfTElHSFRfRklMTFMuUkVELCBzdHJva2U6IE1BVEVSSUFMX0xJR0hUX1NUUk9LRVMuUkVEIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IE1BVEVSSUFMX0xJR0hUX0ZJTExTLkdSQVksIHN0cm9rZTogTUFURVJJQUxfTElHSFRfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPVVJfUkFOR0UsIFtcbiAgICAgIE1BVEVSSUFMX0xJR0hUX0ZJTExTLk9SQU5HRSxcbiAgICAgIE1BVEVSSUFMX0xJR0hUX0ZJTExTLllFTExPVyxcbiAgICAgIE1BVEVSSUFMX0xJR0hUX0ZJTExTLkdSRUVOXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQ09MT1IsIE1BVEVSSUFMX0xJR0hUX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgTUFURVJJQUxfTElHSFRfRklMTFMuQkxVRSk7XG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvdGhlbWVzL3BvbHljaHJvbWFEYXJrLnRzXG52YXIgUE9MWUNIUk9NQV9EQVJLX0ZJTExTID0ge1xuICBCTFVFOiBcIiM0MzZmZjRcIixcbiAgUFVSUExFOiBcIiM5YTdiZmZcIixcbiAgTUFHRU5UQTogXCIjZDE2NWQyXCIsXG4gIFBJTks6IFwiI2YwNTk4YlwiLFxuICBSRUQ6IFwiI2Y0NzM0OFwiLFxuICBPUkFOR0U6IFwiI2YyYTYwMlwiLFxuICBZRUxMT1c6IFwiI2U5ZTIwMVwiLFxuICBHUkVFTjogXCIjMjFiNDQ4XCIsXG4gIENZQU46IFwiIzAwYjlhMlwiLFxuICBNT0RFUkFURV9CTFVFOiBcIiMwMGFlZTRcIixcbiAgR1JBWTogXCIjYmJiYmJiXCJcbn07XG52YXIgUE9MWUNIUk9NQV9EQVJLX1NUUk9LRVMgPSB7XG4gIEJMVUU6IFwiIzY2OThmZlwiLFxuICBQVVJQTEU6IFwiI2MwYTNmZlwiLFxuICBNQUdFTlRBOiBcIiNmYzhkZmNcIixcbiAgUElOSzogXCIjZmY4MmIxXCIsXG4gIFJFRDogXCIjZmY5YjcwXCIsXG4gIE9SQU5HRTogXCIjZmZjZjRlXCIsXG4gIFlFTExPVzogXCIjZmZmZjU4XCIsXG4gIEdSRUVOOiBcIiM1OGRkNzBcIixcbiAgQ1lBTjogXCIjNTFlMmM5XCIsXG4gIE1PREVSQVRFX0JMVUU6IFwiIzRmZDdmZlwiLFxuICBHUkFZOiBcIiNlZWVlZWVcIlxufTtcbnZhciBQb2x5Y2hyb21hRGFyayA9IGNsYXNzIGV4dGVuZHMgRGFya1RoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IFBPTFlDSFJPTUFfREFSS19GSUxMUyxcbiAgICAgIHN0cm9rZXM6IFBPTFlDSFJPTUFfREFSS19TVFJPS0VTLFxuICAgICAgdXA6IHsgZmlsbDogUE9MWUNIUk9NQV9EQVJLX0ZJTExTLkdSRUVOLCBzdHJva2U6IFBPTFlDSFJPTUFfREFSS19TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IFBPTFlDSFJPTUFfREFSS19GSUxMUy5SRUQsIHN0cm9rZTogUE9MWUNIUk9NQV9EQVJLX1NUUk9LRVMuUkVEIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IFBPTFlDSFJPTUFfREFSS19GSUxMUy5HUkFZLCBzdHJva2U6IFBPTFlDSFJPTUFfREFSS19TVFJPS0VTLkdSQVkgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IFBPTFlDSFJPTUFfREFSS19GSUxMUy5CTFVFLCBzdHJva2U6IFBPTFlDSFJPTUFfREFSS19TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogUE9MWUNIUk9NQV9EQVJLX0ZJTExTLlJFRCwgc3Ryb2tlOiBQT0xZQ0hST01BX0RBUktfU1RST0tFUy5SRUQgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogUE9MWUNIUk9NQV9EQVJLX0ZJTExTLkdSQVksIHN0cm9rZTogUE9MWUNIUk9NQV9EQVJLX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3VwZXIuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1VSX1JBTkdFLCBbUE9MWUNIUk9NQV9EQVJLX0ZJTExTLkJMVUUsIFBPTFlDSFJPTUFfREFSS19GSUxMUy5SRURdKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUiwgUE9MWUNIUk9NQV9EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0JBQ0tHUk9VTkRfRklMTCwgUE9MWUNIUk9NQV9EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9wb2x5Y2hyb21hTGlnaHQudHNcbnZhciBQT0xZQ0hST01BX0xJR0hUX0ZJTExTID0ge1xuICBCTFVFOiBcIiM0MzZmZjRcIixcbiAgUFVSUExFOiBcIiM5YTdiZmZcIixcbiAgTUFHRU5UQTogXCIjZDE2NWQyXCIsXG4gIFBJTks6IFwiI2YwNTk4YlwiLFxuICBSRUQ6IFwiI2Y0NzM0OFwiLFxuICBPUkFOR0U6IFwiI2YyYTYwMlwiLFxuICBZRUxMT1c6IFwiI2U5ZTIwMVwiLFxuICBHUkVFTjogXCIjMjFiNDQ4XCIsXG4gIENZQU46IFwiIzAwYjlhMlwiLFxuICBNT0RFUkFURV9CTFVFOiBcIiMwMGFlZTRcIixcbiAgR1JBWTogXCIjYmJiYmJiXCJcbn07XG52YXIgUE9MWUNIUk9NQV9MSUdIVF9TVFJPS0VTID0ge1xuICBCTFVFOiBcIiMyMzQ2YzlcIixcbiAgUFVSUExFOiBcIiM3NjUzZDRcIixcbiAgTUFHRU5UQTogXCIjYTczZGE5XCIsXG4gIFBJTks6IFwiI2MzMmQ2NlwiLFxuICBSRUQ6IFwiI2M4NGIxY1wiLFxuICBPUkFOR0U6IFwiI2M4N2YwMFwiLFxuICBZRUxMT1c6IFwiI2MxYjkwMFwiLFxuICBHUkVFTjogXCIjMDA4YzFjXCIsXG4gIENZQU46IFwiIzAwOTI3Y1wiLFxuICBNT0RFUkFURV9CTFVFOiBcIiMwMDg3YmJcIixcbiAgR1JBWTogXCIjODg4ODg4XCJcbn07XG52YXIgUG9seWNocm9tYUxpZ2h0ID0gY2xhc3MgZXh0ZW5kcyBDaGFydFRoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IFBPTFlDSFJPTUFfTElHSFRfRklMTFMsXG4gICAgICBzdHJva2VzOiBQT0xZQ0hST01BX0xJR0hUX1NUUk9LRVMsXG4gICAgICB1cDogeyBmaWxsOiBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLkdSRUVOLCBzdHJva2U6IFBPTFlDSFJPTUFfTElHSFRfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLlJFRCwgc3Ryb2tlOiBQT0xZQ0hST01BX0xJR0hUX1NUUk9LRVMuUkVEIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IFBPTFlDSFJPTUFfTElHSFRfRklMTFMuR1JBWSwgc3Ryb2tlOiBQT0xZQ0hST01BX0xJR0hUX1NUUk9LRVMuR1JBWSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5CTFVFLCBzdHJva2U6IFBPTFlDSFJPTUFfTElHSFRfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IFBPTFlDSFJPTUFfTElHSFRfRklMTFMuUkVELCBzdHJva2U6IFBPTFlDSFJPTUFfTElHSFRfU1RST0tFUy5SRUQgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogUE9MWUNIUk9NQV9MSUdIVF9GSUxMUy5HUkFZLCBzdHJva2U6IFBPTFlDSFJPTUFfTElHSFRfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPVVJfUkFOR0UsIFtQT0xZQ0hST01BX0xJR0hUX0ZJTExTLkJMVUUsIFBPTFlDSFJPTUFfTElHSFRfRklMTFMuUkVEXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQ09MT1IsIFBPTFlDSFJPTUFfTElHSFRfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBQT0xZQ0hST01BX0xJR0hUX0ZJTExTLkJMVUUpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9zaGVldHNEYXJrLnRzXG52YXIgU0hFRVRTX0RBUktfRklMTFMgPSB7XG4gIEJMVUU6IFwiIzQ0NzJDNFwiLFxuICBPUkFOR0U6IFwiI0VEN0QzMVwiLFxuICBHUkFZOiBcIiNBNUE1QTVcIixcbiAgWUVMTE9XOiBcIiNGRkMwMDBcIixcbiAgTU9ERVJBVEVfQkxVRTogXCIjNUI5QkQ1XCIsXG4gIEdSRUVOOiBcIiM3MEFENDdcIixcbiAgREFSS19HUkFZOiBcIiM3QjdCN0JcIixcbiAgREFSS19CTFVFOiBcIiMyNjQ0NzhcIixcbiAgVkVSWV9EQVJLX0dSQVk6IFwiIzYzNjM2M1wiLFxuICBEQVJLX1lFTExPVzogXCIjOTk3MzAwXCJcbn07XG52YXIgU0hFRVRTX0RBUktfU1RST0tFUyA9IHtcbiAgQkxVRTogXCIjNjg5OWVlXCIsXG4gIE9SQU5HRTogXCIjZmZhNTVkXCIsXG4gIEdSQVk6IFwiI2NkY2RjZFwiLFxuICBZRUxMT1c6IFwiI2ZmZWE1M1wiLFxuICBNT0RFUkFURV9CTFVFOiBcIiM4MmMzZmZcIixcbiAgR1JFRU46IFwiIzk2ZDU2ZlwiLFxuICBEQVJLX0dSQVk6IFwiI2ExYTFhMVwiLFxuICBEQVJLX0JMVUU6IFwiIzQ3Njg5ZlwiLFxuICBWRVJZX0RBUktfR1JBWTogXCIjODc4Nzg3XCIsXG4gIERBUktfWUVMTE9XOiBcIiNjMDk5M2RcIlxufTtcbnZhciBTaGVldHNEYXJrID0gY2xhc3MgZXh0ZW5kcyBEYXJrVGhlbWUge1xuICBnZXREZWZhdWx0Q29sb3JzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBmaWxsczogeyAuLi5TSEVFVFNfREFSS19GSUxMUywgUkVEOiBTSEVFVFNfREFSS19GSUxMUy5PUkFOR0UgfSxcbiAgICAgIHN0cm9rZXM6IHsgLi4uU0hFRVRTX0RBUktfU1RST0tFUywgUkVEOiBTSEVFVFNfREFSS19TVFJPS0VTLk9SQU5HRSB9LFxuICAgICAgdXA6IHsgZmlsbDogU0hFRVRTX0RBUktfRklMTFMuR1JFRU4sIHN0cm9rZTogU0hFRVRTX0RBUktfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBTSEVFVFNfREFSS19GSUxMUy5PUkFOR0UsIHN0cm9rZTogU0hFRVRTX0RBUktfU1RST0tFUy5PUkFOR0UgfSxcbiAgICAgIG5ldXRyYWw6IHsgZmlsbDogU0hFRVRTX0RBUktfRklMTFMuR1JBWSwgc3Ryb2tlOiBTSEVFVFNfREFSS19TVFJPS0VTLkdSQVkgfSxcbiAgICAgIGFsdFVwOiB7IGZpbGw6IFNIRUVUU19EQVJLX0ZJTExTLkJMVUUsIHN0cm9rZTogU0hFRVRTX0RBUktfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IFNIRUVUU19EQVJLX0ZJTExTLk9SQU5HRSwgc3Ryb2tlOiBTSEVFVFNfREFSS19TVFJPS0VTLk9SQU5HRSB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBTSEVFVFNfREFSS19GSUxMUy5HUkFZLCBzdHJva2U6IFNIRUVUU19EQVJLX1NUUk9LRVMuR1JBWSB9XG4gICAgfTtcbiAgfVxuICBnZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKSB7XG4gICAgY29uc3QgcGFyYW1zID0gc3VwZXIuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0RJVkVSR0lOR19TRVJJRVNfQ09MT1VSX1JBTkdFLCBbXG4gICAgICBTSEVFVFNfREFSS19GSUxMUy5PUkFOR0UsXG4gICAgICBTSEVFVFNfREFSS19GSUxMUy5ZRUxMT1csXG4gICAgICBTSEVFVFNfREFSS19GSUxMUy5HUkVFTlxuICAgIF0pO1xuICAgIHBhcmFtcy5zZXQoREVGQVVMVF9BTk5PVEFUSU9OX0NPTE9SLCBTSEVFVFNfREFSS19GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIFNIRUVUU19EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy9zaGVldHNMaWdodC50c1xudmFyIFNIRUVUU19MSUdIVF9GSUxMUyA9IHtcbiAgQkxVRTogXCIjNTI4MWQ1XCIsXG4gIE9SQU5HRTogXCIjZmY4ZDQ0XCIsXG4gIEdSQVk6IFwiI2I1YjViNVwiLFxuICBZRUxMT1c6IFwiI2ZmZDAyZlwiLFxuICBNT0RFUkFURV9CTFVFOiBcIiM2YWFiZTZcIixcbiAgR1JFRU46IFwiIzdmYmQ1N1wiLFxuICBEQVJLX0dSQVk6IFwiIzhhOGE4YVwiLFxuICBEQVJLX0JMVUU6IFwiIzMzNTI4N1wiLFxuICBWRVJZX0RBUktfR1JBWTogXCIjNzE3MTcxXCIsXG4gIERBUktfWUVMTE9XOiBcIiNhOTgyMjBcIlxufTtcbnZhciBTSEVFVFNfTElHSFRfU1RST0tFUyA9IHtcbiAgQkxVRTogXCIjMjE0ZDliXCIsXG4gIE9SQU5HRTogXCIjYzI1NjAwXCIsXG4gIEdSQVk6IFwiIzdmN2Y3ZlwiLFxuICBZRUxMT1c6IFwiI2Q1OTgwMFwiLFxuICBNT0RFUkFURV9CTFVFOiBcIiMzNTc1YWNcIixcbiAgR1JFRU46IFwiIzRiODYxYVwiLFxuICBEQVJLX0dSQVk6IFwiIzU3NTc1N1wiLFxuICBEQVJLX0JMVUU6IFwiIzA2MjI1M1wiLFxuICBWRVJZX0RBUktfR1JBWTogXCIjNDE0MTQxXCIsXG4gIERBUktfWUVMTE9XOiBcIiM3MzRmMDBcIlxufTtcbnZhciBTaGVldHNMaWdodCA9IGNsYXNzIGV4dGVuZHMgQ2hhcnRUaGVtZSB7XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiB7IC4uLlNIRUVUU19MSUdIVF9GSUxMUywgUkVEOiBTSEVFVFNfTElHSFRfRklMTFMuT1JBTkdFIH0sXG4gICAgICBzdHJva2VzOiB7IC4uLlNIRUVUU19MSUdIVF9TVFJPS0VTLCBSRUQ6IFNIRUVUU19MSUdIVF9TVFJPS0VTLk9SQU5HRSB9LFxuICAgICAgdXA6IHsgZmlsbDogU0hFRVRTX0xJR0hUX0ZJTExTLkdSRUVOLCBzdHJva2U6IFNIRUVUU19MSUdIVF9TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IFNIRUVUU19MSUdIVF9GSUxMUy5PUkFOR0UsIHN0cm9rZTogU0hFRVRTX0xJR0hUX1NUUk9LRVMuT1JBTkdFIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IFNIRUVUU19MSUdIVF9TVFJPS0VTLkdSQVksIHN0cm9rZTogU0hFRVRTX0xJR0hUX1NUUk9LRVMuR1JBWSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogU0hFRVRTX0xJR0hUX0ZJTExTLkJMVUUsIHN0cm9rZTogU0hFRVRTX0xJR0hUX1NUUk9LRVMuQkxVRSB9LFxuICAgICAgYWx0RG93bjogeyBmaWxsOiBTSEVFVFNfTElHSFRfRklMTFMuT1JBTkdFLCBzdHJva2U6IFNIRUVUU19MSUdIVF9TVFJPS0VTLk9SQU5HRSB9LFxuICAgICAgYWx0TmV1dHJhbDogeyBmaWxsOiBTSEVFVFNfTElHSFRfRklMTFMuR1JBWSwgc3Ryb2tlOiBTSEVFVFNfTElHSFRfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPVVJfUkFOR0UsIFtcbiAgICAgIFNIRUVUU19MSUdIVF9GSUxMUy5PUkFOR0UsXG4gICAgICBTSEVFVFNfTElHSFRfRklMTFMuWUVMTE9XLFxuICAgICAgU0hFRVRTX0xJR0hUX0ZJTExTLkdSRUVOXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQ09MT1IsIFNIRUVUU19MSUdIVF9GSUxMUy5CTFVFKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9CQUNLR1JPVU5EX0ZJTEwsIFNIRUVUU19MSUdIVF9GSUxMUy5CTFVFKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC90aGVtZXMvdml2aWREYXJrLnRzXG52YXIgVklWSURfREFSS19GSUxMUyA9IHtcbiAgQkxVRTogXCIjMDA4M2ZmXCIsXG4gIE9SQU5HRTogXCIjZmY2NjAwXCIsXG4gIEdSRUVOOiBcIiMwMGFmMDBcIixcbiAgQ1lBTjogXCIjMDBjY2ZmXCIsXG4gIFlFTExPVzogXCIjZjdjNzAwXCIsXG4gIFZJT0xFVDogXCIjYWMyNmZmXCIsXG4gIEdSQVk6IFwiI2E3YTdiN1wiLFxuICBNQUdFTlRBOiBcIiNlODAwYzVcIixcbiAgQlJPV046IFwiI2I1NDMwMFwiLFxuICBSRUQ6IFwiI2ZmMDAwMFwiXG59O1xudmFyIFZJVklEX0RBUktfU1RST0tFUyA9IHtcbiAgQkxVRTogXCIjNjdiN2ZmXCIsXG4gIE9SQU5HRTogXCIjZmZjMjRkXCIsXG4gIEdSRUVOOiBcIiM1Y2M4NmZcIixcbiAgQ1lBTjogXCIjNTRlYmZmXCIsXG4gIFZJT0xFVDogXCIjZmZmNjUzXCIsXG4gIFlFTExPVzogXCIjYzE4YWZmXCIsXG4gIEdSQVk6IFwiI2FlYWVhZVwiLFxuICBNQUdFTlRBOiBcIiNmMDc4ZDRcIixcbiAgQlJPV046IFwiI2JhODQzOFwiLFxuICBSRUQ6IFwiI2ZmNzI2ZVwiXG59O1xudmFyIFZpdmlkRGFyayA9IGNsYXNzIGV4dGVuZHMgRGFya1RoZW1lIHtcbiAgZ2V0RGVmYXVsdENvbG9ycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZmlsbHM6IFZJVklEX0RBUktfRklMTFMsXG4gICAgICBzdHJva2VzOiBWSVZJRF9EQVJLX1NUUk9LRVMsXG4gICAgICB1cDogeyBmaWxsOiBWSVZJRF9EQVJLX0ZJTExTLkdSRUVOLCBzdHJva2U6IFZJVklEX0RBUktfU1RST0tFUy5HUkVFTiB9LFxuICAgICAgZG93bjogeyBmaWxsOiBWSVZJRF9EQVJLX0ZJTExTLlJFRCwgc3Ryb2tlOiBWSVZJRF9EQVJLX1NUUk9LRVMuUkVEIH0sXG4gICAgICBuZXV0cmFsOiB7IGZpbGw6IFZJVklEX0RBUktfRklMTFMuR1JBWSwgc3Ryb2tlOiBWSVZJRF9EQVJLX1NUUk9LRVMuR1JBWSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogVklWSURfREFSS19GSUxMUy5CTFVFLCBzdHJva2U6IFZJVklEX0RBUktfU1RST0tFUy5CTFVFIH0sXG4gICAgICBhbHREb3duOiB7IGZpbGw6IFZJVklEX0RBUktfRklMTFMuT1JBTkdFLCBzdHJva2U6IFZJVklEX0RBUktfU1RST0tFUy5PUkFOR0UgfSxcbiAgICAgIGFsdE5ldXRyYWw6IHsgZmlsbDogVklWSURfREFSS19GSUxMUy5HUkFZLCBzdHJva2U6IFZJVklEX0RBUktfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPVVJfUkFOR0UsIFtcbiAgICAgIFZJVklEX0RBUktfRklMTFMuT1JBTkdFLFxuICAgICAgVklWSURfREFSS19GSUxMUy5ZRUxMT1csXG4gICAgICBWSVZJRF9EQVJLX0ZJTExTLkdSRUVOXG4gICAgXSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQ09MT1IsIFZJVklEX0RBUktfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBWSVZJRF9EQVJLX0ZJTExTLkJMVUUpO1xuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2NoYXJ0L3RoZW1lcy92aXZpZExpZ2h0LnRzXG52YXIgVklWSURfRklMTFMgPSB7XG4gIEJMVUU6IFwiIzAwODNmZlwiLFxuICBPUkFOR0U6IFwiI2ZmNjYwMFwiLFxuICBHUkVFTjogXCIjMDBhZjAwXCIsXG4gIENZQU46IFwiIzAwY2NmZlwiLFxuICBZRUxMT1c6IFwiI2Y3YzcwMFwiLFxuICBWSU9MRVQ6IFwiI2FjMjZmZlwiLFxuICBHUkFZOiBcIiNhN2E3YjdcIixcbiAgTUFHRU5UQTogXCIjZTgwMGM1XCIsXG4gIEJST1dOOiBcIiNiNTQzMDBcIixcbiAgUkVEOiBcIiNmZjAwMDBcIlxufTtcbnZhciBWSVZJRF9TVFJPS0VTID0ge1xuICBCTFVFOiBcIiMwZjY4YzBcIixcbiAgT1JBTkdFOiBcIiNkNDcxMDBcIixcbiAgR1JFRU46IFwiIzAwNzkyMlwiLFxuICBDWUFOOiBcIiMwMDlhYzJcIixcbiAgVklPTEVUOiBcIiNiY2E0MDBcIixcbiAgWUVMTE9XOiBcIiM3NTNjYWNcIixcbiAgR1JBWTogXCIjNjQ2NDY0XCIsXG4gIE1BR0VOVEE6IFwiIzliMjY4NVwiLFxuICBCUk9XTjogXCIjNmMzYjAwXCIsXG4gIFJFRDogXCIjY2IwMDIxXCJcbn07XG52YXIgVml2aWRMaWdodCA9IGNsYXNzIGV4dGVuZHMgQ2hhcnRUaGVtZSB7XG4gIGdldERlZmF1bHRDb2xvcnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpbGxzOiBWSVZJRF9GSUxMUyxcbiAgICAgIHN0cm9rZXM6IFZJVklEX1NUUk9LRVMsXG4gICAgICB1cDogeyBmaWxsOiBWSVZJRF9GSUxMUy5HUkVFTiwgc3Ryb2tlOiBWSVZJRF9TVFJPS0VTLkdSRUVOIH0sXG4gICAgICBkb3duOiB7IGZpbGw6IFZJVklEX0ZJTExTLlJFRCwgc3Ryb2tlOiBWSVZJRF9TVFJPS0VTLlJFRCB9LFxuICAgICAgbmV1dHJhbDogeyBmaWxsOiBWSVZJRF9GSUxMUy5HUkFZLCBzdHJva2U6IFZJVklEX1NUUk9LRVMuR1JBWSB9LFxuICAgICAgYWx0VXA6IHsgZmlsbDogVklWSURfRklMTFMuQkxVRSwgc3Ryb2tlOiBWSVZJRF9TVFJPS0VTLkJMVUUgfSxcbiAgICAgIGFsdERvd246IHsgZmlsbDogVklWSURfRklMTFMuT1JBTkdFLCBzdHJva2U6IFZJVklEX1NUUk9LRVMuT1JBTkdFIH0sXG4gICAgICBhbHROZXV0cmFsOiB7IGZpbGw6IFZJVklEX0ZJTExTLkdSQVksIHN0cm9rZTogVklWSURfU1RST0tFUy5HUkFZIH1cbiAgICB9O1xuICB9XG4gIGdldFRlbXBsYXRlUGFyYW1ldGVycygpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBzdXBlci5nZXRUZW1wbGF0ZVBhcmFtZXRlcnMoKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfRElWRVJHSU5HX1NFUklFU19DT0xPVVJfUkFOR0UsIFtWSVZJRF9GSUxMUy5PUkFOR0UsIFZJVklEX0ZJTExTLllFTExPVywgVklWSURfRklMTFMuR1JFRU5dKTtcbiAgICBwYXJhbXMuc2V0KERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUiwgVklWSURfRklMTFMuQkxVRSk7XG4gICAgcGFyYW1zLnNldChERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLCBWSVZJRF9GSUxMUy5CTFVFKTtcbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG59O1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9tYXBwaW5nL3RoZW1lcy50c1xudmFyIGxpZ2h0VGhlbWUgPSAoKSA9PiBuZXcgQ2hhcnRUaGVtZSgpO1xudmFyIGRhcmtUaGVtZSA9ICgpID0+IG5ldyBEYXJrVGhlbWUoKTtcbnZhciB0aGVtZXMgPSB7XG4gIC8vIGRhcmtUaGVtZXMsXG4gIFwiYWctZGVmYXVsdC1kYXJrXCI6IGRhcmtUaGVtZSxcbiAgXCJhZy1zaGVldHMtZGFya1wiOiAoKSA9PiBuZXcgU2hlZXRzRGFyaygpLFxuICBcImFnLXBvbHljaHJvbWEtZGFya1wiOiAoKSA9PiBuZXcgUG9seWNocm9tYURhcmsoKSxcbiAgXCJhZy12aXZpZC1kYXJrXCI6ICgpID0+IG5ldyBWaXZpZERhcmsoKSxcbiAgXCJhZy1tYXRlcmlhbC1kYXJrXCI6ICgpID0+IG5ldyBNYXRlcmlhbERhcmsoKSxcbiAgXCJhZy1maW5hbmNpYWwtZGFya1wiOiAoKSA9PiBuZXcgRmluYW5jaWFsRGFyaygpLFxuICAvLyBsaWdodFRoZW1lcyxcbiAgbnVsbDogbGlnaHRUaGVtZSxcbiAgdW5kZWZpbmVkOiBsaWdodFRoZW1lLFxuICBcImFnLWRlZmF1bHRcIjogbGlnaHRUaGVtZSxcbiAgXCJhZy1zaGVldHNcIjogKCkgPT4gbmV3IFNoZWV0c0xpZ2h0KCksXG4gIFwiYWctcG9seWNocm9tYVwiOiAoKSA9PiBuZXcgUG9seWNocm9tYUxpZ2h0KCksXG4gIFwiYWctdml2aWRcIjogKCkgPT4gbmV3IFZpdmlkTGlnaHQoKSxcbiAgXCJhZy1tYXRlcmlhbFwiOiAoKSA9PiBuZXcgTWF0ZXJpYWxMaWdodCgpLFxuICBcImFnLWZpbmFuY2lhbFwiOiAoKSA9PiBuZXcgRmluYW5jaWFsTGlnaHQoKVxufTtcbmZ1bmN0aW9uIGdldENoYXJ0VGhlbWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQ2hhcnRUaGVtZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBzdG9ja1RoZW1lID0gdGhlbWVzW3ZhbHVlXTtcbiAgICBpZiAoc3RvY2tUaGVtZSkge1xuICAgICAgcmV0dXJuIHN0b2NrVGhlbWUoKTtcbiAgICB9XG4gICAgTG9nZ2VyLndhcm5PbmNlKGB0aGUgdGhlbWUgWyR7dmFsdWV9XSBpcyBpbnZhbGlkLCB1c2luZyBbYWctZGVmYXVsdF0gaW5zdGVhZC5gKTtcbiAgICByZXR1cm4gbGlnaHRUaGVtZSgpO1xuICB9XG4gIGlmIChpc1ZhbGlkKHZhbHVlLCB0aGVtZU9wdGlvbnNEZWYsIFwidGhlbWVcIikpIHtcbiAgICBjb25zdCBmbGF0dGVuZWRUaGVtZSA9IHJlZHVjZVRoZW1lT3B0aW9ucyh2YWx1ZSk7XG4gICAgY29uc3QgYmFzZVRoZW1lID0gZmxhdHRlbmVkVGhlbWUuYmFzZVRoZW1lID8gZ2V0Q2hhcnRUaGVtZShmbGF0dGVuZWRUaGVtZS5iYXNlVGhlbWUpIDogbGlnaHRUaGVtZSgpO1xuICAgIHJldHVybiBuZXcgYmFzZVRoZW1lLmNvbnN0cnVjdG9yKGZsYXR0ZW5lZFRoZW1lKTtcbiAgfVxuICByZXR1cm4gbGlnaHRUaGVtZSgpO1xufVxuZnVuY3Rpb24gcmVkdWNlVGhlbWVPcHRpb25zKG9wdGlvbnMpIHtcbiAgbGV0IG1heWJlTmVzdGVkID0gb3B0aW9ucztcbiAgbGV0IHBhbGV0dGU7XG4gIGNvbnN0IG92ZXJyaWRlcyA9IFtdO1xuICB3aGlsZSAodHlwZW9mIG1heWJlTmVzdGVkID09PSBcIm9iamVjdFwiKSB7XG4gICAgcGFsZXR0ZSA/PyAocGFsZXR0ZSA9IG1heWJlTmVzdGVkLnBhbGV0dGUpO1xuICAgIGlmIChtYXliZU5lc3RlZC5vdmVycmlkZXMpIHtcbiAgICAgIG92ZXJyaWRlcy5wdXNoKG1heWJlTmVzdGVkLm92ZXJyaWRlcyk7XG4gICAgfVxuICAgIG1heWJlTmVzdGVkID0gbWF5YmVOZXN0ZWQuYmFzZVRoZW1lO1xuICB9XG4gIHJldHVybiB7XG4gICAgYmFzZVRoZW1lOiBtYXliZU5lc3RlZCxcbiAgICBvdmVycmlkZXM6IG1lcmdlRGVmYXVsdHMoLi4ub3ZlcnJpZGVzKSxcbiAgICBwYWxldHRlXG4gIH07XG59XG52YXIgdGhlbWVPcHRpb25zRGVmID0ge1xuICBiYXNlVGhlbWU6IG9yKHN0cmluZywgb2JqZWN0KSxcbiAgb3ZlcnJpZGVzOiBvYmplY3QsXG4gIHBhbGV0dGU6IHtcbiAgICBmaWxsczogYXJyYXlPZihzdHJpbmcpLFxuICAgIHN0cm9rZXM6IGFycmF5T2Yoc3RyaW5nKSxcbiAgICB1cDogeyBmaWxsOiBzdHJpbmcsIHN0cm9rZTogc3RyaW5nIH0sXG4gICAgZG93bjogeyBmaWxsOiBzdHJpbmcsIHN0cm9rZTogc3RyaW5nIH0sXG4gICAgbmV1dHJhbDogeyBmaWxsOiBzdHJpbmcsIHN0cm9rZTogc3RyaW5nIH1cbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvbW9kdWxlL29wdGlvbnNNb2R1bGUudHNcbnZhciB1bnRoZW1lZFNlcmllcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcIm1hcC1zaGFwZS1iYWNrZ3JvdW5kXCIsIFwibWFwLWxpbmUtYmFja2dyb3VuZFwiXSk7XG52YXIgQ2hhcnRPcHRpb25zID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih1c2VyT3B0aW9ucywgc3BlY2lhbE92ZXJyaWRlcykge1xuICAgIHRoaXMuZGVidWcgPSBEZWJ1Zy5jcmVhdGUodHJ1ZSwgXCJvcHRzXCIpO1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBjbG9uZU9wdGlvbnMgPSB7IHNoYWxsb3c6IFtcImRhdGFcIl0gfTtcbiAgICB1c2VyT3B0aW9ucyA9IGRlZXBDbG9uZSh1c2VyT3B0aW9ucywgY2xvbmVPcHRpb25zKTtcbiAgICBjb25zdCBjaGFydFR5cGUyID0gdGhpcy5vcHRpb25zVHlwZSh1c2VyT3B0aW9ucyk7XG4gICAgaWYgKCFlbnRlcnByaXNlTW9kdWxlLmlzRW50ZXJwcmlzZSkge1xuICAgICAgcmVtb3ZlVXNlZEVudGVycHJpc2VPcHRpb25zKHVzZXJPcHRpb25zKTtcbiAgICB9XG4gICAgbGV0IG9wdGlvbnMgPSBkZWVwQ2xvbmUodXNlck9wdGlvbnMsIGNsb25lT3B0aW9ucyk7XG4gICAgdGhpcy50eXBlID0gc3BlY2lhbE92ZXJyaWRlcz8udHlwZTtcbiAgICBpZiAodGhpcy50eXBlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHByZXNldE9wdGlvbnMgPSBQUkVTRVRTW3RoaXMudHlwZV0/LihvcHRpb25zLCAoKSA9PiB0aGlzLmFjdGl2ZVRoZW1lKSA/PyBvcHRpb25zO1xuICAgICAgdGhpcy5kZWJ1ZyhcIj4+PiBBZ0NoYXJ0cy5jcmVhdGVPclVwZGF0ZSgpIC0gYXBwbHlpbmcgcHJlc2V0XCIsIG9wdGlvbnMsIHByZXNldE9wdGlvbnMpO1xuICAgICAgb3B0aW9ucyA9IHByZXNldE9wdGlvbnM7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlVGhlbWUgPSBnZXRDaGFydFRoZW1lKG9wdGlvbnMudGhlbWUpO1xuICAgIGlmICh0aGlzLnR5cGUpIHtcbiAgICAgIG9wdGlvbnMgPSB0aGlzLmFjdGl2ZVRoZW1lLnRlbXBsYXRlVGhlbWUob3B0aW9ucyk7XG4gICAgfVxuICAgIHRoaXMuc2FuaXR5Q2hlY2tBbmRDbGVhbnVwKG9wdGlvbnMpO1xuICAgIHRoaXMuZGVmYXVsdEF4ZXMgPSB0aGlzLmdldERlZmF1bHRBeGVzKG9wdGlvbnMpO1xuICAgIHRoaXMuc3BlY2lhbE92ZXJyaWRlcyA9IHRoaXMuc3BlY2lhbE92ZXJyaWRlc0RlZmF1bHRzKHsgLi4uc3BlY2lhbE92ZXJyaWRlcyB9KTtcbiAgICBjb25zdCB7XG4gICAgICBheGVzOiBheGVzVGhlbWVzID0ge30sXG4gICAgICBhbm5vdGF0aW9uczogeyBheGVzQnV0dG9ucyA9IG51bGwsIC4uLmFubm90YXRpb25zVGhlbWVzIH0gPSB7fSxcbiAgICAgIHNlcmllczogXyxcbiAgICAgIC4uLnRoZW1lRGVmYXVsdHNcbiAgICB9ID0gdGhpcy5nZXRTZXJpZXNUaGVtZUNvbmZpZyhjaGFydFR5cGUyKTtcbiAgICB0aGlzLnVzZXJPcHRpb25zID0gdXNlck9wdGlvbnM7XG4gICAgdGhpcy5wcm9jZXNzZWRPcHRpb25zID0gZGVlcENsb25lKFxuICAgICAgbWVyZ2VEZWZhdWx0cyhcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgYXhlc0J1dHRvbnMgIT0gbnVsbCA/IHsgYW5ub3RhdGlvbnM6IHsgYXhlc0J1dHRvbnMgfSB9IDoge30sXG4gICAgICAgIHRoZW1lRGVmYXVsdHMsXG4gICAgICAgIHRoaXMuZGVmYXVsdEF4ZXNcbiAgICAgICksXG4gICAgICBjbG9uZU9wdGlvbnNcbiAgICApO1xuICAgIHRoaXMucHJvY2Vzc0F4ZXNPcHRpb25zKHRoaXMucHJvY2Vzc2VkT3B0aW9ucywgYXhlc1RoZW1lcyk7XG4gICAgdGhpcy5wcm9jZXNzU2VyaWVzT3B0aW9ucyh0aGlzLnByb2Nlc3NlZE9wdGlvbnMpO1xuICAgIHRoaXMucHJvY2Vzc01pbmlDaGFydFNlcmllc09wdGlvbnModGhpcy5wcm9jZXNzZWRPcHRpb25zKTtcbiAgICB0aGlzLmFubm90YXRpb25UaGVtZXMgPSBhbm5vdGF0aW9uc1RoZW1lcztcbiAgICBpZiAoKGlzQWdDYXJ0ZXNpYW5DaGFydE9wdGlvbnModGhpcy5wcm9jZXNzZWRPcHRpb25zKSB8fCBpc0FnUG9sYXJDaGFydE9wdGlvbnNXaXRoU2VyaWVzQmFzZWRMZWdlbmQodGhpcy5wcm9jZXNzZWRPcHRpb25zKSkgJiYgdGhpcy5wcm9jZXNzZWRPcHRpb25zLmxlZ2VuZD8uZW5hYmxlZCA9PSBudWxsKSB7XG4gICAgICAoX2EgPSB0aGlzLnByb2Nlc3NlZE9wdGlvbnMpLmxlZ2VuZCA/PyAoX2EubGVnZW5kID0ge30pO1xuICAgICAgdGhpcy5wcm9jZXNzZWRPcHRpb25zLmxlZ2VuZC5lbmFibGVkID0gdGhpcy5wcm9jZXNzZWRPcHRpb25zLnNlcmllcy5sZW5ndGggPiAxO1xuICAgIH1cbiAgICB0aGlzLmVuYWJsZUNvbmZpZ3VyZWRPcHRpb25zKHRoaXMucHJvY2Vzc2VkT3B0aW9ucyk7XG4gICAgaWYgKCFlbnRlcnByaXNlTW9kdWxlLmlzRW50ZXJwcmlzZSkge1xuICAgICAgcmVtb3ZlVXNlZEVudGVycHJpc2VPcHRpb25zKHRoaXMucHJvY2Vzc2VkT3B0aW9ucywgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvY2Vzc2VkT3B0aW9ucyA/PyB7fTtcbiAgfVxuICBkaWZmT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGpzb25EaWZmKG9wdGlvbnMsIHRoaXMucHJvY2Vzc2VkT3B0aW9ucyk7XG4gIH1cbiAgZ2V0U2VyaWVzVGhlbWVDb25maWcoc2VyaWVzVHlwZTIpIHtcbiAgICBjb25zdCB0aGVtZUNvbmZpZyA9IGRlZXBDbG9uZSh0aGlzLmFjdGl2ZVRoZW1lPy5jb25maWdbc2VyaWVzVHlwZTJdID8/IHt9KTtcbiAgICB0aGlzLnJlbW92ZUxlZnRvdmVyU3ltYm9scyh0aGVtZUNvbmZpZyk7XG4gICAgcmV0dXJuIHRoZW1lQ29uZmlnO1xuICB9XG4gIGdldERlZmF1bHRBeGVzKG9wdGlvbnMpIHtcbiAgICBjb25zdCBvcHRpb25zVHlwZTIgPSB0aGlzLm9wdGlvbnNUeXBlKG9wdGlvbnMpO1xuICAgIGNvbnN0IGF4ZXNEZWZhdWx0cyA9IHNlcmllc1JlZ2lzdHJ5LmNsb25lRGVmYXVsdEF4ZXMob3B0aW9uc1R5cGUyKTtcbiAgICBpZiAoc2VyaWVzUmVnaXN0cnkuaXNEZWZhdWx0QXhpc1N3YXBOZWVkZWQob3B0aW9ucykpIHtcbiAgICAgIHRoaXMuc3dhcEF4ZXNQb3NpdGlvbihheGVzRGVmYXVsdHMpO1xuICAgIH1cbiAgICByZXR1cm4gYXhlc0RlZmF1bHRzO1xuICB9XG4gIG9wdGlvbnNUeXBlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5zZXJpZXM/LlswXT8udHlwZSA/PyBcImxpbmVcIjtcbiAgfVxuICBzYW5pdHlDaGVja0FuZENsZWFudXAob3B0aW9ucykge1xuICAgIHRoaXMuZGVwcmVjYXRpb25XYXJuaW5ncyhvcHRpb25zKTtcbiAgICB0aGlzLmF4ZXNUeXBlSW50ZWdyaXR5KG9wdGlvbnMpO1xuICAgIHRoaXMuc2VyaWVzVHlwZUludGVncml0eShvcHRpb25zKTtcbiAgICB0aGlzLnNvbG9TZXJpZXNJbnRlZ3JpdHkob3B0aW9ucyk7XG4gICAgdGhpcy5yZW1vdmVEaXNhYmxlZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgdGhpcy5yZW1vdmVMZWZ0b3ZlclN5bWJvbHMob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuc2VyaWVzPy5zb21lKChzKSA9PiBzLnR5cGUgPT09IFwiYnVsbGV0XCIpICYmIG9wdGlvbnMuc3luYyAhPSBudWxsICYmIG9wdGlvbnMuc3luYy5lbmFibGVkICE9PSBmYWxzZSkge1xuICAgICAgTG9nZ2VyLndhcm5PbmNlKFwiYnVsbGV0IHNlcmllcyBjYW5ub3QgYmUgc3luY2VkLCBkaXNhYmxpbmcgc3luY2hyb25pemF0aW9uLlwiKTtcbiAgICAgIGRlbGV0ZSBvcHRpb25zLnN5bmM7XG4gICAgfVxuICB9XG4gIHN3YXBBeGVzUG9zaXRpb24ob3B0aW9ucykge1xuICAgIGlmIChpc0FnQ2FydGVzaWFuQ2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICBjb25zdCBbYXhpczAsIGF4aXMxXSA9IG9wdGlvbnMuYXhlcyA/PyBbXTtcbiAgICAgIG9wdGlvbnMuYXhlcyA9IFtcbiAgICAgICAgeyAuLi5heGlzMCwgcG9zaXRpb246IGF4aXMxLnBvc2l0aW9uIH0sXG4gICAgICAgIHsgLi4uYXhpczEsIHBvc2l0aW9uOiBheGlzMC5wb3NpdGlvbiB9XG4gICAgICBdO1xuICAgIH1cbiAgfVxuICBwcm9jZXNzQXhlc09wdGlvbnMob3B0aW9ucywgYXhlc1RoZW1lcykge1xuICAgIGlmICghKFwiYXhlc1wiIGluIG9wdGlvbnMpKVxuICAgICAgcmV0dXJuO1xuICAgIG9wdGlvbnMuYXhlcyA9IG9wdGlvbnMuYXhlcy5tYXAoKGF4aXMpID0+IHtcbiAgICAgIGNvbnN0IHsgY3Jvc3NMaW5lczogY3Jvc3NMaW5lc1RoZW1lLCAuLi5heGlzVGhlbWUgfSA9IG1lcmdlRGVmYXVsdHMoXG4gICAgICAgIGF4ZXNUaGVtZXNbYXhpcy50eXBlXT8uW2F4aXMucG9zaXRpb25dLFxuICAgICAgICBheGVzVGhlbWVzW2F4aXMudHlwZV1cbiAgICAgICk7XG4gICAgICBpZiAoYXhpcy5jcm9zc0xpbmVzKSB7XG4gICAgICAgIGF4aXMuY3Jvc3NMaW5lcyA9IG1lcmdlQXJyYXlEZWZhdWx0cyhheGlzLmNyb3NzTGluZXMsIGNyb3NzTGluZXNUaGVtZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBncmlkTGluZVN0eWxlID0gYXhpc1RoZW1lLmdyaWRMaW5lPy5zdHlsZTtcbiAgICAgIGlmIChheGlzLmdyaWRMaW5lPy5zdHlsZSAmJiBncmlkTGluZVN0eWxlPy5sZW5ndGgpIHtcbiAgICAgICAgYXhpcy5ncmlkTGluZS5zdHlsZSA9IGF4aXMuZ3JpZExpbmUuc3R5bGUubWFwKFxuICAgICAgICAgIChzdHlsZSwgaW5kZXgpID0+IHN0eWxlLnN0cm9rZSAhPSBudWxsIHx8IHN0eWxlLmxpbmVEYXNoICE9IG51bGwgPyBtZXJnZURlZmF1bHRzKHN0eWxlLCBncmlkTGluZVN0eWxlLmF0KGluZGV4ICUgZ3JpZExpbmVTdHlsZS5sZW5ndGgpKSA6IHN0eWxlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCB7IHRvcDogXzEsIHJpZ2h0OiBfMiwgYm90dG9tOiBfMywgbGVmdDogXzQsIC4uLmF4aXNPcHRpb25zIH0gPSBtZXJnZURlZmF1bHRzKGF4aXMsIGF4aXNUaGVtZSk7XG4gICAgICByZXR1cm4gYXhpc09wdGlvbnM7XG4gICAgfSk7XG4gIH1cbiAgcHJvY2Vzc1Nlcmllc09wdGlvbnMob3B0aW9ucykge1xuICAgIGNvbnN0IGRlZmF1bHRTZXJpZXNUeXBlID0gdGhpcy5nZXREZWZhdWx0U2VyaWVzVHlwZShvcHRpb25zKTtcbiAgICBjb25zdCBkZWZhdWx0VG9vbHRpcFBvc2l0aW9uID0gdGhpcy5nZXRUb29sdGlwUG9zaXRpb25EZWZhdWx0cyhvcHRpb25zKTtcbiAgICBjb25zdCB1c2VyUGFsZXR0ZSA9IGlzT2JqZWN0KG9wdGlvbnMudGhlbWUpID8gcGFsZXR0ZVR5cGUob3B0aW9ucy50aGVtZT8ucGFsZXR0ZSkgOiBcImluYnVpbHRcIjtcbiAgICBjb25zdCBwYWxldHRlT3B0aW9ucyA9IHtcbiAgICAgIGNvbG91ckluZGV4OiAwLFxuICAgICAgdXNlclBhbGV0dGVcbiAgICB9O1xuICAgIGNvbnN0IHByb2Nlc3NlZFNlcmllcyA9IG9wdGlvbnMuc2VyaWVzPy5tYXAoKHNlcmllcykgPT4ge1xuICAgICAgc2VyaWVzLnR5cGUgPz8gKHNlcmllcy50eXBlID0gZGVmYXVsdFNlcmllc1R5cGUpO1xuICAgICAgY29uc3QgeyBpbm5lckxhYmVsczogaW5uZXJMYWJlbHNUaGVtZSwgLi4uc2VyaWVzVGhlbWUgfSA9IHRoaXMuZ2V0U2VyaWVzVGhlbWVDb25maWcoc2VyaWVzLnR5cGUpLnNlcmllcyA/PyB7fTtcbiAgICAgIGNvbnN0IHNlcmllc1BhbGV0dGVPcHRpb25zID0gdW50aGVtZWRTZXJpZXMuaGFzKHNlcmllcy50eXBlKSA/IHsgY29sb3VySW5kZXg6IDAsIHVzZXJQYWxldHRlIH0gOiBwYWxldHRlT3B0aW9ucztcbiAgICAgIGNvbnN0IHBhbGV0dGUgPSB0aGlzLmdldFNlcmllc1BhbGV0dGUoc2VyaWVzLnR5cGUsIHNlcmllc1BhbGV0dGVPcHRpb25zKTtcbiAgICAgIGNvbnN0IGRlZmF1bHRUb29sdGlwUmFuZ2UgPSB0aGlzLmdldFRvb2x0aXBSYW5nZURlZmF1bHRzKG9wdGlvbnMsIHNlcmllcy50eXBlKTtcbiAgICAgIGNvbnN0IHNlcmllc09wdGlvbnMgPSBtZXJnZURlZmF1bHRzKFxuICAgICAgICB0aGlzLmdldFNlcmllc0dyb3VwaW5nT3B0aW9ucyhzZXJpZXMpLFxuICAgICAgICBzZXJpZXMsXG4gICAgICAgIGRlZmF1bHRUb29sdGlwUG9zaXRpb24sXG4gICAgICAgIGRlZmF1bHRUb29sdGlwUmFuZ2UsXG4gICAgICAgIHNlcmllc1RoZW1lLFxuICAgICAgICBwYWxldHRlLFxuICAgICAgICB7IHZpc2libGU6IHRydWUgfVxuICAgICAgKTtcbiAgICAgIGlmIChzZXJpZXNPcHRpb25zLmlubmVyTGFiZWxzKSB7XG4gICAgICAgIHNlcmllc09wdGlvbnMuaW5uZXJMYWJlbHMgPSBtZXJnZUFycmF5RGVmYXVsdHMoc2VyaWVzT3B0aW9ucy5pbm5lckxhYmVscywgaW5uZXJMYWJlbHNUaGVtZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5hY3RpdmVUaGVtZS50ZW1wbGF0ZVRoZW1lKHNlcmllc09wdGlvbnMpO1xuICAgIH0pO1xuICAgIG9wdGlvbnMuc2VyaWVzID0gdGhpcy5zZXRTZXJpZXNHcm91cGluZ09wdGlvbnMocHJvY2Vzc2VkU2VyaWVzID8/IFtdKTtcbiAgfVxuICBwcm9jZXNzTWluaUNoYXJ0U2VyaWVzT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgbGV0IG1pbmlDaGFydFNlcmllcyA9IG9wdGlvbnMubmF2aWdhdG9yPy5taW5pQ2hhcnQ/LnNlcmllcztcbiAgICBpZiAobWluaUNoYXJ0U2VyaWVzID09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcGFsZXR0ZU9wdGlvbnMgPSB7XG4gICAgICBjb2xvdXJJbmRleDogMCxcbiAgICAgIHVzZXJQYWxldHRlOiBpc09iamVjdChvcHRpb25zLnRoZW1lKSA/IHBhbGV0dGVUeXBlKG9wdGlvbnMudGhlbWUucGFsZXR0ZSkgOiBcImluYnVpbHRcIlxuICAgIH07XG4gICAgbWluaUNoYXJ0U2VyaWVzID0gbWluaUNoYXJ0U2VyaWVzLm1hcCgoc2VyaWVzKSA9PiB7XG4gICAgICBzZXJpZXMudHlwZSA/PyAoc2VyaWVzLnR5cGUgPSBcImxpbmVcIik7XG4gICAgICBjb25zdCB7IGlubmVyTGFiZWxzOiBfLCAuLi5zZXJpZXNUaGVtZSB9ID0gdGhpcy5nZXRTZXJpZXNUaGVtZUNvbmZpZyhzZXJpZXMudHlwZSkuc2VyaWVzID8/IHt9O1xuICAgICAgY29uc3Qgc2VyaWVzT3B0aW9ucyA9IG1lcmdlRGVmYXVsdHMoXG4gICAgICAgIHRoaXMuZ2V0U2VyaWVzR3JvdXBpbmdPcHRpb25zKHNlcmllcyksXG4gICAgICAgIHNlcmllcyxcbiAgICAgICAgc2VyaWVzVGhlbWUsXG4gICAgICAgIHRoaXMuZ2V0U2VyaWVzUGFsZXR0ZShzZXJpZXMudHlwZSwgcGFsZXR0ZU9wdGlvbnMpXG4gICAgICApO1xuICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlVGhlbWUudGVtcGxhdGVUaGVtZShzZXJpZXNPcHRpb25zKTtcbiAgICB9KTtcbiAgICBvcHRpb25zLm5hdmlnYXRvci5taW5pQ2hhcnQuc2VyaWVzID0gdGhpcy5zZXRTZXJpZXNHcm91cGluZ09wdGlvbnMobWluaUNoYXJ0U2VyaWVzKTtcbiAgfVxuICBnZXRTZXJpZXNQYWxldHRlKHNlcmllc1R5cGUyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcGFsZXR0ZUZhY3RvcnkgPSBzZXJpZXNSZWdpc3RyeS5nZXRQYWxldHRlRmFjdG9yeShzZXJpZXNUeXBlMik7XG4gICAgY29uc3QgeyBjb2xvdXJJbmRleDogY29sb3VyT2Zmc2V0LCB1c2VyUGFsZXR0ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7IGZpbGxzID0gW10sIHN0cm9rZXMgPSBbXSB9ID0gdGhpcy5hY3RpdmVUaGVtZS5wYWxldHRlO1xuICAgIHJldHVybiBwYWxldHRlRmFjdG9yeT8uKHtcbiAgICAgIHVzZXJQYWxldHRlLFxuICAgICAgY29sb3JzQ291bnQ6IE1hdGgubWF4KGZpbGxzLmxlbmd0aCwgc3Ryb2tlcy5sZW5ndGgpLFxuICAgICAgdGhlbWVUZW1wbGF0ZVBhcmFtZXRlcnM6IHRoaXMuYWN0aXZlVGhlbWUuZ2V0VGVtcGxhdGVQYXJhbWV0ZXJzKCksXG4gICAgICBwYWxldHRlOiB0aGlzLmFjdGl2ZVRoZW1lLnBhbGV0dGUsXG4gICAgICB0YWtlQ29sb3JzKGNvdW50KSB7XG4gICAgICAgIG9wdGlvbnMuY29sb3VySW5kZXggKz0gY291bnQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZmlsbHM6IGNpcmN1bGFyU2xpY2VBcnJheShmaWxscywgY291bnQsIGNvbG91ck9mZnNldCksXG4gICAgICAgICAgc3Ryb2tlczogY2lyY3VsYXJTbGljZUFycmF5KHN0cm9rZXMsIGNvdW50LCBjb2xvdXJPZmZzZXQpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0U2VyaWVzR3JvdXBpbmdPcHRpb25zKHNlcmllcykge1xuICAgIGNvbnN0IGdyb3VwYWJsZSA9IHNlcmllc1JlZ2lzdHJ5LmlzR3JvdXBhYmxlKHNlcmllcy50eXBlKTtcbiAgICBjb25zdCBzdGFja2FibGUgPSBzZXJpZXNSZWdpc3RyeS5pc1N0YWNrYWJsZShzZXJpZXMudHlwZSk7XG4gICAgY29uc3Qgc3RhY2tlZEJ5RGVmYXVsdCA9IHNlcmllc1JlZ2lzdHJ5LmlzU3RhY2tlZEJ5RGVmYXVsdChzZXJpZXMudHlwZSk7XG4gICAgaWYgKHNlcmllcy5ncm91cGVkICYmICFncm91cGFibGUpIHtcbiAgICAgIExvZ2dlci53YXJuT25jZShgdW5zdXBwb3J0ZWQgZ3JvdXBpbmcgb2Ygc2VyaWVzIHR5cGUgXCIke3Nlcmllcy50eXBlfVwiLmApO1xuICAgIH1cbiAgICBpZiAoKHNlcmllcy5zdGFja2VkIHx8IHNlcmllcy5zdGFja0dyb3VwKSAmJiAhc3RhY2thYmxlKSB7XG4gICAgICBMb2dnZXIud2Fybk9uY2UoYHVuc3VwcG9ydGVkIHN0YWNraW5nIG9mIHNlcmllcyB0eXBlIFwiJHtzZXJpZXMudHlwZX1cIi5gKTtcbiAgICB9XG4gICAgbGV0IHsgZ3JvdXBlZCwgc3RhY2tlZCB9ID0gc2VyaWVzO1xuICAgIHN0YWNrZWQgPz8gKHN0YWNrZWQgPSAoc3RhY2tlZEJ5RGVmYXVsdCB8fCBzZXJpZXMuc3RhY2tHcm91cCAhPSBudWxsKSAmJiAhKGdyb3VwYWJsZSAmJiBncm91cGVkKSk7XG4gICAgZ3JvdXBlZCA/PyAoZ3JvdXBlZCA9IHRydWUpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFja2VkOiBzdGFja2FibGUgJiYgc3RhY2tlZCxcbiAgICAgIGdyb3VwZWQ6IGdyb3VwYWJsZSAmJiBncm91cGVkICYmICEoc3RhY2thYmxlICYmIHN0YWNrZWQpXG4gICAgfTtcbiAgfVxuICBzZXRTZXJpZXNHcm91cGluZ09wdGlvbnMoYWxsU2VyaWVzKSB7XG4gICAgY29uc3Qgc2VyaWVzR3JvdXBzID0gdGhpcy5nZXRTZXJpZXNHcm91cGluZyhhbGxTZXJpZXMpO1xuICAgIHRoaXMuZGVidWcoXCJzZXRTZXJpZXNHcm91cGluZ09wdGlvbnMoKSAtIHNlcmllcyBncm91cGluZzogXCIsIHNlcmllc0dyb3Vwcyk7XG4gICAgY29uc3QgZ3JvdXBJZHggPSB7fTtcbiAgICBjb25zdCBncm91cENvdW50MiA9IHNlcmllc0dyb3Vwcy5yZWR1Y2UoKGNvdW50TWFwLCBzZXJpZXNHcm91cCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHNlcmllc0dyb3VwLmdyb3VwVHlwZSA9PT0gXCJkZWZhdWx0XCIgLyogREVGQVVMVCAqLykge1xuICAgICAgICByZXR1cm4gY291bnRNYXA7XG4gICAgICB9XG4gICAgICBjb3VudE1hcFtfYSA9IHNlcmllc0dyb3VwLnNlcmllc1R5cGVdID8/IChjb3VudE1hcFtfYV0gPSAwKTtcbiAgICAgIGNvdW50TWFwW3Nlcmllc0dyb3VwLnNlcmllc1R5cGVdICs9IHNlcmllc0dyb3VwLmdyb3VwVHlwZSA9PT0gXCJzdGFja1wiIC8qIFNUQUNLICovID8gMSA6IHNlcmllc0dyb3VwLnNlcmllcy5sZW5ndGg7XG4gICAgICByZXR1cm4gY291bnRNYXA7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBzZXJpZXNHcm91cHMuZmxhdE1hcCgoc2VyaWVzR3JvdXApID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGdyb3VwSWR4W19hID0gc2VyaWVzR3JvdXAuc2VyaWVzVHlwZV0gPz8gKGdyb3VwSWR4W19hXSA9IDApO1xuICAgICAgc3dpdGNoIChzZXJpZXNHcm91cC5ncm91cFR5cGUpIHtcbiAgICAgICAgY2FzZSBcInN0YWNrXCIgLyogU1RBQ0sgKi86XG4gICAgICAgICAgY29uc3QgZ3JvdXBJbmRleCA9IGdyb3VwSWR4W3Nlcmllc0dyb3VwLnNlcmllc1R5cGVdKys7XG4gICAgICAgICAgcmV0dXJuIHNlcmllc0dyb3VwLnNlcmllcy5tYXAoXG4gICAgICAgICAgICAoc2VyaWVzLCBzdGFja0luZGV4KSA9PiBPYmplY3QuYXNzaWduKHNlcmllcywge1xuICAgICAgICAgICAgICBzZXJpZXNHcm91cGluZzoge1xuICAgICAgICAgICAgICAgIGdyb3VwSWQ6IHNlcmllc0dyb3VwLmdyb3VwSWQsXG4gICAgICAgICAgICAgICAgZ3JvdXBJbmRleCxcbiAgICAgICAgICAgICAgICBncm91cENvdW50OiBncm91cENvdW50MltzZXJpZXNHcm91cC5zZXJpZXNUeXBlXSxcbiAgICAgICAgICAgICAgICBzdGFja0luZGV4LFxuICAgICAgICAgICAgICAgIHN0YWNrQ291bnQ6IHNlcmllc0dyb3VwLnNlcmllcy5sZW5ndGhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICBjYXNlIFwiZ3JvdXBcIiAvKiBHUk9VUCAqLzpcbiAgICAgICAgICByZXR1cm4gc2VyaWVzR3JvdXAuc2VyaWVzLm1hcChcbiAgICAgICAgICAgIChzZXJpZXMpID0+IE9iamVjdC5hc3NpZ24oc2VyaWVzLCB7XG4gICAgICAgICAgICAgIHNlcmllc0dyb3VwaW5nOiB7XG4gICAgICAgICAgICAgICAgZ3JvdXBJZDogc2VyaWVzR3JvdXAuZ3JvdXBJZCxcbiAgICAgICAgICAgICAgICBncm91cEluZGV4OiBncm91cElkeFtzZXJpZXNHcm91cC5zZXJpZXNUeXBlXSsrLFxuICAgICAgICAgICAgICAgIGdyb3VwQ291bnQ6IGdyb3VwQ291bnQyW3Nlcmllc0dyb3VwLnNlcmllc1R5cGVdLFxuICAgICAgICAgICAgICAgIHN0YWNrSW5kZXg6IDAsXG4gICAgICAgICAgICAgICAgc3RhY2tDb3VudDogMFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VyaWVzR3JvdXAuc2VyaWVzO1xuICAgIH0pLm1hcCgoeyBzdGFja2VkOiBfLCBncm91cGVkOiBfXywgLi4uc2VyaWVzT3B0aW9ucyB9KSA9PiBzZXJpZXNPcHRpb25zKTtcbiAgfVxuICBnZXRTZXJpZXNHcm91cElkKHNlcmllcykge1xuICAgIHJldHVybiBbc2VyaWVzLnR5cGUsIHNlcmllcy54S2V5LCBzZXJpZXMuc3RhY2tlZCA/IHNlcmllcy5zdGFja0dyb3VwID8/IFwic3RhY2tlZFwiIDogXCJncm91cGVkXCJdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiLVwiKTtcbiAgfVxuICBnZXRTZXJpZXNHcm91cGluZyhhbGxTZXJpZXMpIHtcbiAgICBjb25zdCBncm91cE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgcmV0dXJuIGFsbFNlcmllcy5yZWR1Y2UoKHJlc3VsdCwgc2VyaWVzKSA9PiB7XG4gICAgICBjb25zdCBzZXJpZXNUeXBlMiA9IHNlcmllcy50eXBlO1xuICAgICAgaWYgKCFzZXJpZXMuc3RhY2tlZCAmJiAhc2VyaWVzLmdyb3VwZWQpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goeyBncm91cFR5cGU6IFwiZGVmYXVsdFwiIC8qIERFRkFVTFQgKi8sIHNlcmllc1R5cGU6IHNlcmllc1R5cGUyLCBzZXJpZXM6IFtzZXJpZXNdLCBncm91cElkOiBcIl9fZGVmYXVsdF9fXCIgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBncm91cElkID0gdGhpcy5nZXRTZXJpZXNHcm91cElkKHNlcmllcyk7XG4gICAgICAgIGlmICghZ3JvdXBNYXAuaGFzKGdyb3VwSWQpKSB7XG4gICAgICAgICAgY29uc3QgZ3JvdXBUeXBlID0gc2VyaWVzLnN0YWNrZWQgPyBcInN0YWNrXCIgLyogU1RBQ0sgKi8gOiBcImdyb3VwXCIgLyogR1JPVVAgKi87XG4gICAgICAgICAgY29uc3QgcmVjb3JkID0geyBncm91cFR5cGUsIHNlcmllc1R5cGU6IHNlcmllc1R5cGUyLCBzZXJpZXM6IFtdLCBncm91cElkIH07XG4gICAgICAgICAgZ3JvdXBNYXAuc2V0KGdyb3VwSWQsIHJlY29yZCk7XG4gICAgICAgICAgcmVzdWx0LnB1c2gocmVjb3JkKTtcbiAgICAgICAgfVxuICAgICAgICBncm91cE1hcC5nZXQoZ3JvdXBJZCkuc2VyaWVzLnB1c2goc2VyaWVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuICB9XG4gIGdldERlZmF1bHRTZXJpZXNUeXBlKG9wdGlvbnMpIHtcbiAgICBpZiAoaXNBZ0NhcnRlc2lhbkNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIFwibGluZVwiO1xuICAgIH0gZWxzZSBpZiAoaXNBZ1BvbGFyQ2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gXCJwaWVcIjtcbiAgICB9IGVsc2UgaWYgKGlzQWdIaWVyYXJjaHlDaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBcInRyZWVtYXBcIjtcbiAgICB9IGVsc2UgaWYgKGlzQWdUb3BvbG9neUNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIFwibWFwLXNoYXBlXCI7XG4gICAgfSBlbHNlIGlmIChpc0FnRmxvd1Byb3BvcnRpb25DaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBcInNhbmtleVwiO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNoYXJ0IG9wdGlvbnMgdHlwZSBkZXRlY3RlZC5cIik7XG4gIH1cbiAgZ2V0VG9vbHRpcFBvc2l0aW9uRGVmYXVsdHMob3B0aW9ucykge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gb3B0aW9ucy50b29sdGlwPy5wb3NpdGlvbjtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QocG9zaXRpb24pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgdHlwZSwgeE9mZnNldCwgeU9mZnNldCB9ID0gcG9zaXRpb247XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgaWYgKGlzU3RyaW5nKHR5cGUpICYmIGlzRW51bVZhbHVlKEFnVG9vbHRpcFBvc2l0aW9uVHlwZSwgdHlwZSkpIHtcbiAgICAgIHJlc3VsdC50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgaWYgKGlzRmluaXRlTnVtYmVyKHhPZmZzZXQpKSB7XG4gICAgICByZXN1bHQueE9mZnNldCA9IHhPZmZzZXQ7XG4gICAgfVxuICAgIGlmIChpc0Zpbml0ZU51bWJlcih5T2Zmc2V0KSkge1xuICAgICAgcmVzdWx0LnlPZmZzZXQgPSB5T2Zmc2V0O1xuICAgIH1cbiAgICByZXR1cm4geyB0b29sdGlwOiB7IHBvc2l0aW9uOiByZXN1bHQgfSB9O1xuICB9XG4gIC8vIEFHLTExNTkxIFN1cHBvcnQgZm9yIG5ldyBzZXJpZXMtc3BlY2lmaWMgJiBsZWdhY3kgY2hhcnQtZ2xvYmFsICd0b29sdGlwLnJhbmdlJyBvcHRpb25zXG4gIC8vXG4gIC8vIFRoZSBgY2hhcnQuc2VyaWVzW10udG9vbHRpcC5yYW5nZWAgb3B0aW9uIGlzIGEgYml0IGRpZmZlcmVudCBmb3IgbGVnYWN5IHJlYXNvbi4gVGhpcyB1c2UgdG8gYmVcbiAgLy8gZ2xvYmFsIG9wdGlvbiAoYGNoYXJ0LnRvb2x0aXAucmFuZ2VgKSB0aGF0IGNvdWxkIG92ZXJyaWRlIHRoZSB0aGVtZS4gQnV0IG5vdywgdGhlIHRvb2x0aXAgcmFuZ2VcbiAgLy8gb3B0aW9uIGlzIHNlcmllcy1zcGVjaWZpYy5cbiAgLy9cbiAgLy8gVG8gcHJlc2VydmUgYmFja3dhcmQgY29tcGF0aWJsaXR5LCB0aGUgYGNoYXJ0LnRvb2x0aXAucmFuZ2VgIHRoZW1lIGRlZmF1bHQgaGFzIGJlZW4gY2hhbmdlZCBmcm9tXG4gIC8vICduZWFyZXN0JyB0byB1bmRlZmluZWQuXG4gIGdldFRvb2x0aXBSYW5nZURlZmF1bHRzKG9wdGlvbnMsIHNlcmllc1R5cGUyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgcmFuZ2U6IG9wdGlvbnMudG9vbHRpcD8ucmFuZ2UgPz8gc2VyaWVzUmVnaXN0cnkuZ2V0VG9vbHRpcERlZmF1bHMoc2VyaWVzVHlwZTIpPy5yYW5nZVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZGVwcmVjYXRpb25XYXJuaW5ncyhvcHRpb25zKSB7XG4gICAgY29uc3QgZGVwcmVjYXRlZEFycmF5UHJvcHMgPSB7IHlLZXlzOiBcInlLZXlcIiwgeU5hbWVzOiBcInlOYW1lXCIgfTtcbiAgICBPYmplY3QuZW50cmllcyhkZXByZWNhdGVkQXJyYXlQcm9wcykuZm9yRWFjaCgoW29sZFByb3AsIG5ld1Byb3BdKSA9PiB7XG4gICAgICBpZiAob3B0aW9ucy5zZXJpZXM/LnNvbWUoKHMpID0+IHNbb2xkUHJvcF0gIT0gbnVsbCkpIHtcbiAgICAgICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgICAgIGBQcm9wZXJ0eSBbc2VyaWVzLiR7b2xkUHJvcH1dIGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSB1c2UgW3Nlcmllcy4ke25ld1Byb3B9XSBhbmQgbXVsdGlwbGUgc2VyaWVzIGluc3RlYWQuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGF4ZXNUeXBlSW50ZWdyaXR5KG9wdGlvbnMpIHtcbiAgICBpZiAoXCJheGVzXCIgaW4gb3B0aW9ucykge1xuICAgICAgY29uc3QgYXhlcyA9IG9wdGlvbnMuYXhlcyA/PyBbXTtcbiAgICAgIGZvciAoY29uc3QgeyB0eXBlIH0gb2YgYXhlcykge1xuICAgICAgICBpZiAoIWlzQXhpc09wdGlvblR5cGUodHlwZSkpIHtcbiAgICAgICAgICBkZWxldGUgb3B0aW9ucy5heGVzO1xuICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBheGlzUmVnaXN0cnkucHVibGljS2V5cygpLmpvaW4oXCIsIFwiKTtcbiAgICAgICAgICBMb2dnZXIud2Fybk9uY2UoYHVua25vd24gYXhpcyB0eXBlOiAke3R5cGV9OyBleHBlY3RlZCBvbmUgb2Y6ICR7ZXhwZWN0ZWRUeXBlc31gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBzZXJpZXNUeXBlSW50ZWdyaXR5KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zLnNlcmllcyA9IG9wdGlvbnMuc2VyaWVzPy5maWx0ZXIoKHsgdHlwZSB9KSA9PiB7XG4gICAgICBpZiAodHlwZSA9PSBudWxsIHx8IGlzU2VyaWVzT3B0aW9uVHlwZSh0eXBlKSB8fCBpc0VudGVycHJpc2VTZXJpZXNUeXBlKHR5cGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgTG9nZ2VyLndhcm5PbmNlKFxuICAgICAgICBgdW5rbm93biBzZXJpZXMgdHlwZTogJHt0eXBlfTsgZXhwZWN0ZWQgb25lIG9mOiAke3B1YmxpY0NoYXJ0VHlwZXMuc2VyaWVzVHlwZXMuam9pbihcIiwgXCIpfWBcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cbiAgc29sb1Nlcmllc0ludGVncml0eShvcHRpb25zKSB7XG4gICAgY29uc3QgYWxsU2VyaWVzID0gb3B0aW9ucy5zZXJpZXM7XG4gICAgaWYgKGFsbFNlcmllcyAmJiBhbGxTZXJpZXMubGVuZ3RoID4gMSAmJiBhbGxTZXJpZXMuc29tZSgoc2VyaWVzKSA9PiBzZXJpZXNSZWdpc3RyeS5pc1NvbG8oc2VyaWVzLnR5cGUpKSkge1xuICAgICAgY29uc3QgbWFpblNlcmllc1R5cGUgPSB0aGlzLm9wdGlvbnNUeXBlKG9wdGlvbnMpO1xuICAgICAgaWYgKHNlcmllc1JlZ2lzdHJ5LmlzU29sbyhtYWluU2VyaWVzVHlwZSkpIHtcbiAgICAgICAgTG9nZ2VyLndhcm4oXG4gICAgICAgICAgYHNlcmllc1swXSBvZiB0eXBlICcke21haW5TZXJpZXNUeXBlfScgaXMgaW5jb21wYXRpYmxlIHdpdGggb3RoZXIgc2VyaWVzIHR5cGVzLiBPbmx5IHByb2Nlc3Npbmcgc2VyaWVzWzBdYFxuICAgICAgICApO1xuICAgICAgICBvcHRpb25zLnNlcmllcyA9IGFsbFNlcmllcy5zbGljZSgwLCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHsgc29sbywgbm9uU29sbyB9ID0gZ3JvdXBCeShcbiAgICAgICAgICBhbGxTZXJpZXMsXG4gICAgICAgICAgKHMpID0+IHNlcmllc1JlZ2lzdHJ5LmlzU29sbyhzLnR5cGUpID8gXCJzb2xvXCIgOiBcIm5vblNvbG9cIlxuICAgICAgICApO1xuICAgICAgICBjb25zdCByZWplY3RzID0gdW5pcXVlKHNvbG8ubWFwKChzKSA9PiBzLnR5cGUpKS5qb2luKFwiLCBcIik7XG4gICAgICAgIExvZ2dlci53YXJuKGBVbmFibGUgdG8gbWl4IHRoZXNlIHNlcmllcyB0eXBlcyB3aXRoIHRoZSBsZWFkIHNlcmllcyB0eXBlOiAke3JlamVjdHN9YCk7XG4gICAgICAgIG9wdGlvbnMuc2VyaWVzID0gbm9uU29sbztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZW5hYmxlQ29uZmlndXJlZE9wdGlvbnMob3B0aW9ucykge1xuICAgIGpzb25XYWxrKFxuICAgICAgdGhpcy51c2VyT3B0aW9ucyxcbiAgICAgICh2aXNpdGluZ1VzZXJPcHRzLCB2aXNpdGluZ01lcmdlZE9wdHMpID0+IHtcbiAgICAgICAgaWYgKHZpc2l0aW5nTWVyZ2VkT3B0cyAmJiBcImVuYWJsZWRcIiBpbiB2aXNpdGluZ01lcmdlZE9wdHMgJiYgIXZpc2l0aW5nTWVyZ2VkT3B0cy5fZW5hYmxlZEZyb21UaGVtZSAmJiB2aXNpdGluZ1VzZXJPcHRzLmVuYWJsZWQgPT0gbnVsbCkge1xuICAgICAgICAgIHZpc2l0aW5nTWVyZ2VkT3B0cy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHsgc2tpcDogW1wiZGF0YVwiLCBcInRoZW1lXCJdIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICBqc29uV2FsayhcbiAgICAgIG9wdGlvbnMsXG4gICAgICAodmlzaXRpbmdNZXJnZWRPcHRzKSA9PiB7XG4gICAgICAgIGlmICh2aXNpdGluZ01lcmdlZE9wdHMuX2VuYWJsZWRGcm9tVGhlbWUgIT0gbnVsbCkge1xuICAgICAgICAgIGRlbGV0ZSB2aXNpdGluZ01lcmdlZE9wdHMuX2VuYWJsZWRGcm9tVGhlbWU7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7IHNraXA6IFtcImRhdGFcIiwgXCJ0aGVtZVwiXSB9XG4gICAgKTtcbiAgfVxuICByZW1vdmVEaXNhYmxlZE9wdGlvbnMob3B0aW9ucykge1xuICAgIGpzb25XYWxrKFxuICAgICAgb3B0aW9ucyxcbiAgICAgIChvcHRpb25zTm9kZSkgPT4ge1xuICAgICAgICBpZiAoXCJlbmFibGVkXCIgaW4gb3B0aW9uc05vZGUgJiYgb3B0aW9uc05vZGUuZW5hYmxlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBPYmplY3Qua2V5cyhvcHRpb25zTm9kZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImVuYWJsZWRcIilcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnNOb2RlW2tleV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7IHNraXA6IFtcImRhdGFcIiwgXCJ0aGVtZVwiXSB9XG4gICAgKTtcbiAgfVxuICByZW1vdmVMZWZ0b3ZlclN5bWJvbHMob3B0aW9ucykge1xuICAgIGpzb25XYWxrKFxuICAgICAgb3B0aW9ucyxcbiAgICAgIChvcHRpb25zTm9kZSkgPT4ge1xuICAgICAgICBpZiAoIW9wdGlvbnNOb2RlIHx8ICFpc09iamVjdChvcHRpb25zTm9kZSkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhvcHRpb25zTm9kZSkpIHtcbiAgICAgICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgICAgICBkZWxldGUgb3B0aW9uc05vZGVba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7IHNraXA6IFtcImRhdGFcIl0gfVxuICAgICk7XG4gIH1cbiAgc3BlY2lhbE92ZXJyaWRlc0RlZmF1bHRzKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy53aW5kb3cgIT0gbnVsbCkge1xuICAgICAgc2V0V2luZG93KG9wdGlvbnMud2luZG93KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIG9wdGlvbnMud2luZG93ID0gd2luZG93O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgb3B0aW9ucy53aW5kb3cgPSBnbG9iYWwud2luZG93O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5kb2N1bWVudCAhPSBudWxsKSB7XG4gICAgICBzZXREb2N1bWVudChvcHRpb25zLmRvY3VtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgb3B0aW9ucy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgb3B0aW9ucy5kb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMud2luZG93ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIHVuYWJsZSB0byByZXNvbHZlIGdsb2JhbCB3aW5kb3dcIik7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRvY3VtZW50ID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFHIENoYXJ0cyAtIHVuYWJsZSB0byByZXNvbHZlIGdsb2JhbCBkb2N1bWVudFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2FwaS9hZ0NoYXJ0cy50c1xudmFyIGRlYnVnMiA9IERlYnVnLmNyZWF0ZSh0cnVlLCBcIm9wdHNcIik7XG5mdW5jdGlvbiBjaGFydFR5cGUob3B0aW9ucykge1xuICBpZiAoaXNBZ0NhcnRlc2lhbkNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgIHJldHVybiBcImNhcnRlc2lhblwiO1xuICB9IGVsc2UgaWYgKGlzQWdQb2xhckNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgIHJldHVybiBcInBvbGFyXCI7XG4gIH0gZWxzZSBpZiAoaXNBZ0hpZXJhcmNoeUNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgIHJldHVybiBcImhpZXJhcmNoeVwiO1xuICB9IGVsc2UgaWYgKGlzQWdUb3BvbG9neUNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgIHJldHVybiBcInRvcG9sb2d5XCI7XG4gIH0gZWxzZSBpZiAoaXNBZ0Zsb3dQcm9wb3J0aW9uQ2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgcmV0dXJuIFwiZmxvdy1wcm9wb3J0aW9uXCI7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBBRyBDaGFydCAtIHVua25vd24gdHlwZSBvZiBjaGFydCBmb3Igb3B0aW9ucyB3aXRoIHR5cGU6ICR7b3B0aW9ucy50eXBlfWApO1xufVxudmFyIEFnQ2hhcnRzID0gY2xhc3Mge1xuICBzdGF0aWMgbGljZW5zZUNoZWNrKG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5saWNlbnNlQ2hlY2tlZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmxpY2Vuc2VNYW5hZ2VyID0gZW50ZXJwcmlzZU1vZHVsZS5saWNlbnNlTWFuYWdlcj8uKG9wdGlvbnMpO1xuICAgIHRoaXMubGljZW5zZU1hbmFnZXI/LnNldExpY2Vuc2VLZXkodGhpcy5saWNlbnNlS2V5LCB0aGlzLmdyaWRDb250ZXh0KTtcbiAgICB0aGlzLmxpY2Vuc2VNYW5hZ2VyPy52YWxpZGF0ZUxpY2Vuc2UoKTtcbiAgICB0aGlzLmxpY2Vuc2VDaGVja2VkID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgc2V0TGljZW5zZUtleShsaWNlbnNlS2V5KSB7XG4gICAgdGhpcy5saWNlbnNlS2V5ID0gbGljZW5zZUtleTtcbiAgfVxuICBzdGF0aWMgc2V0R3JpZENvbnRleHQoZ3JpZENvbnRleHQpIHtcbiAgICB0aGlzLmdyaWRDb250ZXh0ID0gZ3JpZENvbnRleHQ7XG4gIH1cbiAgc3RhdGljIGdldExpY2Vuc2VEZXRhaWxzKGxpY2Vuc2VLZXkpIHtcbiAgICByZXR1cm4gZW50ZXJwcmlzZU1vZHVsZS5saWNlbnNlTWFuYWdlcj8uKHt9KS5nZXRMaWNlbnNlRGV0YWlscyhsaWNlbnNlS2V5KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYEFnQ2hhcnRJbnN0YW5jZWAgZm9yIGEgRE9NIG5vZGUsIGlmIHRoZXJlIGlzIG9uZS5cbiAgICovXG4gIHN0YXRpYyBnZXRJbnN0YW5jZShlbGVtZW50Mikge1xuICAgIHJldHVybiBBZ0NoYXJ0c0ludGVybmFsLmdldEluc3RhbmNlKGVsZW1lbnQyKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBBZ0NoYXJ0SW5zdGFuY2VgIGJhc2VkIHVwb24gdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGUob3B0aW9ucykge1xuICAgIHRoaXMubGljZW5zZUNoZWNrKG9wdGlvbnMpO1xuICAgIGNvbnN0IGNoYXJ0ID0gQWdDaGFydHNJbnRlcm5hbC5jcmVhdGVPclVwZGF0ZShvcHRpb25zLCB2b2lkIDAsIHRoaXMubGljZW5zZU1hbmFnZXIpO1xuICAgIGlmIChlbnRlcnByaXNlTW9kdWxlLnN0eWxlcyAhPSBudWxsKSB7XG4gICAgICBjaGFydC5jaGFydC5jdHguZG9tTWFuYWdlci5hZGRTdHlsZXMoXCJhZy1jaGFydHMtZW50ZXJwcmlzZVwiLCBlbnRlcnByaXNlTW9kdWxlLnN0eWxlcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmxpY2Vuc2VNYW5hZ2VyPy5pc0Rpc3BsYXlXYXRlcm1hcmsoKSAmJiB0aGlzLmxpY2Vuc2VNYW5hZ2VyKSB7XG4gICAgICBlbnRlcnByaXNlTW9kdWxlLmluamVjdFdhdGVybWFyaz8uKGNoYXJ0LmNoYXJ0LmN0eC5kb21NYW5hZ2VyLCB0aGlzLmxpY2Vuc2VNYW5hZ2VyLmdldFdhdGVybWFya01lc3NhZ2UoKSk7XG4gICAgfVxuICAgIHJldHVybiBjaGFydDtcbiAgfVxuICBzdGF0aWMgY3JlYXRlRmluYW5jaWFsQ2hhcnQob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZSh7XG4gICAgICBfdHlwZTogXCJwcmljZS12b2x1bWVcIixcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfVxufTtcbkFnQ2hhcnRzLmxpY2Vuc2VDaGVja2VkID0gZmFsc2U7XG5BZ0NoYXJ0cy5ncmlkQ29udGV4dCA9IGZhbHNlO1xudmFyIF9BZ0NoYXJ0c0ludGVybmFsID0gY2xhc3MgX0FnQ2hhcnRzSW50ZXJuYWwge1xuICBzdGF0aWMgZ2V0SW5zdGFuY2UoZWxlbWVudDIpIHtcbiAgICBjb25zdCBjaGFydCA9IENoYXJ0LmdldEluc3RhbmNlKGVsZW1lbnQyKTtcbiAgICByZXR1cm4gY2hhcnQgPyBBZ0NoYXJ0SW5zdGFuY2VQcm94eS5jaGFydEluc3RhbmNlcy5nZXQoY2hhcnQpIDogdm9pZCAwO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXNlTW9kdWxlcygpIHtcbiAgICBpZiAoX0FnQ2hhcnRzSW50ZXJuYWwuaW5pdGlhbGlzZWQpXG4gICAgICByZXR1cm47XG4gICAgcmVnaXN0ZXJJbmJ1aWx0TW9kdWxlcygpO1xuICAgIHNldHVwTW9kdWxlcygpO1xuICAgIF9BZ0NoYXJ0c0ludGVybmFsLmluaXRpYWxpc2VkID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgY3JlYXRlT3JVcGRhdGUob3B0aW9ucywgcHJveHksIGxpY2Vuc2VNYW5hZ2VyKSB7XG4gICAgX0FnQ2hhcnRzSW50ZXJuYWwuaW5pdGlhbGlzZU1vZHVsZXMoKTtcbiAgICBkZWJ1ZzIoXCI+Pj4gQWdDaGFydHMuY3JlYXRlT3JVcGRhdGUoKSB1c2VyIG9wdGlvbnNcIiwgb3B0aW9ucyk7XG4gICAgY29uc3QgZGVmYXVsdFR5cGUgPSBwcm94eT8uY2hhcnQuY2hhcnRPcHRpb25zLnR5cGU7XG4gICAgY29uc3QgeyBfdHlwZSA9IGRlZmF1bHRUeXBlLCAuLi5vdGhlck9wdGlvbnMgfSA9IG9wdGlvbnM7XG4gICAgbGV0IG11dGFibGVPcHRpb25zID0gb3RoZXJPcHRpb25zO1xuICAgIGlmIChBZ0NoYXJ0cy5vcHRpb25zTXV0YXRpb25Gbikge1xuICAgICAgbXV0YWJsZU9wdGlvbnMgPSBBZ0NoYXJ0cy5vcHRpb25zTXV0YXRpb25GbihtdXRhYmxlT3B0aW9ucywgX3R5cGUpO1xuICAgICAgZGVidWcyKFwiPj4+IEFnQ2hhcnRzLmNyZWF0ZU9yVXBkYXRlKCkgTVVUQVRFRCB1c2VyIG9wdGlvbnNcIiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNvbnN0IHsgb3ZlcnJpZGVEZXZpY2VQaXhlbFJhdGlvLCBkb2N1bWVudDogZG9jdW1lbnQyLCB3aW5kb3c6IHVzZXJXaW5kb3csIC4uLnVzZXJPcHRpb25zIH0gPSBtdXRhYmxlT3B0aW9ucztcbiAgICBjb25zdCBjaGFydE9wdGlvbnMgPSBuZXcgQ2hhcnRPcHRpb25zKHVzZXJPcHRpb25zLCB7XG4gICAgICBvdmVycmlkZURldmljZVBpeGVsUmF0aW8sXG4gICAgICBkb2N1bWVudDogZG9jdW1lbnQyLFxuICAgICAgd2luZG93OiB1c2VyV2luZG93LFxuICAgICAgdHlwZTogX3R5cGVcbiAgICB9KTtcbiAgICBsZXQgY2hhcnQgPSBwcm94eT8uY2hhcnQ7XG4gICAgaWYgKGNoYXJ0ID09IG51bGwgfHwgY2hhcnRUeXBlKHVzZXJPcHRpb25zKSAhPT0gY2hhcnRUeXBlKGNoYXJ0Py5jaGFydE9wdGlvbnMucHJvY2Vzc2VkT3B0aW9ucykpIHtcbiAgICAgIGNoYXJ0ID0gX0FnQ2hhcnRzSW50ZXJuYWwuY3JlYXRlQ2hhcnRJbnN0YW5jZShjaGFydE9wdGlvbnMsIGNoYXJ0KTtcbiAgICB9XG4gICAgaWYgKHByb3h5ID09IG51bGwpIHtcbiAgICAgIHByb3h5ID0gbmV3IEFnQ2hhcnRJbnN0YW5jZVByb3h5KGNoYXJ0LCBfQWdDaGFydHNJbnRlcm5hbC5jYWxsYmFja0FwaSwgbGljZW5zZU1hbmFnZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm94eS5jaGFydCA9IGNoYXJ0O1xuICAgIH1cbiAgICBpZiAoZGVidWcyLmNoZWNrKCkgJiYgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgd2luZG93LmFnQ2hhcnRJbnN0YW5jZXMgPz8gKHdpbmRvdy5hZ0NoYXJ0SW5zdGFuY2VzID0ge30pO1xuICAgICAgd2luZG93LmFnQ2hhcnRJbnN0YW5jZXNbY2hhcnQuaWRdID0gY2hhcnQ7XG4gICAgfVxuICAgIGNoYXJ0LnF1ZXVlZFVzZXJPcHRpb25zLnB1c2godXNlck9wdGlvbnMpO1xuICAgIGNoYXJ0LnJlcXVlc3RGYWN0b3J5VXBkYXRlKChjaGFydFJlZikgPT4ge1xuICAgICAgY2hhcnRSZWYuYXBwbHlPcHRpb25zKGNoYXJ0T3B0aW9ucyk7XG4gICAgICBjb25zdCBxdWV1ZUlkeCA9IGNoYXJ0UmVmLnF1ZXVlZFVzZXJPcHRpb25zLmluZGV4T2YodXNlck9wdGlvbnMpICsgMTtcbiAgICAgIGNoYXJ0UmVmLnF1ZXVlZFVzZXJPcHRpb25zLnNwbGljZSgwLCBxdWV1ZUlkeCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb3h5O1xuICB9XG4gIHN0YXRpYyB1cGRhdGVVc2VyRGVsdGEocHJveHksIGRlbHRhT3B0aW9ucykge1xuICAgIGRlbHRhT3B0aW9ucyA9IGRlZXBDbG9uZShkZWx0YU9wdGlvbnMsIHsgc2hhbGxvdzogW1wiZGF0YVwiXSB9KTtcbiAgICBqc29uV2FsayhcbiAgICAgIGRlbHRhT3B0aW9ucyxcbiAgICAgIChub2RlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gXCJvYmplY3RcIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG5vZGUpKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihub2RlLCB7IFtrZXldOiBTeW1ib2woXCJVTlNFVFwiKSB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7IHNraXA6IFtcImRhdGFcIl0gfVxuICAgICk7XG4gICAgY29uc3QgeyBjaGFydCB9ID0gcHJveHk7XG4gICAgY29uc3QgbGFzdFVwZGF0ZU9wdGlvbnMgPSBjaGFydC5nZXRPcHRpb25zKCk7XG4gICAgY29uc3QgdXNlck9wdGlvbnMgPSBtZXJnZURlZmF1bHRzKGRlbHRhT3B0aW9ucywgbGFzdFVwZGF0ZU9wdGlvbnMpO1xuICAgIGRlYnVnMihcIj4+PiBBZ0NoYXJ0cy51cGRhdGVVc2VyRGVsdGEoKSB1c2VyIGRlbHRhXCIsIGRlbHRhT3B0aW9ucyk7XG4gICAgZGVidWcyKFwiQWdDaGFydHMudXBkYXRlVXNlckRlbHRhKCkgLSBiYXNlIG9wdGlvbnNcIiwgbGFzdFVwZGF0ZU9wdGlvbnMpO1xuICAgIF9BZ0NoYXJ0c0ludGVybmFsLmNyZWF0ZU9yVXBkYXRlKHVzZXJPcHRpb25zLCBwcm94eSk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZUNoYXJ0SW5zdGFuY2Uob3B0aW9ucywgb2xkQ2hhcnQpIHtcbiAgICBjb25zdCB0cmFuc2ZlcmFibGVSZXNvdXJjZSA9IG9sZENoYXJ0Py5kZXN0cm95KHsga2VlcFRyYW5zZmVyYWJsZVJlc291cmNlczogdHJ1ZSB9KTtcbiAgICBjb25zdCBDaGFydENvbnN0cnVjdG9yID0gX0FnQ2hhcnRzSW50ZXJuYWwuZ2V0Q2hhcnRCeU9wdGlvbnMob3B0aW9ucy5wcm9jZXNzZWRPcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IENoYXJ0Q29uc3RydWN0b3Iob3B0aW9ucywgdHJhbnNmZXJhYmxlUmVzb3VyY2UpO1xuICB9XG4gIHN0YXRpYyBnZXRDaGFydEJ5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKGlzQWdDYXJ0ZXNpYW5DaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBDYXJ0ZXNpYW5DaGFydDtcbiAgICB9IGVsc2UgaWYgKGlzQWdIaWVyYXJjaHlDaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBIaWVyYXJjaHlDaGFydDtcbiAgICB9IGVsc2UgaWYgKGlzQWdQb2xhckNoYXJ0T3B0aW9ucyhvcHRpb25zKSkge1xuICAgICAgcmV0dXJuIFBvbGFyQ2hhcnQ7XG4gICAgfSBlbHNlIGlmIChpc0FnVG9wb2xvZ3lDaGFydE9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBUb3BvbG9neUNoYXJ0O1xuICAgIH0gZWxzZSBpZiAoaXNBZ0Zsb3dQcm9wb3J0aW9uQ2hhcnRPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gRmxvd1Byb3BvcnRpb25DaGFydDtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEFHIENoYXJ0cyAtIGNvdWxkbid0IGFwcGx5IGNvbmZpZ3VyYXRpb24sIGNoZWNrIG9wdGlvbnMgYXJlIGNvcnJlY3RseSBzdHJ1Y3R1cmVkIGFuZCBzZXJpZXMgdHlwZXMgYXJlIHNwZWNpZmllZGBcbiAgICApO1xuICB9XG59O1xuX0FnQ2hhcnRzSW50ZXJuYWwuY2FyZXRha2VyID0gbmV3IE1lbWVudG9DYXJldGFrZXIoVkVSU0lPTik7XG5fQWdDaGFydHNJbnRlcm5hbC5pbml0aWFsaXNlZCA9IGZhbHNlO1xuX0FnQ2hhcnRzSW50ZXJuYWwuY2FsbGJhY2tBcGkgPSB7XG4gIGNhcmV0YWtlcjogX0FnQ2hhcnRzSW50ZXJuYWwuY2FyZXRha2VyLFxuICBjcmVhdGVPclVwZGF0ZShvcHRzLCBjaGFydCkge1xuICAgIHJldHVybiBfQWdDaGFydHNJbnRlcm5hbC5jcmVhdGVPclVwZGF0ZShvcHRzLCBjaGFydCk7XG4gIH0sXG4gIHVwZGF0ZVVzZXJEZWx0YShjaGFydCwgZGVsdGFPcHRpb25zKSB7XG4gICAgcmV0dXJuIF9BZ0NoYXJ0c0ludGVybmFsLnVwZGF0ZVVzZXJEZWx0YShjaGFydCwgZGVsdGFPcHRpb25zKTtcbiAgfVxufTtcbnZhciBBZ0NoYXJ0c0ludGVybmFsID0gX0FnQ2hhcnRzSW50ZXJuYWw7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2ludGVncmF0ZWQtY2hhcnRzLXNjZW5lLnRzXG52YXIgaW50ZWdyYXRlZF9jaGFydHNfc2NlbmVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaW50ZWdyYXRlZF9jaGFydHNfc2NlbmVfZXhwb3J0cywge1xuICBBcmM6ICgpID0+IEFyYzIsXG4gIEJCb3g6ICgpID0+IEJCb3gsXG4gIEJhbmRTY2FsZTogKCkgPT4gQmFuZFNjYWxlLFxuICBDYXB0aW9uOiAoKSA9PiBDYXB0aW9uLFxuICBDaGFuZ2VEZXRlY3RhYmxlUHJvcGVydGllczogKCkgPT4gQ2hhbmdlRGV0ZWN0YWJsZVByb3BlcnRpZXMsXG4gIENpcmNsZTogKCkgPT4gQ2lyY2xlLFxuICBDb250aW51b3VzU2NhbGU6ICgpID0+IENvbnRpbnVvdXNTY2FsZSxcbiAgRGlhbW9uZDogKCkgPT4gRGlhbW9uZCxcbiAgRHJvcFNoYWRvdzogKCkgPT4gRHJvcFNoYWRvdyxcbiAgRXh0ZW5kZWRQYXRoMkQ6ICgpID0+IEV4dGVuZGVkUGF0aDJELFxuICBHcm91cDogKCkgPT4gR3JvdXAsXG4gIEhkcGlDYW52YXM6ICgpID0+IEhkcGlDYW52YXMsXG4gIEltYWdlOiAoKSA9PiBJbWFnZSxcbiAgTGFiZWw6ICgpID0+IExhYmVsLFxuICBMaW5lOiAoKSA9PiBMaW5lLFxuICBMaW5lYXJHcmFkaWVudEZpbGw6ICgpID0+IExpbmVhckdyYWRpZW50RmlsbCxcbiAgTGluZWFyU2NhbGU6ICgpID0+IExpbmVhclNjYWxlLFxuICBNYXJrZXI6ICgpID0+IE1hcmtlcixcbiAgTm9kZTogKCkgPT4gTm9kZSxcbiAgT3JkaW5hbFRpbWVTY2FsZTogKCkgPT4gT3JkaW5hbFRpbWVTY2FsZSxcbiAgUGF0aDogKCkgPT4gUGF0aCxcbiAgUG9pbnRlckV2ZW50czogKCkgPT4gUG9pbnRlckV2ZW50cyxcbiAgUmFkaWFsQ29sdW1uU2hhcGU6ICgpID0+IFJhZGlhbENvbHVtblNoYXBlLFxuICBSZWN0OiAoKSA9PiBSZWN0LFxuICBSZWRyYXdUeXBlOiAoKSA9PiBSZWRyYXdUeXBlLFxuICBTY2VuZTogKCkgPT4gU2NlbmUsXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uOiAoKSA9PiBTY2VuZUNoYW5nZURldGVjdGlvbixcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uOiAoKSA9PiBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24sXG4gIFNlY3RvcjogKCkgPT4gU2VjdG9yLFxuICBTZWN0b3JCb3g6ICgpID0+IFNlY3RvckJveCxcbiAgU2VsZWN0aW9uOiAoKSA9PiBTZWxlY3Rpb24sXG4gIFNoYXBlOiAoKSA9PiBTaGFwZSxcbiAgU3F1YXJlOiAoKSA9PiBTcXVhcmUsXG4gIFN2Z1BhdGg6ICgpID0+IFN2Z1BhdGgsXG4gIFRleHQ6ICgpID0+IFRleHQsXG4gIFRvb2x0aXA6ICgpID0+IFRvb2x0aXAsXG4gIFRyaWFuZ2xlOiAoKSA9PiBUcmlhbmdsZSxcbiAgZHJhd0Nvcm5lcjogKCkgPT4gZHJhd0Nvcm5lcixcbiAgZWFzaW5nOiAoKSA9PiBlYXNpbmdfZXhwb3J0cyxcbiAgZXZhbHVhdGVCZXppZXI6ICgpID0+IGV2YWx1YXRlQmV6aWVyLFxuICBnZXRGb250OiAoKSA9PiBnZXRGb250LFxuICBnZXRNYXJrZXI6ICgpID0+IGdldE1hcmtlcixcbiAgZ2V0UmFkaWFsQ29sdW1uV2lkdGg6ICgpID0+IGdldFJhZGlhbENvbHVtbldpZHRoLFxuICBtb3Rpb246ICgpID0+IG1vdGlvbixcbiAgc2VjdG9yQm94OiAoKSA9PiBzZWN0b3JCb3gsXG4gIHNvbHZlQmV6aWVyOiAoKSA9PiBzb2x2ZUJlemllcixcbiAgc3BsaXRCZXppZXI6ICgpID0+IHNwbGl0QmV6aWVyLFxuICB0b1JhZGlhbnM6ICgpID0+IHRvUmFkaWFucyxcbiAgdG9Ub29sdGlwSHRtbDogKCkgPT4gdG9Ub29sdGlwSHRtbFxufSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NoYXBlL2FyYy50c1xudmFyIEFyYzIgPSBjbGFzcyBleHRlbmRzIFBhdGgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY2VudGVyWCA9IDA7XG4gICAgdGhpcy5jZW50ZXJZID0gMDtcbiAgICB0aGlzLnJhZGl1cyA9IDEwO1xuICAgIHRoaXMuc3RhcnRBbmdsZSA9IDA7XG4gICAgdGhpcy5lbmRBbmdsZSA9IE1hdGguUEkgKiAyO1xuICAgIHRoaXMuY291bnRlckNsb2Nrd2lzZSA9IGZhbHNlO1xuICAgIHRoaXMudHlwZSA9IDAgLyogT3BlbiAqLztcbiAgICB0aGlzLnJlc3RvcmVPd25TdHlsZXMoKTtcbiAgfVxuICBnZXQgZnVsbFBpZSgpIHtcbiAgICByZXR1cm4gaXNFcXVhbChub3JtYWxpemVBbmdsZTM2MCh0aGlzLnN0YXJ0QW5nbGUpLCBub3JtYWxpemVBbmdsZTM2MCh0aGlzLmVuZEFuZ2xlKSk7XG4gIH1cbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCBwYXRoID0gdGhpcy5wYXRoO1xuICAgIHBhdGguY2xlYXIoKTtcbiAgICBwYXRoLmFyYyh0aGlzLmNlbnRlclgsIHRoaXMuY2VudGVyWSwgdGhpcy5yYWRpdXMsIHRoaXMuc3RhcnRBbmdsZSwgdGhpcy5lbmRBbmdsZSwgdGhpcy5jb3VudGVyQ2xvY2t3aXNlKTtcbiAgICBpZiAodGhpcy50eXBlID09PSAxIC8qIENob3JkICovKSB7XG4gICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgIH0gZWxzZSBpZiAodGhpcy50eXBlID09PSAyIC8qIFJvdW5kICovICYmICF0aGlzLmZ1bGxQaWUpIHtcbiAgICAgIHBhdGgubGluZVRvKHRoaXMuY2VudGVyWCwgdGhpcy5jZW50ZXJZKTtcbiAgICAgIHBhdGguY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9XG4gIGNvbXB1dGVCQm94KCkge1xuICAgIHJldHVybiBuZXcgQkJveCh0aGlzLmNlbnRlclggLSB0aGlzLnJhZGl1cywgdGhpcy5jZW50ZXJZIC0gdGhpcy5yYWRpdXMsIHRoaXMucmFkaXVzICogMiwgdGhpcy5yYWRpdXMgKiAyKTtcbiAgfVxuICBpc1BvaW50SW5QYXRoKHgsIHkpIHtcbiAgICBjb25zdCBwb2ludCA9IHRoaXMudHJhbnNmb3JtUG9pbnQoeCwgeSk7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuZ2V0QkJveCgpO1xuICAgIHJldHVybiB0aGlzLnR5cGUgIT09IDAgLyogT3BlbiAqLyAmJiBiYm94LmNvbnRhaW5zUG9pbnQocG9pbnQueCwgcG9pbnQueSkgJiYgdGhpcy5wYXRoLmlzUG9pbnRJblBhdGgocG9pbnQueCwgcG9pbnQueSk7XG4gIH1cbn07XG5BcmMyLmNsYXNzTmFtZSA9IFwiQXJjXCI7XG5BcmMyLmRlZmF1bHRTdHlsZXMgPSBPYmplY3QuYXNzaWduKHt9LCBTaGFwZS5kZWZhdWx0U3R5bGVzLCB7XG4gIGxpbmVXaWR0aDogMSxcbiAgZmlsbFN0eWxlOiBudWxsXG59KTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBBcmMyLnByb3RvdHlwZSwgXCJjZW50ZXJYXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIEFyYzIucHJvdG90eXBlLCBcImNlbnRlcllcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgQXJjMi5wcm90b3R5cGUsIFwicmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIEFyYzIucHJvdG90eXBlLCBcInN0YXJ0QW5nbGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgQXJjMi5wcm90b3R5cGUsIFwiZW5kQW5nbGVcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgQXJjMi5wcm90b3R5cGUsIFwiY291bnRlckNsb2Nrd2lzZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBBcmMyLnByb3RvdHlwZSwgXCJ0eXBlXCIsIDIpO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zY2VuZS9zaGFwZS9saW5lYXJHcmFkaWVudEZpbGwudHNcbnZhciBMaW5lYXJHcmFkaWVudEZpbGwgPSBjbGFzcyBleHRlbmRzIFNoYXBlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmRpcmVjdGlvbiA9IFwidG8tcmlnaHRcIjtcbiAgICB0aGlzLnN0b3BzID0gdm9pZCAwO1xuICAgIHRoaXMuX21hc2sgPSB2b2lkIDA7XG4gIH1cbiAgZ2V0IG1hc2soKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hc2s7XG4gIH1cbiAgc2V0IG1hc2sobmV3TWFzaykge1xuICAgIGlmICh0aGlzLl9tYXNrICE9IG51bGwpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2hpbGQodGhpcy5fbWFzayk7XG4gICAgfVxuICAgIGlmIChuZXdNYXNrICE9IG51bGwpIHtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQobmV3TWFzayk7XG4gICAgfVxuICAgIHRoaXMuX21hc2sgPSBuZXdNYXNrO1xuICB9XG4gIGlzUG9pbnRJblBhdGgoeCwgeSkge1xuICAgIHJldHVybiB0aGlzLm1hc2s/LmlzUG9pbnRJblBhdGgoeCwgeSkgPz8gZmFsc2U7XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgcmV0dXJuIHRoaXMubWFzaz8uZ2V0QkJveCgpO1xuICB9XG4gIHJlbmRlcihyZW5kZXJDdHgpIHtcbiAgICBjb25zdCB7IG1hc2ssIHN0b3BzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgY3R4LCBkZXZpY2VQaXhlbFJhdGlvIH0gPSByZW5kZXJDdHg7XG4gICAgY29uc3QgcGl4ZWxMZW5ndGggPSAxIC8gZGV2aWNlUGl4ZWxSYXRpbztcbiAgICBjb25zdCBtYXNrQmJveCA9IG1hc2s/LmNvbXB1dGVUcmFuc2Zvcm1lZEJCb3goKTtcbiAgICBpZiAobWFzayA9PSBudWxsIHx8IHN0b3BzID09IG51bGwgfHwgbWFza0Jib3ggPT0gbnVsbClcbiAgICAgIHJldHVybjtcbiAgICBpZiAobWFzay5kaXJ0eVBhdGgpIHtcbiAgICAgIG1hc2sudXBkYXRlUGF0aCgpO1xuICAgICAgbWFzay5kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguY2xpcChtYXNrLnBhdGguZ2V0UGF0aDJEKCkpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oZGV2aWNlUGl4ZWxSYXRpbywgMCwgMCwgZGV2aWNlUGl4ZWxSYXRpbywgMCwgMCk7XG4gICAgY29uc3QgeDAgPSBNYXRoLmZsb29yKG1hc2tCYm94LngpO1xuICAgIGNvbnN0IHgxID0gTWF0aC5jZWlsKG1hc2tCYm94LnggKyBtYXNrQmJveC53aWR0aCk7XG4gICAgY29uc3QgeTAgPSBNYXRoLmZsb29yKG1hc2tCYm94LnkpO1xuICAgIGNvbnN0IHkxID0gTWF0aC5jZWlsKG1hc2tCYm94LnkgKyBtYXNrQmJveC5oZWlnaHQpO1xuICAgIGNvbnN0IGhvcml6b250YWwgPSB0aGlzLmRpcmVjdGlvbiA9PT0gXCJ0by1yaWdodFwiIHx8IHRoaXMuZGlyZWN0aW9uID09PSBcInRvLWxlZnRcIjtcbiAgICBjb25zdCByZXZlcnNlZCA9IHRoaXMuZGlyZWN0aW9uID09PSBcInRvLXRvcFwiIHx8IHRoaXMuZGlyZWN0aW9uID09PSBcInRvLWxlZnRcIjtcbiAgICBjb25zdCBjb2xvclNjYWxlID0gbmV3IENvbG9yU2NhbGUoKTtcbiAgICBjb25zdCBbaTAsIGkxXSA9IGhvcml6b250YWwgPyBbeDAsIHgxXSA6IFt5MCwgeTFdO1xuICAgIGNvbG9yU2NhbGUuZG9tYWluID0gc3RvcHMubWFwKChfLCBpbmRleCkgPT4ge1xuICAgICAgcmV0dXJuIGkwICsgKGkxIC0gaTApICogaW5kZXggLyAoc3RvcHMubGVuZ3RoIC0gMSk7XG4gICAgfSk7XG4gICAgY29sb3JTY2FsZS5yYW5nZSA9IHJldmVyc2VkID8gc3RvcHMuc2xpY2UoKS5yZXZlcnNlKCkgOiBzdG9wcztcbiAgICBjb2xvclNjYWxlLnVwZGF0ZSgpO1xuICAgIGNvbnN0IGhlaWdodCA9IHkxIC0geTA7XG4gICAgY29uc3Qgd2lkdGggPSB4MSAtIHgwO1xuICAgIHN3aXRjaCAodGhpcy5kaXJlY3Rpb24pIHtcbiAgICAgIGNhc2UgXCJ0by1yaWdodFwiOlxuICAgICAgY2FzZSBcInRvLWxlZnRcIjpcbiAgICAgICAgZm9yIChsZXQgeCA9IHgwOyB4IDw9IHgxOyB4ICs9IHBpeGVsTGVuZ3RoKSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yU2NhbGUuY29udmVydCh4KTtcbiAgICAgICAgICBjdHguZmlsbFJlY3QoeCwgeTAsIHBpeGVsTGVuZ3RoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRvLWJvdHRvbVwiOlxuICAgICAgY2FzZSBcInRvLXRvcFwiOlxuICAgICAgICBmb3IgKGxldCB5ID0geTA7IHkgPD0geTE7IHkgKz0gcGl4ZWxMZW5ndGgpIHtcbiAgICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3JTY2FsZS5jb252ZXJ0KHkpO1xuICAgICAgICAgIGN0eC5maWxsUmVjdCh4MCwgeSwgd2lkdGgsIHBpeGVsTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBMaW5lYXJHcmFkaWVudEZpbGwucHJvdG90eXBlLCBcImRpcmVjdGlvblwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lQ2hhbmdlRGV0ZWN0aW9uKHsgcmVkcmF3OiAzIC8qIE1BSk9SICovIH0pXG5dLCBMaW5lYXJHcmFkaWVudEZpbGwucHJvdG90eXBlLCBcInN0b3BzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVDaGFuZ2VEZXRlY3Rpb24oeyByZWRyYXc6IDMgLyogTUFKT1IgKi8gfSlcbl0sIExpbmVhckdyYWRpZW50RmlsbC5wcm90b3R5cGUsIFwiX21hc2tcIiwgMik7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NoYXBlL3JhZGlhbENvbHVtblNoYXBlLnRzXG5mdW5jdGlvbiByb3RhdGVQb2ludCh4LCB5LCByb3RhdGlvbikge1xuICBjb25zdCByYWRpdXMgPSBNYXRoLnNxcnQoeCAqKiAyICsgeSAqKiAyKTtcbiAgY29uc3QgYW5nbGUyID0gTWF0aC5hdGFuMih5LCB4KTtcbiAgY29uc3Qgcm90YXRlZCA9IGFuZ2xlMiArIHJvdGF0aW9uO1xuICByZXR1cm4ge1xuICAgIHg6IE1hdGguY29zKHJvdGF0ZWQpICogcmFkaXVzLFxuICAgIHk6IE1hdGguc2luKHJvdGF0ZWQpICogcmFkaXVzXG4gIH07XG59XG52YXIgUmFkaWFsQ29sdW1uU2hhcGUgPSBjbGFzcyBleHRlbmRzIFBhdGgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuaXNCZXZlbGVkID0gdHJ1ZTtcbiAgICB0aGlzLmNvbHVtbldpZHRoID0gMDtcbiAgICB0aGlzLnN0YXJ0QW5nbGUgPSAwO1xuICAgIHRoaXMuZW5kQW5nbGUgPSAwO1xuICAgIHRoaXMub3V0ZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMuaW5uZXJSYWRpdXMgPSAwO1xuICAgIHRoaXMuYXhpc0lubmVyUmFkaXVzID0gMDtcbiAgICB0aGlzLmF4aXNPdXRlclJhZGl1cyA9IDA7XG4gICAgdGhpcy5pc1JhZGl1c0F4aXNSZXZlcnNlZCA9IGZhbHNlO1xuICB9XG4gIHNldCBjb3JuZXJSYWRpdXMoX3ZhbHVlKSB7XG4gIH1cbiAgY29tcHV0ZUJCb3goKSB7XG4gICAgY29uc3QgeyBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGNvbHVtbldpZHRoIH0gPSB0aGlzO1xuICAgIGNvbnN0IHJvdGF0aW9uID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuICAgIGNvbnN0IGxlZnQgPSAtY29sdW1uV2lkdGggLyAyO1xuICAgIGNvbnN0IHJpZ2h0ID0gY29sdW1uV2lkdGggLyAyO1xuICAgIGNvbnN0IHRvcCA9IC1vdXRlclJhZGl1cztcbiAgICBjb25zdCBib3R0b20gPSAtaW5uZXJSYWRpdXM7XG4gICAgbGV0IHgwID0gSW5maW5pdHk7XG4gICAgbGV0IHkwID0gSW5maW5pdHk7XG4gICAgbGV0IHgxID0gLUluZmluaXR5O1xuICAgIGxldCB5MSA9IC1JbmZpbml0eTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkgKz0gMSkge1xuICAgICAgY29uc3QgeyB4LCB5IH0gPSByb3RhdGVQb2ludChpICUgMiA9PT0gMCA/IGxlZnQgOiByaWdodCwgaSA8IDIgPyB0b3AgOiBib3R0b20sIHJvdGF0aW9uKTtcbiAgICAgIHgwID0gTWF0aC5taW4oeCwgeDApO1xuICAgICAgeTAgPSBNYXRoLm1pbih5LCB5MCk7XG4gICAgICB4MSA9IE1hdGgubWF4KHgsIHgxKTtcbiAgICAgIHkxID0gTWF0aC5tYXgoeSwgeTEpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJCb3goeDAsIHkwLCB4MSAtIHgwLCB5MSAtIHkwKTtcbiAgfVxuICBnZXRSb3RhdGlvbigpIHtcbiAgICBjb25zdCB7IHN0YXJ0QW5nbGUsIGVuZEFuZ2xlIH0gPSB0aGlzO1xuICAgIGNvbnN0IG1pZEFuZ2xlID0gYW5nbGVCZXR3ZWVuKHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICByZXR1cm4gbm9ybWFsaXplQW5nbGUzNjAoc3RhcnRBbmdsZSArIG1pZEFuZ2xlIC8gMiArIE1hdGguUEkgLyAyKTtcbiAgfVxuICB1cGRhdGVQYXRoKCkge1xuICAgIGNvbnN0IHsgaXNCZXZlbGVkIH0gPSB0aGlzO1xuICAgIGlmIChpc0JldmVsZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlQmV2ZWxlZFBhdGgoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cGRhdGVSZWN0YW5ndWxhclBhdGgoKTtcbiAgICB9XG4gICAgdGhpcy5jaGVja1BhdGhEaXJ0eSgpO1xuICB9XG4gIHVwZGF0ZVJlY3Rhbmd1bGFyUGF0aCgpIHtcbiAgICBjb25zdCB7IGNvbHVtbldpZHRoLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIHBhdGggfSA9IHRoaXM7XG4gICAgY29uc3QgbGVmdCA9IC1jb2x1bW5XaWR0aCAvIDI7XG4gICAgY29uc3QgcmlnaHQgPSBjb2x1bW5XaWR0aCAvIDI7XG4gICAgY29uc3QgdG9wID0gLW91dGVyUmFkaXVzO1xuICAgIGNvbnN0IGJvdHRvbSA9IC1pbm5lclJhZGl1cztcbiAgICBjb25zdCByb3RhdGlvbiA9IHRoaXMuZ2V0Um90YXRpb24oKTtcbiAgICBjb25zdCBwb2ludHMgPSBbXG4gICAgICBbbGVmdCwgYm90dG9tXSxcbiAgICAgIFtsZWZ0LCB0b3BdLFxuICAgICAgW3JpZ2h0LCB0b3BdLFxuICAgICAgW3JpZ2h0LCBib3R0b21dXG4gICAgXS5tYXAoKFt4LCB5XSkgPT4gcm90YXRlUG9pbnQoeCwgeSwgcm90YXRpb24pKTtcbiAgICBwYXRoLmNsZWFyKHRydWUpO1xuICAgIHBhdGgubW92ZVRvKHBvaW50c1swXS54LCBwb2ludHNbMF0ueSk7XG4gICAgcGF0aC5saW5lVG8ocG9pbnRzWzFdLngsIHBvaW50c1sxXS55KTtcbiAgICBwYXRoLmxpbmVUbyhwb2ludHNbMl0ueCwgcG9pbnRzWzJdLnkpO1xuICAgIHBhdGgubGluZVRvKHBvaW50c1szXS54LCBwb2ludHNbM10ueSk7XG4gICAgcGF0aC5jbG9zZVBhdGgoKTtcbiAgfVxuICB1cGRhdGVCZXZlbGVkUGF0aCgpIHtcbiAgICBjb25zdCB7IGNvbHVtbldpZHRoLCBwYXRoLCBvdXRlclJhZGl1cywgaW5uZXJSYWRpdXMsIGF4aXNJbm5lclJhZGl1cywgYXhpc091dGVyUmFkaXVzLCBpc1JhZGl1c0F4aXNSZXZlcnNlZCB9ID0gdGhpcztcbiAgICBjb25zdCBpc1N0YWNrQm90dG9tID0gaXNFcXVhbChpbm5lclJhZGl1cywgYXhpc0lubmVyUmFkaXVzKTtcbiAgICBjb25zdCBzaWRlUm90YXRpb24gPSBNYXRoLmFzaW4oY29sdW1uV2lkdGggLyAyIC8gaW5uZXJSYWRpdXMpO1xuICAgIGNvbnN0IHBvaW50Um90YXRpb24gPSB0aGlzLmdldFJvdGF0aW9uKCk7XG4gICAgY29uc3Qgcm90YXRlMiA9ICh4LCB5KSA9PiByb3RhdGVQb2ludCh4LCB5LCBwb2ludFJvdGF0aW9uKTtcbiAgICBjb25zdCBnZXRUcmlhbmdsZUh5cG90ZW51c2UgPSAobGVnLCBvdGhlckxlZykgPT4gTWF0aC5zcXJ0KGxlZyAqKiAyICsgb3RoZXJMZWcgKiogMik7XG4gICAgY29uc3QgZ2V0VHJpYW5nbGVMZWcgPSAoaHlwb3RlbnVzZSwgb3RoZXJMZWcpID0+IHtcbiAgICAgIGlmIChvdGhlckxlZyA+IGh5cG90ZW51c2UpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KGh5cG90ZW51c2UgKiogMiAtIG90aGVyTGVnICoqIDIpO1xuICAgIH07XG4gICAgY29uc3QgY29tcGFyZSA9ICh2YWx1ZSwgb3RoZXJWYWx1ZSwgbGVzc1RoYW4pID0+IGxlc3NUaGFuID8gdmFsdWUgPCBvdGhlclZhbHVlIDogdmFsdWUgPiBvdGhlclZhbHVlO1xuICAgIGNvbnN0IHNob3VsZENvbm5lY3RCb3R0b21DaXJjbGUgPSBpc1N0YWNrQm90dG9tICYmICFpc05hTihzaWRlUm90YXRpb24pICYmIHNpZGVSb3RhdGlvbiA8IE1hdGguUEkgLyA2O1xuICAgIGxldCBsZWZ0ID0gLWNvbHVtbldpZHRoIC8gMjtcbiAgICBsZXQgcmlnaHQgPSBjb2x1bW5XaWR0aCAvIDI7XG4gICAgY29uc3QgdG9wID0gLW91dGVyUmFkaXVzO1xuICAgIGNvbnN0IGJvdHRvbSA9IC1pbm5lclJhZGl1cyAqIChzaG91bGRDb25uZWN0Qm90dG9tQ2lyY2xlID8gTWF0aC5jb3Moc2lkZVJvdGF0aW9uKSA6IDEpO1xuICAgIGNvbnN0IGhhc0JvdHRvbUludGVyc2VjdGlvbiA9IGNvbXBhcmUoXG4gICAgICBheGlzT3V0ZXJSYWRpdXMsXG4gICAgICBnZXRUcmlhbmdsZUh5cG90ZW51c2UoaW5uZXJSYWRpdXMsIGNvbHVtbldpZHRoIC8gMiksXG4gICAgICAhaXNSYWRpdXNBeGlzUmV2ZXJzZWRcbiAgICApO1xuICAgIGlmIChoYXNCb3R0b21JbnRlcnNlY3Rpb24pIHtcbiAgICAgIGNvbnN0IGJvdHRvbUludGVyc2VjdGlvblggPSBnZXRUcmlhbmdsZUxlZyhheGlzT3V0ZXJSYWRpdXMsIGlubmVyUmFkaXVzKTtcbiAgICAgIGxlZnQgPSAtYm90dG9tSW50ZXJzZWN0aW9uWDtcbiAgICAgIHJpZ2h0ID0gYm90dG9tSW50ZXJzZWN0aW9uWDtcbiAgICB9XG4gICAgcGF0aC5jbGVhcih0cnVlKTtcbiAgICBjb25zdCBib3R0b21MZWZ0UHQgPSByb3RhdGUyKGxlZnQsIGJvdHRvbSk7XG4gICAgcGF0aC5tb3ZlVG8oYm90dG9tTGVmdFB0LngsIGJvdHRvbUxlZnRQdC55KTtcbiAgICBjb25zdCBpc0VtcHR5ID0gaXNFcXVhbChpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMpO1xuICAgIGNvbnN0IGhhc1NpZGVJbnRlcnNlY3Rpb24gPSBjb21wYXJlKFxuICAgICAgYXhpc091dGVyUmFkaXVzLFxuICAgICAgZ2V0VHJpYW5nbGVIeXBvdGVudXNlKG91dGVyUmFkaXVzLCBjb2x1bW5XaWR0aCAvIDIpLFxuICAgICAgIWlzUmFkaXVzQXhpc1JldmVyc2VkXG4gICAgKTtcbiAgICBpZiAoaXNFbXB0eSAmJiBzaG91bGRDb25uZWN0Qm90dG9tQ2lyY2xlKSB7XG4gICAgICBwYXRoLmFyYyhcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgaW5uZXJSYWRpdXMsXG4gICAgICAgIG5vcm1hbGl6ZUFuZ2xlMzYwKC1zaWRlUm90YXRpb24gLSBNYXRoLlBJIC8gMikgKyBwb2ludFJvdGF0aW9uLFxuICAgICAgICBub3JtYWxpemVBbmdsZTM2MChzaWRlUm90YXRpb24gLSBNYXRoLlBJIC8gMikgKyBwb2ludFJvdGF0aW9uLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGhhc1NpZGVJbnRlcnNlY3Rpb24pIHtcbiAgICAgIGNvbnN0IHNpZGVJbnRlcnNlY3Rpb25ZID0gLWdldFRyaWFuZ2xlTGVnKGF4aXNPdXRlclJhZGl1cywgY29sdW1uV2lkdGggLyAyKTtcbiAgICAgIGNvbnN0IHRvcEludGVyc2VjdGlvblggPSBnZXRUcmlhbmdsZUxlZyhheGlzT3V0ZXJSYWRpdXMsIG91dGVyUmFkaXVzKTtcbiAgICAgIGlmICghaGFzQm90dG9tSW50ZXJzZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHRvcExlZnRQdCA9IHJvdGF0ZTIobGVmdCwgc2lkZUludGVyc2VjdGlvblkpO1xuICAgICAgICBwYXRoLmxpbmVUbyh0b3BMZWZ0UHQueCwgdG9wTGVmdFB0LnkpO1xuICAgICAgfVxuICAgICAgcGF0aC5hcmMoXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGF4aXNPdXRlclJhZGl1cyxcbiAgICAgICAgTWF0aC5hdGFuMihzaWRlSW50ZXJzZWN0aW9uWSwgbGVmdCkgKyBwb2ludFJvdGF0aW9uLFxuICAgICAgICBNYXRoLmF0YW4yKHRvcCwgLXRvcEludGVyc2VjdGlvblgpICsgcG9pbnRSb3RhdGlvbixcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgICBpZiAoIWlzRXF1YWwodG9wSW50ZXJzZWN0aW9uWCwgMCkpIHtcbiAgICAgICAgY29uc3QgdG9wUmlnaHRCZXZlbFB0ID0gcm90YXRlMih0b3BJbnRlcnNlY3Rpb25YLCB0b3ApO1xuICAgICAgICBwYXRoLmxpbmVUbyh0b3BSaWdodEJldmVsUHQueCwgdG9wUmlnaHRCZXZlbFB0LnkpO1xuICAgICAgfVxuICAgICAgcGF0aC5hcmMoXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGF4aXNPdXRlclJhZGl1cyxcbiAgICAgICAgTWF0aC5hdGFuMih0b3AsIHRvcEludGVyc2VjdGlvblgpICsgcG9pbnRSb3RhdGlvbixcbiAgICAgICAgTWF0aC5hdGFuMihzaWRlSW50ZXJzZWN0aW9uWSwgcmlnaHQpICsgcG9pbnRSb3RhdGlvbixcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRvcExlZnRQdCA9IHJvdGF0ZTIobGVmdCwgdG9wKTtcbiAgICAgIGNvbnN0IHRvcFJpZ2h0UHQgPSByb3RhdGUyKHJpZ2h0LCB0b3ApO1xuICAgICAgcGF0aC5saW5lVG8odG9wTGVmdFB0LngsIHRvcExlZnRQdC55KTtcbiAgICAgIHBhdGgubGluZVRvKHRvcFJpZ2h0UHQueCwgdG9wUmlnaHRQdC55KTtcbiAgICB9XG4gICAgY29uc3QgYm90dG9tUmlnaHRQdCA9IHJvdGF0ZTIocmlnaHQsIGJvdHRvbSk7XG4gICAgcGF0aC5saW5lVG8oYm90dG9tUmlnaHRQdC54LCBib3R0b21SaWdodFB0LnkpO1xuICAgIGlmIChzaG91bGRDb25uZWN0Qm90dG9tQ2lyY2xlKSB7XG4gICAgICBwYXRoLmFyYyhcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgaW5uZXJSYWRpdXMsXG4gICAgICAgIG5vcm1hbGl6ZUFuZ2xlMzYwKHNpZGVSb3RhdGlvbiAtIE1hdGguUEkgLyAyKSArIHBvaW50Um90YXRpb24sXG4gICAgICAgIG5vcm1hbGl6ZUFuZ2xlMzYwKC1zaWRlUm90YXRpb24gLSBNYXRoLlBJIC8gMikgKyBwb2ludFJvdGF0aW9uLFxuICAgICAgICB0cnVlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCByb3RhdGVkQm90dG9tTGVmdFB0ID0gcm90YXRlMihsZWZ0LCBib3R0b20pO1xuICAgICAgcGF0aC5saW5lVG8ocm90YXRlZEJvdHRvbUxlZnRQdC54LCByb3RhdGVkQm90dG9tTGVmdFB0LnkpO1xuICAgIH1cbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG59O1xuUmFkaWFsQ29sdW1uU2hhcGUuY2xhc3NOYW1lID0gXCJSYWRpYWxDb2x1bW5TaGFwZVwiO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhZGlhbENvbHVtblNoYXBlLnByb3RvdHlwZSwgXCJpc0JldmVsZWRcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmFkaWFsQ29sdW1uU2hhcGUucHJvdG90eXBlLCBcImNvbHVtbldpZHRoXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhZGlhbENvbHVtblNoYXBlLnByb3RvdHlwZSwgXCJzdGFydEFuZ2xlXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhZGlhbENvbHVtblNoYXBlLnByb3RvdHlwZSwgXCJlbmRBbmdsZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSYWRpYWxDb2x1bW5TaGFwZS5wcm90b3R5cGUsIFwib3V0ZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmFkaWFsQ29sdW1uU2hhcGUucHJvdG90eXBlLCBcImlubmVyUmFkaXVzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFJhZGlhbENvbHVtblNoYXBlLnByb3RvdHlwZSwgXCJheGlzSW5uZXJSYWRpdXNcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgUmFkaWFsQ29sdW1uU2hhcGUucHJvdG90eXBlLCBcImF4aXNPdXRlclJhZGl1c1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFNjZW5lUGF0aENoYW5nZURldGVjdGlvbigpXG5dLCBSYWRpYWxDb2x1bW5TaGFwZS5wcm90b3R5cGUsIFwiaXNSYWRpdXNBeGlzUmV2ZXJzZWRcIiwgMik7XG5mdW5jdGlvbiBnZXRSYWRpYWxDb2x1bW5XaWR0aChzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYXhpc091dGVyUmFkaXVzLCBjb2x1bW5XaWR0aFJhdGlvLCBtYXhDb2x1bW5XaWR0aFJhdGlvKSB7XG4gIGNvbnN0IHJvdGF0aW9uID0gYW5nbGVCZXR3ZWVuKHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgY29uc3QgcGFkMiA9IHJvdGF0aW9uICogKDEgLSBjb2x1bW5XaWR0aFJhdGlvKSAvIDI7XG4gIHN0YXJ0QW5nbGUgKz0gcGFkMjtcbiAgZW5kQW5nbGUgLT0gcGFkMjtcbiAgaWYgKHJvdGF0aW9uIDwgMWUtMykge1xuICAgIHJldHVybiAyICogYXhpc091dGVyUmFkaXVzICogbWF4Q29sdW1uV2lkdGhSYXRpbztcbiAgfVxuICBpZiAocm90YXRpb24gPj0gMiAqIE1hdGguUEkpIHtcbiAgICBjb25zdCBtaWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyByb3RhdGlvbiAvIDI7XG4gICAgc3RhcnRBbmdsZSA9IG1pZEFuZ2xlIC0gTWF0aC5QSTtcbiAgICBlbmRBbmdsZSA9IG1pZEFuZ2xlICsgTWF0aC5QSTtcbiAgfVxuICBjb25zdCBzdGFydFggPSBheGlzT3V0ZXJSYWRpdXMgKiBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcbiAgY29uc3Qgc3RhcnRZID0gYXhpc091dGVyUmFkaXVzICogTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gIGNvbnN0IGVuZFggPSBheGlzT3V0ZXJSYWRpdXMgKiBNYXRoLmNvcyhlbmRBbmdsZSk7XG4gIGNvbnN0IGVuZFkgPSBheGlzT3V0ZXJSYWRpdXMgKiBNYXRoLnNpbihlbmRBbmdsZSk7XG4gIGNvbnN0IGNvbFdpZHRoID0gTWF0aC5mbG9vcihNYXRoLnNxcnQoKHN0YXJ0WCAtIGVuZFgpICoqIDIgKyAoc3RhcnRZIC0gZW5kWSkgKiogMikpO1xuICBjb25zdCBtYXhXaWR0aCA9IDIgKiBheGlzT3V0ZXJSYWRpdXMgKiBtYXhDb2x1bW5XaWR0aFJhdGlvO1xuICByZXR1cm4gTWF0aC5tYXgoMSwgTWF0aC5taW4obWF4V2lkdGgsIGNvbFdpZHRoKSk7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3NjZW5lL3NoYXBlL3N2Z1BhdGgudHNcbnZhciBTdmdQYXRoID0gY2xhc3MgZXh0ZW5kcyBQYXRoIHtcbiAgY29uc3RydWN0b3IoZCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtfLCBjb21tYW5kLCBwYXJhbXNTdHJpbmddIG9mIGQubWF0Y2hBbGwoLyhbQS1aXSkoWzAtOS4gXSspL2cpKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSBwYXJhbXNTdHJpbmcuc3BsaXQoXCIgXCIpLm1hcChOdW1iZXIpO1xuICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKFtjb21tYW5kLCBwYXJhbXNdKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGF0aCgpIHtcbiAgICBjb25zdCB7IHBhdGgsIHgsIHkgfSA9IHRoaXM7XG4gICAgcGF0aC5jbGVhcigpO1xuICAgIGxldCBsYXN0WCA9IHg7XG4gICAgbGV0IGxhc3RZID0geTtcbiAgICBmb3IgKGNvbnN0IFtjb21tYW5kLCBwYXJhbXNdIG9mIHRoaXMuY29tbWFuZHMpIHtcbiAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICBjYXNlIFwiTVwiOlxuICAgICAgICAgIHBhdGgubW92ZVRvKHggKyBwYXJhbXNbMF0sIHkgKyBwYXJhbXNbMV0pO1xuICAgICAgICAgIGxhc3RYID0geCArIHBhcmFtc1swXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkNcIjpcbiAgICAgICAgICBwYXRoLmN1YmljQ3VydmVUbyhcbiAgICAgICAgICAgIHggKyBwYXJhbXNbMF0sXG4gICAgICAgICAgICB5ICsgcGFyYW1zWzFdLFxuICAgICAgICAgICAgeCArIHBhcmFtc1syXSxcbiAgICAgICAgICAgIHkgKyBwYXJhbXNbM10sXG4gICAgICAgICAgICB4ICsgcGFyYW1zWzRdLFxuICAgICAgICAgICAgeSArIHBhcmFtc1s1XVxuICAgICAgICAgICk7XG4gICAgICAgICAgbGFzdFggPSB4ICsgcGFyYW1zWzRdO1xuICAgICAgICAgIGxhc3RZID0geSArIHBhcmFtc1s1XTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkhcIjpcbiAgICAgICAgICBwYXRoLmxpbmVUbyh4ICsgcGFyYW1zWzBdLCBsYXN0WSk7XG4gICAgICAgICAgbGFzdFggPSB5ICsgcGFyYW1zWzBdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTFwiOlxuICAgICAgICAgIHBhdGgubGluZVRvKHggKyBwYXJhbXNbMF0sIHkgKyBwYXJhbXNbMV0pO1xuICAgICAgICAgIGxhc3RYID0geCArIHBhcmFtc1swXTtcbiAgICAgICAgICBsYXN0WSA9IHkgKyBwYXJhbXNbMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgICAgcGF0aC5saW5lVG8obGFzdFgsIHkgKyBwYXJhbXNbMF0pO1xuICAgICAgICAgIGxhc3RZID0geSArIHBhcmFtc1swXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCB0cmFuc2xhdGUgY29tbWFuZCAnJHtjb21tYW5kfScgd2l0aCAnJHtwYXJhbXMuam9pbihcIiBcIil9J2ApO1xuICAgICAgfVxuICAgIH1cbiAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICB9XG59O1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgU2NlbmVQYXRoQ2hhbmdlRGV0ZWN0aW9uKClcbl0sIFN2Z1BhdGgucHJvdG90eXBlLCBcInhcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBTY2VuZVBhdGhDaGFuZ2VEZXRlY3Rpb24oKVxuXSwgU3ZnUGF0aC5wcm90b3R5cGUsIFwieVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvaW50ZWdyYXRlZC1jaGFydHMtc2NlbmUudHNcbnZhciBtb3Rpb24gPSB7IC4uLmZyb21Ub01vdGlvbl9leHBvcnRzLCAuLi5yZXNldE1vdGlvbl9leHBvcnRzIH07XG52YXIgZ2V0Rm9udCA9IFRleHRVdGlscy50b0ZvbnRTdHJpbmc7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL2ludGVncmF0ZWQtY2hhcnRzLXRoZW1lLnRzXG52YXIgaW50ZWdyYXRlZF9jaGFydHNfdGhlbWVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoaW50ZWdyYXRlZF9jaGFydHNfdGhlbWVfZXhwb3J0cywge1xuICBDQVJURVNJQU5fQVhJU19UWVBFOiAoKSA9PiBDQVJURVNJQU5fQVhJU19UWVBFLFxuICBDaGFydFRoZW1lOiAoKSA9PiBDaGFydFRoZW1lLFxuICBERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMOiAoKSA9PiBERUZBVUxUX0FOTk9UQVRJT05fQkFDS0dST1VORF9GSUxMLFxuICBERUZBVUxUX0FOTk9UQVRJT05fQ09MT1I6ICgpID0+IERFRkFVTFRfQU5OT1RBVElPTl9DT0xPUixcbiAgREVGQVVMVF9BTk5PVEFUSU9OX0hBTkRMRV9GSUxMOiAoKSA9PiBERUZBVUxUX0FOTk9UQVRJT05fSEFORExFX0ZJTEwsXG4gIERFRkFVTFRfQVhJU19HUklEX0NPTE9VUjogKCkgPT4gREVGQVVMVF9BWElTX0dSSURfQ09MT1VSLFxuICBERUZBVUxUX0FYSVNfTElORV9DT0xPVVI6ICgpID0+IERFRkFVTFRfQVhJU19MSU5FX0NPTE9VUixcbiAgREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9VUjogKCkgPT4gREVGQVVMVF9CQUNLR1JPVU5EX0NPTE9VUixcbiAgREVGQVVMVF9DQVBUSU9OX0FMSUdOTUVOVDogKCkgPT4gREVGQVVMVF9DQVBUSU9OX0FMSUdOTUVOVCxcbiAgREVGQVVMVF9DQVBUSU9OX0xBWU9VVF9TVFlMRTogKCkgPT4gREVGQVVMVF9DQVBUSU9OX0xBWU9VVF9TVFlMRSxcbiAgREVGQVVMVF9DT0xPVVJTOiAoKSA9PiBERUZBVUxUX0NPTE9VUlMsXG4gIERFRkFVTFRfQ1JPU1NfTElORVNfQ09MT1VSOiAoKSA9PiBERUZBVUxUX0NST1NTX0xJTkVTX0NPTE9VUixcbiAgREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9VUl9SQU5HRTogKCkgPT4gREVGQVVMVF9ESVZFUkdJTkdfU0VSSUVTX0NPTE9VUl9SQU5HRSxcbiAgREVGQVVMVF9GT05UX0ZBTUlMWTogKCkgPT4gREVGQVVMVF9GT05UX0ZBTUlMWSxcbiAgREVGQVVMVF9HUklETElORV9FTkFCTEVEOiAoKSA9PiBERUZBVUxUX0dSSURMSU5FX0VOQUJMRUQsXG4gIERFRkFVTFRfSElFUkFSQ0hZX0ZJTExTOiAoKSA9PiBERUZBVUxUX0hJRVJBUkNIWV9GSUxMUyxcbiAgREVGQVVMVF9ISUVSQVJDSFlfU1RST0tFUzogKCkgPT4gREVGQVVMVF9ISUVSQVJDSFlfU1RST0tFUyxcbiAgREVGQVVMVF9JTlNJREVfU0VSSUVTX0xBQkVMX0NPTE9VUjogKCkgPT4gREVGQVVMVF9JTlNJREVfU0VSSUVTX0xBQkVMX0NPTE9VUixcbiAgREVGQVVMVF9JTlZFUlRFRF9MQUJFTF9DT0xPVVI6ICgpID0+IERFRkFVTFRfSU5WRVJURURfTEFCRUxfQ09MT1VSLFxuICBERUZBVUxUX0xBQkVMX0NPTE9VUjogKCkgPT4gREVGQVVMVF9MQUJFTF9DT0xPVVIsXG4gIERFRkFVTFRfTVVURURfTEFCRUxfQ09MT1VSOiAoKSA9PiBERUZBVUxUX01VVEVEX0xBQkVMX0NPTE9VUixcbiAgREVGQVVMVF9QQURESU5HOiAoKSA9PiBERUZBVUxUX1BBRERJTkcsXG4gIERFRkFVTFRfUE9MQVJfU0VSSUVTX1NUUk9LRTogKCkgPT4gREVGQVVMVF9QT0xBUl9TRVJJRVNfU1RST0tFLFxuICBERUZBVUxUX1NIQURPV19DT0xPVVI6ICgpID0+IERFRkFVTFRfU0hBRE9XX0NPTE9VUixcbiAgREVGQVVMVF9URVhUQk9YX0NPTE9SOiAoKSA9PiBERUZBVUxUX1RFWFRCT1hfQ09MT1IsXG4gIERFRkFVTFRfVEVYVEJPWF9GSUxMOiAoKSA9PiBERUZBVUxUX1RFWFRCT1hfRklMTCxcbiAgREVGQVVMVF9URVhUQk9YX1NUUk9LRTogKCkgPT4gREVGQVVMVF9URVhUQk9YX1NUUk9LRSxcbiAgREVGQVVMVF9URVhUX0FOTk9UQVRJT05fQ09MT1I6ICgpID0+IERFRkFVTFRfVEVYVF9BTk5PVEFUSU9OX0NPTE9SLFxuICBERUZBVUxUX1RPT0xCQVJfUE9TSVRJT046ICgpID0+IERFRkFVTFRfVE9PTEJBUl9QT1NJVElPTixcbiAgRk9OVF9TSVpFOiAoKSA9PiBGT05UX1NJWkUsXG4gIEZPTlRfV0VJR0hUOiAoKSA9PiBGT05UX1dFSUdIVDIsXG4gIElTX0RBUktfVEhFTUU6ICgpID0+IElTX0RBUktfVEhFTUUsXG4gIFBBTEVUVEVfQUxUX0RPV05fRklMTDogKCkgPT4gUEFMRVRURV9BTFRfRE9XTl9GSUxMLFxuICBQQUxFVFRFX0FMVF9ET1dOX1NUUk9LRTogKCkgPT4gUEFMRVRURV9BTFRfRE9XTl9TVFJPS0UsXG4gIFBBTEVUVEVfQUxUX05FVVRSQUxfRklMTDogKCkgPT4gUEFMRVRURV9BTFRfTkVVVFJBTF9GSUxMLFxuICBQQUxFVFRFX0FMVF9ORVVUUkFMX1NUUk9LRTogKCkgPT4gUEFMRVRURV9BTFRfTkVVVFJBTF9TVFJPS0UsXG4gIFBBTEVUVEVfQUxUX1VQX0ZJTEw6ICgpID0+IFBBTEVUVEVfQUxUX1VQX0ZJTEwsXG4gIFBBTEVUVEVfQUxUX1VQX1NUUk9LRTogKCkgPT4gUEFMRVRURV9BTFRfVVBfU1RST0tFLFxuICBQQUxFVFRFX0RPV05fRklMTDogKCkgPT4gUEFMRVRURV9ET1dOX0ZJTEwsXG4gIFBBTEVUVEVfRE9XTl9TVFJPS0U6ICgpID0+IFBBTEVUVEVfRE9XTl9TVFJPS0UsXG4gIFBBTEVUVEVfTkVVVFJBTF9GSUxMOiAoKSA9PiBQQUxFVFRFX05FVVRSQUxfRklMTCxcbiAgUEFMRVRURV9ORVVUUkFMX1NUUk9LRTogKCkgPT4gUEFMRVRURV9ORVVUUkFMX1NUUk9LRSxcbiAgUEFMRVRURV9VUF9GSUxMOiAoKSA9PiBQQUxFVFRFX1VQX0ZJTEwsXG4gIFBBTEVUVEVfVVBfU1RST0tFOiAoKSA9PiBQQUxFVFRFX1VQX1NUUk9LRSxcbiAgUE9MQVJfQVhJU19TSEFQRTogKCkgPT4gUE9MQVJfQVhJU19TSEFQRSxcbiAgUE9MQVJfQVhJU19UWVBFOiAoKSA9PiBQT0xBUl9BWElTX1RZUEUsXG4gIFBPU0lUSU9OOiAoKSA9PiBQT1NJVElPTjIsXG4gIGdldENoYXJ0VGhlbWU6ICgpID0+IGdldENoYXJ0VGhlbWUsXG4gIG1hcmtlclBhbGV0dGVGYWN0b3J5OiAoKSA9PiBtYXJrZXJQYWxldHRlRmFjdG9yeSxcbiAgc2luZ2xlU2VyaWVzUGFsZXR0ZUZhY3Rvcnk6ICgpID0+IHNpbmdsZVNlcmllc1BhbGV0dGVGYWN0b3J5LFxuICB0aGVtZXM6ICgpID0+IHRoZW1lczJcbn0pO1xudmFyIHRoZW1lczIgPSBtYXBWYWx1ZXMoXG4gIHRoZW1lcyxcbiAgKHRoZW1lRmFjdG9yeSkgPT4gdGhlbWVGYWN0b3J5Py4oKVxuKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvc3BhcmtsaW5lcy1zY2FsZS50c1xudmFyIHNwYXJrbGluZXNfc2NhbGVfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3BhcmtsaW5lc19zY2FsZV9leHBvcnRzLCB7XG4gIEJhbmRTY2FsZTogKCkgPT4gQmFuZFNjYWxlLFxuICBDb2xvclNjYWxlOiAoKSA9PiBDb2xvclNjYWxlLFxuICBDb250aW51b3VzU2NhbGU6ICgpID0+IENvbnRpbnVvdXNTY2FsZSxcbiAgSW52YWxpZGF0aW5nOiAoKSA9PiBJbnZhbGlkYXRpbmcsXG4gIExpbmVhclNjYWxlOiAoKSA9PiBMaW5lYXJTY2FsZSxcbiAgT3JkaW5hbFRpbWVTY2FsZTogKCkgPT4gT3JkaW5hbFRpbWVTY2FsZSxcbiAgVGltZVNjYWxlOiAoKSA9PiBUaW1lU2NhbGVcbn0pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9zcGFya2xpbmVzLXV0aWwudHNcbnZhciBzcGFya2xpbmVzX3V0aWxfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoc3BhcmtsaW5lc191dGlsX2V4cG9ydHMsIHtcbiAgQ29sb3I6ICgpID0+IENvbG9yLFxuICBEZWJ1ZzogKCkgPT4gRGVidWcsXG4gIExvZ2dlcjogKCkgPT4gTG9nZ2VyLFxuICBQYWRkaW5nOiAoKSA9PiBQYWRkaW5nLFxuICBUaW1lSW50ZXJ2YWw6ICgpID0+IFRpbWVJbnRlcnZhbCxcbiAgVmVjMjogKCkgPT4gVmVjMixcbiAgYW5nbGVCZXR3ZWVuOiAoKSA9PiBhbmdsZUJldHdlZW4sXG4gIGFuZ2xlRGlmZjogKCkgPT4gYW5nbGVEaWZmLFxuICBhcmVBcnJheU51bWJlcnNFcXVhbDogKCkgPT4gYXJlQXJyYXlOdW1iZXJzRXF1YWwsXG4gIGJpZnVyY2F0ZTogKCkgPT4gYmlmdXJjYXRlLFxuICBjaGVja0RhdHVtOiAoKSA9PiBjaGVja0RhdHVtLFxuICBjbGFtcDogKCkgPT4gY2xhbXAsXG4gIGNsYW1wQXJyYXk6ICgpID0+IGNsYW1wQXJyYXksXG4gIGNvdW50RnJhY3Rpb25EaWdpdHM6ICgpID0+IGNvdW50RnJhY3Rpb25EaWdpdHMsXG4gIGNyZWF0ZUlkOiAoKSA9PiBjcmVhdGVJZCxcbiAgZGF5OiAoKSA9PiBkYXksXG4gIGRlZXBDbG9uZTogKCkgPT4gZGVlcENsb25lLFxuICBkaXNwbGFjZVBvaW50RnJvbVZlY3RvcjogKCkgPT4gZGlzcGxhY2VQb2ludEZyb21WZWN0b3IsXG4gIGV4dGVudDogKCkgPT4gZXh0ZW50LFxuICBmaW5kTWluTWF4OiAoKSA9PiBmaW5kTWluTWF4LFxuICBmaW5kUmFuZ2VFeHRlbnQ6ICgpID0+IGZpbmRSYW5nZUV4dGVudCxcbiAgZm9ybWF0Tm9ybWFsaXplZFBlcmNlbnRhZ2U6ICgpID0+IGZvcm1hdE5vcm1hbGl6ZWRQZXJjZW50YWdlLFxuICBmb3JtYXRQZXJjZW50YWdlOiAoKSA9PiBmb3JtYXRQZXJjZW50YWdlLFxuICBmcmlkYXk6ICgpID0+IGZyaWRheSxcbiAgaG91cjogKCkgPT4gaG91cixcbiAgaW50ZXJwb2xhdGVDb2xvcjogKCkgPT4gaW50ZXJwb2xhdGVDb2xvcixcbiAgaW50ZXJwb2xhdGVOdW1iZXI6ICgpID0+IGludGVycG9sYXRlTnVtYmVyLFxuICBpc0JldHdlZW5BbmdsZXM6ICgpID0+IGlzQmV0d2VlbkFuZ2xlcyxcbiAgaXNDb250aW51b3VzOiAoKSA9PiBpc0NvbnRpbnVvdXMsXG4gIGlzRGF0ZTogKCkgPT4gaXNWYWxpZERhdGUsXG4gIGlzRGVuc2VJbnRlcnZhbDogKCkgPT4gaXNEZW5zZUludGVydmFsLFxuICBpc0VxdWFsOiAoKSA9PiBpc0VxdWFsLFxuICBpc05lZ2F0aXZlOiAoKSA9PiBpc05lZ2F0aXZlLFxuICBpc051bWJlcjogKCkgPT4gaXNGaW5pdGVOdW1iZXIsXG4gIGlzTnVtYmVyRXF1YWw6ICgpID0+IGlzRXF1YWwsXG4gIGlzTnVtYmVyT2JqZWN0OiAoKSA9PiBpc051bWJlck9iamVjdCxcbiAgaXNTdHJpbmc6ICgpID0+IGlzU3RyaW5nLFxuICBpc1N0cmluZ09iamVjdDogKCkgPT4gaXNTdHJpbmdPYmplY3QsXG4gIGpzb25BcHBseTogKCkgPT4ganNvbkFwcGx5LFxuICBqc29uRGlmZjogKCkgPT4ganNvbkRpZmYsXG4gIGpzb25XYWxrOiAoKSA9PiBqc29uV2FsayxcbiAgbWlsbGlzZWNvbmQ6ICgpID0+IG1pbGxpc2Vjb25kLFxuICBtaW51dGU6ICgpID0+IG1pbnV0ZSxcbiAgbW9kOiAoKSA9PiBtb2QsXG4gIG1vbmRheTogKCkgPT4gbW9uZGF5LFxuICBtb250aDogKCkgPT4gbW9udGgsXG4gIG5vcm1hbGlzZWRFeHRlbnQ6ICgpID0+IG5vcm1hbGlzZWRFeHRlbnQsXG4gIG5vcm1hbGlzZWRFeHRlbnRXaXRoTWV0YWRhdGE6ICgpID0+IG5vcm1hbGlzZWRFeHRlbnRXaXRoTWV0YWRhdGEsXG4gIG5vcm1hbGl6ZUFuZ2xlMTgwOiAoKSA9PiBub3JtYWxpemVBbmdsZTE4MCxcbiAgbm9ybWFsaXplQW5nbGUzNjA6ICgpID0+IG5vcm1hbGl6ZUFuZ2xlMzYwLFxuICBub3JtYWxpemVBbmdsZTM2MEluY2x1c2l2ZTogKCkgPT4gbm9ybWFsaXplQW5nbGUzNjBJbmNsdXNpdmUsXG4gIHJhbmdlOiAoKSA9PiByYW5nZSxcbiAgcmVzZXRJZHM6ICgpID0+IHJlc2V0SWRzLFxuICByb3VuZDogKCkgPT4gcm91bmQsXG4gIHNhbml0aXplSHRtbDogKCkgPT4gc2FuaXRpemVIdG1sLFxuICBzYXR1cmRheTogKCkgPT4gc2F0dXJkYXksXG4gIHNlY29uZDogKCkgPT4gc2Vjb25kLFxuICBzZXRBdHRyaWJ1dGU6ICgpID0+IHNldEF0dHJpYnV0ZSxcbiAgc2V0VmlzaWJpbGl0eTogKCkgPT4gc2V0VmlzaWJpbGl0eSxcbiAgc2hhbGxvd0Nsb25lOiAoKSA9PiBzaGFsbG93Q2xvbmUsXG4gIHN1bmRheTogKCkgPT4gc3VuZGF5LFxuICB0aHVyc2RheTogKCkgPT4gdGh1cnNkYXksXG4gIHRpY2tGb3JtYXQ6ICgpID0+IHRpY2tGb3JtYXQsXG4gIHRpY2tTdGVwOiAoKSA9PiB0aWNrU3RlcCxcbiAgdGlja3M6ICgpID0+IGNyZWF0ZVRpY2tzLFxuICB0b0RlZ3JlZXM6ICgpID0+IHRvRGVncmVlcyxcbiAgdG9GaXhlZDogKCkgPT4gdG9GaXhlZCxcbiAgdG9SYWRpYW5zOiAoKSA9PiB0b1JhZGlhbnMsXG4gIHRyYW5zZm9ybUludGVncmF0ZWRDYXRlZ29yeVZhbHVlOiAoKSA9PiB0cmFuc2Zvcm1JbnRlZ3JhdGVkQ2F0ZWdvcnlWYWx1ZSxcbiAgdHVlc2RheTogKCkgPT4gdHVlc2RheSxcbiAgdXRjRGF5OiAoKSA9PiB1dGNEYXksXG4gIHV0Y0hvdXI6ICgpID0+IHV0Y0hvdXIsXG4gIHV0Y01pbnV0ZTogKCkgPT4gdXRjTWludXRlLFxuICB1dGNNb250aDogKCkgPT4gdXRjTW9udGgsXG4gIHV0Y1llYXI6ICgpID0+IHV0Y1llYXIsXG4gIHV1aWQ6ICgpID0+IHV1aWQsXG4gIHdlZG5lc2RheTogKCkgPT4gd2VkbmVzZGF5LFxuICB5ZWFyOiAoKSA9PiB5ZWFyLFxuICB6aXBPYmplY3Q6ICgpID0+IHppcE9iamVjdFxufSk7XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdmVjdG9yLnRzXG52YXIgVmVjMiA9IHtcbiAgYWRkLFxuICBhbmdsZSxcbiAgYXBwbHksXG4gIGVxdWFsLFxuICBkaXN0YW5jZTogZGlzdGFuY2UyLFxuICBkaXN0YW5jZVNxdWFyZWQ6IGRpc3RhbmNlU3F1YXJlZDIsXG4gIGZyb20sXG4gIGZyb21PZmZzZXQsXG4gIGxlbmd0aCxcbiAgbGVuZ3RoU3F1YXJlZCxcbiAgcmVxdWlyZWQsXG4gIHJvdGF0ZSxcbiAgc3ViXG59O1xuZnVuY3Rpb24gYWRkKGEsIGIpIHtcbiAgcmV0dXJuIHsgeDogYS54ICsgYi54LCB5OiBhLnkgKyBiLnkgfTtcbn1cbmZ1bmN0aW9uIHN1YihhLCBiKSB7XG4gIHJldHVybiB7IHg6IGEueCAtIGIueCwgeTogYS55IC0gYi55IH07XG59XG5mdW5jdGlvbiBsZW5ndGgoYSkge1xuICByZXR1cm4gTWF0aC5zcXJ0KGEueCAqIGEueCArIGEueSAqIGEueSk7XG59XG5mdW5jdGlvbiBsZW5ndGhTcXVhcmVkKGEpIHtcbiAgcmV0dXJuIGEueCAqIGEueCArIGEueSAqIGEueTtcbn1cbmZ1bmN0aW9uIGRpc3RhbmNlMihhLCBiKSB7XG4gIGNvbnN0IGQgPSBzdWIoYSwgYik7XG4gIHJldHVybiBNYXRoLnNxcnQoZC54ICogZC54ICsgZC55ICogZC55KTtcbn1cbmZ1bmN0aW9uIGRpc3RhbmNlU3F1YXJlZDIoYSwgYikge1xuICBjb25zdCBkID0gc3ViKGEsIGIpO1xuICByZXR1cm4gZC54ICogZC54ICsgZC55ICogZC55O1xufVxuZnVuY3Rpb24gYW5nbGUoYSwgYikge1xuICByZXR1cm4gTWF0aC5hdGFuMihhLnksIGEueCkgLSBNYXRoLmF0YW4yKGIueSwgYi54KTtcbn1cbmZ1bmN0aW9uIHJvdGF0ZShhLCB0aGV0YSwgYiA9IHJlcXVpcmVkKCkpIHtcbiAgY29uc3QgbCA9IFZlYzIubGVuZ3RoKGEpO1xuICByZXR1cm4geyB4OiBiLnggKyBsICogTWF0aC5jb3ModGhldGEpLCB5OiBiLnkgKyBsICogTWF0aC5zaW4odGhldGEpIH07XG59XG5mdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLnggPT09IGIueCAmJiBhLnkgPT09IGIueTtcbn1cbmZ1bmN0aW9uIGZyb20oeCwgeSkge1xuICByZXR1cm4geyB4LCB5IH07XG59XG5mdW5jdGlvbiBmcm9tT2Zmc2V0KGEpIHtcbiAgcmV0dXJuIHsgeDogYS5vZmZzZXRYLCB5OiBhLm9mZnNldFkgfTtcbn1cbmZ1bmN0aW9uIGFwcGx5KGEsIGIpIHtcbiAgYS54ID0gYi54O1xuICBhLnkgPSBiLnk7XG4gIHJldHVybiBhO1xufVxuZnVuY3Rpb24gcmVxdWlyZWQoYSkge1xuICByZXR1cm4geyB4OiBhPy54ID8/IDAsIHk6IGE/LnkgPz8gMCB9O1xufVxuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL3ppcC50c1xuZnVuY3Rpb24gemlwT2JqZWN0KGtleXMsIHZhbHVlcykge1xuICBjb25zdCB6aXBwZWQgPSB7fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgemlwcGVkW2Ake2tleXNbaV19YF0gPSB2YWx1ZXNbaV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgemlwcGVkW2Ake2tleXNbaV19YF0gPSB2YWx1ZXM7XG4gICAgfVxuICB9XG4gIHJldHVybiB6aXBwZWQ7XG59XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL21vZHVsZS1zdXBwb3J0LnRzXG52YXIgbW9kdWxlX3N1cHBvcnRfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobW9kdWxlX3N1cHBvcnRfZXhwb3J0cywge1xuICBBTkQ6ICgpID0+IEFORCxcbiAgQVJSQVk6ICgpID0+IEFSUkFZLFxuICBBUlJBWV9PRjogKCkgPT4gQVJSQVlfT0YsXG4gIEFic3RyYWN0QmFyU2VyaWVzOiAoKSA9PiBBYnN0cmFjdEJhclNlcmllcyxcbiAgQWJzdHJhY3RCYXJTZXJpZXNQcm9wZXJ0aWVzOiAoKSA9PiBBYnN0cmFjdEJhclNlcmllc1Byb3BlcnRpZXMsXG4gIEFjdGlvbk9uU2V0OiAoKSA9PiBBY3Rpb25PblNldCxcbiAgQW5pbWF0aW9uOiAoKSA9PiBBbmltYXRpb24sXG4gIEFuaW1hdGlvbk1hbmFnZXI6ICgpID0+IEFuaW1hdGlvbk1hbmFnZXIsXG4gIEFyZWFTZXJpZXNUYWc6ICgpID0+IEFyZWFTZXJpZXNUYWcsXG4gIEF4aXM6ICgpID0+IEF4aXMsXG4gIEF4aXNJbnRlcnZhbDogKCkgPT4gQXhpc0ludGVydmFsLFxuICBBeGlzTGFiZWw6ICgpID0+IEF4aXNMYWJlbCxcbiAgQXhpc1RpY2s6ICgpID0+IEF4aXNUaWNrLFxuICBBeGlzVGlja3M6ICgpID0+IEF4aXNUaWNrcyxcbiAgQk9PTEVBTjogKCkgPT4gQk9PTEVBTixcbiAgQk9PTEVBTl9BUlJBWTogKCkgPT4gQk9PTEVBTl9BUlJBWSxcbiAgQmFja2dyb3VuZDogKCkgPT4gQmFja2dyb3VuZCxcbiAgQmFja2dyb3VuZE1vZHVsZTogKCkgPT4gQmFja2dyb3VuZE1vZHVsZSxcbiAgQmFzZU1vZHVsZUluc3RhbmNlOiAoKSA9PiBCYXNlTW9kdWxlSW5zdGFuY2UsXG4gIEJhc2VQcm9wZXJ0aWVzOiAoKSA9PiBCYXNlUHJvcGVydGllcyxcbiAgQ09MT1JfU1RSSU5HOiAoKSA9PiBDT0xPUl9TVFJJTkcsXG4gIENPTE9SX1NUUklOR19BUlJBWTogKCkgPT4gQ09MT1JfU1RSSU5HX0FSUkFZLFxuICBDYWNoZWRUZXh0TWVhc3VyZXI6ICgpID0+IENhY2hlZFRleHRNZWFzdXJlcixcbiAgQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbDogKCkgPT4gQ2FjaGVkVGV4dE1lYXN1cmVyUG9vbCxcbiAgQ2FydGVzaWFuQXhpczogKCkgPT4gQ2FydGVzaWFuQXhpcyxcbiAgQ2FydGVzaWFuU2VyaWVzOiAoKSA9PiBDYXJ0ZXNpYW5TZXJpZXMsXG4gIENhcnRlc2lhblNlcmllc05vZGVFdmVudDogKCkgPT4gQ2FydGVzaWFuU2VyaWVzTm9kZUV2ZW50LFxuICBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzOiAoKSA9PiBDYXJ0ZXNpYW5TZXJpZXNQcm9wZXJ0aWVzLFxuICBDYXRlZ29yeUF4aXM6ICgpID0+IENhdGVnb3J5QXhpcyxcbiAgQ2hhcnRBeGlzRGlyZWN0aW9uOiAoKSA9PiBDaGFydEF4aXNEaXJlY3Rpb24sXG4gIENoYXJ0RXZlbnRNYW5hZ2VyOiAoKSA9PiBDaGFydEV2ZW50TWFuYWdlcixcbiAgQ2hhcnRPcHRpb25zOiAoKSA9PiBDaGFydE9wdGlvbnMsXG4gIENoYXJ0VXBkYXRlVHlwZTogKCkgPT4gQ2hhcnRVcGRhdGVUeXBlLFxuICBDb250ZXh0TWVudVJlZ2lzdHJ5OiAoKSA9PiBDb250ZXh0TWVudVJlZ2lzdHJ5LFxuICBDdXJzb3I6ICgpID0+IEN1cnNvcixcbiAgQ3Vyc29yTWFuYWdlcjogKCkgPT4gQ3Vyc29yTWFuYWdlcixcbiAgREFURTogKCkgPT4gREFURSxcbiAgREFURV9BUlJBWTogKCkgPT4gREFURV9BUlJBWSxcbiAgREFURV9PUl9EQVRFVElNRV9NUzogKCkgPT4gREFURV9PUl9EQVRFVElNRV9NUyxcbiAgREVGQVVMVF9DQVJURVNJQU5fRElSRUNUSU9OX0tFWVM6ICgpID0+IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9LRVlTLFxuICBERUZBVUxUX0NBUlRFU0lBTl9ESVJFQ1RJT05fTkFNRVM6ICgpID0+IERFRkFVTFRfQ0FSVEVTSUFOX0RJUkVDVElPTl9OQU1FUyxcbiAgREVGQVVMVF9UT09MVElQX0NMQVNTOiAoKSA9PiBERUZBVUxUX1RPT0xUSVBfQ0xBU1MsXG4gIERFRkFVTFRfVE9PTFRJUF9EQVJLX0NMQVNTOiAoKSA9PiBERUZBVUxUX1RPT0xUSVBfREFSS19DTEFTUyxcbiAgREVHUkVFOiAoKSA9PiBERUdSRUUsXG4gIERJUkVDVElPTjogKCkgPT4gRElSRUNUSU9OLFxuICBET01NYW5hZ2VyOiAoKSA9PiBET01NYW5hZ2VyLFxuICBEYXRhQ29udHJvbGxlcjogKCkgPT4gRGF0YUNvbnRyb2xsZXIsXG4gIERhdGFNb2RlbDogKCkgPT4gRGF0YU1vZGVsLFxuICBEYXRhTW9kZWxTZXJpZXM6ICgpID0+IERhdGFNb2RlbFNlcmllcyxcbiAgRGF0YVNlcnZpY2U6ICgpID0+IERhdGFTZXJ2aWNlLFxuICBEZWZhdWx0OiAoKSA9PiBEZWZhdWx0LFxuICBEZXByZWNhdGVkOiAoKSA9PiBEZXByZWNhdGVkLFxuICBEZXByZWNhdGVkQW5kUmVuYW1lZFRvOiAoKSA9PiBEZXByZWNhdGVkQW5kUmVuYW1lZFRvLFxuICBFTVBUWV9UT09MVElQX0NPTlRFTlQ6ICgpID0+IEVNUFRZX1RPT0xUSVBfQ09OVEVOVCxcbiAgRk9OVF9TVFlMRTogKCkgPT4gRk9OVF9TVFlMRSxcbiAgRk9OVF9XRUlHSFQ6ICgpID0+IEZPTlRfV0VJR0hULFxuICBGVU5DVElPTjogKCkgPT4gRlVOQ1RJT04sXG4gIEdSRUFURVJfVEhBTjogKCkgPT4gR1JFQVRFUl9USEFOLFxuICBHZXN0dXJlRGV0ZWN0b3I6ICgpID0+IEdlc3R1cmVEZXRlY3RvcixcbiAgR3JvdXBlZENhdGVnb3J5QXhpczogKCkgPT4gR3JvdXBlZENhdGVnb3J5QXhpcyxcbiAgSGllcmFyY2h5Tm9kZTogKCkgPT4gSGllcmFyY2h5Tm9kZSxcbiAgSGllcmFyY2h5U2VyaWVzOiAoKSA9PiBIaWVyYXJjaHlTZXJpZXMsXG4gIEhpZXJhcmNoeVNlcmllc1Byb3BlcnRpZXM6ICgpID0+IEhpZXJhcmNoeVNlcmllc1Byb3BlcnRpZXMsXG4gIEhpZ2hsaWdodE1hbmFnZXI6ICgpID0+IEhpZ2hsaWdodE1hbmFnZXIsXG4gIEhpZ2hsaWdodFByb3BlcnRpZXM6ICgpID0+IEhpZ2hsaWdodFByb3BlcnRpZXMsXG4gIEhpZ2hsaWdodFN0eWxlOiAoKSA9PiBIaWdobGlnaHRTdHlsZSxcbiAgSU5URVJBQ1RJT05fUkFOR0U6ICgpID0+IElOVEVSQUNUSU9OX1JBTkdFLFxuICBJTlRFUlBPTEFUSU9OX1NURVBfUE9TSVRJT046ICgpID0+IElOVEVSUE9MQVRJT05fU1RFUF9QT1NJVElPTixcbiAgSU5URVJQT0xBVElPTl9UWVBFOiAoKSA9PiBJTlRFUlBPTEFUSU9OX1RZUEUsXG4gIEludGVyYWN0aW9uTWFuYWdlcjogKCkgPT4gSW50ZXJhY3Rpb25NYW5hZ2VyLFxuICBJbnRlcmFjdGlvblN0YXRlOiAoKSA9PiBJbnRlcmFjdGlvblN0YXRlLFxuICBJbnRlcnBvbGF0aW9uUHJvcGVydGllczogKCkgPT4gSW50ZXJwb2xhdGlvblByb3BlcnRpZXMsXG4gIEtleU5hdk1hbmFnZXI6ICgpID0+IEtleU5hdk1hbmFnZXIsXG4gIExBQkVMX1BMQUNFTUVOVDogKCkgPT4gTEFCRUxfUExBQ0VNRU5ULFxuICBMQVJHRVNUX0tFWV9JTlRFUlZBTDogKCkgPT4gTEFSR0VTVF9LRVlfSU5URVJWQUwsXG4gIExFU1NfVEhBTjogKCkgPT4gTEVTU19USEFOLFxuICBMSU5FX0NBUDogKCkgPT4gTElORV9DQVAsXG4gIExJTkVfREFTSDogKCkgPT4gTElORV9EQVNILFxuICBMSU5FX0pPSU46ICgpID0+IExJTkVfSk9JTixcbiAgTGF5ZXJzOiAoKSA9PiBMYXllcnMsXG4gIExheW91dFNlcnZpY2U6ICgpID0+IExheW91dFNlcnZpY2UsXG4gIExvbkxhdEJCb3g6ICgpID0+IExvbkxhdEJCb3gsXG4gIE1BUktFUl9TSEFQRTogKCkgPT4gTUFSS0VSX1NIQVBFLFxuICBNQVRDSElOR19DUk9TU0xJTkVfVFlQRTogKCkgPT4gTUFUQ0hJTkdfQ1JPU1NMSU5FX1RZUEUsXG4gIE1BWF9TUEFDSU5HOiAoKSA9PiBNQVhfU1BBQ0lORyxcbiAgTUlOX1NQQUNJTkc6ICgpID0+IE1JTl9TUEFDSU5HLFxuICBNZXJjYXRvclNjYWxlOiAoKSA9PiBNZXJjYXRvclNjYWxlLFxuICBNb2R1bGVSZWdpc3RyeTogKCkgPT4gTW9kdWxlUmVnaXN0cnksXG4gIE1vdGlvbjogKCkgPT4gZWFzaW5nX2V4cG9ydHMsXG4gIE5BTjogKCkgPT4gTkFOLFxuICBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HOiAoKSA9PiBOT0RFX1VQREFURV9TVEFURV9UT19QSEFTRV9NQVBQSU5HLFxuICBOVU1CRVI6ICgpID0+IE5VTUJFUixcbiAgTlVNQkVSX0FSUkFZOiAoKSA9PiBOVU1CRVJfQVJSQVksXG4gIE5VTUJFUl9PUl9OQU46ICgpID0+IE5VTUJFUl9PUl9OQU4sXG4gIE5hdmlnYXRvcjogKCkgPT4gTmF2aWdhdG9yLFxuICBOYXZpZ2F0b3JNb2R1bGU6ICgpID0+IE5hdmlnYXRvck1vZHVsZSxcbiAgT0JKRUNUOiAoKSA9PiBPQkpFQ1QsXG4gIE9CSkVDVF9BUlJBWTogKCkgPT4gT0JKRUNUX0FSUkFZLFxuICBPUjogKCkgPT4gT1IsXG4gIE9WRVJGTE9XX1NUUkFURUdZOiAoKSA9PiBPVkVSRkxPV19TVFJBVEVHWSxcbiAgT2JzZXJ2ZUNoYW5nZXM6ICgpID0+IE9ic2VydmVDaGFuZ2VzLFxuICBQSEFTRV9NRVRBREFUQTogKCkgPT4gUEhBU0VfTUVUQURBVEEsXG4gIFBIQVNFX09SREVSOiAoKSA9PiBQSEFTRV9PUkRFUixcbiAgUExBQ0VNRU5UOiAoKSA9PiBQTEFDRU1FTlQsXG4gIFBMQUlOX09CSkVDVDogKCkgPT4gUExBSU5fT0JKRUNULFxuICBQT0lOVEVSX0lOVEVSQUNUSU9OX1RZUEVTOiAoKSA9PiBQT0lOVEVSX0lOVEVSQUNUSU9OX1RZUEVTLFxuICBQT1NJVElPTjogKCkgPT4gUE9TSVRJT04sXG4gIFBPU0lUSU9OX1RPUF9DT09SRElOQVRFUzogKCkgPT4gUE9TSVRJT05fVE9QX0NPT1JESU5BVEVTLFxuICBQT1NJVElWRV9OVU1CRVI6ICgpID0+IFBPU0lUSVZFX05VTUJFUixcbiAgUG9sYXJBeGlzOiAoKSA9PiBQb2xhckF4aXMsXG4gIFBvbGFyU2VyaWVzOiAoKSA9PiBQb2xhclNlcmllcyxcbiAgUHJvcGVydGllc0FycmF5OiAoKSA9PiBQcm9wZXJ0aWVzQXJyYXksXG4gIFByb3h5T25Xcml0ZTogKCkgPT4gUHJveHlPbldyaXRlLFxuICBQcm94eVByb3BlcnR5OiAoKSA9PiBQcm94eVByb3BlcnR5LFxuICBQcm94eVByb3BlcnR5T25Xcml0ZTogKCkgPT4gUHJveHlQcm9wZXJ0eU9uV3JpdGUsXG4gIFFVSUNLX1RSQU5TSVRJT046ICgpID0+IFFVSUNLX1RSQU5TSVRJT04sXG4gIFJBVElPOiAoKSA9PiBSQVRJTyxcbiAgUkVHSU9OUzogKCkgPT4gUkVHSU9OUyxcbiAgUmVnaW9uTWFuYWdlcjogKCkgPT4gUmVnaW9uTWFuYWdlcixcbiAgUmVwZWF0VHlwZTogKCkgPT4gUmVwZWF0VHlwZSxcbiAgU0tJUF9KU19CVUlMVElOUzogKCkgPT4gU0tJUF9KU19CVUlMVElOUyxcbiAgU01BTExFU1RfS0VZX0lOVEVSVkFMOiAoKSA9PiBTTUFMTEVTVF9LRVlfSU5URVJWQUwsXG4gIFNPUlRfRE9NQUlOX0dST1VQUzogKCkgPT4gU09SVF9ET01BSU5fR1JPVVBTLFxuICBTVFJJTkc6ICgpID0+IFNUUklORyxcbiAgU1RSSU5HX0FSUkFZOiAoKSA9PiBTVFJJTkdfQVJSQVksXG4gIFNlcmllczogKCkgPT4gU2VyaWVzLFxuICBTZXJpZXNHcm91cGluZ0NoYW5nZWRFdmVudDogKCkgPT4gU2VyaWVzR3JvdXBpbmdDaGFuZ2VkRXZlbnQsXG4gIFNlcmllc0l0ZW1IaWdobGlnaHRTdHlsZTogKCkgPT4gU2VyaWVzSXRlbUhpZ2hsaWdodFN0eWxlLFxuICBTZXJpZXNNYXJrZXI6ICgpID0+IFNlcmllc01hcmtlcixcbiAgU2VyaWVzTm9kZUV2ZW50OiAoKSA9PiBTZXJpZXNOb2RlRXZlbnQsXG4gIFNlcmllc05vZGVQaWNrTW9kZTogKCkgPT4gU2VyaWVzTm9kZVBpY2tNb2RlLFxuICBTZXJpZXNQcm9wZXJ0aWVzOiAoKSA9PiBTZXJpZXNQcm9wZXJ0aWVzLFxuICBTZXJpZXNUb29sdGlwOiAoKSA9PiBTZXJpZXNUb29sdGlwLFxuICBTaW1wbGVUZXh0TWVhc3VyZXI6ICgpID0+IFNpbXBsZVRleHRNZWFzdXJlcixcbiAgU3RhdGVNYWNoaW5lOiAoKSA9PiBTdGF0ZU1hY2hpbmUsXG4gIFRFWFRfQUxJR046ICgpID0+IFRFWFRfQUxJR04sXG4gIFRFWFRfV1JBUDogKCkgPT4gVEVYVF9XUkFQLFxuICBUSUNLX0lOVEVSVkFMOiAoKSA9PiBUSUNLX0lOVEVSVkFMLFxuICBUZXh0VXRpbHM6ICgpID0+IFRleHRVdGlscyxcbiAgVGV4dFdyYXBwZXI6ICgpID0+IFRleHRXcmFwcGVyLFxuICBUb29sYmFyTWFuYWdlcjogKCkgPT4gVG9vbGJhck1hbmFnZXIsXG4gIFRvb2x0aXA6ICgpID0+IFRvb2x0aXAsXG4gIFRvb2x0aXBNYW5hZ2VyOiAoKSA9PiBUb29sdGlwTWFuYWdlcixcbiAgVG9vbHRpcFBvc2l0aW9uOiAoKSA9PiBUb29sdGlwUG9zaXRpb24sXG4gIFVOSU9OOiAoKSA9PiBVTklPTixcbiAgVXBkYXRlU2VydmljZTogKCkgPT4gVXBkYXRlU2VydmljZSxcbiAgVkVSVElDQUxfQUxJR046ICgpID0+IFZFUlRJQ0FMX0FMSUdOLFxuICBWYWxpZGF0ZTogKCkgPT4gVmFsaWRhdGUsXG4gIFpvb21NYW5hZ2VyOiAoKSA9PiBab29tTWFuYWdlcixcbiAgX19GT1JDRV9NT0RVTEVfREVURUNUSU9OOiAoKSA9PiBfX0ZPUkNFX01PRFVMRV9ERVRFQ1RJT04sXG4gIGFjY3VtdWxhdGVHcm91cDogKCkgPT4gYWNjdW11bGF0ZUdyb3VwLFxuICBhY2N1bXVsYXRlU3RhY2s6ICgpID0+IGFjY3VtdWxhdGVTdGFjayxcbiAgYWNjdW11bGF0ZWRWYWx1ZTogKCkgPT4gYWNjdW11bGF0ZWRWYWx1ZSxcbiAgYWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eTogKCkgPT4gYWNjdW11bGF0aXZlVmFsdWVQcm9wZXJ0eSxcbiAgYWRkSGl0VGVzdGVyc1RvUXVhZHRyZWU6ICgpID0+IGFkZEhpdFRlc3RlcnNUb1F1YWR0cmVlLFxuICBhZGp1c3RMYWJlbFBsYWNlbWVudDogKCkgPT4gYWRqdXN0TGFiZWxQbGFjZW1lbnQsXG4gIGFsbEluU3RyaW5nVW5pb246ICgpID0+IGFsbEluU3RyaW5nVW5pb24sXG4gIGFuaW1hdGlvblZhbGlkYXRpb246ICgpID0+IGFuaW1hdGlvblZhbGlkYXRpb24sXG4gIGFyZWE6ICgpID0+IGFyZWEsXG4gIGFycmF5c0VxdWFsOiAoKSA9PiBhcnJheXNFcXVhbCxcbiAgYmFja2ZpbGxQYXRoUG9pbnREYXRhOiAoKSA9PiBiYWNrZmlsbFBhdGhQb2ludERhdGEsXG4gIGJhc2ljQ29udGludW91c0NoZWNrRGF0dW1WYWxpZGF0aW9uOiAoKSA9PiBiYXNpY0NvbnRpbnVvdXNDaGVja0RhdHVtVmFsaWRhdGlvbixcbiAgYmlmdXJjYXRlOiAoKSA9PiBiaWZ1cmNhdGUsXG4gIGJ1aWxkRm9ybWF0dGVyOiAoKSA9PiBidWlsZEZvcm1hdHRlcixcbiAgYnVpbGRSZXNldFBhdGhGbjogKCkgPT4gYnVpbGRSZXNldFBhdGhGbixcbiAgY2FsY3VsYXRlRGVmYXVsdFRpbWVUaWNrRm9ybWF0OiAoKSA9PiBjYWxjdWxhdGVEZWZhdWx0VGltZVRpY2tGb3JtYXQsXG4gIGNhbGN1bGF0ZUxhYmVsQ2hhcnRQYWRkaW5nOiAoKSA9PiBjYWxjdWxhdGVMYWJlbENoYXJ0UGFkZGluZyxcbiAgY2FsY3VsYXRlTGFiZWxUcmFuc2xhdGlvbjogKCkgPT4gY2FsY3VsYXRlTGFiZWxUcmFuc2xhdGlvbixcbiAgY2FsY3VsYXRlUGxhY2VtZW50OiAoKSA9PiBjYWxjdWxhdGVQbGFjZW1lbnQsXG4gIGNoZWNrQ3Jpc3A6ICgpID0+IGNoZWNrQ3Jpc3AsXG4gIGNoaWxkcmVuSXRlcjogKCkgPT4gY2hpbGRyZW5JdGVyLFxuICBjaXJjdWxhclNsaWNlQXJyYXk6ICgpID0+IGNpcmN1bGFyU2xpY2VBcnJheSxcbiAgY2xhbXA6ICgpID0+IGNsYW1wLFxuICBjbGFtcEFycmF5OiAoKSA9PiBjbGFtcEFycmF5LFxuICBjb2xsYXBzZWRTdGFydGluZ0JhclBvc2l0aW9uOiAoKSA9PiBjb2xsYXBzZWRTdGFydGluZ0JhclBvc2l0aW9uLFxuICBjb21wdXRlQmFyRm9jdXNCb3VuZHM6ICgpID0+IGNvbXB1dGVCYXJGb2N1c0JvdW5kcyxcbiAgY29tcHV0ZU1hcmtlckZvY3VzQm91bmRzOiAoKSA9PiBjb21wdXRlTWFya2VyRm9jdXNCb3VuZHMsXG4gIGNvbnZlcnRWYWx1ZXNUb1NjYWxlQnlEZWZzOiAoKSA9PiBjb252ZXJ0VmFsdWVzVG9TY2FsZUJ5RGVmcyxcbiAgY291bnRGcmFjdGlvbkRpZ2l0czogKCkgPT4gY291bnRGcmFjdGlvbkRpZ2l0cyxcbiAgY3JlYXRlRGF0dW1JZDogKCkgPT4gY3JlYXRlRGF0dW1JZCxcbiAgY3JlYXRlRGVwcmVjYXRpb25XYXJuaW5nOiAoKSA9PiBjcmVhdGVEZXByZWNhdGlvbldhcm5pbmcsXG4gIGNyZWF0ZUVsZW1lbnQ6ICgpID0+IGNyZWF0ZUVsZW1lbnQsXG4gIGNyZWF0ZUVsZW1lbnROUzogKCkgPT4gY3JlYXRlRWxlbWVudE5TLFxuICBkYXRlVG9OdW1iZXI6ICgpID0+IGRhdGVUb051bWJlcixcbiAgZGVjb25zdHJ1Y3RTZWxlY3Rpb25zT3JOb2RlczogKCkgPT4gZGVjb25zdHJ1Y3RTZWxlY3Rpb25zT3JOb2RlcyxcbiAgZGVlcENsb25lOiAoKSA9PiBkZWVwQ2xvbmUsXG4gIGRlZXBNZXJnZTogKCkgPT4gZGVlcE1lcmdlLFxuICBkZWZhdWx0VGltZVRpY2tGb3JtYXQ6ICgpID0+IGRlZmF1bHRUaW1lVGlja0Zvcm1hdCxcbiAgZGV0ZXJtaW5lUGF0aFN0YXR1czogKCkgPT4gZGV0ZXJtaW5lUGF0aFN0YXR1cyxcbiAgZGlmZjogKCkgPT4gZGlmZixcbiAgZG93bmxvYWRVcmw6ICgpID0+IGRvd25sb2FkVXJsLFxuICBlbnRlcnByaXNlTW9kdWxlOiAoKSA9PiBlbnRlcnByaXNlTW9kdWxlLFxuICBleHRlbnQ6ICgpID0+IGV4dGVudCxcbiAgZXh0cmFjdERlY29yYXRlZFByb3BlcnRpZXM6ICgpID0+IGV4dHJhY3REZWNvcmF0ZWRQcm9wZXJ0aWVzLFxuICBmaW5kTWF4VmFsdWU6ICgpID0+IGZpbmRNYXhWYWx1ZSxcbiAgZmluZE1pbk1heDogKCkgPT4gZmluZE1pbk1heCxcbiAgZmluZFF1YWR0cmVlTWF0Y2g6ICgpID0+IGZpbmRRdWFkdHJlZU1hdGNoLFxuICBmaW5kUmFuZ2VFeHRlbnQ6ICgpID0+IGZpbmRSYW5nZUV4dGVudCxcbiAgZml4TnVtZXJpY0V4dGVudDogKCkgPT4gZml4TnVtZXJpY0V4dGVudCxcbiAgZm9ybWF0Tm9ybWFsaXplZFBlcmNlbnRhZ2U6ICgpID0+IGZvcm1hdE5vcm1hbGl6ZWRQZXJjZW50YWdlLFxuICBmb3JtYXRQZXJjZW50YWdlOiAoKSA9PiBmb3JtYXRQZXJjZW50YWdlLFxuICBmcm9tVG9Nb3Rpb246ICgpID0+IGZyb21Ub01vdGlvbixcbiAgZ2V0RG9jdW1lbnQ6ICgpID0+IGdldERvY3VtZW50LFxuICBnZXRNaXNzQ291bnQ6ICgpID0+IGdldE1pc3NDb3VudCxcbiAgZ2V0UGF0aDogKCkgPT4gZ2V0UGF0aCxcbiAgZ2V0UGF0aENvbXBvbmVudHM6ICgpID0+IGdldFBhdGhDb21wb25lbnRzLFxuICBnZXRSZWN0Q29uZmlnOiAoKSA9PiBnZXRSZWN0Q29uZmlnLFxuICBnZXRXaW5kb3c6ICgpID0+IGdldFdpbmRvdyxcbiAgZ3JvdXBBY2N1bXVsYXRpdmVWYWx1ZVByb3BlcnR5OiAoKSA9PiBncm91cEFjY3VtdWxhdGl2ZVZhbHVlUHJvcGVydHksXG4gIGdyb3VwQXZlcmFnZTogKCkgPT4gZ3JvdXBBdmVyYWdlLFxuICBncm91cEJ5OiAoKSA9PiBncm91cEJ5LFxuICBncm91cENvdW50OiAoKSA9PiBncm91cENvdW50LFxuICBncm91cFN0YWNrVmFsdWVQcm9wZXJ0eTogKCkgPT4gZ3JvdXBTdGFja1ZhbHVlUHJvcGVydHksXG4gIGdyb3VwU3VtOiAoKSA9PiBncm91cFN1bSxcbiAgaW5pdE1lbnVLZXlOYXY6ICgpID0+IGluaXRNZW51S2V5TmF2LFxuICBpbml0VG9vbGJhcktleU5hdjogKCkgPT4gaW5pdFRvb2xiYXJLZXlOYXYsXG4gIGlzQXJyYXk6ICgpID0+IGlzQXJyYXksXG4gIGlzQm9vbGVhbjogKCkgPT4gaXNCb29sZWFuLFxuICBpc0RhdGU6ICgpID0+IGlzRGF0ZSxcbiAgaXNEZWNvcmF0ZWRPYmplY3Q6ICgpID0+IGlzRGVjb3JhdGVkT2JqZWN0LFxuICBpc0RlZmluZWQ6ICgpID0+IGlzRGVmaW5lZCxcbiAgaXNFbnVtS2V5OiAoKSA9PiBpc0VudW1LZXksXG4gIGlzRW51bVZhbHVlOiAoKSA9PiBpc0VudW1WYWx1ZSxcbiAgaXNFcXVhbDogKCkgPT4gaXNFcXVhbCxcbiAgaXNGaW5pdGVOdW1iZXI6ICgpID0+IGlzRmluaXRlTnVtYmVyLFxuICBpc0Z1bmN0aW9uOiAoKSA9PiBpc0Z1bmN0aW9uLFxuICBpc0h0bWxFbGVtZW50OiAoKSA9PiBpc0h0bWxFbGVtZW50LFxuICBpc05lZ2F0aXZlOiAoKSA9PiBpc05lZ2F0aXZlLFxuICBpc051bWJlcjogKCkgPT4gaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiAoKSA9PiBpc09iamVjdCxcbiAgaXNPYmplY3RMaWtlOiAoKSA9PiBpc09iamVjdExpa2UsXG4gIGlzUGxhaW5PYmplY3Q6ICgpID0+IGlzUGxhaW5PYmplY3QsXG4gIGlzUHJvcGVydGllczogKCkgPT4gaXNQcm9wZXJ0aWVzLFxuICBpc1JlZ0V4cDogKCkgPT4gaXNSZWdFeHAsXG4gIGlzU3RyaW5nOiAoKSA9PiBpc1N0cmluZyxcbiAgaXNTeW1ib2w6ICgpID0+IGlzU3ltYm9sLFxuICBpc1ZhbGlkRGF0ZTogKCkgPT4gaXNWYWxpZERhdGUsXG4gIGpzb25BcHBseTogKCkgPT4ganNvbkFwcGx5LFxuICBqc29uRGlmZjogKCkgPT4ganNvbkRpZmYsXG4gIGpzb25XYWxrOiAoKSA9PiBqc29uV2FsayxcbiAga2V5UHJvcGVydHk6ICgpID0+IGtleVByb3BlcnR5LFxuICBsYWJlbERpcmVjdGlvbkhhbmRsaW5nOiAoKSA9PiBsYWJlbERpcmVjdGlvbkhhbmRsaW5nLFxuICBsaXN0RGVjb3JhdGVkUHJvcGVydGllczogKCkgPT4gbGlzdERlY29yYXRlZFByb3BlcnRpZXMsXG4gIG1ha2VBY2Nlc3NpYmxlQ2xpY2tMaXN0ZW5lcjogKCkgPT4gbWFrZUFjY2Vzc2libGVDbGlja0xpc3RlbmVyLFxuICBtYXBJdGVyYWJsZTogKCkgPT4gbWFwSXRlcmFibGUsXG4gIG1hcFZhbHVlczogKCkgPT4gbWFwVmFsdWVzLFxuICBtYXJrZXJGYWRlSW5BbmltYXRpb246ICgpID0+IG1hcmtlckZhZGVJbkFuaW1hdGlvbixcbiAgbWFya2VyUGFsZXR0ZUZhY3Rvcnk6ICgpID0+IG1hcmtlclBhbGV0dGVGYWN0b3J5LFxuICBtYXJrZXJTY2FsZUluQW5pbWF0aW9uOiAoKSA9PiBtYXJrZXJTY2FsZUluQW5pbWF0aW9uLFxuICBtYXJrZXJTd2lwZVNjYWxlSW5BbmltYXRpb246ICgpID0+IG1hcmtlclN3aXBlU2NhbGVJbkFuaW1hdGlvbixcbiAgbWVyZ2VBcnJheURlZmF1bHRzOiAoKSA9PiBtZXJnZUFycmF5RGVmYXVsdHMsXG4gIG1lcmdlRGVmYXVsdHM6ICgpID0+IG1lcmdlRGVmYXVsdHMsXG4gIG1pZHBvaW50U3RhcnRpbmdCYXJQb3NpdGlvbjogKCkgPT4gbWlkcG9pbnRTdGFydGluZ0JhclBvc2l0aW9uLFxuICBtaW5NYXg6ICgpID0+IG1pbk1heCxcbiAgbW9kOiAoKSA9PiBtb2QsXG4gIG1vZHVsZVJlZ2lzdHJ5OiAoKSA9PiBtb2R1bGVSZWdpc3RyeSxcbiAgbmVhcmVzdFNxdWFyZWQ6ICgpID0+IG5lYXJlc3RTcXVhcmVkLFxuICBuZWFyZXN0U3F1YXJlZEluQ29udGFpbmVyOiAoKSA9PiBuZWFyZXN0U3F1YXJlZEluQ29udGFpbmVyLFxuICBub3JtYWxpc2VHcm91cFRvOiAoKSA9PiBub3JtYWxpc2VHcm91cFRvLFxuICBub3JtYWxpc2VQcm9wZXJ0eVRvOiAoKSA9PiBub3JtYWxpc2VQcm9wZXJ0eVRvLFxuICBub3JtYWxpc2VkRXh0ZW50OiAoKSA9PiBub3JtYWxpc2VkRXh0ZW50LFxuICBub3JtYWxpc2VkRXh0ZW50V2l0aE1ldGFkYXRhOiAoKSA9PiBub3JtYWxpc2VkRXh0ZW50V2l0aE1ldGFkYXRhLFxuICBwYWlyQ2F0ZWdvcnlEYXRhOiAoKSA9PiBwYWlyQ2F0ZWdvcnlEYXRhLFxuICBwYWlyQ29udGludW91c0RhdGE6ICgpID0+IHBhaXJDb250aW51b3VzRGF0YSxcbiAgcGFydGlhbEFzc2lnbjogKCkgPT4gcGFydGlhbEFzc2lnbixcbiAgcGF0aEZhZGVJbkFuaW1hdGlvbjogKCkgPT4gcGF0aEZhZGVJbkFuaW1hdGlvbixcbiAgcGF0aEZhZGVPdXRBbmltYXRpb246ICgpID0+IHBhdGhGYWRlT3V0QW5pbWF0aW9uLFxuICBwYXRoUmFuZ2VQb2ludHM6ICgpID0+IHBhdGhSYW5nZVBvaW50cyxcbiAgcGF0aFJhbmdlUG9pbnRzUmV2ZXJzZTogKCkgPT4gcGF0aFJhbmdlUG9pbnRzUmV2ZXJzZSxcbiAgcGF0aFJhbmdlczogKCkgPT4gcGF0aFJhbmdlcyxcbiAgcGF0aFN3aXBlSW5BbmltYXRpb246ICgpID0+IHBhdGhTd2lwZUluQW5pbWF0aW9uLFxuICBwaWNrQnlNYXRjaGluZ0FuZ2xlOiAoKSA9PiBwaWNrQnlNYXRjaGluZ0FuZ2xlLFxuICBwaWNrTm9kZTogKCkgPT4gcGlja05vZGUsXG4gIHBsb3RQYXRoOiAoKSA9PiBwbG90UGF0aCxcbiAgcHJlZGljYXRlV2l0aE1lc3NhZ2U6ICgpID0+IHByZWRpY2F0ZVdpdGhNZXNzYWdlLFxuICBwcmVwYXJlQXJlYVBhdGhBbmltYXRpb246ICgpID0+IHByZXBhcmVBcmVhUGF0aEFuaW1hdGlvbixcbiAgcHJlcGFyZUF4aXNBbmltYXRpb25Db250ZXh0OiAoKSA9PiBwcmVwYXJlQXhpc0FuaW1hdGlvbkNvbnRleHQsXG4gIHByZXBhcmVBeGlzQW5pbWF0aW9uRnVuY3Rpb25zOiAoKSA9PiBwcmVwYXJlQXhpc0FuaW1hdGlvbkZ1bmN0aW9ucyxcbiAgcHJlcGFyZUJhckFuaW1hdGlvbkZ1bmN0aW9uczogKCkgPT4gcHJlcGFyZUJhckFuaW1hdGlvbkZ1bmN0aW9ucyxcbiAgcHJlcGFyZUxpbmVQYXRoQW5pbWF0aW9uOiAoKSA9PiBwcmVwYXJlTGluZVBhdGhBbmltYXRpb24sXG4gIHByZXBhcmVMaW5lUGF0aEFuaW1hdGlvbkZuczogKCkgPT4gcHJlcGFyZUxpbmVQYXRoQW5pbWF0aW9uRm5zLFxuICBwcmVwYXJlTGluZVBhdGhQcm9wZXJ0eUFuaW1hdGlvbjogKCkgPT4gcHJlcGFyZUxpbmVQYXRoUHJvcGVydHlBbmltYXRpb24sXG4gIHByZXBhcmVNYXJrZXJBbmltYXRpb246ICgpID0+IHByZXBhcmVNYXJrZXJBbmltYXRpb24sXG4gIHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnM6ICgpID0+IHByZXBhcmVQaWVTZXJpZXNBbmltYXRpb25GdW5jdGlvbnMsXG4gIHJhbmdlOiAoKSA9PiByYW5nZTIsXG4gIHJhbmdlZFZhbHVlUHJvcGVydHk6ICgpID0+IHJhbmdlZFZhbHVlUHJvcGVydHksXG4gIHJlbmRlclBhcnRpYWxQYXRoOiAoKSA9PiByZW5kZXJQYXJ0aWFsUGF0aCxcbiAgcmVzZXRBeGlzR3JvdXBGbjogKCkgPT4gcmVzZXRBeGlzR3JvdXBGbixcbiAgcmVzZXRBeGlzTGFiZWxTZWxlY3Rpb25GbjogKCkgPT4gcmVzZXRBeGlzTGFiZWxTZWxlY3Rpb25GbixcbiAgcmVzZXRBeGlzTGluZVNlbGVjdGlvbkZuOiAoKSA9PiByZXNldEF4aXNMaW5lU2VsZWN0aW9uRm4sXG4gIHJlc2V0QXhpc1NlbGVjdGlvbkZuOiAoKSA9PiByZXNldEF4aXNTZWxlY3Rpb25GbixcbiAgcmVzZXRCYXJTZWxlY3Rpb25zRm46ICgpID0+IHJlc2V0QmFyU2VsZWN0aW9uc0ZuLFxuICByZXNldElkczogKCkgPT4gcmVzZXRJZHMsXG4gIHJlc2V0TGFiZWxGbjogKCkgPT4gcmVzZXRMYWJlbEZuLFxuICByZXNldE1hcmtlckZuOiAoKSA9PiByZXNldE1hcmtlckZuLFxuICByZXNldE1hcmtlclBvc2l0aW9uRm46ICgpID0+IHJlc2V0TWFya2VyUG9zaXRpb25GbixcbiAgcmVzZXRNb3Rpb246ICgpID0+IHJlc2V0TW90aW9uLFxuICByZXNldFBpZVNlbGVjdGlvbnNGbjogKCkgPT4gcmVzZXRQaWVTZWxlY3Rpb25zRm4sXG4gIHJvdW5kOiAoKSA9PiByb3VuZCxcbiAgc2NhbGU6ICgpID0+IHNjYWxlLFxuICBzZXJpZXNMYWJlbEZhZGVJbkFuaW1hdGlvbjogKCkgPT4gc2VyaWVzTGFiZWxGYWRlSW5BbmltYXRpb24sXG4gIHNlcmllc0xhYmVsRmFkZU91dEFuaW1hdGlvbjogKCkgPT4gc2VyaWVzTGFiZWxGYWRlT3V0QW5pbWF0aW9uLFxuICBzZXREb2N1bWVudDogKCkgPT4gc2V0RG9jdW1lbnQsXG4gIHNldEVsZW1lbnRCQm94OiAoKSA9PiBzZXRFbGVtZW50QkJveCxcbiAgc2V0UGF0aDogKCkgPT4gc2V0UGF0aCxcbiAgc2V0V2luZG93OiAoKSA9PiBzZXRXaW5kb3csXG4gIHNoYWxsb3dDbG9uZTogKCkgPT4gc2hhbGxvd0Nsb25lLFxuICBzaW5nbGVTZXJpZXNQYWxldHRlRmFjdG9yeTogKCkgPT4gc2luZ2xlU2VyaWVzUGFsZXR0ZUZhY3RvcnksXG4gIHNwbGl0UGFpckRhdGE6ICgpID0+IHNwbGl0UGFpckRhdGEsXG4gIHN0YXRpY0Zyb21Ub01vdGlvbjogKCkgPT4gc3RhdGljRnJvbVRvTW90aW9uLFxuICBzdHJpbmdpZnk6ICgpID0+IHN0cmluZ2lmeSxcbiAgc3VtOiAoKSA9PiBzdW0sXG4gIHN1bVZhbHVlczogKCkgPT4gc3VtVmFsdWVzLFxuICB0aW1lczogKCkgPT4gdGltZXMsXG4gIHRvQXJyYXk6ICgpID0+IHRvQXJyYXksXG4gIHRvRml4ZWQ6ICgpID0+IHRvRml4ZWQsXG4gIHRvVG9vbHRpcEh0bWw6ICgpID0+IHRvVG9vbHRpcEh0bWwsXG4gIHRyYWlsaW5nQWNjdW11bGF0ZWRWYWx1ZTogKCkgPT4gdHJhaWxpbmdBY2N1bXVsYXRlZFZhbHVlLFxuICB0cmFpbGluZ0FjY3VtdWxhdGVkVmFsdWVQcm9wZXJ0eTogKCkgPT4gdHJhaWxpbmdBY2N1bXVsYXRlZFZhbHVlUHJvcGVydHksXG4gIHVuaXF1ZTogKCkgPT4gdW5pcXVlLFxuICB1cGRhdGVDbGlwUGF0aDogKCkgPT4gdXBkYXRlQ2xpcFBhdGgsXG4gIHVwZGF0ZUxhYmVsTm9kZTogKCkgPT4gdXBkYXRlTGFiZWxOb2RlLFxuICB1cGRhdGVSZWN0OiAoKSA9PiB1cGRhdGVSZWN0LFxuICB2YWxpZGF0ZUNyb3NzTGluZVZhbHVlczogKCkgPT4gdmFsaWRhdGVDcm9zc0xpbmVWYWx1ZXMsXG4gIHZhbHVlUHJvcGVydHk6ICgpID0+IHZhbHVlUHJvcGVydHksXG4gIHdpdGhvdXQ6ICgpID0+IHdpdGhvdXRcbn0pO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy91dGlsL2RlcHJlY2F0aW9uLnRzXG5mdW5jdGlvbiBjcmVhdGVEZXByZWNhdGlvbldhcm5pbmcoKSB7XG4gIHJldHVybiAoa2V5LCBtZXNzYWdlKSA9PiB7XG4gICAgY29uc3QgbXNnID0gW2BQcm9wZXJ0eSBbJHtrZXl9XSBpcyBkZXByZWNhdGVkLmAsIG1lc3NhZ2VdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbiAgICBMb2dnZXIud2Fybk9uY2UobXNnKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIERlcHJlY2F0ZWQobWVzc2FnZSwgb3B0cykge1xuICBjb25zdCB3YXJuRGVwcmVjYXRlZCA9IGNyZWF0ZURlcHJlY2F0aW9uV2FybmluZygpO1xuICBjb25zdCBkZWYgPSBvcHRzPy5kZWZhdWx0O1xuICByZXR1cm4gYWRkVHJhbnNmb3JtVG9JbnN0YW5jZVByb3BlcnR5KChfLCBrZXksIHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlICE9PSBkZWYpIHtcbiAgICAgIHdhcm5EZXByZWNhdGVkKGtleS50b1N0cmluZygpLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIERlcHJlY2F0ZWRBbmRSZW5hbWVkVG8obmV3UHJvcE5hbWUsIG1hcFZhbHVlKSB7XG4gIGNvbnN0IHdhcm5EZXByZWNhdGVkID0gY3JlYXRlRGVwcmVjYXRpb25XYXJuaW5nKCk7XG4gIHJldHVybiBhZGRUcmFuc2Zvcm1Ub0luc3RhbmNlUHJvcGVydHkoXG4gICAgKHRhcmdldCwga2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHZhbHVlICE9PSB0YXJnZXRbbmV3UHJvcE5hbWVdKSB7XG4gICAgICAgIHdhcm5EZXByZWNhdGVkKGtleS50b1N0cmluZygpLCBgVXNlIFske25ld1Byb3BOYW1lfV0gaW5zdGVhZC5gKTtcbiAgICAgICAgc2V0UGF0aCh0YXJnZXQsIG5ld1Byb3BOYW1lLCBtYXBWYWx1ZSA/IG1hcFZhbHVlKHZhbHVlKSA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBCUkVBS19UUkFOU0ZPUk1fQ0hBSU47XG4gICAgfSxcbiAgICAodGFyZ2V0LCBrZXkpID0+IHtcbiAgICAgIHdhcm5EZXByZWNhdGVkKGtleS50b1N0cmluZygpLCBgVXNlIFske25ld1Byb3BOYW1lfV0gaW5zdGVhZC5gKTtcbiAgICAgIHJldHVybiBnZXRQYXRoKHRhcmdldCwgbmV3UHJvcE5hbWUpO1xuICAgIH1cbiAgKTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvdXRpbC9zZWFyY2gudXRpbC50c1xuZnVuY3Rpb24gZmluZE1heFZhbHVlKG1pbiwgbWF4LCBpdGVyYXRlZSkge1xuICBpZiAobWluID4gbWF4KVxuICAgIHJldHVybjtcbiAgbGV0IGZvdW5kO1xuICB3aGlsZSAobWF4ID49IG1pbikge1xuICAgIGNvbnN0IGluZGV4ID0gTWF0aC5mbG9vcigobWF4ICsgbWluKSAvIDIpO1xuICAgIGNvbnN0IHZhbHVlID0gaXRlcmF0ZWUoaW5kZXgpO1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBtYXggPSBpbmRleCAtIDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvdW5kID0gdmFsdWU7XG4gICAgICBtaW4gPSBpbmRleCArIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiBmb3VuZDtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2hpZXJhcmNoeS9oaWVyYXJjaHlTZXJpZXMudHNcbnZhciBfSGllcmFyY2h5Tm9kZSA9IGNsYXNzIF9IaWVyYXJjaHlOb2RlIHtcbiAgY29uc3RydWN0b3Ioc2VyaWVzLCBpbmRleCwgZGF0dW0sIHNpemUsIGNvbG9yVmFsdWUsIGZpbGwsIHN0cm9rZSwgc3VtU2l6ZSwgZGVwdGgsIHBhcmVudCwgY2hpbGRyZW4pIHtcbiAgICB0aGlzLnNlcmllcyA9IHNlcmllcztcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5kYXR1bSA9IGRhdHVtO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5jb2xvclZhbHVlID0gY29sb3JWYWx1ZTtcbiAgICB0aGlzLmZpbGwgPSBmaWxsO1xuICAgIHRoaXMuc3Ryb2tlID0gc3Ryb2tlO1xuICAgIHRoaXMuc3VtU2l6ZSA9IHN1bVNpemU7XG4gICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICB0aGlzLm1pZFBvaW50ID0geyB4OiAwLCB5OiAwIH07XG4gIH1cbiAgY29udGFpbnMob3RoZXIpIHtcbiAgICBsZXQgY3VycmVudCA9IG90aGVyO1xuICAgIHdoaWxlIChjdXJyZW50ICE9IG51bGwgJiYgY3VycmVudC5pbmRleCA+PSB0aGlzLmluZGV4KSB7XG4gICAgICBpZiAoY3VycmVudCA9PT0gdGhpcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHdhbGsoY2FsbGJhY2syLCBvcmRlciA9IF9IaWVyYXJjaHlOb2RlLldhbGsuUHJlT3JkZXIpIHtcbiAgICBpZiAob3JkZXIgPT09IF9IaWVyYXJjaHlOb2RlLldhbGsuUHJlT3JkZXIpIHtcbiAgICAgIGNhbGxiYWNrMih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgY2hpbGQud2FsayhjYWxsYmFjazIsIG9yZGVyKTtcbiAgICB9KTtcbiAgICBpZiAob3JkZXIgPT09IF9IaWVyYXJjaHlOb2RlLldhbGsuUG9zdE9yZGVyKSB7XG4gICAgICBjYWxsYmFjazIodGhpcyk7XG4gICAgfVxuICB9XG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICB5aWVsZCB0aGlzO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgeWllbGQqIGNoaWxkO1xuICAgIH1cbiAgfVxufTtcbl9IaWVyYXJjaHlOb2RlLldhbGsgPSB7XG4gIFByZU9yZGVyOiAwLFxuICBQb3N0T3JkZXI6IDFcbn07XG52YXIgSGllcmFyY2h5Tm9kZSA9IF9IaWVyYXJjaHlOb2RlO1xudmFyIEhpZXJhcmNoeVNlcmllcyA9IGNsYXNzIGV4dGVuZHMgU2VyaWVzIHtcbiAgY29uc3RydWN0b3IobW9kdWxlQ3R4KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbW9kdWxlQ3R4LFxuICAgICAgcGlja01vZGVzOiBbMyAvKiBORUFSRVNUX05PREUgKi8sIDAgLyogRVhBQ1RfU0hBUEVfTUFUQ0ggKi9dLFxuICAgICAgY29udGVudEdyb3VwVmlydHVhbDogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLnJvb3ROb2RlID0gbmV3IEhpZXJhcmNoeU5vZGUoXG4gICAgICB0aGlzLFxuICAgICAgMCxcbiAgICAgIHZvaWQgMCxcbiAgICAgIDAsXG4gICAgICB2b2lkIDAsXG4gICAgICB2b2lkIDAsXG4gICAgICB2b2lkIDAsXG4gICAgICAwLFxuICAgICAgdm9pZCAwLFxuICAgICAgdm9pZCAwLFxuICAgICAgW11cbiAgICApO1xuICAgIHRoaXMuY29sb3JEb21haW4gPSBbMCwgMF07XG4gICAgdGhpcy5tYXhEZXB0aCA9IDA7XG4gICAgdGhpcy5mb2N1c1BhdGggPSBbXTtcbiAgICB0aGlzLmFuaW1hdGlvblN0YXRlID0gbmV3IFN0YXRlTWFjaGluZShcbiAgICAgIFwiZW1wdHlcIixcbiAgICAgIHtcbiAgICAgICAgZW1wdHk6IHtcbiAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJyZWFkeVwiLFxuICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlRW1wdHlVcGRhdGVSZWFkeShkYXRhKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzZXQ6IFwiZW1wdHlcIixcbiAgICAgICAgICBza2lwOiBcInJlYWR5XCJcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZHk6IHtcbiAgICAgICAgICB1cGRhdGVEYXRhOiBcIndhaXRpbmdcIixcbiAgICAgICAgICBjbGVhcjogXCJjbGVhcmluZ1wiLFxuICAgICAgICAgIGhpZ2hsaWdodDogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVJlYWR5SGlnaGxpZ2h0KGRhdGEpLFxuICAgICAgICAgIHJlc2l6ZTogKGRhdGEpID0+IHRoaXMuYW5pbWF0ZVJlYWR5UmVzaXplKGRhdGEpLFxuICAgICAgICAgIHJlc2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgc2tpcDogXCJyZWFkeVwiXG4gICAgICAgIH0sXG4gICAgICAgIHdhaXRpbmc6IHtcbiAgICAgICAgICB1cGRhdGU6IHtcbiAgICAgICAgICAgIHRhcmdldDogXCJyZWFkeVwiLFxuICAgICAgICAgICAgYWN0aW9uOiAoZGF0YSkgPT4gdGhpcy5hbmltYXRlV2FpdGluZ1VwZGF0ZVJlYWR5KGRhdGEpXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiLFxuICAgICAgICAgIHNraXA6IFwicmVhZHlcIlxuICAgICAgICB9LFxuICAgICAgICBjbGVhcmluZzoge1xuICAgICAgICAgIHVwZGF0ZToge1xuICAgICAgICAgICAgdGFyZ2V0OiBcImVtcHR5XCIsXG4gICAgICAgICAgICBhY3Rpb246IChkYXRhKSA9PiB0aGlzLmFuaW1hdGVDbGVhcmluZ1VwZGF0ZUVtcHR5KGRhdGEpXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXNldDogXCJlbXB0eVwiLFxuICAgICAgICAgIHNraXA6IFwicmVhZHlcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgKCkgPT4gdGhpcy5jaGVja1Byb2Nlc3NlZERhdGFBbmltYXRhYmxlKClcbiAgICApO1xuICB9XG4gIHJlc2V0QW5pbWF0aW9uKHBoYXNlKSB7XG4gICAgaWYgKHBoYXNlID09PSBcImluaXRpYWxcIikge1xuICAgICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwicmVzZXRcIik7XG4gICAgfSBlbHNlIGlmIChwaGFzZSA9PT0gXCJyZWFkeVwiKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvblN0YXRlLnRyYW5zaXRpb24oXCJza2lwXCIpO1xuICAgIH1cbiAgfVxuICBhc3luYyBwcm9jZXNzRGF0YSgpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuS2V5LCBzaXplS2V5LCBjb2xvcktleSwgZmlsbHMsIHN0cm9rZXMsIGNvbG9yUmFuZ2UgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGNvbnN0IGdldEluZGV4ID0gKCkgPT4ge1xuICAgICAgaW5kZXggKz0gMTtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuICAgIGxldCBtYXhEZXB0aCA9IDA7XG4gICAgbGV0IG1pbkNvbG9yID0gSW5maW5pdHk7XG4gICAgbGV0IG1heENvbG9yID0gLUluZmluaXR5O1xuICAgIGNvbnN0IGNvbG9ycyA9IG5ldyBBcnJheSgodGhpcy5kYXRhPy5sZW5ndGggPz8gMCkgKyAxKS5maWxsKHZvaWQgMCk7XG4gICAgY29uc3QgY3JlYXRlTm9kZSA9IChkYXR1bSwgcGFyZW50KSA9PiB7XG4gICAgICBjb25zdCBub2RlSW5kZXggPSBnZXRJbmRleCgpO1xuICAgICAgY29uc3QgZGVwdGggPSBwYXJlbnQuZGVwdGggIT0gbnVsbCA/IHBhcmVudC5kZXB0aCArIDEgOiAwO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBjaGlsZHJlbktleSAhPSBudWxsID8gZGF0dW1bY2hpbGRyZW5LZXldIDogdm9pZCAwO1xuICAgICAgY29uc3QgaXNMZWFmID0gY2hpbGRyZW4gPT0gbnVsbCB8fCBjaGlsZHJlbi5sZW5ndGggPT09IDA7XG4gICAgICBsZXQgc2l6ZSA9IHNpemVLZXkgIT0gbnVsbCA/IGRhdHVtW3NpemVLZXldIDogdm9pZCAwO1xuICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShzaXplKSkge1xuICAgICAgICBzaXplID0gTWF0aC5tYXgoc2l6ZSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaXplID0gaXNMZWFmID8gMSA6IDA7XG4gICAgICB9XG4gICAgICBjb25zdCBzdW1TaXplID0gc2l6ZTtcbiAgICAgIG1heERlcHRoID0gTWF0aC5tYXgobWF4RGVwdGgsIGRlcHRoKTtcbiAgICAgIGNvbnN0IGNvbG9yID0gY29sb3JLZXkgIT0gbnVsbCA/IGRhdHVtW2NvbG9yS2V5XSA6IHZvaWQgMDtcbiAgICAgIGlmICh0eXBlb2YgY29sb3IgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgY29sb3JzW25vZGVJbmRleF0gPSBjb2xvcjtcbiAgICAgICAgbWluQ29sb3IgPSBNYXRoLm1pbihtaW5Db2xvciwgY29sb3IpO1xuICAgICAgICBtYXhDb2xvciA9IE1hdGgubWF4KG1heENvbG9yLCBjb2xvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXBwZW5kQ2hpbGRyZW4oXG4gICAgICAgIG5ldyBIaWVyYXJjaHlOb2RlKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgbm9kZUluZGV4LFxuICAgICAgICAgIGRhdHVtLFxuICAgICAgICAgIHNpemUsXG4gICAgICAgICAgY29sb3IsXG4gICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICBzdW1TaXplLFxuICAgICAgICAgIGRlcHRoLFxuICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICBbXVxuICAgICAgICApLFxuICAgICAgICBjaGlsZHJlblxuICAgICAgKTtcbiAgICB9O1xuICAgIGNvbnN0IGFwcGVuZENoaWxkcmVuID0gKG5vZGUsIGRhdGEpID0+IHtcbiAgICAgIGRhdGE/LmZvckVhY2goKGRhdHVtKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY3JlYXRlTm9kZShkYXR1bSwgbm9kZSk7XG4gICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIG5vZGUuc3VtU2l6ZSArPSBjaGlsZC5zdW1TaXplO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIGNvbnN0IHJvb3ROb2RlID0gYXBwZW5kQ2hpbGRyZW4oXG4gICAgICBuZXcgSGllcmFyY2h5Tm9kZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICAwLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgW11cbiAgICAgICksXG4gICAgICB0aGlzLmRhdGFcbiAgICApO1xuICAgIGNvbnN0IGNvbG9yRG9tYWluID0gW21pbkNvbG9yLCBtYXhDb2xvcl07XG4gICAgbGV0IGNvbG9yU2NhbGU7XG4gICAgaWYgKGNvbG9yUmFuZ2UgIT0gbnVsbCAmJiBOdW1iZXIuaXNGaW5pdGUobWluQ29sb3IpICYmIE51bWJlci5pc0Zpbml0ZShtYXhDb2xvcikpIHtcbiAgICAgIGNvbG9yU2NhbGUgPSBuZXcgQ29sb3JTY2FsZSgpO1xuICAgICAgY29sb3JTY2FsZS5kb21haW4gPSBjb2xvckRvbWFpbjtcbiAgICAgIGNvbG9yU2NhbGUucmFuZ2UgPSBjb2xvclJhbmdlO1xuICAgICAgY29sb3JTY2FsZS51cGRhdGUoKTtcbiAgICB9XG4gICAgcm9vdE5vZGUuY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQsIGNoaWxkSW5kZXgpID0+IHtcbiAgICAgIGNoaWxkLndhbGsoKG5vZGUpID0+IHtcbiAgICAgICAgbGV0IGZpbGw7XG4gICAgICAgIGNvbnN0IGNvbG9yID0gY29sb3JzW25vZGUuaW5kZXhdO1xuICAgICAgICBpZiAoY29sb3IgIT0gbnVsbCkge1xuICAgICAgICAgIGZpbGwgPSBjb2xvclNjYWxlPy5jb252ZXJ0KGNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgICBmaWxsID8/IChmaWxsID0gZmlsbHM/LltjaGlsZEluZGV4ICUgZmlsbHMubGVuZ3RoXSk7XG4gICAgICAgIG5vZGUuZmlsbCA9IGZpbGw7XG4gICAgICAgIG5vZGUuc3Ryb2tlID0gY29sb3JTY2FsZSA9PSBudWxsID8gc3Ryb2tlcz8uW2NoaWxkSW5kZXggJSBzdHJva2VzLmxlbmd0aF0gOiBcInJnYmEoMCwgMCwgMCwgMC4yKVwiO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5yb290Tm9kZSA9IHJvb3ROb2RlO1xuICAgIHRoaXMubWF4RGVwdGggPSBtYXhEZXB0aDtcbiAgICB0aGlzLmNvbG9yRG9tYWluID0gY29sb3JEb21haW47XG4gICAgdGhpcy5mb2N1c1BhdGggPSBbeyBub2RlRGF0dW06IHRoaXMucm9vdE5vZGUsIGNoaWxkSW5kZXg6IDAgfV07XG4gIH1cbiAgYXN5bmMgdXBkYXRlKHsgc2VyaWVzUmVjdCB9KSB7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVTZWxlY3Rpb25zKCk7XG4gICAgYXdhaXQgdGhpcy51cGRhdGVOb2RlcygpO1xuICAgIGNvbnN0IGFuaW1hdGlvbkRhdGEgPSB0aGlzLmdldEFuaW1hdGlvbkRhdGEoKTtcbiAgICBjb25zdCByZXNpemUgPSB0aGlzLmNoZWNrUmVzaXplKHNlcmllc1JlY3QpO1xuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcInJlc2l6ZVwiLCBhbmltYXRpb25EYXRhKTtcbiAgICB9XG4gICAgdGhpcy5hbmltYXRpb25TdGF0ZS50cmFuc2l0aW9uKFwidXBkYXRlXCIsIGFuaW1hdGlvbkRhdGEpO1xuICB9XG4gIHJlc2V0QWxsQW5pbWF0aW9uKGRhdGEpIHtcbiAgICBjb25zdCBkYXR1bSA9IHRoaXMuYW5pbWF0aW9uUmVzZXRGbnM/LmRhdHVtO1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc3RvcEJ5QW5pbWF0aW9uR3JvdXBJZCh0aGlzLmlkKTtcbiAgICBpZiAoZGF0dW0gIT0gbnVsbCkge1xuICAgICAgcmVzZXRNb3Rpb24oZGF0YS5kYXR1bVNlbGVjdGlvbnMsIGRhdHVtKTtcbiAgICB9XG4gIH1cbiAgYW5pbWF0ZUVtcHR5VXBkYXRlUmVhZHkoZGF0YSkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oZGF0YSk7XG4gIH1cbiAgYW5pbWF0ZVdhaXRpbmdVcGRhdGVSZWFkeShkYXRhKSB7XG4gICAgdGhpcy5jdHguYW5pbWF0aW9uTWFuYWdlci5za2lwQ3VycmVudEJhdGNoKCk7XG4gICAgdGhpcy5yZXNldEFsbEFuaW1hdGlvbihkYXRhKTtcbiAgfVxuICBhbmltYXRlUmVhZHlIaWdobGlnaHQoZGF0YSkge1xuICAgIGNvbnN0IGRhdHVtID0gdGhpcy5hbmltYXRpb25SZXNldEZucz8uZGF0dW07XG4gICAgaWYgKGRhdHVtICE9IG51bGwpIHtcbiAgICAgIHJlc2V0TW90aW9uKFtkYXRhXSwgZGF0dW0pO1xuICAgIH1cbiAgfVxuICBhbmltYXRlUmVhZHlSZXNpemUoZGF0YSkge1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oZGF0YSk7XG4gIH1cbiAgYW5pbWF0ZUNsZWFyaW5nVXBkYXRlRW1wdHkoZGF0YSkge1xuICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIHRoaXMucmVzZXRBbGxBbmltYXRpb24oZGF0YSk7XG4gIH1cbiAgYW5pbWF0aW9uVHJhbnNpdGlvbkNsZWFyKCkge1xuICAgIHRoaXMuYW5pbWF0aW9uU3RhdGUudHJhbnNpdGlvbihcImNsZWFyXCIsIHRoaXMuZ2V0QW5pbWF0aW9uRGF0YSgpKTtcbiAgfVxuICBnZXRBbmltYXRpb25EYXRhKCkge1xuICAgIGNvbnN0IGFuaW1hdGlvbkRhdGEgPSB7XG4gICAgICBkYXR1bVNlbGVjdGlvbnM6IFt0aGlzLmdyb3VwU2VsZWN0aW9uXVxuICAgIH07XG4gICAgcmV0dXJuIGFuaW1hdGlvbkRhdGE7XG4gIH1cbiAgaXNQcm9jZXNzZWREYXRhQW5pbWF0YWJsZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjaGVja1Byb2Nlc3NlZERhdGFBbmltYXRhYmxlKCkge1xuICAgIGlmICghdGhpcy5pc1Byb2Nlc3NlZERhdGFBbmltYXRhYmxlKCkpIHtcbiAgICAgIHRoaXMuY3R4LmFuaW1hdGlvbk1hbmFnZXIuc2tpcEN1cnJlbnRCYXRjaCgpO1xuICAgIH1cbiAgfVxuICBnZXRMYWJlbERhdGEoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGdldFNlcmllc0RvbWFpbigpIHtcbiAgICByZXR1cm4gW05hTiwgTmFOXTtcbiAgfVxuICBnZXRMZWdlbmREYXRhKGxlZ2VuZFR5cGUpIHtcbiAgICBjb25zdCB7IGNvbG9yS2V5LCBjb2xvck5hbWUsIGNvbG9yUmFuZ2UsIHZpc2libGUgfSA9IHRoaXMucHJvcGVydGllcztcbiAgICByZXR1cm4gbGVnZW5kVHlwZSA9PT0gXCJncmFkaWVudFwiICYmIGNvbG9yS2V5ICE9IG51bGwgJiYgY29sb3JSYW5nZSAhPSBudWxsID8gW1xuICAgICAge1xuICAgICAgICBsZWdlbmRUeXBlOiBcImdyYWRpZW50XCIsXG4gICAgICAgIGVuYWJsZWQ6IHZpc2libGUsXG4gICAgICAgIHNlcmllc0lkOiB0aGlzLmlkLFxuICAgICAgICBjb2xvck5hbWUsXG4gICAgICAgIGNvbG9yUmFuZ2UsXG4gICAgICAgIGNvbG9yRG9tYWluOiB0aGlzLmNvbG9yRG9tYWluXG4gICAgICB9XG4gICAgXSA6IFtdO1xuICB9XG4gIGdldERhdHVtSWRGcm9tRGF0YShub2RlKSB7XG4gICAgcmV0dXJuIGAke25vZGUuaW5kZXh9YDtcbiAgfVxuICBnZXREYXR1bUlkKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXREYXR1bUlkRnJvbURhdGEobm9kZSk7XG4gIH1cbiAgcGlja0ZvY3VzKG9wdHMpIHtcbiAgICBpZiAodGhpcy5yb290Tm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIGlmICh0aGlzLmZvY3VzUGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIExvZ2dlci5lcnJvcihcInRoaXMuZm9jdXNQYXRoIHNob3VsZCBub3QgYmUgZW1wdHlcIik7XG4gICAgfVxuICAgIGNvbnN0IHsgZGF0dW1JbmRleERlbHRhOiBjaGlsZERlbHRhLCBvdGhlckluZGV4RGVsdGE6IGRlcHRoRGVsdGEgfSA9IG9wdHM7XG4gICAgY29uc3QgeyBmb2N1c1BhdGg6IHBhdGggfSA9IHRoaXM7XG4gICAgY29uc3QgZGVwdGggPSBwYXRoLmxlbmd0aCAtIDI7XG4gICAgaWYgKGRlcHRoRGVsdGEgIT09IDAgfHwgcGF0aC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IHRhcmdldERlcHRoID0gTWF0aC5tYXgoMCwgZGVwdGggKyBkZXB0aERlbHRhKTtcbiAgICAgIGlmIChwYXRoW3RhcmdldERlcHRoICsgMV0gIT09IHZvaWQgMCkge1xuICAgICAgICBwYXRoLmxlbmd0aCA9IHRhcmdldERlcHRoICsgMjtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUZvY3VzT3V0cHV0cyhwYXRoW3RhcmdldERlcHRoICsgMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGRlZXBlc3QgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIHdoaWxlIChkZWVwZXN0Lm5vZGVEYXR1bS5jaGlsZHJlbi5sZW5ndGggPiAwICYmIChkZWVwZXN0Lm5vZGVEYXR1bS5kZXB0aCA/PyAtMSkgPCB0YXJnZXREZXB0aCkge1xuICAgICAgICAgIGNvbnN0IG5leHREZWVwZXN0ID0geyBub2RlRGF0dW06IGRlZXBlc3Qubm9kZURhdHVtLmNoaWxkcmVuWzBdLCBjaGlsZEluZGV4OiAwIH07XG4gICAgICAgICAgcGF0aC5wdXNoKG5leHREZWVwZXN0KTtcbiAgICAgICAgICBkZWVwZXN0ID0gbmV4dERlZXBlc3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUZvY3VzT3V0cHV0cyhkZWVwZXN0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoaWxkRGVsdGEgIT09IDApIHtcbiAgICAgIGNvbnN0IHRhcmdldENoaWxkID0gcGF0aFtkZXB0aCArIDFdLmNoaWxkSW5kZXggKyBjaGlsZERlbHRhO1xuICAgICAgY29uc3QgY3VycmVudFBhcmVudCA9IHBhdGhbZGVwdGhdLm5vZGVEYXR1bTtcbiAgICAgIGNvbnN0IGNoaWxkQ291bnQgPSBjdXJyZW50UGFyZW50Py5jaGlsZHJlbj8ubGVuZ3RoO1xuICAgICAgaWYgKGNoaWxkQ291bnQgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBuZXdDaGlsZCA9IGNsYW1wKDAsIHRhcmdldENoaWxkLCBjaGlsZENvdW50IC0gMSk7XG4gICAgICAgIGNvbnN0IG5ld0ZvY3VzID0geyBub2RlRGF0dW06IGN1cnJlbnRQYXJlbnQuY2hpbGRyZW5bbmV3Q2hpbGRdLCBjaGlsZEluZGV4OiBuZXdDaGlsZCB9O1xuICAgICAgICBwYXRoW2RlcHRoICsgMV0gPSBuZXdGb2N1cztcbiAgICAgICAgcGF0aC5sZW5ndGggPSBkZXB0aCArIDI7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVGb2N1c091dHB1dHMobmV3Rm9jdXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wdXRlRm9jdXNPdXRwdXRzKHBhdGhbcGF0aC5sZW5ndGggLSAxXSk7XG4gICAgfVxuICB9XG4gIGdldERhdHVtQXJpYVRleHQoZGF0dW0sIGRlc2NyaXB0aW9uKSB7XG4gICAgaWYgKCEoZGF0dW0gaW5zdGFuY2VvZiBIaWVyYXJjaHlOb2RlKSkge1xuICAgICAgTG9nZ2VyLmVycm9yKGBkYXR1bSBpcyBub3QgSGllcmFyY2h5Tm9kZTogJHtkYXR1bX1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3R4LmxvY2FsZU1hbmFnZXIudChcImFyaWFBbm5vdW5jZUhpZXJhcmNoeURhdHVtXCIsIHtcbiAgICAgIGxldmVsOiAoZGF0dW0uZGVwdGggPz8gLTEpICsgMSxcbiAgICAgIGNvdW50OiBkYXR1bS5jaGlsZHJlbi5sZW5ndGgsXG4gICAgICBkZXNjcmlwdGlvblxuICAgIH0pO1xuICB9XG4gIGNvbXB1dGVGb2N1c091dHB1dHMoeyBub2RlRGF0dW0sIGNoaWxkSW5kZXggfSkge1xuICAgIGNvbnN0IGJvdW5kcyA9IHRoaXMuY29tcHV0ZUZvY3VzQm91bmRzKG5vZGVEYXR1bSk7XG4gICAgaWYgKGJvdW5kcykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGF0dW06IG5vZGVEYXR1bSxcbiAgICAgICAgZGF0dW1JbmRleDogY2hpbGRJbmRleCxcbiAgICAgICAgb3RoZXJJbmRleDogbm9kZURhdHVtLmRlcHRoLFxuICAgICAgICBib3VuZHMsXG4gICAgICAgIHNob3dGb2N1c0JveDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL2hpZXJhcmNoeS9oaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzLnRzXG52YXIgSGllcmFyY2h5U2VyaWVzUHJvcGVydGllcyA9IGNsYXNzIGV4dGVuZHMgU2VyaWVzUHJvcGVydGllcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5jaGlsZHJlbktleSA9IFwiY2hpbGRyZW5cIjtcbiAgICB0aGlzLmZpbGxzID0gT2JqZWN0LnZhbHVlcyhERUZBVUxUX0ZJTExTKTtcbiAgICB0aGlzLnN0cm9rZXMgPSBPYmplY3QudmFsdWVzKERFRkFVTFRfU1RST0tFUyk7XG4gIH1cbn07XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcpXG5dLCBIaWVyYXJjaHlTZXJpZXNQcm9wZXJ0aWVzLnByb3RvdHlwZSwgXCJjaGlsZHJlbktleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgSGllcmFyY2h5U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic2l6ZUtleVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKFNUUklORywgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgSGllcmFyY2h5U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29sb3JLZXlcIiwgMik7XG5fX2RlY29yYXRlQ2xhc3MoW1xuICBWYWxpZGF0ZShTVFJJTkcsIHsgb3B0aW9uYWw6IHRydWUgfSlcbl0sIEhpZXJhcmNoeVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImNvbG9yTmFtZVwiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklOR19BUlJBWSlcbl0sIEhpZXJhcmNoeVNlcmllc1Byb3BlcnRpZXMucHJvdG90eXBlLCBcImZpbGxzXCIsIDIpO1xuX19kZWNvcmF0ZUNsYXNzKFtcbiAgVmFsaWRhdGUoQ09MT1JfU1RSSU5HX0FSUkFZKVxuXSwgSGllcmFyY2h5U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwic3Ryb2tlc1wiLCAyKTtcbl9fZGVjb3JhdGVDbGFzcyhbXG4gIFZhbGlkYXRlKENPTE9SX1NUUklOR19BUlJBWSwgeyBvcHRpb25hbDogdHJ1ZSB9KVxuXSwgSGllcmFyY2h5U2VyaWVzUHJvcGVydGllcy5wcm90b3R5cGUsIFwiY29sb3JSYW5nZVwiLCAyKTtcblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvc2VyaWVzL3RvcG9sb2d5L2xvbkxhdEJib3gudHNcbnZhciBMb25MYXRCQm94ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcihsb24wLCBsYXQwLCBsb24xLCBsYXQxKSB7XG4gICAgdGhpcy5sb24wID0gbG9uMDtcbiAgICB0aGlzLmxhdDAgPSBsYXQwO1xuICAgIHRoaXMubG9uMSA9IGxvbjE7XG4gICAgdGhpcy5sYXQxID0gbGF0MTtcbiAgfVxuICBtZXJnZShvdGhlcikge1xuICAgIHRoaXMubG9uMCA9IE1hdGgubWluKHRoaXMubG9uMCwgb3RoZXIubG9uMCk7XG4gICAgdGhpcy5sYXQwID0gTWF0aC5taW4odGhpcy5sYXQwLCBvdGhlci5sYXQwKTtcbiAgICB0aGlzLmxvbjEgPSBNYXRoLm1heCh0aGlzLmxvbjEsIG90aGVyLmxvbjEpO1xuICAgIHRoaXMubGF0MSA9IE1hdGgubWF4KHRoaXMubGF0MSwgb3RoZXIubGF0MSk7XG4gIH1cbn07XG5cbi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1jb21tdW5pdHkvc3JjL3V0aWwvdGVtcFV0aWxzLnRzXG5mdW5jdGlvbiBjcmVhdGVJZHNHZW5lcmF0b3IoKSB7XG4gIGNvbnN0IGlkc0NvdW50ZXIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICByZXR1cm4gKG5hbWUpID0+IHtcbiAgICBjb25zdCBjb3VudGVyID0gaWRzQ291bnRlci5nZXQobmFtZSk7XG4gICAgaWYgKGNvdW50ZXIpIHtcbiAgICAgIGlkc0NvdW50ZXIuc2V0KG5hbWUsIGNvdW50ZXIgKyAxKTtcbiAgICAgIHJldHVybiBgJHtuYW1lfSR7Y291bnRlcn1gO1xuICAgIH1cbiAgICBpZHNDb3VudGVyLnNldChuYW1lLCAxKTtcbiAgICByZXR1cm4gbmFtZTtcbiAgfTtcbn1cblxuLy8gcGFja2FnZXMvYWctY2hhcnRzLWNvbW11bml0eS9zcmMvY2hhcnQvYXhpcy9heGlzVGlja3MudHNcbnZhciBfQXhpc1RpY2tzID0gY2xhc3MgX0F4aXNUaWNrcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuaWQgPSBjcmVhdGVJZCh0aGlzKTtcbiAgICB0aGlzLmF4aXNHcm91cCA9IG5ldyBHcm91cCh7IG5hbWU6IGAke3RoaXMuaWR9LUF4aXNUaWNrc2AsIHpJbmRleDogMiAvKiBBWElTX1pJTkRFWCAqLyB9KTtcbiAgICB0aGlzLmxhYmVsU2VsZWN0aW9uID0gU2VsZWN0aW9uLnNlbGVjdCh0aGlzLmF4aXNHcm91cCwgVGV4dCwgZmFsc2UpO1xuICAgIHRoaXMuaW50ZXJ2YWwgPSBuZXcgQXhpc0ludGVydmFsKCk7XG4gICAgdGhpcy5sYWJlbCA9IG5ldyBBeGlzTGFiZWwoKTtcbiAgICB0aGlzLnNjYWxlID0gbmV3IExpbmVhclNjYWxlKCk7XG4gICAgdGhpcy5wb3NpdGlvbiA9IFwiYm90dG9tXCI7XG4gICAgdGhpcy50cmFuc2xhdGlvblggPSAwO1xuICAgIHRoaXMudHJhbnNsYXRpb25ZID0gMDtcbiAgICB0aGlzLnBhZGRpbmcgPSAwO1xuICB9XG4gIGF0dGFjaEF4aXMoYXhpc05vZGUpIHtcbiAgICBheGlzTm9kZS5hcHBlbmRDaGlsZCh0aGlzLmF4aXNHcm91cCk7XG4gIH1cbiAgY2FsY3VsYXRlTGF5b3V0KCkge1xuICAgIHRoaXMuc2NhbGUuaW50ZXJ2YWwgPSB0aGlzLmludGVydmFsLnN0ZXA7XG4gICAgY29uc3QgYm94ZXMgPSBbXTtcbiAgICBjb25zdCB0aWNrRGF0YSA9IHRoaXMuZ2VuZXJhdGVUaWNrcygpO1xuICAgIGNvbnN0IHsgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSA9IHRoaXM7XG4gICAgdGhpcy5sYWJlbFNlbGVjdGlvbi51cGRhdGUoXG4gICAgICB0aWNrRGF0YS50aWNrcy5tYXAoKGQpID0+IHRoaXMuY3JlYXRlTGFiZWxEYXR1bShkKSksXG4gICAgICAoZ3JvdXApID0+IGdyb3VwLmFwcGVuZENoaWxkKG5ldyBUZXh0KCkpLFxuICAgICAgKGRhdHVtKSA9PiBkYXR1bS50aWNrSWRcbiAgICApO1xuICAgIHRoaXMubGFiZWxTZWxlY3Rpb24uZWFjaCgobm9kZSwgZGF0dW0pID0+IHtcbiAgICAgIG5vZGUuc2V0UHJvcGVydGllcyhkYXR1bSk7XG4gICAgICBpZiAoZGF0dW0udmlzaWJsZSkge1xuICAgICAgICBib3hlcy5wdXNoKG5vZGUuZ2V0QkJveCgpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmF4aXNHcm91cC5zZXRQcm9wZXJ0aWVzKHsgdHJhbnNsYXRpb25YLCB0cmFuc2xhdGlvblkgfSk7XG4gICAgcmV0dXJuIEJCb3gubWVyZ2UoYm94ZXMpO1xuICB9XG4gIGdldExhYmVsUGFyYW1zKGRhdHVtKSB7XG4gICAgY29uc3QgeyBwYWRkaW5nIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgdHJhbnNsYXRlIH0gPSBkYXR1bTtcbiAgICBzd2l0Y2ggKHRoaXMucG9zaXRpb24pIHtcbiAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgIGNhc2UgXCJib3R0b21cIjpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4OiB0cmFuc2xhdGUsXG4gICAgICAgICAgeTogcGFkZGluZyxcbiAgICAgICAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXG4gICAgICAgICAgdGV4dEJhc2VsaW5lOiBcInRvcFwiXG4gICAgICAgIH07XG4gICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgY2FzZSBcInJpZ2h0XCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogcGFkZGluZyxcbiAgICAgICAgICB5OiB0cmFuc2xhdGUsXG4gICAgICAgICAgdGV4dEFsaWduOiBcInN0YXJ0XCIsXG4gICAgICAgICAgdGV4dEJhc2VsaW5lOiBcIm1pZGRsZVwiXG4gICAgICAgIH07XG4gICAgfVxuICB9XG4gIGluUmFuZ2UoeCwgdG9sZXJhbmNlID0gMWUtMykge1xuICAgIGNvbnN0IFttaW4sIG1heF0gPSBmaW5kTWluTWF4KHRoaXMuc2NhbGUucmFuZ2UpO1xuICAgIHJldHVybiB4ID49IG1pbiAtIHRvbGVyYW5jZSAmJiB4IDw9IG1heCArIHRvbGVyYW5jZTtcbiAgfVxuICBjcmVhdGVMYWJlbERhdHVtKGRhdHVtKSB7XG4gICAgY29uc3QgeyB4LCB5LCB0ZXh0QmFzZWxpbmUsIHRleHRBbGlnbiB9ID0gdGhpcy5nZXRMYWJlbFBhcmFtcyhkYXR1bSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZpc2libGU6IEJvb2xlYW4oZGF0dW0udGlja0xhYmVsKSxcbiAgICAgIHRpY2tJZDogZGF0dW0udGlja0lkLFxuICAgICAgZmlsbDogdGhpcy5sYWJlbC5jb2xvcixcbiAgICAgIGZvbnRGYW1pbHk6IHRoaXMubGFiZWwuZm9udEZhbWlseSxcbiAgICAgIGZvbnRTaXplOiB0aGlzLmxhYmVsLmZvbnRTaXplLFxuICAgICAgZm9udFN0eWxlOiB0aGlzLmxhYmVsLmZvbnRTdHlsZSxcbiAgICAgIGZvbnRXZWlnaHQ6IHRoaXMubGFiZWwuZm9udFdlaWdodCxcbiAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgcm90YXRpb25DZW50ZXJYOiAwLFxuICAgICAgdGV4dDogZGF0dW0udGlja0xhYmVsLFxuICAgICAgdGV4dEFsaWduLFxuICAgICAgdGV4dEJhc2VsaW5lLFxuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9XG4gIGdlbmVyYXRlVGlja3MoKSB7XG4gICAgY29uc3QgeyBtaW5TcGFjaW5nLCBtYXhTcGFjaW5nIH0gPSB0aGlzLmludGVydmFsO1xuICAgIGNvbnN0IGV4dGVudFdpdGhCbGVlZCA9IHJvdW5kKGZpbmRSYW5nZUV4dGVudCh0aGlzLnNjYWxlLnJhbmdlKSwgMik7XG4gICAgY29uc3QgeyBtYXhUaWNrQ291bnQsIG1pblRpY2tDb3VudCwgdGlja0NvdW50IH0gPSBlc3RpbWF0ZVRpY2tDb3VudChcbiAgICAgIGV4dGVudFdpdGhCbGVlZCxcbiAgICAgIG1pblNwYWNpbmcsXG4gICAgICBtYXhTcGFjaW5nLFxuICAgICAgX0F4aXNUaWNrcy5EZWZhdWx0VGlja0NvdW50LFxuICAgICAgX0F4aXNUaWNrcy5EZWZhdWx0TWluU3BhY2luZ1xuICAgICk7XG4gICAgaWYgKHRpY2tDb3VudCkge1xuICAgICAgdGhpcy5zY2FsZS50aWNrQ291bnQgPSB0aWNrQ291bnQ7XG4gICAgICB0aGlzLnNjYWxlLm1pblRpY2tDb3VudCA9IG1pblRpY2tDb3VudDtcbiAgICAgIHRoaXMuc2NhbGUubWF4VGlja0NvdW50ID0gbWF4VGlja0NvdW50O1xuICAgIH1cbiAgICBjb25zdCB0aWNrRGF0YSA9IHRoaXMuZ2V0VGlja3NEYXRhKCk7XG4gICAgaWYgKHRoaXMucG9zaXRpb24gPT09IFwiYm90dG9tXCIgfHwgdGhpcy5wb3NpdGlvbiA9PT0gXCJ0b3BcIikge1xuICAgICAgY29uc3QgbWVhc3VyZXIgPSBDYWNoZWRUZXh0TWVhc3VyZXJQb29sLmdldE1lYXN1cmVyKHsgZm9udDogdGhpcy5sYWJlbCB9KTtcbiAgICAgIGxldCBsYXN0VGlja1Bvc2l0aW9uID0gLUluZmluaXR5O1xuICAgICAgdGlja0RhdGEudGlja3MgPSB0aWNrRGF0YS50aWNrcy5maWx0ZXIoKGRhdGEpID0+IHtcbiAgICAgICAgaWYgKGxhc3RUaWNrUG9zaXRpb24gPCBkYXRhLnRyYW5zbGF0ZSkge1xuICAgICAgICAgIGxhc3RUaWNrUG9zaXRpb24gPSBkYXRhLnRyYW5zbGF0ZSArIG1lYXN1cmVyLnRleHRXaWR0aChkYXRhLnRpY2tMYWJlbCwgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGlja0RhdGE7XG4gIH1cbiAgZ2V0VGlja3NEYXRhKCkge1xuICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgY29uc3QgcmF3VGlja3MgPSB0aGlzLnNjYWxlLnRpY2tzKCk7XG4gICAgY29uc3QgZnJhY3Rpb25EaWdpdHMgPSByYXdUaWNrcy5yZWR1Y2UoKG1heCwgdGljaykgPT4gTWF0aC5tYXgobWF4LCBjb3VudEZyYWN0aW9uRGlnaXRzKHRpY2spKSwgMCk7XG4gICAgY29uc3QgaWRHZW5lcmF0b3IgPSBjcmVhdGVJZHNHZW5lcmF0b3IoKTtcbiAgICBjb25zdCBsYWJlbEZvcm1hdHRlciA9IHRoaXMubGFiZWwuZm9ybWF0ID8gdGhpcy5zY2FsZS50aWNrRm9ybWF0KHsgdGlja3M6IHJhd1RpY2tzLCBzcGVjaWZpZXI6IHRoaXMubGFiZWwuZm9ybWF0IH0pIDogKHgpID0+IGlzTnVtYmVyKHgpID8geC50b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSA6IFN0cmluZyh4KTtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcmF3VGlja3MubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCB0aWNrID0gcmF3VGlja3NbaW5kZXhdO1xuICAgICAgY29uc3QgdHJhbnNsYXRlID0gdGhpcy5zY2FsZS5jb252ZXJ0KHRpY2spO1xuICAgICAgaWYgKCF0aGlzLmluUmFuZ2UodHJhbnNsYXRlKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjb25zdCB0aWNrTGFiZWwgPSB0aGlzLmxhYmVsLmZvcm1hdHRlcj8uKHsgdmFsdWU6IHRpY2ssIGluZGV4LCBmcmFjdGlvbkRpZ2l0cyB9KSA/PyBsYWJlbEZvcm1hdHRlcih0aWNrKTtcbiAgICAgIGNvbnN0IHRpY2tJZCA9IGlkR2VuZXJhdG9yKHRpY2tMYWJlbCk7XG4gICAgICB0aWNrcy5wdXNoKHsgdGljaywgdGlja0lkLCB0aWNrTGFiZWwsIHRyYW5zbGF0ZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcmF3VGlja3MsIGZyYWN0aW9uRGlnaXRzLCB0aWNrcyB9O1xuICB9XG59O1xuX0F4aXNUaWNrcy5EZWZhdWx0VGlja0NvdW50ID0gNTtcbl9BeGlzVGlja3MuRGVmYXVsdE1pblNwYWNpbmcgPSA1MDtcbnZhciBBeGlzVGlja3MgPSBfQXhpc1RpY2tzO1xuXG4vLyBwYWNrYWdlcy9hZy1jaGFydHMtY29tbXVuaXR5L3NyYy9jaGFydC9sZWdlbmREYXR1bS50c1xudmFyIF9fRk9SQ0VfTU9EVUxFX0RFVEVDVElPTiA9IDA7XG5leHBvcnQge1xuICBBR19DSEFSVFNfTE9DQUxFX0VOX1VTLFxuICBBZ0NoYXJ0cyxcbiAgQWdFcnJvckJhclN1cHBvcnRlZFNlcmllc1R5cGVzLFxuICBBZ1Rvb2x0aXBQb3NpdGlvblR5cGUsXG4gIElDT05TX0xFR0FDWSxcbiAgTWFya2VyLFxuICBWRVJTSU9OLFxuICBtb2R1bGVfc3VwcG9ydF9leHBvcnRzIGFzIF9Nb2R1bGVTdXBwb3J0LFxuICBzcGFya2xpbmVzX3NjYWxlX2V4cG9ydHMgYXMgX1NjYWxlLFxuICBpbnRlZ3JhdGVkX2NoYXJ0c19zY2VuZV9leHBvcnRzIGFzIF9TY2VuZSxcbiAgaW50ZWdyYXRlZF9jaGFydHNfdGhlbWVfZXhwb3J0cyBhcyBfVGhlbWUsXG4gIHNwYXJrbGluZXNfdXRpbF9leHBvcnRzIGFzIF9VdGlsLFxuICB0aW1lX2V4cG9ydHMgYXMgdGltZVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ag-charts-community/dist/package/main.esm.mjs\n"));

/***/ }),

/***/ "./node_modules/ag-charts-react/dist/package/index.esm.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/ag-charts-react/dist/package/index.esm.mjs ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AgCharts: function() { return /* binding */ AgCharts; },\n/* harmony export */   AgFinancialCharts: function() { return /* binding */ AgFinancialCharts; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var ag_charts_community__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ag-charts-community */ \"./node_modules/ag-charts-community/dist/package/main.esm.mjs\");\n// packages/ag-charts-react/src/index.ts\n\n\nfunction getOptions(options, containerRef) {\n  return {\n    ...options,\n    container: containerRef.current\n  };\n}\nfunction ChartWithConstructor(ctor, displayName) {\n  const Component = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function AgChartsReact(props, ref) {\n    const { options, style, className } = props;\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const chartRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n      const chart = ctor(getOptions(options, containerRef));\n      chartRef.current = chart;\n      return () => {\n        chart.destroy();\n      };\n    }, []);\n    const unsafeIsInitialMount = chartRef.current === void 0;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n      if (!unsafeIsInitialMount) {\n        void chartRef.current?.update(getOptions(options, containerRef));\n      }\n    }, [options]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => chartRef.current, []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n      return (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"div\", {\n        ref: containerRef,\n        style,\n        className\n      });\n    }, [style, className]);\n  });\n  Component.displayName = displayName;\n  return Component;\n}\nvar AgCharts = /* @__PURE__ */ ChartWithConstructor(\n  (options) => ag_charts_community__WEBPACK_IMPORTED_MODULE_1__.AgCharts.create(options),\n  \"AgCharts\"\n);\nvar AgFinancialCharts = /* @__PURE__ */ ChartWithConstructor(\n  (options) => ag_charts_community__WEBPACK_IMPORTED_MODULE_1__.AgCharts.createFinancialChart(options),\n  \"AgFinancialCharts\"\n);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWctY2hhcnRzLXJlYWN0L2Rpc3QvcGFja2FnZS9pbmRleC5lc20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQVNlO0FBR2M7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaURBQVU7QUFDOUIsWUFBWSw0QkFBNEI7QUFDeEMseUJBQXlCLDZDQUFNO0FBQy9CLHFCQUFxQiw2Q0FBTTtBQUMzQixJQUFJLHNEQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksMERBQW1CO0FBQ3ZCLFdBQVcsOENBQU87QUFDbEIsYUFBYSxvREFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseURBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBVztBQUMxQjtBQUNBO0FBSUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FnLWNoYXJ0cy1yZWFjdC9kaXN0L3BhY2thZ2UvaW5kZXguZXNtLm1qcz82ZjllIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHBhY2thZ2VzL2FnLWNoYXJ0cy1yZWFjdC9zcmMvaW5kZXgudHNcbmltcG9ydCB7XG4gIGNyZWF0ZUVsZW1lbnQsXG4gIGZvcndhcmRSZWYsXG4gIHVzZUVmZmVjdCxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZSxcbiAgdXNlTGF5b3V0RWZmZWN0LFxuICB1c2VNZW1vLFxuICB1c2VSZWZcbn0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQge1xuICBBZ0NoYXJ0cyBhcyBBZ0NoYXJ0c0FQSVxufSBmcm9tIFwiYWctY2hhcnRzLWNvbW11bml0eVwiO1xuZnVuY3Rpb24gZ2V0T3B0aW9ucyhvcHRpb25zLCBjb250YWluZXJSZWYpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5vcHRpb25zLFxuICAgIGNvbnRhaW5lcjogY29udGFpbmVyUmVmLmN1cnJlbnRcbiAgfTtcbn1cbmZ1bmN0aW9uIENoYXJ0V2l0aENvbnN0cnVjdG9yKGN0b3IsIGRpc3BsYXlOYW1lKSB7XG4gIGNvbnN0IENvbXBvbmVudCA9IGZvcndhcmRSZWYoZnVuY3Rpb24gQWdDaGFydHNSZWFjdChwcm9wcywgcmVmKSB7XG4gICAgY29uc3QgeyBvcHRpb25zLCBzdHlsZSwgY2xhc3NOYW1lIH0gPSBwcm9wcztcbiAgICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgY2hhcnRSZWYgPSB1c2VSZWYoKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgY29uc3QgY2hhcnQgPSBjdG9yKGdldE9wdGlvbnMob3B0aW9ucywgY29udGFpbmVyUmVmKSk7XG4gICAgICBjaGFydFJlZi5jdXJyZW50ID0gY2hhcnQ7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjaGFydC5kZXN0cm95KCk7XG4gICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCB1bnNhZmVJc0luaXRpYWxNb3VudCA9IGNoYXJ0UmVmLmN1cnJlbnQgPT09IHZvaWQgMDtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgaWYgKCF1bnNhZmVJc0luaXRpYWxNb3VudCkge1xuICAgICAgICB2b2lkIGNoYXJ0UmVmLmN1cnJlbnQ/LnVwZGF0ZShnZXRPcHRpb25zKG9wdGlvbnMsIGNvbnRhaW5lclJlZikpO1xuICAgICAgfVxuICAgIH0sIFtvcHRpb25zXSk7XG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IGNoYXJ0UmVmLmN1cnJlbnQsIFtdKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgIHJlZjogY29udGFpbmVyUmVmLFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgY2xhc3NOYW1lXG4gICAgICB9KTtcbiAgICB9LCBbc3R5bGUsIGNsYXNzTmFtZV0pO1xuICB9KTtcbiAgQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gIHJldHVybiBDb21wb25lbnQ7XG59XG52YXIgQWdDaGFydHMgPSAvKiBAX19QVVJFX18gKi8gQ2hhcnRXaXRoQ29uc3RydWN0b3IoXG4gIChvcHRpb25zKSA9PiBBZ0NoYXJ0c0FQSS5jcmVhdGUob3B0aW9ucyksXG4gIFwiQWdDaGFydHNcIlxuKTtcbnZhciBBZ0ZpbmFuY2lhbENoYXJ0cyA9IC8qIEBfX1BVUkVfXyAqLyBDaGFydFdpdGhDb25zdHJ1Y3RvcihcbiAgKG9wdGlvbnMpID0+IEFnQ2hhcnRzQVBJLmNyZWF0ZUZpbmFuY2lhbENoYXJ0KG9wdGlvbnMpLFxuICBcIkFnRmluYW5jaWFsQ2hhcnRzXCJcbik7XG5leHBvcnQge1xuICBBZ0NoYXJ0cyxcbiAgQWdGaW5hbmNpYWxDaGFydHNcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ag-charts-react/dist/package/index.esm.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2Fhome%2Flenovo%2FDesktop%2Fgit%2Freactgooglemap-api%2Fsrc%2Fpages%2Findex.js&page=%2F!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);